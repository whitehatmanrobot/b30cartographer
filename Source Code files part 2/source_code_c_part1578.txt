pIpsecPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN;

    //
    // Set the state to DS-DOWNLOADED.
    //

    pIpsecPolicyState->dwCurrentState = POLL_STATE_DS_DOWNLOADED;

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval =  pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    pIpsecPolicyState->RegIncarnationNumber = 0;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    NotifyIpsecPolicyChange();

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
    }
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_UPDATE_CACHE_TO_DS,
        NULL,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
ProcessLocalPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwStatus = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    DWORD dwDSIncarnationNumber = 0;
    DWORD dwError = 0;
    BOOL bChanged = FALSE;
    DWORD dwIncarnationNumber = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    

    dwStatus = GetDirectoryPolicyDN(
                   &pszDirectoryPolicyDN
                   );
    if (!dwStatus) {

        dwStatus = GetDirectoryIncarnationNumber(
                       pszDirectoryPolicyDN,
                       &dwDSIncarnationNumber
                       );
        if (pszDirectoryPolicyDN) {
            FreeSPDStr(pszDirectoryPolicyDN);
        }
        if (!dwStatus) {
            dwStatus = OnPolicyChanged(pIpsecPolicyState);
            return (dwStatus);
        }

    }

    dwError = HasRegistryPolicyChanged(
                  pIpsecPolicyState->pszRegistryPolicyDN,
                  &bChanged
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bChanged) {

        dwError = OnPolicyChanged(pIpsecPolicyState);
        return (dwError);

    }

    if (pIpsecPolicyState->dwCurrentState == POLL_STATE_INITIAL) {
        return (ERROR_SUCCESS);
    }

    dwError = GetRegistryIncarnationNumber(
                  pIpsecPolicyState->pszRegistryPolicyDN,
                  &dwIncarnationNumber
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwIncarnationNumber == pIpsecPolicyState->RegIncarnationNumber) {

        //
        // The policy has not changed at all.
        //

        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_POLLING_NO_CHANGES,
            NULL,
            TRUE,
            TRUE
            );
        return (ERROR_SUCCESS);
    }

    dwError = LoadRegistryPolicy(
                  pIpsecPolicyState->pszRegistryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UpdatePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData,
                  pIpsecPolicyData
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->RegIncarnationNumber = dwIncarnationNumber;

    NotifyIpsecPolicyChange();

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
    }
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_POLLING_APPLIED_CHANGES,
        NULL,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
HasRegistryPolicyChanged(
    LPWSTR pszCurrentPolicyDN,
    PBOOL pbChanged
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR  pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    BOOL bChanged = FALSE;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecLocalPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ActivePolicy",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );
    //
    // Must not bail from here, as there can be no
    // active local policy.
    //

    if (pszIpsecPolicyName && *pszIpsecPolicyName) {

        if (!pszCurrentPolicyDN || !*pszCurrentPolicyDN) {
            bChanged = TRUE;
        }
        else {

            if (!_wcsicmp(pszIpsecPolicyName, pszCurrentPolicyDN)) {
                bChanged = FALSE;
            }
            else {
                bChanged = TRUE;
            }

        }

    }
    else {
        if (!pszCurrentPolicyDN || !*pszCurrentPolicyDN) {
            bChanged = FALSE;
        }
        else {
            bChanged = TRUE;
        }
    }

    *pbChanged = bChanged;
    dwError = ERROR_SUCCESS;

cleanup:

    if (hRegKey) {
        CloseHandle(hRegKey);
    }

    if (pszIpsecPolicyName) {
        FreeSPDStr(pszIpsecPolicyName);
    }

    return (dwError);

error:

    *pbChanged = FALSE;

    goto cleanup;
}


DWORD
GetRegistryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD * pdwIncarnationNumber
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwType = REG_DWORD;
    DWORD dwWhenChanged = 0;
    DWORD dwSize = sizeof(DWORD);


    *pdwIncarnationNumber = 0;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  pszIpsecPolicyDN,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

     *pdwIncarnationNumber = dwWhenChanged;

error:

    if (hRegKey) {
        CloseHandle(hRegKey);
    }

    return(dwError);
}


DWORD
UpdatePolicyInformation(
    PIPSEC_POLICY_DATA pOldIpsecPolicyData,
    PIPSEC_POLICY_DATA pNewIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData = NULL;
    PIPSEC_NFA_DATA * ppOldIpsecNFAData = NULL;
    DWORD dwNumOldNFACount = 0;
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData = NULL;
    PIPSEC_NFA_DATA * ppNewIpsecNFAData = NULL;
    DWORD dwNumNewNFACount = 0;


    pOldIpsecISAKMPData = pOldIpsecPolicyData->pIpsecISAKMPData;
    ppOldIpsecNFAData = pOldIpsecPolicyData->ppIpsecNFAData;
    dwNumOldNFACount = pOldIpsecPolicyData->dwNumNFACount;

    pNewIpsecISAKMPData = pNewIpsecPolicyData->pIpsecISAKMPData;
    ppNewIpsecNFAData = pNewIpsecPolicyData->ppIpsecNFAData;
    dwNumNewNFACount = pNewIpsecPolicyData->dwNumNFACount;

    dwError = PADeleteObseleteISAKMPData(
                  &pOldIpsecISAKMPData,
                  1,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  &pNewIpsecISAKMPData,
                  1
                  );

    dwError = PAUpdateISAKMPData(
                  &pNewIpsecISAKMPData,
                  1,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  &pOldIpsecISAKMPData,
                  1
                  );

    dwError = PADeleteObseleteNFAData(
                  pNewIpsecISAKMPData,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  ppNewIpsecNFAData,
                  dwNumNewNFACount
                  );

    dwError = PAUpdateNFAData(
                  pNewIpsecISAKMPData,
                  ppNewIpsecNFAData,
                  dwNumNewNFACount,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount
                  );

    return (dwError);
}


DWORD
LoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    )
{
    DWORD dwError = 0;

    gbLoadedISAKMPDefaults = TRUE;

    return (dwError);
}


VOID
UnLoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\patx-fil.h ===
typedef struct _txfilterstate {
    GUID gFilterID;
    GUID gPolicyID;
    HANDLE hTxFilter;
    struct _txfilterstate * pNext;
} TXFILTERSTATE, * PTXFILTERSTATE;


DWORD
PAAddQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PAAddTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PACreateTxFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTXFILTERSTATE * ppTxFilterState
    );

DWORD
PACreateTxFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTRANSPORT_FILTER * ppSPDTxFilter
    );

VOID
SetFilterActions(
    PQMPOLICYSTATE pQMPolicyState,
    PFILTER_FLAG pInboundFilterFlag,
    PFILTER_FLAG pOutboundFilterFlag
    );

VOID
PAFreeTxFilter(
    PTRANSPORT_FILTER pSPDTxFilter
    );

DWORD
PADeleteAllTxFilters(
    );

VOID
PAFreeTxFilterStateList(
    PTXFILTERSTATE pTxFilterState
    );

DWORD
PADeleteQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PADeleteTxFilter(
    GUID gFilterID
    );

VOID
PADeleteTxFilterState(
    PTXFILTERSTATE pTxFilterState
    );

PTXFILTERSTATE
FindTxFilterState(
    GUID gFilterID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\paupdate.h ===
DWORD
PADeleteObseleteISAKMPData(
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies
    );

PIPSEC_ISAKMP_DATA
FindISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    );

DWORD
PADeleteObseleteNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount
    );

PIPSEC_NFA_DATA
FindNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PAUpdateISAKMPData(
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies
    );

DWORD
PAUpdateNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount
    );

DWORD
PAProcessISAKMPUpdate(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData
    );

BOOL
EqualISAKMPData(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData
    );

BOOL
EqualCryptoBundle(
    PCRYPTO_BUNDLE pOldBundle,
    PCRYPTO_BUNDLE pNewBundle
    );

DWORD
PAProcessNFAUpdate(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PAUpdateAuthMethod(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedMMFilters
    );

BOOL
EqualAuthMethodData(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

BOOL
EqualAuthBundle(
    PIPSEC_AUTH_METHOD pOldAuthMethod,
    PIPSEC_AUTH_METHOD pNewAuthMethod
    );

DWORD
PAProcessQMNFAUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PADeleteQMInfoForNFA(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    );

DWORD
PAAddQMInfoForNFA(
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PAProcessNegPolUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedQMFilters
    );

BOOL
EqualNegPolData(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    );

BOOL
EqualSecurityMethod(
    PIPSEC_SECURITY_METHOD pOldBundle,
    PIPSEC_SECURITY_METHOD pNewBundle
    );

DWORD
PAUpdateMMFilters(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

BOOL
EqualFilterKeysInNegPols(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    );

BOOL
EqualFilterKeysInNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PAProcessMMFilterDataForNFAs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PADeleteObseleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    );

PIPSEC_FILTER_SPEC
FindFilterSpec(
    PIPSEC_FILTER_SPEC pFilterSpec,
    PIPSEC_FILTER_SPEC * ppFilterSpecs,
    DWORD dwNumFilterSpecs
    );

DWORD
PAUpdateMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    );

DWORD
PAAddMMFilterSpec(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec
    );

BOOL
EqualFilterSpecs(
    PIPSEC_FILTER_SPEC pOldFilterSpec,
    PIPSEC_FILTER_SPEC pNewFilterSpec
    );

DWORD
PAUpdateQMFilters(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PAAddQMFilterSpecs(
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PADeleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    );

DWORD
PAProcessQMFilterDataForNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PADeleteObseleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    );

DWORD
PAUpdateQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    );

DWORD
PADeleteQMFilter(
    PIPSEC_NFA_DATA pIpsecNFAData,
    GUID FilterSpecGUID
    );

DWORD
PAAddQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    );

DWORD
PAAddTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    );

DWORD
PAAddTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    );

BOOL
AllowsSoft(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods
    );

DWORD
PAUpdateQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    );

DWORD
PAUpdateTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    );

DWORD
PAUpdateTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\patn-fil.c ===
#include "precomp.h"


DWORD
PAAddTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PTNFILTERSTATE pTnFilterState = NULL;
    PTUNNEL_FILTER pSPDTnFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pQMPolicyState = FindQMPolicyState(
                         pIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    if (!IsClearOnly(pQMPolicyState->gNegPolAction) &&
        !IsBlocking(pQMPolicyState->gNegPolAction) &&
        !(pQMPolicyState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    

    for (i = 0; i < dwNumFilterSpecs; i++) {

        dwError = PACreateTnFilterState(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pTnFilterState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateTnFilter(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      pQMPolicyState,
                      &pSPDTnFilter
                      );
        if (dwError) {

            pTnFilterState->hTnFilter = NULL;

            pTnFilterState->pNext = gpTnFilterState;
            gpTnFilterState = pTnFilterState;

            continue;

        }

        dwError = AddTunnelFilter(
                      pServerName,
                      dwPersist,
                      pSPDTnFilter,
                      &(pTnFilterState->hTnFilter)
                      );

        pTnFilterState->pNext = gpTnFilterState;
        gpTnFilterState = pTnFilterState;

        PAFreeTnFilter(pSPDTnFilter);

    }

    return (dwError);
}


DWORD
PACreateTnFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTNFILTERSTATE * ppTnFilterState
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(TNFILTERSTATE),
                  &pTnFilterState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pTnFilterState->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    memcpy(
        &(pTnFilterState->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    pTnFilterState->hTnFilter = NULL;
    pTnFilterState->pNext = NULL;

    *ppTnFilterState = pTnFilterState;

    return (dwError);

error:

    *ppTnFilterState = NULL;

    return (dwError);
}


DWORD
PACreateTnFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTUNNEL_FILTER * ppSPDTnFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pSPDTnFilter = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(TUNNEL_FILTER),
                  &pSPDTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDTnFilter->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    if (pFilterSpec->pszDescription && *(pFilterSpec->pszDescription)) {

        dwError = AllocateSPDString(
                      pFilterSpec->pszDescription,
                      &(pSPDTnFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwTnFilterCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pSPDTnFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PASetInterfaceType(
        pIpsecNFAData->dwInterfaceType,
        &(pSPDTnFilter->InterfaceType)
        );

    pSPDTnFilter->bCreateMirror = FALSE;

    pSPDTnFilter->dwFlags = 0;

    PASetAddress(
        pFilterSpec->Filter.SrcMask,
        pFilterSpec->Filter.SrcAddr,
        &(pSPDTnFilter->SrcAddr)
        );

    PASetAddress(
        pFilterSpec->Filter.DestMask,
        pFilterSpec->Filter.DestAddr, 
        &(pSPDTnFilter->DesAddr)
        );

    PASetAddress(
        SUBNET_MASK_ANY,
        SUBNET_ADDRESS_ANY,
        &(pSPDTnFilter->SrcTunnelAddr)
        );

    PASetTunnelAddress(
        ((ULONG) pIpsecNFAData->dwTunnelIpAddr),
        &(pSPDTnFilter->DesTunnelAddr)
        );

    pSPDTnFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pSPDTnFilter->Protocol.dwProtocol = pFilterSpec->Filter.Protocol;

    pSPDTnFilter->SrcPort.PortType = PORT_UNIQUE;
    pSPDTnFilter->SrcPort.wPort = pFilterSpec->Filter.SrcPort;

    pSPDTnFilter->DesPort.PortType = PORT_UNIQUE;
    pSPDTnFilter->DesPort.wPort = pFilterSpec->Filter.DestPort;

    SetFilterActions(
        pQMPolicyState,
        &(pSPDTnFilter->InboundFilterFlag),
        &(pSPDTnFilter->OutboundFilterFlag)
        );

    pSPDTnFilter->dwDirection = 0;

    pSPDTnFilter->dwWeight = 0;

    memcpy(
        &(pSPDTnFilter->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    *ppSPDTnFilter = pSPDTnFilter;

    return (dwError);

error:

    if (pSPDTnFilter) {
        PAFreeTnFilter(
            pSPDTnFilter
            );
    }

    *ppSPDTnFilter = NULL;

    return (dwError);
}


VOID
PAFreeTnFilter(
    PTUNNEL_FILTER pSPDTnFilter
    )
{
    if (pSPDTnFilter) {

        if (pSPDTnFilter->pszFilterName) {
            FreeSPDString(pSPDTnFilter->pszFilterName);
        }

        FreeSPDMemory(pSPDTnFilter);

    }

    return;
}


DWORD
PADeleteAllTnFilters(
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;
    PTNFILTERSTATE pTemp = NULL;
    PTNFILTERSTATE pLeftTnFilterState = NULL;


    pTnFilterState = gpTnFilterState;

    while (pTnFilterState) {

        if (pTnFilterState->hTnFilter) {

            dwError = DeleteTunnelFilter(
                          pTnFilterState->hTnFilter
                          );
            if (!dwError) {
                pTemp = pTnFilterState;
                pTnFilterState = pTnFilterState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pTemp = pTnFilterState;
                pTnFilterState = pTnFilterState->pNext;

                pTemp->pNext = pLeftTnFilterState;
                pLeftTnFilterState = pTemp;
            }

        }
        else {

            pTemp = pTnFilterState;
            pTnFilterState = pTnFilterState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpTnFilterState = pLeftTnFilterState;
    
    return (dwError);
}


VOID
PAFreeTnFilterStateList(
    PTNFILTERSTATE pTnFilterState
    )
{
    PTNFILTERSTATE pTemp = NULL;


    while (pTnFilterState) {

        pTemp = pTnFilterState;
        pTnFilterState = pTnFilterState->pNext;
        FreeSPDMemory(pTemp);

    }
}


DWORD
PADeleteTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    
    for (i = 0; i < dwNumFilterSpecs; i++) {

        pFilterSpec = *(ppFilterSpecs + i);

        dwError = PADeleteTnFilter(
                      pFilterSpec->FilterSpecGUID
                      );

    }

    return (dwError);
}


DWORD
PADeleteTnFilter(
    GUID gFilterID
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;


    pTnFilterState = FindTnFilterState(
                         gFilterID
                         );
    if (!pTnFilterState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pTnFilterState->hTnFilter) {

        dwError = DeleteTunnelFilter(
                      pTnFilterState->hTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteTnFilterState(pTnFilterState);

error:

    return (dwError);
}


VOID
PADeleteTnFilterState(
    PTNFILTERSTATE pTnFilterState
    )
{
    PTNFILTERSTATE * ppTemp = NULL;


    ppTemp = &gpTnFilterState;

    while (*ppTemp) {

        if (*ppTemp == pTnFilterState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pTnFilterState->pNext;
    }

    FreeSPDMemory(pTnFilterState);

    return;
}


PTNFILTERSTATE
FindTnFilterState(
    GUID gFilterID
    )
{
    PTNFILTERSTATE pTnFilterState = NULL;


    pTnFilterState = gpTnFilterState;

    while (pTnFilterState) {

        if (!memcmp(&(pTnFilterState->gFilterID), &gFilterID, sizeof(GUID))) {
            return (pTnFilterState);
        }

        pTnFilterState = pTnFilterState->pNext;

    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\patx-fil.c ===
#include "precomp.h"


DWORD
PAAddQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (!(pIpsecNFAData->dwTunnelFlags)) {

            dwError = PAAddTxFilterSpecs(
                          pIpsecNFAData
                          );

        }
        else {

            dwError = PAAddTnFilterSpecs(
                          pIpsecNFAData
                          );

        }

    }

    return (dwError);
}


DWORD
PAAddTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PTXFILTERSTATE pTxFilterState = NULL;
    PTRANSPORT_FILTER pSPDTxFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pQMPolicyState = FindQMPolicyState(
                         pIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    if (!IsClearOnly(pQMPolicyState->gNegPolAction) &&
        !IsBlocking(pQMPolicyState->gNegPolAction) &&
        !(pQMPolicyState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    

    for (i = 0; i < dwNumFilterSpecs; i++) {

        dwError = PACreateTxFilterState(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pTxFilterState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateTxFilter(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      pQMPolicyState,
                      &pSPDTxFilter
                      );
        if (dwError) {

            pTxFilterState->hTxFilter = NULL;

            pTxFilterState->pNext = gpTxFilterState;
            gpTxFilterState = pTxFilterState;

            continue;

        }

        dwError = AddTransportFilter(
                      pServerName,
                      dwPersist,
                      pSPDTxFilter,
                      &(pTxFilterState->hTxFilter)
                      );

        pTxFilterState->pNext = gpTxFilterState;
        gpTxFilterState = pTxFilterState;

        PAFreeTxFilter(pSPDTxFilter);

    }

    return (dwError);
}


DWORD
PACreateTxFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTXFILTERSTATE * ppTxFilterState
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(TXFILTERSTATE),
                  &pTxFilterState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pTxFilterState->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    memcpy(
        &(pTxFilterState->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    pTxFilterState->hTxFilter = NULL;
    pTxFilterState->pNext = NULL;

    *ppTxFilterState = pTxFilterState;

    return (dwError);

error:

    *ppTxFilterState = NULL;

    return (dwError);
}


DWORD
PACreateTxFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTRANSPORT_FILTER * ppSPDTxFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pSPDTxFilter = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(TRANSPORT_FILTER),
                  &pSPDTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDTxFilter->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    if (pFilterSpec->pszDescription && *(pFilterSpec->pszDescription)) {

        dwError = AllocateSPDString(
                      pFilterSpec->pszDescription,
                      &(pSPDTxFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwTxFilterCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pSPDTxFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PASetInterfaceType(
        pIpsecNFAData->dwInterfaceType,
        &(pSPDTxFilter->InterfaceType)
        );

    pSPDTxFilter->bCreateMirror = (BOOL) pFilterSpec->dwMirrorFlag;

    pSPDTxFilter->dwFlags = 0;

    PASetAddress(
        pFilterSpec->Filter.SrcMask,
        pFilterSpec->Filter.SrcAddr,
        &(pSPDTxFilter->SrcAddr)
        );

    PASetAddress(
        pFilterSpec->Filter.DestMask,
        pFilterSpec->Filter.DestAddr, 
        &(pSPDTxFilter->DesAddr)
        );

    pSPDTxFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pSPDTxFilter->Protocol.dwProtocol = pFilterSpec->Filter.Protocol;

    pSPDTxFilter->SrcPort.PortType = PORT_UNIQUE;
    pSPDTxFilter->SrcPort.wPort = pFilterSpec->Filter.SrcPort;

    pSPDTxFilter->DesPort.PortType = PORT_UNIQUE;
    pSPDTxFilter->DesPort.wPort = pFilterSpec->Filter.DestPort;

    SetFilterActions(
        pQMPolicyState,
        &(pSPDTxFilter->InboundFilterFlag),
        &(pSPDTxFilter->OutboundFilterFlag)
        );

    pSPDTxFilter->dwDirection = 0;

    pSPDTxFilter->dwWeight = 0;

    memcpy(
        &(pSPDTxFilter->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    *ppSPDTxFilter = pSPDTxFilter;

    return (dwError);

error:

    if (pSPDTxFilter) {
        PAFreeTxFilter(
            pSPDTxFilter
            );
    }

    *ppSPDTxFilter = NULL;

    return (dwError);
}


VOID
SetFilterActions(
    PQMPOLICYSTATE pQMPolicyState,
    PFILTER_FLAG pInboundFilterFlag,
    PFILTER_FLAG pOutboundFilterFlag
    )
{
    *pInboundFilterFlag = NEGOTIATE_SECURITY;
    *pOutboundFilterFlag = NEGOTIATE_SECURITY;

    if (IsBlocking(pQMPolicyState->gNegPolAction)) {
        *pInboundFilterFlag = BLOCKING;
        *pOutboundFilterFlag = BLOCKING;
    }
    else if (IsClearOnly(pQMPolicyState->gNegPolAction)) {
        *pInboundFilterFlag = PASS_THRU;
        *pOutboundFilterFlag = PASS_THRU;
    }
    else if (IsInboundPassThru(pQMPolicyState->gNegPolAction)) {
        *pInboundFilterFlag = PASS_THRU;
    }

    if (pQMPolicyState->bAllowsSoft  && gbBackwardSoftSA) {
        *pInboundFilterFlag = PASS_THRU;
    }
}

    
VOID
PAFreeTxFilter(
    PTRANSPORT_FILTER pSPDTxFilter
    )
{
    if (pSPDTxFilter) {

        if (pSPDTxFilter->pszFilterName) {
            FreeSPDString(pSPDTxFilter->pszFilterName);
        }

        FreeSPDMemory(pSPDTxFilter);

    }

    return;
}


DWORD
PADeleteAllTxFilters(
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;
    PTXFILTERSTATE pTemp = NULL;
    PTXFILTERSTATE pLeftTxFilterState = NULL;


    pTxFilterState = gpTxFilterState;

    while (pTxFilterState) {

        if (pTxFilterState->hTxFilter) {

            dwError = DeleteTransportFilter(
                          pTxFilterState->hTxFilter
                          );
            if (!dwError) {
                pTemp = pTxFilterState;
                pTxFilterState = pTxFilterState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pTemp = pTxFilterState;
                pTxFilterState = pTxFilterState->pNext;

                pTemp->pNext = pLeftTxFilterState;
                pLeftTxFilterState = pTemp;
            }

        }
        else {

            pTemp = pTxFilterState;
            pTxFilterState = pTxFilterState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpTxFilterState = pLeftTxFilterState;
    
    return (dwError);
}


VOID
PAFreeTxFilterStateList(
    PTXFILTERSTATE pTxFilterState
    )
{
    PTXFILTERSTATE pTemp = NULL;


    while (pTxFilterState) {

        pTemp = pTxFilterState;
        pTxFilterState = pTxFilterState->pNext;
        FreeSPDMemory(pTemp);

    }
}


DWORD
PADeleteQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (!(pIpsecNFAData->dwTunnelFlags)) {

            dwError = PADeleteTxFilterSpecs(
                          pIpsecNFAData
                          );

        }
        else {

            dwError = PADeleteTnFilterSpecs(
                          pIpsecNFAData
                          );

        }

    }

    return (dwError);
}


DWORD
PADeleteTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    
    for (i = 0; i < dwNumFilterSpecs; i++) {

        pFilterSpec = *(ppFilterSpecs + i);

        dwError = PADeleteTxFilter(
                      pFilterSpec->FilterSpecGUID
                      );

    }

    return (dwError);
}


DWORD
PADeleteTxFilter(
    GUID gFilterID
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;


    pTxFilterState = FindTxFilterState(
                         gFilterID
                         );
    if (!pTxFilterState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pTxFilterState->hTxFilter) {

        dwError = DeleteTransportFilter(
                      pTxFilterState->hTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteTxFilterState(pTxFilterState);

error:

    return (dwError);
}


VOID
PADeleteTxFilterState(
    PTXFILTERSTATE pTxFilterState
    )
{
    PTXFILTERSTATE * ppTemp = NULL;


    ppTemp = &gpTxFilterState;

    while (*ppTemp) {

        if (*ppTemp == pTxFilterState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pTxFilterState->pNext;
    }

    FreeSPDMemory(pTxFilterState);

    return;
}


PTXFILTERSTATE
FindTxFilterState(
    GUID gFilterID
    )
{
    PTXFILTERSTATE pTxFilterState = NULL;


    pTxFilterState = gpTxFilterState;

    while (pTxFilterState) {

        if (!memcmp(&(pTxFilterState->gFilterID), &gFilterID, sizeof(GUID))) {
            return (pTxFilterState);
        }

        pTxFilterState = pTxFilterState->pNext;

    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\port.h ===
DWORD
VerifyPortsForProtocol(
    PORT        Port,
    PROTOCOL    Protocol
    );

BOOL
EqualPorts(
    IN PORT     OldPort,
    IN PORT     NewPort
    );

VOID
CopyPorts(
    IN  PORT    InPort,
    OUT PPORT   pOutPort
    );

BOOL
MatchPorts(
    PORT PortToMatch,
    PORT PortTemplate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\paupdate.c ===
#include "precomp.h"


DWORD
PADeleteObseleteISAKMPData(
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA pFoundISAKMPData = NULL;


    for (i = 0; i < dwNumOldPolicies; i++) {

        pOldIpsecISAKMPData = *(ppOldIpsecISAKMPData + i);

        pFoundISAKMPData = FindISAKMPData(
                               pOldIpsecISAKMPData,
                               ppNewIpsecISAKMPData,
                               dwNumNewPolicies
                               );

        if (!pFoundISAKMPData) {

            dwError = PADeleteMMFilters(
                          pOldIpsecISAKMPData,
                          ppOldIpsecNFAData,
                          dwNumOldNFACount
                          );

            dwError = PADeleteMMPolicy(
                          pOldIpsecISAKMPData->ISAKMPIdentifier
                          );

        }

    }

    return (dwError);
}


PIPSEC_ISAKMP_DATA
FindISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    )
{
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pTemp = NULL;


    for (i = 0; i < dwNumPolicies; i++) {

        pTemp = *(ppIpsecISAKMPData + i);

        if (!memcmp(
                &(pIpsecISAKMPData->ISAKMPIdentifier),
                &(pTemp->ISAKMPIdentifier),
                sizeof(GUID))) {
            return (pTemp);
        }

    }

    return (NULL);
}


DWORD
PADeleteObseleteNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pOldIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pFoundNFAData = NULL;


    for (i = 0; i < dwNumOldNFACount; i++) {

        pOldIpsecNFAData = *(ppOldIpsecNFAData + i);

        pFoundNFAData = FindNFAData(
                            pOldIpsecNFAData,
                            ppNewIpsecNFAData,
                            dwNumNewNFACount
                            );

        if (!pFoundNFAData) {

            dwError = PADeleteMMFilterSpecs(
                          pNewIpsecISAKMPData,
                          pOldIpsecNFAData
                          );

            dwError = PADeleteMMAuthMethod(
                          pOldIpsecNFAData->NFAIdentifier
                          );

            dwError = PADeleteQMInfoForNFA(
                          pOldIpsecNFAData
                          );

        }

    }

    return (dwError);
}


PIPSEC_NFA_DATA
FindNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD i = 0;
    PIPSEC_NFA_DATA pTemp = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pTemp = *(ppIpsecNFAData + i);

        if (!memcmp(
                &(pIpsecNFAData->NFAIdentifier),
                &(pTemp->NFAIdentifier),
                sizeof(GUID))) {
            return (pTemp);
        }

    }

    return (NULL);
}


DWORD
PAUpdateISAKMPData(
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA pFoundISAKMPData = NULL;


    for (i = 0; i < dwNumNewPolicies; i++) {

        pNewIpsecISAKMPData = *(ppNewIpsecISAKMPData + i);

        pFoundISAKMPData = FindISAKMPData(
                               pNewIpsecISAKMPData,
                               ppOldIpsecISAKMPData,
                               dwNumOldPolicies
                               );

        if (!pFoundISAKMPData) {
            dwError = PAAddMMPolicies(
                          &pNewIpsecISAKMPData,
                          1
                          );

            dwError = PAAddMMFilters(
                          pNewIpsecISAKMPData,
                          ppOldIpsecNFAData,
                          dwNumOldNFACount
                          );
        }
        else {

            dwError = PAProcessISAKMPUpdate(
                          pFoundISAKMPData,
                          ppOldIpsecNFAData,
                          dwNumOldNFACount,
                          pNewIpsecISAKMPData
                          );

        }

    }

    return (dwError);
}


DWORD
PAUpdateNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pNewIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pFoundNFAData = NULL;


    for (i = 0; i < dwNumNewNFACount; i++) {

        pNewIpsecNFAData = *(ppNewIpsecNFAData + i);

        pFoundNFAData = FindNFAData(
                            pNewIpsecNFAData,
                            ppOldIpsecNFAData,
                            dwNumOldNFACount
                            );

        if (!pFoundNFAData) {

            dwError = PAAddMMAuthMethods(
                          &pNewIpsecNFAData,
                          1
                          );

            dwError = PAAddMMFilterSpecs(
                          pNewIpsecISAKMPData,
                          pNewIpsecNFAData
                          );

            dwError = PAAddQMInfoForNFA(
                          pNewIpsecNFAData
                          );

        }
        else {

            dwError = PAProcessNFAUpdate(
                          pNewIpsecISAKMPData,
                          pFoundNFAData,
                          pNewIpsecNFAData
                          );

        }

    }

    return (dwError);
}


DWORD
PAProcessISAKMPUpdate(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    BOOL bEqual = FALSE;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;
    LPWSTR pServerName = NULL;


    pMMPolicyState = FindMMPolicyState(
                         pOldIpsecISAKMPData->ISAKMPIdentifier
                         );
    if (!pMMPolicyState) {
        dwError = PAAddMMPolicies(
                      &pNewIpsecISAKMPData,
                      1
                      );
        dwError = PAAddMMFilters(
                      pNewIpsecISAKMPData,
                      ppOldIpsecNFAData,
                      dwNumOldNFACount
                      );
        return (dwError);
    }

    if (!(pMMPolicyState->bInSPD)) {
        PADeleteMMPolicyState(pMMPolicyState);
        dwError = PAAddMMPolicies(
                      &pNewIpsecISAKMPData,
                      1
                      );
        dwError = PAAddMMFilters(
                      pNewIpsecISAKMPData,
                      ppOldIpsecNFAData,
                      dwNumOldNFACount
                      );
        return (dwError);
    }

    bEqual = EqualISAKMPData(
                 pOldIpsecISAKMPData,
                 pNewIpsecISAKMPData
                 );
    if (bEqual) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PACreateMMPolicy(
                  pNewIpsecISAKMPData,
                  pMMPolicyState,
                  &pSPDMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SetMMPolicy(
                  pServerName,
                  pMMPolicyState->pszPolicyName,
                  pSPDMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pSPDMMPolicy) {
        PAFreeMMPolicy(pSPDMMPolicy);
    }

    return (dwError);
}


BOOL
EqualISAKMPData(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldCnt = 0;
    PCRYPTO_BUNDLE pOldSecurityMethods = NULL;
    DWORD dwNewCnt = 0;
    PCRYPTO_BUNDLE pNewSecurityMethods = NULL;
    DWORD i = 0;
    PCRYPTO_BUNDLE pNewTemp = NULL;
    PCRYPTO_BUNDLE pOldTemp = NULL;


    //
    // At this point, pszPolicyName and ISAKMPIdentifier are same and
    // dwWhenChanged is different.
    //

    dwOldCnt = pOldIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    pOldSecurityMethods = pOldIpsecISAKMPData->pSecurityMethods;

    dwNewCnt = pNewIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    pNewSecurityMethods = pNewIpsecISAKMPData->pSecurityMethods;

    //
    // At this point, dwOldCnt >= 1 and pOldSecurityMethods != NULL.
    //

    if (!dwNewCnt || !pNewSecurityMethods) {
        return (FALSE);
    }

    if (dwOldCnt != dwNewCnt) {
        return (FALSE);
    }

    pNewTemp = pNewSecurityMethods;
    pOldTemp = pOldSecurityMethods;

    for (i = 0; i < dwNewCnt; i++) {

        bEqual = FALSE;

        bEqual = EqualCryptoBundle(
                     pOldTemp,
                     pNewTemp
                     );
        if (!bEqual) {
            break;
        }

        pOldTemp++;

        pNewTemp++;

    }

    return (bEqual);
}


BOOL
EqualCryptoBundle(
    PCRYPTO_BUNDLE pOldBundle,
    PCRYPTO_BUNDLE pNewBundle
    )
{
    if (memcmp(
            &(pOldBundle->Lifetime),
            &(pNewBundle->Lifetime),
            sizeof(OAKLEY_LIFETIME))) {
       return (FALSE);
    }

    if (pOldBundle->QuickModeLimit != pNewBundle->QuickModeLimit) {
        return (FALSE);
    }

    if (pOldBundle->OakleyGroup != pNewBundle->OakleyGroup) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldBundle->EncryptionAlgorithm),
            &(pNewBundle->EncryptionAlgorithm),
            sizeof(OAKLEY_ALGORITHM))) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldBundle->HashAlgorithm),
            &(pNewBundle->HashAlgorithm),
            sizeof(OAKLEY_ALGORITHM))) {
        return (FALSE);
    }

    return (TRUE);
}

    
DWORD
PAProcessNFAUpdate(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;
    BOOL bAddedMMFilters = FALSE;


    dwError = PAUpdateAuthMethod(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  pNewIpsecNFAData,
                  &bAddedMMFilters
                  );

    if (!bAddedMMFilters) {
        dwError = PAUpdateMMFilters(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData,
                      pNewIpsecNFAData
                      );
    }

    dwError = PAProcessQMNFAUpdate(
                  pOldIpsecNFAData,
                  pNewIpsecNFAData
                  );

    return (dwError);
}


DWORD
PAUpdateAuthMethod(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedMMFilters
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    BOOL bEqual = FALSE;
    PMM_AUTH_METHODS pSPDMMAuthMethods = NULL;
    LPWSTR pServerName = NULL;


    *pbAddedMMFilters = FALSE;

    pMMAuthState = FindMMAuthState(
                       pOldIpsecNFAData->NFAIdentifier
                       );
    if (!pMMAuthState) {
        dwError = PAAddMMAuthMethods(
                      &pNewIpsecNFAData,
                      1
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData
                      );
        *pbAddedMMFilters = TRUE;
        return (dwError);
    }

    if (!(pMMAuthState->bInSPD)) {
        PADeleteMMAuthState(pMMAuthState);
        dwError = PAAddMMAuthMethods(
                      &pNewIpsecNFAData,
                      1
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData
                      );
        *pbAddedMMFilters = TRUE;
        return (dwError);
    }

    bEqual = EqualAuthMethodData(
                 pOldIpsecNFAData,
                 pNewIpsecNFAData
                 );
    if (bEqual) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PACreateMMAuthMethods(
                  pNewIpsecNFAData,
                  &pSPDMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SetMMAuthMethods(
                  pServerName,
                  pMMAuthState->gMMAuthID,
                  pSPDMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pSPDMMAuthMethods) {
        PAFreeMMAuthMethods(pSPDMMAuthMethods);
    }

    return (dwError);
}


BOOL
EqualAuthMethodData(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldCnt = 0;
    PIPSEC_AUTH_METHOD * ppOldAuthMethods = NULL;
    DWORD dwNewCnt = 0;
    PIPSEC_AUTH_METHOD * ppNewAuthMethods = NULL;
    DWORD i = 0;
    PIPSEC_AUTH_METHOD pNewAuthMethod = NULL;
    PIPSEC_AUTH_METHOD pOldAuthMethod = NULL;


    //
    // At this point, NFAIdentifier is same and
    // dwWhenChanged is different.
    //

    dwOldCnt = pOldIpsecNFAData->dwAuthMethodCount;
    ppOldAuthMethods = pOldIpsecNFAData->ppAuthMethods;

    dwNewCnt = pNewIpsecNFAData->dwAuthMethodCount;
    ppNewAuthMethods = pNewIpsecNFAData->ppAuthMethods;

    //
    // At this point, dwOldCnt >= 1 and ppOldAuthMethods != NULL.
    //

    if (!dwNewCnt || !ppNewAuthMethods) {
        return (FALSE);
    }

    if (dwOldCnt != dwNewCnt) {
        return (FALSE);
    }


    for (i = 0; i < dwNewCnt; i++) {

        pNewAuthMethod = *(ppNewAuthMethods + i);

        pOldAuthMethod = *(ppOldAuthMethods + i);

        bEqual = FALSE;

        bEqual = EqualAuthBundle(
                     pOldAuthMethod,
                     pNewAuthMethod
                     );

        if (!bEqual) {
            break;
        }

    }

    return (bEqual);
}


BOOL
EqualAuthBundle(
    PIPSEC_AUTH_METHOD pOldAuthMethod,
    PIPSEC_AUTH_METHOD pNewAuthMethod
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldAuthLen = 0;
    DWORD dwNewAuthLen = 0;


    if (pOldAuthMethod->dwAuthType != pNewAuthMethod->dwAuthType) {
        return (FALSE);
    }

    switch (pNewAuthMethod->dwAuthType) {

    case OAK_SSPI:

        bEqual = TRUE;
        break;

    default:

        //
        // Since auth version 2 also has auth version 1 fields filled in it, so
        // there is no need to explicitly compare exclusive auth version 2 fields.
        //

        dwOldAuthLen = pOldAuthMethod->dwAuthLen;
        dwNewAuthLen = pNewAuthMethod->dwAuthLen;

        if (!dwNewAuthLen || !(pNewAuthMethod->pszAuthMethod)) {
            bEqual = FALSE;
            break;
        }

        if (dwOldAuthLen != dwNewAuthLen) {
            bEqual = FALSE;
            break;
        }

        if (!memcmp(
                (LPBYTE) pNewAuthMethod->pszAuthMethod,
                (LPBYTE) pOldAuthMethod->pszAuthMethod,
                (dwNewAuthLen*sizeof(WCHAR)))) {
            bEqual = TRUE;
            break;
        }

        break;

    }
                
    return (bEqual);
}


DWORD
PAProcessQMNFAUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    BOOL bAddedQMFilters = FALSE;


    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolIdentifier),
            &(pNewIpsecNegPolData->NegPolIdentifier),
            sizeof(GUID))) {

        dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData);

        dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);

    }
    else {

        dwError = PAProcessNegPolUpdate(
                      pOldIpsecNFAData,
                      pNewIpsecNFAData,
                      &bAddedQMFilters
                      );

        if (!bAddedQMFilters) {
            dwError = PAUpdateQMFilters(
                          pOldIpsecNFAData,
                          pNewIpsecNFAData
                          );
        }

    }

    return (dwError);
}


DWORD
PADeleteQMInfoForNFA(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;


    dwError = PADeleteQMFilterSpecs(
                  pOldIpsecNFAData
                  );

    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;

    dwError = PADeleteQMPolicy(
                  pOldIpsecNegPolData->NegPolIdentifier
                  );

    return (dwError);
}


DWORD
PAAddQMInfoForNFA(
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;


    dwError = PAAddQMPolicies(
                  &pNewIpsecNFAData,
                  1
                  );

    dwError = PAAddQMFilterSpecs(
                  pNewIpsecNFAData
                  );

    return (dwError);
}


DWORD
PAProcessNegPolUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedQMFilters
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    BOOL bEqual = FALSE;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    LPWSTR pServerName = NULL;


    *pbAddedQMFilters = FALSE;

    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    pQMPolicyState = FindQMPolicyState(
                         pOldIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);
        *pbAddedQMFilters = TRUE;
        return (dwError);
    }

    if (IsClearOnly(pQMPolicyState->gNegPolAction)) {
        if (IsClearOnly(pNewIpsecNegPolData->NegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (IsBlocking(pQMPolicyState->gNegPolAction)) {
        if (IsBlocking(pNewIpsecNegPolData->NegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (IsClearOnly(pNewIpsecNegPolData->NegPolAction)) {
        if (IsClearOnly(pQMPolicyState->gNegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (IsBlocking(pNewIpsecNegPolData->NegPolAction)) {
        if (IsBlocking(pQMPolicyState->gNegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (!(pQMPolicyState->bInSPD)) {
        PADeleteQMPolicy(pQMPolicyState->gPolicyID);
        dwError = PAAddQMInfoForNFA(pNewIpsecNFAData);
        *pbAddedQMFilters = TRUE;
        return (dwError);
    }

    bEqual = EqualNegPolData(
                 pOldIpsecNegPolData,
                 pNewIpsecNegPolData
                 );
    if (bEqual) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    memcpy(
        &(pQMPolicyState->gNegPolType),
        &(pNewIpsecNegPolData->NegPolType),
        sizeof(GUID)
        );

    memcpy(
        &(pQMPolicyState->gNegPolAction),
        &(pNewIpsecNegPolData->NegPolAction),
        sizeof(GUID)
        );

    dwError = PACreateQMPolicy(
                  pNewIpsecNFAData,
                  pQMPolicyState,
                  &pSPDQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SetQMPolicy(
                  pServerName,
                  pQMPolicyState->pszPolicyName,
                  pSPDQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pSPDQMPolicy) {
        PAFreeQMPolicy(pSPDQMPolicy);
    }

    return (dwError);
}


BOOL
EqualNegPolData(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldCnt = 0;
    PIPSEC_SECURITY_METHOD pOldSecurityMethods = NULL;
    DWORD dwNewCnt = 0;
    PIPSEC_SECURITY_METHOD pNewSecurityMethods = NULL;
    DWORD i = 0;
    PIPSEC_SECURITY_METHOD pNewTemp = NULL;
    PIPSEC_SECURITY_METHOD pOldTemp = NULL;


    //
    // At this point, pszPolicyName and NegPolIdentifier are same and
    // dwWhenChanged is different.
    //

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolAction),
            &(pNewIpsecNegPolData->NegPolAction),
            sizeof(GUID))) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolType),
            &(pNewIpsecNegPolData->NegPolType),
            sizeof(GUID))) {
        return (FALSE);
    }
 
    dwOldCnt = pOldIpsecNegPolData->dwSecurityMethodCount;
    pOldSecurityMethods = pOldIpsecNegPolData->pIpsecSecurityMethods;

    dwNewCnt = pNewIpsecNegPolData->dwSecurityMethodCount;
    pNewSecurityMethods = pNewIpsecNegPolData->pIpsecSecurityMethods;

    //
    // At this point, dwOldCnt >= 1 and pOldSecurityMethods != NULL.
    //

    if (!dwNewCnt || !pNewSecurityMethods) {
        return (FALSE);
    }

    if (dwOldCnt != dwNewCnt) {
        return (FALSE);
    }

    pNewTemp = pNewSecurityMethods;
    pOldTemp = pOldSecurityMethods;

    for (i = 0; i < dwNewCnt; i++) {

        bEqual = FALSE;

        bEqual = EqualSecurityMethod(
                     pOldTemp,
                     pNewTemp
                     );

        if (!bEqual) {
            break;
        }

        pOldTemp++;

        pNewTemp++;

    }

    return (bEqual);
}


BOOL
EqualSecurityMethod(
    PIPSEC_SECURITY_METHOD pOldBundle,
    PIPSEC_SECURITY_METHOD pNewBundle
    )
{
    DWORD i = 0;


    if (memcmp(
            &(pOldBundle->Lifetime),
            &(pNewBundle->Lifetime),
            sizeof(LIFETIME))) {
       return (FALSE);
    }

    if (pOldBundle->Flags != pNewBundle->Flags) {
        return (FALSE);
    }

    if (pOldBundle->PfsQMRequired != pNewBundle->PfsQMRequired) {
        return (FALSE);
    }

    if (pOldBundle->Count != pNewBundle->Count) {
        return (FALSE);
    }

    if (pNewBundle->Count == 0) {
        return (TRUE);
    }

    for (i = 0; i < (pNewBundle->Count); i++) {

        if (memcmp(
                &(pOldBundle->Algos[i]),
                &(pNewBundle->Algos[i]),
                sizeof(IPSEC_ALGO_INFO))) {
            return (FALSE);
        }

    }

    return (TRUE);
}


DWORD
PAUpdateMMFilters(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;
    BOOL bEqual = FALSE;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;


    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    bEqual = EqualFilterKeysInNegPols(
                 pOldIpsecNegPolData,
                 pNewIpsecNegPolData
                 );
    if (!bEqual) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData
                      );
        return (dwError);
    }

    bEqual = EqualFilterKeysInNFAs(
                 pOldIpsecNFAData,
                 pNewIpsecNFAData
                 );
    if (!bEqual) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData
                      );
        return (dwError);
    }

    if (!memcmp(
            &(pNewIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (IsClearOnly(pNewIpsecNegPolData->NegPolAction) ||
        IsBlocking(pNewIpsecNegPolData->NegPolAction)) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PAProcessMMFilterDataForNFAs(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  pNewIpsecNFAData
                  );

    return (dwError);
}


BOOL
EqualFilterKeysInNegPols(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    )
{
    BOOL bOldAllowsSoft = FALSE;
    BOOL bNewAllowsSoft = FALSE;


    if (memcmp(
            &(pOldIpsecNegPolData->NegPolType),
            &(pNewIpsecNegPolData->NegPolType),
            sizeof(GUID))) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolAction),
            &(pNewIpsecNegPolData->NegPolAction),
            sizeof(GUID))) {
        return (FALSE);
    }

    bOldAllowsSoft = AllowsSoft(
                         pOldIpsecNegPolData->dwSecurityMethodCount,
                         pOldIpsecNegPolData->pIpsecSecurityMethods
                         );

    bNewAllowsSoft = AllowsSoft(
                         pNewIpsecNegPolData->dwSecurityMethodCount,
                         pNewIpsecNegPolData->pIpsecSecurityMethods
                         );

    if (bOldAllowsSoft != bNewAllowsSoft) {
        return (FALSE);
    }

    return (TRUE);
}


BOOL
EqualFilterKeysInNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    if (pOldIpsecNFAData->dwInterfaceType !=
        pNewIpsecNFAData->dwInterfaceType) {
        return (FALSE);
    }

    if (pOldIpsecNFAData->dwTunnelFlags !=
        pNewIpsecNFAData->dwTunnelFlags) {
        return (FALSE);
    }

    if (pOldIpsecNFAData->dwTunnelIpAddr !=
        pNewIpsecNFAData->dwTunnelIpAddr) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
PAProcessMMFilterDataForNFAs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pOldIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA pNewIpsecFilterData = NULL;
    DWORD dwNumOldFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs = NULL;
    DWORD dwNumNewFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs = NULL;


    pOldIpsecFilterData = pOldIpsecNFAData->pIpsecFilterData;
    pNewIpsecFilterData = pNewIpsecNFAData->pIpsecFilterData;

    if (!pOldIpsecFilterData) {
        if (!pNewIpsecFilterData) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PAAddMMFilterSpecs(
                          pNewIpsecISAKMPData,
                          pNewIpsecNFAData
                          );
            return (dwError);
        }
    }

    if (!pNewIpsecFilterData) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        return (dwError);
    }

    if (memcmp(
            &(pOldIpsecFilterData->FilterIdentifier),
            &(pNewIpsecFilterData->FilterIdentifier),
            sizeof(GUID))) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData
                      );
        return (dwError);
    }

    dwNumOldFilterSpecs = pOldIpsecFilterData->dwNumFilterSpecs;
    ppOldFilterSpecs = pOldIpsecFilterData->ppFilterSpecs;

    dwNumNewFilterSpecs = pNewIpsecFilterData->dwNumFilterSpecs;
    ppNewFilterSpecs = pNewIpsecFilterData->ppFilterSpecs;

    dwError = PADeleteObseleteMMFilterSpecs(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs
                  );

    dwError = PAUpdateMMFilterSpecs(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs
                  );

    return (dwError);
}


DWORD
PADeleteObseleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pOldFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;


    for (i = 0; i < dwNumOldFilterSpecs; i++) {

        pOldFilterSpec = *(ppOldFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pOldFilterSpec,
                               ppNewFilterSpecs,
                               dwNumNewFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PADeleteMMFilter(
                          pOldFilterSpec->FilterSpecGUID
                          );
        }

    }

    return (dwError);
}


PIPSEC_FILTER_SPEC
FindFilterSpec(
    PIPSEC_FILTER_SPEC pFilterSpec,
    PIPSEC_FILTER_SPEC * ppFilterSpecs,
    DWORD dwNumFilterSpecs
    )
{
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pTemp = NULL;


    for (i = 0; i < dwNumFilterSpecs; i++) {

        pTemp = *(ppFilterSpecs + i);

        if (!memcmp(
                &(pFilterSpec->FilterSpecGUID),
                &(pTemp->FilterSpecGUID),
                sizeof(GUID))) {
            return (pTemp);
        }

    }

    return (NULL);
}


DWORD
PAUpdateMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    PMMAUTHSTATE pMMAuthState = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pNewFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;
    BOOL bEqual = FALSE;
    PMMFILTERSTATE pMMFilterState = NULL;


    pMMPolicyState = FindMMPolicyState(
                         pNewIpsecISAKMPData->ISAKMPIdentifier
                         );
    if (!pMMPolicyState || !(pMMPolicyState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    pMMAuthState = FindMMAuthState(
                       pNewIpsecNFAData->NFAIdentifier
                       );
    if (!pMMAuthState || !(pMMAuthState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    for (i = 0; i < dwNumNewFilterSpecs; i++) {

        pNewFilterSpec = *(ppNewFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pNewFilterSpec,
                               ppOldFilterSpecs,
                               dwNumOldFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PAAddMMFilterSpec(
                          pNewIpsecISAKMPData,
                          pNewIpsecNFAData,
                          pNewFilterSpec
                          );
        }
        else {
            bEqual = FALSE;
            bEqual = EqualFilterSpecs(
                         pFoundFilterSpec,
                         pNewFilterSpec
                         );
            if (!bEqual) {
                dwError = PADeleteMMFilter(
                              pFoundFilterSpec->FilterSpecGUID
                              );
                dwError = PAAddMMFilterSpec(
                              pNewIpsecISAKMPData,
                              pNewIpsecNFAData,
                              pNewFilterSpec
                              ); 
            }
            else {
                pMMFilterState = FindMMFilterState(
                                     pFoundFilterSpec->FilterSpecGUID
                                     );
                if (!pMMFilterState) {
                    dwError = PAAddMMFilterSpec(
                                  pNewIpsecISAKMPData,
                                  pNewIpsecNFAData,
                                  pNewFilterSpec
                                  ); 
                }
                else {
                    if (!pMMFilterState->hMMFilter) {
                        PADeleteMMFilterState(pMMFilterState);
                        dwError = PAAddMMFilterSpec(
                                      pNewIpsecISAKMPData,
                                      pNewIpsecNFAData,
                                      pNewFilterSpec
                                      );
                    }
                }
            }
        }
    }

    return (dwError);
}


DWORD
PAAddMMFilterSpec(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;
    PMM_FILTER pSPDMMFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    dwError = PACreateMMFilterState(
                  pIpsecISAKMPData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pMMFilterState
                  );
    if (dwError) {
        return (dwError);
    }

    dwError = PACreateMMFilter(
                  pIpsecISAKMPData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pSPDMMFilter
                  );
    if (dwError) {

        pMMFilterState->hMMFilter = NULL;

        pMMFilterState->pNext = gpMMFilterState;
        gpMMFilterState = pMMFilterState;

        return (dwError);

    }

    dwError = AddMMFilter(
                  pServerName,
                  dwPersist,
                  pSPDMMFilter,
                  &(pMMFilterState->hMMFilter)
                  );

    pMMFilterState->pNext = gpMMFilterState;
    gpMMFilterState = pMMFilterState;

    PAFreeMMFilter(pSPDMMFilter);

    return (dwError);
}


BOOL
EqualFilterSpecs(
    PIPSEC_FILTER_SPEC pOldFilterSpec,
    PIPSEC_FILTER_SPEC pNewFilterSpec
    )
{
    BOOL bEqual = FALSE;


    //
    // At this point, FilterSpecGUID is same.
    //

    bEqual = AreNamesEqual(
                 pOldFilterSpec->pszDescription,
                 pNewFilterSpec->pszDescription
                 );
    if (!bEqual) {
        return (FALSE);
    }

    if (pOldFilterSpec->dwMirrorFlag !=
        pNewFilterSpec->dwMirrorFlag) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldFilterSpec->Filter),
            &(pNewFilterSpec->Filter),
            sizeof(IPSEC_FILTER))) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
PAUpdateQMFilters(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;
    BOOL bEqual = FALSE;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;


    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    bEqual = EqualFilterKeysInNegPols(
                 pOldIpsecNegPolData,
                 pNewIpsecNegPolData
                 );
    if (!bEqual) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        dwError = PAAddQMFilterSpecs(
                      pNewIpsecNFAData
                      );
        return (dwError);
    }

    bEqual = EqualFilterKeysInNFAs(
                 pOldIpsecNFAData,
                 pNewIpsecNFAData
                 );
    if (!bEqual) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        dwError = PAAddQMFilterSpecs(
                      pNewIpsecNFAData
                      );
        return (dwError);
    }

    if (!memcmp(
            &(pNewIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PAProcessQMFilterDataForNFAs(
                  pOldIpsecNFAData,
                  pNewIpsecNFAData
                  );

    return (dwError);
}


DWORD
PAAddQMFilterSpecs(
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;


    if (!(pNewIpsecNFAData->dwTunnelFlags)) {
        dwError = PAAddTxFilterSpecs(
                      pNewIpsecNFAData
                      );
    }
    else {
        dwError = PAAddTnFilterSpecs(
                      pNewIpsecNFAData
                      );
    }

    return (dwError);
}


DWORD
PADeleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    )
{
    DWORD dwError = 0;


    if (!(pOldIpsecNFAData->dwTunnelFlags)) {
        dwError = PADeleteTxFilterSpecs(
                      pOldIpsecNFAData
                      );
    }
    else {
        dwError = PADeleteTnFilterSpecs(
                      pOldIpsecNFAData
                      );
    }

    return (dwError);
}


DWORD
PAProcessQMFilterDataForNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pOldIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA pNewIpsecFilterData = NULL;
    DWORD dwNumOldFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs = NULL;
    DWORD dwNumNewFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs = NULL;


    pOldIpsecFilterData = pOldIpsecNFAData->pIpsecFilterData;
    pNewIpsecFilterData = pNewIpsecNFAData->pIpsecFilterData;

    if (!pOldIpsecFilterData) {
        if (!pNewIpsecFilterData) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PAAddQMFilterSpecs(
                          pNewIpsecNFAData
                          );
            return (dwError);
        }
    }

    if (!pNewIpsecFilterData) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        return (dwError);
    }

    if (memcmp(
            &(pOldIpsecFilterData->FilterIdentifier),
            &(pNewIpsecFilterData->FilterIdentifier),
            sizeof(GUID))) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        dwError = PAAddQMFilterSpecs(
                      pNewIpsecNFAData
                      );
        return (dwError);
    }

    dwNumOldFilterSpecs = pOldIpsecFilterData->dwNumFilterSpecs;
    ppOldFilterSpecs = pOldIpsecFilterData->ppFilterSpecs;

    dwNumNewFilterSpecs = pNewIpsecFilterData->dwNumFilterSpecs;
    ppNewFilterSpecs = pNewIpsecFilterData->ppFilterSpecs;

    dwError = PADeleteObseleteQMFilterSpecs(
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs
                  );

    dwError = PAUpdateQMFilterSpecs(
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs
                  );

    return (dwError);
}


DWORD
PADeleteObseleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pOldFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;


    for (i = 0; i < dwNumOldFilterSpecs; i++) {

        pOldFilterSpec = *(ppOldFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pOldFilterSpec,
                               ppNewFilterSpecs,
                               dwNumNewFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PADeleteQMFilter(
                          pOldIpsecNFAData,
                          pOldFilterSpec->FilterSpecGUID
                          );
        }

    }

    return (dwError);
}


DWORD
PAUpdateQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pNewFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;
    BOOL bEqual = FALSE;


    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    pQMPolicyState = FindQMPolicyState(
                         pNewIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    if (!IsClearOnly(pQMPolicyState->gNegPolAction) &&
        !IsBlocking(pQMPolicyState->gNegPolAction) &&
        !(pQMPolicyState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    for (i = 0; i < dwNumNewFilterSpecs; i++) {

        pNewFilterSpec = *(ppNewFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pNewFilterSpec,
                               ppOldFilterSpecs,
                               dwNumOldFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PAAddQMFilterSpec(
                          pNewIpsecNFAData,
                          pQMPolicyState,
                          pNewFilterSpec
                          );
        }
        else {
            bEqual = FALSE;
            bEqual = EqualFilterSpecs(
                         pFoundFilterSpec,
                         pNewFilterSpec
                         );
            if (!bEqual) {
                dwError = PADeleteQMFilter(
                              pOldIpsecNFAData,
                              pFoundFilterSpec->FilterSpecGUID
                              );
                dwError = PAAddQMFilterSpec(
                              pNewIpsecNFAData,
                              pQMPolicyState,
                              pNewFilterSpec
                              ); 
            }
            else {
                dwError = PAUpdateQMFilterSpec(
                              pNewIpsecNFAData,
                              pQMPolicyState,
                              pNewFilterSpec
                              );
            }
        }
    }

    return (dwError);
}


DWORD
PADeleteQMFilter(
    PIPSEC_NFA_DATA pIpsecNFAData,
    GUID FilterSpecGUID
    )
{
    DWORD dwError = 0;


    if (!(pIpsecNFAData->dwTunnelFlags)) {
        dwError = PADeleteTxFilter(
                      FilterSpecGUID
                      );
    }
    else {
        dwError = PADeleteTnFilter(
                      FilterSpecGUID
                      );
    }

    return (dwError);
}


DWORD
PAAddQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;


    if (!(pIpsecNFAData->dwTunnelFlags)) {
        dwError = PAAddTxFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec
                      );
    }
    else {
        dwError = PAAddTnFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec
                      );
    }

    return (dwError);
}


DWORD
PAAddTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PTXFILTERSTATE pTxFilterState = NULL;
    PTRANSPORT_FILTER pSPDTxFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    dwError = PACreateTxFilterState(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pTxFilterState
                  );
    if (dwError) {
        return (dwError);
    }

    dwError = PACreateTxFilter(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  pQMPolicyState,
                  &pSPDTxFilter
                  );
    if (dwError) {

        pTxFilterState->hTxFilter = NULL;

        pTxFilterState->pNext = gpTxFilterState;
        gpTxFilterState = pTxFilterState;

        return (dwError);

    }

    dwError = AddTransportFilter(
                  pServerName,
                  dwPersist,
                  pSPDTxFilter,
                  &(pTxFilterState->hTxFilter)
                  );

    pTxFilterState->pNext = gpTxFilterState;
    gpTxFilterState = pTxFilterState;

    PAFreeTxFilter(pSPDTxFilter);

    return (dwError);
}


DWORD
PAAddTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PTNFILTERSTATE pTnFilterState = NULL;
    PTUNNEL_FILTER pSPDTnFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    dwError = PACreateTnFilterState(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pTnFilterState
                  );
    if (dwError) {
        return (dwError);
    }

    dwError = PACreateTnFilter(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  pQMPolicyState,
                  &pSPDTnFilter
                  );
    if (dwError) {

        pTnFilterState->hTnFilter = NULL;

        pTnFilterState->pNext = gpTnFilterState;
        gpTnFilterState = pTnFilterState;

        return (dwError);

    }

    dwError = AddTunnelFilter(
                  pServerName,
                  dwPersist,
                  pSPDTnFilter,
                  &(pTnFilterState->hTnFilter)
                  );

    pTnFilterState->pNext = gpTnFilterState;
    gpTnFilterState = pTnFilterState;

    PAFreeTnFilter(pSPDTnFilter);

    return (dwError);
}


BOOL
AllowsSoft(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods
    )
{
    DWORD dwTempOfferCount = 0;
    PIPSEC_SECURITY_METHOD pTempMethod = NULL;
    BOOL bAllowsSoft = FALSE;
    DWORD i = 0;


    if (!dwSecurityMethodCount || !pIpsecSecurityMethods) {
        return (FALSE);
    }

    if (dwSecurityMethodCount > IPSEC_MAX_QM_OFFERS) {
        dwTempOfferCount = IPSEC_MAX_QM_OFFERS;
    }
    else {
        dwTempOfferCount = dwSecurityMethodCount;
    }

    pTempMethod = pIpsecSecurityMethods;
 
    for (i = 0; i < dwTempOfferCount; i++) {

        if (pTempMethod->Count == 0) {
            bAllowsSoft = TRUE;
            break;
        }

        pTempMethod++;

    }

    return (bAllowsSoft);
}


DWORD
PAUpdateQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;


    if (!(pIpsecNFAData->dwTunnelFlags)) {

        dwError = PAUpdateTxFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec
                      );

    }
    else {

        dwError = PAUpdateTnFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec
                      );

    }

    return (dwError);
}


DWORD
PAUpdateTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;


    pTxFilterState = FindTxFilterState(
                         pFilterSpec->FilterSpecGUID
                         );
    if (!pTxFilterState) {
        dwError = PAAddTxFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec
                      ); 
    }
    else {
        if (!pTxFilterState->hTxFilter) {
            PADeleteTxFilterState(pTxFilterState);
            dwError = PAAddTxFilterSpec(
                          pIpsecNFAData,
                          pQMPolicyState,
                          pFilterSpec
                          ); 
        }
    }

    return (dwError);
}


DWORD
PAUpdateTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;


    pTnFilterState = FindTnFilterState(
                         pFilterSpec->FilterSpecGUID
                         );
    if (!pTnFilterState) {
        dwError = PAAddTnFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec
                      ); 
    }
    else {
        if (!pTnFilterState->hTnFilter) {
            PADeleteTnFilterState(pTnFilterState);
            dwError = PAAddTnFilterSpec(
                          pIpsecNFAData,
                          pQMPolicyState,
                          pFilterSpec
                          );
        }
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\port.c ===
#include "precomp.h"


DWORD
VerifyPortsForProtocol(
    PORT        Port,
    PROTOCOL    Protocol
    )
{
    DWORD   dwError = 0;

    switch (Port.PortType) {

    case PORT_UNIQUE:

        if (Port.wPort < 0) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        switch (Protocol.ProtocolType) {

        case PROTOCOL_UNIQUE:
            if ((Protocol.dwProtocol != TCP_PROTOCOL) && 
                (Protocol.dwProtocol != UDP_PROTOCOL)) {
                if (Port.wPort != 0) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
            }
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
            break;
        }

        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


BOOL
EqualPorts(
    IN PORT     OldPort,
    IN PORT     NewPort
    )
{
    BOOL bMatches = FALSE;

    if (OldPort.PortType == NewPort.PortType) {
        switch(OldPort.PortType) {
        case PORT_UNIQUE:
            if (OldPort.wPort == NewPort.wPort) {
                bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyPorts(
    IN  PORT    InPort,
    OUT PPORT   pOutPort
    )
{
    memcpy(
        pOutPort,
        &InPort,
        sizeof(PORT)
        );
}


BOOL
MatchPorts(
    PORT PortToMatch,
    PORT PortTemplate
    )
{
    switch (PortTemplate.PortType) {

    case PORT_UNIQUE:
        if (PortToMatch.wPort) {
            if (PortToMatch.wPort != PortTemplate.wPort) {
                return (FALSE);
            }
        }
        break;

    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <imagehlp.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <dsgetdc.h>

#ifdef __cplusplus
}
#endif

#include "winioctl.h"
#include "winsock2.h"
#include "winsock.h"
#include <userenv.h>
#include <wchar.h>
#include <winldap.h>
#include "ipexport.h"
#include <iphlpapi.h>
#include <nhapi.h>
#include <seopaque.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <msaudite.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <ntsam.h>
#include <lsaisrv.h>

#ifdef __cplusplus
}
#endif

#include "spd_s.h"
#include "winipsec.h"
#include "structs.h"
#include "spdaudit.h"

#include "audit.h"

#include "interface.h"
#include "address.h"
#include "port.h"
#include "protocol.h"
#include "utils.h"
#include "memory.h"
#include "security.h"
#include "init.h"
#include "rpcserv.h"
#include "iphlpwrp.h"
#include "loopmgr.h"
#include "ipsecspd.h"
#include "qm-policy.h"
#include "mm-policy.h"
#include "mmauth.h"
#include "txfilter.h"
#include "txspecific.h"
#include "tnfilter.h"
#include "tnspecific.h"
#include "mmfilter.h"
#include "mmspecific.h"
#include "ipsec.h"
#include "driver.h"


//
// Policy Agent Store specific headers.
//

#include "oakdefs.h"
#include "polstructs.h"
#include "..\..\pastore\ldaputil.h"
#include "..\..\pastore\structs.h"
#include "..\..\pastore\dsstore.h"
#include "..\..\pastore\regstore.h"
#include "..\..\pastore\procrule.h"
#include "..\..\pastore\persist.h"
#include "..\..\pastore\utils.h"
#include "polguids.h"
#include "pamm-pol.h"
#include "pammauth.h"
#include "paqm-pol.h"
#include "pamm-fil.h"
#include "patx-fil.h"
#include "patn-fil.h"
#include "paupdate.h"
#include "pastore.h"


//
// Persistence specific headers.
//

#include "mmp-load.h"
#include "mmp-pers.h"
#include "mma-load.h"
#include "mma-pers.h"
#include "qmp-load.h"
#include "qmp-pers.h"
#include "mmf-load.h"
#include "mmf-pers.h"
#include "txf-load.h"
#include "txf-pers.h"
#include "tnf-load.h"
#include "tnf-pers.h"
#include "ipsecshr.h"


#include "oakdll.h"

#include "externs.h"


extern
DWORD
AllocateAndGetIfTableFromStack(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );


#ifdef BAIL_ON_WIN32_ERROR
#undef BAIL_ON_WIN32_ERROR
#endif

#ifdef BAIL_ON_LOCK_ERROR
#undef BAIL_ON_LOCK_ERROR
#endif


#define BAIL_ON_WIN32_ERROR(dwError)                \
    if (dwError) {                                  \
        goto error;                                 \
    }

#define BAIL_ON_LOCK_ERROR(dwError)                 \
    if (dwError) {                                  \
        goto lock;                                  \
    }

#define BAIL_ON_WIN32_SUCCESS(dwError) \
    if (!dwError) {                    \
        goto success;                  \
    }

#define BAIL_ON_LOCK_SUCCESS(dwError)  \
    if (!dwError) {                    \
        goto lock_success;             \
    }

#define ENTER_SPD_SECTION()             \
    EnterCriticalSection(&gcSPDSection) \

#define LEAVE_SPD_SECTION()             \
    LeaveCriticalSection(&gcSPDSection) \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\protocol.h ===
DWORD
VerifyProtocols(
    PROTOCOL    Protocol
    );


BOOL
EqualProtocols(
    IN PROTOCOL OldProtocol,
    IN PROTOCOL NewProtocol
    );


VOID
CopyProtocols(
    IN  PROTOCOL    InProtocol,
    OUT PPROTOCOL   pOutProtocol
    );


BOOL
MatchProtocols(
    PROTOCOL ProtocolToMatch,
    PROTOCOL ProtocolTemplate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\protocol.c ===
#include "precomp.h"


DWORD
VerifyProtocols(
    PROTOCOL    Protocol
    )
{
    DWORD   dwError = 0;

    switch (Protocol.ProtocolType) {

    case PROTOCOL_UNIQUE:
        if (Protocol.dwProtocol > 255) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


BOOL
EqualProtocols(
    IN PROTOCOL OldProtocol,
    IN PROTOCOL NewProtocol
    )
{
    BOOL bMatches = FALSE;

    if (OldProtocol.ProtocolType == NewProtocol.ProtocolType) {
        switch(OldProtocol.ProtocolType) {
        case PROTOCOL_UNIQUE:
            if (OldProtocol.dwProtocol == NewProtocol.dwProtocol) {
                bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyProtocols(
    IN  PROTOCOL    InProtocol,
    OUT PPROTOCOL   pOutProtocol
    )
{
    memcpy(
        pOutProtocol,
        &InProtocol,
        sizeof(PROTOCOL)
        );
}


BOOL
MatchProtocols(
    PROTOCOL ProtocolToMatch,
    PROTOCOL ProtocolTemplate
    )
{
    switch (ProtocolTemplate.ProtocolType) {

    case PROTOCOL_UNIQUE:
        if (ProtocolToMatch.dwProtocol) {
            if (ProtocolToMatch.dwProtocol != 
                ProtocolTemplate.dwProtocol) {
                return (FALSE);
            }
        }
        break;

    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\qmp-load.h ===
DWORD
LoadPersistedQMPolicies(
    HKEY hParentRegKey
    );

DWORD
SPDReadQMPolicy(
    HKEY hParentRegKey,
    LPWSTR pszQMPolicyUniqueID,
    PIPSEC_QM_POLICY * ppQMPolicy
    );

DWORD
UnMarshallQMOffers(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PIPSEC_QM_OFFER * ppOffers,
    PDWORD pdwOfferCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\qm-policy.h ===
typedef struct _iniqmpolicy {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD  cRef;
    BOOL bIsPersisted;
    DWORD dwFlags;
    DWORD dwOfferCount;
    PIPSEC_QM_OFFER pOffers;
    struct _iniqmpolicy * pNext;
} INIQMPOLICY, * PINIQMPOLICY;


DWORD
CreateIniQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    PINIQMPOLICY * ppIniQMPolicy
    );

DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

PINIQMPOLICY
FindQMPolicy(
    PINIQMPOLICY pIniQMPolicyList,
    LPWSTR pszPolicyName
    );

VOID
FreeIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    );

VOID
FreeIniQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

DWORD
CreateIniQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

DWORD
SetIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
GetIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY * ppQMPolicy
    );

DWORD
CopyQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
CreateQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

DWORD
DeleteIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    );

VOID
FreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

VOID
FreeIniQMPolicyList(
    PINIQMPOLICY pIniQMPolicyList
    );

PINIQMPOLICY
FindQMPolicyByGuid(
    PINIQMPOLICY pIniQMPolicyList,
    GUID gPolicyID
    );

VOID
FreeQMPolicies(
    DWORD dwNumQMPolicies,
    PIPSEC_QM_POLICY pQMPolicies
    );

DWORD
LocateQMPolicy(
    DWORD dwFlags,
    GUID gPolicyID,
    PINIQMPOLICY * ppIniQMPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\qm-policy.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    qm-policy.c

Abstract:


Author:


Environment: User Mode


Revision History:


--*/


#include "precomp.h"


DWORD
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy
    )
/*++

Routine Description:

    This function adds a quick mode policy to the SPD.

Arguments:

    pServerName - Server on which the quick mode policy is to be added.

    pQMPolicy - Quick mode policy to be added.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    BOOL bPersist = FALSE;


    bPersist = (BOOL) (dwFlags & PERSIST_SPD_OBJECT);

    //
    // Validate the quick mode policy.
    //

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pQMPolicy->pszPolicyName
                       );
    if (pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniQMPolicy = FindQMPolicyByGuid(
                       gpIniQMPolicy,
                       pQMPolicy->gPolicyID
                       );
    if (pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (bPersist && !gbLoadingPersistence) {
        dwError = PersistQMPolicy(
                      pQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniQMPolicy(
                  pQMPolicy,
                  &pIniQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy->bIsPersisted = bPersist;

    pIniQMPolicy->pNext = gpIniQMPolicy;
    gpIniQMPolicy = pIniQMPolicy;

    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = pIniQMPolicy;
    }

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pQMPolicy && bPersist && !gbLoadingPersistence) {
        (VOID) SPDPurgeQMPolicy(
                   pQMPolicy->gPolicyID
                   );
    }

    return (dwError);
}


DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;


    if (!pQMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicy->pszPolicyName) || !(*(pQMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}



DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_QM_OFFER pTemp = NULL;
    DWORD j = 0;
    BOOL bAH = FALSE;
    BOOL bESP = FALSE;
    DWORD dwQMGroup = PFS_GROUP_NONE;


    if (!dwOfferCount || !pOffers || (dwOfferCount > IPSEC_MAX_QM_OFFERS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of offers
    // specified is more than the actual number of offers.
    //


    pTemp = pOffers;

    if (pTemp->bPFSRequired) {
        if ((pTemp->dwPFSGroup != PFS_GROUP_1) &&
            (pTemp->dwPFSGroup != PFS_GROUP_2) &&
            (pTemp->dwPFSGroup != PFS_GROUP_MM)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        dwQMGroup=pTemp->dwPFSGroup;
    }
    else {
        if (pTemp->dwPFSGroup != PFS_GROUP_NONE) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwOfferCount; i++) {
        
        if (dwQMGroup) {
            if ((!pTemp->bPFSRequired) || (pTemp->dwPFSGroup != dwQMGroup)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);    
            } 
        } else {            
            if ((pTemp->bPFSRequired) || (pTemp->dwPFSGroup != PFS_GROUP_NONE)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);    
            }
        }

        if (!(pTemp->dwNumAlgos) || (pTemp->dwNumAlgos > QM_MAX_ALGOS)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        bAH = FALSE;
        bESP = FALSE;

        for (j = 0; j < (pTemp->dwNumAlgos); j++) {

            switch (pTemp->Algos[j].Operation) {

            case AUTHENTICATION:
                if (bAH) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if ((pTemp->Algos[j].uAlgoIdentifier == IPSEC_DOI_AH_NONE) ||
                    (pTemp->Algos[j].uAlgoIdentifier >= IPSEC_DOI_AH_MAX)) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uSecAlgoIdentifier != HMAC_AH_NONE) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                bAH = TRUE;
                break;

            case ENCRYPTION:
                if (bESP) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uAlgoIdentifier >= IPSEC_DOI_ESP_MAX) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uSecAlgoIdentifier >= HMAC_AH_MAX) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uAlgoIdentifier == IPSEC_DOI_ESP_NONE) {
                    if (pTemp->Algos[j].uSecAlgoIdentifier == HMAC_AH_NONE) {
                        dwError = ERROR_INVALID_PARAMETER;
                        BAIL_ON_WIN32_ERROR(dwError);
                    }
                }
                bESP = TRUE;
                break;

            case NONE:
            case COMPRESSION:
            default:
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
                break;

            }

        }

        pTemp++;

    }

error:

    return (dwError);
}

DWORD
CreateIniQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    PINIQMPOLICY * ppIniQMPolicy
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIQMPOLICY),
                  &pIniQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIniQMPolicy->gPolicyID),
        &(pQMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  AllocateSPDString(
                   pQMPolicy->pszPolicyName,
                   &(pIniQMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniQMPolicy->cRef = 0;
    pIniQMPolicy->bIsPersisted = FALSE;

    pIniQMPolicy->dwFlags = pQMPolicy->dwFlags;
    pIniQMPolicy->pNext = NULL;

    dwError = CreateIniQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers,
                  &(pIniQMPolicy->dwOfferCount),
                  &(pIniQMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniQMPolicy = pIniQMPolicy;
    return (dwError);

error:

    if (pIniQMPolicy) {
        FreeIniQMPolicy(
            pIniQMPolicy
            );
    }

    *ppIniQMPolicy = NULL;
    return (dwError);
}


DWORD
CreateIniQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTemp = NULL;
    PIPSEC_QM_OFFER pInTempOffer = NULL;
    DWORD i = 0;
    DWORD j = 0;


    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_QM_OFFER) * dwInOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->bPFSRequired = pInTempOffer->bPFSRequired;
        pTemp->dwPFSGroup = pInTempOffer->dwPFSGroup;
        pTemp->dwNumAlgos = pInTempOffer->dwNumAlgos;

        for (j = 0; j < (pInTempOffer->dwNumAlgos); j++) {
            memcpy(
                &(pTemp->Algos[j]),
                &(pInTempOffer->Algos[j]),
                sizeof(IPSEC_QM_ALGO)
                );
        }

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwInOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        FreeIniQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


VOID
FreeIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    )
{
    if (pIniQMPolicy) {

        if (pIniQMPolicy->pszPolicyName) {
            FreeSPDString(pIniQMPolicy->pszPolicyName);
        }

        FreeIniQMOffers(
            pIniQMPolicy->dwOfferCount,
            pIniQMPolicy->pOffers
            );

        FreeSPDMemory(pIniQMPolicy);

    }
}


VOID
FreeIniQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


PINIQMPOLICY
FindQMPolicy(
    PINIQMPOLICY pIniQMPolicyList,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pTemp = NULL;


    pTemp = pIniQMPolicyList;

    while (pTemp) {

        if (!_wcsicmp(pTemp->pszPolicyName, pszPolicyName)) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


DWORD
DeleteQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    )
/*++

Routine Description:

    This function deletes a quick mode policy from the SPD.

Arguments:

    pServerName - Server on which the quick mode policy is to be deleted.

    pszPolicyName - Quick mode policy to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    GUID gPolicyID;


    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pszPolicyName
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniQMPolicy->cRef) {
        dwError = ERROR_IPSEC_QM_POLICY_IN_USE;
        memcpy(&gPolicyID, &pIniQMPolicy->gPolicyID, sizeof(GUID));
        BAIL_ON_LOCK_ERROR(dwError);
    }

    memcpy(&gPolicyID, &pIniQMPolicy->gPolicyID, sizeof(GUID));

    if (pIniQMPolicy->bIsPersisted) {
        dwError = SPDPurgeQMPolicy(
                      gPolicyID
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniQMPolicy(
                  pIniQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_QM
                   );
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if ((dwError == ERROR_IPSEC_QM_POLICY_IN_USE) && gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_QM
                   );
    }

    return (dwError);
}


DWORD
EnumQMPolicies(
    LPWSTR pServerName,
    PIPSEC_QM_POLICY * ppQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function enumerates quick mode policies from the SPD.

Arguments:

    pServerName - Server on which the quick mode policies are to
                  be enumerated.

    ppQMPolicies - Enumerated quick mode policies returned to the 
                   caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumPolicies - Number of quick mode policies actually enumerated.

    pdwResumeHandle - Handle to the location in the quick mode policy
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    DWORD i = 0;
    PINIQMPOLICY pTemp = NULL;
    DWORD dwNumPolicies = 0;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_QMPOLICY_ENUM_COUNT)) {
        dwNumToEnum = MAX_QMPOLICY_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = gpIniQMPolicy;

    for (i = 0; (i < dwResumeHandle) && (pIniQMPolicy != NULL); i++) {
        pIniQMPolicy = pIniQMPolicy->pNext;
    }

    if (!pIniQMPolicy) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTemp = pIniQMPolicy;

    while (pTemp && (dwNumPolicies < dwNumToEnum)) {
        dwNumPolicies++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY)*dwNumPolicies,
                  &pQMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTemp = pIniQMPolicy;
    pQMPolicy = pQMPolicies;

    for (i = 0; i < dwNumPolicies; i++) {

        dwError = CopyQMPolicy(
                      pTemp,
                      pQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTemp = pTemp->pNext;
        pQMPolicy++;

    }

    *ppQMPolicies = pQMPolicies;
    *pdwResumeHandle = dwResumeHandle + dwNumPolicies;
    *pdwNumPolicies = dwNumPolicies;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pQMPolicies) {
        FreeQMPolicies(
            i,
            pQMPolicies
            );
    }

    *ppQMPolicies = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy
    )
/*++

Routine Description:

    This function updates a quick mode policy in the SPD.

Arguments:

    pServerName - Server on which the quick mode policy is to be
                  updated.

    pszPolicyName - Name of the quick mode policy to be updated.

    pQMPolicy - New quick mode policy which will replace the 
                existing policy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;


    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }
    
    //
    // Validate quick mode policy.
    //

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pszPolicyName
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (memcmp(
            &(pIniQMPolicy->gPolicyID),
            &(pQMPolicy->gPolicyID),
            sizeof(GUID))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniQMPolicy(
                  pIniQMPolicy,
                  pQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniQMPolicy->bIsPersisted) {
        dwError = PersistQMPolicy(
                      pQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    LEAVE_SPD_SECTION();

    (VOID) IKENotifyPolicyChange(
               &(pQMPolicy->gPolicyID),
               POLICY_GUID_QM
               );

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    return (dwError);
}


DWORD
GetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
/*++

Routine Description:

    This function gets a quick mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the quick mode policy.

    pszPolicyName - Name of the quick mode policy to get.

    ppQMPolicy - Quick mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pszPolicyName
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniQMPolicy(
                  pIniQMPolicy,
                  &pQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
SetIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_QM_OFFER pOffers = NULL;


    dwError = CreateIniQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers,
                  &dwOfferCount,
                  &pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    FreeIniQMOffers(
        pIniQMPolicy->dwOfferCount,
        pIniQMPolicy->pOffers
        );
    
    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = NULL;
    }

    pIniQMPolicy->dwFlags = pQMPolicy->dwFlags;
    pIniQMPolicy->dwOfferCount = dwOfferCount;
    pIniQMPolicy->pOffers = pOffers;

    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = pIniQMPolicy;
    }

error:

    return (dwError);
}


DWORD
GetIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY),
                  &pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyQMPolicy(
                  pIniQMPolicy,
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;
    return (dwError);

error:

    if (pQMPolicy) {
        SPDApiBufferFree(pQMPolicy);
    }

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
CopyQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pQMPolicy->gPolicyID),
        &(pIniQMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  SPDApiBufferAllocate(
                   wcslen(pIniQMPolicy->pszPolicyName)*sizeof(WCHAR)
                   + sizeof(WCHAR),
                   &(pQMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(pQMPolicy->pszPolicyName, pIniQMPolicy->pszPolicyName);
 
    pQMPolicy->dwFlags = pIniQMPolicy->dwFlags;

    dwError = CreateQMOffers(
                  pIniQMPolicy->dwOfferCount,
                  pIniQMPolicy->pOffers,
                  &(pQMPolicy->dwOfferCount),
                  &(pQMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    return (dwError);

error:

    if (pQMPolicy->pszPolicyName) {
        SPDApiBufferFree(pQMPolicy->pszPolicyName);
    }

    return (dwError);
}


DWORD
CreateQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTemp = NULL;
    PIPSEC_QM_OFFER pInTempOffer = NULL;
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;


    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_OFFER) * dwInOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->bPFSRequired = pInTempOffer->bPFSRequired;
        pTemp->dwPFSGroup = pInTempOffer->dwPFSGroup;
        pTemp->dwNumAlgos = pInTempOffer->dwNumAlgos;

        for (j = 0; j < (pInTempOffer->dwNumAlgos); j++) {
            memcpy(
                &(pTemp->Algos[j]),
                &(pInTempOffer->Algos[j]),
                sizeof(IPSEC_QM_ALGO)
                );
        }

        for (k = j; k < QM_MAX_ALGOS; k++) {
            memset(&(pTemp->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
        }

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwInOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        FreeQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


DWORD
DeleteIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY * ppTemp = NULL;


    ppTemp = &gpIniQMPolicy;

    while (*ppTemp) {

        if (*ppTemp == pIniQMPolicy) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pIniQMPolicy->pNext;
    }

    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = NULL;
    }

    FreeIniQMPolicy(pIniQMPolicy);

    return (dwError);
}


VOID
FreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    if (pOffers) {
        SPDApiBufferFree(pOffers);
    }
}


VOID
FreeIniQMPolicyList(
    PINIQMPOLICY pIniQMPolicyList
    )
{
    PINIQMPOLICY pTemp = NULL;
    PINIQMPOLICY pIniQMPolicy = NULL;


    pTemp = pIniQMPolicyList;

    while (pTemp) {

         pIniQMPolicy = pTemp;
         pTemp = pTemp->pNext;

         FreeIniQMPolicy(pIniQMPolicy);

    }
}


PINIQMPOLICY
FindQMPolicyByGuid(
    PINIQMPOLICY pIniQMPolicyList,
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pTemp = NULL;


    pTemp = pIniQMPolicyList;

    while (pTemp) {

        if (!memcmp(&(pTemp->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


VOID
FreeQMPolicies(
    DWORD dwNumQMPolicies,
    PIPSEC_QM_POLICY pQMPolicies
    )
{
    DWORD i = 0;

    if (pQMPolicies) {

        for (i = 0; i < dwNumQMPolicies; i++) {

            if (pQMPolicies[i].pszPolicyName) {
                SPDApiBufferFree(pQMPolicies[i].pszPolicyName);
            }

            FreeQMOffers(
                pQMPolicies[i].dwOfferCount,
                pQMPolicies[i].pOffers
                );

        }

        SPDApiBufferFree(pQMPolicies);

    }

}


DWORD
GetQMPolicyByID(
    LPWSTR pServerName,
    GUID gQMPolicyID,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
/*++

Routine Description:

    This function gets a quick mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the quick mode policy.

    gQMFilter - Guid of the quick mode policy to get.

    ppQMPolicy - Quick mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicyByGuid(
                       gpIniQMPolicy,
                       gQMPolicyID
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniQMPolicy(
                  pIniQMPolicy,
                  &pQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
LocateQMPolicy(
    DWORD dwFlags,
    GUID gPolicyID,
    PINIQMPOLICY * ppIniQMPolicy
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;


    if (dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY) {

        if (!gpIniDefaultQMPolicy) {
            dwError = ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIniQMPolicy = gpIniDefaultQMPolicy;

    }
    else {

        pIniQMPolicy = FindQMPolicyByGuid(
                           gpIniQMPolicy,
                           gPolicyID
                           );
        if (!pIniQMPolicy) {
            dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    *ppIniQMPolicy = pIniQMPolicy;
    return (dwError);

error:

    *ppIniQMPolicy = NULL;
    return (dwError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\qmp-load.c ===
#include "precomp.h"


DWORD
LoadPersistedQMPolicies(
    HKEY hParentRegKey
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;
    WCHAR szQMPolicyUniqueID[MAX_PATH];
    DWORD dwIndex = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    LPWSTR pszServerName = NULL;
    DWORD dwPersist = 0;


    dwPersist |= PERSIST_SPD_OBJECT;

    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  L"QM Policies",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    while (1) {

        dwSize = MAX_PATH;
        szQMPolicyUniqueID[0] = L'\0';

        dwError = RegEnumKeyExW(
                      hRegKey,
                      dwIndex,
                      szQMPolicyUniqueID,
                      &dwSize,
                      NULL,
                      NULL,
                      0,
                      0
                      );

        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        }

        BAIL_ON_WIN32_ERROR(dwError);

        dwError = SPDReadQMPolicy(
                      hRegKey,
                      szQMPolicyUniqueID,
                      &pQMPolicy
                      );

        if (dwError) {
            dwIndex++;
            continue;
        }

        dwError = AddQMPolicy(
                      pszServerName,
                      dwPersist,
                      pQMPolicy
                      );

        if (pQMPolicy) {
            FreeQMPolicies(
                1,
                pQMPolicy
                );
        }

        dwIndex++;

    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
SPDReadQMPolicy(
    HKEY hParentRegKey,
    LPWSTR pszQMPolicyUniqueID,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    LPWSTR pszPolicyID = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;


    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  pszQMPolicyUniqueID,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pQMPolicy = (PIPSEC_QM_POLICY) AllocSPDMem(
                                   sizeof(IPSEC_QM_POLICY)
                                   );
    if (!pQMPolicy) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyID",
                  REG_SZ,
                  (LPBYTE *)&pszPolicyID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszPolicyID,
        &pQMPolicy->gPolicyID
        );

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyName",
                  REG_SZ,
                  (LPBYTE *)&pQMPolicy->pszPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Flags",
                  NULL,
                  &dwType,
                  (LPBYTE)&pQMPolicy->dwFlags,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"Offers",
                  REG_BINARY,
                  (LPBYTE *)&pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallQMOffers(
                  pBuffer,
                  dwBufferSize,
                  &pQMPolicy->pOffers,
                  &pQMPolicy->dwOfferCount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszPolicyID) {
        FreeSPDStr(pszPolicyID);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    *ppQMPolicy = NULL;

    if (pQMPolicy) {
        FreeQMPolicies(
            1,
            pQMPolicy
            );
    }

    goto cleanup;
}


DWORD
UnMarshallQMOffers(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PIPSEC_QM_OFFER * ppOffers,
    PDWORD pdwOfferCount
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;
    PIPSEC_QM_OFFER pOffers = NULL;
    DWORD dwOfferCount = 0;


    pMem = pBuffer;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy(
        (LPBYTE) &dwOfferCount,
        pMem,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    pOffers = (PIPSEC_QM_OFFER) AllocSPDMem(
                                sizeof(IPSEC_QM_OFFER)*dwOfferCount
                                );
    if (!pOffers) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        (LPBYTE) pOffers,
        pMem,
        sizeof(IPSEC_QM_OFFER)*dwOfferCount
        );

    *ppOffers = pOffers;
    *pdwOfferCount = dwOfferCount;
    return (dwError);

error:

    *ppOffers = NULL;
    *pdwOfferCount = 0;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\qmp-pers.c ===
#include "precomp.h"


LPWSTR gpszIpsecQMPoliciesKey = 
L"SOFTWARE\\Microsoft\\IPSec\\QM Policies";


DWORD
PersistQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecQMPoliciesKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegistryKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDWriteQMPolicy(
                  hRegistryKey,
                  pQMPolicy
                  );    
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    if (hRegistryKey) {
        (VOID) SPDPurgeQMPolicy(
                   pQMPolicy->gPolicyID
                   );
    }

    goto cleanup;
}


DWORD
SPDWriteQMPolicy(
    HKEY hParentRegKey,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;
    WCHAR szPolicyID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;


    szPolicyID[0] = L'\0';

    dwError = UuidToString(
                  &pQMPolicy->gPolicyID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszStringUuid);
    wcscat(szPolicyID, L"}");

    dwError = RegCreateKeyExW(
                  hParentRegKey,
                  szPolicyID,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyID",
                  0,
                  REG_SZ,
                  (LPBYTE) szPolicyID,
                  (wcslen(szPolicyID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyName",
                  0,
                  REG_SZ,
                  (LPBYTE) pQMPolicy->pszPolicyName,
                  (wcslen(pQMPolicy->pszPolicyName) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Flags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pQMPolicy->dwFlags,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MarshallQMOffers(
                  pQMPolicy->pOffers,
                  pQMPolicy->dwOfferCount,
                  &pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Offers",
                  0,
                  REG_BINARY,
                  (LPBYTE) pBuffer,
                  dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    goto cleanup;
}


DWORD
MarshallQMOffers(
    PIPSEC_QM_OFFER pOffers,
    DWORD dwOfferCount,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    )
{
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    LPBYTE pMem = NULL;
    static const GUID GUID_IPSEC_QM_OFFER_VER1 =
    { 0xabcd0002, 0x0001, 0x0001, { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } };


    dwBufferSize = sizeof(GUID) +
                   sizeof(DWORD) +
                   sizeof(DWORD) +
                   sizeof(IPSEC_QM_OFFER)*dwOfferCount;

    pBuffer = (LPBYTE) AllocSPDMem(
                           dwBufferSize
                           );
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &GUID_IPSEC_QM_OFFER_VER1,
        sizeof(GUID)
        );
    pMem += sizeof(GUID);

    memcpy(
        pMem,
        (LPBYTE) &dwBufferSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &dwOfferCount,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) pOffers,
        sizeof(IPSEC_QM_OFFER)*dwOfferCount
        );

    *ppBuffer = pBuffer;
    *pdwBufferSize = dwBufferSize;

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferSize = 0;

    return (dwError);
}


DWORD
SPDPurgeQMPolicy(
    GUID gQMPolicyID
    )
{
    DWORD dwError = 0;
    HKEY hParentRegKey = NULL;
    DWORD dwDisposition = 0;
    WCHAR szPolicyID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecQMPoliciesKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hParentRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szPolicyID[0] = L'\0';

    dwError = UuidToString(
                  &gQMPolicyID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszStringUuid);
    wcscat(szPolicyID, L"}");

    dwError = RegDeleteKeyW(
                  hParentRegKey,
                  szPolicyID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hParentRegKey) {
        RegCloseKey(hParentRegKey);
    }

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\rpcserv.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    rpcserv.h

Abstract:

    This module contains the RPC server startup
    and shutdown code prototypes.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
SPDStartRPCServer(
    );


DWORD
SPDStopRPCServer(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\qmp-pers.h ===
DWORD
PersistQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
SPDWriteQMPolicy(
    HKEY hParentRegKey,
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
MarshallQMOffers(
    PIPSEC_QM_OFFER pOffers,
    DWORD dwOfferCount,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    );

DWORD
SPDPurgeQMPolicy(
    GUID gQMPolicyID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\rpcserv.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    rpcserv.c

Abstract:

    This module contains the RPC server startup
    and shutdown code.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
SPDStartRPCServer(
    )
{
    DWORD dwStatus = 0;
    WCHAR * pszPrincipalName = NULL;

    dwStatus = RpcServerUseProtseqEp(
                   L"ncacn_np",
                   10,
                   L"\\pipe\\ipsec",
                   NULL
                   );

    if (dwStatus) {
        if (dwStatus != RPC_S_DUPLICATE_ENDPOINT) {
            return (dwStatus);
        }
    }

    dwStatus = RpcServerUseProtseqEp(
                   L"ncalrpc",
                   10,
                   L"ipsec",
                   NULL
                   );

    if (dwStatus) {
        if (dwStatus != RPC_S_DUPLICATE_ENDPOINT) {
            return (dwStatus);
        }
    }

    dwStatus = RpcServerRegisterIf(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );

    if (dwStatus) {
        return (dwStatus);
    }

    dwStatus = RpcServerRegisterAuthInfo(
                   0,
                   RPC_C_AUTHN_WINNT,
                   0,
                   0
                   );
    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        return (dwStatus);
    }

    dwStatus = RpcServerInqDefaultPrincNameW(
                   RPC_C_AUTHN_GSS_KERBEROS,
                   &pszPrincipalName
                   );
    if (dwStatus == RPC_S_INVALID_AUTH_IDENTITY) {
        dwStatus = ERROR_SUCCESS;
        pszPrincipalName = NULL;
    }

    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        return (dwStatus);
    }

    dwStatus = RpcServerRegisterAuthInfo(
                   pszPrincipalName,
                   RPC_C_AUTHN_GSS_KERBEROS,
                   0,
                   0
                   );
    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        RpcStringFree(&pszPrincipalName);
        return (dwStatus);
    }

    dwStatus = RpcServerRegisterAuthInfo(
                   pszPrincipalName,
                   RPC_C_AUTHN_GSS_NEGOTIATE,
                   0,
                   0
                   );
    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        RpcStringFree(&pszPrincipalName);
        return (dwStatus);
    }

    RpcStringFree(&pszPrincipalName);

    #if !defined(__IN_LSASS__)

        EnterCriticalSection(&gcServerListenSection);

        gdwServersListening++;

        if (gdwServersListening == 1) {

            dwStatus = RpcServerListen(
                           3,
                           RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                           TRUE
                           );

            if (dwStatus) {
                LeaveCriticalSection(&gcServerListenSection);
                (VOID) RpcServerUnregisterIfEx(
                           winipsec_ServerIfHandle,
                           0,
                           0
                           );
                return (dwStatus);
            }

        }

        LeaveCriticalSection(&gcServerListenSection);

    #endif

    gbSPDRPCServerUp = TRUE;
    return (dwStatus);
}


DWORD
SPDStopRPCServer(
    )
{

    DWORD dwStatus = 0;

    dwStatus = RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
   
    #if !defined(__IN_LSASS__)

        EnterCriticalSection(&gcServerListenSection);

        gdwServersListening--;

        if (gdwServersListening == 0) {
            RpcMgmtStopServerListening(0);
        }

        LeaveCriticalSection(&gcServerListenSection);

    #endif

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\spdrpc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    spdrpc.c

Abstract:

    This module contains all of the code to service the
    RPC calls made to the SPD server.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


VOID
TRANSPORTFILTER_HANDLE_rundown(
    TRANSPORTFILTER_HANDLE hFilter
    )
{
    if (!gbSPDRPCServerUp) {
        return;
    }

    if (hFilter) {
        (VOID) DeleteTransportFilter(
                   hFilter
                   );
    }

    return;
}


DWORD
RpcAddTransportFilter(
    STRING_HANDLE pServerName,
    DWORD dwFlags,
    PTRANSPORT_FILTER_CONTAINER pFilterContainer,
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTransportFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTransportFilter = pFilterContainer->pTransportFilters;

    dwError = AddTransportFilter(
                  pServerName,
                  dwFlags,
                  pTransportFilter,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteTransportFilter(
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = DeleteTransportFilter(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumTransportFilters(
    STRING_HANDLE pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTRANSPORT_FILTER_CONTAINER * ppFilterContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilters = NULL;
    DWORD dwNumFilters = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppFilterContainer || !pdwResumeHandle || !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    dwError = EnumTransportFilters(
                  pServerName,
                  dwLevel,
                  gGenericFilterID,
                  &pTransportFilters,
                  dwPreferredNumEntries,
                  &dwNumFilters,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTransportFilters = pTransportFilters;
    (*ppFilterContainer)->dwNumFilters = dwNumFilters;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTransportFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetTransportFilter(
    TRANSPORTFILTER_HANDLE hFilter,
    PTRANSPORT_FILTER_CONTAINER pFilterContainer
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!hFilter || !pFilterContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTransportFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTransportFilter = pFilterContainer->pTransportFilters;

    dwError = SetTransportFilter(
                  hFilter,
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetTransportFilter(
    TRANSPORTFILTER_HANDLE hFilter,
    PTRANSPORT_FILTER_CONTAINER * ppFilterContainer
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!hFilter || !ppFilterContainer || !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetTransportFilter(
                  hFilter,
                  &pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTransportFilters = pTransportFilter;
    (*ppFilterContainer)->dwNumFilters = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTransportFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddQMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pQMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicyContainer->pPolicies) ||
        !(pQMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pQMPolicy = pQMPolicyContainer->pPolicies;

    dwError = AddQMPolicy(
                  pServerName,
                  dwFlags,
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteQMPolicy(
    STRING_HANDLE pServerName,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DeleteQMPolicy(
                  pServerName,
                  pszPolicyName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumQMPolicies(
    STRING_HANDLE pServerName,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    DWORD dwNumPolicies = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppQMPolicyContainer || !pdwResumeHandle || !*ppQMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = EnumQMPolicies(
                  pServerName,
                  &pQMPolicies,
                  dwPreferredNumEntries,
                  &dwNumPolicies,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMPolicyContainer)->pPolicies = pQMPolicies;
    (*ppQMPolicyContainer)->dwNumPolicies = dwNumPolicies;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetQMPolicy(
    STRING_HANDLE pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pszPolicyName || !*pszPolicyName ||
        !pQMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicyContainer->pPolicies) ||
        !(pQMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pQMPolicy = pQMPolicyContainer->pPolicies;

    dwError = SetQMPolicy(
                  pServerName,
                  pszPolicyName,
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetQMPolicy(
    STRING_HANDLE pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pszPolicyName || !*pszPolicyName || !ppQMPolicyContainer ||
        !*ppQMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetQMPolicy(
                  pServerName,
                  pszPolicyName,
                  &pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMPolicyContainer)->pPolicies = pQMPolicy;
    (*ppQMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddMMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwFlags,
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pMMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicyContainer->pPolicies) ||
        !(pMMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMPolicy = pMMPolicyContainer->pPolicies;

    dwError = AddMMPolicy(
                  pServerName,
                  dwFlags,
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMPolicy(
    STRING_HANDLE pServerName,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DeleteMMPolicy(
                  pServerName,
                  pszPolicyName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMPolicies(
    STRING_HANDLE pServerName,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicies = NULL;
    DWORD dwNumPolicies = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppMMPolicyContainer || !pdwResumeHandle || !*ppMMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = EnumMMPolicies(
                  pServerName,
                  &pMMPolicies,
                  dwPreferredNumEntries,
                  &dwNumPolicies,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMPolicyContainer)->pPolicies = pMMPolicies;
    (*ppMMPolicyContainer)->dwNumPolicies = dwNumPolicies;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetMMPolicy(
    STRING_HANDLE pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pszPolicyName || !*pszPolicyName ||
        !pMMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicyContainer->pPolicies) ||
        !(pMMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMPolicy = pMMPolicyContainer->pPolicies;

    dwError = SetMMPolicy(
                  pServerName,
                  pszPolicyName,
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMPolicy(
    STRING_HANDLE pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pszPolicyName || !*pszPolicyName || !ppMMPolicyContainer ||
        !*ppMMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMPolicy(
                  pServerName,
                  pszPolicyName,
                  &pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMPolicyContainer)->pPolicies = pMMPolicy;
    (*ppMMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


VOID
MMFILTER_HANDLE_rundown(
    MMFILTER_HANDLE hMMFilter
    )
{
    if (!gbSPDRPCServerUp) {
        return;
    }

    if (hMMFilter) {
        (VOID) DeleteMMFilter(
                   hMMFilter
                   );
    }

    return;
}


DWORD
RpcAddMMFilter(
    STRING_HANDLE pServerName,
    DWORD dwFlags,
    PMM_FILTER_CONTAINER pMMFilterContainer,
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pMMFilterContainer || !phMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    dwError = AddMMFilter(
                  pServerName,
                  dwFlags,
                  pMMFilter,
                  phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMFilter(
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phMMFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = DeleteMMFilter(
                  *phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phMMFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMFilters(
    STRING_HANDLE pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PMM_FILTER_CONTAINER * ppMMFilterContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilters = NULL;
    DWORD dwNumFilters = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppMMFilterContainer || !pdwResumeHandle || !*ppMMFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    dwError = EnumMMFilters(
                  pServerName,
                  dwLevel,
                  gGenericFilterID,
                  &pMMFilters,
                  dwPreferredNumEntries,
                  &dwNumFilters,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMFilterContainer)->pMMFilters = pMMFilters;
    (*ppMMFilterContainer)->dwNumFilters = dwNumFilters;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMFilterContainer)->pMMFilters = NULL;
    (*ppMMFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetMMFilter(
    MMFILTER_HANDLE hMMFilter,
    PMM_FILTER_CONTAINER pMMFilterContainer
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!hMMFilter || !pMMFilterContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    dwError = SetMMFilter(
                  hMMFilter,
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMFilter(
    MMFILTER_HANDLE hMMFilter,
    PMM_FILTER_CONTAINER * ppMMFilterContainer
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!hMMFilter || !ppMMFilterContainer || !*ppMMFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMFilter(
                  hMMFilter,
                  &pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMFilterContainer)->pMMFilters = pMMFilter;
    (*ppMMFilterContainer)->dwNumFilters = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMFilterContainer)->pMMFilters = NULL;
    (*ppMMFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcMatchMMFilter(
    STRING_HANDLE pServerName,
    PMM_FILTER_CONTAINER pMMFilterContainer,
    DWORD dwFlags,
    PMM_FILTER_CONTAINER * ppMMFilterContainer,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer,
    PMM_AUTH_METHODS_CONTAINER * ppMMAuthContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    PMM_FILTER pMatchedMMFilters = NULL;
    PIPSEC_MM_POLICY pMatchedMMPolicies = NULL;
    PMM_AUTH_METHODS pMatchedMMAuthMethods = NULL;
    DWORD dwNumMatches = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pMMFilterContainer || !ppMMFilterContainer ||
        !ppMMPolicyContainer || !ppMMAuthContainer || !pdwResumeHandle ||
        !*ppMMFilterContainer || !*ppMMPolicyContainer || !*ppMMAuthContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    dwError = MatchMMFilter(
                  pServerName,
                  pMMFilter,
                  dwFlags,
                  &pMatchedMMFilters,
                  &pMatchedMMPolicies,
                  &pMatchedMMAuthMethods,
                  dwPreferredNumEntries,
                  &dwNumMatches,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMFilterContainer)->pMMFilters = pMatchedMMFilters;
    (*ppMMFilterContainer)->dwNumFilters = dwNumMatches;
    (*ppMMPolicyContainer)->pPolicies = pMatchedMMPolicies;
    (*ppMMPolicyContainer)->dwNumPolicies = dwNumMatches;
    (*ppMMAuthContainer)->pMMAuthMethods = pMatchedMMAuthMethods;
    (*ppMMAuthContainer)->dwNumAuthMethods = dwNumMatches;

    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMFilterContainer)->pMMFilters = NULL;
    (*ppMMFilterContainer)->dwNumFilters = 0;
    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    (*ppMMAuthContainer)->pMMAuthMethods = NULL;
    (*ppMMAuthContainer)->dwNumAuthMethods = 0;

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcMatchTransportFilter(
    STRING_HANDLE pServerName,
    PTRANSPORT_FILTER_CONTAINER pTxFilterContainer,
    DWORD dwFlags,
    PTRANSPORT_FILTER_CONTAINER * ppTxFilterContainer,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTxFilter = NULL;
    PTRANSPORT_FILTER pMatchedTxFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumMatches = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pTxFilterContainer || !ppTxFilterContainer ||
        !ppQMPolicyContainer || !pdwResumeHandle ||
        !*ppTxFilterContainer || !*ppQMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pTxFilterContainer->pTransportFilters) ||
        !(pTxFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTxFilter = pTxFilterContainer->pTransportFilters;

    dwError = MatchTransportFilter(
                  pServerName,
                  pTxFilter,
                  dwFlags,
                  &pMatchedTxFilters,
                  &pMatchedQMPolicies,
                  dwPreferredNumEntries,
                  &dwNumMatches,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppTxFilterContainer)->pTransportFilters = pMatchedTxFilters;
    (*ppTxFilterContainer)->dwNumFilters = dwNumMatches;
    (*ppQMPolicyContainer)->pPolicies = pMatchedQMPolicies;
    (*ppQMPolicyContainer)->dwNumPolicies = dwNumMatches;

    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppTxFilterContainer)->pTransportFilters = NULL;
    (*ppTxFilterContainer)->dwNumFilters = 0;
    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetQMPolicyByID(
    STRING_HANDLE pServerName,
    GUID gQMPolicyID,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppQMPolicyContainer || !*ppQMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetQMPolicyByID(
                  pServerName,
                  gQMPolicyID,
                  &pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMPolicyContainer)->pPolicies = pQMPolicy;
    (*ppQMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMPolicyByID(
    STRING_HANDLE pServerName,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppMMPolicyContainer || !*ppMMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMPolicyByID(
                  pServerName,
                  gMMPolicyID,
                  &pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMPolicyContainer)->pPolicies = pMMPolicy;
    (*ppMMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddMMAuthMethods(
    STRING_HANDLE pServerName,
    DWORD dwFlags,
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer
    )
{
    DWORD dwError = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pMMAuthContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMAuthContainer->pMMAuthMethods) ||
        !(pMMAuthContainer->dwNumAuthMethods)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMAuthMethods = pMMAuthContainer->pMMAuthMethods;

    dwError = AddMMAuthMethods(
                  pServerName,
                  dwFlags,
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMAuthMethods(
    STRING_HANDLE pServerName,
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteMMAuthMethods(
                  pServerName,
                  gMMAuthID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMAuthMethods(
    STRING_HANDLE pServerName,
    PMM_AUTH_METHODS_CONTAINER * ppMMAuthContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    DWORD dwNumAuthMethods = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppMMAuthContainer || !pdwResumeHandle || !*ppMMAuthContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = EnumMMAuthMethods(
                  pServerName,
                  &pMMAuthMethods,
                  dwPreferredNumEntries,
                  &dwNumAuthMethods,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMAuthContainer)->pMMAuthMethods = pMMAuthMethods;
    (*ppMMAuthContainer)->dwNumAuthMethods = dwNumAuthMethods;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMAuthContainer)->pMMAuthMethods = NULL;
    (*ppMMAuthContainer)->dwNumAuthMethods = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetMMAuthMethods(
    STRING_HANDLE pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer
    )
{
    DWORD dwError = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pMMAuthContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMAuthContainer->pMMAuthMethods) ||
        !(pMMAuthContainer->dwNumAuthMethods)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMAuthMethods = pMMAuthContainer->pMMAuthMethods;

    dwError = SetMMAuthMethods(
                  pServerName,
                  gMMAuthID,
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMAuthMethods(
    STRING_HANDLE pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS_CONTAINER * ppMMAuthContainer
    )
{
    DWORD dwError = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppMMAuthContainer || !*ppMMAuthContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMAuthMethods(
                  pServerName,
                  gMMAuthID,
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMAuthContainer)->pMMAuthMethods = pMMAuthMethods;
    (*ppMMAuthContainer)->dwNumAuthMethods = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMAuthContainer)->pMMAuthMethods = NULL;
    (*ppMMAuthContainer)->dwNumAuthMethods = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcQueryIPSecStatistics(
    STRING_HANDLE pServerName,
    PIPSEC_STATISTICS_CONTAINER * ppIpsecStatsContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_STATISTICS pIpsecStatistics = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppIpsecStatsContainer || !*ppIpsecStatsContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = QueryIPSecStatistics(
                  pServerName,
                  &pIpsecStatistics
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppIpsecStatsContainer)->pIpsecStatistics = pIpsecStatistics;
    (*ppIpsecStatsContainer)->dwNumIpsecStats = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppIpsecStatsContainer)->pIpsecStatistics = NULL;
    (*ppIpsecStatsContainer)->dwNumIpsecStats = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumQMSAs(
    STRING_HANDLE pServerName,
    PQM_SA_CONTAINER pQMSATempContainer,
    PQM_SA_CONTAINER * ppQMSAContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_SA pQMSATemplate = NULL;
    PIPSEC_QM_SA pQMSAs = NULL;
    DWORD dwNumQMSAs = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pQMSATempContainer || !ppQMSAContainer ||
        !pdwNumTotalQMSAs || !pdwResumeHandle ||
        !*ppQMSAContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pQMSATempContainer->dwNumQMSAs)) {
        pQMSATemplate = NULL;
    }
    else {
        if (!(pQMSATempContainer->pQMSAs)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pQMSATemplate = pQMSATempContainer->pQMSAs;
    }

    dwError = EnumQMSAs(
                  pServerName,
                  pQMSATemplate,
                  &pQMSAs,
                  dwPreferredNumEntries,
                  &dwNumQMSAs,
                  pdwNumTotalQMSAs,
                  pdwResumeHandle,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMSAContainer)->pQMSAs = pQMSAs;
    (*ppQMSAContainer)->dwNumQMSAs = dwNumQMSAs;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMSAContainer)->pQMSAs = NULL;
    (*ppQMSAContainer)->dwNumQMSAs = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


VOID
TUNNELFILTER_HANDLE_rundown(
    TUNNELFILTER_HANDLE hFilter
    )
{
    if (!gbSPDRPCServerUp) {
        return;
    }

    if (hFilter) {
        (VOID) DeleteTunnelFilter(
                   hFilter
                   );
    }

    return;
}


DWORD
RpcAddTunnelFilter(
    STRING_HANDLE pServerName,
    DWORD dwFlags,
    PTUNNEL_FILTER_CONTAINER pFilterContainer,
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTunnelFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTunnelFilter = pFilterContainer->pTunnelFilters;

    dwError = AddTunnelFilter(
                  pServerName,
                  dwFlags,
                  pTunnelFilter,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteTunnelFilter(
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = DeleteTunnelFilter(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumTunnelFilters(
    STRING_HANDLE pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTUNNEL_FILTER_CONTAINER * ppFilterContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilters = NULL;
    DWORD dwNumFilters = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!ppFilterContainer || !pdwResumeHandle || !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    dwError = EnumTunnelFilters(
                  pServerName,
                  dwLevel,
                  gGenericFilterID,
                  &pTunnelFilters,
                  dwPreferredNumEntries,
                  &dwNumFilters,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTunnelFilters = pTunnelFilters;
    (*ppFilterContainer)->dwNumFilters = dwNumFilters;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTunnelFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetTunnelFilter(
    TUNNELFILTER_HANDLE hFilter,
    PTUNNEL_FILTER_CONTAINER pFilterContainer
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!hFilter || !pFilterContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTunnelFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTunnelFilter = pFilterContainer->pTunnelFilters;

    dwError = SetTunnelFilter(
                  hFilter,
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetTunnelFilter(
    TUNNELFILTER_HANDLE hFilter,
    PTUNNEL_FILTER_CONTAINER * ppFilterContainer
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!hFilter || !ppFilterContainer || !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetTunnelFilter(
                  hFilter,
                  &pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTunnelFilters = pTunnelFilter;
    (*ppFilterContainer)->dwNumFilters = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTunnelFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcMatchTunnelFilter(
    STRING_HANDLE pServerName,
    PTUNNEL_FILTER_CONTAINER pTnFilterContainer,
    DWORD dwFlags,
    PTUNNEL_FILTER_CONTAINER * ppTnFilterContainer,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilter = NULL;
    PTUNNEL_FILTER pMatchedTnFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumMatches = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pTnFilterContainer || !ppTnFilterContainer ||
        !ppQMPolicyContainer || !pdwResumeHandle ||
        !*ppTnFilterContainer || !*ppQMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pTnFilterContainer->pTunnelFilters) ||
        !(pTnFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTnFilter = pTnFilterContainer->pTunnelFilters;

    dwError = MatchTunnelFilter(
                  pServerName,
                  pTnFilter,
                  dwFlags,
                  &pMatchedTnFilters,
                  &pMatchedQMPolicies,
                  dwPreferredNumEntries,
                  &dwNumMatches,
                  pdwResumeHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppTnFilterContainer)->pTunnelFilters = pMatchedTnFilters;
    (*ppTnFilterContainer)->dwNumFilters = dwNumMatches;
    (*ppQMPolicyContainer)->pPolicies = pMatchedQMPolicies;
    (*ppQMPolicyContainer)->dwNumPolicies = dwNumMatches;

    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppTnFilterContainer)->pTunnelFilters = NULL;
    (*ppTnFilterContainer)->dwNumFilters = 0;
    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcOpenMMFilterHandle(
    STRING_HANDLE pServerName,
    PMM_FILTER_CONTAINER pMMFilterContainer,
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pMMFilterContainer || !phMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    dwError = OpenMMFilterHandle(
                  pServerName,
                  pMMFilter,
                  phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseMMFilterHandle(
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phMMFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseMMFilterHandle(
                  *phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phMMFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcOpenTransportFilterHandle(
    STRING_HANDLE pServerName,
    PTRANSPORT_FILTER_CONTAINER pFilterContainer,
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTransportFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTransportFilter = pFilterContainer->pTransportFilters;

    dwError = OpenTransportFilterHandle(
                  pServerName,
                  pTransportFilter,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseTransportFilterHandle(
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseTransportFilterHandle(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcOpenTunnelFilterHandle(
    STRING_HANDLE pServerName,
    PTUNNEL_FILTER_CONTAINER pFilterContainer,
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTunnelFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTunnelFilter = pFilterContainer->pTunnelFilters;

    dwError = OpenTunnelFilterHandle(
                  pServerName,
                  pTunnelFilter,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseTunnelFilterHandle(
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseTunnelFilterHandle(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumIpsecInterfaces(
    STRING_HANDLE pServerName,
    PIPSEC_INTERFACE_CONTAINER pIpsecIfTempContainer,
    PIPSEC_INTERFACE_CONTAINER * ppIpsecIfContainer,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate = NULL;
    PIPSEC_INTERFACE_INFO pIpsecInterfaces = NULL;
    DWORD dwNumInterfaces = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (!pIpsecIfTempContainer || !ppIpsecIfContainer ||
        !pdwNumTotalInterfaces || !pdwResumeHandle ||
        !*ppIpsecIfContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pIpsecIfTempContainer->dwNumInterfaces)) {
        pIpsecIfTemplate = NULL;
    }
    else {
        if (!(pIpsecIfTempContainer->pIpsecInterfaces)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIpsecIfTemplate = pIpsecIfTempContainer->pIpsecInterfaces;
    }

    dwError = EnumIPSecInterfaces(
                  pServerName,
                  pIpsecIfTemplate,
                  &pIpsecInterfaces,
                  dwPreferredNumEntries,
                  &dwNumInterfaces,
                  pdwNumTotalInterfaces,
                  pdwResumeHandle,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppIpsecIfContainer)->pIpsecInterfaces = pIpsecInterfaces;
    (*ppIpsecIfContainer)->dwNumInterfaces = dwNumInterfaces;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppIpsecIfContainer)->pIpsecInterfaces = NULL;
    (*ppIpsecIfContainer)->dwNumInterfaces = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteQMSAs(
    STRING_HANDLE pServerName,
    PQM_SA_CONTAINER pQMSAContainer,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pQMSAContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMSAContainer->pQMSAs) ||
        !(pQMSAContainer->dwNumQMSAs)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError= IPSecDeleteQMSAs(
                 pServerName,
                 pQMSAContainer->pQMSAs,
                 dwFlags
                 );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\structs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    structs.h

Abstract:

    This module contains all of the internal structures
    for IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


#define TCP_PROTOCOL     6

#define UDP_PROTOCOL    17


#define WEIGHT_SPECIFIC_SOURCE_PORT         0x00000001
#define WEIGHT_SPECIFIC_DESTINATION_PORT    0x00000002
#define WEIGHT_SPECIFIC_PROTOCOL            0x00000100

#define WEIGHT_TUNNEL_FILTER                0x00001000
#define WEIGHT_SPECIFIC_TUNNEL_FILTER       0x00002000


typedef struct _IPSEC_INTERFACE {

    DWORD dwInterfaceType;
    ULONG IpAddress;
    DWORD dwIndex;
    BOOL bIsASuspect;
    GUID gInterfaceID;
    LPWSTR pszInterfaceName;
    LPWSTR pszDeviceName;
    struct _IPSEC_INTERFACE * pNext;

} IPSEC_INTERFACE, * PIPSEC_INTERFACE;


typedef struct _matching_addr {
    ULONG uIpAddr;
    GUID gInterfaceID;
} MATCHING_ADDR, * PMATCHING_ADDR;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\security.h ===
#define MAX_ACE 6

#define SPD_OBJECT_SERVER 0

#define SPD_OBJECT_COUNT 1

#define SERVER_ACCESS_ADMINISTER 0x00000001

#define SERVER_ACCESS_ENUMERATE 0x00000002

#define SERVER_READ (STANDARD_RIGHTS_READ |\
                     SERVER_ACCESS_ENUMERATE)

#define SERVER_WRITE (STANDARD_RIGHTS_WRITE |\
                      SERVER_ACCESS_ADMINISTER |\
                      SERVER_ACCESS_ENUMERATE)

#define SERVER_EXECUTE (STANDARD_RIGHTS_EXECUTE |\
                        SERVER_ACCESS_ENUMERATE)

#define SERVER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |\
                           SERVER_ACCESS_ADMINISTER |\
                           SERVER_ACCESS_ENUMERATE)


DWORD
InitializeSPDSecurity(
    PSECURITY_DESCRIPTOR * ppSPDSD
    );

DWORD
BuildSPDObjectProtection(
    DWORD dwAceCount,
    PUCHAR pAceType,
    PSID * ppAceSid,
    PACCESS_MASK pAceMask,
    PBYTE pInheritFlags,
    PSID pOwnerSid,
    PSID pGroupSid,
    PGENERIC_MAPPING pGenericMap,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
ValidateSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

VOID
MapGenericToSpecificAccess(
    DWORD dwObjectType,
    ACCESS_MASK GenericAccess,
    PACCESS_MASK pSpecificAccess
    );

BOOL
GetTokenHandle(
    PHANDLE phToken
    );

DWORD
ValidateMMSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

DWORD
ValidateTxSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

DWORD
ValidateTnSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnf-load.h ===
DWORD
LoadPersistedTnFilters(
    HKEY hParentRegKey
    );

DWORD
SPDReadTnFilter(
    HKEY hParentRegKey,
    LPWSTR pszTnFilterUniqueID,
    PTUNNEL_FILTER * ppTnFilter
    );

DWORD
UnMarshallTnFilterBuffer(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PTUNNEL_FILTER pTnFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\spd_s_stub.c ===
#include "spd_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnf-load.c ===
#include "precomp.h"


DWORD
LoadPersistedTnFilters(
    HKEY hParentRegKey
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;
    WCHAR szTnFilterUniqueID[MAX_PATH];
    DWORD dwIndex = 0;
    PTUNNEL_FILTER pTnFilter = NULL;
    LPWSTR pszServerName = NULL;
    HANDLE hTnFilter = NULL;
    DWORD dwPersist = 0;


    dwPersist |= PERSIST_SPD_OBJECT;

    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  L"Tunnel Filters",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    while (1) {

        dwSize = MAX_PATH;
        szTnFilterUniqueID[0] = L'\0';

        dwError = RegEnumKeyExW(
                      hRegKey,
                      dwIndex,
                      szTnFilterUniqueID,
                      &dwSize,
                      NULL,
                      NULL,
                      0,
                      0
                      );

        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        }

        BAIL_ON_WIN32_ERROR(dwError);

        dwError = SPDReadTnFilter(
                      hRegKey,
                      szTnFilterUniqueID,
                      &pTnFilter
                      );

        if (dwError) {
            dwIndex++;
            continue;
        }

        dwError = AddTunnelFilter(
                      pszServerName,
                      dwPersist,
                      pTnFilter,
                      &hTnFilter
                      );

        if (pTnFilter) {
            FreeTnFilters(
                1,
                pTnFilter
                );
        }

        if (hTnFilter) {
            CloseTunnelFilterHandle(hTnFilter);
        }

        dwIndex++;

    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
SPDReadTnFilter(
    HKEY hParentRegKey,
    LPWSTR pszTnFilterUniqueID,
    PTUNNEL_FILTER * ppTnFilter
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    PTUNNEL_FILTER pTnFilter = NULL;
    LPWSTR pszFilterID = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwMirrored = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwInboundFilterFlag = 0;
    DWORD dwOutboundFilterFlag = 0;
    LPWSTR pszPolicyID = NULL;


    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  pszTnFilterUniqueID,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter = (PTUNNEL_FILTER) AllocSPDMem(
                                   sizeof(TUNNEL_FILTER)
                                   );
    if (!pTnFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"FilterID",
                  REG_SZ,
                  (LPBYTE *)&pszFilterID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszFilterID,
        &pTnFilter->gFilterID
        );

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"FilterName",
                  REG_SZ,
                  (LPBYTE *)&pTnFilter->pszFilterName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"InterfaceType",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwInterfaceType,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = (IF_TYPE) dwInterfaceType;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Mirrored",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwMirrored,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->bCreateMirror = (BOOL) dwMirrored;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Flags",
                  NULL,
                  &dwType,
                  (LPBYTE)&pTnFilter->dwFlags,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"Tunnel Filter Buffer",
                  REG_BINARY,
                  (LPBYTE *)&pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallTnFilterBuffer(
                  pBuffer,
                  dwBufferSize,
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"InboundFilterFlag",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwInboundFilterFlag,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InboundFilterFlag = (FILTER_FLAG) dwInboundFilterFlag;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"OutboundFilterFlag",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwOutboundFilterFlag,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->OutboundFilterFlag = (FILTER_FLAG) dwOutboundFilterFlag;

    pTnFilter->dwDirection = 0;

    pTnFilter->dwWeight = 0;

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyID",
                  REG_SZ,
                  (LPBYTE *)&pszPolicyID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszPolicyID,
        &pTnFilter->gPolicyID
        );

    *ppTnFilter = pTnFilter;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszFilterID) {
        FreeSPDStr(pszFilterID);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    if (pszPolicyID) {
        FreeSPDStr(pszPolicyID);
    }

    return (dwError);

error:

    *ppTnFilter = NULL;

    if (pTnFilter) {
        FreeTnFilters(
            1,
            pTnFilter
            );
    }

    goto cleanup;
}


DWORD
UnMarshallTnFilterBuffer(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;


    pMem = pBuffer;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy(
        (LPBYTE) &pTnFilter->SrcAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        (LPBYTE) &pTnFilter->DesAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        (LPBYTE) &pTnFilter->Protocol,
        pMem,
        sizeof(PROTOCOL)
        );
    pMem += sizeof(PROTOCOL);

    memcpy(
        (LPBYTE) &pTnFilter->SrcPort,
        pMem,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    memcpy(
        (LPBYTE) &pTnFilter->DesPort,
        pMem,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    memcpy(
        (LPBYTE) &pTnFilter->SrcTunnelAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        (LPBYTE) &pTnFilter->DesTunnelAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\security.c ===
#include "precomp.h"


GENERIC_MAPPING GenericMapping[SPD_OBJECT_COUNT] = {
    {
      SERVER_READ,
      SERVER_WRITE,
      SERVER_EXECUTE,
      SERVER_ALL_ACCESS
    }
};


DWORD
InitializeSPDSecurity(
    PSECURITY_DESCRIPTOR * ppSPDSD
    )
{
    DWORD dwError = 0;
    BOOL bOK = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID pAdminAliasSid = NULL;
    DWORD dwAceCount = 0;
    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];
    ACCESS_MASK AceMask[MAX_ACE];
    BYTE InheritFlags[MAX_ACE];
    DWORD dwObjectType = SPD_OBJECT_SERVER;
    PSECURITY_DESCRIPTOR pSPDSD = NULL;


    //
    // Administrator Alias SID.
    //

    bOK = AllocateAndInitializeSid(
              &NtAuthority,
              2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS,
              0, 0, 0, 0, 0, 0,
              &pAdminAliasSid
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    AceType[dwAceCount] = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[dwAceCount] = pAdminAliasSid;
    AceMask[dwAceCount] = SERVER_ALL_ACCESS;
    InheritFlags[dwAceCount] = 0;
    dwAceCount++;

    AceType[dwAceCount] = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[dwAceCount] = pAdminAliasSid;
    AceMask[dwAceCount] = GENERIC_ALL;
    InheritFlags[dwAceCount] = INHERIT_ONLY_ACE |
                               CONTAINER_INHERIT_ACE |
                               OBJECT_INHERIT_ACE;
    dwAceCount++;

    if (dwAceCount > MAX_ACE) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = BuildSPDObjectProtection(
                  dwAceCount,
                  AceType,
                  AceSid,
                  AceMask,
                  InheritFlags,
                  pAdminAliasSid,
                  pAdminAliasSid,
                  &GenericMapping[dwObjectType],
                  &pSPDSD
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppSPDSD = pSPDSD;

cleanup:

    if (pAdminAliasSid) {
        FreeSid(pAdminAliasSid);
    }

    return (dwError);

error:

    *ppSPDSD = NULL;

    goto cleanup;
}


DWORD
BuildSPDObjectProtection(
    DWORD dwAceCount,
    PUCHAR pAceType,
    PSID * ppAceSid,
    PACCESS_MASK pAceMask,
    PBYTE pInheritFlags,
    PSID pOwnerSid,
    PSID pGroupSid,
    PGENERIC_MAPPING pGenericMap,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD dwError = 0;
    BOOL bOK = FALSE;
    SECURITY_DESCRIPTOR Absolute;
    DWORD dwDaclLength = 0;
    DWORD i = 0;
    PACL pTmpAcl= NULL;
    PACCESS_ALLOWED_ACE pTmpAce = NULL;
    DWORD dwSDLength = 0;
    PSECURITY_DESCRIPTOR pRelative = NULL;


    bOK = InitializeSecurityDescriptor(
              &Absolute,
              SECURITY_DESCRIPTOR_REVISION1
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = SetSecurityDescriptorOwner(
              &Absolute,
              pOwnerSid,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = SetSecurityDescriptorGroup(
              &Absolute,
              pGroupSid,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Build the Discretionary ACL:
    //     Calculate its length.
    //     Allocate it.
    //     Initialize it.
    //     Add each ACE.
    //     Set ACE as InheritOnly if necessary.
    //     Add it to the security descriptor.
    //

    dwDaclLength = (DWORD) sizeof(ACL);

    for (i = 0; i < dwAceCount; i++) {

        dwDaclLength += GetLengthSid(ppAceSid[i]) +
                        (DWORD) sizeof(ACCESS_ALLOWED_ACE) -
                        (DWORD) sizeof(DWORD);

        //
        // Subtract out SidStart field length.
        //

    }

    pTmpAcl = (PACL) AllocSPDMem(dwDaclLength);

    if (!pTmpAcl) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = InitializeAcl(
              pTmpAcl,
              dwDaclLength,
              ACL_REVISION2
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwAceCount; i++) {

        if (pAceType[i] == ACCESS_ALLOWED_ACE_TYPE) {
            bOK = AddAccessAllowedAce(
                      pTmpAcl,
                      ACL_REVISION2,
                      pAceMask[i],
                      ppAceSid[i]
                      );
        }
        else {
            bOK = AddAccessDeniedAce(
                      pTmpAcl,
                      ACL_REVISION2,
                      pAceMask[i],
                      ppAceSid[i]
                      );
        }
        if (!bOK) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pInheritFlags[i] != 0) {

            bOK = GetAce(pTmpAcl, i, (LPVOID *) &pTmpAce);
            if (!bOK) {
                dwError = GetLastError();
                BAIL_ON_WIN32_ERROR(dwError);
            }

            pTmpAce->Header.AceFlags = pInheritFlags[i];

        }

    }

    bOK = SetSecurityDescriptorDacl(
              &Absolute,
              TRUE,
              pTmpAcl,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Convert the security descriptor from absolute to self-relative:
    //     Get the length needed.
    //     Allocate that much memory.
    //     Copy it.
    //     Free the generated absolute ACLs.
    //

    dwSDLength = GetSecurityDescriptorLength(&Absolute);

    //
    // Must allocate the relative SD from heap.
    //

    pRelative = LocalAlloc(0, dwSDLength);
    if (!pRelative) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = MakeSelfRelativeSD(&Absolute, pRelative, &dwSDLength);
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppSecurityDescriptor = pRelative;

cleanup:

    if (pTmpAcl){
        FreeSPDMem(pTmpAcl);
    }

    return (dwError);

error:

    *ppSecurityDescriptor = NULL;

    if (pRelative) {
        LocalFree(pRelative);
    }

    goto cleanup;
}


DWORD
ValidateSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    ACCESS_MASK MappedDesiredAccess = 0;
    BOOL bOK = FALSE;
    HANDLE hClientToken = NULL;
    BYTE PrivilegeSetBuffer[256];
    DWORD dwPrivilegeSetBufferLen = 256;
    PPRIVILEGE_SET pPrivilegeSet = NULL;
    BOOL bAccessCheckOK = FALSE;
    ACCESS_MASK GrantedAccess = 0;
    BOOL bAccessStatus = FALSE;


    memset(PrivilegeSetBuffer, 0, dwPrivilegeSetBufferLen);

    switch (dwObjectType) {

    case SPD_OBJECT_SERVER:
        pSecurityDescriptor = gpSPDSD;
        break;

    default:
        dwError = ERROR_ACCESS_DENIED;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    MapGenericToSpecificAccess(
        dwObjectType,
        DesiredAccess,
        &MappedDesiredAccess
        );

    bOK = GetTokenHandle(&hClientToken);
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;

    bAccessCheckOK = AccessCheck(
                         pSecurityDescriptor,
                         hClientToken,
                         MappedDesiredAccess,
                         &GenericMapping[dwObjectType],
                         pPrivilegeSet,
                         &dwPrivilegeSetBufferLen,
                         &GrantedAccess,
                         &bAccessStatus
                         );
    if (!bAccessCheckOK) {
        if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN) {
            dwError = ERROR_SUCCESS;
            GrantedAccess = MappedDesiredAccess;
        }
        else {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        if (!bAccessStatus) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

cleanup:

    if (hClientToken) {
        CloseHandle(hClientToken);
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    goto cleanup;
}


VOID
MapGenericToSpecificAccess(
    DWORD dwObjectType,
    ACCESS_MASK GenericAccess,
    PACCESS_MASK pSpecificAccess
    )
{
    *pSpecificAccess = GenericAccess;

    MapGenericMask(
        pSpecificAccess,
        &GenericMapping[dwObjectType]
        );
}


BOOL
GetTokenHandle(
    PHANDLE phToken
    )
{
    if (!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            phToken)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            //
            // This means that there's no impersonation.
            // Get the token out of the process.
            //

            if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                    phToken)) {
                return (FALSE);
            }

        } 
        else {
            return (FALSE);
        }

    }

    return (TRUE);
}


DWORD
ValidateMMSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}


DWORD
ValidateTxSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}


DWORD
ValidateTnSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnf-pers.c ===
#include "precomp.h"


LPWSTR gpszIpsecTnFiltersKey = 
L"SOFTWARE\\Microsoft\\IPSec\\Tunnel Filters";


DWORD
PersistTnFilter(
    GUID gFilterID,
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecTnFiltersKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegistryKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDWriteTnFilter(
                  hRegistryKey,
                  gFilterID,
                  pTnFilter
                  );    
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    if (hRegistryKey) {
        (VOID) SPDPurgeTnFilter(
                   gFilterID
                   );
    }

    goto cleanup;
}


DWORD
SPDWriteTnFilter(
    HKEY hParentRegKey,
    GUID gFilterID,
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    WCHAR szFilterID[MAX_PATH];
    WCHAR szPolicyID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszPolicyUuid = NULL;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwMirrored = 0;
    DWORD dwInboundFilterFlag = 0;
    DWORD dwOutboundFilterFlag = 0;


    szFilterID[0] = L'\0';
    szPolicyID[0] = L'\0';

    dwError = UuidToString(
                  &gFilterID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szFilterID, L"{");
    wcscat(szFilterID, pszStringUuid);
    wcscat(szFilterID, L"}");

    dwError = UuidToString(
                  &pTnFilter->gPolicyID,
                  &pszPolicyUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszPolicyUuid);
    wcscat(szPolicyID, L"}");

    dwError = RegCreateKeyExW(
                  hParentRegKey,
                  szFilterID,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"FilterID",
                  0,
                  REG_SZ,
                  (LPBYTE) szFilterID,
                  (wcslen(szFilterID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"FilterName",
                  0,
                  REG_SZ,
                  (LPBYTE) pTnFilter->pszFilterName,
                  (wcslen(pTnFilter->pszFilterName) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwInterfaceType = (DWORD) pTnFilter->InterfaceType;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"InterfaceType",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwInterfaceType,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwMirrored = (DWORD) pTnFilter->bCreateMirror;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"Mirrored",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwMirrored,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Flags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pTnFilter->dwFlags,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MarshallTnFilterBuffer(
                  pTnFilter,
                  &pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Tunnel Filter Buffer",
                  0,
                  REG_BINARY,
                  (LPBYTE) pBuffer,
                  dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwInboundFilterFlag = (DWORD) pTnFilter->InboundFilterFlag;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"InboundFilterFlag",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwInboundFilterFlag,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwOutboundFilterFlag = (DWORD) pTnFilter->OutboundFilterFlag;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"OutboundFilterFlag",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwOutboundFilterFlag,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyID",
                  0,
                  REG_SZ,
                  (LPBYTE) szPolicyID,
                  (wcslen(szPolicyID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (pszPolicyUuid) {
        RpcStringFree(&pszPolicyUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    goto cleanup;
}


DWORD
MarshallTnFilterBuffer(
    PTUNNEL_FILTER pTnFilter,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    )
{
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    LPBYTE pMem = NULL;
    static const GUID GUID_IPSEC_TN_FILTER_VER1 =
    { 0xabcd0006, 0x0001, 0x0001, { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } };


    dwBufferSize = sizeof(GUID) +
                   sizeof(DWORD) +
                   sizeof(ADDR) +
                   sizeof(ADDR) +
                   sizeof(PROTOCOL) +
                   sizeof(PORT) +
                   sizeof(PORT) +
                   sizeof(ADDR) +
                   sizeof(ADDR);

    pBuffer = (LPBYTE) AllocSPDMem(
                           dwBufferSize
                           );
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &GUID_IPSEC_TN_FILTER_VER1,
        sizeof(GUID)
        );
    pMem += sizeof(GUID);

    memcpy(
        pMem,
        (LPBYTE) &dwBufferSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->SrcAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->DesAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->Protocol,
        sizeof(PROTOCOL)
        );
    pMem += sizeof(PROTOCOL);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->SrcPort,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->DesPort,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->SrcTunnelAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        pMem,
        (LPBYTE) &pTnFilter->DesTunnelAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    *ppBuffer = pBuffer;
    *pdwBufferSize = dwBufferSize;

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferSize = 0;

    return (dwError);
}


DWORD
SPDPurgeTnFilter(
    GUID gTnFilterID
    )
{
    DWORD dwError = 0;
    HKEY hParentRegKey = NULL;
    DWORD dwDisposition = 0;
    WCHAR szFilterID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecTnFiltersKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hParentRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szFilterID[0] = L'\0';

    dwError = UuidToString(
                  &gTnFilterID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szFilterID, L"{");
    wcscat(szFilterID, pszStringUuid);
    wcscat(szFilterID, L"}");

    dwError = RegDeleteKeyW(
                  hParentRegKey,
                  szFilterID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hParentRegKey) {
        RegCloseKey(hParentRegKey);
    }

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnf-pers.h ===
DWORD
PersistTnFilter(
    GUID gFilterID,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
SPDWriteTnFilter(
    HKEY hParentRegKey,
    GUID gFilterID,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
MarshallTnFilterBuffer(
    PTUNNEL_FILTER pTnFilter,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    );

DWORD
SPDPurgeTnFilter(
    GUID gTnFilterID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txf-load.h ===
DWORD
LoadPersistedTxFilters(
    HKEY hParentRegKey
    );

DWORD
SPDReadTxFilter(
    HKEY hParentRegKey,
    LPWSTR pszTxFilterUniqueID,
    PTRANSPORT_FILTER * ppTxFilter
    );

DWORD
UnMarshallTxFilterBuffer(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PTRANSPORT_FILTER pTxFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnfilter.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnfilter.h

Abstract:

    This module contains all of the code prototypes to
    drive the tunnel filter list management of
    IPSecSPD Service.

Author:


Environment: User Mode


Revision History:


--*/


typedef struct _initnfilter {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    ADDR SrcTunnelAddr;
    ADDR DesTunnelAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD cRef;
    BOOL bIsPersisted;
    BOOL bPendingDeletion;
    GUID gPolicyID;
    PINIQMPOLICY pIniQMPolicy;
    DWORD dwNumTnSFilters;
    struct _initnsfilter ** ppIniTnSFilters;
    struct _initnfilter * pNext;
} INITNFILTER, * PINITNFILTER;


typedef struct _initnsfilter {
    GUID gParentID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    ADDR SrcTunnelAddr;
    ADDR DesTunnelAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD cRef;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
    PINIQMPOLICY pIniQMPolicy;
    struct _initnsfilter * pNext;
} INITNSFILTER, * PINITNSFILTER;


typedef struct _tn_filter_handle {
    PINITNFILTER pIniTnFilter;
    GUID gFilterID;
    struct _tn_filter_handle * pNext;
} TN_FILTER_HANDLE, * PTN_FILTER_HANDLE;


DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTnFilter
    );

PINITNFILTER
FindTnFilterByGuid(
    PTN_FILTER_HANDLE pTnFilterHandleList,
    GUID gFilterID
    );
  
PINITNFILTER
FindTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTnFilter
    );

BOOL
EqualTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
CreateIniTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER * ppIniTnFilter
    );

DWORD
CreateIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITNSFILTER * ppIniTnSFilters
    );

DWORD
CreateIniMirroredTnFilter(
    PINITNFILTER pFilter,
    PINITNFILTER * ppMirroredFilter
    );

BOOL
EqualIniTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PINITNFILTER pFilter
    );

DWORD
CreateTnFilterHandle(
    PINITNFILTER pIniTnFilter,
    GUID gFilterID,
    PTN_FILTER_HANDLE * ppTnFilterHandle
    );

DWORD
CreateSpecificTnFilterLinks(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER pIniTnSFilters
    );

VOID
LinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    );

VOID
FreeIniTnFilterList(
    PINITNFILTER pIniTnFilterList
    );

VOID
FreeIniTnFilter(
    PINITNFILTER pIniTnFilter
    );

DWORD
DeleteIniTnFilter(
    PINITNFILTER pIniTnFilter
    );

VOID
DelinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    );

DWORD
DeleteIniTnSFilters(
    PINITNFILTER pIniTnFilter
    );

VOID
RemoveIniTnFilter(
    PINITNFILTER pIniTnFilter
    );

VOID
RemoveTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    );

VOID
FreeTnFilterHandleList(
    PTN_FILTER_HANDLE pTnFilterHandleList
    );

VOID
FreeTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    );

DWORD
EnumGenericTnFilters(
    PINITNFILTER pIniTnFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    );

DWORD
CopyTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

VOID
FreeTnFilters(
    DWORD dwNumTnFilters,
    PTUNNEL_FILTER pTnFilters
    );

DWORD
SetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

BOOL
EqualTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
CreateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    );

VOID
RemoveTnSFilters(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER * ppIniCurTnSFilters 
    );

VOID
UpdateTnSFilterLinks(
    PINITNFILTER pIniTnFilter,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    );

VOID
UpdateTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    LPWSTR pszFilterName,
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    );

DWORD
GetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER * ppTnFilter
    );

DWORD
ApplyIfChangeToIniTnFilters(
    PDWORD pdwTnError,
    PIPSEC_INTERFACE pLatestIfList
    );

DWORD
UpdateIniTnFilterThruIfChange(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pLatestIfList
    );

DWORD
FormIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pIfList,
    PINITNSFILTER * ppIniTnSFilters
    );

VOID
ProcessIniTnSFilters(
    PINITNSFILTER * ppLatestIniTnSFilters,
    PINITNSFILTER * ppCurIniTnSFilters,
    PINITNSFILTER * ppNewIniTnSFilters,
    PINITNSFILTER * ppOldIniTnSFilters
    );

BOOL
EqualIniTnSFilterIfPKeys(
    PINITNSFILTER pExsIniTnSFilter,
    PINITNSFILTER pNewIniTnSFilter
    );

DWORD
AllocateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    );

VOID
SetTnSFilterLinks(
    PINITNSFILTER pCurIniTnSFilters,
    PINITNSFILTER pNewIniTnSFilters,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    );

VOID
AddToGenericTnList(
    PINITNFILTER pIniTnFilter
    );

PINITNFILTER
FindExactTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTnFilter
    );

BOOL
EqualMirroredTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnfilter.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnfilter.c

Abstract:

    This module contains all of the code to drive
    the tunnel filter list management of IPSecSPD
    Service.

Author:

    abhisheV    05-October-1999

Environment: User Mode


Revision History:


--*/


#include "precomp.h"


DWORD
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phTnFilter
    )
/*++

Routine Description:

    This function adds a generic tunnel filter to the SPD.

Arguments:

    pServerName - Server on which the tunnel filter is to be added.

    pTunnelFilter - Tunnel Filter to be added.

    phTnFilter -  Handle to the filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNFILTER pIniExistsTnFilter = NULL;
    PINITNFILTER pIniTnFilter = NULL;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PINITNSFILTER pIniTnSFilters = NULL;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    BOOL bPersist = FALSE;


    bPersist = (BOOL) (dwFlags & PERSIST_SPD_OBJECT);

    if (!phTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external tunnel filter.
    //

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistsTnFilter = FindTnFilter(
                             gpIniTnFilter,
                             pTunnelFilter
                             );
    if (pIniExistsTnFilter) {
        //
        // TODO: Also need to check for filter flags and policy id.
        //
        dwError = ERROR_IPSEC_TUNNEL_FILTER_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniExistsTnFilter = FindTnFilterByGuid(
                             gpTnFilterHandle,
                             pTunnelFilter->gFilterID
                             );
    if (pIniExistsTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if ((pTunnelFilter->InboundFilterFlag == NEGOTIATE_SECURITY) ||
        (pTunnelFilter->OutboundFilterFlag == NEGOTIATE_SECURITY)) {

        dwError = LocateQMPolicy(
                      pTunnelFilter->dwFlags,
                      pTunnelFilter->gPolicyID,
                      &pIniQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }

    if (bPersist && !gbLoadingPersistence) {
        dwError = PersistTnFilter(
                      pTunnelFilter->gFilterID,
                      pTunnelFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniTnFilter(
                  pTunnelFilter,
                  pIniQMPolicy,
                  &pIniTnFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnFilter->bIsPersisted = bPersist;

    dwError = GetMatchingInterfaces(
                  pIniTnFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateIniTnSFilters(
                  pIniTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniTnSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateTnFilterHandle(
                  pIniTnFilter,
                  pTunnelFilter->gFilterID,
                  &pTnFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateSpecificTnFilterLinks(
                  pIniTnFilter,
                  pIniTnSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = InsertTunnelFiltersIntoIPSec(
                  pIniTnSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniQMPolicy) {
        LinkTnFilter(
            pIniQMPolicy,
            pIniTnFilter
            );
        LinkTnSpecificFilters(
            pIniQMPolicy,
            pIniTnSFilters
            );
    }

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pIniTnSFilters
        );

    pIniTnFilter->cRef = 1;

    AddToGenericTnList(
        pIniTnFilter
        );

    pTnFilterHandle->pNext = gpTnFilterHandle;
    gpTnFilterHandle = pTnFilterHandle;

    *phTnFilter = (HANDLE) pTnFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pTunnelFilter && bPersist && !gbLoadingPersistence) {
        (VOID) SPDPurgeTnFilter(
                   pTunnelFilter->gFilterID
                   );
    }

    if (pIniTnFilter) {
        FreeIniTnFilter(pIniTnFilter);
    }

    if (pIniTnSFilters) {
        FreeIniTnSFilterList(pIniTnSFilters);
    }

    if (pTnFilterHandle) {
        FreeTnFilterHandle(pTnFilterHandle);
    }

    *phTnFilter = NULL;
    goto cleanup;
}


DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function validates an external generic tunnel filter.

Arguments:

    pTnFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTnFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTnFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTnFilter->SrcAddr,
                     pTnFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTnFilter->DesTunnelAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTnFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->SrcPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->DesPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTnFilter->pszFilterName) || !(*(pTnFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTnFilter->InterfaceType >= INTERFACE_TYPE_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTnFilter->bCreateMirror) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTnFilter->InboundFilterFlag >= FILTER_FLAG_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTnFilter->OutboundFilterFlag >= FILTER_FLAG_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTnFilter->dwFlags &&
        !(pTnFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // No need to call ApplyMulticastFilterValidation as bCreateMirror
    // is always false for a tunnel filter.
    //

error:

    return (dwError);
}


PINITNFILTER
FindTnFilterByGuid(
    PTN_FILTER_HANDLE pTnFilterHandleList,
    GUID gFilterID
    )
{
    BOOL bEqual = FALSE;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;


    pTnFilterHandle = pTnFilterHandleList;

    while (pTnFilterHandle) {

        bEqual = AreGuidsEqual(
                     pTnFilterHandle->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pTnFilterHandle->pIniTnFilter);
        }
        pTnFilterHandle = pTnFilterHandle->pNext;

    }

    return (NULL);
}


PINITNFILTER
FindTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function looks for a filter in the filter list.

Arguments:

    pGenericTnList - Filter list in which to search.

    pTnFilter - Filter to search for in the filter list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    PINITNFILTER pIniTnFilter = NULL;
    BOOL bEqual = FALSE;

    pIniTnFilter = pGenericTnList;

    while (pIniTnFilter) {

        bEqual = EqualTnFilterPKeys(
                     pIniTnFilter,
                     pTnFilter
                     );
        if (bEqual) {
            return (pIniTnFilter);
        }

        bEqual = EqualMirroredTnFilterPKeys(
                     pIniTnFilter,
                     pTnFilter
                     );
        if (bEqual) {
            return (pIniTnFilter);
        }

        pIniTnFilter = pIniTnFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function compares an internal and an external tunnel 
    filter for equality.

Arguments:

    pIniTnFilter - Filter to compare.

    pTnFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTnFilter->SrcAddr, pTnFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesAddr, pTnFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesTunnelAddr, pTnFilter->DesTunnelAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->SrcPort, pTnFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->DesPort, pTnFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTnFilter->Protocol, pTnFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniTnFilter->InterfaceType != pTnFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniTnFilter->bCreateMirror != pTnFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateIniTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER * ppIniTnFilter
    )
/*++

Routine Description:

    This function creates an internal generic tunnel filter from
    the external filter.

Arguments:

    pTnFilter - External generic tunnel filter.

    pIniQMPolicy - QM Policy corresponding to the filter.

    ppIniTnFilter - Internal generic tunnel filter created from
                    the external filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNFILTER pIniTnFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INITNFILTER),
                    &pIniTnFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniTnFilter->cRef = 0;

    pIniTnFilter->bIsPersisted = FALSE;

    pIniTnFilter->bPendingDeletion = FALSE;

    CopyGuid(pTnFilter->gFilterID, &(pIniTnFilter->gFilterID));

    dwError = AllocateSPDString(
                  pTnFilter->pszFilterName,
                  &(pIniTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniTnFilter->InterfaceType = pTnFilter->InterfaceType;

    pIniTnFilter->bCreateMirror = pTnFilter->bCreateMirror;

    pIniTnFilter->dwFlags = pTnFilter->dwFlags;

    CopyAddresses(pTnFilter->SrcAddr, &(pIniTnFilter->SrcAddr));

    CopyAddresses(pTnFilter->DesAddr, &(pIniTnFilter->DesAddr));

    CopyAddresses(pTnFilter->SrcTunnelAddr, &(pIniTnFilter->SrcTunnelAddr));

    CopyAddresses(pTnFilter->DesTunnelAddr, &(pIniTnFilter->DesTunnelAddr));

    CopyPorts(pTnFilter->SrcPort, &(pIniTnFilter->SrcPort));

    CopyPorts(pTnFilter->DesPort, &(pIniTnFilter->DesPort));

    CopyProtocols(pTnFilter->Protocol, &(pIniTnFilter->Protocol));

    pIniTnFilter->InboundFilterFlag = pTnFilter->InboundFilterFlag;

    pIniTnFilter->OutboundFilterFlag = pTnFilter->OutboundFilterFlag;

    if (pIniQMPolicy) {
        CopyGuid(pIniQMPolicy->gPolicyID, &(pIniTnFilter->gPolicyID));
    }
    else {
        CopyGuid(pTnFilter->gPolicyID, &(pIniTnFilter->gPolicyID));
    }

    pIniTnFilter->pIniQMPolicy = NULL;

    pIniTnFilter->dwNumTnSFilters = 0;

    pIniTnFilter->ppIniTnSFilters = NULL;

    pIniTnFilter->pNext = NULL;

    *ppIniTnFilter = pIniTnFilter;
    return (dwError);

error:

    if (pIniTnFilter) {
        FreeIniTnFilter(pIniTnFilter);
    }

    *ppIniTnFilter = NULL;
    return (dwError);
}


DWORD
CreateIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITNSFILTER * ppIniTnSFilters
    )
/*++

Routine Description:

    This function expands a generic filter into a set of specific
    filters.

Arguments:

    pIniTnFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Count of local ip addresses in the list.

    ppIniTnSFilters - Expanded specific filters.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pSpecificFilters = NULL;
    PINITNFILTER pMirroredFilter = NULL;
    PINITNSFILTER pMirroredSpecificFilters = NULL;
    BOOL bEqual = FALSE;


    if (!dwAddrCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = ApplyTnTransform(
                  pIniTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTnFilter->bCreateMirror) {

        dwError = CreateIniMirroredTnFilter(
                      pIniTnFilter,
                      &pMirroredFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        bEqual = EqualIniTnFilterPKeys(
                     pIniTnFilter,
                     pMirroredFilter
                     );
        if (!bEqual) {

            dwError = ApplyTnTransform(
                          pMirroredFilter,
                          pMatchingAddresses,
                          dwAddrCnt,
                          &pMirroredSpecificFilters
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            AddToSpecificTnList(
                &pSpecificFilters,
                pMirroredSpecificFilters
                );

        }

    }

    *ppIniTnSFilters = pSpecificFilters;

cleanup:

    if (pMirroredFilter) {
        FreeIniTnFilter(pMirroredFilter);
    }

    return (dwError);

success:
error:

    if (pSpecificFilters) {
        FreeIniTnSFilterList(pSpecificFilters);
    }

    *ppIniTnSFilters = NULL;
    goto cleanup;
}


DWORD
CreateIniMirroredTnFilter(
    PINITNFILTER pFilter,
    PINITNFILTER * ppMirroredFilter
    )
/*++

Routine Description:

    This function creates a mirrored filter for the given filter.

Arguments:

    pFilter - Filter for which to create the mirror.

    ppMirroredFilter - Mirrored filter created for the given filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNFILTER pMirroredFilter = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INITNFILTER),
                  &pMirroredFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->cRef = pFilter->cRef;

    pMirroredFilter->bIsPersisted = pFilter->bIsPersisted;

    pMirroredFilter->bPendingDeletion = pFilter->bPendingDeletion;

    CopyGuid(pFilter->gFilterID, &(pMirroredFilter->gFilterID));

    dwError = AllocateSPDString(
                  pFilter->pszFilterName,
                  &(pMirroredFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->InterfaceType = pFilter->InterfaceType;

    pMirroredFilter->bCreateMirror = pFilter->bCreateMirror;

    pMirroredFilter->dwFlags = pFilter->dwFlags;

    CopyAddresses(pFilter->DesAddr, &(pMirroredFilter->SrcAddr));

    CopyAddresses(pFilter->SrcAddr, &(pMirroredFilter->DesAddr));

    CopyAddresses(pFilter->DesTunnelAddr, &(pMirroredFilter->SrcTunnelAddr));

    CopyAddresses(pFilter->SrcTunnelAddr, &(pMirroredFilter->DesTunnelAddr));

    CopyPorts(pFilter->DesPort, &(pMirroredFilter->SrcPort));

    CopyPorts(pFilter->SrcPort, &(pMirroredFilter->DesPort));

    CopyProtocols(pFilter->Protocol, &(pMirroredFilter->Protocol));

    pMirroredFilter->InboundFilterFlag = pFilter->InboundFilterFlag;

    pMirroredFilter->OutboundFilterFlag = pFilter->OutboundFilterFlag;

    CopyGuid(pFilter->gPolicyID, &(pMirroredFilter->gPolicyID));

    pMirroredFilter->pIniQMPolicy = NULL;

    pMirroredFilter->dwNumTnSFilters = 0;

    pMirroredFilter->ppIniTnSFilters = NULL;

    pMirroredFilter->pNext = NULL;

    *ppMirroredFilter = pMirroredFilter;
    return (dwError);

error:

    if (pMirroredFilter) {
        FreeIniTnFilter(pMirroredFilter);
    }

    *ppMirroredFilter = NULL;
    return (dwError);
}


BOOL
EqualIniTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PINITNFILTER pFilter
    )
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTnFilter->SrcAddr, pFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesAddr, pFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesTunnelAddr, pFilter->DesTunnelAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->SrcPort, pFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->DesPort, pFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTnFilter->Protocol, pFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniTnFilter->InterfaceType != pFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniTnFilter->bCreateMirror != pFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateTnFilterHandle(
    PINITNFILTER pIniTnFilter,
    GUID gFilterID,
    PTN_FILTER_HANDLE * ppTnFilterHandle
    )
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(TN_FILTER_HANDLE),
                    &pTnFilterHandle
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilterHandle->pIniTnFilter= pIniTnFilter;
    CopyGuid(gFilterID, &(pTnFilterHandle->gFilterID));
    pTnFilterHandle->pNext = NULL;

    *ppTnFilterHandle = pTnFilterHandle;
    return (dwError);

error:

    *ppTnFilterHandle = NULL;
    return (dwError);
}


DWORD
CreateSpecificTnFilterLinks(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER pIniTnSFilters
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwCnt = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTnSFilters;

    while (pTemp) {
        dwCnt++;
        pTemp = pTemp->pNext;
    }

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIniTnFilter->ppIniTnSFilters = (PINITNSFILTER *)
                                    AllocSPDMem(
                                        sizeof(PINITNSFILTER)*dwCnt
                                        );
    if (!(pIniTnFilter->ppIniTnSFilters)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);    
    }

    pTemp = pIniTnSFilters;
    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;

    for (i = 0; i < dwCnt; i++) {
        *(ppIniTnSFilters + i) = pTemp; 
        pTemp = pTemp->pNext;
    }
    pIniTnFilter->dwNumTnSFilters = dwCnt;

error:

    return (dwError);
}


VOID
LinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    )
{
    pIniQMPolicy->cRef++;
    pIniTnFilter->pIniQMPolicy = pIniQMPolicy;
    return;
}


VOID
FreeIniTnFilterList(
    PINITNFILTER pIniTnFilterList
    )
{
    PINITNFILTER pFilter = NULL;
    PINITNFILTER pTempFilter = NULL;

    pFilter = pIniTnFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniTnFilter(pTempFilter);
    }
}


VOID
FreeIniTnFilter(
    PINITNFILTER pIniTnFilter
    )
{
    if (pIniTnFilter) {
        if (pIniTnFilter->pszFilterName) {
            FreeSPDString(pIniTnFilter->pszFilterName);
        }

        //
        // Must not ever free pIniTnFilter->pIniQMPolicy.
        //

        //
        // Must not ever free memory pointed by each of
        // the pointers in pIniTnFilter->ppIniTnSFilters.
        //

        if (pIniTnFilter->ppIniTnSFilters) {
            FreeSPDMemory(pIniTnFilter->ppIniTnSFilters);
        }

        FreeSPDMemory(pIniTnFilter);
    }
}


DWORD
DeleteTunnelFilter(
    HANDLE hTnFilter
    )
/*++

Routine Description:

    This function deletes a generic tunnel filter from the SPD.

Arguments:

    hTnFilter -  Handle to the filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;


    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTnFilter->cRef > 1) {

        pIniTnFilter->cRef--;
        pIniTnFilter->bPendingDeletion = TRUE;

        RemoveTnFilterHandle(
            pFilterHandle
            );

        FreeTnFilterHandle(
            pFilterHandle
            );


        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    if (pIniTnFilter->bIsPersisted) {
        dwError = SPDPurgeTnFilter(
                      pIniTnFilter->gFilterID
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniTnFilter(
                  pIniTnFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    //
    // Delete the filter handle from the list of tunnel handles.
    //

    RemoveTnFilterHandle(
        pFilterHandle
        );

    FreeTnFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


DWORD
DeleteIniTnFilter(
    PINITNFILTER pIniTnFilter
    )
/*++

Routine Description:

    This function physically deletes a tunnel filter and all the
    specific tunnel filters expanded out of it.

Arguments:

    pIniTnFilter - Generic filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    dwError = DeleteIniTnSFilters(
                  pIniTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTnFilter->pIniQMPolicy) {
        DelinkTnFilter(
            pIniTnFilter->pIniQMPolicy,
            pIniTnFilter
            );
    }

    RemoveIniTnFilter(
        pIniTnFilter
        );

    FreeIniTnFilter(pIniTnFilter);

error:

    return (dwError);
}


VOID
DelinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    )
{
    pIniQMPolicy->cRef--;
    pIniTnFilter->pIniQMPolicy = NULL;
    return;
}


DWORD
DeleteIniTnSFilters(
    PINITNFILTER pIniTnFilter
    )
{
    DWORD dwError = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    DWORD i = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    PINITNSFILTER pIniRemoveTnSFilter = NULL;
    PINITNSFILTER pTemp = NULL;


    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;
    dwNumTnSFilters = pIniTnFilter->dwNumTnSFilters;

    for (i = 0; i < dwNumTnSFilters; i++) {

       //
       // Remove each entry from the Tunnel Specific Filter List.
       //

        pIniTnSFilter =  *(ppIniTnSFilters + i);
        RemoveIniTnSFilter(pIniTnSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniTnSFilter->pNext = NULL;
        AddToSpecificTnList(
            &pIniRemoveTnSFilter,
            pIniTnSFilter
            );

    }

    //
    // Delete the specific filters from the IPSec Driver.
    //

    dwError = DeleteTunnelFiltersFromIPSec(
                  pIniRemoveTnSFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Physically delete the removed list.
    //

    while (pIniRemoveTnSFilter) {
        pTemp = pIniRemoveTnSFilter;
        pIniRemoveTnSFilter = pIniRemoveTnSFilter->pNext;
        FreeIniTnSFilter(pTemp);
    }

    return (dwError);

error :

    if (pIniRemoveTnSFilter) {
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pIniRemoveTnSFilter
            );
    }

    return (dwError);
}


VOID
RemoveIniTnFilter(
    PINITNFILTER pIniTnFilter
    )
{
    PINITNFILTER * ppTemp = NULL;

    ppTemp = &gpIniTnFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniTnFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniTnFilter->pNext;
    }

    return;
}


VOID
RemoveTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    )
{
    PTN_FILTER_HANDLE * ppTemp = NULL;

    ppTemp = &gpTnFilterHandle;

    while (*ppTemp) {

        if (*ppTemp == pTnFilterHandle) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pTnFilterHandle->pNext;
    }

    return;
}


VOID
FreeTnFilterHandleList(
    PTN_FILTER_HANDLE pTnFilterHandleList
    )
{
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;
    PTN_FILTER_HANDLE pTemp = NULL;

    pTnFilterHandle = pTnFilterHandleList;

    while (pTnFilterHandle) {
        pTemp = pTnFilterHandle;
        pTnFilterHandle = pTnFilterHandle->pNext;
        FreeTnFilterHandle(pTemp);
    }
}


VOID
FreeTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    )
{
    if (pTnFilterHandle) {
        FreeSPDMemory(pTnFilterHandle);
    }
    return;
}


DWORD
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,  
    PTUNNEL_FILTER * ppTunnelFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumTnFilters,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function enumerates tunnel filters from the SPD.

Arguments:

    pServerName - Server on which the filters are to be enumerated.

    dwLevel - Level to identify the type of enumeration desired:
              (i) enumerate generic tunnel filters or
              (ii) enumerate specific tunnel filters or
              (iii) enumerate specific tunnel filters for a 
                    generic tunnel filter.

    gGenericFilterID - Filter id of the generic tunnel filter 
                       in the case when the specific tunnel filters
                       for a generic filter are to be enumerated.
 
    ppTunnelFilters - Enumerated Filters returned to the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumTnFilters - Number of filters actually enumerated.

    pdwResumeHandle - Handle to the location in the filter list from
                      which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    DWORD dwNumTnFilters = 0;
    PINITNFILTER pIniTnFilter = NULL;


    if (!ppTunnelFilters || !pdwNumTnFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:

        dwError = EnumGenericTnFilters(
                      gpIniTnFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTnFilters,
                      &dwNumTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SELECT_SPECIFIC_FILTERS:

        pIniTnFilter = FindTnFilterByGuid(
                           gpTnFilterHandle,
                           gGenericFilterID
                           );
        if (!pIniTnFilter) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = EnumSelectSpecificTnFilters(
                      pIniTnFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTnFilters,
                      &dwNumTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SPECIFIC_FILTERS:

        dwError = EnumSpecificTnFilters(
                      gpIniTnSFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTnFilters,
                      &dwNumTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    default:

        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    }

    *ppTunnelFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    *pdwResumeHandle = *pdwResumeHandle + dwNumTnFilters;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppTunnelFilters = NULL;
    *pdwNumTnFilters = 0;
    *pdwResumeHandle = *pdwResumeHandle;

    return (dwError);
}


DWORD
EnumGenericTnFilters(
    PINITNFILTER pIniTnFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    )
/*++

Routine Description:

    This function creates enumerated generic filters.

Arguments:

    pIniTnFilterList - List of generic filters to enumerate.

    dwResumeHandle - Location in the generic filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTnFilters - Enumerated filters returned to the caller.

    pdwNumTnFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINITNFILTER pIniTnFilter = NULL;
    DWORD i = 0;
    PINITNFILTER pTemp = NULL;
    DWORD dwNumTnFilters = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    PTUNNEL_FILTER pTnFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniTnFilter = pIniTnFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniTnFilter != NULL); i++) {
        pIniTnFilter = pIniTnFilter->pNext;
    }

    if (!pIniTnFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniTnFilter;

    while (pTemp && (dwNumTnFilters < dwNumToEnum)) {
        dwNumTnFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumTnFilters,
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniTnFilter;
    pTnFilter = pTnFilters;

    for (i = 0; i < dwNumTnFilters; i++) {

        dwError = CopyTnFilter(
                      pTemp,
                      pTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTnFilter++;

    }

    *ppTnFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            i,
            pTnFilters
            );
    }

    *ppTnFilters = NULL;
    *pdwNumTnFilters = 0;

    return (dwError);
}


DWORD
CopyTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniTnFilter - Internal filter to copy.

    pTnFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    CopyGuid(pIniTnFilter->gFilterID, &(pTnFilter->gFilterID));

    dwError = CopyName(
                  pIniTnFilter->pszFilterName,
                  &(pTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = pIniTnFilter->InterfaceType;

    pTnFilter->bCreateMirror = pIniTnFilter->bCreateMirror;

    pTnFilter->dwFlags = pIniTnFilter->dwFlags;

    CopyAddresses(pIniTnFilter->SrcAddr, &(pTnFilter->SrcAddr));

    CopyAddresses(pIniTnFilter->DesAddr, &(pTnFilter->DesAddr));

    CopyAddresses(pIniTnFilter->SrcTunnelAddr, &(pTnFilter->SrcTunnelAddr));

    CopyAddresses(pIniTnFilter->DesTunnelAddr, &(pTnFilter->DesTunnelAddr));

    CopyProtocols(pIniTnFilter->Protocol, &(pTnFilter->Protocol));

    CopyPorts(pIniTnFilter->SrcPort, &(pTnFilter->SrcPort));

    CopyPorts(pIniTnFilter->DesPort, &(pTnFilter->DesPort));

    pTnFilter->InboundFilterFlag = pIniTnFilter->InboundFilterFlag;

    pTnFilter->OutboundFilterFlag = pIniTnFilter->OutboundFilterFlag;

    pTnFilter->dwDirection = 0;

    pTnFilter->dwWeight = 0;

    CopyGuid(pIniTnFilter->gPolicyID, &(pTnFilter->gPolicyID));

error:

    return (dwError);
}


VOID
FreeTnFilters(
    DWORD dwNumTnFilters,
    PTUNNEL_FILTER pTnFilters
    )
{
    DWORD i = 0;

    if (pTnFilters) {

        for (i = 0; i < dwNumTnFilters; i++) {

            if (pTnFilters[i].pszFilterName) {
                SPDApiBufferFree(pTnFilters[i].pszFilterName);
            }

        }

        SPDApiBufferFree(pTnFilters);

    }

}


DWORD
SetTunnelFilter(
    HANDLE hTnFilter,
    PTUNNEL_FILTER pTunnelFilter
    )
/*++

Routine Description:

    This function sets (updates) a tunnel filter in the SPD.

Arguments:

    hTnFilter - Handle to the filter to be replaced.

    pTunnelFilter - Filter that will replace the existing filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;
    BOOL bEqualPKeys = FALSE;


    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTnFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    bEqualPKeys = EqualTnFilterPKeys(
                      pIniTnFilter,
                      pTunnelFilter
                      );
    if (!bEqualPKeys) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniTnFilter(
                  pIniTnFilter,
                  pTunnelFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniTnFilter->bIsPersisted) {
        dwError = PersistTnFilter(
                      pIniTnFilter->gFilterID,
                      pTunnelFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    return (dwError);
}


DWORD
SetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    BOOL bEqualNonPKeys = FALSE;
    PINIQMPOLICY pIniNewQMPolicy = NULL;
    PINITNFILTER pIniNewTnFilter = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINITNSFILTER pIniNewTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    LPWSTR pszFilterName = NULL;
    PINITNSFILTER pIniCurTnSFilters = NULL;


    bEqualNonPKeys = EqualTnFilterNonPKeys(
                         pIniTnFilter,
                         pTnFilter
                         );
    if (bEqualNonPKeys) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if ((pTnFilter->InboundFilterFlag == NEGOTIATE_SECURITY) ||
        (pTnFilter->OutboundFilterFlag == NEGOTIATE_SECURITY)) {

        dwError = LocateQMPolicy(
                      pTnFilter->dwFlags,
                      pTnFilter->gPolicyID,
                      &pIniNewQMPolicy
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = CreateIniTnFilter(
                  pTnFilter,
                  pIniNewQMPolicy,
                  &pIniNewTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GetMatchingInterfaces(
                  pIniNewTnFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniTnSFilters(
                  pIniNewTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniNewTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateTnSFilterLinks(
                  pIniNewTnSFilters,
                  &dwNumTnSFilters,
                  &ppIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDString(
                  pTnFilter->pszFilterName,
                  &pszFilterName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveTnSFilters(
        pIniTnFilter,
        &pIniCurTnSFilters
        );

    dwError = DeleteTunnelFiltersFromIPSec(
                  pIniCurTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = InsertTunnelFiltersIntoIPSec(
                  pIniNewTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    UpdateTnSFilterLinks(
        pIniTnFilter,
        dwNumTnSFilters,
        ppIniTnSFilters
        );

    if (pIniTnFilter->pIniQMPolicy) {
        DelinkTnFilter(
            pIniTnFilter->pIniQMPolicy,
            pIniTnFilter
            );
    }

    if (pIniNewQMPolicy) {
        LinkTnFilter(
            pIniNewQMPolicy,
            pIniTnFilter
            );
        LinkTnSpecificFilters(
            pIniNewQMPolicy,
            pIniNewTnSFilters
            );
    }

    UpdateTnFilterNonPKeys(
        pIniTnFilter,
        pszFilterName,
        pTnFilter,
        pIniNewQMPolicy
        );

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pIniNewTnSFilters
        );

    if (pIniCurTnSFilters) {
        FreeIniTnSFilterList(pIniCurTnSFilters);
    }

cleanup:

    if (pIniNewTnFilter) {
        FreeIniTnFilter(pIniNewTnFilter);
    }

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    if (pIniNewTnSFilters) {
        FreeIniTnSFilterList(pIniNewTnSFilters);
    }

    if (ppIniTnSFilters) {
        FreeSPDMemory(ppIniTnSFilters);
    }

    if (pszFilterName) {
        FreeSPDString(pszFilterName);
    }

    if (pIniCurTnSFilters) {
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pIniCurTnSFilters
            );
    }

    goto cleanup;
}


BOOL
EqualTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
{
    if (_wcsicmp(
            pIniTnFilter->pszFilterName,
            pTnFilter->pszFilterName)) {
        return (FALSE);
    }

    if (pIniTnFilter->InboundFilterFlag != 
        pTnFilter->InboundFilterFlag) {
        return (FALSE);
    }

    if (pIniTnFilter->OutboundFilterFlag != 
        pTnFilter->OutboundFilterFlag) {
        return (FALSE);
    }

    if ((pIniTnFilter->InboundFilterFlag == NEGOTIATE_SECURITY) ||
        (pIniTnFilter->OutboundFilterFlag == NEGOTIATE_SECURITY)) {
        if ((pIniTnFilter->dwFlags) != (pTnFilter->dwFlags)) {
            return (FALSE);
        }

        if (memcmp(
                &(pIniTnFilter->gPolicyID),
                &(pTnFilter->gPolicyID),
                sizeof(GUID))) {
            return (FALSE);
        }
    }

    return (TRUE);
}


DWORD
CreateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTnSFilters;
    while (pTemp) {
        dwNumTnSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumTnSFilters) {
        ppIniTnSFilters = (PINITNSFILTER *)
                          AllocSPDMem(
                              sizeof(PINITNSFILTER)*
                              dwNumTnSFilters
                              );
        if (!ppIniTnSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    pTemp = pIniTnSFilters;
    for (i = 0; i < dwNumTnSFilters; i++) {
        *(ppIniTnSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    *pdwNumTnSFilters = dwNumTnSFilters;
    *pppIniTnSFilters = ppIniTnSFilters;
    return (dwError);

error:

    *pdwNumTnSFilters = 0;
    *pppIniTnSFilters = NULL;
    return (dwError);
}


VOID
RemoveTnSFilters(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER * ppIniCurTnSFilters 
    )
{
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    DWORD i = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    PINITNSFILTER pIniCurTnSFilters = NULL;


    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;
    dwNumTnSFilters = pIniTnFilter->dwNumTnSFilters;

    for (i = 0; i < dwNumTnSFilters; i++) {

        //
        // Remove each entry from the Tunnel Specific Filter List.
        //

        pIniTnSFilter =  *(ppIniTnSFilters + i);
        RemoveIniTnSFilter(pIniTnSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniTnSFilter->pNext = NULL;
        AddToSpecificTnList(
            &pIniCurTnSFilters,
            pIniTnSFilter
            );

    }

    *ppIniCurTnSFilters = pIniCurTnSFilters;
}


VOID
UpdateTnSFilterLinks(
    PINITNFILTER pIniTnFilter,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    )
{
    if (pIniTnFilter->ppIniTnSFilters) {
        FreeSPDMemory(pIniTnFilter->ppIniTnSFilters);
    }

    pIniTnFilter->ppIniTnSFilters = ppIniTnSFilters;
    pIniTnFilter->dwNumTnSFilters = dwNumTnSFilters;
}


VOID
UpdateTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    LPWSTR pszFilterName,
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    )
{
    if (pIniTnFilter->pszFilterName) {
        FreeSPDString(pIniTnFilter->pszFilterName);
    }
    pIniTnFilter->pszFilterName = pszFilterName;

    pIniTnFilter->dwFlags = pTnFilter->dwFlags;

    pIniTnFilter->InboundFilterFlag = pTnFilter->InboundFilterFlag;

    pIniTnFilter->OutboundFilterFlag = pTnFilter->OutboundFilterFlag;

    if (pIniQMPolicy) {
        CopyGuid(pIniQMPolicy->gPolicyID, &(pIniTnFilter->gPolicyID));
    }
    else {
        CopyGuid(pTnFilter->gPolicyID, &(pIniTnFilter->gPolicyID));
    }
}


DWORD
GetTunnelFilter(
    HANDLE hTnFilter,
    PTUNNEL_FILTER * ppTunnelFilter
    )
/*++

Routine Description:

    This function retrieves a tunnel filter from the SPD.

Arguments:

    hTnFilter - Handle to the filter to be retrieved.

    ppTunnelFilter -  Filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;
    PTUNNEL_FILTER pTunnelFilter = NULL;


    if (!hTnFilter || !ppTunnelFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniTnFilter(
                  pIniTnFilter,
                  &pTunnelFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    *ppTunnelFilter = pTunnelFilter;
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppTunnelFilter = NULL;
    return (dwError);
}


DWORD
GetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER * ppTnFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilter = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER),
                  &pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyTnFilter(
                  pIniTnFilter,
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppTnFilter = pTnFilter;
    return (dwError);

error:

    if (pTnFilter) {
        SPDApiBufferFree(pTnFilter);
    }

    *ppTnFilter = NULL;
    return (dwError);
}


DWORD
ApplyIfChangeToIniTnFilters(
    PDWORD pdwTnError,
    PIPSEC_INTERFACE pLatestIfList
    )
{
    DWORD dwError = 0;
    PINITNFILTER pIniTnFilter = NULL;


    pIniTnFilter = gpIniTnFilter;

    while (pIniTnFilter) {

        dwError = UpdateIniTnFilterThruIfChange(
                      pIniTnFilter,
                      pLatestIfList
                      );
        if (dwError) {
            *pdwTnError = dwError;
        }

        pIniTnFilter = pIniTnFilter->pNext;

    }

    dwError = ERROR_SUCCESS;
    return (dwError);
}


DWORD
UpdateIniTnFilterThruIfChange(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pLatestIfList
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pLatestIniTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    PINITNSFILTER pCurIniTnSFilters = NULL;
    PINITNSFILTER pNewIniTnSFilters = NULL;
    PINITNSFILTER pOldIniTnSFilters = NULL;
    BOOL bDeletedFromDriver = FALSE;
 

    dwError = FormIniTnSFilters(
                  pIniTnFilter,
                  pLatestIfList,
                  &pLatestIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateTnSFilterLinks(
                  pLatestIniTnSFilters,
                  &dwNumTnSFilters,
                  &ppIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveTnSFilters(
        pIniTnFilter,
        &pCurIniTnSFilters
        );

    ProcessIniTnSFilters(
        &pLatestIniTnSFilters,
        &pCurIniTnSFilters,
        &pNewIniTnSFilters,
        &pOldIniTnSFilters
        );

    dwError = DeleteTunnelFiltersFromIPSec(
                  pOldIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    bDeletedFromDriver = TRUE;

    dwError = InsertTunnelFiltersIntoIPSec(
                  pNewIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTnFilter->pIniQMPolicy) {
        LinkTnSpecificFilters(
            pIniTnFilter->pIniQMPolicy,
            pCurIniTnSFilters
            );
        LinkTnSpecificFilters(
            pIniTnFilter->pIniQMPolicy,
            pNewIniTnSFilters
            );
    }

    SetTnSFilterLinks(
        pCurIniTnSFilters,
        pNewIniTnSFilters,
        dwNumTnSFilters,
        ppIniTnSFilters
        );

    UpdateTnSFilterLinks(
        pIniTnFilter,
        dwNumTnSFilters,
        ppIniTnSFilters
        );

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pCurIniTnSFilters
        );

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pNewIniTnSFilters
        );

    if (pOldIniTnSFilters) {
        FreeIniTnSFilterList(pOldIniTnSFilters);
    }

    return (dwError);

error:

    if (pLatestIniTnSFilters) {
        FreeIniTnSFilterList(pLatestIniTnSFilters);
    }

    if (ppIniTnSFilters) {
        FreeSPDMemory(ppIniTnSFilters);
    }

    if (pCurIniTnSFilters) {
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pCurIniTnSFilters
            );
    }

    if (pNewIniTnSFilters) {
        FreeIniTnSFilterList(pNewIniTnSFilters);
    }

    if (pOldIniTnSFilters) {
        if (bDeletedFromDriver) {
            (VOID) InsertTunnelFiltersIntoIPSec(
                       pOldIniTnSFilters
                       );
        }
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pOldIniTnSFilters
            );
    }

    return (dwError);
}


DWORD
FormIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pIfList,
    PINITNSFILTER * ppIniTnSFilters
    )
{
    DWORD dwError = 0;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINITNSFILTER pIniTnSFilters = NULL;


    dwError = GetMatchingInterfaces(
                  pIniTnFilter->InterfaceType,
                  pIfList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniTnSFilters(
                  pIniTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniTnSFilters = pIniTnSFilters;

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    *ppIniTnSFilters = NULL;

    goto cleanup;
}


VOID
ProcessIniTnSFilters(
    PINITNSFILTER * ppLatestIniTnSFilters,
    PINITNSFILTER * ppCurIniTnSFilters,
    PINITNSFILTER * ppNewIniTnSFilters,
    PINITNSFILTER * ppOldIniTnSFilters
    )
{
    PINITNSFILTER pLatestIniTnSFilters = NULL;
    PINITNSFILTER pCurIniTnSFilters = NULL;
    PINITNSFILTER pTempCur = NULL;
    BOOL bEqual = FALSE;
    PINITNSFILTER pTempLatest = NULL;
    PINITNSFILTER pTemp = NULL;
    PINITNSFILTER pNewIniTnSFilters = NULL;
    PINITNSFILTER pOldIniTnSFilters = NULL;
    PINITNSFILTER pTempPreToCur = NULL;
    PINITNSFILTER pTempPreToLatest = NULL;


    pCurIniTnSFilters = *ppCurIniTnSFilters;
    pTempCur = *ppCurIniTnSFilters;

    while (pTempCur) {

        bEqual = FALSE;
        pTempLatest = *ppLatestIniTnSFilters;

        while (pTempLatest) {

            bEqual = EqualIniTnSFilterIfPKeys(
                         pTempLatest,
                         pTempCur
                         );
            if (bEqual) {
                break;
            }

            pTempLatest = pTempLatest->pNext;

        }

        if (bEqual) {
            pTempPreToCur  = pTempCur;
            pTempCur = pTempCur->pNext;
        }
        else {
            pTemp = pTempCur;
            pTempCur = pTempCur->pNext;
            if (pTempPreToCur) {
                pTempPreToCur->pNext = pTempCur;
            }
            else {
                pCurIniTnSFilters = pTempCur;
            }
            pTemp->pNext = NULL;
            AddToSpecificTnList(
                &pOldIniTnSFilters,
                pTemp
                );
        }

    }

    pLatestIniTnSFilters = *ppLatestIniTnSFilters;
    pTempLatest = *ppLatestIniTnSFilters;

    while (pTempLatest) {

        bEqual = FALSE;
        pTempCur = pCurIniTnSFilters;

        while (pTempCur) {

            bEqual = EqualIniTnSFilterIfPKeys(
                         pTempCur,
                         pTempLatest
                         );
            if (bEqual) {
                break;
            }

            pTempCur = pTempCur->pNext;

        }

        if (bEqual) {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniTnSFilters = pTempLatest;
            }
            FreeIniTnSFilter(pTemp);
        }
        else {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniTnSFilters = pTempLatest;
            }
            pTemp->pNext = NULL;
            AddToSpecificTnList(
                &pNewIniTnSFilters,
                pTemp
                );
        }

    }

    *ppLatestIniTnSFilters = pLatestIniTnSFilters;
    *ppCurIniTnSFilters = pCurIniTnSFilters;
    *ppNewIniTnSFilters = pNewIniTnSFilters;
    *ppOldIniTnSFilters = pOldIniTnSFilters;
}


BOOL
EqualIniTnSFilterIfPKeys(
    PINITNSFILTER pExsIniTnSFilter,
    PINITNSFILTER pNewIniTnSFilter
    )
{
    BOOL  bCmp = FALSE;


    //
    // No need to compare: gParentID, pszFilterName, dwFlags
    //                     cRef, Protocol, SrcPort, DesPort,
    //                     InboundFilterFlag, OutboundFilterFlag,
    //                     dwWeight and gPolicyID.
    // They will be the same for both the filters.
    //

    if (pExsIniTnSFilter->InterfaceType != pNewIniTnSFilter->InterfaceType) {
        return (FALSE);
    }

    bCmp = EqualAddresses(
               pExsIniTnSFilter->DesTunnelAddr,
               pNewIniTnSFilter->DesTunnelAddr
               );
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniTnSFilter->SrcAddr, pNewIniTnSFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniTnSFilter->DesAddr, pNewIniTnSFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pExsIniTnSFilter->dwDirection != pNewIniTnSFilter->dwDirection) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
AllocateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTnSFilters;
    while (pTemp) {
        dwNumTnSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumTnSFilters) {
        ppIniTnSFilters = (PINITNSFILTER *)
                          AllocSPDMem(
                              sizeof(PINITNSFILTER)*
                              dwNumTnSFilters
                              );
        if (!ppIniTnSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    for (i = 0; i < dwNumTnSFilters; i++) {
        *(ppIniTnSFilters + i) = NULL;
    }

    *pdwNumTnSFilters = dwNumTnSFilters;
    *pppIniTnSFilters = ppIniTnSFilters;
    return (dwError);

error:

    *pdwNumTnSFilters = 0;
    *pppIniTnSFilters = NULL;
    return (dwError);
}


VOID
SetTnSFilterLinks(
    PINITNSFILTER pCurIniTnSFilters,
    PINITNSFILTER pNewIniTnSFilters,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    )
{
    PINITNSFILTER pTemp = NULL;
    DWORD i = 0;
    DWORD j = 0;


    pTemp = pCurIniTnSFilters;
    for (i = 0; (i < dwNumTnSFilters) && (pTemp != NULL); i++) {
        *(ppIniTnSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    pTemp = pNewIniTnSFilters;
    for (j = i; (j < dwNumTnSFilters) && (pTemp != NULL); j++) {
        *(ppIniTnSFilters + j) = pTemp;
        pTemp = pTemp->pNext;
    }
}


VOID
AddToGenericTnList(
    PINITNFILTER pIniTnFilter
    )
{
    PINITNFILTER pTemp = NULL;


    if (!gpIniTnFilter) {
        gpIniTnFilter = pIniTnFilter;
        return;
    }

    pTemp = gpIniTnFilter;

    while (pTemp->pNext) {
        pTemp = pTemp->pNext;
    }

    pTemp->pNext = pIniTnFilter;

    return;
}


DWORD
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phTnFilter
    )
{
    DWORD dwError = 0;
    PINITNFILTER pIniExistingTnFilter = NULL;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;


    if (!phTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external Tunnel filter.
    //

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingTnFilter = FindExactTnFilter(
                               gpIniTnFilter,
                               pTunnelFilter
                               );
    if (!pIniExistingTnFilter) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniExistingTnFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateTnFilterHandle(
                  pIniExistingTnFilter,
                  pTunnelFilter->gFilterID,
                  &pTnFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingTnFilter->cRef++;

    pTnFilterHandle->pNext = gpTnFilterHandle;
    gpTnFilterHandle = pTnFilterHandle;

    *phTnFilter = (HANDLE) pTnFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pTnFilterHandle) {
        FreeTnFilterHandle(pTnFilterHandle);
    }

    *phTnFilter = NULL;
    goto cleanup;
}


DWORD
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    )
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;


    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTnFilter->cRef > 1) {

        pIniTnFilter->cRef--;

        RemoveTnFilterHandle(
            pFilterHandle
            );
        FreeTnFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    if (pIniTnFilter->bPendingDeletion) {

        if (pIniTnFilter->bIsPersisted) {
            dwError = SPDPurgeTnFilter(
                          pIniTnFilter->gFilterID
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = DeleteIniTnFilter(
                      pIniTnFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }
    else {
        pIniTnFilter->cRef--;
    }

    RemoveTnFilterHandle(
        pFilterHandle
        );
    FreeTnFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


PINITNFILTER
FindExactTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTunnelFilter
    )
{
    PINITNFILTER pIniTnFilter = NULL;
    BOOL bEqual = FALSE;


    pIniTnFilter = pGenericTnList;

    while (pIniTnFilter) {

        bEqual = EqualTnFilterPKeys(
                     pIniTnFilter,
                     pTunnelFilter
                     );
        if (bEqual) {
            bEqual = EqualTnFilterNonPKeys(
                         pIniTnFilter,
                         pTunnelFilter
                         );
            if (bEqual) {
                return (pIniTnFilter);
            }
        }

        pIniTnFilter = pIniTnFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualMirroredTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function compares an internal and an external tunnel 
    filter for equality.

Arguments:

    pIniTnFilter - Filter to compare.

    pTnFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTnFilter->DesAddr, pTnFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->SrcAddr, pTnFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesTunnelAddr, pTnFilter->DesTunnelAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->DesPort, pTnFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->SrcPort, pTnFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTnFilter->Protocol, pTnFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if ((pIniTnFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pTnFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pIniTnFilter->InterfaceType != pTnFilter->InterfaceType)) {
        return (FALSE);
    }

    if (pIniTnFilter->bCreateMirror != pTnFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnspecific.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnspecific.h

Abstract:

    This module contains all of the code prototypes to
    drive the specific tunnel filter list management of 
    IPSecSPD Service.

Author:

    abhisheV    29-October-1999

Environment

    User Level: Win32

Revision History:


--*/


DWORD
ApplyTnTransform(
    PINITNFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITNSFILTER * ppSpecificFilters
    );

DWORD
FormTnOutboundInboundAddresses(
    PINITNFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutDesTunAddrList,
    PDWORD pdwOutDesTunAddrCnt,
    PADDR * ppInDesTunAddrList,
    PDWORD pdwInDesTunAddrCnt
    );

DWORD
FormSpecificTnFilters(
    PINITNFILTER pFilter,
    PADDR pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR pDesAddrList,
    DWORD dwDesAddrCnt,
    PADDR pDesTunAddrList,
    DWORD dwDesTunAddrCnt,
    DWORD dwDirection,
    PINITNSFILTER * ppSpecificFilters
    );

DWORD
CreateSpecificTnFilter(
    PINITNFILTER pGenericFilter,
    ADDR SrcAddr,
    ADDR DesAddr,
    ADDR DesTunnelAddr,
    PINITNSFILTER * ppSpecificFilter
    );

VOID
AssignTnFilterWeight(
    PINITNSFILTER pSpecificFilter
    );

VOID
AddToSpecificTnList(
    PINITNSFILTER * ppSpecificTnFilterList,
    PINITNSFILTER pSpecificTnFilters
    );

VOID
FreeIniTnSFilterList(
    PINITNSFILTER pIniTnSFilterList
    );

VOID
FreeIniTnSFilter(
    PINITNSFILTER pIniTnSFilter
    );

VOID
LinkTnSpecificFilters(
    PINIQMPOLICY pIniQMPolicy,
    PINITNSFILTER pIniTnSFilters
    );

VOID
RemoveIniTnSFilter(
    PINITNSFILTER pIniTnSFilter
    );

DWORD
EnumSpecificTnFilters(
    PINITNSFILTER pIniTnSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    );

DWORD
CopyTnSFilter(
    PINITNSFILTER pIniTnSFilter,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
EnumSelectSpecificTnFilters(
    PINITNFILTER pIniTnFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    );

DWORD
ValidateTnFilterTemplate(
    PTUNNEL_FILTER pTnFilter
    );

BOOL
MatchIniTnSFilter(
    PINITNSFILTER pIniTnSFilter,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
CopyTnMatchDefaults(
    PTUNNEL_FILTER * ppTnFilters,
    PIPSEC_QM_POLICY * ppQMPolicies,
    PDWORD pdwNumMatches
    );

DWORD
CopyDefaultTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\tnspecific.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnspecific.c

Abstract:

    This module contains all of the code to drive the
    specific tunnel filter list management of IPSecSPD
    Service.

Author:

    abhisheV    29-October-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
ApplyTnTransform(
    PINITNFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITNSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function expands a generic tunnel filter into its
    corresponding specific filters.

Arguments:

    pFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppSpecificFilters - List of specific filters expanded for the
                        given generic filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pSpecificFilters = NULL;
    PINITNSFILTER pOutboundSpecificFilters = NULL;
    PINITNSFILTER pInboundSpecificFilters = NULL;

    PADDR pSrcAddrList = NULL;
    DWORD dwSrcAddrCnt = 0;
    PADDR pDesAddrList = NULL;
    DWORD dwDesAddrCnt = 0;

    PADDR pOutDesTunAddrList = NULL;
    DWORD dwOutDesTunAddrCnt = 0;
    PADDR pInDesTunAddrList = NULL;
    DWORD dwInDesTunAddrCnt = 0;


    //
    // Replace wild card information to generate the new source
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->SrcAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pSrcAddrList,
                  &dwSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Replace wild card information to generate the new destination
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->DesAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pDesAddrList,
                  &dwDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    // 
    // Form the outbound and inbound destination tunnel address lists.
    // 

    dwError = FormTnOutboundInboundAddresses(
                  pFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pOutDesTunAddrList,
                  &dwOutDesTunAddrCnt,
                  &pInDesTunAddrList,
                  &dwInDesTunAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form outbound specific filters.
    //

    dwError = FormSpecificTnFilters(
                  pFilter,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pOutDesTunAddrList,
                  dwOutDesTunAddrCnt,
                  FILTER_DIRECTION_OUTBOUND,
                  &pOutboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form inbound specific filters.
    //

    dwError = FormSpecificTnFilters(
                  pFilter,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pInDesTunAddrList,
                  dwInDesTunAddrCnt,
                  FILTER_DIRECTION_INBOUND,
                  &pInboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pSpecificFilters = pOutboundSpecificFilters;

    AddToSpecificTnList(
        &pSpecificFilters,
        pInboundSpecificFilters
        );


    *ppSpecificFilters = pSpecificFilters;

cleanup:

    if (pSrcAddrList) {
        FreeSPDMemory(pSrcAddrList);
    }

    if (pDesAddrList) {
        FreeSPDMemory(pDesAddrList);
    }

    if (pOutDesTunAddrList) {
        FreeSPDMemory(pOutDesTunAddrList);
    }

    if (pInDesTunAddrList) {
        FreeSPDMemory(pInDesTunAddrList);
    }

    return (dwError);

error:

    if (pOutboundSpecificFilters) {
        FreeIniTnSFilterList(pOutboundSpecificFilters);
    }

    if (pInboundSpecificFilters) {
        FreeIniTnSFilterList(pInboundSpecificFilters);
    }


    *ppSpecificFilters = NULL;
    goto cleanup;
}


DWORD
FormTnOutboundInboundAddresses(
    PINITNFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutDesTunAddrList,
    PDWORD pdwOutDesTunAddrCnt,
    PADDR * ppInDesTunAddrList,
    PDWORD pdwInDesTunAddrCnt
    )
/*++

Routine Description:

    This function forms the outbound and inbound
    destination  tunnel address sets for a generic filter.

Arguments:

    pFilter - Generic filter under consideration.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppOutDesTunAddrList - List of outbound destination tunnel addresses.

    pdwOutDesTunAddrCnt - Number of addresses in the outbound
                          destination tunnel address list.

    ppInDesTunAddrList - List of inbound destination tunnel addresses.

    pdwInDesTunAddrCnt - Number of addresses in the inbound
                         destination tunnel address list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    PADDR pDesTunAddrList = NULL;
    DWORD dwDesTunAddrCnt = 0;

    PADDR pOutDesTunAddrList = NULL;
    DWORD dwOutDesTunAddrCnt = 0;
    PADDR pInDesTunAddrList = NULL;
    DWORD dwInDesTunAddrCnt = 0;


    //
    // Replace wild card information to generate the new destination
    // tunnel address list.
    //

    dwError = FormAddressList(
                  pFilter->DesTunnelAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pDesTunAddrList,
                  &dwDesTunAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the destination tunnel address list into outbound
    // and inbound destination tunnel address sets based on the local 
    // machine's ip addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->DesTunnelAddr.AddrType,
                  pDesTunAddrList,
                  dwDesTunAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pInDesTunAddrList,
                  &dwInDesTunAddrCnt,
                  &pOutDesTunAddrList,
                  &dwOutDesTunAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppOutDesTunAddrList = pOutDesTunAddrList;
    *pdwOutDesTunAddrCnt = dwOutDesTunAddrCnt;
    *ppInDesTunAddrList = pInDesTunAddrList;
    *pdwInDesTunAddrCnt = dwInDesTunAddrCnt;

cleanup:

    if (pDesTunAddrList) {
        FreeSPDMemory(pDesTunAddrList);
    }

    return (dwError);

error:

    if (pOutDesTunAddrList) {
        FreeSPDMemory(pOutDesTunAddrList);
    }

    if (pInDesTunAddrList) {
        FreeSPDMemory(pInDesTunAddrList);
    }

    *ppOutDesTunAddrList = NULL;
    *pdwOutDesTunAddrCnt = 0;
    *ppInDesTunAddrList = NULL;
    *pdwInDesTunAddrCnt = 0;

    goto cleanup;
}

    
DWORD
FormSpecificTnFilters(
    PINITNFILTER pFilter,
    PADDR pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR pDesAddrList,
    DWORD dwDesAddrCnt,
    PADDR pDesTunAddrList,
    DWORD dwDesTunAddrCnt,
    DWORD dwDirection,
    PINITNSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function forms the specific tunnel filters
    for the given generic filter and the source and 
    destination address sets.

Arguments:

    pFilter - Generic filter for which specific filters
              are to be created.

    pSrcAddrList - List of source addresses.

    dwSrcAddrCnt - Number of addresses in the source
                   address list.

    pDesAddrList - List of destination addresses.

    dwDesAddrCnt - Number of addresses in the destination
                   address list.

    pDesTunAddrList - List of destination tunnel addresses.

    dwDesTunAddrCnt - Number of addresses in the destination
                      tunnel address list.

    dwDirection - direction of the resulting specific filters.

    ppSpecificFilters - Specific filters created for the given
                        generic filter and the given addresses.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pSpecificFilters = NULL;
    DWORD i = 0, j = 0, k = 0;
    PINITNSFILTER pSpecificFilter = NULL;


    for (k = 0; k < dwDesTunAddrCnt; k++) {

        for (i = 0; i < dwSrcAddrCnt; i++) {

            for (j = 0; j < dwDesAddrCnt; j++) {

                dwError = CreateSpecificTnFilter(
                               pFilter,
                               pSrcAddrList[i],
                               pDesAddrList[j],
                               pDesTunAddrList[k],
                               &pSpecificFilter
                               );
                BAIL_ON_WIN32_ERROR(dwError);

                //
                // Set the direction of the filter.
                //

                pSpecificFilter->dwDirection = dwDirection;

                AssignTnFilterWeight(pSpecificFilter);

                AddToSpecificTnList(
                    &pSpecificFilters,
                    pSpecificFilter
                    );

            }

        }

    }

    *ppSpecificFilters = pSpecificFilters;
    return (dwError);

error:

    if (pSpecificFilters) {
        FreeIniTnSFilterList(pSpecificFilters);
    }

    *ppSpecificFilters = NULL;
    return (dwError);
}


DWORD
CreateSpecificTnFilter(
    PINITNFILTER pGenericFilter,
    ADDR SrcAddr,
    ADDR DesAddr,
    ADDR DesTunnelAddr,
    PINITNSFILTER * ppSpecificFilter
    )
{
    DWORD dwError = 0; 
    PINITNSFILTER pSpecificFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INITNSFILTER),
                    &pSpecificFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->cRef = 0;

    CopyGuid(pGenericFilter->gFilterID, &(pSpecificFilter->gParentID));

    dwError = AllocateSPDString(
                  pGenericFilter->pszFilterName,
                  &(pSpecificFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->InterfaceType = pGenericFilter->InterfaceType;

    pSpecificFilter->dwFlags = pGenericFilter->dwFlags;

    CopyAddresses(SrcAddr, &(pSpecificFilter->SrcAddr));

    CopyAddresses(DesAddr, &(pSpecificFilter->DesAddr));

    CopyAddresses(
        pGenericFilter->SrcTunnelAddr, 
        &(pSpecificFilter->SrcTunnelAddr)
        );

    CopyAddresses(DesTunnelAddr, &(pSpecificFilter->DesTunnelAddr));

    CopyPorts(pGenericFilter->SrcPort, &(pSpecificFilter->SrcPort));

    CopyPorts(pGenericFilter->DesPort, &(pSpecificFilter->DesPort));

    CopyProtocols(pGenericFilter->Protocol, &(pSpecificFilter->Protocol));

    pSpecificFilter->InboundFilterFlag = pGenericFilter->InboundFilterFlag;

    pSpecificFilter->OutboundFilterFlag = pGenericFilter->OutboundFilterFlag;

    //
    // Direction must be set in the calling routine.
    //

    pSpecificFilter->dwDirection = 0;

    //
    // Weight must be set in the calling routine.
    //

    pSpecificFilter->dwWeight = 0;

    CopyGuid(pGenericFilter->gPolicyID, &(pSpecificFilter->gPolicyID));

    pSpecificFilter->pIniQMPolicy = NULL;

    pSpecificFilter->pNext = NULL;

    *ppSpecificFilter = pSpecificFilter;
    return (dwError);

error:

    if (pSpecificFilter) {
        FreeIniTnSFilter(pSpecificFilter);
    }

    *ppSpecificFilter = NULL;
    return (dwError);
}


VOID
AssignTnFilterWeight(
    PINITNSFILTER pSpecificFilter
    )
/*++

Routine Description:

    Computes and assigns the weight to a specific tunnel filter.

    The tunnel filter weight consists of the following:

    31         16          12           8        0
    +-----------+-----------+-----------+--------+
    |AddrMaskWgt| TunnelWgt |ProtocolWgt|PortWgts|
    +-----------+-----------+-----------+--------+

Arguments:

    pSpecificFilter - Specific tunnel filter to which the weight 
                      is to be assigned.

Return Value:

    None.

--*/
{
    DWORD dwWeight = 0;
    ULONG SrcMask = 0;
    ULONG DesMask = 0;
    DWORD dwMaskWeight = 0;
    DWORD i = 0;


    //
    // Weight Rule:
    // A field with a more specific value gets a higher weight than
    // the same field with a lesser specific value.
    //

    //
    // If the protocol is specific then assign the specific protocol
    // weight else the weight is zero.
    // All the specific filters that have a specific protocol and
    // differ only in the protocol field will have the same weight.
    //

    if (pSpecificFilter->Protocol.dwProtocol != 0) {
        dwWeight |= WEIGHT_SPECIFIC_PROTOCOL;
    }

    //
    // If the source port is specific then assign the specific source
    // port weight else the weight is zero.
    // All the specific filters that have a specific source port and 
    // differ only in the source port field will have the same weight.
    //

    if (pSpecificFilter->SrcPort.wPort != 0) {
        dwWeight |= WEIGHT_SPECIFIC_SOURCE_PORT;
    }

    //
    // If the destination port is specific then assign the specific
    // destination port weight else the weight is zero. 
    // All the specific filters that have a specific destination port
    // and differ only in the destination port field will have the
    // same weight.
    //

    if (pSpecificFilter->DesPort.wPort != 0) {
        dwWeight |= WEIGHT_SPECIFIC_DESTINATION_PORT;
    }

    dwWeight |= WEIGHT_TUNNEL_FILTER;

    if (pSpecificFilter->DesTunnelAddr.uIpAddr != SUBNET_ADDRESS_ANY) {
        dwWeight |= WEIGHT_SPECIFIC_TUNNEL_FILTER;
    }

    //
    // IP addresses get the weight values based on their mask values.
    // In the address case, the weight is computed as a sum of the 
    // bit positions starting from the position that contains the 
    // first least significant non-zero bit to the most significant
    // bit position of the mask. 
    // All unique ip addresses have a mask of 0xFFFFFFFF and thus get
    // the same weight, which is 1 + 2 + .... + 32.
    // A subnet address has a mask with atleast the least significant
    // bit zero and thus gets weight in the range (2 + .. + 32) to 0.
    //
  
    DesMask = ntohl(pSpecificFilter->DesAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((DesMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         DesMask = DesMask >> 1;

    }


    SrcMask = ntohl(pSpecificFilter->SrcAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((SrcMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         SrcMask = SrcMask >> 1;

    }

    //
    // Move the mask weight to the set of bits in the overall weight
    // that it occupies.
    //

    dwMaskWeight = dwMaskWeight << 16;

    dwWeight += dwMaskWeight;

    pSpecificFilter->dwWeight = dwWeight;
}


VOID
AddToSpecificTnList(
    PINITNSFILTER * ppSpecificTnFilterList,
    PINITNSFILTER pSpecificTnFilters
    )
{
    PINITNSFILTER pListOne = NULL;
    PINITNSFILTER pListTwo = NULL;
    PINITNSFILTER pListMerge = NULL;
    PINITNSFILTER pLast = NULL;

    if (!(*ppSpecificTnFilterList) && !pSpecificTnFilters) {
        return;
    }

    if (!(*ppSpecificTnFilterList)) {
        *ppSpecificTnFilterList = pSpecificTnFilters;
        return;
    }

    if (!pSpecificTnFilters) {
        return;
    }

    pListOne = *ppSpecificTnFilterList;
    pListTwo = pSpecificTnFilters;

    while (pListOne && pListTwo) {

        if ((pListOne->dwWeight) > (pListTwo->dwWeight)) {

            if (!pListMerge) {
                pListMerge = pListOne;
                pLast = pListOne;
                pListOne = pListOne->pNext;
            }
            else {
                pLast->pNext = pListOne;
                pListOne = pListOne->pNext;
                pLast = pLast->pNext;
            }

        }
        else {

            if (!pListMerge) {
                pListMerge = pListTwo;
                pLast = pListTwo;
                pListTwo = pListTwo->pNext;
            }
            else {
                pLast->pNext = pListTwo;
                pListTwo = pListTwo->pNext;
                pLast = pLast->pNext;
            }

        }

    }

    if (pListOne) {
        pLast->pNext = pListOne;
    }
    else {
        pLast->pNext = pListTwo;
    }

    *ppSpecificTnFilterList = pListMerge;
    return;
}


VOID
FreeIniTnSFilterList(
    PINITNSFILTER pIniTnSFilterList
    )
{
    PINITNSFILTER pFilter = NULL;
    PINITNSFILTER pTempFilter = NULL;

    pFilter = pIniTnSFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniTnSFilter(pTempFilter);
    }
}


VOID
FreeIniTnSFilter(
    PINITNSFILTER pIniTnSFilter
    )
{
    if (pIniTnSFilter) {
        if (pIniTnSFilter->pszFilterName) {
            FreeSPDString(pIniTnSFilter->pszFilterName);
        }

        //
        // Must not ever free pIniTnSFilter->pIniQMPolicy.
        //

        FreeSPDMemory(pIniTnSFilter);
    }
}


VOID
LinkTnSpecificFilters(
    PINIQMPOLICY pIniQMPolicy,
    PINITNSFILTER pIniTnSFilters
    )
{
    PINITNSFILTER pTemp = NULL;

    pTemp = pIniTnSFilters;

    while (pTemp) {
        pTemp->pIniQMPolicy = pIniQMPolicy;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
RemoveIniTnSFilter(
    PINITNSFILTER pIniTnSFilter
    )
{
    PINITNSFILTER * ppTemp = NULL;

    ppTemp = &gpIniTnSFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniTnSFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniTnSFilter->pNext;
    }

    return;
}


DWORD
EnumSpecificTnFilters(
    PINITNSFILTER pIniTnSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters.

Arguments:

    pIniTnSFilterList - List of specific filters to enumerate.

    dwResumeHandle - Location in the specific filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTnFilters - Enumerated filters returned to the caller.

    pdwNumTnFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    DWORD i = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumTnFilters = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    PTUNNEL_FILTER pTnFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniTnSFilter = pIniTnSFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniTnSFilter != NULL); i++) {
        pIniTnSFilter = pIniTnSFilter->pNext;
    }

    if (!pIniTnSFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniTnSFilter;

    while (pTemp && (dwNumTnFilters < dwNumToEnum)) {
        dwNumTnFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumTnFilters,
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniTnSFilter;
    pTnFilter = pTnFilters;

    for (i = 0; i < dwNumTnFilters; i++) {

        dwError = CopyTnSFilter(
                      pTemp,
                      pTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTnFilter++;

    }

    *ppTnFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            i,
            pTnFilters
            );
    }

    *ppTnFilters = NULL;
    *pdwNumTnFilters = 0;

    return (dwError);
}


DWORD
CopyTnSFilter(
    PINITNSFILTER pIniTnSFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniTnSFilter - Internal filter to copy.

    pTnFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    CopyGuid(pIniTnSFilter->gParentID, &(pTnFilter->gFilterID));

    dwError = CopyName(
                  pIniTnSFilter->pszFilterName,
                  &(pTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = pIniTnSFilter->InterfaceType;

    pTnFilter->bCreateMirror = FALSE;

    pTnFilter->dwFlags = pIniTnSFilter->dwFlags;

    CopyAddresses(pIniTnSFilter->SrcAddr, &(pTnFilter->SrcAddr));

    CopyAddresses(pIniTnSFilter->DesAddr, &(pTnFilter->DesAddr));

    CopyAddresses(pIniTnSFilter->SrcTunnelAddr, &(pTnFilter->SrcTunnelAddr));

    CopyAddresses(pIniTnSFilter->DesTunnelAddr, &(pTnFilter->DesTunnelAddr));

    CopyProtocols(pIniTnSFilter->Protocol, &(pTnFilter->Protocol));

    CopyPorts(pIniTnSFilter->SrcPort, &(pTnFilter->SrcPort));

    CopyPorts(pIniTnSFilter->DesPort, &(pTnFilter->DesPort));

    pTnFilter->InboundFilterFlag = pIniTnSFilter->InboundFilterFlag;

    pTnFilter->OutboundFilterFlag = pIniTnSFilter->OutboundFilterFlag;

    pTnFilter->dwDirection = pIniTnSFilter->dwDirection;

    pTnFilter->dwWeight = pIniTnSFilter->dwWeight;

    CopyGuid(pIniTnSFilter->gPolicyID, &(pTnFilter->gPolicyID));

error:

    return (dwError);
}


DWORD
EnumSelectSpecificTnFilters(
    PINITNFILTER pIniTnFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters for
    the given generic filter.

Arguments:

    pIniTnFilter - Generic filter for which specific filters
                   are to be enumerated.

    dwResumeHandle - Location in the specific filter list for the
                     given generic filter from which to resume
                     enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTnFilters - Enumerated filters returned to the caller.

    pdwNumTnFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumTnSFilters = 0; 
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;
    DWORD dwNumTnFilters = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    PTUNNEL_FILTER pTnFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    dwNumTnSFilters = pIniTnFilter->dwNumTnSFilters;
    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;

    if (!dwNumTnSFilters || (dwNumTnSFilters <= dwResumeHandle)) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumTnFilters = min((dwNumTnSFilters-dwResumeHandle),
                         dwNumToEnum);
 
    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumTnFilters,
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter = pTnFilters;

    for (i = 0; i < dwNumTnFilters; i++) {

        dwError = CopyTnSFilter(
                      *(ppIniTnSFilters + (dwResumeHandle + i)),
                      pTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pTnFilter++;

    }

    *ppTnFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            i,
            pTnFilters
            );
    }

    *ppTnFilters = NULL;
    *pdwNumTnFilters = 0;

    return (dwError);
}


DWORD
MatchTunnelFilter(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function finds the matching tunnel filters for the 
    given tunnel filter template. The matched filters can not
    be more specific than the given filter template.

Arguments:

    pServerName - Server on which a filter template is to be matched.

    pTnFilter - Filter template to match.

    dwFlags - Flags.

    ppMatchedTnFilters - Matched tunnel filters returned to the
                         caller.

    ppMatchedQMPolicies - Quick mode policies corresponding to the 
                          matched tunnel filters returned to the
                          caller.

    dwPreferredNumEntries - Preferred number of matched entries.

    pdwNumMatches - Number of filters actually matched.

    pdwResumeHandle - Handle to the location in the matched filter 
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToMatch = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    DWORD i = 0;
    BOOL bMatches = FALSE;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumMatches = 0;
    PINITNSFILTER pLastMatchedFilter = NULL;
    PTUNNEL_FILTER pMatchedTnFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;
    PTUNNEL_FILTER pMatchedTnFilter = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicy = NULL;


    dwError = ValidateTnFilterTemplate(
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries) {
        dwNumToMatch = 1;
    }
    else if (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT) {
        dwNumToMatch = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToMatch = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnSFilter = gpIniTnSFilter;

    while ((i < dwResumeHandle) && (pIniTnSFilter != NULL)) {
        bMatches = MatchIniTnSFilter(
                       pIniTnSFilter,
                       pTnFilter
                       );
        if (bMatches) {
            i++;
        }
        pIniTnSFilter = pIniTnSFilter->pNext;
    }

    if (!pIniTnSFilter) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyTnMatchDefaults(
                          &pMatchedTnFilters,
                          &pMatchedQMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    pTemp = pIniTnSFilter;

    while (pTemp && (dwNumMatches < dwNumToMatch)) {
        bMatches = MatchIniTnSFilter(
                       pTemp,
                       pTnFilter
                       );
        if (bMatches) {
            pLastMatchedFilter = pTemp;
            dwNumMatches++;
        }
        pTemp = pTemp->pNext;
    }

    if (!dwNumMatches) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyTnMatchDefaults(
                          &pMatchedTnFilters,
                          &pMatchedQMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumMatches,
                  &pMatchedTnFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY)*dwNumMatches,
                  &pMatchedQMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);


    if (dwNumMatches == 1) {

        dwError = CopyTnSFilter(
                      pLastMatchedFilter,
                      pMatchedTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        dwNumFilters++;

        if (pLastMatchedFilter->pIniQMPolicy) {
            dwError = CopyQMPolicy(
                          pLastMatchedFilter->pIniQMPolicy,
                          pMatchedQMPolicies
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedQMPolicies, 0, sizeof(IPSEC_QM_POLICY));
        }
        dwNumPolicies++;

    }
    else {

        pTemp = pIniTnSFilter;
        pMatchedTnFilter = pMatchedTnFilters;
        pMatchedQMPolicy = pMatchedQMPolicies;
        i = 0;

        while (i < dwNumMatches) {

            bMatches = MatchIniTnSFilter(
                           pTemp,
                           pTnFilter
                           );
            if (bMatches) {

                dwError = CopyTnSFilter(
                              pTemp,
                              pMatchedTnFilter
                              );
                BAIL_ON_LOCK_ERROR(dwError);
                pMatchedTnFilter++;
                dwNumFilters++;

                if (pTemp->pIniQMPolicy) {
                    dwError = CopyQMPolicy(
                                  pTemp->pIniQMPolicy,
                                  pMatchedQMPolicy
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pMatchedQMPolicy, 0, sizeof(IPSEC_QM_POLICY));
                }
                pMatchedQMPolicy++;
                dwNumPolicies++;

                i++;

            }

            pTemp = pTemp->pNext;

        }

    }

lock_success:

    LEAVE_SPD_SECTION();

    *ppMatchedTnFilters = pMatchedTnFilters;
    *ppMatchedQMPolicies = pMatchedQMPolicies;
    *pdwNumMatches = dwNumMatches;
    *pdwResumeHandle = dwResumeHandle + dwNumMatches;

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMatchedTnFilters) {
        FreeTnFilters(
            dwNumFilters,
            pMatchedTnFilters
            );
    }

    if (pMatchedQMPolicies) {
        FreeQMPolicies(
            dwNumPolicies,
            pMatchedQMPolicies
            );
    }

    *ppMatchedTnFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
ValidateTnFilterTemplate(
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTnFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTnFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTnFilter->SrcAddr,
                     pTnFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTnFilter->DesTunnelAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTnFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->SrcPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->DesPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTnFilter->dwDirection) {
        if ((pTnFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTnFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
MatchIniTnSFilter(
    PINITNSFILTER pIniTnSFilter,
    PTUNNEL_FILTER pTnFilter
    )
{
    BOOL bMatches = FALSE;

    if (pTnFilter->dwDirection) {
        if (pTnFilter->dwDirection != pIniTnSFilter->dwDirection) {
            return (FALSE);
        }
    }

    if ((pIniTnSFilter->InboundFilterFlag != NEGOTIATE_SECURITY) &&
        (pIniTnSFilter->OutboundFilterFlag != NEGOTIATE_SECURITY)) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTnSFilter->SrcAddr,
                   pTnFilter->SrcAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTnSFilter->DesAddr,
                   pTnFilter->DesAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTnSFilter->DesTunnelAddr,
                   pTnFilter->DesTunnelAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchPorts(
                   pIniTnSFilter->SrcPort,
                   pTnFilter->SrcPort
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchPorts(
                   pIniTnSFilter->DesPort,
                   pTnFilter->DesPort
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchProtocols(
                   pIniTnSFilter->Protocol,
                   pTnFilter->Protocol
                   );
    if (!bMatches) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CopyTnMatchDefaults(
    PTUNNEL_FILTER * ppTnFilters,
    PIPSEC_QM_POLICY * ppQMPolicies,
    PDWORD pdwNumMatches
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilters = NULL;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;


    if (!gpIniDefaultQMPolicy) {
        dwError = ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER),
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY),
                  &pQMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyDefaultTnFilter(
                  pTnFilters,
                  gpIniDefaultQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumFilters++;

    dwError = CopyQMPolicy(
                  gpIniDefaultQMPolicy,
                  pQMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumPolicies++;

    *ppTnFilters = pTnFilters;
    *ppQMPolicies = pQMPolicies;
    *pdwNumMatches = 1;

    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            dwNumFilters,
            pTnFilters
            );
    }

    if (pQMPolicies) {
        FreeQMPolicies(
            dwNumPolicies,
            pQMPolicies
            );
    }

    *ppTnFilters = NULL;
    *ppQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
CopyDefaultTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    )
{
    DWORD dwError = 0;


    UuidCreate(&(pTnFilter->gFilterID));

    dwError = CopyName(
                  L"0",
                  &(pTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = INTERFACE_TYPE_ALL;

    pTnFilter->bCreateMirror = TRUE;

    pTnFilter->dwFlags = 0;
    pTnFilter->dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;

    pTnFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;

    pTnFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;

    pTnFilter->SrcTunnelAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->SrcTunnelAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->SrcTunnelAddr.uSubNetMask = SUBNET_MASK_ANY;

    pTnFilter->DesTunnelAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->DesTunnelAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->DesTunnelAddr.uSubNetMask = SUBNET_MASK_ANY;

    pTnFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pTnFilter->Protocol.dwProtocol = 0;

    pTnFilter->SrcPort.PortType = PORT_UNIQUE;
    pTnFilter->SrcPort.wPort = 0;

    pTnFilter->DesPort.PortType = PORT_UNIQUE;
    pTnFilter->DesPort.wPort = 0;

    pTnFilter->InboundFilterFlag = NEGOTIATE_SECURITY;

    pTnFilter->OutboundFilterFlag = NEGOTIATE_SECURITY;

    pTnFilter->dwDirection = 0;

    pTnFilter->dwWeight = 0;

    CopyGuid(pIniQMPolicy->gPolicyID, &(pTnFilter->gPolicyID));

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txf-load.c ===
#include "precomp.h"


DWORD
LoadPersistedTxFilters(
    HKEY hParentRegKey
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;
    WCHAR szTxFilterUniqueID[MAX_PATH];
    DWORD dwIndex = 0;
    PTRANSPORT_FILTER pTxFilter = NULL;
    LPWSTR pszServerName = NULL;
    HANDLE hTxFilter = NULL;
    DWORD dwPersist = 0;


    dwPersist |= PERSIST_SPD_OBJECT;

    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  L"Transport Filters",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    while (1) {

        dwSize = MAX_PATH;
        szTxFilterUniqueID[0] = L'\0';

        dwError = RegEnumKeyExW(
                      hRegKey,
                      dwIndex,
                      szTxFilterUniqueID,
                      &dwSize,
                      NULL,
                      NULL,
                      0,
                      0
                      );

        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        }

        BAIL_ON_WIN32_ERROR(dwError);

        dwError = SPDReadTxFilter(
                      hRegKey,
                      szTxFilterUniqueID,
                      &pTxFilter
                      );

        if (dwError) {
            dwIndex++;
            continue;
        }

        dwError = AddTransportFilter(
                      pszServerName,
                      dwPersist,
                      pTxFilter,
                      &hTxFilter
                      );

        if (pTxFilter) {
            FreeTxFilters(
                1,
                pTxFilter
                );
        }

        if (hTxFilter) {
            CloseTransportFilterHandle(hTxFilter);
        }

        dwIndex++;

    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
SPDReadTxFilter(
    HKEY hParentRegKey,
    LPWSTR pszTxFilterUniqueID,
    PTRANSPORT_FILTER * ppTxFilter
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    PTRANSPORT_FILTER pTxFilter = NULL;
    LPWSTR pszFilterID = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwMirrored = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwInboundFilterFlag = 0;
    DWORD dwOutboundFilterFlag = 0;
    LPWSTR pszPolicyID = NULL;


    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  pszTxFilterUniqueID,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter = (PTRANSPORT_FILTER) AllocSPDMem(
                                   sizeof(TRANSPORT_FILTER)
                                   );
    if (!pTxFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"FilterID",
                  REG_SZ,
                  (LPBYTE *)&pszFilterID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszFilterID,
        &pTxFilter->gFilterID
        );

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"FilterName",
                  REG_SZ,
                  (LPBYTE *)&pTxFilter->pszFilterName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"InterfaceType",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwInterfaceType,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->InterfaceType = (IF_TYPE) dwInterfaceType;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Mirrored",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwMirrored,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->bCreateMirror = (BOOL) dwMirrored;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Flags",
                  NULL,
                  &dwType,
                  (LPBYTE)&pTxFilter->dwFlags,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"Transport Filter Buffer",
                  REG_BINARY,
                  (LPBYTE *)&pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallTxFilterBuffer(
                  pBuffer,
                  dwBufferSize,
                  pTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"InboundFilterFlag",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwInboundFilterFlag,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->InboundFilterFlag = (FILTER_FLAG) dwInboundFilterFlag;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"OutboundFilterFlag",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwOutboundFilterFlag,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->OutboundFilterFlag = (FILTER_FLAG) dwOutboundFilterFlag;

    pTxFilter->dwDirection = 0;

    pTxFilter->dwWeight = 0;

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyID",
                  REG_SZ,
                  (LPBYTE *)&pszPolicyID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszPolicyID,
        &pTxFilter->gPolicyID
        );

    *ppTxFilter = pTxFilter;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszFilterID) {
        FreeSPDStr(pszFilterID);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    if (pszPolicyID) {
        FreeSPDStr(pszPolicyID);
    }

    return (dwError);

error:

    *ppTxFilter = NULL;

    if (pTxFilter) {
        FreeTxFilters(
            1,
            pTxFilter
            );
    }

    goto cleanup;
}


DWORD
UnMarshallTxFilterBuffer(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;


    pMem = pBuffer;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy(
        (LPBYTE) &pTxFilter->SrcAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        (LPBYTE) &pTxFilter->DesAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        (LPBYTE) &pTxFilter->Protocol,
        pMem,
        sizeof(PROTOCOL)
        );
    pMem += sizeof(PROTOCOL);

    memcpy(
        (LPBYTE) &pTxFilter->SrcPort,
        pMem,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    memcpy(
        (LPBYTE) &pTxFilter->DesPort,
        pMem,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txf-pers.h ===
DWORD
PersistTxFilter(
    GUID gFilterID,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
SPDWriteTxFilter(
    HKEY hParentRegKey,
    GUID gFilterID,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
MarshallTxFilterBuffer(
    PTRANSPORT_FILTER pTxFilter,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    );

DWORD
SPDPurgeTxFilter(
    GUID gTxFilterID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txf-pers.c ===
#include "precomp.h"


LPWSTR gpszIpsecTxFiltersKey = 
L"SOFTWARE\\Microsoft\\IPSec\\Transport Filters";


DWORD
PersistTxFilter(
    GUID gFilterID,
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecTxFiltersKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegistryKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDWriteTxFilter(
                  hRegistryKey,
                  gFilterID,
                  pTxFilter
                  );    
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    if (hRegistryKey) {
        (VOID) SPDPurgeTxFilter(
                   gFilterID
                   );
    }

    goto cleanup;
}


DWORD
SPDWriteTxFilter(
    HKEY hParentRegKey,
    GUID gFilterID,
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    WCHAR szFilterID[MAX_PATH];
    WCHAR szPolicyID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszPolicyUuid = NULL;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwMirrored = 0;
    DWORD dwInboundFilterFlag = 0;
    DWORD dwOutboundFilterFlag = 0;


    szFilterID[0] = L'\0';
    szPolicyID[0] = L'\0';

    dwError = UuidToString(
                  &gFilterID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szFilterID, L"{");
    wcscat(szFilterID, pszStringUuid);
    wcscat(szFilterID, L"}");

    dwError = UuidToString(
                  &pTxFilter->gPolicyID,
                  &pszPolicyUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszPolicyUuid);
    wcscat(szPolicyID, L"}");

    dwError = RegCreateKeyExW(
                  hParentRegKey,
                  szFilterID,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"FilterID",
                  0,
                  REG_SZ,
                  (LPBYTE) szFilterID,
                  (wcslen(szFilterID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"FilterName",
                  0,
                  REG_SZ,
                  (LPBYTE) pTxFilter->pszFilterName,
                  (wcslen(pTxFilter->pszFilterName) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwInterfaceType = (DWORD) pTxFilter->InterfaceType;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"InterfaceType",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwInterfaceType,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwMirrored = (DWORD) pTxFilter->bCreateMirror;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"Mirrored",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwMirrored,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Flags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pTxFilter->dwFlags,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MarshallTxFilterBuffer(
                  pTxFilter,
                  &pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Transport Filter Buffer",
                  0,
                  REG_BINARY,
                  (LPBYTE) pBuffer,
                  dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwInboundFilterFlag = (DWORD) pTxFilter->InboundFilterFlag;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"InboundFilterFlag",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwInboundFilterFlag,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwOutboundFilterFlag = (DWORD) pTxFilter->OutboundFilterFlag;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"OutboundFilterFlag",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwOutboundFilterFlag,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyID",
                  0,
                  REG_SZ,
                  (LPBYTE) szPolicyID,
                  (wcslen(szPolicyID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (pszPolicyUuid) {
        RpcStringFree(&pszPolicyUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    goto cleanup;
}


DWORD
MarshallTxFilterBuffer(
    PTRANSPORT_FILTER pTxFilter,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    )
{
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    LPBYTE pMem = NULL;
    static const GUID GUID_IPSEC_TX_FILTER_VER1 =
    { 0xabcd0005, 0x0001, 0x0001, { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } };


    dwBufferSize = sizeof(GUID) +
                   sizeof(DWORD) +
                   sizeof(ADDR) +
                   sizeof(ADDR) +
                   sizeof(PROTOCOL) +
                   sizeof(PORT) +
                   sizeof(PORT);

    pBuffer = (LPBYTE) AllocSPDMem(
                           dwBufferSize
                           );
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &GUID_IPSEC_TX_FILTER_VER1,
        sizeof(GUID)
        );
    pMem += sizeof(GUID);

    memcpy(
        pMem,
        (LPBYTE) &dwBufferSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &pTxFilter->SrcAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        pMem,
        (LPBYTE) &pTxFilter->DesAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        pMem,
        (LPBYTE) &pTxFilter->Protocol,
        sizeof(PROTOCOL)
        );
    pMem += sizeof(PROTOCOL);

    memcpy(
        pMem,
        (LPBYTE) &pTxFilter->SrcPort,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    memcpy(
        pMem,
        (LPBYTE) &pTxFilter->DesPort,
        sizeof(PORT)
        );
    pMem += sizeof(PORT);

    *ppBuffer = pBuffer;
    *pdwBufferSize = dwBufferSize;

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferSize = 0;

    return (dwError);
}


DWORD
SPDPurgeTxFilter(
    GUID gTxFilterID
    )
{
    DWORD dwError = 0;
    HKEY hParentRegKey = NULL;
    DWORD dwDisposition = 0;
    WCHAR szFilterID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecTxFiltersKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hParentRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szFilterID[0] = L'\0';

    dwError = UuidToString(
                  &gTxFilterID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szFilterID, L"{");
    wcscat(szFilterID, pszStringUuid);
    wcscat(szFilterID, L"}");

    dwError = RegDeleteKeyW(
                  hParentRegKey,
                  szFilterID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hParentRegKey) {
        RegCloseKey(hParentRegKey);
    }

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txspecific.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    txspecific.h

Abstract:

    This module contains all of the code prototypes to
    drive the specific transport filter list management of 
    IPSecSPD Service.

Author:

    abhisheV    29-October-1999

Environment

    User Level: Win32

Revision History:


--*/


DWORD
ApplyTxTransform(
    PINITXFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITXSFILTER * ppSpecificFilters
    );

DWORD
FormTxOutboundInboundAddresses(
    PINITXFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutSrcAddrList,
    PDWORD pdwOutSrcAddrCnt,
    PADDR * ppInSrcAddrList,
    PDWORD pdwInSrcAddrCnt,
    PADDR * ppOutDesAddrList,
    PDWORD pdwOutDesAddrCnt,
    PADDR * ppInDesAddrList,
    PDWORD pdwInDesAddrCnt
    );

DWORD
FormAddressList(
    ADDR InAddr,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutAddr,
    PDWORD pdwOutAddrCnt
    );

DWORD
SeparateAddrList(
    ADDR_TYPE AddrType,
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppOutAddrList,
    PDWORD pdwOutAddrCnt,
    PADDR * ppInAddrList,
    PDWORD pdwInAddrCnt
    );

DWORD
FormSpecificTxFilters(
    PINITXFILTER pFilter,
    PADDR pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR pDesAddrList,
    DWORD dwDesAddrCnt,
    DWORD dwDirection,
    PINITXSFILTER * ppSpecificFilters
    );

DWORD
SeparateUniqueAddresses(
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppIsMeAddrList,
    PDWORD pdwIsMeAddrCnt,
    PADDR * ppIsNotMeAddrList,
    PDWORD pdwIsNotMeAddrCnt
    );

DWORD
SeparateSubNetAddresses(
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppIsMeAddrList,
    PDWORD pdwIsMeAddrCnt,
    PADDR * ppIsNotMeAddrList,
    PDWORD pdwIsNotMeAddrCnt
    );

DWORD
CreateSpecificTxFilter(
    PINITXFILTER pGenericFilter,
    ADDR SrcAddr,
    ADDR DesAddr,
    PINITXSFILTER * ppSpecificFilter
    );

VOID
AssignTxFilterWeight(
    PINITXSFILTER pSpecificFilter
    );

VOID
AddToSpecificTxList(
    PINITXSFILTER * ppSpecificTxFilterList,
    PINITXSFILTER pSpecificTxFilters
    );

VOID
FreeIniTxSFilterList(
    PINITXSFILTER pIniTxSFilterList
    );

VOID
FreeIniTxSFilter(
    PINITXSFILTER pIniTxSFilter
    );

VOID
LinkTxSpecificFilters(
    PINIQMPOLICY pIniQMPolicy,
    PINITXSFILTER pIniTxSFilters
    );

VOID
RemoveIniTxSFilter(
    PINITXSFILTER pIniTxSFilter
    );

DWORD
EnumSpecificTxFilters(
    PINITXSFILTER pIniTxSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTxFilters,
    PDWORD pdwNumTxFilters
    );

DWORD
CopyTxSFilter(
    PINITXSFILTER pIniTxSFilter,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
EnumSelectSpecificTxFilters(
    PINITXFILTER pIniTxFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTxFilters,
    PDWORD pdwNumTxFilters
    );

DWORD
ValidateTxFilterTemplate(
    PTRANSPORT_FILTER pTxFilter
    );

BOOL
MatchIniTxSFilter(
    PINITXSFILTER pIniTxSFilter,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
CopyTxMatchDefaults(
    PTRANSPORT_FILTER * ppTxFilters,
    PIPSEC_QM_POLICY * ppQMPolicies,
    PDWORD pdwNumMatches
    );

DWORD
CopyDefaultTxFilter(
    PTRANSPORT_FILTER pTxFilter,
    PINIQMPOLICY pIniQMPolicy
    );

DWORD
SeparateInterfaceAddresses(
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppIsMeAddrList,
    PDWORD pdwIsMeAddrCnt,
    PADDR * ppIsNotMeAddrList,
    PDWORD pdwIsNotMeAddrCnt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\utils.c ===
#include "precomp.h"


BOOL
AreGuidsEqual(
    GUID gOldGuid,
    GUID gNewGuid
    )
{
    if (!memcmp(
            &(gOldGuid),
            &(gNewGuid),
            sizeof(GUID))) {
        return (TRUE);
    }

    return (FALSE);
}


VOID
CopyGuid(
    GUID gInGuid,
    GUID * pgOutGuid
    )
{
    memcpy(
        pgOutGuid,
        &gInGuid,
        sizeof(GUID)
        );
}


DWORD
CopyName(
    LPWSTR pszInName,
    LPWSTR * ppszOutName
    )
{
    DWORD dwError = 0;
    LPWSTR pszOutName = NULL;


    if (pszInName && *(pszInName)) {

        dwError = SPDApiBufferAllocate(
                      wcslen(pszInName)*sizeof(WCHAR) + sizeof(WCHAR),
                      &pszOutName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        wcscpy(pszOutName, pszInName);

    }

    *ppszOutName = pszOutName;
    return (dwError);

error:

    *ppszOutName = NULL;
    return (dwError);
}


DWORD
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    )
{
    DWORD dwError = 0;

    if (ppBuffer == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppBuffer = MIDL_user_allocate(dwByteCount);

    if (*ppBuffer == NULL) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


VOID
SPDApiBufferFree(
    LPVOID pBuffer
    )
{
    if (pBuffer) {
        MIDL_user_free(pBuffer);
    }
}


BOOL
AreNamesEqual(
    LPWSTR pszOldName,
    LPWSTR pszNewName
    )
{
    BOOL bEqual = FALSE;


    if (pszOldName && *pszOldName) {

        if (!pszNewName || !*pszNewName) {
            bEqual = FALSE;
        }
        else {

            if (!_wcsicmp(pszOldName, pszNewName)) {
                bEqual = TRUE;
            }
            else {
                bEqual = FALSE;
            }

        }

    }
    else {

        if (!pszNewName || !*pszNewName) {
            bEqual = TRUE;
        }
        else {
            bEqual = FALSE;
        }

    }

    return (bEqual);
}


DWORD
SPDImpersonateClient(
    PBOOL pbImpersonating
    )
{
    DWORD dwError = 0;


    dwError = RpcImpersonateClient(NULL);
    BAIL_ON_WIN32_ERROR(dwError);

    *pbImpersonating = TRUE;
    return (dwError);

error:

    *pbImpersonating = FALSE;
    return (dwError);
}


VOID
SPDRevertToSelf(
    BOOL bImpersonating
    )
{
    if (bImpersonating) {
        RpcRevertToSelf();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txfilter.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    txfilter.c

Abstract:

    This module contains all of the code to drive
    the transport filter list management of IPSecSPD
    Service.

Author:

    abhisheV    05-October-1999

Environment: User Mode


Revision History:


--*/


#include "precomp.h"


DWORD
AddTransportFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phTxFilter
    )
/*++

Routine Description:

    This function adds a generic transport filter to the SPD.

Arguments:

    pServerName - Server on which the transport filter is to be added.

    pTransportFilter - Transport Filter to be added.

    phTxFilter -  Handle to the filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXFILTER pIniExistsTxFilter = NULL;
    PINITXFILTER pIniTxFilter = NULL;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PINITXSFILTER pIniTxSFilters = NULL;
    PTX_FILTER_HANDLE pTxFilterHandle = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    BOOL bPersist = FALSE;


    bPersist = (BOOL) (dwFlags & PERSIST_SPD_OBJECT);

    if (!phTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external transport filter.
    //

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistsTxFilter = FindTxFilter(
                             gpIniTxFilter,
                             pTransportFilter
                             );
    if (pIniExistsTxFilter) {
        //
        // TODO: Also need to check for filter flags and policy id.
        //
        dwError = ERROR_IPSEC_TRANSPORT_FILTER_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniExistsTxFilter = FindTxFilterByGuid(
                             gpTxFilterHandle,
                             pTransportFilter->gFilterID
                             );
    if (pIniExistsTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if ((pTransportFilter->InboundFilterFlag == NEGOTIATE_SECURITY) ||
        (pTransportFilter->OutboundFilterFlag == NEGOTIATE_SECURITY)) {

        dwError = LocateQMPolicy(
                      pTransportFilter->dwFlags,
                      pTransportFilter->gPolicyID,
                      &pIniQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }

    if (bPersist && !gbLoadingPersistence) {
        dwError = PersistTxFilter(
                      pTransportFilter->gFilterID,
                      pTransportFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniTxFilter(
                  pTransportFilter,
                  pIniQMPolicy,
                  &pIniTxFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTxFilter->bIsPersisted = bPersist;

    dwError = GetMatchingInterfaces(
                  pIniTxFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateIniTxSFilters(
                  pIniTxFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniTxSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateTxFilterHandle(
                  pIniTxFilter,
                  pTransportFilter->gFilterID,
                  &pTxFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateSpecificTxFilterLinks(
                  pIniTxFilter,
                  pIniTxSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = InsertTransportFiltersIntoIPSec(
                  pIniTxSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniQMPolicy) {
        LinkTxFilter(
            pIniQMPolicy,
            pIniTxFilter
            );
        LinkTxSpecificFilters(
            pIniQMPolicy,
            pIniTxSFilters
            );
    }

    AddToSpecificTxList(
        &gpIniTxSFilter,
        pIniTxSFilters
        );

    pIniTxFilter->cRef = 1;
    pIniTxFilter->pNext = gpIniTxFilter;
    gpIniTxFilter = pIniTxFilter;

    pTxFilterHandle->pNext = gpTxFilterHandle;
    gpTxFilterHandle = pTxFilterHandle;

    *phTxFilter = (HANDLE) pTxFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pTransportFilter && bPersist && !gbLoadingPersistence) {
        (VOID) SPDPurgeTxFilter(
                   pTransportFilter->gFilterID
                   );
    }

    if (pIniTxFilter) {
        FreeIniTxFilter(pIniTxFilter);
    }

    if (pIniTxSFilters) {
        FreeIniTxSFilterList(pIniTxSFilters);
    }

    if (pTxFilterHandle) {
        FreeTxFilterHandle(pTxFilterHandle);
    }

    *phTxFilter = NULL;
    goto cleanup;
}


DWORD
ValidateTransportFilter(
    PTRANSPORT_FILTER pTxFilter
    )
/*++

Routine Description:

    This function validates an external generic transport filter.

Arguments:

    pTxFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTxFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTxFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTxFilter->SrcAddr,
                     pTxFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pTxFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->SrcPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->DesPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTxFilter->pszFilterName) || !(*(pTxFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTxFilter->InterfaceType >= INTERFACE_TYPE_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTxFilter->InboundFilterFlag >= FILTER_FLAG_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTxFilter->OutboundFilterFlag >= FILTER_FLAG_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTxFilter->dwFlags &&
        !(pTxFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pTxFilter->DesAddr,
                  pTxFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


PINITXFILTER
FindTxFilterByGuid(
    PTX_FILTER_HANDLE pTxFilterHandleList,
    GUID gFilterID
    )
{
    BOOL bEqual = FALSE;
    PTX_FILTER_HANDLE pTxFilterHandle = NULL;


    pTxFilterHandle = pTxFilterHandleList;

    while (pTxFilterHandle) {

        bEqual = AreGuidsEqual(
                     pTxFilterHandle->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pTxFilterHandle->pIniTxFilter);
        }
        pTxFilterHandle = pTxFilterHandle->pNext;

    }

    return (NULL);
}


PINITXFILTER
FindTxFilter(
    PINITXFILTER pGenericTxList,
    PTRANSPORT_FILTER pTxFilter
    )
/*++

Routine Description:

    This function looks for a filter in the filter list.

Arguments:

    pGenericTxList - Filter list in which to search.

    pTxFilter - Filter to search for in the filter list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    PINITXFILTER pIniTxFilter = NULL;
    BOOL bEqual = FALSE;

    pIniTxFilter = pGenericTxList;

    while (pIniTxFilter) {

        bEqual = EqualTxFilterPKeys(
                     pIniTxFilter,
                     pTxFilter
                     );
        if (bEqual) {
            return (pIniTxFilter);
        }

        bEqual = EqualMirroredTxFilterPKeys(
                     pIniTxFilter,
                     pTxFilter
                     );
        if (bEqual) {
            return (pIniTxFilter);
        }

        pIniTxFilter = pIniTxFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualTxFilterPKeys(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    )
/*++

Routine Description:

    This function compares an internal and an external transport 
    filter for equality.

Arguments:

    pIniTxFilter - Filter to compare.

    pTxFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTxFilter->SrcAddr, pTxFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTxFilter->DesAddr, pTxFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTxFilter->SrcPort, pTxFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTxFilter->DesPort, pTxFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTxFilter->Protocol, pTxFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniTxFilter->InterfaceType != pTxFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniTxFilter->bCreateMirror != pTxFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateIniTxFilter(
    PTRANSPORT_FILTER pTxFilter,
    PINIQMPOLICY pIniQMPolicy,
    PINITXFILTER * ppIniTxFilter
    )
/*++

Routine Description:

    This function creates an internal generic transport filter from
    the external filter.

Arguments:

    pTxFilter - External generic transport filter.

    pIniQMPolicy - QM Policy corresponding to the filter.

    ppIniTxFilter - Internal generic transport filter created from
                    the external filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXFILTER pIniTxFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INITXFILTER),
                    &pIniTxFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniTxFilter->cRef = 0;

    pIniTxFilter->bIsPersisted = FALSE;

    pIniTxFilter->bPendingDeletion = FALSE;

    CopyGuid(pTxFilter->gFilterID, &(pIniTxFilter->gFilterID));

    dwError = AllocateSPDString(
                  pTxFilter->pszFilterName,
                  &(pIniTxFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniTxFilter->InterfaceType = pTxFilter->InterfaceType;

    pIniTxFilter->bCreateMirror = pTxFilter->bCreateMirror;

    pIniTxFilter->dwFlags = pTxFilter->dwFlags;

    CopyAddresses(pTxFilter->SrcAddr, &(pIniTxFilter->SrcAddr));

    CopyAddresses(pTxFilter->DesAddr, &(pIniTxFilter->DesAddr));

    CopyPorts(pTxFilter->SrcPort, &(pIniTxFilter->SrcPort));

    CopyPorts(pTxFilter->DesPort, &(pIniTxFilter->DesPort));

    CopyProtocols(pTxFilter->Protocol, &(pIniTxFilter->Protocol));

    pIniTxFilter->InboundFilterFlag = pTxFilter->InboundFilterFlag;

    pIniTxFilter->OutboundFilterFlag = pTxFilter->OutboundFilterFlag;

    if (pIniQMPolicy) {
        CopyGuid(pIniQMPolicy->gPolicyID, &(pIniTxFilter->gPolicyID));
    }
    else {
        CopyGuid(pTxFilter->gPolicyID, &(pIniTxFilter->gPolicyID));
    }

    pIniTxFilter->pIniQMPolicy = NULL;

    pIniTxFilter->dwNumTxSFilters = 0;

    pIniTxFilter->ppIniTxSFilters = NULL;

    pIniTxFilter->pNext = NULL;

    *ppIniTxFilter = pIniTxFilter;
    return (dwError);

error:

    if (pIniTxFilter) {
        FreeIniTxFilter(pIniTxFilter);
    }

    *ppIniTxFilter = NULL;
    return (dwError);
}


DWORD
CreateIniTxSFilters(
    PINITXFILTER pIniTxFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITXSFILTER * ppIniTxSFilters
    )
/*++

Routine Description:

    This function expands a generic filter into a set of specific
    filters.

Arguments:

    pIniTxFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Count of local ip addresses in the list.

    ppIniTxSFilters - Expanded specific filters.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXSFILTER pSpecificFilters = NULL;
    PINITXFILTER pMirroredFilter = NULL;
    PINITXSFILTER pMirroredSpecificFilters = NULL;
    BOOL bEqual = FALSE;


    if (!dwAddrCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = ApplyTxTransform(
                  pIniTxFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTxFilter->bCreateMirror) {

        dwError = CreateIniMirroredTxFilter(
                      pIniTxFilter,
                      &pMirroredFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        bEqual = EqualIniTxFilterPKeys(
                     pIniTxFilter,
                     pMirroredFilter
                     );
        if (!bEqual) {

            dwError = ApplyTxTransform(
                          pMirroredFilter,
                          pMatchingAddresses,
                          dwAddrCnt,
                          &pMirroredSpecificFilters
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            AddToSpecificTxList(
                &pSpecificFilters,
                pMirroredSpecificFilters
                );

        }

    }

    *ppIniTxSFilters = pSpecificFilters;

cleanup:

    if (pMirroredFilter) {
        FreeIniTxFilter(pMirroredFilter);
    }

    return (dwError);

success:
error:

    if (pSpecificFilters) {
        FreeIniTxSFilterList(pSpecificFilters);
    }

    *ppIniTxSFilters = NULL;
    goto cleanup;
}


DWORD
CreateIniMirroredTxFilter(
    PINITXFILTER pFilter,
    PINITXFILTER * ppMirroredFilter
    )
/*++

Routine Description:

    This function creates a mirrored filter for the given filter.

Arguments:

    pFilter - Filter for which to create the mirror.

    ppMirroredFilter - Mirrored filter created for the given filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXFILTER pMirroredFilter = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INITXFILTER),
                  &pMirroredFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->cRef = pFilter->cRef;

    pMirroredFilter->bIsPersisted = pFilter->bIsPersisted;

    pMirroredFilter->bPendingDeletion = pFilter->bPendingDeletion;

    CopyGuid(pFilter->gFilterID, &(pMirroredFilter->gFilterID));

    dwError = AllocateSPDString(
                  pFilter->pszFilterName,
                  &(pMirroredFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->InterfaceType = pFilter->InterfaceType;

    pMirroredFilter->bCreateMirror = pFilter->bCreateMirror;

    pMirroredFilter->dwFlags = pFilter->dwFlags;

    CopyAddresses(pFilter->DesAddr, &(pMirroredFilter->SrcAddr));

    CopyAddresses(pFilter->SrcAddr, &(pMirroredFilter->DesAddr));

    CopyPorts(pFilter->DesPort, &(pMirroredFilter->SrcPort));

    CopyPorts(pFilter->SrcPort, &(pMirroredFilter->DesPort));

    CopyProtocols(pFilter->Protocol, &(pMirroredFilter->Protocol));

    pMirroredFilter->InboundFilterFlag = pFilter->InboundFilterFlag;

    pMirroredFilter->OutboundFilterFlag = pFilter->OutboundFilterFlag;

    CopyGuid(pFilter->gPolicyID, &(pMirroredFilter->gPolicyID));

    pMirroredFilter->pIniQMPolicy = NULL;

    pMirroredFilter->dwNumTxSFilters = 0;

    pMirroredFilter->ppIniTxSFilters = NULL;

    pMirroredFilter->pNext = NULL;

    *ppMirroredFilter = pMirroredFilter;
    return (dwError);

error:

    if (pMirroredFilter) {
        FreeIniTxFilter(pMirroredFilter);
    }

    *ppMirroredFilter = NULL;
    return (dwError);
}


BOOL
EqualIniTxFilterPKeys(
    PINITXFILTER pIniTxFilter,
    PINITXFILTER pFilter
    )
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTxFilter->SrcAddr, pFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTxFilter->DesAddr, pFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTxFilter->SrcPort, pFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTxFilter->DesPort, pFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTxFilter->Protocol, pFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniTxFilter->InterfaceType != pFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniTxFilter->bCreateMirror != pFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateTxFilterHandle(
    PINITXFILTER pIniTxFilter,
    GUID gFilterID,
    PTX_FILTER_HANDLE * ppTxFilterHandle
    )
{
    DWORD dwError = 0;
    PTX_FILTER_HANDLE pTxFilterHandle = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(TX_FILTER_HANDLE),
                    &pTxFilterHandle
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilterHandle->pIniTxFilter= pIniTxFilter;
    CopyGuid(gFilterID, &(pTxFilterHandle->gFilterID));
    pTxFilterHandle->pNext = NULL;

    *ppTxFilterHandle = pTxFilterHandle;
    return (dwError);

error:

    *ppTxFilterHandle = NULL;
    return (dwError);
}


DWORD
CreateSpecificTxFilterLinks(
    PINITXFILTER pIniTxFilter,
    PINITXSFILTER pIniTxSFilters
    )
{
    DWORD dwError = 0;
    PINITXSFILTER pTemp = NULL;
    DWORD dwCnt = 0;
    PINITXSFILTER * ppIniTxSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTxSFilters;

    while (pTemp) {
        dwCnt++;
        pTemp = pTemp->pNext;
    }

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIniTxFilter->ppIniTxSFilters = (PINITXSFILTER *)
                                    AllocSPDMem(
                                        sizeof(PINITXSFILTER)*dwCnt
                                        );
    if (!(pIniTxFilter->ppIniTxSFilters)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);    
    }

    pTemp = pIniTxSFilters;
    ppIniTxSFilters = pIniTxFilter->ppIniTxSFilters;

    for (i = 0; i < dwCnt; i++) {
        *(ppIniTxSFilters + i) = pTemp; 
        pTemp = pTemp->pNext;
    }
    pIniTxFilter->dwNumTxSFilters = dwCnt;

error:

    return (dwError);
}


VOID
LinkTxFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITXFILTER pIniTxFilter
    )
{
    pIniQMPolicy->cRef++;
    pIniTxFilter->pIniQMPolicy = pIniQMPolicy;
    return;
}


VOID
FreeIniTxFilterList(
    PINITXFILTER pIniTxFilterList
    )
{
    PINITXFILTER pFilter = NULL;
    PINITXFILTER pTempFilter = NULL;

    pFilter = pIniTxFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniTxFilter(pTempFilter);
    }
}


VOID
FreeIniTxFilter(
    PINITXFILTER pIniTxFilter
    )
{
    if (pIniTxFilter) {
        if (pIniTxFilter->pszFilterName) {
            FreeSPDString(pIniTxFilter->pszFilterName);
        }

        //
        // Must not ever free pIniTxFilter->pIniQMPolicy.
        //

        //
        // Must not ever free memory pointed by each of
        // the pointers in pIniTxFilter->ppIniTxSFilters.
        //

        if (pIniTxFilter->ppIniTxSFilters) {
            FreeSPDMemory(pIniTxFilter->ppIniTxSFilters);
        }

        FreeSPDMemory(pIniTxFilter);
    }
}


DWORD
DeleteTransportFilter(
    HANDLE hTxFilter
    )
/*++

Routine Description:

    This function deletes a generic transport filter from the SPD.

Arguments:

    hTxFilter -  Handle to the filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTX_FILTER_HANDLE pFilterHandle = NULL;
    PINITXFILTER pIniTxFilter = NULL;


    if (!hTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PTX_FILTER_HANDLE) hTxFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTxFilter = pFilterHandle->pIniTxFilter;

    if (!pIniTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTxFilter->cRef > 1) {

        pIniTxFilter->cRef--;
        pIniTxFilter->bPendingDeletion = TRUE;

        RemoveTxFilterHandle(
            pFilterHandle
            );

        FreeTxFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    if (pIniTxFilter->bIsPersisted) {
        dwError = SPDPurgeTxFilter(
                      pIniTxFilter->gFilterID
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniTxFilter(
                  pIniTxFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    //
    // Delete the filter handle from the list of transport handles.
    //

    RemoveTxFilterHandle(
        pFilterHandle
        );

    FreeTxFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


DWORD
DeleteIniTxFilter(
    PINITXFILTER pIniTxFilter
    )
/*++

Routine Description:

    This function physically deletes a transport filter and all the
    specific transport filters expanded out of it.

Arguments:

    pIniTxFilter - Generic filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    dwError = DeleteIniTxSFilters(
                  pIniTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTxFilter->pIniQMPolicy) {
        DelinkTxFilter(
            pIniTxFilter->pIniQMPolicy,
            pIniTxFilter
            );
    }

    RemoveIniTxFilter(
        pIniTxFilter
        );

    FreeIniTxFilter(pIniTxFilter);

error:

    return (dwError);
}


VOID
DelinkTxFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITXFILTER pIniTxFilter
    )
{
    pIniQMPolicy->cRef--;
    pIniTxFilter->pIniQMPolicy = NULL;
    return;
}


DWORD
DeleteIniTxSFilters(
    PINITXFILTER pIniTxFilter
    )
{
    DWORD dwError = 0;
    PINITXSFILTER * ppIniTxSFilters = NULL;
    DWORD dwNumTxSFilters = 0;
    DWORD i = 0;
    PINITXSFILTER pIniTxSFilter = NULL;
    PINITXSFILTER pIniRemoveTxSFilter = NULL;
    PINITXSFILTER pTemp = NULL;


    ppIniTxSFilters = pIniTxFilter->ppIniTxSFilters;
    dwNumTxSFilters = pIniTxFilter->dwNumTxSFilters;

    for (i = 0; i < dwNumTxSFilters; i++) {

       //
       // Remove each entry from the Transport Specific Filter List.
       //

        pIniTxSFilter =  *(ppIniTxSFilters + i);
        RemoveIniTxSFilter(pIniTxSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniTxSFilter->pNext = NULL;
        AddToSpecificTxList(
            &pIniRemoveTxSFilter,
            pIniTxSFilter
            );

    }

    //
    // Delete the specific filters from the IPSec Driver.
    //

    dwError = DeleteTransportFiltersFromIPSec(
                  pIniRemoveTxSFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Physically delete the removed list.
    //

    while (pIniRemoveTxSFilter) {
        pTemp = pIniRemoveTxSFilter;
        pIniRemoveTxSFilter = pIniRemoveTxSFilter->pNext;
        FreeIniTxSFilter(pTemp);
    }

    return (dwError);

error :

    if (pIniRemoveTxSFilter) {
        AddToSpecificTxList(
            &gpIniTxSFilter,
            pIniRemoveTxSFilter
            );
    }

    return (dwError);
}


VOID
RemoveIniTxFilter(
    PINITXFILTER pIniTxFilter
    )
{
    PINITXFILTER * ppTemp = NULL;

    ppTemp = &gpIniTxFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniTxFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniTxFilter->pNext;
    }

    return;
}


VOID
RemoveTxFilterHandle(
    PTX_FILTER_HANDLE pTxFilterHandle
    )
{
    PTX_FILTER_HANDLE * ppTemp = NULL;

    ppTemp = &gpTxFilterHandle;

    while (*ppTemp) {

        if (*ppTemp == pTxFilterHandle) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pTxFilterHandle->pNext;
    }

    return;
}


VOID
FreeTxFilterHandleList(
    PTX_FILTER_HANDLE pTxFilterHandleList
    )
{
    PTX_FILTER_HANDLE pTxFilterHandle = NULL;
    PTX_FILTER_HANDLE pTemp = NULL;

    pTxFilterHandle = pTxFilterHandleList;

    while (pTxFilterHandle) {
        pTemp = pTxFilterHandle;
        pTxFilterHandle = pTxFilterHandle->pNext;
        FreeTxFilterHandle(pTemp);
    }
}


VOID
FreeTxFilterHandle(
    PTX_FILTER_HANDLE pTxFilterHandle
    )
{
    if (pTxFilterHandle) {
        FreeSPDMemory(pTxFilterHandle);
    }
    return;
}


DWORD
EnumTransportFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,  
    PTRANSPORT_FILTER * ppTransportFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumTxFilters,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function enumerates transport filters from the SPD.

Arguments:

    pServerName - Server on which the filters are to be enumerated.

    dwLevel - Level to identify the type of enumeration desired:
              (i) enumerate generic transport filters or
              (ii) enumerate specific transport filters or
              (iii) enumerate specific transport filters for a 
                    generic transport filter.

    gGenericFilterID - Filter id of the generic transport filter 
                       in the case when the specific transport filters
                       for a generic filter are to be enumerated.
 
    ppTransportFilters - Enumerated Filters returned to the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumTxFilters - Number of filters actually enumerated.

    pdwResumeHandle - Handle to the location in the filter list from
                      which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTxFilters = 0;
    DWORD dwNumTxFilters = 0;
    PINITXFILTER pIniTxFilter = NULL;


    if (!ppTransportFilters || !pdwNumTxFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:

        dwError = EnumGenericTxFilters(
                      gpIniTxFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTxFilters,
                      &dwNumTxFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SELECT_SPECIFIC_FILTERS:

        pIniTxFilter = FindTxFilterByGuid(
                           gpTxFilterHandle,
                           gGenericFilterID
                           );
        if (!pIniTxFilter) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = EnumSelectSpecificTxFilters(
                      pIniTxFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTxFilters,
                      &dwNumTxFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SPECIFIC_FILTERS:

        dwError = EnumSpecificTxFilters(
                      gpIniTxSFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTxFilters,
                      &dwNumTxFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    default:

        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    }

    *ppTransportFilters = pTxFilters;
    *pdwNumTxFilters = dwNumTxFilters;
    *pdwResumeHandle = *pdwResumeHandle + dwNumTxFilters;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppTransportFilters = NULL;
    *pdwNumTxFilters = 0;
    *pdwResumeHandle = *pdwResumeHandle;

    return (dwError);
}


DWORD
EnumGenericTxFilters(
    PINITXFILTER pIniTxFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTxFilters,
    PDWORD pdwNumTxFilters
    )
/*++

Routine Description:

    This function creates enumerated generic filters.

Arguments:

    pIniTxFilterList - List of generic filters to enumerate.

    dwResumeHandle - Location in the generic filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTxFilters - Enumerated filters returned to the caller.

    pdwNumTxFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINITXFILTER pIniTxFilter = NULL;
    DWORD i = 0;
    PINITXFILTER pTemp = NULL;
    DWORD dwNumTxFilters = 0;
    PTRANSPORT_FILTER pTxFilters = 0;
    PTRANSPORT_FILTER pTxFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TRANSPORTFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TRANSPORTFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniTxFilter = pIniTxFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniTxFilter != NULL); i++) {
        pIniTxFilter = pIniTxFilter->pNext;
    }

    if (!pIniTxFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniTxFilter;

    while (pTemp && (dwNumTxFilters < dwNumToEnum)) {
        dwNumTxFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TRANSPORT_FILTER)*dwNumTxFilters,
                  &pTxFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniTxFilter;
    pTxFilter = pTxFilters;

    for (i = 0; i < dwNumTxFilters; i++) {

        dwError = CopyTxFilter(
                      pTemp,
                      pTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTxFilter++;

    }

    *ppTxFilters = pTxFilters;
    *pdwNumTxFilters = dwNumTxFilters;
    return (dwError);

error:

    if (pTxFilters) {
        FreeTxFilters(
            i,
            pTxFilters
            );
    }

    *ppTxFilters = NULL;
    *pdwNumTxFilters = 0;

    return (dwError);
}


DWORD
CopyTxFilter(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniTxFilter - Internal filter to copy.

    pTxFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    CopyGuid(pIniTxFilter->gFilterID, &(pTxFilter->gFilterID));

    dwError = CopyName(
                  pIniTxFilter->pszFilterName,
                  &(pTxFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->InterfaceType = pIniTxFilter->InterfaceType;

    pTxFilter->bCreateMirror = pIniTxFilter->bCreateMirror;

    pTxFilter->dwFlags = pIniTxFilter->dwFlags;

    CopyAddresses(pIniTxFilter->SrcAddr, &(pTxFilter->SrcAddr));

    CopyAddresses(pIniTxFilter->DesAddr, &(pTxFilter->DesAddr));

    CopyProtocols(pIniTxFilter->Protocol, &(pTxFilter->Protocol));

    CopyPorts(pIniTxFilter->SrcPort, &(pTxFilter->SrcPort));

    CopyPorts(pIniTxFilter->DesPort, &(pTxFilter->DesPort));

    pTxFilter->InboundFilterFlag = pIniTxFilter->InboundFilterFlag;

    pTxFilter->OutboundFilterFlag = pIniTxFilter->OutboundFilterFlag;

    pTxFilter->dwDirection = 0;

    pTxFilter->dwWeight = 0;

    CopyGuid(pIniTxFilter->gPolicyID, &(pTxFilter->gPolicyID));

error:

    return (dwError);
}


VOID
FreeTxFilters(
    DWORD dwNumTxFilters,
    PTRANSPORT_FILTER pTxFilters
    )
{
    DWORD i = 0;

    if (pTxFilters) {

        for (i = 0; i < dwNumTxFilters; i++) {

            if (pTxFilters[i].pszFilterName) {
                SPDApiBufferFree(pTxFilters[i].pszFilterName);
            }

        }

        SPDApiBufferFree(pTxFilters);

    }

}


DWORD
SetTransportFilter(
    HANDLE hTxFilter,
    PTRANSPORT_FILTER pTransportFilter
    )
/*++

Routine Description:

    This function sets (updates) a transport filter in the SPD.

Arguments:

    hTxFilter - Handle to the filter to be replaced.

    pTransportFilter - Filter that will replace the existing filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTX_FILTER_HANDLE pFilterHandle = NULL;
    PINITXFILTER pIniTxFilter = NULL;
    BOOL bEqualPKeys = FALSE;


    if (!hTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PTX_FILTER_HANDLE) hTxFilter;

    pIniTxFilter = pFilterHandle->pIniTxFilter;

    if (!pIniTxFilter) {
        dwError = ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTxFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    bEqualPKeys = EqualTxFilterPKeys(
                      pIniTxFilter,
                      pTransportFilter
                      );
    if (!bEqualPKeys) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniTxFilter(
                  pIniTxFilter,
                  pTransportFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniTxFilter->bIsPersisted) {
        dwError = PersistTxFilter(
                      pIniTxFilter->gFilterID,
                      pTransportFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    return (dwError);
}


DWORD
SetIniTxFilter(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    BOOL bEqualNonPKeys = FALSE;
    PINIQMPOLICY pIniNewQMPolicy = NULL;
    PINITXFILTER pIniNewTxFilter = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINITXSFILTER pIniNewTxSFilters = NULL;
    DWORD dwNumTxSFilters = 0;
    PINITXSFILTER * ppIniTxSFilters = NULL;
    LPWSTR pszFilterName = NULL;
    PINITXSFILTER pIniCurTxSFilters = NULL;


    bEqualNonPKeys = EqualTxFilterNonPKeys(
                         pIniTxFilter,
                         pTxFilter
                         );
    if (bEqualNonPKeys) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if ((pTxFilter->InboundFilterFlag == NEGOTIATE_SECURITY) ||
        (pTxFilter->OutboundFilterFlag == NEGOTIATE_SECURITY)) {

        dwError = LocateQMPolicy(
                      pTxFilter->dwFlags,
                      pTxFilter->gPolicyID,
                      &pIniNewQMPolicy
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = CreateIniTxFilter(
                  pTxFilter,
                  pIniNewQMPolicy,
                  &pIniNewTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GetMatchingInterfaces(
                  pIniNewTxFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniTxSFilters(
                  pIniNewTxFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniNewTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateTxSFilterLinks(
                  pIniNewTxSFilters,
                  &dwNumTxSFilters,
                  &ppIniTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDString(
                  pTxFilter->pszFilterName,
                  &pszFilterName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveTxSFilters(
        pIniTxFilter,
        &pIniCurTxSFilters
        );

    dwError = DeleteTransportFiltersFromIPSec(
                  pIniCurTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = InsertTransportFiltersIntoIPSec(
                  pIniNewTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    UpdateTxSFilterLinks(
        pIniTxFilter,
        dwNumTxSFilters,
        ppIniTxSFilters
        );

    if (pIniTxFilter->pIniQMPolicy) {
        DelinkTxFilter(
            pIniTxFilter->pIniQMPolicy,
            pIniTxFilter
            );
    }

    if (pIniNewQMPolicy) {
        LinkTxFilter(
            pIniNewQMPolicy,
            pIniTxFilter
            );
        LinkTxSpecificFilters(
            pIniNewQMPolicy,
            pIniNewTxSFilters
            );
    }

    UpdateTxFilterNonPKeys(
        pIniTxFilter,
        pszFilterName,
        pTxFilter,
        pIniNewQMPolicy
        );

    AddToSpecificTxList(
        &gpIniTxSFilter,
        pIniNewTxSFilters
        );

    if (pIniCurTxSFilters) {
        FreeIniTxSFilterList(pIniCurTxSFilters);
    }

cleanup:

    if (pIniNewTxFilter) {
        FreeIniTxFilter(pIniNewTxFilter);
    }

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    if (pIniNewTxSFilters) {
        FreeIniTxSFilterList(pIniNewTxSFilters);
    }

    if (ppIniTxSFilters) {
        FreeSPDMemory(ppIniTxSFilters);
    }

    if (pszFilterName) {
        FreeSPDString(pszFilterName);
    }

    if (pIniCurTxSFilters) {
        AddToSpecificTxList(
            &gpIniTxSFilter,
            pIniCurTxSFilters
            );
    }

    goto cleanup;
}


BOOL
EqualTxFilterNonPKeys(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    )
{
    if (_wcsicmp(
            pIniTxFilter->pszFilterName,
            pTxFilter->pszFilterName)) {
        return (FALSE);
    }

    if (pIniTxFilter->InboundFilterFlag != 
        pTxFilter->InboundFilterFlag) {
        return (FALSE);
    }

    if (pIniTxFilter->OutboundFilterFlag != 
        pTxFilter->OutboundFilterFlag) {
        return (FALSE);
    }

    if ((pIniTxFilter->InboundFilterFlag == NEGOTIATE_SECURITY) ||
        (pIniTxFilter->OutboundFilterFlag == NEGOTIATE_SECURITY)) {
        if ((pIniTxFilter->dwFlags) != (pTxFilter->dwFlags)) {
            return (FALSE);
        }

        if (memcmp(
                &(pIniTxFilter->gPolicyID),
                &(pTxFilter->gPolicyID),
                sizeof(GUID))) {
            return (FALSE);
        }
    }

    return (TRUE);
}


DWORD
CreateTxSFilterLinks(
    PINITXSFILTER pIniTxSFilters,
    PDWORD pdwNumTxSFilters,
    PINITXSFILTER ** pppIniTxSFilters
    )
{
    DWORD dwError = 0;
    PINITXSFILTER pTemp = NULL;
    DWORD dwNumTxSFilters = 0;
    PINITXSFILTER * ppIniTxSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTxSFilters;
    while (pTemp) {
        dwNumTxSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumTxSFilters) {
        ppIniTxSFilters = (PINITXSFILTER *)
                          AllocSPDMem(
                              sizeof(PINITXSFILTER)*
                              dwNumTxSFilters
                              );
        if (!ppIniTxSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    pTemp = pIniTxSFilters;
    for (i = 0; i < dwNumTxSFilters; i++) {
        *(ppIniTxSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    *pdwNumTxSFilters = dwNumTxSFilters;
    *pppIniTxSFilters = ppIniTxSFilters;
    return (dwError);

error:

    *pdwNumTxSFilters = 0;
    *pppIniTxSFilters = NULL;
    return (dwError);
}


VOID
RemoveTxSFilters(
    PINITXFILTER pIniTxFilter,
    PINITXSFILTER * ppIniCurTxSFilters 
    )
{
    PINITXSFILTER * ppIniTxSFilters = NULL;
    DWORD dwNumTxSFilters = 0;
    DWORD i = 0;
    PINITXSFILTER pIniTxSFilter = NULL;
    PINITXSFILTER pIniCurTxSFilters = NULL;


    ppIniTxSFilters = pIniTxFilter->ppIniTxSFilters;
    dwNumTxSFilters = pIniTxFilter->dwNumTxSFilters;

    for (i = 0; i < dwNumTxSFilters; i++) {

        //
        // Remove each entry from the Transport Specific Filter List.
        //

        pIniTxSFilter =  *(ppIniTxSFilters + i);
        RemoveIniTxSFilter(pIniTxSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniTxSFilter->pNext = NULL;
        AddToSpecificTxList(
            &pIniCurTxSFilters,
            pIniTxSFilter
            );

    }

    *ppIniCurTxSFilters = pIniCurTxSFilters;
}


VOID
UpdateTxSFilterLinks(
    PINITXFILTER pIniTxFilter,
    DWORD dwNumTxSFilters,
    PINITXSFILTER * ppIniTxSFilters
    )
{
    if (pIniTxFilter->ppIniTxSFilters) {
        FreeSPDMemory(pIniTxFilter->ppIniTxSFilters);
    }

    pIniTxFilter->ppIniTxSFilters = ppIniTxSFilters;
    pIniTxFilter->dwNumTxSFilters = dwNumTxSFilters;
}


VOID
UpdateTxFilterNonPKeys(
    PINITXFILTER pIniTxFilter,
    LPWSTR pszFilterName,
    PTRANSPORT_FILTER pTxFilter,
    PINIQMPOLICY pIniQMPolicy
    )
{
    if (pIniTxFilter->pszFilterName) {
        FreeSPDString(pIniTxFilter->pszFilterName);
    }
    pIniTxFilter->pszFilterName = pszFilterName;

    pIniTxFilter->dwFlags = pTxFilter->dwFlags;

    pIniTxFilter->InboundFilterFlag = pTxFilter->InboundFilterFlag;

    pIniTxFilter->OutboundFilterFlag = pTxFilter->OutboundFilterFlag;

    if (pIniQMPolicy) {
        CopyGuid(pIniQMPolicy->gPolicyID, &(pIniTxFilter->gPolicyID));
    }
    else {
        CopyGuid(pTxFilter->gPolicyID, &(pIniTxFilter->gPolicyID));
    }
}


DWORD
GetTransportFilter(
    HANDLE hTxFilter,
    PTRANSPORT_FILTER * ppTransportFilter
    )
/*++

Routine Description:

    This function retrieves a transport filter from the SPD.

Arguments:

    hTxFilter - Handle to the filter to be retrieved.

    ppTransportFilter -  Filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTX_FILTER_HANDLE pFilterHandle = NULL;
    PINITXFILTER pIniTxFilter = NULL;
    PTRANSPORT_FILTER pTransportFilter = NULL;


    if (!hTxFilter || !ppTransportFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PTX_FILTER_HANDLE) hTxFilter;

    pIniTxFilter = pFilterHandle->pIniTxFilter;

    if (!pIniTxFilter) {
        dwError = ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniTxFilter(
                  pIniTxFilter,
                  &pTransportFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    *ppTransportFilter = pTransportFilter;
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppTransportFilter = NULL;
    return (dwError);
}


DWORD
GetIniTxFilter(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER * ppTxFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTxFilter = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(TRANSPORT_FILTER),
                  &pTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyTxFilter(
                  pIniTxFilter,
                  pTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppTxFilter = pTxFilter;
    return (dwError);

error:

    if (pTxFilter) {
        SPDApiBufferFree(pTxFilter);
    }

    *ppTxFilter = NULL;
    return (dwError);
}


DWORD
ApplyIfChangeToIniTxFilters(
    PDWORD pdwTxError,
    PIPSEC_INTERFACE pLatestIfList
    )
{
    DWORD dwError = 0;
    PINITXFILTER pIniTxFilter = NULL;


    pIniTxFilter = gpIniTxFilter;

    while (pIniTxFilter) {

        dwError = UpdateIniTxFilterThruIfChange(
                      pIniTxFilter,
                      pLatestIfList
                      );
        if (dwError) {
            *pdwTxError = dwError;
        }

        pIniTxFilter = pIniTxFilter->pNext;

    }

    dwError = ERROR_SUCCESS;
    return (dwError);
}


DWORD
UpdateIniTxFilterThruIfChange(
    PINITXFILTER pIniTxFilter,
    PIPSEC_INTERFACE pLatestIfList
    )
{
    DWORD dwError = 0;
    PINITXSFILTER pLatestIniTxSFilters = NULL;
    DWORD dwNumTxSFilters = 0;
    PINITXSFILTER * ppIniTxSFilters = NULL;
    PINITXSFILTER pCurIniTxSFilters = NULL;
    PINITXSFILTER pNewIniTxSFilters = NULL;
    PINITXSFILTER pOldIniTxSFilters = NULL;
    BOOL bDeletedFromDriver = FALSE;
 

    dwError = FormIniTxSFilters(
                  pIniTxFilter,
                  pLatestIfList,
                  &pLatestIniTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateTxSFilterLinks(
                  pLatestIniTxSFilters,
                  &dwNumTxSFilters,
                  &ppIniTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveTxSFilters(
        pIniTxFilter,
        &pCurIniTxSFilters
        );

    ProcessIniTxSFilters(
        &pLatestIniTxSFilters,
        &pCurIniTxSFilters,
        &pNewIniTxSFilters,
        &pOldIniTxSFilters
        );

    dwError = DeleteTransportFiltersFromIPSec(
                  pOldIniTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    bDeletedFromDriver = TRUE;

    dwError = InsertTransportFiltersIntoIPSec(
                  pNewIniTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTxFilter->pIniQMPolicy) {
        LinkTxSpecificFilters(
            pIniTxFilter->pIniQMPolicy,
            pCurIniTxSFilters
            );
        LinkTxSpecificFilters(
            pIniTxFilter->pIniQMPolicy,
            pNewIniTxSFilters
            );
    }

    SetTxSFilterLinks(
        pCurIniTxSFilters,
        pNewIniTxSFilters,
        dwNumTxSFilters,
        ppIniTxSFilters
        );

    UpdateTxSFilterLinks(
        pIniTxFilter,
        dwNumTxSFilters,
        ppIniTxSFilters
        );

    AddToSpecificTxList(
        &gpIniTxSFilter,
        pCurIniTxSFilters
        );

    AddToSpecificTxList(
        &gpIniTxSFilter,
        pNewIniTxSFilters
        );

    if (pOldIniTxSFilters) {
        FreeIniTxSFilterList(pOldIniTxSFilters);
    }

    return (dwError);

error:

    if (pLatestIniTxSFilters) {
        FreeIniTxSFilterList(pLatestIniTxSFilters);
    }

    if (ppIniTxSFilters) {
        FreeSPDMemory(ppIniTxSFilters);
    }

    if (pCurIniTxSFilters) {
        AddToSpecificTxList(
            &gpIniTxSFilter,
            pCurIniTxSFilters
            );
    }

    if (pNewIniTxSFilters) {
        FreeIniTxSFilterList(pNewIniTxSFilters);
    }

    if (pOldIniTxSFilters) {
        if (bDeletedFromDriver) {
            (VOID) InsertTransportFiltersIntoIPSec(
                       pOldIniTxSFilters
                       );
        }
        AddToSpecificTxList(
            &gpIniTxSFilter,
            pOldIniTxSFilters
            );
    }

    return (dwError);
}


DWORD
FormIniTxSFilters(
    PINITXFILTER pIniTxFilter,
    PIPSEC_INTERFACE pIfList,
    PINITXSFILTER * ppIniTxSFilters
    )
{
    DWORD dwError = 0;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINITXSFILTER pIniTxSFilters = NULL;


    dwError = GetMatchingInterfaces(
                  pIniTxFilter->InterfaceType,
                  pIfList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniTxSFilters(
                  pIniTxFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniTxSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniTxSFilters = pIniTxSFilters;

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    *ppIniTxSFilters = NULL;

    goto cleanup;
}


VOID
ProcessIniTxSFilters(
    PINITXSFILTER * ppLatestIniTxSFilters,
    PINITXSFILTER * ppCurIniTxSFilters,
    PINITXSFILTER * ppNewIniTxSFilters,
    PINITXSFILTER * ppOldIniTxSFilters
    )
{
    PINITXSFILTER pLatestIniTxSFilters = NULL;
    PINITXSFILTER pCurIniTxSFilters = NULL;
    PINITXSFILTER pTempCur = NULL;
    BOOL bEqual = FALSE;
    PINITXSFILTER pTempLatest = NULL;
    PINITXSFILTER pTemp = NULL;
    PINITXSFILTER pNewIniTxSFilters = NULL;
    PINITXSFILTER pOldIniTxSFilters = NULL;
    PINITXSFILTER pTempPreToCur = NULL;
    PINITXSFILTER pTempPreToLatest = NULL;


    pCurIniTxSFilters = *ppCurIniTxSFilters;
    pTempCur = *ppCurIniTxSFilters;

    while (pTempCur) {

        bEqual = FALSE;
        pTempLatest = *ppLatestIniTxSFilters;

        while (pTempLatest) {

            bEqual = EqualIniTxSFilterIfPKeys(
                         pTempLatest,
                         pTempCur
                         );
            if (bEqual) {
                break;
            }

            pTempLatest = pTempLatest->pNext;

        }

        if (bEqual) {
            pTempPreToCur  = pTempCur;
            pTempCur = pTempCur->pNext;
        }
        else {
            pTemp = pTempCur;
            pTempCur = pTempCur->pNext;
            if (pTempPreToCur) {
                pTempPreToCur->pNext = pTempCur;
            }
            else {
                pCurIniTxSFilters = pTempCur;
            }
            pTemp->pNext = NULL;
            AddToSpecificTxList(
                &pOldIniTxSFilters,
                pTemp
                );
        }

    }

    pLatestIniTxSFilters = *ppLatestIniTxSFilters;
    pTempLatest = *ppLatestIniTxSFilters;

    while (pTempLatest) {

        bEqual = FALSE;
        pTempCur = pCurIniTxSFilters;

        while (pTempCur) {

            bEqual = EqualIniTxSFilterIfPKeys(
                         pTempCur,
                         pTempLatest
                         );
            if (bEqual) {
                break;
            }

            pTempCur = pTempCur->pNext;

        }

        if (bEqual) {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniTxSFilters = pTempLatest;
            }
            FreeIniTxSFilter(pTemp);
        }
        else {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniTxSFilters = pTempLatest;
            }
            pTemp->pNext = NULL;
            AddToSpecificTxList(
                &pNewIniTxSFilters,
                pTemp
                );
        }

    }

    *ppLatestIniTxSFilters = pLatestIniTxSFilters;
    *ppCurIniTxSFilters = pCurIniTxSFilters;
    *ppNewIniTxSFilters = pNewIniTxSFilters;
    *ppOldIniTxSFilters = pOldIniTxSFilters;
}


BOOL
EqualIniTxSFilterIfPKeys(
    PINITXSFILTER pExsIniTxSFilter,
    PINITXSFILTER pNewIniTxSFilter
    )
{
    BOOL  bCmp = FALSE;


    //
    // No need to compare: gParentID, pszFilterName, dwFlags
    //                     cRef, Protocol, SrcPort, DesPort,
    //                     InboundFilterFlag, OutboundFilterFlag,
    //                     dwWeight and gPolicyID.
    // They will be the same for both the filters.
    //

    if (pExsIniTxSFilter->InterfaceType != pNewIniTxSFilter->InterfaceType) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniTxSFilter->SrcAddr, pNewIniTxSFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniTxSFilter->DesAddr, pNewIniTxSFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pExsIniTxSFilter->dwDirection != pNewIniTxSFilter->dwDirection) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
AllocateTxSFilterLinks(
    PINITXSFILTER pIniTxSFilters,
    PDWORD pdwNumTxSFilters,
    PINITXSFILTER ** pppIniTxSFilters
    )
{
    DWORD dwError = 0;
    PINITXSFILTER pTemp = NULL;
    DWORD dwNumTxSFilters = 0;
    PINITXSFILTER * ppIniTxSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTxSFilters;
    while (pTemp) {
        dwNumTxSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumTxSFilters) {
        ppIniTxSFilters = (PINITXSFILTER *)
                          AllocSPDMem(
                              sizeof(PINITXSFILTER)*
                              dwNumTxSFilters
                              );
        if (!ppIniTxSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    for (i = 0; i < dwNumTxSFilters; i++) {
        *(ppIniTxSFilters + i) = NULL;
    }

    *pdwNumTxSFilters = dwNumTxSFilters;
    *pppIniTxSFilters = ppIniTxSFilters;
    return (dwError);

error:

    *pdwNumTxSFilters = 0;
    *pppIniTxSFilters = NULL;
    return (dwError);
}


VOID
SetTxSFilterLinks(
    PINITXSFILTER pCurIniTxSFilters,
    PINITXSFILTER pNewIniTxSFilters,
    DWORD dwNumTxSFilters,
    PINITXSFILTER * ppIniTxSFilters
    )
{
    PINITXSFILTER pTemp = NULL;
    DWORD i = 0;
    DWORD j = 0;


    pTemp = pCurIniTxSFilters;
    for (i = 0; (i < dwNumTxSFilters) && (pTemp != NULL); i++) {
        *(ppIniTxSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    pTemp = pNewIniTxSFilters;
    for (j = i; (j < dwNumTxSFilters) && (pTemp != NULL); j++) {
        *(ppIniTxSFilters + j) = pTemp;
        pTemp = pTemp->pNext;
    }
}


DWORD
OpenTransportFilterHandle(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phTxFilter
    )
{
    DWORD dwError = 0;
    PINITXFILTER pIniExistingTxFilter = NULL;
    PTX_FILTER_HANDLE pTxFilterHandle = NULL;


    if (!phTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external Transport filter.
    //

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingTxFilter = FindExactTxFilter(
                               gpIniTxFilter,
                               pTransportFilter
                               );
    if (!pIniExistingTxFilter) {
        dwError = ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniExistingTxFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateTxFilterHandle(
                  pIniExistingTxFilter,
                  pTransportFilter->gFilterID,
                  &pTxFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingTxFilter->cRef++;

    pTxFilterHandle->pNext = gpTxFilterHandle;
    gpTxFilterHandle = pTxFilterHandle;

    *phTxFilter = (HANDLE) pTxFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pTxFilterHandle) {
        FreeTxFilterHandle(pTxFilterHandle);
    }

    *phTxFilter = NULL;
    goto cleanup;
}


DWORD
CloseTransportFilterHandle(
    HANDLE hTxFilter
    )
{
    DWORD dwError = 0;
    PTX_FILTER_HANDLE pFilterHandle = NULL;
    PINITXFILTER pIniTxFilter = NULL;


    if (!hTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PTX_FILTER_HANDLE) hTxFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTxFilter = pFilterHandle->pIniTxFilter;

    if (!pIniTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTxFilter->cRef > 1) {

        pIniTxFilter->cRef--;

        RemoveTxFilterHandle(
            pFilterHandle
            );
        FreeTxFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    if (pIniTxFilter->bPendingDeletion) {

        if (pIniTxFilter->bIsPersisted) {
            dwError = SPDPurgeTxFilter(
                          pIniTxFilter->gFilterID
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = DeleteIniTxFilter(
                      pIniTxFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }
    else {
        pIniTxFilter->cRef--;
    }

    RemoveTxFilterHandle(
        pFilterHandle
        );
    FreeTxFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


PINITXFILTER
FindExactTxFilter(
    PINITXFILTER pGenericTxList,
    PTRANSPORT_FILTER pTransportFilter
    )
{
    PINITXFILTER pIniTxFilter = NULL;
    BOOL bEqual = FALSE;


    pIniTxFilter = pGenericTxList;

    while (pIniTxFilter) {

        bEqual = EqualTxFilterPKeys(
                     pIniTxFilter,
                     pTransportFilter
                     );
        if (bEqual) {
            bEqual = EqualTxFilterNonPKeys(
                         pIniTxFilter,
                         pTransportFilter
                         );
            if (bEqual) {
                return (pIniTxFilter);
            }
        }

        pIniTxFilter = pIniTxFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualMirroredTxFilterPKeys(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    )
/*++

Routine Description:

    This function compares an internal and an external transport 
    filter for equality.

Arguments:

    pIniTxFilter - Filter to compare.

    pTxFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTxFilter->DesAddr, pTxFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTxFilter->SrcAddr, pTxFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTxFilter->DesPort, pTxFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTxFilter->SrcPort, pTxFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTxFilter->Protocol, pTxFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if ((pIniTxFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pTxFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pIniTxFilter->InterfaceType != pTxFilter->InterfaceType)) {
        return (FALSE);
    }

    if (!pIniTxFilter->bCreateMirror && !pTxFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}

DWORD
ValidateIPSecQMFilter(
    PIPSEC_QM_FILTER pQMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;

    if (!pQMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pQMFilter->SrcAddr, FALSE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pQMFilter->DesAddr, FALSE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pQMFilter->SrcAddr,
                     pQMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pQMFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pQMFilter->SrcPort,
                  pQMFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pQMFilter->DesPort,
                  pQMFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    if (pQMFilter->QMFilterType == QM_TUNNEL_FILTER) {

        if (pQMFilter->MyTunnelEndpt.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        if (pQMFilter->PeerTunnelEndpt.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        dwError = VerifyAddresses(pQMFilter->MyTunnelEndpt, FALSE, FALSE);
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = VerifyAddresses(pQMFilter->PeerTunnelEndpt, FALSE, FALSE);
        BAIL_ON_WIN32_ERROR(dwError);

    }

    if (pQMFilter->QMFilterType != QM_TUNNEL_FILTER &&
        pQMFilter->QMFilterType != QM_TRANSPORT_FILTER) {
        dwError=ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txfilter.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    txfilter.h

Abstract:

    This module contains all of the code prototypes to
    drive the transport filter list management of
    IPSecSPD Service.

Author:


Environment: User Mode


Revision History:


--*/


typedef struct _initxfilter {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD cRef;
    BOOL bIsPersisted;
    BOOL bPendingDeletion;
    GUID gPolicyID;
    PINIQMPOLICY pIniQMPolicy;
    DWORD dwNumTxSFilters;
    struct _initxsfilter ** ppIniTxSFilters;
    struct _initxfilter * pNext;
} INITXFILTER, * PINITXFILTER;


typedef struct _initxsfilter {
    GUID gParentID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD cRef;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
    PINIQMPOLICY pIniQMPolicy;
    struct _initxsfilter * pNext;
} INITXSFILTER, * PINITXSFILTER;


typedef struct _tx_filter_handle {
    PINITXFILTER pIniTxFilter;
    GUID gFilterID;
    struct _tx_filter_handle * pNext;
} TX_FILTER_HANDLE, * PTX_FILTER_HANDLE;


DWORD
ValidateTransportFilter(
    PTRANSPORT_FILTER pTxFilter
    );

PINITXFILTER
FindTxFilterByGuid(
    PTX_FILTER_HANDLE pTxFilterHandleList,
    GUID gFilterID
    );
  
PINITXFILTER
FindTxFilter(
    PINITXFILTER pGenericTxList,
    PTRANSPORT_FILTER pTxFilter
    );

BOOL
EqualTxFilterPKeys(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
CreateIniTxFilter(
    PTRANSPORT_FILTER pTxFilter,
    PINIQMPOLICY pIniQMPolicy,
    PINITXFILTER * ppIniTxFilter
    );

DWORD
CreateIniTxSFilters(
    PINITXFILTER pIniTxFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITXSFILTER * ppIniTxSFilters
    );

DWORD
CreateIniMirroredTxFilter(
    PINITXFILTER pFilter,
    PINITXFILTER * ppMirroredFilter
    );

BOOL
EqualIniTxFilterPKeys(
    PINITXFILTER pIniTxFilter,
    PINITXFILTER pFilter
    );

DWORD
CreateTxFilterHandle(
    PINITXFILTER pIniTxFilter,
    GUID gFilterID,
    PTX_FILTER_HANDLE * ppTxFilterHandle
    );

DWORD
CreateSpecificTxFilterLinks(
    PINITXFILTER pIniTxFilter,
    PINITXSFILTER pIniTxSFilters
    );

VOID
LinkTxFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITXFILTER pIniTxFilter
    );

VOID
FreeIniTxFilterList(
    PINITXFILTER pIniTxFilterList
    );

VOID
FreeIniTxFilter(
    PINITXFILTER pIniTxFilter
    );

DWORD
DeleteIniTxFilter(
    PINITXFILTER pIniTxFilter
    );

VOID
DelinkTxFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITXFILTER pIniTxFilter
    );

DWORD
DeleteIniTxSFilters(
    PINITXFILTER pIniTxFilter
    );

VOID
RemoveIniTxFilter(
    PINITXFILTER pIniTxFilter
    );

VOID
RemoveTxFilterHandle(
    PTX_FILTER_HANDLE pTxFilterHandle
    );

VOID
FreeTxFilterHandleList(
    PTX_FILTER_HANDLE pTxFilterHandleList
    );

VOID
FreeTxFilterHandle(
    PTX_FILTER_HANDLE pTxFilterHandle
    );

DWORD
EnumGenericTxFilters(
    PINITXFILTER pIniTxFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTxFilters,
    PDWORD pdwNumTxFilters
    );

DWORD
CopyTxFilter(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    );

VOID
FreeTxFilters(
    DWORD dwNumTxFilters,
    PTRANSPORT_FILTER pTxFilters
    );

DWORD
SetIniTxFilter(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    );

BOOL
EqualTxFilterNonPKeys(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
CreateTxSFilterLinks(
    PINITXSFILTER pIniTxSFilters,
    PDWORD pdwNumTxSFilters,
    PINITXSFILTER ** pppIniTxSFilters
    );

VOID
RemoveTxSFilters(
    PINITXFILTER pIniTxFilter,
    PINITXSFILTER * ppIniCurTxSFilters 
    );

VOID
UpdateTxSFilterLinks(
    PINITXFILTER pIniTxFilter,
    DWORD dwNumTxSFilters,
    PINITXSFILTER * ppIniTxSFilters
    );

VOID
UpdateTxFilterNonPKeys(
    PINITXFILTER pIniTxFilter,
    LPWSTR pszFilterName,
    PTRANSPORT_FILTER pTxFilter,
    PINIQMPOLICY pIniQMPolicy
    );

DWORD
GetIniTxFilter(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER * ppTxFilter
    );

DWORD
ApplyIfChangeToIniTxFilters(
    PDWORD pdwTxError,
    PIPSEC_INTERFACE pLatestIfList
    );

DWORD
UpdateIniTxFilterThruIfChange(
    PINITXFILTER pIniTxFilter,
    PIPSEC_INTERFACE pLatestIfList
    );

DWORD
FormIniTxSFilters(
    PINITXFILTER pIniTxFilter,
    PIPSEC_INTERFACE pIfList,
    PINITXSFILTER * ppIniTxSFilters
    );

VOID
ProcessIniTxSFilters(
    PINITXSFILTER * ppLatestIniTxSFilters,
    PINITXSFILTER * ppCurIniTxSFilters,
    PINITXSFILTER * ppNewIniTxSFilters,
    PINITXSFILTER * ppOldIniTxSFilters
    );

BOOL
EqualIniTxSFilterIfPKeys(
    PINITXSFILTER pExsIniTxSFilter,
    PINITXSFILTER pNewIniTxSFilter
    );

DWORD
AllocateTxSFilterLinks(
    PINITXSFILTER pIniTxSFilters,
    PDWORD pdwNumTxSFilters,
    PINITXSFILTER ** pppIniTxSFilters
    );

VOID
SetTxSFilterLinks(
    PINITXSFILTER pCurIniTxSFilters,
    PINITXSFILTER pNewIniTxSFilters,
    DWORD dwNumTxSFilters,
    PINITXSFILTER * ppIniTxSFilters
    );

PINITXFILTER
FindExactTxFilter(
    PINITXFILTER pGenericTxList,
    PTRANSPORT_FILTER pTxFilter
    );

BOOL
EqualMirroredTxFilterPKeys(
    PINITXFILTER pIniTxFilter,
    PTRANSPORT_FILTER pTxFilter
    );

DWORD
ValidateIPSecQMFilter(
    PIPSEC_QM_FILTER pQMFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\utils.h ===
BOOL
AreGuidsEqual(
    GUID OldGuid,
    GUID gNewGuid
    );

VOID
CopyGuid(
    GUID gInGuid,
    GUID * pgOutGuid
    );

DWORD
CopyName(
    LPWSTR pszInName,
    LPWSTR * ppszOutName
    );

BOOL
AreNamesEqual(
    LPWSTR pszOldName,
    LPWSTR pszNewName
    );

DWORD
SPDImpersonateClient(
    PBOOL pbImpersonating
    );

VOID
SPDRevertToSelf(
    BOOL bImpersonating
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\txspecific.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    txspecific.c

Abstract:

    This module contains all of the code to drive the
    specific transport filter list management of IPSecSPD
    Service.

Author:

    abhisheV    29-October-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
ApplyTxTransform(
    PINITXFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINITXSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function expands a generic transport filter into its
    corresponding specific filters.

Arguments:

    pFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppSpecificFilters - List of specific filters expanded for the
                        given generic filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXSFILTER pSpecificFilters = NULL;
    PINITXSFILTER pOutboundSpecificFilters = NULL;
    PINITXSFILTER pInboundSpecificFilters = NULL;

    PADDR pOutSrcAddrList = NULL;
    DWORD dwOutSrcAddrCnt = 0;
    PADDR pInSrcAddrList = NULL;
    DWORD dwInSrcAddrCnt = 0;

    PADDR pOutDesAddrList = NULL;
    DWORD dwOutDesAddrCnt = 0;
    PADDR pInDesAddrList = NULL;
    DWORD dwInDesAddrCnt = 0;


    // 
    // Form the outbound and inbound source and destination
    // address lists.
    // 

    dwError = FormTxOutboundInboundAddresses(
                  pFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pOutSrcAddrList,
                  &dwOutSrcAddrCnt,
                  &pInSrcAddrList,
                  &dwInSrcAddrCnt,
                  &pOutDesAddrList,
                  &dwOutDesAddrCnt,
                  &pInDesAddrList,
                  &dwInDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form outbound specific filters.
    //

    dwError = FormSpecificTxFilters(
                  pFilter,
                  pOutSrcAddrList,
                  dwOutSrcAddrCnt,
                  pOutDesAddrList,
                  dwOutDesAddrCnt,
                  FILTER_DIRECTION_OUTBOUND,
                  &pOutboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form inbound specific filters.
    //

    dwError = FormSpecificTxFilters(
                  pFilter,
                  pInSrcAddrList,
                  dwInSrcAddrCnt,
                  pInDesAddrList,
                  dwInDesAddrCnt,
                  FILTER_DIRECTION_INBOUND,
                  &pInboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pSpecificFilters = pOutboundSpecificFilters;

    AddToSpecificTxList(
        &pSpecificFilters,
        pInboundSpecificFilters
        );


    *ppSpecificFilters = pSpecificFilters;

cleanup:

    if (pOutSrcAddrList) {
        FreeSPDMemory(pOutSrcAddrList);
    }

    if (pInSrcAddrList) {
        FreeSPDMemory(pInSrcAddrList);
    }

    if (pOutDesAddrList) {
        FreeSPDMemory(pOutDesAddrList);
    }

    if (pInDesAddrList) {
        FreeSPDMemory(pInDesAddrList);
    }

    return (dwError);

error:

    if (pOutboundSpecificFilters) {
        FreeIniTxSFilterList(pOutboundSpecificFilters);
    }

    if (pInboundSpecificFilters) {
        FreeIniTxSFilterList(pInboundSpecificFilters);
    }


    *ppSpecificFilters = NULL;
    goto cleanup;
}


DWORD
FormTxOutboundInboundAddresses(
    PINITXFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutSrcAddrList,
    PDWORD pdwOutSrcAddrCnt,
    PADDR * ppInSrcAddrList,
    PDWORD pdwInSrcAddrCnt,
    PADDR * ppOutDesAddrList,
    PDWORD pdwOutDesAddrCnt,
    PADDR * ppInDesAddrList,
    PDWORD pdwInDesAddrCnt
    )
/*++

Routine Description:

    This function forms the outbound and inbound source and
    destination address sets for a generic filter.

Arguments:

    pFilter - Generic filter under consideration.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppOutSrcAddrList - List of outbound source addresses.

    pdwOutSrcAddrCnt - Number of addresses in the outbound
                       source address list.

    ppInSrcAddrList - List of inbound source addresses.

    pdwInSrcAddrCnt - Number of addresses in the inbound
                      source address list.

    ppOutDesAddrList - List of outbound destination addresses.

    pdwOutDesAddrCnt - Number of addresses in the outbound
                       destination address list.

    ppInDesAddrList - List of inbound destination addresses.

    pdwInDesAddrCnt - Number of addresses in the inbound
                      destination address list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    PADDR pSrcAddrList = NULL;
    DWORD dwSrcAddrCnt = 0;
    PADDR pDesAddrList = NULL;
    DWORD dwDesAddrCnt = 0;

    PADDR pOutSrcAddrList = NULL;
    DWORD dwOutSrcAddrCnt = 0;
    PADDR pInSrcAddrList = NULL;
    DWORD dwInSrcAddrCnt = 0;

    PADDR pOutDesAddrList = NULL;
    DWORD dwOutDesAddrCnt = 0;
    PADDR pInDesAddrList = NULL;
    DWORD dwInDesAddrCnt = 0;


    //
    // Replace wild card information to generate the new source
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->SrcAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pSrcAddrList,
                  &dwSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Replace wild card information to generate the new destination
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->DesAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pDesAddrList,
                  &dwDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the source address list into outbound and inbound 
    // source address sets based on the local machine's ip addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->SrcAddr.AddrType,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pOutSrcAddrList,
                  &dwOutSrcAddrCnt,
                  &pInSrcAddrList,
                  &dwInSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the destination address list into outbound and inbound
    // destination address sets based on the local machine's ip 
    // addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->DesAddr.AddrType,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pInDesAddrList,
                  &dwInDesAddrCnt,
                  &pOutDesAddrList,
                  &dwOutDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppOutSrcAddrList = pOutSrcAddrList;
    *pdwOutSrcAddrCnt = dwOutSrcAddrCnt;
    *ppInSrcAddrList = pInSrcAddrList;
    *pdwInSrcAddrCnt = dwInSrcAddrCnt;

    *ppOutDesAddrList = pOutDesAddrList;
    *pdwOutDesAddrCnt = dwOutDesAddrCnt;
    *ppInDesAddrList = pInDesAddrList;
    *pdwInDesAddrCnt = dwInDesAddrCnt;

cleanup:

    if (pSrcAddrList) {
        FreeSPDMemory(pSrcAddrList);
    }

    if (pDesAddrList) {
        FreeSPDMemory(pDesAddrList);
    }

    return (dwError);

error:

    if (pOutSrcAddrList) {
        FreeSPDMemory(pOutSrcAddrList);
    }

    if (pInSrcAddrList) {
        FreeSPDMemory(pInSrcAddrList);
    }

    if (pOutDesAddrList) {
        FreeSPDMemory(pOutDesAddrList);
    }

    if (pInDesAddrList) {
        FreeSPDMemory(pInDesAddrList);
    }

    *ppOutSrcAddrList = NULL;
    *pdwOutSrcAddrCnt = 0;
    *ppInSrcAddrList = NULL;
    *pdwInSrcAddrCnt = 0;

    *ppOutDesAddrList = NULL;
    *pdwOutDesAddrCnt = 0;
    *ppInDesAddrList = NULL;
    *pdwInDesAddrCnt = 0;

    goto cleanup;
}


DWORD
FormAddressList(
    ADDR InAddr,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutAddr,
    PDWORD pdwOutAddrCnt
    )
/*++

Routine Description:

    This function forms the address list for a generic
    address.

Arguments:

    InAddr - Generic address to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppOutAddr - Expanded address list for the generic address.

    pdwOutAddrCnt - Number of addresses in the expanded list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PADDR pOutAddr = NULL;
    DWORD dwOutAddrCnt = 0;
    DWORD i = 0, j = 0;

    switch(InAddr.AddrType) {

    case IP_ADDR_UNIQUE:

        if (InAddr.uIpAddr == IP_ADDRESS_ME) {

            dwError = AllocateSPDMemory(
                          sizeof(ADDR) * dwAddrCnt,
                          &pOutAddr
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            for (i = 0; i < dwAddrCnt; i++) {
                pOutAddr[i].AddrType = InAddr.AddrType;
                pOutAddr[i].uIpAddr = pMatchingAddresses[i].uIpAddr;
                pOutAddr[i].uSubNetMask = InAddr.uSubNetMask;
                memcpy(
                    &pOutAddr[i].gInterfaceID,
                    &InAddr.gInterfaceID,
                    sizeof(GUID)
                    );
            }
            dwOutAddrCnt = dwAddrCnt;

        }
        else {

            dwError = AllocateSPDMemory(
                          sizeof(ADDR),
                          &pOutAddr
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            memcpy(pOutAddr, &InAddr, sizeof(ADDR));
            dwOutAddrCnt = 1;

        }

        break;

    case IP_ADDR_SUBNET:

        dwError = AllocateSPDMemory(
                      sizeof(ADDR),
                      &pOutAddr
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        memcpy(pOutAddr, &InAddr, sizeof(ADDR));
        dwOutAddrCnt = 1;

        break;

    case IP_ADDR_INTERFACE:

        for (i = 0; i < dwAddrCnt; i++) {
            if (!memcmp(
                    &pMatchingAddresses[i].gInterfaceID,
                    &InAddr.gInterfaceID,
                    sizeof(GUID))) {
                dwOutAddrCnt++;
            } 
        }

        if (dwOutAddrCnt) {

            dwError = AllocateSPDMemory(
                          sizeof(ADDR) * dwOutAddrCnt,
                          &pOutAddr
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            for (i = 0; i < dwAddrCnt; i++) {

                if (!memcmp(
                    &pMatchingAddresses[i].gInterfaceID,
                    &InAddr.gInterfaceID,
                    sizeof(GUID))) {
                    pOutAddr[j].AddrType = InAddr.AddrType;
                    pOutAddr[j].uIpAddr = pMatchingAddresses[i].uIpAddr;
                    pOutAddr[j].uSubNetMask = InAddr.uSubNetMask;
                    memcpy(
                        &pOutAddr[j].gInterfaceID,
                        &InAddr.gInterfaceID,
                        sizeof(GUID)
                        );
                    j++;
                }

            }

        }

        break; 

    }

    *ppOutAddr = pOutAddr;
    *pdwOutAddrCnt = dwOutAddrCnt;
    return (dwError);

error:

    *ppOutAddr = NULL;
    *pdwOutAddrCnt = 0;
    return (dwError);
}


DWORD
SeparateAddrList(
    ADDR_TYPE AddrType,
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppOutAddrList,
    PDWORD pdwOutAddrCnt,
    PADDR * ppInAddrList,
    PDWORD pdwInAddrCnt
    )
/*++

Routine Description:

    This function separates the address list into
    two mutually exclusive outbound and inbound
    address sets.

Arguments:

    AddrType - Type of address under consideration.

    pAddrList - List of addresses to separate.

    dwAddrCnt - Number of addresses in the list.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwLocalAddrCnt - Number of local ip addresses in the list.

    ppOutAddrList - List of outbound addresses.

    pdwOutAddrCnt - Number of addresses in the outbound
                    address list.

    ppInAddrList - List of inbound addresses.

    pdwInAddrCnt - Number of addresses in the inbound
                   address list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    switch(AddrType) {

    case IP_ADDR_UNIQUE:

        dwError = SeparateUniqueAddresses(
                      pAddrList,
                      dwAddrCnt,
                      pMatchingAddresses,
                      dwLocalAddrCnt,
                      ppOutAddrList,
                      pdwOutAddrCnt,
                      ppInAddrList,
                      pdwInAddrCnt
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case IP_ADDR_SUBNET:

        dwError = SeparateSubNetAddresses(
                      pAddrList,
                      dwAddrCnt,
                      pMatchingAddresses,
                      dwLocalAddrCnt,
                      ppOutAddrList,
                      pdwOutAddrCnt,
                      ppInAddrList,
                      pdwInAddrCnt
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case IP_ADDR_INTERFACE:

        dwError = SeparateInterfaceAddresses(
                      pAddrList,
                      dwAddrCnt,
                      pMatchingAddresses,
                      dwLocalAddrCnt,
                      ppOutAddrList,
                      pdwOutAddrCnt,
                      ppInAddrList,
                      pdwInAddrCnt
                      );
         BAIL_ON_WIN32_ERROR(dwError);
         break;

    }

error:

    return (dwError);
}

    
DWORD
FormSpecificTxFilters(
    PINITXFILTER pFilter,
    PADDR pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR pDesAddrList,
    DWORD dwDesAddrCnt,
    DWORD dwDirection,
    PINITXSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function forms the specific transport filters
    for the given generic filter and the source and 
    destination address sets.

Arguments:

    pFilter - Generic filter for which specific filters
              are to be created.

    pSrcAddrList - List of source addresses.

    dwSrcAddrCnt - Number of addresses in the source
                   address list.

    pDesAddrList - List of destination addresses.

    dwDesAddrCnt - Number of addresses in the destination
                   address list.

    ppSpecificFilters - Specific filters created for the given
                        generic filter and the given addresses.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXSFILTER pSpecificFilters = NULL;
    DWORD i = 0, j = 0;
    PINITXSFILTER pSpecificFilter = NULL;



    for (i = 0; i < dwSrcAddrCnt; i++) {

        for (j = 0; j < dwDesAddrCnt; j++) {

            dwError = CreateSpecificTxFilter(
                          pFilter,
                          pSrcAddrList[i],
                          pDesAddrList[j],
                          &pSpecificFilter
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            //
            // Set the direction of the filter.
            //

            pSpecificFilter->dwDirection = dwDirection;

            AssignTxFilterWeight(pSpecificFilter);

            AddToSpecificTxList(
                &pSpecificFilters,
                pSpecificFilter
                );

        }

    }

    *ppSpecificFilters = pSpecificFilters;
    return (dwError);

error:

    if (pSpecificFilters) {
        FreeIniTxSFilterList(pSpecificFilters);
    }

    *ppSpecificFilters = NULL;
    return (dwError);
}


DWORD
SeparateUniqueAddresses(
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppIsMeAddrList,
    PDWORD pdwIsMeAddrCnt,
    PADDR * ppIsNotMeAddrList,
    PDWORD pdwIsNotMeAddrCnt
    )
/*++

Routine Description:

    This function separates a list of unique ip addresses into
    two mutually exclusive local and non-local address sets.

Arguments:

    pAddrList - List of unique ip addresses to separate.

    dwAddrCnt - Number of unique ip addresses in the list.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppIsMeAddrList - List of machine's ip addresses separated from
                     the given list.

    pdwIsMeAddrCnt - Number of machine's ip addresses in the list.

    ppIsNotMeAddrList - List of not machine's ip addresses separated from
                        the given list.

    pdwIsNotMeAddrCnt - Number of not machine's ip addresses in the list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PADDR pIsMeAddrList = NULL;
    DWORD dwIsMeAddrCnt = 0;
    PADDR pIsNotMeAddrList = NULL;
    DWORD dwIsNotMeAddrCnt = 0;
    DWORD i = 0, j = 0, k = 0;
    BOOL bEqual = FALSE;
    BOOL bIsClassD = FALSE;


    for (i = 0; i < dwAddrCnt; i++) {

        bIsClassD = IN_CLASSD(ntohl(pAddrList[i].uIpAddr));

        switch (bIsClassD) {

        case TRUE:

            dwIsMeAddrCnt++;
            dwIsNotMeAddrCnt++;

            break;

        case FALSE:

            //
            // Check if the address is one of the matching interfaces' address.
            //

            bEqual = InterfaceAddrIsLocal(
                         pAddrList[i].uIpAddr,
                         pAddrList[i].uSubNetMask,
                         pMatchingAddresses,
                         dwLocalAddrCnt
                         );
            if (bEqual) {
                dwIsMeAddrCnt++;
            }
            else {
                //
                // Check if the address is one of the machine's ip address.
                //
                bEqual = IsMyAddress(
                             pAddrList[i].uIpAddr,
                             pAddrList[i].uSubNetMask,
                             gpInterfaceList
                             );
                if (!bEqual) {
                    dwIsNotMeAddrCnt++;
                }
            }

            break;

        }

    }

    if (dwIsMeAddrCnt) {
        dwError = AllocateSPDMemory(
                      sizeof(ADDR) * dwIsMeAddrCnt,
                      &pIsMeAddrList
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwIsNotMeAddrCnt) {
        dwError = AllocateSPDMemory(
                      sizeof(ADDR) * dwIsNotMeAddrCnt,
                      &pIsNotMeAddrList
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwAddrCnt; i++) {

        bIsClassD = IN_CLASSD(ntohl(pAddrList[i].uIpAddr));

        switch (bIsClassD) {

        case TRUE:

            memcpy(
                &(pIsMeAddrList[j]),
                &(pAddrList[i]),
                sizeof(ADDR)
                );
            j++;

            memcpy(
                &pIsNotMeAddrList[k],
                &pAddrList[i],
                sizeof(ADDR)
                );
            k++;

            break;

        case FALSE:

            bEqual = InterfaceAddrIsLocal(
                         pAddrList[i].uIpAddr,
                         pAddrList[i].uSubNetMask,
                         pMatchingAddresses,
                         dwLocalAddrCnt
                         );
            if (bEqual) {
                memcpy(
                    &(pIsMeAddrList[j]),
                    &(pAddrList[i]),
                    sizeof(ADDR)
                    );
                j++;
            }
            else {
                bEqual = IsMyAddress(
                             pAddrList[i].uIpAddr,
                             pAddrList[i].uSubNetMask,
                             gpInterfaceList
                             );
                if (!bEqual) {
                    memcpy(
                        &pIsNotMeAddrList[k],
                        &pAddrList[i],
                        sizeof(ADDR)
                        );
                    k++;
                }
            }

            break;

        }

    }

    *ppIsMeAddrList = pIsMeAddrList;
    *pdwIsMeAddrCnt = dwIsMeAddrCnt;
    *ppIsNotMeAddrList = pIsNotMeAddrList;
    *pdwIsNotMeAddrCnt = dwIsNotMeAddrCnt;

    return (dwError);

error:

    if (pIsMeAddrList) {
        FreeSPDMemory(pIsMeAddrList);
    }

    if (pIsNotMeAddrList) {
        FreeSPDMemory(pIsNotMeAddrList);
    }

    *ppIsMeAddrList = NULL;
    *pdwIsMeAddrCnt = 0;
    *ppIsNotMeAddrList = NULL;
    *pdwIsNotMeAddrCnt = 0;

    return (dwError);
}


DWORD
SeparateSubNetAddresses(
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppIsMeAddrList,
    PDWORD pdwIsMeAddrCnt,
    PADDR * ppIsNotMeAddrList,
    PDWORD pdwIsNotMeAddrCnt
    )
/*++

Routine Description:

    This function separates a list of subnet addresses into
    two non-mutually exclusive local and non-local address sets.

Arguments:

    pAddrList - List of subnet addresses to separate.

    dwAddrCnt - Number of subnet addresses in the list.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppIsMeAddrList - List of subnet addresses that contain atleast
                     one of the machine's ip address.

    pdwIsMeAddrCnt - Number of subnet addresses containing atleast
                     one of the machine's ip address.

    ppIsNotMeAddrList - List of subnet addresses as in the input list.

    pdwIsNotMeAddrCnt - Number of subnet addresses as in the input list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PADDR pIsMeAddrList = NULL;
    DWORD dwIsMeAddrCnt = 0;
    PADDR pIsNotMeAddrList = NULL;
    DWORD dwIsNotMeAddrCnt = 0;
    DWORD i = 0, j = 0, k = 0;
    BOOL bEqual = FALSE;
    BOOL bIsClassD = FALSE;


    for (i = 0; i < dwAddrCnt; i++) {

        bIsClassD = IN_CLASSD(ntohl(pAddrList[i].uIpAddr));

        switch (bIsClassD) {

        case TRUE:

            dwIsMeAddrCnt++;
            break;

        case FALSE:

            //
            // Check if one of the matching interfaces' address belongs to
            // the subnet.
            //

            bEqual = InterfaceAddrIsLocal(
                         pAddrList[i].uIpAddr,
                         pAddrList[i].uSubNetMask,
                         pMatchingAddresses,
                         dwLocalAddrCnt
                         );
            if (bEqual) {
                dwIsMeAddrCnt++;
            }
            break;

        }

        //
        // The subnet will have addresses that don't belong to the local
        // machine.
        //

        dwIsNotMeAddrCnt++;

    }

    if (dwIsMeAddrCnt) {
        dwError = AllocateSPDMemory(
                      sizeof(ADDR) * dwIsMeAddrCnt,
                      &pIsMeAddrList
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwIsNotMeAddrCnt) {
        dwError = AllocateSPDMemory(
                      sizeof(ADDR) * dwIsNotMeAddrCnt,
                      &pIsNotMeAddrList
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwAddrCnt; i++) {

        bIsClassD = IN_CLASSD(ntohl(pAddrList[i].uIpAddr));

        switch (bIsClassD) {

        case TRUE:

            memcpy(
                &(pIsMeAddrList[j]),
                &(pAddrList[i]),
                sizeof(ADDR)
                );
            j++;
            break;

        case FALSE:

            bEqual = InterfaceAddrIsLocal(
                         pAddrList[i].uIpAddr,
                         pAddrList[i].uSubNetMask,
                         pMatchingAddresses,
                         dwLocalAddrCnt
                         );
            if (bEqual) {
                memcpy(
                    &(pIsMeAddrList[j]),
                    &(pAddrList[i]),
                    sizeof(ADDR)
                    );
                j++;
            }
            break;

        }

        memcpy(
            &pIsNotMeAddrList[k],
            &pAddrList[i],
            sizeof(ADDR)
            );
        k++;

    }

    *ppIsMeAddrList = pIsMeAddrList;
    *pdwIsMeAddrCnt = dwIsMeAddrCnt;
    *ppIsNotMeAddrList = pIsNotMeAddrList;
    *pdwIsNotMeAddrCnt = dwIsNotMeAddrCnt;

    return (dwError);

error:

    if (pIsMeAddrList) {
        FreeSPDMemory(pIsMeAddrList);
    }

    if (pIsNotMeAddrList) {
        FreeSPDMemory(pIsNotMeAddrList);
    }

    *ppIsMeAddrList = NULL;
    *pdwIsMeAddrCnt = 0;
    *ppIsNotMeAddrList = NULL;
    *pdwIsNotMeAddrCnt = 0;

    return (dwError);
}


DWORD
CreateSpecificTxFilter(
    PINITXFILTER pGenericFilter,
    ADDR SrcAddr,
    ADDR DesAddr,
    PINITXSFILTER * ppSpecificFilter
    )
{
    DWORD dwError = 0; 
    PINITXSFILTER pSpecificFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INITXSFILTER),
                    &pSpecificFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->cRef = 0;

    CopyGuid(pGenericFilter->gFilterID, &(pSpecificFilter->gParentID));

    dwError = AllocateSPDString(
                  pGenericFilter->pszFilterName,
                  &(pSpecificFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->InterfaceType = pGenericFilter->InterfaceType;

    pSpecificFilter->dwFlags = pGenericFilter->dwFlags;

    CopyAddresses(SrcAddr, &(pSpecificFilter->SrcAddr));

    CopyAddresses(DesAddr, &(pSpecificFilter->DesAddr));

    CopyPorts(pGenericFilter->SrcPort, &(pSpecificFilter->SrcPort));

    CopyPorts(pGenericFilter->DesPort, &(pSpecificFilter->DesPort));

    CopyProtocols(pGenericFilter->Protocol, &(pSpecificFilter->Protocol));

    pSpecificFilter->InboundFilterFlag = pGenericFilter->InboundFilterFlag;

    pSpecificFilter->OutboundFilterFlag = pGenericFilter->OutboundFilterFlag;

    //
    // Direction must be set in the calling routine.
    //

    pSpecificFilter->dwDirection = 0;

    //
    // Weight must be set in the calling routine.
    //

    pSpecificFilter->dwWeight = 0;

    CopyGuid(pGenericFilter->gPolicyID, &(pSpecificFilter->gPolicyID));

    pSpecificFilter->pIniQMPolicy = NULL;

    pSpecificFilter->pNext = NULL;

    *ppSpecificFilter = pSpecificFilter;
    return (dwError);

error:

    if (pSpecificFilter) {
        FreeIniTxSFilter(pSpecificFilter);
    }

    *ppSpecificFilter = NULL;
    return (dwError);

}


VOID
AssignTxFilterWeight(
    PINITXSFILTER pSpecificFilter
    )
/*++

Routine Description:

    Computes and assigns the weight to a specific transport filter.

    The transport filter weight consists of the following:

    31         16       12           8        0
    +-----------+--------+-----------+--------+
    |AddrMaskWgt|Reserved|ProtocolWgt|PortWgts|
    +-----------+--------+-----------+--------+

Arguments:

    pSpecificFilter - Specific transport filter to which the weight 
                      is to be assigned.

Return Value:

    None.

--*/
{
    DWORD dwWeight = 0;
    ULONG SrcMask = 0;
    ULONG DesMask = 0;
    DWORD dwMaskWeight = 0;
    DWORD i = 0;


    //
    // Weight Rule:
    // A field with a more specific value gets a higher weight than
    // the same field with a lesser specific value.
    //

    //
    // If the protocol is specific then assign the specific protocol
    // weight else the weight is zero.
    // All the specific filters that have a specific protocol and
    // differ only in the protocol field will have the same weight.
    //

    if (pSpecificFilter->Protocol.dwProtocol != 0) {
        dwWeight |= WEIGHT_SPECIFIC_PROTOCOL;
    }

    //
    // If the source port is specific then assign the specific source
    // port weight else the weight is zero.
    // All the specific filters that have a specific source port and 
    // differ only in the source port field will have the same weight.
    //

    if (pSpecificFilter->SrcPort.wPort != 0) {
        dwWeight |= WEIGHT_SPECIFIC_SOURCE_PORT;
    }

    //
    // If the destination port is specific then assign the specific
    // destination port weight else the weight is zero. 
    // All the specific filters that have a specific destination port
    // and differ only in the destination port field will have the
    // same weight.
    //

    if (pSpecificFilter->DesPort.wPort != 0) {
        dwWeight |= WEIGHT_SPECIFIC_DESTINATION_PORT;
    }

    //
    // IP addresses get the weight values based on their mask values.
    // In the address case, the weight is computed as a sum of the 
    // bit positions starting from the position that contains the 
    // first least significant non-zero bit to the most significant
    // bit position of the mask. 
    // All unique ip addresses have a mask of 0xFFFFFFFF and thus get
    // the same weight, which is 1 + 2 + .... + 32.
    // A subnet address has a mask with atleast the least significant
    // bit zero and thus gets weight in the range (2 + .. + 32) to 0.
    //
  
    DesMask = ntohl(pSpecificFilter->DesAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((DesMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         DesMask = DesMask >> 1;

    }


    SrcMask = ntohl(pSpecificFilter->SrcAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((SrcMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         SrcMask = SrcMask >> 1;

    }

    //
    // Move the mask weight to the set of bits in the overall weight
    // that it occupies.
    //

    dwMaskWeight = dwMaskWeight << 16;

    dwWeight += dwMaskWeight;

    pSpecificFilter->dwWeight = dwWeight;
}


VOID
AddToSpecificTxList(
    PINITXSFILTER * ppSpecificTxFilterList,
    PINITXSFILTER pSpecificTxFilters
    )
{
    PINITXSFILTER pListOne = NULL;
    PINITXSFILTER pListTwo = NULL;
    PINITXSFILTER pListMerge = NULL;
    PINITXSFILTER pLast = NULL;

    if (!(*ppSpecificTxFilterList) && !pSpecificTxFilters) {
        return;
    }

    if (!(*ppSpecificTxFilterList)) {
        *ppSpecificTxFilterList = pSpecificTxFilters;
        return;
    }

    if (!pSpecificTxFilters) {
        return;
    }

    pListOne = *ppSpecificTxFilterList;
    pListTwo = pSpecificTxFilters;

    while (pListOne && pListTwo) {

        if ((pListOne->dwWeight) > (pListTwo->dwWeight)) {

            if (!pListMerge) {
                pListMerge = pListOne;
                pLast = pListOne;
                pListOne = pListOne->pNext;
            }
            else {
                pLast->pNext = pListOne;
                pListOne = pListOne->pNext;
                pLast = pLast->pNext;
            }

        }
        else {

            if (!pListMerge) {
                pListMerge = pListTwo;
                pLast = pListTwo;
                pListTwo = pListTwo->pNext;
            }
            else {
                pLast->pNext = pListTwo;
                pListTwo = pListTwo->pNext;
                pLast = pLast->pNext;
            }

        }

    }

    if (pListOne) {
        pLast->pNext = pListOne;
    }
    else {
        pLast->pNext = pListTwo;
    }

    *ppSpecificTxFilterList = pListMerge;
    return;
}


VOID
FreeIniTxSFilterList(
    PINITXSFILTER pIniTxSFilterList
    )
{
    PINITXSFILTER pFilter = NULL;
    PINITXSFILTER pTempFilter = NULL;

    pFilter = pIniTxSFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniTxSFilter(pTempFilter);
    }
}


VOID
FreeIniTxSFilter(
    PINITXSFILTER pIniTxSFilter
    )
{
    if (pIniTxSFilter) {
        if (pIniTxSFilter->pszFilterName) {
            FreeSPDString(pIniTxSFilter->pszFilterName);
        }

        //
        // Must not ever free pIniTxSFilter->pIniQMPolicy.
        //

        FreeSPDMemory(pIniTxSFilter);
    }
}


VOID
LinkTxSpecificFilters(
    PINIQMPOLICY pIniQMPolicy,
    PINITXSFILTER pIniTxSFilters
    )
{
    PINITXSFILTER pTemp = NULL;

    pTemp = pIniTxSFilters;

    while (pTemp) {
        pTemp->pIniQMPolicy = pIniQMPolicy;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
RemoveIniTxSFilter(
    PINITXSFILTER pIniTxSFilter
    )
{
    PINITXSFILTER * ppTemp = NULL;

    ppTemp = &gpIniTxSFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniTxSFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniTxSFilter->pNext;
    }

    return;
}


DWORD
EnumSpecificTxFilters(
    PINITXSFILTER pIniTxSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTxFilters,
    PDWORD pdwNumTxFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters.

Arguments:

    pIniTxSFilterList - List of specific filters to enumerate.

    dwResumeHandle - Location in the specific filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTxFilters - Enumerated filters returned to the caller.

    pdwNumTxFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINITXSFILTER pIniTxSFilter = NULL;
    DWORD i = 0;
    PINITXSFILTER pTemp = NULL;
    DWORD dwNumTxFilters = 0;
    PTRANSPORT_FILTER pTxFilters = 0;
    PTRANSPORT_FILTER pTxFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TRANSPORTFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TRANSPORTFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniTxSFilter = pIniTxSFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniTxSFilter != NULL); i++) {
        pIniTxSFilter = pIniTxSFilter->pNext;
    }

    if (!pIniTxSFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniTxSFilter;

    while (pTemp && (dwNumTxFilters < dwNumToEnum)) {
        dwNumTxFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TRANSPORT_FILTER)*dwNumTxFilters,
                  &pTxFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniTxSFilter;
    pTxFilter = pTxFilters;

    for (i = 0; i < dwNumTxFilters; i++) {

        dwError = CopyTxSFilter(
                      pTemp,
                      pTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTxFilter++;

    }

    *ppTxFilters = pTxFilters;
    *pdwNumTxFilters = dwNumTxFilters;
    return (dwError);

error:

    if (pTxFilters) {
        FreeTxFilters(
            i,
            pTxFilters
            );
    }

    *ppTxFilters = NULL;
    *pdwNumTxFilters = 0;

    return (dwError);
}


DWORD
CopyTxSFilter(
    PINITXSFILTER pIniTxSFilter,
    PTRANSPORT_FILTER pTxFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniTxSFilter - Internal filter to copy.

    pTxFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    CopyGuid(pIniTxSFilter->gParentID, &(pTxFilter->gFilterID));

    dwError = CopyName(
                  pIniTxSFilter->pszFilterName,
                  &(pTxFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->InterfaceType = pIniTxSFilter->InterfaceType;

    pTxFilter->bCreateMirror = FALSE;

    pTxFilter->dwFlags = pIniTxSFilter->dwFlags;

    CopyAddresses(pIniTxSFilter->SrcAddr, &(pTxFilter->SrcAddr));

    CopyAddresses(pIniTxSFilter->DesAddr, &(pTxFilter->DesAddr));

    CopyProtocols(pIniTxSFilter->Protocol, &(pTxFilter->Protocol));

    CopyPorts(pIniTxSFilter->SrcPort, &(pTxFilter->SrcPort));

    CopyPorts(pIniTxSFilter->DesPort, &(pTxFilter->DesPort));

    pTxFilter->InboundFilterFlag = pIniTxSFilter->InboundFilterFlag;

    pTxFilter->OutboundFilterFlag = pIniTxSFilter->OutboundFilterFlag;

    pTxFilter->dwDirection = pIniTxSFilter->dwDirection;

    pTxFilter->dwWeight = pIniTxSFilter->dwWeight;

    CopyGuid(pIniTxSFilter->gPolicyID, &(pTxFilter->gPolicyID));

error:

    return (dwError);
}


DWORD
EnumSelectSpecificTxFilters(
    PINITXFILTER pIniTxFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTxFilters,
    PDWORD pdwNumTxFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters for
    the given generic filter.

Arguments:

    pIniTxFilter - Generic filter for which specific filters
                   are to be enumerated.

    dwResumeHandle - Location in the specific filter list for the
                     given generic filter from which to resume
                     enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTxFilters - Enumerated filters returned to the caller.

    pdwNumTxFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumTxSFilters = 0; 
    PINITXSFILTER * ppIniTxSFilters = NULL;
    DWORD i = 0;
    DWORD dwNumTxFilters = 0;
    PTRANSPORT_FILTER pTxFilters = 0;
    PTRANSPORT_FILTER pTxFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TRANSPORTFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TRANSPORTFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    dwNumTxSFilters = pIniTxFilter->dwNumTxSFilters;
    ppIniTxSFilters = pIniTxFilter->ppIniTxSFilters;

    if (!dwNumTxSFilters || (dwNumTxSFilters <= dwResumeHandle)) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumTxFilters = min((dwNumTxSFilters-dwResumeHandle),
                         dwNumToEnum);
 
    dwError = SPDApiBufferAllocate(
                  sizeof(TRANSPORT_FILTER)*dwNumTxFilters,
                  &pTxFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter = pTxFilters;

    for (i = 0; i < dwNumTxFilters; i++) {

        dwError = CopyTxSFilter(
                      *(ppIniTxSFilters + (dwResumeHandle + i)),
                      pTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pTxFilter++;

    }

    *ppTxFilters = pTxFilters;
    *pdwNumTxFilters = dwNumTxFilters;
    return (dwError);

error:

    if (pTxFilters) {
        FreeTxFilters(
            i,
            pTxFilters
            );
    }

    *ppTxFilters = NULL;
    *pdwNumTxFilters = 0;

    return (dwError);
}


DWORD
MatchTransportFilter(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTxFilter,
    DWORD dwFlags,
    PTRANSPORT_FILTER * ppMatchedTxFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function finds the matching transport filters for the 
    given transport filter template. The matched filters can not
    be more specific than the given filter template.

Arguments:

    pServerName - Server on which a filter template is to be matched.

    pTxFilter - Filter template to match.

    dwFlags - Flags.

    ppMatchedTxFilters - Matched transport filters returned to the
                         caller.

    ppMatchedQMPolicies - Quick mode policies corresponding to the 
                          matched transport filters returned to the
                          caller.

    dwPreferredNumEntries - Preferred number of matched entries.

    pdwNumMatches - Number of filters actually matched.

    pdwResumeHandle - Handle to the location in the matched filter 
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToMatch = 0;
    PINITXSFILTER pIniTxSFilter = NULL;
    DWORD i = 0;
    BOOL bMatches = FALSE;
    PINITXSFILTER pTemp = NULL;
    DWORD dwNumMatches = 0;
    PINITXSFILTER pLastMatchedFilter = NULL;
    PTRANSPORT_FILTER pMatchedTxFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;
    PTRANSPORT_FILTER pMatchedTxFilter = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicy = NULL;


    dwError = ValidateTxFilterTemplate(
                  pTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries) {
        dwNumToMatch = 1;
    }
    else if (dwPreferredNumEntries > MAX_TRANSPORTFILTER_ENUM_COUNT) {
        dwNumToMatch = MAX_TRANSPORTFILTER_ENUM_COUNT;
    }
    else {
        dwNumToMatch = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTxSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTxSFilter = gpIniTxSFilter;

    while ((i < dwResumeHandle) && (pIniTxSFilter != NULL)) {
        bMatches = MatchIniTxSFilter(
                       pIniTxSFilter,
                       pTxFilter
                       );
        if (bMatches) {
            i++;
        }
        pIniTxSFilter = pIniTxSFilter->pNext;
    }

    if (!pIniTxSFilter) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyTxMatchDefaults(
                          &pMatchedTxFilters,
                          &pMatchedQMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    pTemp = pIniTxSFilter;

    while (pTemp && (dwNumMatches < dwNumToMatch)) {
        bMatches = MatchIniTxSFilter(
                       pTemp,
                       pTxFilter
                       );
        if (bMatches) {
            pLastMatchedFilter = pTemp;
            dwNumMatches++;
        }
        pTemp = pTemp->pNext;
    }

    if (!dwNumMatches) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyTxMatchDefaults(
                          &pMatchedTxFilters,
                          &pMatchedQMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TRANSPORT_FILTER)*dwNumMatches,
                  &pMatchedTxFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY)*dwNumMatches,
                  &pMatchedQMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);


    if (dwNumMatches == 1) {

        dwError = CopyTxSFilter(
                      pLastMatchedFilter,
                      pMatchedTxFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        dwNumFilters++;

        if (pLastMatchedFilter->pIniQMPolicy) {
            dwError = CopyQMPolicy(
                          pLastMatchedFilter->pIniQMPolicy,
                          pMatchedQMPolicies
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedQMPolicies, 0, sizeof(IPSEC_QM_POLICY));
        }
        dwNumPolicies++;

    }
    else {

        pTemp = pIniTxSFilter;
        pMatchedTxFilter = pMatchedTxFilters;
        pMatchedQMPolicy = pMatchedQMPolicies;
        i = 0;

        while (i < dwNumMatches) {

            bMatches = MatchIniTxSFilter(
                           pTemp,
                           pTxFilter
                           );
            if (bMatches) {

                dwError = CopyTxSFilter(
                              pTemp,
                              pMatchedTxFilter
                              );
                BAIL_ON_LOCK_ERROR(dwError);
                pMatchedTxFilter++;
                dwNumFilters++;

                if (pTemp->pIniQMPolicy) {
                    dwError = CopyQMPolicy(
                                  pTemp->pIniQMPolicy,
                                  pMatchedQMPolicy
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pMatchedQMPolicy, 0, sizeof(IPSEC_QM_POLICY));
                }
                pMatchedQMPolicy++;
                dwNumPolicies++;

                i++;

            }

            pTemp = pTemp->pNext;

        }

    }

lock_success:

    LEAVE_SPD_SECTION();

    *ppMatchedTxFilters = pMatchedTxFilters;
    *ppMatchedQMPolicies = pMatchedQMPolicies;
    *pdwNumMatches = dwNumMatches;
    *pdwResumeHandle = dwResumeHandle + dwNumMatches;

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMatchedTxFilters) {
        FreeTxFilters(
            dwNumFilters,
            pMatchedTxFilters
            );
    }

    if (pMatchedQMPolicies) {
        FreeQMPolicies(
            dwNumPolicies,
            pMatchedQMPolicies
            );
    }

    *ppMatchedTxFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
ValidateTxFilterTemplate(
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTxFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTxFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTxFilter->SrcAddr,
                     pTxFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pTxFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->SrcPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->DesPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTxFilter->dwDirection) {
        if ((pTxFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTxFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
MatchIniTxSFilter(
    PINITXSFILTER pIniTxSFilter,
    PTRANSPORT_FILTER pTxFilter
    )
{
    BOOL bMatches = FALSE;

    if (pTxFilter->dwDirection) {
        if (pTxFilter->dwDirection != pIniTxSFilter->dwDirection) {
            return (FALSE);
        }
    }

    if ((pIniTxSFilter->InboundFilterFlag != NEGOTIATE_SECURITY) &&
        (pIniTxSFilter->OutboundFilterFlag != NEGOTIATE_SECURITY)) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTxSFilter->SrcAddr,
                   pTxFilter->SrcAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTxSFilter->DesAddr,
                   pTxFilter->DesAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchPorts(
                   pIniTxSFilter->SrcPort,
                   pTxFilter->SrcPort
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchPorts(
                   pIniTxSFilter->DesPort,
                   pTxFilter->DesPort
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchProtocols(
                   pIniTxSFilter->Protocol,
                   pTxFilter->Protocol
                   );
    if (!bMatches) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CopyTxMatchDefaults(
    PTRANSPORT_FILTER * ppTxFilters,
    PIPSEC_QM_POLICY * ppQMPolicies,
    PDWORD pdwNumMatches
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTxFilters = NULL;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;


    if (!gpIniDefaultQMPolicy) {
        dwError = ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TRANSPORT_FILTER),
                  &pTxFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY),
                  &pQMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyDefaultTxFilter(
                  pTxFilters,
                  gpIniDefaultQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumFilters++;

    dwError = CopyQMPolicy(
                  gpIniDefaultQMPolicy,
                  pQMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pQMPolicies->dwFlags |= IPSEC_QM_POLICY_ON_NO_MATCH;
    dwNumPolicies++;

    *ppTxFilters = pTxFilters;
    *ppQMPolicies = pQMPolicies;
    *pdwNumMatches = 1;

    return (dwError);

error:

    if (pTxFilters) {
        FreeTxFilters(
            dwNumFilters,
            pTxFilters
            );
    }

    if (pQMPolicies) {
        FreeQMPolicies(
            dwNumPolicies,
            pQMPolicies
            );
    }

    *ppTxFilters = NULL;
    *ppQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
CopyDefaultTxFilter(
    PTRANSPORT_FILTER pTxFilter,
    PINIQMPOLICY pIniQMPolicy
    )
{
    DWORD dwError = 0;


    UuidCreate(&(pTxFilter->gFilterID));

    dwError = CopyName(
                  L"0",
                  &(pTxFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTxFilter->InterfaceType = INTERFACE_TYPE_ALL;

    pTxFilter->bCreateMirror = TRUE;

    pTxFilter->dwFlags = 0;
    pTxFilter->dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;

    pTxFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    pTxFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTxFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;

    pTxFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    pTxFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTxFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;

    pTxFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pTxFilter->Protocol.dwProtocol = 0;

    pTxFilter->SrcPort.PortType = PORT_UNIQUE;
    pTxFilter->SrcPort.wPort = 0;

    pTxFilter->DesPort.PortType = PORT_UNIQUE;
    pTxFilter->DesPort.wPort = 0;

    pTxFilter->InboundFilterFlag = NEGOTIATE_SECURITY;

    pTxFilter->OutboundFilterFlag = NEGOTIATE_SECURITY;

    pTxFilter->dwDirection = 0;

    pTxFilter->dwWeight = 0;

    CopyGuid(pIniQMPolicy->gPolicyID, &(pTxFilter->gPolicyID));

error:

    return (dwError);
}


DWORD
SeparateInterfaceAddresses(
    PADDR pAddrList,
    DWORD dwAddrCnt,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwLocalAddrCnt,
    PADDR * ppIsMeAddrList,
    PDWORD pdwIsMeAddrCnt,
    PADDR * ppIsNotMeAddrList,
    PDWORD pdwIsNotMeAddrCnt
    )
{
    DWORD dwError = 0;
    PADDR pIsMeAddrList = NULL;
    DWORD i = 0;


    if (dwAddrCnt) {
        dwError = AllocateSPDMemory(
                      sizeof(ADDR) * dwAddrCnt,
                      &pIsMeAddrList
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwAddrCnt; i++) {

        memcpy(
            &(pIsMeAddrList[i]),
            &(pAddrList[i]),
            sizeof(ADDR)
            );

    }

    *ppIsMeAddrList = pIsMeAddrList;
    *pdwIsMeAddrCnt = dwAddrCnt;
    *ppIsNotMeAddrList = NULL;
    *pdwIsNotMeAddrCnt = 0;

    return (dwError);

error:

    if (pIsMeAddrList) {
        FreeSPDMemory(pIsMeAddrList);
    }

    *ppIsMeAddrList = NULL;
    *pdwIsMeAddrCnt = 0;
    *ppIsNotMeAddrList = NULL;
    *pdwIsNotMeAddrCnt = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\buffer.h ===
typedef VOID (*BUFFER_FREE_ROUTINE)(
    struct _IRCOMM_BUFFER   *Buffer
    );

typedef struct _IRCOMM_BUFFER {

    SINGLE_LIST_ENTRY     ListEntry;
    PVOID                 BufferPool;
    BUFFER_FREE_ROUTINE   FreeBuffer;
    PVOID                 Context;
    PVOID                 Context2;
    PMDL                  Mdl;
    PIRP                  Irp;
    ULONG                 BufferLength;
    UCHAR                 Data[1];

} IRCOMM_BUFFER, *PIRCOMM_BUFFER;

typedef PVOID BUFFER_POOL_HANDLE;


BUFFER_POOL_HANDLE
CreateBufferPool(
    ULONG      StackDepth,
    ULONG      BufferSize,
    ULONG      BufferCount
    );


VOID
FreeBufferPool(
    BUFFER_POOL_HANDLE    Handle
    );


PIRCOMM_BUFFER
GetBuffer(
    BUFFER_POOL_HANDLE    Handle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\ircomm.h ===
#ifndef __IRCOMM_CONTROL__
#define __IRCOMM_CONTROL__

#define PI_ServiceType 0x00
#define PI_DataRate    0x10
#define PI_DataFormat  0x11
#define PI_FLOWCONTROL 0x12
#define PI_XONXOFF     0x13
#define PI_ENQACK      0x14
#define PI_LineStatus  0x15
#define PI_Break       0x16
#define PI_DTESettings 0x20
#define PI_DCESettings 0x21
#define PI_Poll        0x22



#define PV_ServiceType_3_Wire     (1 << 1)
#define PV_ServiceType_9_Wire     (1 << 2)
#define PV_ServiceType_Centronics (1 << 3)

#define PV_DTESetting_Delta_DTR   (1 << 0)
#define PV_DTESetting_Delta_RTS   (1 << 1)

#define PV_DTESetting_DTR_High   (1 << 2)
#define PV_DTESetting_RTS_High   (1 << 3)

#define PV_DataFormat_8_Bits      (0x3)
#define PV_DataFormat_7_Bits      (0x2)
#define PV_DataFormat_6_Bits      (0x1)
#define PV_DataFormat_5_Bits      (0x0)

#define PV_DataFormat_1_Stop      (0 << 2)
#define PV_DataFormat_2_Stop      (1 << 2)

#define PV_DataFormat_No_Parity   (0 << 3)
#define PV_DataFormat_Yes_Parity  (1 << 3)

#define PV_DataFormat_Odd_Parity   (0 << 4)
#define PV_DataFormat_Even_Parity  (1 << 4)
#define PV_DataFormat_Mark_Parity  (2 << 4)
#define PV_DataFormat_Sapce_Parity (3 << 4)


#define PV_DCESetting_Delta_CTS   (1 << 0)
#define PV_DCESetting_Delta_DSR   (1 << 1)
#define PV_DCESetting_Delta_RI    (1 << 2)
#define PV_DCESetting_Delta_CD    (1 << 3)

#define PV_DCESetting_CTS_State   (1 << 4)
#define PV_DCESetting_DSR_State   (1 << 5)
#define PV_DCESetting_RI_State    (1 << 6)
#define PV_DCESetting_CD_State    (1 << 7)


typedef struct _CONTROL_INFO {

    LIST_ENTRY        ListElement;

    UCHAR             PI;
    UCHAR             PL;

    UCHAR             PV[1];

} CONTROL_INFO, *PCONTROL_INFO;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\ircommtdi.h ===
#ifndef __IRCOMM_TDI__
#define __IRCOMM_TDI__

#include <af_irda.h>
#include <irdatdi.h>




NTSTATUS
IrdaDiscoverDevices(
    PDEVICELIST pDevList,
    PULONG       pDevListLen
    );

NTSTATUS
IrdaIASStringQuery(
    ULONG   DeviceID,
    PSTR    ClassName,
    PSTR    AttributeName,
    PWSTR  *ReturnString
    );

NTSTATUS
IrdaIASIntegerQuery(
    ULONG   DeviceID,
    PSTR    ClassName,
    PSTR    AttributeName,
    LONG   *ReturnValue
    );

NTSTATUS
IrdaIASStringSet(
    HANDLE  AddressHandle,
    PSTR    ClassName,
    PSTR    AttributeName,
    PSTR    StringToSet
    );

VOID
IrdaLazyDiscoverDevices(
    HANDLE             ControlHandle,
    HANDLE             Event,
    PIO_STATUS_BLOCK   Iosb,
    PDEVICELIST        pDevList,
    ULONG              DevListLen
    );

NTSTATUS
IrdaOpenControlChannel(
    HANDLE     *ControlHandle
    );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\irdatdi.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    irdatdi.h

Abstract:

    Library of routines that abstracts the tdi client interface to
    the IrDA stack. Used by rasirda.sys
    
Author:

    mbert 9-97    

--*/


#define IRDA_DEVICE_NAME        TEXT("\\Device\\IrDA")
#define IRDA_NAME               TEXT("IrDA")
#define TDI_ADDRESS_TYPE_IRDA   26 // wmz - the following belongs in tdi.h
#define IRDA_DEV_SERVICE_LEN    26
#define IRDA_MAX_DATA_SIZE      2044
#define TTP_RECV_CREDITS        14

typedef struct _TDI_ADDRESS_IRDA
{
	UCHAR   irdaDeviceID[4];
	CHAR 	irdaServiceName[IRDA_DEV_SERVICE_LEN];
} TDI_ADDRESS_IRDA, *PTDI_ADDRESS_IRDA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\irenum.h ===
#define IRENUM_CONFIG_SPACE_INFO  0

typedef struct _IRCOMM_BUS_INFO {

    ULONG     DeviceAddress;
    BOOLEAN   OutGoingConnection;

} IRCOMM_BUS_INFO, *PIRCOMM_BUS_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\link.h ===
typedef PVOID LINK_HANDLE;

typedef PVOID CONNECTION_HANDLE;

typedef enum {
    BUFFER_TYPE_SEND,
    BUFFER_TYPE_CONTROL,
    BUFFER_TYPE_RECEIVE
} BUFFER_TYPE;

typedef NTSTATUS (*PLINK_RECEIVE)(
    PVOID        Context,
    ULONG        ReceiveFlags,
    ULONG        BytesIndicated,
    ULONG        BytesAvailible,
    ULONG       *BytesTaken,
    PVOID        Tsdu,
    PIRP        *Irp
    );

typedef VOID (*PLINK_STATE)(
    PVOID        Context,
    BOOLEAN      LinkUp,
    ULONG        MaxSendPdu
    );


NTSTATUS
CreateTdiLink(
    ULONG                  DeviceAddress,
    CHAR                  *ServiceName,
    BOOLEAN                OutGoingConnection,
    LINK_HANDLE           *LinkHandle,
    PVOID                  Context,
    PLINK_RECEIVE          LinkReceiveHandler,
    PLINK_STATE            LinkStateHandler,
    ULONG                  SendBuffers,
    ULONG                  ControlBuffers,
    ULONG                  ReceiveBuffer
    );


VOID
CloseTdiLink(
    LINK_HANDLE   LinkHandle
    );


CONNECTION_HANDLE
GetCurrentConnection(
    LINK_HANDLE    LinkHandle
    );

VOID
ReleaseConnection(
    CONNECTION_HANDLE    ContectionHandle
    );


PIRCOMM_BUFFER
ConnectionGetBuffer(
    CONNECTION_HANDLE   ConnectionHandle,
    BUFFER_TYPE         BufferType
    );

PFILE_OBJECT
ConnectionGetFileObject(
    CONNECTION_HANDLE   ConnectionHandle
    );

VOID
ConnectionReleaseFileObject(
    CONNECTION_HANDLE   ConnectionHandle,
    PFILE_OBJECT   FileObject
    );

NTSTATUS
SendSynchronousControlInfo(
    CONNECTION_HANDLE        ConnectionHandle,
    UCHAR               PI,
    UCHAR               PL,
    UCHAR              *PV
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@

$(O)\mdmirmdm.inf: $(_INX)\mdmirmdm.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\ircommdbg.h ===
#ifndef __IRCOMM_DEBUG__
#define __IRCOMM_DEBUG__

extern ULONG  DebugMemoryTag;
extern ULONG  DebugFlags;

#define ALLOCATE_PAGED_POOL(_y)  ExAllocatePoolWithTag(PagedPool,_y, DebugMemoryTag)

#define ALLOCATE_NONPAGED_POOL(_y) ExAllocatePoolWithTag(NonPagedPool,_y,DebugMemoryTag)

#define FREE_POOL(_x) {ExFreePool(_x);_x=NULL;};





#if DBG

#define DEBUG_FLAG_ERROR  0x0001
#define DEBUG_FLAG_INIT   0x0002
#define DEBUG_FLAG_PNP    0x0004
#define DEBUG_FLAG_POWER  0x0008
#define DEBUG_FLAG_WMI    0x0010

#define DEBUG_FLAG_TRACE0 0x0020
#define DEBUG_FLAG_TRACE1 0x0040
#define DEBUG_FLAG_TRACE2 0x0080
#define DEBUG_FLAG_ENUM   0x0100

#define DEBUG_FLAG_TRACE  DEBUG_FLAG_TRACE0

#define D_ERROR(_x)  if (DebugFlags & DEBUG_FLAG_ERROR) {_x}

#define D_INIT(_x)   if (DebugFlags & DEBUG_FLAG_INIT) {_x}

#define D_PNP(_x)    if (DebugFlags & DEBUG_FLAG_PNP) {_x}

#define D_POWER(_x)  if (DebugFlags & DEBUG_FLAG_POWER) {_x}

#define D_TRACE(_x)  if (DebugFlags & DEBUG_FLAG_TRACE) {_x}

#define D_TRACE1(_x) if (DebugFlags & DEBUG_FLAG_TRACE1) {_x}

#define D_TRACE2(_x) if (DebugFlags & DEBUG_FLAG_TRACE2) {_x}

#define D_ENUM(_x)   if (DebugFlags & DEBUG_FLAG_ENUM) {_x}

#define D_WMI(_x)    if (DebugFlags & DEBUG_FLAG_WMI) {_x}

#else

#define D_ERROR(_x) {}

#define D_INIT(_x)  {}

#define D_PNP(_x)   {}

#define D_POWER(_x) {}

#define D_TRACE(_x) {}

#define D_TRACE1(_x) {}

#define D_TRACE2(_x) {}

#define D_ENUM(_x)  {}

#define D_WMI(_x)   {}

#endif

VOID
DumpBuffer(
    PUCHAR    Data,
    ULONG     Length
    );


#endif  // __IRCOMM_DEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\inc\vuart.h ===
#ifndef __IRCOMM_TDI__
#define __IRCOMM_TDI__

#include <af_irda.h>
#include <irdatdi.h>


typedef PVOID IRDA_HANDLE;


typedef NTSTATUS (*RECEIVE_CALLBACK)(
    PVOID    Context,
    PUCHAR   Buffer,
    ULONG    BytesAvailible,
    PULONG   BytesUsed
    );

typedef VOID (*EVENT_CALLBACK)(
    PVOID    Context,
    ULONG    Event
    );

//
//  irda connection functions
//
NTSTATUS
IrdaConnect(
    ULONG                  DeviceAddress,
    CHAR                  *ServiceName,
    BOOLEAN                OutGoingConnection,
    IRDA_HANDLE           *ConnectionHandle,
    RECEIVE_CALLBACK       ReceiveCallBack,
    EVENT_CALLBACK         EventCallBack,
    PVOID                  CallbackContext
    );


VOID
FreeConnection(
    IRDA_HANDLE    Handle
    );


typedef VOID (*CONNECTION_CALLBACK)(
    PVOID    Context,
    PIRP     Irp
    );

VOID
SendOnConnection(
    IRDA_HANDLE    Handle,
    PIRP           Irp,
    CONNECTION_CALLBACK    Callback,
    PVOID                  Context,
    ULONG                  Timeout
    );

VOID
AbortSend(
    IRDA_HANDLE            Handle
    );


VOID
AccessUartState(
    IRDA_HANDLE            Handle,
    PIRP                   Irp,
    CONNECTION_CALLBACK    Callback,
    PVOID                  Context
    );





NTSTATUS
QueueControlInfo(
    IRDA_HANDLE              Handle,
    UCHAR                    PI,
    UCHAR                    PL,
    PUCHAR                   PV
    );

#if 0
NTSTATUS
IrdaDiscoverDevices(
    PDEVICELIST pDevList,
    PULONG       pDevListLen
    );

NTSTATUS
IrdaIASStringQuery(
    ULONG   DeviceID,
    PSTR    ClassName,
    PSTR    AttributeName,
    PWSTR  *ReturnString
    );

NTSTATUS
IrdaIASIntegerQuery(
    ULONG   DeviceID,
    PSTR    ClassName,
    PSTR    AttributeName,
    LONG   *ReturnValue
    );

NTSTATUS
IrdaIASStringSet(
    HANDLE  AddressHandle,
    PSTR    ClassName,
    PSTR    AttributeName,
    PSTR    StringToSet
    );
#endif


NTSTATUS
IndicateReceiveBufferSpaceAvailible(
    IRDA_HANDLE    Handle
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\ioctl.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"
#include <ntddmodm.h>
#include "ircomm.h"

VOID
LockedMemoryCopy(
    PKSPIN_LOCK     Lock,
    PVOID           Destination,
    PVOID           Source,
    ULONG           Length
    )

{

    KIRQL           OldIrql;

    KeAcquireSpinLock(
        Lock,
        &OldIrql
        );

    RtlCopyMemory(
        Destination,
        Source,
        Length
        );

    KeReleaseSpinLock(
        Lock,
        OldIrql
        );

    return;
}

VOID
LockedZeroMemory(
    PKSPIN_LOCK     Lock,
    PVOID           Destination,
    ULONG           Length
    )

{

    KIRQL           OldIrql;

    KeAcquireSpinLock(
        Lock,
        &OldIrql
        );

    RtlZeroMemory(
        Destination,
        Length
        );

    KeReleaseSpinLock(
        Lock,
        OldIrql
        );

    return;
}


NTSTATUS
IrCommDeviceControl(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION       IrpSp=IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                 Status=STATUS_SUCCESS;

    PUCHAR                   SystemBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG                    InputLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ULONG                    OutputLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ULONG                    SizeNeeded;

    Irp->IoStatus.Information=0;

    D_TRACE(DbgPrint("IRCOMM: IrCommDeviceControl\n");)

    if (DeviceExtension->Removing) {
        //
        //  the device has been removed, no more irps
        //
        Irp->IoStatus.Status=STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }


    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_SET_TIMEOUTS:

            if (InputLength >= sizeof(SERIAL_TIMEOUTS)) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    &DeviceExtension->TimeOuts,
                    SystemBuffer,
                    sizeof(SERIAL_TIMEOUTS)
                    );

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_GET_TIMEOUTS:

            if (OutputLength >= sizeof(SERIAL_TIMEOUTS) ) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    SystemBuffer,
                    &DeviceExtension->TimeOuts,
                    sizeof(SERIAL_TIMEOUTS)
                    );

                Irp->IoStatus.Information=sizeof(SERIAL_TIMEOUTS);

                break;
            }
            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_SET_QUEUE_SIZE:


            if (InputLength >= sizeof( SERIAL_QUEUE_SIZE)) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    &DeviceExtension->QueueSizes,
                    SystemBuffer,
                    sizeof( SERIAL_QUEUE_SIZE)
                    );

                break;
            }
            Status=STATUS_INVALID_PARAMETER;

            break;



        case IOCTL_SERIAL_GET_HANDFLOW:

            SizeNeeded=sizeof(SERIAL_HANDFLOW);

            if (OutputLength >= SizeNeeded) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    SystemBuffer,
                    &DeviceExtension->HandFlow,
                    SizeNeeded
                    );


                Irp->IoStatus.Information=SizeNeeded;

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_SET_HANDFLOW:

            SizeNeeded=sizeof(SERIAL_HANDFLOW);

            if (InputLength >= SizeNeeded) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    &DeviceExtension->HandFlow,
                    SystemBuffer,
                    SizeNeeded
                    );

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;


        case IOCTL_SERIAL_GET_BAUD_RATE:

            if (OutputLength >= sizeof(ULONG) ) {

                IoMarkIrpPending(Irp);

                QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

                return STATUS_PENDING;
            }
            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_SET_BAUD_RATE:

            if (InputLength >= sizeof(ULONG) ) {

                IoMarkIrpPending(Irp);

                QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

                return STATUS_PENDING;
            }
            Status=STATUS_INVALID_PARAMETER;

            break;



        case IOCTL_SERIAL_GET_LINE_CONTROL:

            if (OutputLength >= sizeof(SERIAL_LINE_CONTROL)) {

                IoMarkIrpPending(Irp);

                QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

                return STATUS_PENDING;

            }
            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_SET_LINE_CONTROL:

            if (InputLength >= sizeof(SERIAL_LINE_CONTROL)) {

                IoMarkIrpPending(Irp);

                QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

                return STATUS_PENDING;

            }
            Status=STATUS_INVALID_PARAMETER;

            break;


        case IOCTL_SERIAL_GET_CHARS:

            if (OutputLength >= sizeof(SERIAL_CHARS)) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    SystemBuffer,
                    &DeviceExtension->SerialChars,
                    sizeof(SERIAL_CHARS)
                    );

                Irp->IoStatus.Information=sizeof(SERIAL_CHARS);

                break;
            }
            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_SET_CHARS:

            SizeNeeded=sizeof(SERIAL_CHARS);

            if (InputLength >= SizeNeeded) {

                LockedMemoryCopy(
                    &DeviceExtension->SpinLock,
                    &DeviceExtension->SerialChars,
                    SystemBuffer,
                    SizeNeeded
                    );

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;


        case IOCTL_SERIAL_GET_WAIT_MASK:
        case IOCTL_SERIAL_SET_WAIT_MASK:
        case IOCTL_SERIAL_WAIT_ON_MASK:

            IoMarkIrpPending(Irp);

            Irp->IoStatus.Information=0;

            QueuePacket(&DeviceExtension->Mask.Queue,Irp,FALSE);

            return STATUS_PENDING;


        case IOCTL_SERIAL_GET_MODEMSTATUS:

            if (OutputLength >= sizeof(ULONG)) {

                IoMarkIrpPending(Irp);

                QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

                return STATUS_PENDING;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;


        case IOCTL_SERIAL_PURGE:

            if (InputLength >= sizeof(ULONG)) {

                if (*(PULONG)SystemBuffer & SERIAL_PURGE_TXABORT) {
                    //
                    //  we only want to flush the write irps in the queue, not any ioctl's
                    //
                    FlushQueuedPackets(&DeviceExtension->Write.Queue,IRP_MJ_WRITE);
                    AbortSend(DeviceExtension->ConnectionHandle);
                }

                if (*(PULONG)SystemBuffer & SERIAL_PURGE_RXABORT) {

                    FlushQueuedPackets(&DeviceExtension->Read.Queue,FLUSH_ALL_IRPS);

                    ReadPurge(DeviceExtension,READ_PURGE_ABORT_IRP);
                }

                if (*(PULONG)SystemBuffer & SERIAL_PURGE_TXCLEAR) {

                }

                if (*(PULONG)SystemBuffer & SERIAL_PURGE_RXCLEAR) {

                    ReadPurge(DeviceExtension,READ_PURGE_CLEAR_BUFFER);
                }

                break;

            }

            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR:

            DeviceExtension->Read.DtrState= (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR);

        case IOCTL_SERIAL_SET_RTS:
        case IOCTL_SERIAL_CLR_RTS: {


            IoMarkIrpPending(Irp);

            QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

            return STATUS_PENDING;
        }

        case IOCTL_SERIAL_GET_DTRRTS:

            SizeNeeded=sizeof(ULONG);

            if (OutputLength >= SizeNeeded) {

                IoMarkIrpPending(Irp);

                QueuePacket(&DeviceExtension->Uart.Queue,Irp,FALSE);

                return STATUS_PENDING;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;


        case IOCTL_SERIAL_GET_COMMSTATUS:

            SizeNeeded=sizeof(SERIAL_STATUS);

            if (OutputLength >= SizeNeeded) {

                RtlZeroMemory(
                    SystemBuffer,
                    SizeNeeded
                    );

                LockedMemoryCopy(
                    &DeviceExtension->Read.ReadLock,
                    &((PSERIAL_STATUS)SystemBuffer)->AmountInInQueue,
                    &DeviceExtension->Read.BytesInBuffer,
                    sizeof(DeviceExtension->Read.BytesInBuffer)
                    );

                Irp->IoStatus.Information=SizeNeeded;

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_SERIAL_GET_STATS: {

            PSERIALPERF_STATS    Stats=(PSERIALPERF_STATS)SystemBuffer;

            SizeNeeded=sizeof(SERIAL_STATUS);

            if (OutputLength >= SizeNeeded) {

                RtlZeroMemory(
                    Stats,
                    OutputLength
                    );

                Stats->TransmittedCount = DeviceExtension->Write.BytesWritten;
                Stats->ReceivedCount =    DeviceExtension->Read.BytesRead;

                Irp->IoStatus.Information=SizeNeeded;

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;
        }

        case IOCTL_SERIAL_CLEAR_STATS:

            DeviceExtension->Write.BytesWritten=0;
            DeviceExtension->Read.BytesRead=0;

            break;


        case IOCTL_SERIAL_GET_PROPERTIES: {

            PSERIAL_COMMPROP    SerialProps=(PSERIAL_COMMPROP)SystemBuffer;

            SizeNeeded=FIELD_OFFSET(SERIAL_COMMPROP,ProvChar);

            if (OutputLength >= SizeNeeded) {

                RtlZeroMemory(
                    SerialProps,
                    OutputLength
                    );

                SerialProps->PacketLength=(USHORT)SizeNeeded;
                SerialProps->PacketVersion=1;
                SerialProps->ServiceMask=SERIAL_SP_SERIALCOMM;
                SerialProps->MaxBaud=115200;

                SerialProps->ProvSubType=SERIAL_SP_RS232;
                SerialProps->ProvCapabilities=SERIAL_PCF_DTRDSR | SERIAL_PCF_RTSCTS | SERIAL_PCF_CD | SERIAL_PCF_TOTALTIMEOUTS | SERIAL_PCF_INTTIMEOUTS;
                SerialProps->SettableParams=SERIAL_SP_PARITY | SERIAL_SP_BAUD | SERIAL_SP_DATABITS | SERIAL_SP_STOPBITS | SERIAL_SP_HANDSHAKING | SERIAL_SP_CARRIER_DETECT;
                SerialProps->SettableBaud=SERIAL_BAUD_9600   |
                                          SERIAL_BAUD_14400  |
                                          SERIAL_BAUD_19200  |
                                          SERIAL_BAUD_38400  |
                                          SERIAL_BAUD_56K    |
                                          SERIAL_BAUD_128K   |
                                          SERIAL_BAUD_115200 |
                                          SERIAL_BAUD_57600  |
                                          SERIAL_BAUD_USER;

                SerialProps->SettableData=SERIAL_DATABITS_7 | SERIAL_DATABITS_8;

                SerialProps->SettableStopParity = SERIAL_STOPBITS_10 | SERIAL_PARITY_NONE | SERIAL_PARITY_EVEN | SERIAL_PARITY_ODD;

                Irp->IoStatus.Information=SizeNeeded;

                break;
            }
            Status=STATUS_INVALID_PARAMETER;

            break;
        }

        case IOCTL_SERIAL_CONFIG_SIZE:

            SizeNeeded=sizeof(ULONG);

            if (OutputLength >= SizeNeeded) {

                *(PULONG)SystemBuffer=0;

                Irp->IoStatus.Information=SizeNeeded;

                break;
            }

            Status=STATUS_INVALID_PARAMETER;

            break;

        case IOCTL_MODEM_CHECK_FOR_MODEM:

            Status=STATUS_INVALID_DEVICE_REQUEST;

            break;


        default:

            DbgPrint("IRCOMM: unhandled ioctl %d \n",(IrpSp->Parameters.DeviceIoControl.IoControlCode >> 2) & 0x3f);

            Status=STATUS_INVALID_DEVICE_REQUEST;

            break;

    }


    IoMarkIrpPending(Irp);

    Irp->IoStatus.Status=Status;

#if DBG
    if (Status ==  STATUS_INVALID_PARAMETER) {

        D_ERROR(DbgPrint("IRCOMM: ioctl irp %d bad param, in size=%d, out size=%d\n",
            IrpSp->Parameters.DeviceIoControl.IoControlCode,
            InputLength,
            OutputLength
            );)
    }

#endif

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_PENDING;

}

VOID
UartComplete(
    PVOID    Context,
    PIRP     Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    StartNextPacket(&DeviceExtension->Uart.Queue);

    return;
}



VOID
UartStartRoutine(
    PVOID    Context,
    PIRP     Irp

    )

{

    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION       IrpSp=IoGetCurrentIrpStackLocation(Irp);

    AccessUartState(
        DeviceExtension->ConnectionHandle,
        Irp,
        UartComplete,
        DeviceExtension
        );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\internal.h ===
#define INITGUID

#include <wdm.h>

#include <ntddser.h>
#include <irenum.h>
#include "queue.h"
#include <ircommdbg.h>
#include <vuart.h>


#define INPUT_BUFFER_SIZE   (8092)


typedef struct _READ_STATE {

        PACKET_QUEUE      Queue;

        PIRP              CurrentIrp;
        ULONG             IrpRefCount;
        BOOLEAN           IrpShouldBeCompleted;
        BOOLEAN           IrpShouldBeCompletedWithAnyData;
        BOOLEAN           RefusedDataIndication;

        KTIMER            IntervalTimer;
        KDPC              IntervalTimerDpc;
        BOOLEAN           IntervalTimerSet;

        KTIMER            TotalTimer;
        KDPC              TotalTimerDpc;
        BOOLEAN           TotalTimerSet;
        BOOLEAN           DtrState;

        KSPIN_LOCK        ReadLock;

        ULONG             BytesInBuffer;
        PUCHAR            NextFilledByte;
        PUCHAR            NextEmptyByte;
        LONG              BytesRead;

        ULONG             IntervalTimeOut;


        UCHAR             InputBuffer[INPUT_BUFFER_SIZE];

} READ_STATE, *PREAD_STATE;

typedef struct _WRITE_STATE {

        PACKET_QUEUE      Queue;
        LONG              BytesWritten;

} WRITE_STATE, *PWRITE_STATE;


typedef struct _MASK_STATE {

        PACKET_QUEUE     Queue;

        ULONG            CurrentMask;
        ULONG            HistoryMask;

        PIRP             CurrentWaitMaskIrp;

        KSPIN_LOCK       Lock;

} MASK_STATE, *PMASK_STATE;

typedef struct _UART_STATE {

        PACKET_QUEUE     Queue;

} UART_STATE, *PUART_STATE;

typedef struct _FDO_DEVICE_EXTENSION {


    PDEVICE_OBJECT        DeviceObject;
    PDEVICE_OBJECT        Pdo;
    PDEVICE_OBJECT        LowerDevice;


    BOOLEAN               Removing;
    BOOLEAN               Removed;

    LONG                  OpenCount;

    IRDA_HANDLE           ConnectionHandle;

    UNICODE_STRING        InterfaceName;

    ULONG                 DeviceAddress;

    KSPIN_LOCK            SpinLock;

    SERIAL_TIMEOUTS       TimeOuts;
    SERIAL_QUEUE_SIZE     QueueSizes;
    SERIAL_CHARS          SerialChars;
    SERIAL_HANDFLOW       HandFlow;

    ULONG                 MaxSendSize;

    WRITE_STATE           Write;

    MASK_STATE            Mask;

    UART_STATE            Uart;

    READ_STATE            Read;

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;


#define READ_PURGE_CLEAR_BUFFER  0
#define READ_PURGE_ABORT_IRP     1

VOID
WriteStartRoutine(
    PVOID    Context,
    PIRP     Irp
    );

VOID
MaskStartRoutine(
    PVOID    Context,
    PIRP     Irp
    );

VOID
UartStartRoutine(
    PVOID    Context,
    PIRP     Irp
    );



NTSTATUS
IrCommAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
IrCommPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IrCommPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IrCommWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
//   util fucntions
//
#define LEAVE_NEXT_AS_IS      FALSE
#define COPY_CURRENT_TO_NEXT  TRUE


NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    );

NTSTATUS
ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    );

NTSTATUS
GetRegistryKeyValue (
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    );

NTSTATUS
IrCommHandleSymbolicLink(
    PDEVICE_OBJECT      Pdo,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );

NTSTATUS
QueryPdoInformation(
    PDEVICE_OBJECT    Pdo,
    ULONG             InformationType,
    PVOID             Buffer,
    ULONG             BufferLength
    );



VOID
DumpBuffer(
    PUCHAR    Data,
    ULONG     Length
    );



//
//  io dispatch
//

NTSTATUS
IrCommCreate(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
IrCommClose(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
IrCommWrite(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
IrCommCleanup(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
IrCommQueryInformation(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
IrCommRead(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

NTSTATUS
IrCommDeviceControl(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );






NTSTATUS
DataAvailibleHandler(
    PVOID    Context,
    PUCHAR   Buffer,
    ULONG    BytesAvailible,
    PULONG   BytesUsed
    );

VOID
ReadStartRoutine(
    PVOID    Context,
    PIRP     Irp
    );

VOID
IntervalTimeProc(
    PKDPC    Dpc,
    PVOID    Context,
    PVOID    SystemParam1,
    PVOID    SystemParam2
    );

VOID
TotalTimerProc(
    PKDPC    Dpc,
    PVOID    Context,
    PVOID    SystemParam1,
    PVOID    SystemParam2
    );

VOID
EventHandler(
    PVOID    Context,
    UCHAR    PI,
    UCHAR    PL,
    PUCHAR   PV
    );

VOID
ReadPurge(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    ULONG                 Flags
    );

VOID
EventNotification(
    PFDO_DEVICE_EXTENSION    DeviceExtension,
    ULONG                    SerialEvent
    );


VOID
CleanupIoRequests(
    PFDO_DEVICE_EXTENSION    DeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\initunlo.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"

ULONG  DebugFlags;
ULONG  DebugMemoryTag='oCrI';
PVOID            PagedCodeSectionHandle;
UNICODE_STRING   DriverEntryRegPath;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
IrCommUnload(
    IN PDRIVER_OBJECT DriverObject
    );


NTSTATUS
UnHandledDispatch(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );



#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,IrCommUnload)






NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_NO_SUCH_DEVICE.

--*/

{
    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //
    RTL_QUERY_REGISTRY_TABLE paramTable[4];
    ULONG zero = 0;
    ULONG debugLevel = 0;
    ULONG debugFlags = 0;
    ULONG shouldBreak = 0;


    D_PNP(DbgPrint("IRCOMM: DriverEntry\n");)

    DriverEntryRegPath.Length=RegistryPath->Length;
    DriverEntryRegPath.MaximumLength=DriverEntryRegPath.Length+sizeof(WCHAR);


    DriverEntryRegPath.Buffer=ALLOCATE_PAGED_POOL(DriverEntryRegPath.MaximumLength);

    if (DriverEntryRegPath.Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(
        DriverEntryRegPath.Buffer,
        RegistryPath->Buffer,
        RegistryPath->Length
        );

    //
    //  NULL terminate the string
    //
    DriverEntryRegPath.Buffer[RegistryPath->Length/sizeof(WCHAR)]=L'\0';

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //

    RtlZeroMemory(
        &paramTable[0],
        sizeof(paramTable)
        );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"BreakOnEntry";
    paramTable[0].EntryContext = &shouldBreak;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"DebugFlags";
    paramTable[1].EntryContext = &debugFlags;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &zero;
    paramTable[1].DefaultLength = sizeof(ULONG);

    if (!NT_SUCCESS(RtlQueryRegistryValues(
                        RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                        DriverEntryRegPath.Buffer,
                        &paramTable[0],
                        NULL,
                        NULL
                        ))) {

        shouldBreak = 0;

    }


#if DBG
    DebugFlags=debugFlags;
#endif

    if (shouldBreak) {

        DbgBreakPoint();

    }
    //
    //  pnp driver entry point
    //
    DriverObject->DriverExtension->AddDevice = IrCommAddDevice;

    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverUnload = IrCommUnload;
#if DBG
    {
        ULONG i;

        for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

            DriverObject->MajorFunction[i]=UnHandledDispatch;
        }
    }
#endif
    DriverObject->MajorFunction[IRP_MJ_PNP]     = IrCommPnP;

    DriverObject->MajorFunction[IRP_MJ_POWER]   = IrCommPower;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = IrCommWmi;

    DriverObject->MajorFunction[IRP_MJ_CREATE]  = IrCommCreate;

    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = IrCommClose;

    DriverObject->MajorFunction[IRP_MJ_WRITE]   = IrCommWrite;

    DriverObject->MajorFunction[IRP_MJ_READ]    = IrCommRead;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]    = IrCommDeviceControl;

    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = IrCommCleanup;

    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = IrCommQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = IrCommQueryInformation;
    //
    //  lock and unlock here so we can get a handle to the section
    //  so future calls will be faster
    //
    PagedCodeSectionHandle=MmLockPagableCodeSection(IrCommUnload);
    MmUnlockPagableImageSection(PagedCodeSectionHandle);


    return STATUS_SUCCESS;

}
#if DBG
NTSTATUS
UnHandledDispatch(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{

    NTSTATUS          Status=STATUS_NOT_SUPPORTED;
    PIO_STACK_LOCATION   IrpSp=IoGetCurrentIrpStackLocation(Irp);

    D_ERROR(DbgPrint("IRCOMM: Unhandled irp mj %x\n",IrpSp->MajorFunction);)

    Irp->IoStatus.Status=Status;
    Irp->IoStatus.Information=0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}
#endif


VOID
IrCommUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{

    D_PNP(DbgPrint("IRCOMM: UnLoad\n");)

    FREE_POOL(DriverEntryRegPath.Buffer);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\openclos.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"
#include "ircomm.h"

NTSTATUS
IrCommCreate(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    NTSTATUS          Status=STATUS_SUCCESS;
    IRDA_HANDLE       Handle;
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    UCHAR                    ControlBuffer[4];

    IRCOMM_BUS_INFO    BusInfo;

    if (InterlockedIncrement(&DeviceExtension->OpenCount) > 1) {

        D_ERROR(DbgPrint("IRCOMM: Create already open\n");)

        InterlockedDecrement(&DeviceExtension->OpenCount);

        Irp->IoStatus.Status=STATUS_ACCESS_DENIED;

        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return STATUS_ACCESS_DENIED;
    }


    Status=QueryPdoInformation(
        DeviceExtension->Pdo,
        IRENUM_CONFIG_SPACE_INFO,
        &BusInfo,
        sizeof(BusInfo)
        );

    if (NT_SUCCESS(Status)) {

        DeviceExtension->DeviceAddress=BusInfo.DeviceAddress;
    }

    Status=IrdaConnect(
        DeviceExtension->DeviceAddress,
        "IrDA:IrCOMM",
        BusInfo.OutGoingConnection,
        &DeviceExtension->ConnectionHandle,
        DataAvailibleHandler,
        EventNotification,
        DeviceExtension
        );

    D_TRACE(DbgPrint("IRCOMM: Create %08lx\n",Status);)



    if (NT_SUCCESS(Status)) {

        DeviceExtension->HandFlow.ControlHandShake=SERIAL_DTR_CONTROL | SERIAL_CTS_HANDSHAKE;
        DeviceExtension->HandFlow.FlowReplace=SERIAL_RTS_HANDSHAKE;

    } else {
        //
        //  could not creat the connection
        //
        goto CleanUp;
    }


    Irp->IoStatus.Status=Status;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);


    return Status;

CleanUp:

    //
    //  something failed, undo what we did in this function
    //

    if (DeviceExtension->ConnectionHandle != NULL) {

        FreeConnection(DeviceExtension->ConnectionHandle);
        DeviceExtension->ConnectionHandle=NULL;
    }

    InterlockedDecrement(&DeviceExtension->OpenCount);

    Irp->IoStatus.Status=Status;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return Status;


}



NTSTATUS
IrCommClose(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS          Status=STATUS_SUCCESS;


    FreeConnection(DeviceExtension->ConnectionHandle);
    DeviceExtension->ConnectionHandle=NULL;


    InterlockedDecrement(&DeviceExtension->OpenCount);

    Irp->IoStatus.Status=Status;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return Status;

}


VOID
CleanupIoRequests(
    PFDO_DEVICE_EXTENSION    DeviceExtension
    )
{

    KIRQL                    OldIrql;
    PIRP                     WaitIrp=NULL;

    FlushQueuedPackets(&DeviceExtension->Write.Queue,FLUSH_ALL_IRPS);
    FlushQueuedPackets(&DeviceExtension->Read.Queue,FLUSH_ALL_IRPS);
    ReadPurge(DeviceExtension,0);

    FlushQueuedPackets(&DeviceExtension->Mask.Queue,FLUSH_ALL_IRPS);

    FlushQueuedPackets(&DeviceExtension->Uart.Queue,FLUSH_ALL_IRPS);

    KeAcquireSpinLock(&DeviceExtension->Mask.Lock,&OldIrql);

    WaitIrp=DeviceExtension->Mask.CurrentWaitMaskIrp;
    DeviceExtension->Mask.CurrentWaitMaskIrp=NULL;

    KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

    if (WaitIrp != NULL) {

        WaitIrp->IoStatus.Status=STATUS_CANCELLED;
        WaitIrp->IoStatus.Information=0;

        IoCompleteRequest(WaitIrp,IO_NO_INCREMENT);
    }

    return;
}

NTSTATUS
IrCommCleanup(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS                 Status=STATUS_SUCCESS;

    D_TRACE(DbgPrint("IRCOMM: Cleanup\n");)

    CleanupIoRequests(DeviceExtension);

    Irp->IoStatus.Status=Status;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return Status;

}

NTSTATUS
IrCommQueryInformation(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS          Status=STATUS_SUCCESS;


    Irp->IoStatus.Status=Status;
    Irp->IoStatus.Information=0;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\pnp.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"




NTSTATUS
IrCommAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

{
    NTSTATUS       Status;

    WCHAR          TempBuffer[256];

    PDEVICE_OBJECT Fdo = NULL;

    PDEVICE_OBJECT LowerDevice=NULL;

    //
    // Pointer to the device extension created for this
    // device
    //
    PFDO_DEVICE_EXTENSION DeviceExtension = NULL;

    D_PNP(DbgPrint("IrComm: AddDevice\n");)


    //
    // Create the device object for this device.
    //

    Status = IoCreateDevice(
                 DriverObject,
                 sizeof(FDO_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_NULL,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &Fdo
                 );

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    LowerDevice=IoAttachDeviceToDeviceStack(
        Fdo,
        Pdo
        );

    if (LowerDevice == NULL) {

        D_ERROR(DbgPrint("IRCOMM: Could not attach to PDO\n");)

        Status=STATUS_INSUFFICIENT_RESOURCES;

        goto CleanUp;
    }

    Fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    Fdo->StackSize=LowerDevice->StackSize+1;

    DeviceExtension=Fdo->DeviceExtension;

    D_ERROR(DbgPrint("IRCOMM: Device Extension %p\n",DeviceExtension);)

    DeviceExtension->DeviceObject = Fdo;
    DeviceExtension->Pdo=Pdo;
    DeviceExtension->LowerDevice=LowerDevice;

    KeInitializeTimer(
        &DeviceExtension->Read.IntervalTimer
        );

    KeInitializeDpc(
        &DeviceExtension->Read.IntervalTimerDpc,
        IntervalTimeProc,
        DeviceExtension
        );

    KeInitializeTimer(
        &DeviceExtension->Read.TotalTimer
        );

    KeInitializeDpc(
        &DeviceExtension->Read.TotalTimerDpc,
        TotalTimerProc,
        DeviceExtension
        );


    KeInitializeSpinLock(
        &DeviceExtension->SpinLock
        );



    KeInitializeSpinLock(
        &DeviceExtension->Read.ReadLock
        );


    KeInitializeSpinLock(
        &DeviceExtension->Mask.Lock
        );



    IrCommHandleSymbolicLink(
        Pdo,
        &DeviceExtension->InterfaceName,
        TRUE
        );


    {
        IRCOMM_BUS_INFO    BusInfo;

        QueryPdoInformation(
            Pdo,
            IRENUM_CONFIG_SPACE_INFO,
            &BusInfo,
            sizeof(BusInfo)
            );

        DeviceExtension->DeviceAddress=BusInfo.DeviceAddress;
    }

    InitializePacketQueue(
        &DeviceExtension->Write.Queue,
        DeviceExtension,
        WriteStartRoutine
        );

    InitializePacketQueue(
        &DeviceExtension->Read.Queue,
        DeviceExtension,
        ReadStartRoutine
        );

    InitializePacketQueue(
        &DeviceExtension->Mask.Queue,
        DeviceExtension,
        MaskStartRoutine
        );

    InitializePacketQueue(
        &DeviceExtension->Uart.Queue,
        DeviceExtension,
        UartStartRoutine
        );

#if 0
    DeviceExtension->LineControl.StopBits=1;
    DeviceExtension->LineControl.Parity=0;
    DeviceExtension->LineControl.WordLength=8;

    DeviceExtension->BaudRate=115200;
#endif
    DeviceExtension->Read.BytesInBuffer=0;
    DeviceExtension->Read.NextFilledByte=&DeviceExtension->Read.InputBuffer[0];
    DeviceExtension->Read.NextEmptyByte=&DeviceExtension->Read.InputBuffer[0];

    return STATUS_SUCCESS;

CleanUp:

    IoDeleteDevice(Fdo);

    return Status;

}

NTSTATUS
IrCommPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    ULONG                   i;



    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_START_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_QUERY_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("IRCOMM: IRP_MN_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("IrComm: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("IrComm: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        case IRP_MN_SURPRISE_REMOVAL: {

            D_PNP(DbgPrint("IrComm: IRP_MN_SURPRISE_REMOVAL\n");)

            DeviceExtension->Removing=TRUE;

            //
            //  now that new io is blocked, flush out all pended irps
            //
            CleanupIoRequests(DeviceExtension);

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        }
        break;


        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;

            D_PNP(DbgPrint("IrComm: IRP_MN_REMOVE_DEVICE\n");)
            //
            //  removing now for sure
            //
            DeviceExtension->Removing=TRUE;
            DeviceExtension->Removed=TRUE;


            if (DeviceExtension->InterfaceName.Buffer != NULL) {

                IrCommHandleSymbolicLink(
                    DeviceExtension->Pdo,
                    &DeviceExtension->InterfaceName,
                    FALSE
                    );
            }

            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=IoCallDriver(DeviceExtension->LowerDevice, Irp);

            //
            //  detach from the driver below
            //
            IoDetachDevice(DeviceExtension->LowerDevice);

            //
            //  delete our device object
            //
            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("IrComm: IRP_MN_REMOVE_DEVICE exit, %08lx\n",status);)

            return status;

        }


        default:
            D_PNP(DbgPrint("IrComm: Sending to PDO PnP IRP, MN func=%d\n",irpSp->MinorFunction);)

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);
    }



    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

NTSTATUS
IrCommPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(DeviceExtension->LowerDevice, Irp);

}

NTSTATUS
IrCommWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\queue.c ===
#include "internal.h"

#pragma alloc_text(PAGE,InitializePacketQueue)

VOID
InitializePacketQueue(
    PPACKET_QUEUE    PacketQueue,
    PVOID            Context,
    PACKET_STARTER   StarterRoutine
    )

{

    RtlZeroMemory(PacketQueue,sizeof(*PacketQueue));

    KeInitializeSpinLock(&PacketQueue->Lock);

    PacketQueue->Context=Context;

    PacketQueue->Starter=StarterRoutine;

    PacketQueue->Active=TRUE;

    KeInitializeEvent(&PacketQueue->InactiveEvent,NotificationEvent,FALSE);

    InitializeListHead(&PacketQueue->ListHead);

    return;

}

VOID
IrpQueueCancelRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PPACKET_QUEUE     PacketQueue;
    KIRQL             OldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    PacketQueue=Irp->Tail.Overlay.DriverContext[0];

    KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

    if (Irp->Tail.Overlay.ListEntry.Flink == NULL) {
        //
        //  the irp has been removed from the queue
        //
    } else {
        //
        //  the irp is still in the queue, remove it
        //
        RemoveEntryList(
            &Irp->Tail.Overlay.ListEntry
            );
    }

    KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

    Irp->IoStatus.Status=STATUS_CANCELLED;
    Irp->IoStatus.Information=0;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return;
}

PIRP
GetUseableIrp(
    PLIST_ENTRY    List
    )

{
    PIRP    Packet=NULL;

    while ( (Packet == NULL) && !IsListEmpty(List)) {
        //
        //  there is a packet queued
        //
        PLIST_ENTRY              ListEntry;

        ListEntry=RemoveTailList(List);

        Packet=CONTAINING_RECORD(ListEntry,IRP,Tail.Overlay.ListEntry);

        if (IoSetCancelRoutine(Packet,NULL) == NULL) {
            //
            //  The cancel rountine has run and is waiting on the queue spinlock,
            //  set the flink to null so the cancel routine knows not to try
            //  take the irp off the list
            //
            Packet->Tail.Overlay.ListEntry.Flink=NULL;
            Packet=NULL;

            //
            //  try to get another one
            //
        }
    }

    return Packet;

}




VOID
QueuePacket(
    PPACKET_QUEUE    PacketQueue,
    PIRP             Packet,
    BOOLEAN          InsertAtFront
    )

{

    NTSTATUS                 Status;
    KIRQL                    OldIrql;
    KIRQL                    CancelIrql;
    BOOLEAN                  Canceled=FALSE;

    KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

    if ((PacketQueue->CurrentPacket == NULL) && PacketQueue->Active && (IsListEmpty(&PacketQueue->ListHead))) {
        //
        //  not currently handling a packet and the queue is active and there are not other packets
        //  queued, so handle it now
        //

        PacketQueue->CurrentPacket=Packet;

        KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

        (*PacketQueue->Starter)(
            PacketQueue->Context,
            Packet
            );

        return;

    }

    Packet->Tail.Overlay.DriverContext[0]=PacketQueue;

    IoAcquireCancelSpinLock(&CancelIrql);

    if (Packet->Cancel) {
        //
        //  the irp has already been canceled
        //
        Canceled=TRUE;

    } else {

        IoSetCancelRoutine(
            Packet,
            IrpQueueCancelRoutine
            );
    }

    IoReleaseCancelSpinLock(CancelIrql);


    //
    //  need to queue the packet
    //

    if (!Canceled) {

        if (InsertAtFront) {
            //
            //  this one is high priorty for some reason, put it at the front
            //
            InsertTailList(&PacketQueue->ListHead,&Packet->Tail.Overlay.ListEntry);

        } else {

            InsertHeadList(&PacketQueue->ListHead,&Packet->Tail.Overlay.ListEntry);
        }
    }

    KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

    if (Canceled) {
        //
        //  complete the canceled irp now
        //
        Packet->IoStatus.Status=STATUS_CANCELLED;
        Packet->IoStatus.Information=0;

        IoCompleteRequest(Packet,IO_NO_INCREMENT);
    }


    return;

}


VOID
StartNextPacket(
    PPACKET_QUEUE    PacketQueue
    )

{
    KIRQL                    OldIrql;

    KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

    ASSERT(PacketQueue->CurrentPacket != NULL);

    //
    //  done with this one
    //
    PacketQueue->CurrentPacket=NULL;

    if (!PacketQueue->InStartNext) {
        //
        //  not already in this function
        //
        PacketQueue->InStartNext=TRUE;

        while ((PacketQueue->CurrentPacket == NULL) && PacketQueue->Active ) {
            //
            //  there isn't a current packet and the queue is active
            //
            PIRP    Packet;

            Packet=GetUseableIrp(&PacketQueue->ListHead);

            if (Packet != NULL) {
                //
                //  we got an irp to use
                //
                //  now the current one
                //
                PacketQueue->CurrentPacket=Packet;

                KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

                //
                //  start the processing
                //
                (*PacketQueue->Starter)(
                    PacketQueue->Context,
                    Packet
                    );

                KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

            } else {
                //
                //  queue is empty, break out of loop
                //
                break;

            }

        }

        if (!PacketQueue->Active && (PacketQueue->CurrentPacket == NULL)) {
            //
            //  the queue has been paused and we don't have a current packet, signal the event
            //
            KeSetEvent(
                &PacketQueue->InactiveEvent,
                IO_NO_INCREMENT,
                FALSE
                );
        }

        PacketQueue->InStartNext=FALSE;
    }

    KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

    return;

}

VOID
PausePacketProcessing(
    PPACKET_QUEUE    PacketQueue,
    BOOLEAN          WaitForInactive
    )

{
    KIRQL                    OldIrql;
    BOOLEAN   CurrentlyActive=FALSE;

    KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

    PacketQueue->Active=FALSE;

    if (PacketQueue->CurrentPacket != NULL) {
        //
        //  there is a packet currently being processed
        //
        CurrentlyActive=TRUE;

        KeClearEvent(&PacketQueue->InactiveEvent);

    }

    KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

    if (WaitForInactive  && CurrentlyActive) {
        //
        //  the caller wants use to wait for the queue to inactive, and it was active when
        //  theis was called
        //
        KeWaitForSingleObject(
            &PacketQueue->InactiveEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }

    return;

}

VOID
ActivatePacketProcessing(
    PPACKET_QUEUE    PacketQueue
    )

{

    KIRQL                    OldIrql;

    KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

    PacketQueue->Active=TRUE;

    if ((PacketQueue->CurrentPacket == NULL)) {
        //
        //  No packet is currently being used
        //
        PIRP    Packet;

        Packet=GetUseableIrp(&PacketQueue->ListHead);

        if (Packet != NULL) {
            //
            //  we got an irp to use
            //
            //  now the current one
            //
            PacketQueue->CurrentPacket=Packet;

            KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

            //
            //  start the processing
            //
            (*PacketQueue->Starter)(
                PacketQueue->Context,
                Packet
                );

            KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

        }

    }


    KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

    return;

}



VOID
FlushQueuedPackets(
    PPACKET_QUEUE    PacketQueue,
    UCHAR            MajorFunction
    )

{
    KIRQL                    OldIrql;
    PIRP                     Packet;
    LIST_ENTRY               TempList;

    InitializeListHead(&TempList);

    //
    //  dispose of all of the queue packets, don't touch the current one though
    //
    KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

    Packet=GetUseableIrp(&PacketQueue->ListHead);

    while (Packet != NULL) {

        PIO_STACK_LOCATION    IrpSp=IoGetCurrentIrpStackLocation(Packet);

        if ((MajorFunction == 0xff) || (MajorFunction==IrpSp->MajorFunction)) {
            //
            //  either the caller wants all of irps completed, or they just want
            //  this specific type. In any case this is going to get completed
            //
            KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

            Packet->IoStatus.Status=STATUS_CANCELLED;
            Packet->IoStatus.Information=0;

            IoCompleteRequest(Packet,IO_NO_INCREMENT);

            KeAcquireSpinLock(&PacketQueue->Lock,&OldIrql);

        } else {
            //
            //  this one does not need to be completed, put it on the temp list
            //
            InsertHeadList(&TempList,&Packet->Tail.Overlay.ListEntry);

        }

        Packet=GetUseableIrp(&PacketQueue->ListHead);
    }

    while (!IsListEmpty(&TempList)) {
        //
        //  move all the irps on the temp queue back to the real queue
        //
        PLIST_ENTRY              ListEntry;

        ListEntry=RemoveTailList(&TempList);

        InsertHeadList(&PacketQueue->ListHead,ListEntry);
    }

    KeReleaseSpinLock(&PacketQueue->Lock,OldIrql);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\mask.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mask.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"
#include "ircomm.h"


VOID
WaitMaskCancelRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

PIRP
GetCurrentWaitIrp(
    PFDO_DEVICE_EXTENSION DeviceExtension
    );


VOID
MaskStartRoutine(
    PVOID    Context,
    PIRP     Irp
    )

{

    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION       IrpSp = IoGetCurrentIrpStackLocation(Irp);

    KIRQL                    OldIrql;

    PUCHAR                   SystemBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG                    InputLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ULONG                    OutputLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;


    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_GET_WAIT_MASK:

            if (OutputLength >= sizeof(ULONG)) {

                *(PULONG)SystemBuffer=DeviceExtension->Mask.CurrentMask;
                Irp->IoStatus.Information=sizeof(ULONG);
                Irp->IoStatus.Status=STATUS_SUCCESS;

            } else {

                Irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
            }

            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            StartNextPacket(&DeviceExtension->Mask.Queue);

            break;


        case IOCTL_SERIAL_SET_WAIT_MASK: {


            ULONG   NewMask=*(PULONG)SystemBuffer;

            if (InputLength >= sizeof(ULONG)) {

                PIRP    WaitIrp=NULL;

                D_TRACE(DbgPrint("IRCOMM: mask %08lx\n",NewMask);)

                KeAcquireSpinLock(&DeviceExtension->Mask.Lock,&OldIrql);

                DeviceExtension->Mask.HistoryMask &= NewMask;
                DeviceExtension->Mask.CurrentMask=NewMask;

                Irp->IoStatus.Status=STATUS_SUCCESS;

                //
                //  if there was a wait irp, clear ir out now
                //
                WaitIrp=GetCurrentWaitIrp(DeviceExtension);

                KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

                if (WaitIrp != NULL) {

                    WaitIrp->IoStatus.Information=sizeof(ULONG);
                    WaitIrp->IoStatus.Status=STATUS_SUCCESS;

                    *(PULONG)WaitIrp->AssociatedIrp.SystemBuffer=0;

                    IoCompleteRequest(WaitIrp,IO_NO_INCREMENT);
                }

            } else {

                Irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
            }


            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            StartNextPacket(&DeviceExtension->Mask.Queue);

            break;
        }


        case IOCTL_SERIAL_WAIT_ON_MASK:

            if (OutputLength >= sizeof(ULONG)) {

                KeAcquireSpinLock(&DeviceExtension->Mask.Lock,&OldIrql);

                if ((DeviceExtension->Mask.CurrentWaitMaskIrp == NULL) && (DeviceExtension->Mask.CurrentMask != 0)) {

                    if (DeviceExtension->Mask.CurrentMask & DeviceExtension->Mask.HistoryMask) {
                        //
                        //  we got an event while there a was no irp queue, complete this
                        //  one with the event, and clear the history
                        //
                        D_TRACE(DbgPrint("IRCOMM: Completing wait from histroy %08lx\n", DeviceExtension->Mask.HistoryMask & DeviceExtension->Mask.CurrentMask);)

                        *(PULONG)Irp->AssociatedIrp.SystemBuffer=DeviceExtension->Mask.HistoryMask & DeviceExtension->Mask.CurrentMask;
                        DeviceExtension->Mask.HistoryMask=0;

                        Irp->IoStatus.Information=sizeof(ULONG);
                        Irp->IoStatus.Status=STATUS_SUCCESS;

                    } else {
                        //
                        //  the irp will remain pending here until an event happens
                        //
                        KIRQL    CancelIrql;

                        IoAcquireCancelSpinLock(&CancelIrql);

                        if (Irp->Cancel) {
                            //
                            //  canceled already
                            //
                            Irp->IoStatus.Status=STATUS_CANCELLED;

                            IoReleaseCancelSpinLock(CancelIrql);

                            KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

                        } else {
                            //
                            //  not canceled, set the cancel routine and proceed
                            //
                            IoSetCancelRoutine(Irp,WaitMaskCancelRoutine);

                            DeviceExtension->Mask.CurrentWaitMaskIrp=Irp;

                            IoReleaseCancelSpinLock(CancelIrql);

                            KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

                            //
                            //  were done processing this so far, we can now handle more
                            //  requests from the irp queue
                            //
                            Irp=NULL;

                            StartNextPacket(&DeviceExtension->Mask.Queue);

                            return;
                        }
                    }

                } else {
                    //
                    //  already have an wait event irp or there is not currently an event mask set, fail
                    //
                    D_ERROR(DbgPrint("IRCOMM: MaskStartRoutine: WaitOnMask failing, Current=&p, Mask=%08lx\n",DeviceExtension->Mask.CurrentWaitMaskIrp,DeviceExtension->Mask.CurrentMask);)

                    Irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
                }

                KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

            } else {
                //
                //  too small
                //
                Irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
            }

            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            StartNextPacket(&DeviceExtension->Mask.Queue);

            break;

        default:

            ASSERT(0);

            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            StartNextPacket(&DeviceExtension->Mask.Queue);

            break;
    }

    return;
}



VOID
WaitMaskCancelRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{

    PFDO_DEVICE_EXTENSION DeviceExtension=DeviceObject->DeviceExtension;
    KIRQL                 OldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    KeAcquireSpinLock(&DeviceExtension->Mask.Lock,&OldIrql);

    //
    //  since we only handle one mask irp at a time, it should not be possible for it to not
    //  be the current one
    //
    ASSERT(DeviceExtension->Mask.CurrentWaitMaskIrp == Irp);
    DeviceExtension->Mask.CurrentWaitMaskIrp=NULL;

    KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

    Irp->IoStatus.Status=STATUS_CANCELLED;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return;
}

VOID
EventNotification(
    PFDO_DEVICE_EXTENSION    DeviceExtension,
    ULONG                    SerialEvent
    )

{

    PIRP                     WaitIrp=NULL;
    KIRQL                    OldIrql;


    KeAcquireSpinLock(&DeviceExtension->Mask.Lock,&OldIrql);

    if (SerialEvent & DeviceExtension->Mask.CurrentMask) {
        //
        //  an event the the client is intereasted in occured
        //
        WaitIrp=GetCurrentWaitIrp(DeviceExtension);

        if (WaitIrp != NULL) {
            //
            //  There is a wait irp pending
            //
            D_TRACE(DbgPrint("IRCOMM: Completing wait event %08lx\n", SerialEvent & DeviceExtension->Mask.CurrentMask);)

            *(PULONG)WaitIrp->AssociatedIrp.SystemBuffer=SerialEvent & DeviceExtension->Mask.CurrentMask;

        } else {
            //
            //  this was an event the the client was interested in, but there was no wait irp
            //  add it to the histrory mask
            //
            DeviceExtension->Mask.HistoryMask |= SerialEvent & DeviceExtension->Mask.CurrentMask;
        }
    }


    KeReleaseSpinLock(&DeviceExtension->Mask.Lock,OldIrql);

    if (WaitIrp != NULL) {

        WaitIrp->IoStatus.Information=sizeof(ULONG);
        WaitIrp->IoStatus.Status=STATUS_SUCCESS;

        IoCompleteRequest(WaitIrp,IO_NO_INCREMENT);
    }

    return;
}


PIRP
GetCurrentWaitIrp(
    PFDO_DEVICE_EXTENSION DeviceExtension
    )

{
    PVOID    OldCancelRoutine;
    PIRP     WaitIrp;

    //
    //  if there was a wait irp, clear ir out now
    //
    WaitIrp=DeviceExtension->Mask.CurrentWaitMaskIrp;

    if (WaitIrp != NULL) {

        OldCancelRoutine=IoSetCancelRoutine(WaitIrp,NULL);

        if (OldCancelRoutine == NULL) {
            //
            //  the cancel routine has run and will complete the irp
            //
            WaitIrp=NULL;

        } else {
            //
            //  the cancel routine will not be running, clear the irp out
            //
            DeviceExtension->Mask.CurrentWaitMaskIrp=NULL;
        }
    }

    return WaitIrp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\queue.h ===
typedef VOID (*PACKET_STARTER)(
    PVOID                       Context,
    PIRP                        Irp
    );



typedef struct _PACKET_QUEUE {

    LIST_ENTRY      ListHead;

    PIRP            CurrentPacket;

    BOOLEAN         Active;

    BOOLEAN         InStartNext;

    KSPIN_LOCK      Lock;

    PVOID           Context;

    PACKET_STARTER  Starter;

    KEVENT          InactiveEvent;

} PACKET_QUEUE, *PPACKET_QUEUE;





VOID
InitializePacketQueue(
    PPACKET_QUEUE    PacketQueue,
    PVOID            Context,
    PACKET_STARTER   StarterRoutine
    );

VOID
QueuePacket(
    PPACKET_QUEUE    PacketQueue,
    PIRP             Irp,
    BOOLEAN          InsertAtFront
    );

VOID
StartNextPacket(
    PPACKET_QUEUE    PacketQueue
    );

VOID
PausePacketProcessing(
    PPACKET_QUEUE    PacketQueue,
    BOOLEAN          WaitForInactive
    );

VOID
ActivatePacketProcessing(
    PPACKET_QUEUE    PacketQueue
    );

#define FLUSH_ALL_IRPS (0xff)

VOID
FlushQueuedPackets(
    PPACKET_QUEUE    PacketQueue,
    UCHAR            MajorFunction
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\irenum\internal.h ===
#include <ntddk.h>


#include <irenum.h>
#include <ircommdbg.h>



extern ULONG  EnumStaticDevice;

#define DO_TYPE_PDO   ' ODP'
#define DO_TYPE_FDO   ' ODF'

#define DO_TYPE_DEL_PDO   'ODPx'
#define DO_TYPE_DEL_FDO   'ODFx'

typedef KEVENT PASSIVE_LOCK, *PPASSICE_LOCK;

#define INIT_PASSIVE_LOCK(_lock)    KeInitializeEvent(_lock,SynchronizationEvent,TRUE)

#define ACQUIRE_PASSIVE_LOCK(_lock) KeWaitForSingleObject(_lock,Executive,KernelMode, FALSE, NULL)

#define RELEASE_PASSIVE_LOCK(_lock) KeSetEvent(_lock,IO_NO_INCREMENT,FALSE)

#define IRENUM_COMPAT_ID L"PNPC103"
#define IRENUM_PREFIX    L"IRENUM\\"

#define MAX_COMPAT_IDS  17

typedef struct _IR_DEVICE {

    ULONG     DeviceId;

    WCHAR     DeviceName[24];

    UCHAR     Hint1;
    UCHAR     Hint2;

    PWSTR     HardwareId;
    LONG      CompatIdCount;
    PWSTR     CompatId[MAX_COMPAT_IDS];
    PWSTR     Name;
    PWSTR     Manufacturer;


    ULONG     PresentCount;
    BOOLEAN   InUse;
    BOOLEAN   Enumerated;
    BOOLEAN   Static;
    BOOLEAN   Printer;
    BOOLEAN   Modem;

    PDEVICE_OBJECT    Pdo;

} IR_DEVICE, *PIR_DEVICE;


typedef PVOID  ENUM_HANDLE;

typedef struct _FDO_DEVICE_EXTENSION {

    ULONG             DoType;

    PDEVICE_OBJECT    DeviceObject;
    PDEVICE_OBJECT    Pdo;
    PDEVICE_OBJECT    LowerDevice;

    ENUM_HANDLE       EnumHandle;

    BOOLEAN           CreateStaticDevice;

    BOOLEAN           Removing;
    BOOLEAN           Removed;



} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;

typedef struct _PDO_DEVICE_EXTENSION {

    ULONG             DoType;

    PDEVICE_OBJECT    ParentFdo;

    PIR_DEVICE        DeviceDescription;

} PDO_DEVICE_EXTENSION, *PPDO_DEVICE_EXTENSION;


NTSTATUS
IrEnumAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
IrEnumPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IrEnumPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IrEnumWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#define LEAVE_NEXT_AS_IS      FALSE
#define COPY_CURRENT_TO_NEXT  TRUE


NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    );

NTSTATUS
ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    );



//
//  enumeration object
//

NTSTATUS
CreateEnumObject(
    PDEVICE_OBJECT  Fdo,
    ENUM_HANDLE    *Object,
    BOOLEAN         CreateStaticDevice
    );


VOID
CloseEnumObject(
    ENUM_HANDLE    Handle
    );

NTSTATUS
GetDeviceList(
    ENUM_HANDLE    Handle,
    PIRP           Irp
    );

VOID
RemoveDevice(
    ENUM_HANDLE    Handle,
    PIR_DEVICE     IrDevice
    );


//
//  child irp handlers
//

NTSTATUS
IrEnumPdoPnp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );


NTSTATUS
IrEnumPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IrEnumPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



NTSTATUS
GetRegistryKeyValue(
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\write.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"
#include "ircomm.h"


VOID
ProcesWriteData(
    PFDO_DEVICE_EXTENSION    DeviceExtension
    );



NTSTATUS
IrCommWrite(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS                 Status=STATUS_SUCCESS;

    D_TRACE(DbgPrint("IRCOMM: IrCommWrite\n");)

    if (DeviceExtension->Removing) {
        //
        //  the device has been removed, no more irps
        //
        Irp->IoStatus.Status=STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    IoMarkIrpPending(Irp);

    QueuePacket(&DeviceExtension->Write.Queue,Irp,FALSE);

    return STATUS_PENDING;

}


VOID
SendComplete(
    PVOID    Context,
    PIRP     Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION       IrpSp=IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        InterlockedExchangeAdd(
            &DeviceExtension->Write.BytesWritten,
            (LONG)Irp->IoStatus.Information
            );
    }

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    StartNextPacket(&DeviceExtension->Write.Queue);

    return;
}



VOID
WriteStartRoutine(
    PVOID    Context,
    PIRP     Irp
    )

{

    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION       IrpSp=IoGetCurrentIrpStackLocation(Irp);

    SendOnConnection(
        DeviceExtension->ConnectionHandle,
        Irp,
        SendComplete,
        DeviceExtension,
        DeviceExtension->TimeOuts.WriteTotalTimeoutConstant + (DeviceExtension->TimeOuts.WriteTotalTimeoutMultiplier * IrpSp->Parameters.Write.Length)
        );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\irenum\enum.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"


#define UINT ULONG //tmp

#include <irioctl.h>

#include <ircommtdi.h>

#define MAX_DEVICES  16

#define STATIC_DEVICE_NAME  L"Incoming IRCOMM"
#define STATIC_HARDWARE_ID  L"IR_NULL_IN"

#define GENERIC_MODEM_NAME  L"Infrared Modem"
#define GENERIC_HARDWARE_ID L"PNPC103"

#define DEVICE_PRESENT_START_VALUE   (1)

int sprintf(char *, ...);

typedef struct _ENUM_OBJECT {

    PVOID             ThreadObject;
    KEVENT            WaitEvent;
    KTIMER            Timer;

    PASSIVE_LOCK      PassiveLock;

    HANDLE            IoWaitEventHandle;
    PKEVENT           IoWaitEventObject;
    IO_STATUS_BLOCK   IoStatusBlock;

    HANDLE            ControlChannel;

    PDEVICE_OBJECT    Fdo;

    ULONG             DeviceCount;
    ULONG             EnumeratedDevices;

    UCHAR             DeviceListBuffer[512];

    IR_DEVICE         Devices[MAX_DEVICES];

} ENUM_OBJECT, *PENUM_OBJECT;


VOID
WorkerThread(
    PVOID    Context
    );

NTSTATUS
EnumIrda(
    PENUM_OBJECT    EnumObject
    );

NTSTATUS
DoIasQueries(
    PIR_DEVICE    IrDevice
    );


NTSTATUS
CreatePdo(
    PDEVICE_OBJECT    Fdo,
    PIR_DEVICE        IrDevice
    );

NTSTATUS
CreateStaticDevice(
    PENUM_OBJECT    EnumObject
    );

VOID
CloseEnumObject(
    ENUM_HANDLE    Handle
    );

NTSTATUS
DeviceNameFromDeviceInfo(
    PIRDA_DEVICE_INFO   DeviceInfo,
    PWCHAR              DeviceName,
    ULONG               NameLength
    );

VOID
FixupDeviceId(
    PWSTR   HardwareId
    );


#pragma alloc_text(PAGE,WorkerThread)
#pragma alloc_text(PAGE,EnumIrda)
#pragma alloc_text(PAGE,DoIasQueries)
#pragma alloc_text(PAGE,CreatePdo)
#pragma alloc_text(PAGE,CreateStaticDevice)
#pragma alloc_text(PAGE,CloseEnumObject)
#pragma alloc_text(PAGE,DeviceNameFromDeviceInfo)
#pragma alloc_text(PAGE,FixupDeviceId)
#pragma alloc_text(PAGE,GetDeviceList)
#pragma alloc_text(PAGE,RemoveDevice)


NTSTATUS
CreateStaticDevice(
    PENUM_OBJECT    EnumObject
    )

{
    NTSTATUS          Status;
    ULONG             DeviceId=0;
    PIR_DEVICE        IrDevice=&EnumObject->Devices[0];

    //
    //  zero the whole thing
    //
    RtlZeroMemory(IrDevice,sizeof(*IrDevice));

    //
    //  inuse now
    //
    IrDevice->InUse=TRUE;

    IrDevice->PresentCount=DEVICE_PRESENT_START_VALUE;

    IrDevice->Static=TRUE;

    EnumObject->DeviceCount++;

    EnumObject->EnumeratedDevices++;


    RtlCopyMemory(&IrDevice->DeviceId,&DeviceId,4);


    RtlCopyMemory(
        IrDevice->DeviceName,
        STATIC_DEVICE_NAME,
        sizeof(STATIC_DEVICE_NAME)
        );


    IrDevice->Name=ALLOCATE_PAGED_POOL(sizeof(STATIC_DEVICE_NAME));

    if (IrDevice->Name == NULL) {

        Status=STATUS_NO_MEMORY;
        goto CleanUp;
    }

    RtlCopyMemory(
        IrDevice->Name,
        STATIC_DEVICE_NAME,
        sizeof(STATIC_DEVICE_NAME)
        );


    IrDevice->HardwareId=ALLOCATE_PAGED_POOL(sizeof(STATIC_HARDWARE_ID));

    if (IrDevice->HardwareId == NULL) {

        Status=STATUS_NO_MEMORY;
        goto CleanUp;
    }

    RtlCopyMemory(
        IrDevice->HardwareId,
        STATIC_HARDWARE_ID,
        sizeof(STATIC_HARDWARE_ID)
        );


    Status=CreatePdo(
        EnumObject->Fdo,
        IrDevice
        );

    if (NT_SUCCESS(Status)) {

        return Status;
    }

CleanUp:

    if (IrDevice->Name != NULL) {

        FREE_POOL(IrDevice->Name);
    }


    if (IrDevice->HardwareId != NULL) {

        FREE_POOL(IrDevice->HardwareId);
    }

    RtlZeroMemory(IrDevice,sizeof(&IrDevice));

    EnumObject->DeviceCount--;

    EnumObject->EnumeratedDevices--;

    return Status;
}

NTSTATUS
CreateEnumObject(
    PDEVICE_OBJECT  Fdo,
    ENUM_HANDLE    *Object,
    BOOLEAN         StaticDevice
    )

{
    NTSTATUS        Status;
    PENUM_OBJECT    EnumObject;
    HANDLE          ThreadHandle;
    UNICODE_STRING  EventName;

    *Object=NULL;

    EnumObject=ALLOCATE_NONPAGED_POOL(sizeof(*EnumObject));

    if (EnumObject==NULL) {

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(EnumObject,sizeof(*EnumObject));

    KeInitializeEvent(
        &EnumObject->WaitEvent,
        NotificationEvent,
        FALSE
        );

    KeInitializeTimerEx(
        &EnumObject->Timer,
        SynchronizationTimer
        );

    INIT_PASSIVE_LOCK(&EnumObject->PassiveLock);


    EnumObject->Fdo=Fdo;

    if (StaticDevice) {

        CreateStaticDevice(EnumObject);
    }

    RtlInitUnicodeString(
        &EventName,
        L"\\Device\\IrEnumIoEvent"
        );

    EnumObject->IoWaitEventObject=IoCreateNotificationEvent(
        &EventName,
        &EnumObject->IoWaitEventHandle
        );

    if (EnumObject->IoWaitEventObject == NULL) {

        D_ERROR(DbgPrint("IRENUM: could not create event\n");)

        goto CleanUp;
    }


    Status=PsCreateSystemThread(
        &ThreadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        NULL,
        NULL,
        WorkerThread,
        EnumObject
        );

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    Status=ObReferenceObjectByHandle(
        ThreadHandle,
        0,
        NULL,
        KernelMode,
        &EnumObject->ThreadObject,
        NULL
        );

    ZwClose(ThreadHandle);
    ThreadHandle=NULL;

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    *Object=EnumObject;

    return Status;


CleanUp:

    KeSetEvent(
        &EnumObject->WaitEvent,
        IO_NO_INCREMENT,
        FALSE
        );

    //
    //  make sure we really got the object
    //
    if (EnumObject->ThreadObject != NULL) {

        KeWaitForSingleObject(
            EnumObject->ThreadObject,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        ObDereferenceObject(EnumObject->ThreadObject);

    }

    if (EnumObject->IoWaitEventHandle != NULL) {

        ZwClose(EnumObject->IoWaitEventHandle);
    }

    FREE_POOL(EnumObject);

    return Status;

}


VOID
CloseEnumObject(
    ENUM_HANDLE    Handle
    )

{
    PENUM_OBJECT    EnumObject=Handle;
    ULONG           j;

    KeSetEvent(
        &EnumObject->WaitEvent,
        IO_NO_INCREMENT,
        FALSE
        );


    KeWaitForSingleObject(
        EnumObject->ThreadObject,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );


    ObDereferenceObject(EnumObject->ThreadObject);

    if (EnumObject->IoWaitEventHandle != NULL) {

        ZwClose(EnumObject->IoWaitEventHandle);
    }


    for (j=0; j< MAX_DEVICES; j++) {
        //
        //  if remove it
        //
        if (EnumObject->Devices[j].InUse) {
            //
            //  not enumerated any more since tha parent is going away
            //
            EnumObject->Devices[j].Enumerated=FALSE;

            RemoveDevice(EnumObject,&EnumObject->Devices[j]);
        }
    }


    FREE_POOL(EnumObject);

    return;
}




#define OBJECT_ARRAY_SIZE  (3)

VOID
WorkerThread(
    PVOID    Context
    )

{

    NTSTATUS        Status;
    PENUM_OBJECT    EnumObject=Context;
    BOOLEAN         ExitLoop=FALSE;

    PKEVENT         ObjectArray[OBJECT_ARRAY_SIZE];

    LARGE_INTEGER  DueTime;

    DueTime.QuadPart = -10*1000*10000;


    D_ENUM(DbgPrint("IRENUM: WorkerThread: started\n");)

    KeClearEvent(EnumObject->IoWaitEventObject);

    ObjectArray[0]=&EnumObject->WaitEvent;
    ObjectArray[1]=(PKEVENT)&EnumObject->Timer;
    ObjectArray[2]=EnumObject->IoWaitEventObject;


    KeSetTimer(
        &EnumObject->Timer,
        DueTime,
        NULL
        );

    while (!ExitLoop) {

        Status=KeWaitForMultipleObjects(
            OBJECT_ARRAY_SIZE,
            &ObjectArray[0],
            WaitAny,
            Executive,
            KernelMode,
            FALSE,
            NULL,
            NULL
            );

        switch (Status) {

            case 0:
                //
                //  the event was signaled, time to exit
                //
                ExitLoop=TRUE;
                break;

            case 1:
                //
                //  the timer expired, check for devices
                //
                if (EnumObject->ControlChannel == NULL) {
                    //
                    //  we have not been able to open the control channel yet
                    //
                    Status=IrdaOpenControlChannel(&EnumObject->ControlChannel);

                    if (!NT_SUCCESS(Status)) {

                        EnumObject->ControlChannel=NULL;
                    }
                }

                if (EnumObject->ControlChannel != NULL) {
                    //
                    //  we have the control handle, start the discover request
                    //
                    IrdaLazyDiscoverDevices(
                        EnumObject->ControlChannel,
                        EnumObject->IoWaitEventHandle,
                        &EnumObject->IoStatusBlock,
                        (PDEVICELIST)&EnumObject->DeviceListBuffer[0],
                        sizeof(EnumObject->DeviceListBuffer)
                        );

                } else {

                    KeSetTimer(
                        &EnumObject->Timer,
                        DueTime,
                        NULL
                        );
                }
                break;

            case 2:
                //
                //   the discovery completed
                //
                KeResetEvent(EnumObject->IoWaitEventObject);

                if (EnumObject->IoStatusBlock.Status == STATUS_SUCCESS) {

                    ACQUIRE_PASSIVE_LOCK(&EnumObject->PassiveLock);

                    EnumIrda(EnumObject);

                    RELEASE_PASSIVE_LOCK(&EnumObject->PassiveLock);

                    //
                    //  start another io
                    //
                    IrdaLazyDiscoverDevices(
                        EnumObject->ControlChannel,
                        EnumObject->IoWaitEventHandle,
                        &EnumObject->IoStatusBlock,
                        (PDEVICELIST)&EnumObject->DeviceListBuffer[0],
                        sizeof(EnumObject->DeviceListBuffer)
                        );

                } else {
                    //
                    //  the discovery failed, just start the timer
                    //
                    KeSetTimer(
                        &EnumObject->Timer,
                        DueTime,
                        NULL
                        );
               }


                break;

            default:

                ASSERT(0);
                break;
        }


    }

    KeCancelTimer(&EnumObject->Timer);

    D_ENUM(DbgPrint("IRENUM: WorkerThread: stopping\n");)

    PsTerminateSystemThread(STATUS_SUCCESS);

    return;

}


NTSTATUS
DeviceNameFromDeviceInfo(
    PIRDA_DEVICE_INFO   DeviceInfo,
    PWCHAR              DeviceName,
    ULONG               NameLength
    )

{

    NTSTATUS          Status=STATUS_SUCCESS;
    WCHAR             TempBuffer[23];
    UNICODE_STRING    UnicodeString;

    //
    //  zero out the temp buffer, so we can copy the remote device name,
    //  so we can be sure it is null terminated
    //
    RtlZeroMemory(TempBuffer,sizeof(TempBuffer));

    RtlCopyMemory(TempBuffer,DeviceInfo->irdaDeviceName,sizeof(DeviceInfo->irdaDeviceName));

    UnicodeString.Length=0;
    UnicodeString.MaximumLength=(USHORT)(NameLength-1)*sizeof(WCHAR);
    UnicodeString.Buffer=DeviceName;

    RtlZeroMemory(UnicodeString.Buffer,UnicodeString.MaximumLength);

    if (DeviceInfo->irdaCharSet == LmCharSetUNICODE) {
        //
        //  the name is unicode
        //
        Status=RtlAppendUnicodeToString(&UnicodeString,TempBuffer);

    } else {
        //
        //  the name is ansi, need to convert unicode
        //
        ANSI_STRING    AnsiString;

        RtlInitAnsiString(
            &AnsiString,
            (PCSZ)TempBuffer
            );

        Status=RtlAnsiStringToUnicodeString(
            &UnicodeString,
            &AnsiString,
            FALSE
            );

    }
    return Status;
}


NTSTATUS
EnumIrda(
    PENUM_OBJECT    EnumObject
    )

{
    NTSTATUS   Status;

    PDEVICELIST     pDevList = (PDEVICELIST)&EnumObject->DeviceListBuffer[0] ;
    ULONG           i;
    ULONG           j;
    BOOLEAN         InvalidateDeviceRelations=FALSE;
    PIR_DEVICE      IrDevice;


    D_ENUM(DbgPrint("IRENUM: Found %d devices\n",pDevList->numDevice);)

    for (j=0; j< MAX_DEVICES; j++) {
        //
        //  first mark all the device not present
        //
        if (!EnumObject->Devices[j].Static) {
            //
            //  only non-static device go away
            //
            EnumObject->Devices[j].PresentCount--;
        }
    }

    for (i=0; i < pDevList->numDevice; i++) {

        PIRDA_DEVICE_INFO   DeviceInfo=&pDevList->Device[i];
        ULONG               DeviceId;
        LONG                EmptySlot=-1;

        RtlCopyMemory(&DeviceId, &DeviceInfo->irdaDeviceID[0],4);

        //
        //  now go through all of our slots to see if we have seen this device before
        //  based on the name it reports
        //
        for (j=0; j< MAX_DEVICES; j++) {

            WCHAR    TempBuffer[24];

            if (EnumObject->Devices[j].InUse) {

                DeviceNameFromDeviceInfo(
                        DeviceInfo,
                        TempBuffer,
                        sizeof(TempBuffer)/sizeof(WCHAR)
                        );

                if (0 == wcscmp(TempBuffer, EnumObject->Devices[j].DeviceName)) {
                    //
                    //  Already present
                    //
                    EnumObject->Devices[j].PresentCount=DEVICE_PRESENT_START_VALUE;

                    if (DeviceId != EnumObject->Devices[j].DeviceId) {
                        //
                        //  the device id seems to have changed since we saw it last, just update it
                        //
                        D_ERROR(DbgPrint("IRENUM: Found Dup device %x devices\n",DeviceId);)
                        RtlCopyMemory(&EnumObject->Devices[j].DeviceId,&DeviceInfo->irdaDeviceID[0],4);
                    }

                    break;
                }

            } else {
                //
                //  this slot is empty, remember this for later
                //
                if (EmptySlot == -1) {
                    //
                    // only set it for this first one
                    //
                    EmptySlot=j;
                }
            }
        }

        if ( j < MAX_DEVICES) {
            //
            //  We found a match, skip this one
            //
            continue;
        }

        if (EmptySlot == -1) {
            //
            //  All of the slots are used up
            //
            continue;
        }

        //
        //  at this point we have a new device
        //


        IrDevice=&EnumObject->Devices[EmptySlot];
        //
        //  found a slot for it, zero the info
        //
        RtlZeroMemory(IrDevice,sizeof(*IrDevice));

        EnumObject->DeviceCount++;

        //
        //  inuse now
        //
        IrDevice->InUse=TRUE;

        IrDevice->PresentCount=DEVICE_PRESENT_START_VALUE;

        IrDevice->DeviceId=DeviceId;

        IrDevice->Hint1=DeviceInfo->irdaDeviceHints1;
        IrDevice->Hint2=DeviceInfo->irdaDeviceHints2;

        DeviceNameFromDeviceInfo(
            DeviceInfo,
            IrDevice->DeviceName,
            sizeof(IrDevice->DeviceName)/sizeof(WCHAR)
            );

        D_ENUM(DbgPrint(
                  "IRENUM: Name %ws, device id=%08lx, hint1=%x, hint2=%x\n",
                  IrDevice->DeviceName,
                  IrDevice->DeviceId,
                  IrDevice->Hint1,
                  IrDevice->Hint2
                  );)

        if (DeviceInfo->irdaDeviceHints1 & LM_HB1_Printer) {
            //
            //  the device says it is a printer
            //
            IrDevice->Printer=TRUE;
        }

        if ((DeviceInfo->irdaDeviceHints1 & LM_HB1_Modem) && (DeviceInfo->irdaDeviceHints2 & 4)) {
            //
            //  Device reports that it is a modem that supports ircomm
            //
            IrDevice->Modem=TRUE;
        }



        if (DeviceInfo->irdaDeviceHints1 & LM_HB1_PnP) {
            //
            //  the device says it is pnp aware
            //
            DoIasQueries(
                IrDevice
                );

            if (IrDevice->HardwareId != NULL) {
                //
                //  we were able to query it for a hardware id
                //
                Status=CreatePdo(
                    EnumObject->Fdo,
                    IrDevice
                    );

                if (!NT_SUCCESS(Status)) {
                    //
                    //  We could not create a PDO for the new device
                    //
                    if (IrDevice->Name != NULL) {

                        FREE_POOL(IrDevice->Name);
                    }

                    if (IrDevice->HardwareId != NULL) {

                        FREE_POOL(IrDevice->HardwareId);
                    }

                } else {
                    //
                    //  we created a PDO for a new child device
                    //
                    EnumObject->EnumeratedDevices++;

                    //
                    //  new device
                    //
                    InvalidateDeviceRelations=TRUE;
                }

            } else {
                //
                //  the device did not report a pnp hardware id
                //
                EnumObject->Devices[EmptySlot].Pdo=NULL;
            }

        } else {
            //
            //  the device is not pnp aware, make something up
            //
            if ((DeviceInfo->irdaDeviceHints1 & LM_HB1_Modem) && (DeviceInfo->irdaDeviceHints2 & 4)) {
                //
                //  the hint bits report the device as modem that supports ircomm
                //
                IrDevice->HardwareId=ALLOCATE_PAGED_POOL(sizeof(GENERIC_HARDWARE_ID));

                if (IrDevice->HardwareId != NULL) {

                    wcscpy(IrDevice->HardwareId,GENERIC_HARDWARE_ID);
                }

                IrDevice->Name=ALLOCATE_NONPAGED_POOL((wcslen(IrDevice->DeviceName)+1)*sizeof(WCHAR));

                if (IrDevice->Name != NULL) {

                    wcscpy(IrDevice->Name,IrDevice->DeviceName);

                }

                if (IrDevice->HardwareId != NULL) {
                    //
                    //  we were able to query it for a hardware id
                    //
                    Status=CreatePdo(
                        EnumObject->Fdo,
                        IrDevice
                        );

                    if (!NT_SUCCESS(Status)) {
                        //
                        //  We could not create a PDO for the new device
                        //
                        if (IrDevice->Name != NULL) {

                            FREE_POOL(IrDevice->Name);
                        }

                        if (IrDevice->HardwareId != NULL) {

                            FREE_POOL(IrDevice->HardwareId);
                        }

                    } else {
                        //
                        //  we created a PDO for a new child device
                        //
                        EnumObject->EnumeratedDevices++;

                        //
                        //  new device
                        //
                        InvalidateDeviceRelations=TRUE;
                    }

                }

            } else {
                //
                //  the device does not support pnp and it is not an ircomm device
                //

            }
        }

    }

    for (j=0; j< MAX_DEVICES; j++) {
        //
        //  lets see if anything disappeared
        //
        if (EnumObject->Devices[j].InUse) {
            //
            //  found a slot that is in use
            //
            if (EnumObject->Devices[j].PresentCount == 0) {
                //
                //  but it does not have a device present
                //
                D_ENUM(DbgPrint("IRENUM: Name %ws, no longer present\n",EnumObject->Devices[j].Name);)

                if (EnumObject->Devices[j].Pdo != NULL) {
                    //
                    //  we have enumerated a child for this device
                    //
                    InvalidateDeviceRelations=TRUE;

                } else {
                    //
                    //  This one does not have a child, just zero it out
                    //
                    RtlZeroMemory(&EnumObject->Devices[j],sizeof(EnumObject->Devices[j]));
                    EnumObject->DeviceCount--;
                }
            }
        }
    }


    if (InvalidateDeviceRelations) {
        //
        //  tell the system to check the device relations because a device has appeared or
        //  disappeared
        //
        PFDO_DEVICE_EXTENSION FdoExtension=EnumObject->Fdo->DeviceExtension;

        IoInvalidateDeviceRelations(FdoExtension->Pdo,BusRelations);
    }


    return Status;
}


NTSTATUS
CreatePdo(
    PDEVICE_OBJECT    Fdo,
    PIR_DEVICE        IrDevice
    )

{
    NTSTATUS          Status;

    PDEVICE_OBJECT    NewPdo;

    Status = IoCreateDevice(
                 Fdo->DriverObject,
                 sizeof(PDO_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_BUS_EXTENDER,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &NewPdo
                 );

    if (NT_SUCCESS(Status)) {
        //
        //  got the device
        //
        PPDO_DEVICE_EXTENSION   PdoExtension=NewPdo->DeviceExtension;

        PdoExtension->DoType=DO_TYPE_PDO;

        PdoExtension->ParentFdo=Fdo;

        PdoExtension->DeviceDescription=IrDevice;

        IrDevice->Pdo = NewPdo;

        NewPdo->Flags |= DO_POWER_PAGABLE;

        NewPdo->Flags &= ~DO_DEVICE_INITIALIZING;

    } else {

        D_ENUM(DbgPrint("MODEM: CreateChildPdo: IoCreateDevice() failed %08lx\n",Status);)

    }

    return Status;

}

VOID
FixupDeviceId(
    PWSTR   HardwareId
    )

{
    //
    // munge the hardware id to make sure it is compatable with the os requirements
    //
    while (*HardwareId != L'\0') {

        if ((*HardwareId < L' ') || (*HardwareId > 127) || (*HardwareId == L',')) {

            *HardwareId = L'?';
        }

        HardwareId++;
    }
    return;
}

NTSTATUS
DoIasQueries(
    PIR_DEVICE    IrDevice
    )

{
    NTSTATUS      Status;
    LONG          CompatCount;

    Status=IrdaIASStringQuery(
        IrDevice->DeviceId,
        "PnP",
        "Manufacturer",
        &IrDevice->Manufacturer
        );

    if (NT_SUCCESS(Status)) {

        D_ENUM(DbgPrint("IRENUM: got pnp manufacturer %ws\n",IrDevice->Manufacturer);)
    }

    Status=IrdaIASStringQuery(
        IrDevice->DeviceId,
        "PnP",
        "Name",
        &IrDevice->Name
        );

    if (NT_SUCCESS(Status)) {

        D_ENUM(DbgPrint("IRENUM: got pnp name %ws\n",IrDevice->Name);)
    }

    Status=IrdaIASStringQuery(
        IrDevice->DeviceId,
        "PnP",
        "DeviceID",
        &IrDevice->HardwareId
        );

    if (NT_SUCCESS(Status)) {

        D_ENUM(DbgPrint("IRENUM: got pnp id %ws\n",IrDevice->HardwareId);)

        FixupDeviceId(IrDevice->HardwareId);
    }

    //
    //  check for compat id's
    //
    IrDevice->CompatIdCount=0;

    Status=IrdaIASIntegerQuery(
        IrDevice->DeviceId,
        "PnP",
        "CompCnt",
        &CompatCount
        );

    if (NT_SUCCESS(Status)) {

        LONG   i;

        if ( CompatCount > 16) {

            CompatCount=16;

        } else {

            if ( CompatCount < 0) {

                CompatCount = 0;
            }
        }

        for (i=0; i< CompatCount; i++) {

            CHAR    Attribute[20];

            sprintf(Attribute,"Comp#%02d",i+1);

            Status=IrdaIASStringQuery(
                IrDevice->DeviceId,
                "PnP",
                Attribute,
                &IrDevice->CompatId[IrDevice->CompatIdCount]
                );

            if (NT_SUCCESS(Status)) {

                D_ENUM(DbgPrint("IRENUM: got compat pnp id %ws\n",IrDevice->CompatId[IrDevice->CompatIdCount]);)
                FixupDeviceId(IrDevice->CompatId[IrDevice->CompatIdCount]);

                IrDevice->CompatIdCount++;

            } else {

                D_ERROR(DbgPrint("IRENUM: could not get id for %s\n",Attribute);)
            }
        }
    }

    if (IrDevice->Modem && !IrDevice->Printer) {
        //
        //  It the hint bits say this is a modem and it is not a printer then
        //
        //  Create a standard compat ID for all devices, so we can load a standard driver
        //
        IrDevice->CompatId[IrDevice->CompatIdCount]=ALLOCATE_PAGED_POOL(sizeof(IRENUM_COMPAT_ID));

        if (IrDevice->CompatId[IrDevice->CompatIdCount] != NULL) {

            RtlCopyMemory(IrDevice->CompatId[IrDevice->CompatIdCount],IRENUM_COMPAT_ID,sizeof(IRENUM_COMPAT_ID));
            IrDevice->CompatIdCount++;
        }
    }


    return STATUS_SUCCESS;
}


NTSTATUS
GetDeviceList(
    ENUM_HANDLE    Handle,
    PIRP           Irp
    )

{
    PENUM_OBJECT    EnumObject=Handle;
    NTSTATUS        Status=STATUS_SUCCESS;

    PDEVICE_RELATIONS    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;
    PDEVICE_RELATIONS    NewRelations=NULL;
    ULONG                DeviceCount=EnumObject->DeviceCount;
    ULONG                i;

    ACQUIRE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    if (CurrentRelations != NULL) {
        //
        //  we need to allocate a new relations structure and copy the old one to the new one
        //
        DeviceCount+=CurrentRelations->Count;
    }

    NewRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS)+sizeof(PDEVICE_OBJECT)*DeviceCount);

    if (NewRelations == NULL) {

        Status= STATUS_INSUFFICIENT_RESOURCES;

    } else {

        NewRelations->Count=0;

        if (CurrentRelations != NULL) {

            D_ENUM(DbgPrint("IRENUM: GetDeviceList: %d existing devices\n",CurrentRelations->Count);)

            for (i=0; i < CurrentRelations->Count; i++) {

                NewRelations->Objects[i]=CurrentRelations->Objects[i];
                NewRelations->Count++;
            }

            FREE_POOL(CurrentRelations);
        }


        for (i=0; i < MAX_DEVICES; i++) {

            if ((EnumObject->Devices[i].Pdo != NULL) && (EnumObject->Devices[i].PresentCount > 0)) {

                EnumObject->Devices[i].Enumerated=TRUE;

                D_ENUM(DbgPrint("IRENUM: GetDeviceList: reporting DO %p\n",EnumObject->Devices[i].Pdo);)

                NewRelations->Objects[NewRelations->Count]=EnumObject->Devices[i].Pdo;
                ObReferenceObject(NewRelations->Objects[NewRelations->Count]);
                NewRelations->Count++;

            }  else {
                //
                //  the device is no longer present
                //
                EnumObject->Devices[i].Enumerated=FALSE;
            }
        }

        Irp->IoStatus.Information=(ULONG_PTR)NewRelations;
    }

    RELEASE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    return Status;
}



VOID
RemoveDevice(
    ENUM_HANDLE    Handle,
    PIR_DEVICE     IrDevice
    )

{
    PENUM_OBJECT    EnumObject=Handle;

    ACQUIRE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    if (IrDevice->Enumerated) {
        //
        //  the device is still present
        //
        //  Just leave it alone
        //
    } else {
        //
        //  the parent is not enumerating the device anymore
        //
        PPDO_DEVICE_EXTENSION   PdoDeviceExtension;
        LONG                    i;

        //
        //  clean things up
        //
        if (IrDevice->HardwareId != NULL) {

            FREE_POOL(IrDevice->HardwareId);
        }

        if (IrDevice->Name != NULL) {

            FREE_POOL(IrDevice->Name);
        }

        if (IrDevice->Manufacturer != NULL) {

            FREE_POOL(IrDevice->Manufacturer);
        }

        for (i=0; i< IrDevice->CompatIdCount; i++) {

            if (IrDevice->CompatId[i] != NULL) {

                FREE_POOL(IrDevice->CompatId[i]);
            }
        }

        if (IrDevice->Pdo != NULL) {

            PdoDeviceExtension=IrDevice->Pdo->DeviceExtension;

            PdoDeviceExtension->DoType=DO_TYPE_DEL_PDO;

            IoDeleteDevice(IrDevice->Pdo);

            EnumObject->EnumeratedDevices--;
        }


        RtlZeroMemory(IrDevice,sizeof(*IrDevice));

        EnumObject->DeviceCount--;

    }

    RELEASE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\irenum\initunlo.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"

ULONG  DebugFlags;
ULONG  DebugMemoryTag='nErI';
PVOID            PagedCodeSectionHandle;
UNICODE_STRING   DriverEntryRegPath;

ULONG  EnumStaticDevice=0;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
IrEnumUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
UnHandledDispatch(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );



#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,IrEnumUnload)






NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_NO_SUCH_DEVICE.

--*/

{
    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //
    RTL_QUERY_REGISTRY_TABLE paramTable[4];
    ULONG zero = 0;
    ULONG debugLevel = 0;
    ULONG debugFlags = 0;
    ULONG shouldBreak = 0;


    DriverEntryRegPath.Length=RegistryPath->Length;
    DriverEntryRegPath.MaximumLength=DriverEntryRegPath.Length+sizeof(WCHAR);


    DriverEntryRegPath.Buffer=ALLOCATE_PAGED_POOL(DriverEntryRegPath.MaximumLength);

    if (DriverEntryRegPath.Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(
        DriverEntryRegPath.Buffer,
        RegistryPath->Buffer,
        RegistryPath->Length
        );

    //
    //  NULL terminate the string
    //
    DriverEntryRegPath.Buffer[RegistryPath->Length/sizeof(WCHAR)]=L'\0';

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //

    RtlZeroMemory(
        &paramTable[0],
        sizeof(paramTable)
        );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"BreakOnEntry";
    paramTable[0].EntryContext = &shouldBreak;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"DebugFlags";
    paramTable[1].EntryContext = &debugFlags;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &zero;
    paramTable[1].DefaultLength = sizeof(ULONG);

    paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name = L"EnumStaticDevice";
    paramTable[2].EntryContext = &EnumStaticDevice;
    paramTable[2].DefaultType = REG_DWORD;
    paramTable[2].DefaultData = &zero;
    paramTable[2].DefaultLength = sizeof(ULONG);


    if (!NT_SUCCESS(RtlQueryRegistryValues(
                        RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                        DriverEntryRegPath.Buffer,
                        &paramTable[0],
                        NULL,
                        NULL
                        ))) {

        shouldBreak = 0;

    }


#if DBG
    DebugFlags=debugFlags;
#endif

    if (shouldBreak) {

        DbgBreakPoint();

    }
    //
    //  pnp driver entry point
    //
    DriverObject->DriverExtension->AddDevice = IrEnumAddDevice;

    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverUnload = IrEnumUnload;


    {
        ULONG i;

        for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

            DriverObject->MajorFunction[i]=UnHandledDispatch;
        }
    }


    DriverObject->MajorFunction[IRP_MJ_PNP]   = IrEnumPnP;

    DriverObject->MajorFunction[IRP_MJ_POWER] = IrEnumPower;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = IrEnumWmi;


    D_PNP(DbgPrint("IRENUM: DriverEntry\n");)


    //
    //  lock and unlock here so we can get a handle to the section
    //  so future calls will be faster
    //
    PagedCodeSectionHandle=MmLockPagableCodeSection(IrEnumUnload);
    MmUnlockPagableImageSection(PagedCodeSectionHandle);


    return STATUS_SUCCESS;

}

VOID
IrEnumUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{

    D_PNP(DbgPrint("IRENUM: UnLoad\n");)

    FREE_POOL(DriverEntryRegPath.Buffer);

    return;

}


NTSTATUS
UnHandledDispatch(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{

    NTSTATUS                Status=STATUS_NOT_SUPPORTED;
    PFDO_DEVICE_EXTENSION   DeviceExtension=DeviceObject->DeviceExtension;

    if (DeviceExtension->DoType == DO_TYPE_FDO) {
        //
        //  this irp is for the parent devnode, just send it down the stack
        //
        IoSkipCurrentIrpStackLocation(Irp);
        Status=IoCallDriver(DeviceExtension->LowerDevice, Irp);

    } else {
        //
        //  this irp is for the child PDO, it does not handle this irp
        //  since it is at the bottom of the stack by definition, it can only complete it
        //
#if DBG
        PIO_STACK_LOCATION   IrpSp=IoGetCurrentIrpStackLocation(Irp);

        D_ERROR(DbgPrint("IRENUM: Unhandled irp for PDO:  mj= %x\n",IrpSp->MajorFunction);)
#endif

        Irp->IoStatus.Status=Status;
        Irp->IoStatus.Information=0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\read.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"

VOID
ReadCancelRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );


VOID
MoveDataFromBufferToIrp(
    PFDO_DEVICE_EXTENSION DeviceExtension
    );

VOID
SeeIfIrpShouldBeCompleted(
    PFDO_DEVICE_EXTENSION DeviceExtension
    );


NTSTATUS
IrCommRead(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS                 Status=STATUS_SUCCESS;

    D_TRACE(DbgPrint("IRCOMM: IrCommRead\n");)

    if (DeviceExtension->Removing) {
        //
        //  the device has been removed, no more irps
        //
        Irp->IoStatus.Status=STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }


#if DBG
    {
        PIO_STACK_LOCATION       IrpSp = IoGetCurrentIrpStackLocation(Irp);

        RtlFillMemory(
            Irp->AssociatedIrp.SystemBuffer,
            IrpSp->Parameters.Read.Length,
            0xf1
            );


    }
#endif

    IoMarkIrpPending(Irp);

    Irp->IoStatus.Information=0;

    QueuePacket(&DeviceExtension->Read.Queue,Irp,FALSE);

    return STATUS_PENDING;

}

VOID
ReadStartRoutine(
    PVOID    Context,
    PIRP     Irp
    )

{

    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;
    PIO_STACK_LOCATION       IrpSp = IoGetCurrentIrpStackLocation(Irp);

    KIRQL                    OldIrql;
    KIRQL                    CancelIrql;

    Irp->IoStatus.Information=0;
    Irp->IoStatus.Status=STATUS_TIMEOUT;

    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    ASSERT(!DeviceExtension->Read.TotalTimerSet);
    ASSERT(!DeviceExtension->Read.IntervalTimerSet);

    //
    //  add one refcount for this routine.
    //
    DeviceExtension->Read.IrpRefCount=1;
    DeviceExtension->Read.CurrentIrp=Irp;
    DeviceExtension->Read.IrpShouldBeCompleted=FALSE;
    DeviceExtension->Read.IrpShouldBeCompletedWithAnyData=FALSE;

    IoAcquireCancelSpinLock(&CancelIrql);

    if (Irp->Cancel) {
        //
        //  it has already been canceled, just mark it to complete
        //
        DeviceExtension->Read.IrpShouldBeCompleted=FALSE;
    }

    DeviceExtension->Read.IrpRefCount++;

    IoSetCancelRoutine(Irp,ReadCancelRoutine);

    IoReleaseCancelSpinLock(CancelIrql);

    if ((DeviceExtension->TimeOuts.ReadIntervalTimeout == MAXULONG)
        &&
        (DeviceExtension->TimeOuts.ReadTotalTimeoutMultiplier == 0)
        &&
        (DeviceExtension->TimeOuts.ReadTotalTimeoutConstant == 0)) {
         //
         //  The set of timeouts means that the request should simply return with
         //  whatever data is availible
         //
         DeviceExtension->Read.IrpShouldBeCompleted=TRUE;
         Irp->IoStatus.Status=STATUS_SUCCESS;

    }

    if ((DeviceExtension->TimeOuts.ReadTotalTimeoutMultiplier != 0) || (DeviceExtension->TimeOuts.ReadTotalTimeoutConstant != 0)) {
        //
        //  need a total timeout
        //
        LARGE_INTEGER    DueTime;
        ULONG            TimeoutMultiplier=DeviceExtension->TimeOuts.ReadTotalTimeoutMultiplier;

        if ((TimeoutMultiplier == MAXULONG) && (DeviceExtension->TimeOuts.ReadIntervalTimeout == MAXULONG)) {
            //
            //  this means that the read should complete as soon as any data is read, or the constant timeout
            //  expires.
            //
            DeviceExtension->Read.IrpShouldBeCompletedWithAnyData=TRUE;

            TimeoutMultiplier=0;
        }


        DueTime.QuadPart= ((LONGLONG)(DeviceExtension->TimeOuts.ReadTotalTimeoutConstant +
                           (TimeoutMultiplier * IrpSp->Parameters.Read.Length)))
                           * -10000;

        KeSetTimer(
            &DeviceExtension->Read.TotalTimer,
            DueTime,
            &DeviceExtension->Read.TotalTimerDpc
            );

        DeviceExtension->Read.TotalTimerSet=TRUE;
        DeviceExtension->Read.IrpRefCount++;
    }

    DeviceExtension->Read.IntervalTimeOut=0;

    if ((DeviceExtension->TimeOuts.ReadIntervalTimeout != 0) && (DeviceExtension->TimeOuts.ReadIntervalTimeout != MAXULONG)) {
        //
        //  capture the interval timer we will use for this irp
        //
        DeviceExtension->Read.IntervalTimeOut=DeviceExtension->TimeOuts.ReadIntervalTimeout;
    }

    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );



    MoveDataFromBufferToIrp(
        DeviceExtension
        );


    SeeIfIrpShouldBeCompleted(
        DeviceExtension
        );


    return;
}

BOOLEAN
CopyMemoryAndCheckForChar(
    PUCHAR    Destination,
    PUCHAR    Source,
    ULONG     Length,
    UCHAR     CharacterToCheck
    )

{
    PUCHAR    EndPoint=Destination+Length;
    BOOLEAN   ReturnValue=FALSE;

    while (Destination < EndPoint) {

        *Destination = *Source;

        if (*Destination == CharacterToCheck) {

//            DbgPrint("Got event char\n");
            ReturnValue=TRUE;
        }

        Destination++;
        Source++;
    }

    return ReturnValue;
}


NTSTATUS
DataAvailibleHandler(
    PVOID    Context,
    PUCHAR   Buffer,
    ULONG    BytesAvailible,
    PULONG   BytesUsed
    )

{

    PFDO_DEVICE_EXTENSION    DeviceExtension=(PFDO_DEVICE_EXTENSION)Context;
    ULONG                    BytesToCopy;
    ULONG                    BytesToCopyInFirstPass;
    BOOLEAN                  FoundEventCharacter;
    BOOLEAN                  FoundEventCharacter2=FALSE;
    BOOLEAN                  EightyPercentFull=FALSE;


    KIRQL     OldIrql;

    *BytesUsed = 0;

    ASSERT(BytesAvailible <= INPUT_BUFFER_SIZE);

    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    //
    //  find out how many bytes can be copied
    //
    BytesToCopy = min(BytesAvailible , INPUT_BUFFER_SIZE - DeviceExtension->Read.BytesInBuffer);

    if (BytesToCopy < BytesAvailible) {

        if (DeviceExtension->Read.DtrState) {
            //
            //  only take the whole packet, so we don't have to worry about how to figure out if
            //  the ircomm control info in on the front of the buffer
            //
            DeviceExtension->Read.RefusedDataIndication=TRUE;

            D_TRACE1(DbgPrint("IRCOMM: data refused\n");)

            KeReleaseSpinLock(
                &DeviceExtension->Read.ReadLock,
                OldIrql
                );

            *BytesUsed=0;
            return STATUS_DATA_NOT_ACCEPTED;

        } else {
            //
            //  dtr is low, just throw the data away as we are probably trying to hangup
            //
            D_TRACE1(DbgPrint("IRCOMM: overflow data thrown away because dtr low - %d\n",BytesAvailible);)

            KeReleaseSpinLock(
                &DeviceExtension->Read.ReadLock,
                OldIrql
                );

            *BytesUsed=BytesAvailible;
            return STATUS_SUCCESS;


        }
    }

    //
    //  see how much more is left before we wrap the buffer
    //
    BytesToCopyInFirstPass= (ULONG)(&DeviceExtension->Read.InputBuffer[INPUT_BUFFER_SIZE] - DeviceExtension->Read.NextEmptyByte);

    //
    //  only can copy as many as are actually availible
    //
    BytesToCopyInFirstPass= min( BytesToCopy , BytesToCopyInFirstPass );

    FoundEventCharacter=CopyMemoryAndCheckForChar(
        DeviceExtension->Read.NextEmptyByte,
        Buffer,
        BytesToCopyInFirstPass,
        DeviceExtension->SerialChars.EventChar
        );

    DeviceExtension->Read.NextEmptyByte += BytesToCopyInFirstPass;
    *BytesUsed += BytesToCopyInFirstPass;
    DeviceExtension->Read.BytesInBuffer += BytesToCopyInFirstPass;

    if (BytesToCopyInFirstPass < BytesToCopy) {
        //
        //  must have wrapped, copy the rest
        //
        ULONG   BytesToCopyInSecondPass=BytesToCopy-BytesToCopyInFirstPass;

        ASSERT(DeviceExtension->Read.NextEmptyByte == &DeviceExtension->Read.InputBuffer[INPUT_BUFFER_SIZE]);

        //
        //  back to the beggining
        //
        DeviceExtension->Read.NextEmptyByte=&DeviceExtension->Read.InputBuffer[0];

        FoundEventCharacter2 =CopyMemoryAndCheckForChar(
            DeviceExtension->Read.NextEmptyByte,
            Buffer+BytesToCopyInFirstPass,
            BytesToCopyInSecondPass,
            DeviceExtension->SerialChars.EventChar
            );

        DeviceExtension->Read.NextEmptyByte += BytesToCopyInSecondPass;
        *BytesUsed += BytesToCopyInSecondPass;
        DeviceExtension->Read.BytesInBuffer += BytesToCopyInSecondPass;
    }

    if (DeviceExtension->Read.CurrentIrp != NULL) {
        //
        //  there is currently a read irp, Check to see if we should set an interval timeout
        //
        if (DeviceExtension->Read.IntervalTimerSet) {
            //
            //  the time is already set, cancel it first
            //
            BOOLEAN Canceled;

            Canceled=KeCancelTimer(
                &DeviceExtension->Read.IntervalTimer
                );

            if (Canceled) {
                //
                //  the timer had not fired yet, reset these since they will be changed below
                //
                DeviceExtension->Read.IntervalTimerSet=FALSE;
                DeviceExtension->Read.IrpRefCount--;

            } else {
                //
                //  the time has already expired. it will complete the current irp
                //
            }
        }

        //
        //  either this is the first time we are setting the timer, or we tried to
        //  cancel a previous version of it. If we did cancel it this is the same as
        //  it not being set. If it was set before and we did not cancel it, then we
        //  won't set a new one since the timer DPC is queued to run and will complete
        //  the irp
        //
        if ((DeviceExtension->Read.IntervalTimeOut != 0) && !DeviceExtension->Read.IntervalTimerSet) {
            //
            //  we need an interval timer
            //
            LARGE_INTEGER    DueTime;

            DueTime.QuadPart= (LONGLONG)DeviceExtension->Read.IntervalTimeOut * -10000;

            KeSetTimer(
                &DeviceExtension->Read.IntervalTimer,
                DueTime,
                &DeviceExtension->Read.IntervalTimerDpc
                );

            DeviceExtension->Read.IntervalTimerSet=TRUE;
            DeviceExtension->Read.IrpRefCount++;

        }
    }

    EightyPercentFull= DeviceExtension->Read.BytesInBuffer > (INPUT_BUFFER_SIZE * 8)/10;

    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );

    //
    //  try to move the buffered data to a read irp
    //
    MoveDataFromBufferToIrp(
        DeviceExtension
        );

    SeeIfIrpShouldBeCompleted(
        DeviceExtension
        );

    EventNotification(
        DeviceExtension,
        SERIAL_EV_RXCHAR |
        ((FoundEventCharacter || FoundEventCharacter) ? SERIAL_EV_RXFLAG : 0) |
        ((EightyPercentFull) ? SERIAL_EV_RX80FULL : 0)
        );

    ASSERT(*BytesUsed == BytesAvailible);


    return STATUS_SUCCESS;

}
#if 0
VOID
DebugCopyMemory(
    PUCHAR    Destination,
    PUCHAR    Source,
    ULONG     Length
    )

{
    PUCHAR    EndPoint=Destination+Length;

    while (Destination < EndPoint) {

        *Destination = *Source;

        if ((*Source == 0xe1) || (*Source == 0xe2)) {

            DbgPrint("IRCOMM: bad data at %p\n",Source);
            DbgBreakPoint();
        }

        Destination++;
        Source++;
    }

    return;
}
#endif


VOID
MoveDataFromBufferToIrp(
    PFDO_DEVICE_EXTENSION DeviceExtension
    )

{

    KIRQL     OldIrql;
    BOOLEAN   RequestDataIndications=FALSE;

    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    if (DeviceExtension->Read.CurrentIrp != NULL) {

        PIRP                     Irp   = DeviceExtension->Read.CurrentIrp;
        PIO_STACK_LOCATION       IrpSp = IoGetCurrentIrpStackLocation(Irp);

        ULONG                    TotalBytesToCopy;
        ULONG                    BytesToCopyInFirstPass;
        ULONG                    BytesToCopyInSecondPass;
        ULONG                    BytesToEndOfBuffer;

        //
        //  find the max number of bytes that can be copied
        //
        TotalBytesToCopy = min(DeviceExtension->Read.BytesInBuffer , IrpSp->Parameters.Read.Length - (ULONG)Irp->IoStatus.Information );

        //
        //  Find out how many bytes are between the first filled byte and the end of the buffer
        //
        BytesToEndOfBuffer= (ULONG)(&DeviceExtension->Read.InputBuffer[INPUT_BUFFER_SIZE] - DeviceExtension->Read.NextFilledByte);

        //
        //  If the buffer wraps, the bytes to the end will be the limiting factor, otherwise
        //  it does not wrap and in that case the total bytes will be the limiting factor
        //
        BytesToCopyInFirstPass= min(TotalBytesToCopy , BytesToEndOfBuffer);


        RtlCopyMemory(
            (PUCHAR)Irp->AssociatedIrp.SystemBuffer + Irp->IoStatus.Information,
            DeviceExtension->Read.NextFilledByte,
            BytesToCopyInFirstPass
            );
#if DBG
        RtlFillMemory(
            DeviceExtension->Read.NextFilledByte,
            BytesToCopyInFirstPass,
            0xe1
            );
#endif

        DeviceExtension->Read.NextFilledByte += BytesToCopyInFirstPass;
        DeviceExtension->Read.BytesInBuffer -= BytesToCopyInFirstPass;
        Irp->IoStatus.Information+= BytesToCopyInFirstPass;

        BytesToCopyInSecondPass= TotalBytesToCopy - BytesToCopyInFirstPass;

        if (BytesToCopyInSecondPass > 0) {

            //
            //  back to the begining of the buffer
            //
            ASSERT( DeviceExtension->Read.NextFilledByte == &DeviceExtension->Read.InputBuffer[INPUT_BUFFER_SIZE]);

            DeviceExtension->Read.NextFilledByte=&DeviceExtension->Read.InputBuffer[0];

            RtlCopyMemory(
                (PUCHAR)Irp->AssociatedIrp.SystemBuffer + Irp->IoStatus.Information,
                DeviceExtension->Read.NextFilledByte,
                BytesToCopyInSecondPass
                );
#if DBG
            RtlFillMemory(
                DeviceExtension->Read.NextFilledByte,
                BytesToCopyInSecondPass,
                0xe2
                );
#endif

            DeviceExtension->Read.NextFilledByte += BytesToCopyInSecondPass;
            DeviceExtension->Read.BytesInBuffer -= BytesToCopyInSecondPass;
            Irp->IoStatus.Information+= BytesToCopyInSecondPass;

        }

        if (Irp->IoStatus.Information == IrpSp->Parameters.Read.Length) {
            //
            //  the irp is full, set status to success
            //
            Irp->IoStatus.Status=STATUS_SUCCESS;

            //
            //  since it is now full, it can complete now
            //
            DeviceExtension->Read.IrpShouldBeCompleted=TRUE;
        }

        if (DeviceExtension->Read.IrpShouldBeCompletedWithAnyData && (Irp->IoStatus.Information > 0)) {
            //
            //  the client wants the irp to complete when any data is present
            //
            Irp->IoStatus.Status=STATUS_SUCCESS;

            //
            //  make complete
            //
            DeviceExtension->Read.IrpShouldBeCompleted=TRUE;
        }

    }

    if ((DeviceExtension->Read.BytesInBuffer == 0) && DeviceExtension->Read.RefusedDataIndication) {
        //
        //  the buffer is empty now and we previous refused some indicated data
        //
        DbgPrint("IRCOMM: requesting data\n");

        DeviceExtension->Read.RefusedDataIndication=FALSE;
        RequestDataIndications=TRUE;
    }

    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );


    if (RequestDataIndications) {

        IndicateReceiveBufferSpaceAvailible(
            DeviceExtension->ConnectionHandle
            );
    }

    return;
}

VOID
ReadCancelRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{

    PFDO_DEVICE_EXTENSION DeviceExtension=DeviceObject->DeviceExtension;
    KIRQL                 OldIrql;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    DeviceExtension->Read.IrpRefCount--;
    DeviceExtension->Read.IrpShouldBeCompleted=TRUE;


    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );


    SeeIfIrpShouldBeCompleted(
        DeviceExtension
        );


    return;

}


VOID
IntervalTimeProc(
    PKDPC    Dpc,
    PVOID    Context,
    PVOID    SystemParam1,
    PVOID    SystemParam2
    )

{

    PFDO_DEVICE_EXTENSION DeviceExtension=Context;
    KIRQL                 OldIrql;
    PIRP                  Irp=NULL;

    D_ERROR(DbgPrint("IRCOMM: Interval timeout expired\n");)

    MoveDataFromBufferToIrp(
        DeviceExtension
        );


    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    ASSERT(DeviceExtension->Read.IntervalTimerSet);

    //
    //  this timer is not set anymore
    //
    DeviceExtension->Read.IntervalTimerSet=FALSE;
    DeviceExtension->Read.IrpRefCount--;
    DeviceExtension->Read.IrpShouldBeCompleted=TRUE;


    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );


    SeeIfIrpShouldBeCompleted(
        DeviceExtension
        );


    return;

}


VOID
TotalTimerProc(
    PKDPC    Dpc,
    PVOID    Context,
    PVOID    SystemParam1,
    PVOID    SystemParam2
    )

{

    PFDO_DEVICE_EXTENSION DeviceExtension=Context;
    KIRQL     OldIrql;

    D_TRACE(DbgPrint("IRCOMM: Total timeout expired\n");)

    MoveDataFromBufferToIrp(
        DeviceExtension
        );


    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    ASSERT(DeviceExtension->Read.TotalTimerSet);

    //
    //  this timer is not set anymore
    //
    DeviceExtension->Read.TotalTimerSet=FALSE;
    DeviceExtension->Read.IrpRefCount--;
    DeviceExtension->Read.IrpShouldBeCompleted=TRUE;

    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );

    SeeIfIrpShouldBeCompleted(
        DeviceExtension
        );

    return;

}

VOID
SeeIfIrpShouldBeCompleted(
    PFDO_DEVICE_EXTENSION DeviceExtension
    )

{
    KIRQL                 OldIrql;
    PIRP                  Irp=NULL;

    KeAcquireSpinLock(
        &DeviceExtension->Read.ReadLock,
        &OldIrql
        );

    if (DeviceExtension->Read.CurrentIrp != NULL) {
        //
        //  There is an irp present
        //
        if (DeviceExtension->Read.IrpShouldBeCompleted) {
            //
            //  either the irp is full, or a timer has expired. We are done with this irp in anycase.
            //
            PVOID     OldCancelRoutine;

            //
            //  try to cancel the timers, since we want to complete the irp now.
            //
            if (DeviceExtension->Read.IntervalTimerSet) {

                BOOLEAN    Canceled;

                Canceled=KeCancelTimer(
                    &DeviceExtension->Read.IntervalTimer
                    );

                if (Canceled) {
                    //
                    //  We ended up canceling the timer
                    //
                    DeviceExtension->Read.IrpRefCount--;
                    DeviceExtension->Read.IntervalTimerSet=FALSE;

                } else {
                    //
                    //  The timer is already running, we will just let it complete
                    //  and do the clean up.
                    //

                }
            }

            if (DeviceExtension->Read.TotalTimerSet) {

                BOOLEAN    Canceled;

                Canceled=KeCancelTimer(
                    &DeviceExtension->Read.TotalTimer
                    );

                if (Canceled) {
                    //
                    //  We ended up canceling the timer
                    //
                    DeviceExtension->Read.IrpRefCount--;
                    DeviceExtension->Read.TotalTimerSet=FALSE;

                } else {
                    //
                    //  The timer is already running, we will just let it complete
                    //  and do the clean up.
                    //

                }
            }

            OldCancelRoutine=IoSetCancelRoutine(DeviceExtension->Read.CurrentIrp,NULL);

            if (OldCancelRoutine != NULL) {
                //
                //  the irp has not been canceled yet, and will not be now
                //
                DeviceExtension->Read.IrpRefCount--;

            } else {
                //
                //  the cancel routine has run and decremented the ref count for us
                //

            }


            ASSERT(DeviceExtension->Read.IrpRefCount > 0);

            if (DeviceExtension->Read.IrpRefCount == 1) {
                //
                //  We can complete the irp now
                //
                ASSERT(!DeviceExtension->Read.TotalTimerSet);
                ASSERT(!DeviceExtension->Read.IntervalTimerSet);
#if DBG
                DeviceExtension->Read.IrpRefCount=0;
#endif
                Irp=DeviceExtension->Read.CurrentIrp;
                DeviceExtension->Read.CurrentIrp=NULL;

                InterlockedExchangeAdd(&DeviceExtension->Read.BytesRead,(LONG)Irp->IoStatus.Information);
            }

        }

    }

    KeReleaseSpinLock(
        &DeviceExtension->Read.ReadLock,
        OldIrql
        );


    if (Irp != NULL) {
        //
        //  we should complete this irp now
        //
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        StartNextPacket(&DeviceExtension->Read.Queue);
    }

    return;
}



VOID
ReadPurge(
    PFDO_DEVICE_EXTENSION DeviceExtension,
    ULONG                 Flags
    )

{

    KIRQL                 OldIrql;
    BOOLEAN               RequestDataIndications=FALSE;

    if (Flags == READ_PURGE_CLEAR_BUFFER) {
        //
        //  the caller wants the buffer cleared
        //
        KeAcquireSpinLock(
            &DeviceExtension->Read.ReadLock,
            &OldIrql
            );

        DeviceExtension->Read.BytesInBuffer=0;
        DeviceExtension->Read.NextFilledByte=&DeviceExtension->Read.InputBuffer[0];
        DeviceExtension->Read.NextEmptyByte=&DeviceExtension->Read.InputBuffer[0];

#if DBG
        RtlFillMemory(
            &DeviceExtension->Read.InputBuffer[0],
            sizeof(DeviceExtension->Read.InputBuffer),
            0xf7
            );
#endif

        if (DeviceExtension->Read.RefusedDataIndication) {
            //
            //  the buffer is empty now and we previous refused some indicated data
            //
            DbgPrint("IRCOMM: requesting data from purge\n");

            DeviceExtension->Read.RefusedDataIndication=FALSE;
            RequestDataIndications=TRUE;
        }

        KeReleaseSpinLock(
            &DeviceExtension->Read.ReadLock,
            OldIrql
            );

    }

    if (Flags == READ_PURGE_ABORT_IRP) {
        //
        //  the caller wants the current irp to complete
        //
        DeviceExtension->Read.IrpShouldBeCompleted=TRUE;

        SeeIfIrpShouldBeCompleted(
            DeviceExtension
            );
    }

    if (RequestDataIndications) {

        IndicateReceiveBufferSpaceAvailible(
            DeviceExtension->ConnectionHandle
            );
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\irenum\pdo.c ===
#include <internal.h>
#define INITGUID
#include <guiddef.h>
#include <wdmguid.h>

#pragma alloc_text(PAGE,IrEnumPdoPnp)
#pragma alloc_text(PAGE,IrEnumPdoPower)
#pragma alloc_text(PAGE,IrEnumPdoWmi)


#define CHILD_DEVICE_TEXT L"IR Communication Device"

#define HARDWARE_ID_PREFIX L"IRENUM\\"

//#define HARDWARE_ID L"IRENUM\\PNP0501"




NTSTATUS
IrEnumPdoPnp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    PPDO_DEVICE_EXTENSION   PdoDeviceExtension=DeviceObject->DeviceExtension;

    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer=NULL;
    ULONG                   length, i, j;
    NTSTATUS                status;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;


    switch (IrpSp->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_QUERY_CAPABILITIES\n");)


        //
        // Get the packet.
        //
        deviceCapabilities=IrpSp->Parameters.DeviceCapabilities.Capabilities;

        //
        // Set the capabilities.
        //

        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

        // We cannot wake the system.
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

        // We have no latencies
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

        // No locking or ejection
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

        // Device can be physically removed.
        // Technically there is no physical device to remove, but this bus
        // driver can yank the PDO from the PlugPlay system, when ever it
        // receives an IOCTL_SERENUM_REMOVE_PORT device control command.
//        deviceCapabilities->Removable = TRUE;

        deviceCapabilities->SurpriseRemovalOK=TRUE;

        if (PdoDeviceExtension->DeviceDescription->Printer) {
            //
            //  there is no server for printers
            //
            deviceCapabilities->RawDeviceOK=TRUE;
        }


        // not Docking device
        deviceCapabilities->DockDevice = FALSE;

//        deviceCapabilities->UniqueID = TRUE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        if (IrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            ULONG    BufferLength=0;

            if (PdoDeviceExtension->DeviceDescription->Name != NULL) {

                BufferLength += wcslen(PdoDeviceExtension->DeviceDescription->Name)*sizeof(WCHAR);
            }

            if (BufferLength > 0) {
                //
                //  we have a name or manufacturer
                //
                buffer=ALLOCATE_PAGED_POOL((BufferLength+sizeof(UNICODE_NULL)+sizeof(L" ")));

                if (buffer != NULL) {

                    buffer[0]=L'\0';

                    if (PdoDeviceExtension->DeviceDescription->Name != NULL) {

                        wcscat(buffer,PdoDeviceExtension->DeviceDescription->Name);
                    }

                    status=STATUS_SUCCESS;

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                //
                //  no pnp info, just make something up
                //
                buffer=ALLOCATE_PAGED_POOL(sizeof(CHILD_DEVICE_TEXT));

                if (buffer != NULL) {

                    RtlCopyMemory(buffer,CHILD_DEVICE_TEXT,sizeof(CHILD_DEVICE_TEXT));

                    status=STATUS_SUCCESS;

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            Irp->IoStatus.Status=status;
            Irp->IoStatus.Information = (ULONG_PTR) buffer;
        }
        break;

    case IRP_MN_QUERY_ID:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_QUERY_ID\n");)

        // Query the IDs of the device

        switch (IrpSp->Parameters.QueryId.IdType) {

            case BusQueryInstanceID: {
                //
                // Build an instance ID.  This is what PnP uses to tell if it has
                // seen this thing before or not.
                //
                ULONG    Length;

                Length=wcslen(PdoDeviceExtension->DeviceDescription->DeviceName)*sizeof(WCHAR);

                buffer = ALLOCATE_PAGED_POOL( Length + sizeof(WCHAR));

                if (buffer) {

                    RtlZeroMemory(buffer, Length + sizeof(WCHAR));

                    RtlCopyMemory (buffer, PdoDeviceExtension->DeviceDescription->DeviceName, Length);
                    status=STATUS_SUCCESS;

                } else {

                    status=STATUS_NO_MEMORY;
                }

                Irp->IoStatus.Status=status;
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;
            }



            case BusQueryDeviceID:
            case BusQueryHardwareIDs: {
                //
                // return a multi WCHAR (null terminated) string (null terminated)
                // array for use in matching hardare ids in inf files;
                //
                //
                //  the device reported and hardware id
                //
                ULONG    Length;

                //
                //  figure out the length, it is multi sz so we need a double null,
                //
                Length=wcslen(PdoDeviceExtension->DeviceDescription->HardwareId)*sizeof(WCHAR) + (sizeof(UNICODE_NULL)*2) + sizeof(HARDWARE_ID_PREFIX);

                buffer = ALLOCATE_PAGED_POOL( Length );

                if (buffer != NULL) {
                    //
                    //  build the hardware is by concatenating irenuum\ with the value retuned by the device
                    //
                    RtlZeroMemory(buffer,Length);

                    if ((IrpSp->Parameters.QueryId.IdType == BusQueryDeviceID) || !PdoDeviceExtension->DeviceDescription->Printer) {
                        //
                        // prepend IRENUM\ for the device ID always and for the HARDWARE id when it isn't a printer
                        //
                        wcscpy(buffer,HARDWARE_ID_PREFIX);
                    }
                    wcscat(buffer,PdoDeviceExtension->DeviceDescription->HardwareId);

                    status=STATUS_SUCCESS;

                } else {

                    status=STATUS_NO_MEMORY;
                }


                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;
            }

            case BusQueryCompatibleIDs: {
                //
                // The generic ids for installation of this pdo.
                //
                ULONG    Length=0;
                LONG     i;

                for (i=0; i< PdoDeviceExtension->DeviceDescription->CompatIdCount; i++) {

                    Length += (wcslen(PdoDeviceExtension->DeviceDescription->CompatId[i])+1)*sizeof(WCHAR)+sizeof(IRENUM_PREFIX);
                }

                Length += sizeof(WCHAR)*2;

                buffer = ALLOCATE_PAGED_POOL(Length);

                if (buffer != NULL) {

                    LONG Index=0;

                    RtlZeroMemory (buffer,  Length);

                    for (i=0; i< PdoDeviceExtension->DeviceDescription->CompatIdCount; i++) {

                        if (!PdoDeviceExtension->DeviceDescription->Printer) {
                            //
                            //  for printers we don't prepend our enumerator name
                            //
                            wcscpy(&buffer[Index],IRENUM_PREFIX);
                        }

                        wcscat(
                            &buffer[Index],
                            PdoDeviceExtension->DeviceDescription->CompatId[i]
                            );

                        //
                        //  figure out where the next string should go
                        //
                        Index += wcslen(&buffer[Index]) +1 ;
                    }

                    status = STATUS_SUCCESS;

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;
            }
            break;

            default:
                //
                //  not supported
                //
                break;

        }
        break;

    case IRP_MN_START_DEVICE: {

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_START_DEVICE\n");)

        if (PdoDeviceExtension->DeviceDescription->Printer) {
            //
            //  Need to set a value in the devices parameters key for printers
            //
            HANDLE    Handle;

            status=IoOpenDeviceRegistryKey(
                DeviceObject,
                PLUGPLAY_REGKEY_DEVICE,
                STANDARD_RIGHTS_READ,
                &Handle
                );

            if (NT_SUCCESS(status)) {

                UNICODE_STRING    KeyName;

                RtlInitUnicodeString(&KeyName,L"PortName");

                ZwSetValueKey(
                    Handle,
                    &KeyName,
                    0,
                    REG_SZ,
                    L"IR",
                    sizeof(L"IR")
                    );


                ZwClose(Handle);
            }

        }

        status = STATUS_SUCCESS;

        break;
    }

    case IRP_MN_QUERY_STOP_DEVICE:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_QUERY_STOP_DEVICE\n");)

        // No reason here why we can't stop the device.
        // If there were a reason we should speak now for answering success
        // here may result in a stop device irp.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_CANCEL_STOP_DEVICE\n");)
        //
        // The stop was canceled.  Whatever state we set, or resources we put
        // on hold in anticipation of the forcoming STOP device IRP should be
        // put back to normal.  Someone, in the long list of concerned parties,
        // has failed the stop device query.
        //
        status = STATUS_SUCCESS;
        break;


    case IRP_MN_STOP_DEVICE:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_STOP_DEVICE\n");)

        // Here we shut down the device.  The opposite of start.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_SURPRISE_REMOVAL\n");)

        status = STATUS_SUCCESS;
        break;


    case IRP_MN_REMOVE_DEVICE: {

            PFDO_DEVICE_EXTENSION   FdoDeviceExtension=PdoDeviceExtension->ParentFdo->DeviceExtension;

            D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_REMOVE_DEVICE: %08lx\n",DeviceObject);)

            RemoveDevice(FdoDeviceExtension->EnumHandle,PdoDeviceExtension->DeviceDescription);

            status=STATUS_SUCCESS;

        }
        break;


    case IRP_MN_QUERY_REMOVE_DEVICE:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_QUERY_REMOVE_DEVICE\n");)

        //
        // Just like Query Stop only now the impending doom is the remove irp
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_CANCEL_REMOVE_DEVICE\n");)
        //
        // Clean up a remove that did not go through, just like cancel STOP.
        //
        status = STATUS_SUCCESS;
        break;



    case IRP_MN_READ_CONFIG:

        D_PNP(DbgPrint("IRENUM: PDO: IRP_MN_READ_CONFIG: Space=%d\n",IrpSp->Parameters.ReadWriteConfig.WhichSpace);)

        switch ( IrpSp->Parameters.ReadWriteConfig.WhichSpace ) {

            case IRENUM_CONFIG_SPACE_INFO:

                if ((IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(IRCOMM_BUS_INFO))) {

                    IRCOMM_BUS_INFO    BusInfo;

                    BusInfo.DeviceAddress= PdoDeviceExtension->DeviceDescription->DeviceId;
                    BusInfo.OutGoingConnection=!PdoDeviceExtension->DeviceDescription->Static;

                    RtlCopyMemory(
                        IrpSp->Parameters.ReadWriteConfig.Buffer,
                        &BusInfo,
                        sizeof(BusInfo)
                        );

                    status = STATUS_SUCCESS;
                    Irp->IoStatus.Information=sizeof(BusInfo);
                    break;

                }
                status=STATUS_BUFFER_TOO_SMALL;
                break;



            default:

                break;
        }
        break;

    case IRP_MN_QUERY_BUS_INFORMATION: {

        PPNP_BUS_INFORMATION   BusInfo;

        BusInfo = ALLOCATE_PAGED_POOL( sizeof(*BusInfo));

        if (BusInfo != NULL) {

            BusInfo->BusTypeGuid = GUID_BUS_TYPE_IRDA;
            BusInfo->LegacyBusType=PNPBus;
            BusInfo->BusNumber=0;

            Irp->IoStatus.Information=(ULONG_PTR)BusInfo;

            status = STATUS_SUCCESS;

        } else {

            status=STATUS_INSUFFICIENT_RESOURCES;

        }
        break;
    }

    case IRP_MN_QUERY_DEVICE_RELATIONS: {

        PDEVICE_RELATIONS    CurrentRelations;

        switch (IrpSp->Parameters.QueryDeviceRelations.Type) {

            case TargetDeviceRelation:

                CurrentRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS));

                if (CurrentRelations != NULL) {

                    ObReferenceObject(DeviceObject);
                    CurrentRelations->Objects[0]=DeviceObject;
                    CurrentRelations->Count=1;

                    Irp->IoStatus.Information=(ULONG_PTR)CurrentRelations;

                    status=STATUS_SUCCESS;

                }  else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                break;

            default:

                break;

        }

        break;
    }

    default:
        //
        //  we aren't handling this irp
        //  just complete it
        //
        break;

    }

    //
    //  the irp has been handled in some way or the other
    //  complete it now
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
IrEnumPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    D_POWER(DbgPrint("IRENUM: PDO: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


NTSTATUS
IrEnumPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    NTSTATUS   Status=Irp->IoStatus.Status;

    D_WMI(DbgPrint("IRENUM: PDO: Wmi\n");)

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\ircomm\util.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"

#define OBJECT_DIRECTORY L"\\DosDevices\\"

#pragma alloc_text(PAGE, WaitForLowerDriverToCompleteIrp)


NTSTATUS
IoCompletionSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{


#if DBG
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    UCHAR    *Pnp="PnP";
    UCHAR    *Power="Power";
    UCHAR    *Create="Create";
    UCHAR    *Close="Close";
    UCHAR    *Other="Other";


    PUCHAR   IrpType;

    switch(irpSp->MajorFunction) {

        case IRP_MJ_PNP:

            IrpType=Pnp;
            break;

        case IRP_MJ_CREATE:

            IrpType=Create;
            break;

        case IRP_MJ_CLOSE:

            IrpType=Close;
            break;

        default:

            IrpType=Other;
            break;

    }

    D_PNP(DbgPrint("IRCOMM: Setting event for %s wait, completed with %08lx\n",IrpType,Irp->IoStatus.Status);)
#endif

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    )

{
    NTSTATUS         Status;
    KEVENT           Event;

#if DBG
    PIO_STACK_LOCATION  IrpSp=IoGetCurrentIrpStackLocation(Irp);
#endif

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );


    if (CopyCurrentToNext) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(
                 Irp,
                 IoCompletionSetEvent,
                 &Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         D_TRACE(DbgPrint("IRCOMM: Waiting for PDO\n");)

         KeWaitForSingleObject(
             &Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

#if DBG
    ASSERT(IrpSp == IoGetCurrentIrpStackLocation(Irp));

    RtlZeroMemory(&Event,sizeof(Event));
#endif

    return Irp->IoStatus.Status;

}




#if DBG

NTSTATUS
UnhandledPnpIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    D_PNP(DbgPrint("IRCOMM: Forwarded IRP, MN func=%d, completed with %08lx\n",irpSp->MinorFunction,Irp->IoStatus.Status);)

    return STATUS_SUCCESS;

}

#endif

NTSTATUS
ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    )

{

#if DBG
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(
                         Irp,
                         UnhandledPnpIrpCompletion,
                         NULL,
                         TRUE,
                         TRUE,
                         TRUE
                         );

            IoCallDriver(NextDevice, Irp);

            return STATUS_PENDING;
#else
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(NextDevice, Irp);
#endif

}



NTSTATUS
GetRegistryKeyValue (
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_PARTIAL_INFORMATION     PartialInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    HANDLE                      Handle;

    PAGED_CODE();


    ntStatus = IoOpenDeviceRegistryKey(
        Pdo,
        DevInstKeyType,
        STANDARD_RIGHTS_READ,
        &Handle
        );


    if (NT_SUCCESS(ntStatus)) {

        RtlInitUnicodeString (&keyName, KeyNameString);

        length = sizeof(KEY_VALUE_FULL_INFORMATION) + DataLength;

        PartialInfo = ALLOCATE_PAGED_POOL(length);

        if (PartialInfo) {
            ntStatus = ZwQueryValueKey (Handle,
                                        &keyName,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        length,
                                        &length);

            if (NT_SUCCESS(ntStatus)) {
                //
                // If there is enough room in the data buffer, copy the output
                //

                if (DataLength >= PartialInfo->DataLength) {

                    RtlCopyMemory (Data,
                                   PartialInfo->Data,
                                   PartialInfo->DataLength);
                } else {

                    ntStatus=STATUS_BUFFER_TOO_SMALL;
                }
            } else {

                D_ERROR(DbgPrint("MODEM: could not query value, %08lx\n",ntStatus);)
            }

            FREE_POOL(PartialInfo);
        }

        ZwClose(Handle);

    } else {

        D_ERROR(DbgPrint("MODEM: could open device reg key, %08lx\n",ntStatus);)
    }

    return ntStatus;
}





NTSTATUS
IrCommHandleSymbolicLink(
    PDEVICE_OBJECT      Pdo,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )

{

    UNICODE_STRING     SymbolicLink;
    UNICODE_STRING     PdoName;
    ULONG              StringLength;
    NTSTATUS           Status;

    PdoName.Buffer=NULL;
    SymbolicLink.Buffer=NULL;

    SymbolicLink.Length=0;
    SymbolicLink.MaximumLength=sizeof(WCHAR)*256;

    SymbolicLink.Buffer=ALLOCATE_PAGED_POOL(SymbolicLink.MaximumLength+sizeof(WCHAR));

    if (SymbolicLink.Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }



    RtlZeroMemory(
        SymbolicLink.Buffer,
        SymbolicLink.MaximumLength
        );

    RtlAppendUnicodeToString(
        &SymbolicLink,
        OBJECT_DIRECTORY
        );

    Status=GetRegistryKeyValue(
        Pdo,
        PLUGPLAY_REGKEY_DEVICE,
        L"PortName",
        SymbolicLink.Buffer+(SymbolicLink.Length/sizeof(WCHAR)),
        (ULONG)SymbolicLink.MaximumLength-SymbolicLink.Length
        );

    if (!NT_SUCCESS(Status)) {

        goto Exit;
    }

    SymbolicLink.Length=(USHORT)wcslen(SymbolicLink.Buffer)*sizeof(WCHAR);

    //
    //  Get the PDO name so we can point the symbolic to that
    //


    PdoName.Length=0;
    PdoName.MaximumLength=sizeof(WCHAR)*256;

    PdoName.Buffer=ALLOCATE_PAGED_POOL(PdoName.MaximumLength+sizeof(WCHAR));

    if (PdoName.Buffer == NULL) {

        Status=STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }


    Status=IoGetDeviceProperty(
        Pdo,
        DevicePropertyPhysicalDeviceObjectName,
        (ULONG)PdoName.MaximumLength,
        PdoName.Buffer,
        &StringLength
        );

    if (!NT_SUCCESS(Status)) {

        goto Exit;
    }

    PdoName.Length+=(USHORT)StringLength-sizeof(UNICODE_NULL);

    if (Create) {

        Status=IoCreateSymbolicLink(
            &SymbolicLink,
            &PdoName
            );



        if (!NT_SUCCESS(Status)) {

            D_ERROR(DbgPrint("IRCOMM: IoCreateSymbolicLink() failed %08lx\n",Status);)

        } else {

            Status = RtlWriteRegistryValue(
                RTL_REGISTRY_DEVICEMAP,
                L"SERIALCOMM",
                PdoName.Buffer,
                REG_SZ,
                SymbolicLink.Buffer+((sizeof(OBJECT_DIRECTORY)-sizeof(UNICODE_NULL))/sizeof(WCHAR)),
                SymbolicLink.Length - (sizeof(OBJECT_DIRECTORY) - sizeof(UNICODE_NULL))
                );
        }

        Status=IoRegisterDeviceInterface(
            Pdo,
            &GUID_CLASS_COMPORT,
            NULL,
            InterfaceName
            );


        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

        }  else {

            D_ERROR(DbgPrint("IRCOMM: IoRegisterDeviceInterface() failed %08lx\n",Status);)
        }

    } else {

        if (InterfaceName->Buffer != NULL) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                FALSE
                );

            RtlFreeUnicodeString(
                InterfaceName
                );
        }

        RtlDeleteRegistryValue(
            RTL_REGISTRY_DEVICEMAP,
            L"SERIALCOMM",
            PdoName.Buffer
            );

        Status=IoDeleteSymbolicLink(
            &SymbolicLink
            );

    }

Exit:

    if ( SymbolicLink.Buffer != NULL) {

        FREE_POOL(SymbolicLink.Buffer);
    }

    if (PdoName.Buffer != NULL) {

        FREE_POOL(PdoName.Buffer);
    }

    return Status;

}


NTSTATUS
QueryPdoInformation(
    PDEVICE_OBJECT    Pdo,
    ULONG             InformationType,
    PVOID             Buffer,
    ULONG             BufferLength
    )

{

    PDEVICE_OBJECT       deviceObject=Pdo;
    PIRP                 irp;
    PIO_STACK_LOCATION   irpSp;
    NTSTATUS             Status;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    while (deviceObject->AttachedDevice) {
        deviceObject = deviceObject->AttachedDevice;
    }

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize+1, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    IoSetNextIrpStackLocation(irp);

    irpSp = IoGetCurrentIrpStackLocation(irp);

    irpSp->MajorFunction=IRP_MJ_PNP;
    irpSp->MinorFunction=IRP_MN_READ_CONFIG;
#endif


    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;


    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MajorFunction=IRP_MJ_PNP;
    irpSp->MinorFunction=IRP_MN_READ_CONFIG;
    irpSp->Parameters.ReadWriteConfig.WhichSpace=InformationType;
    irpSp->Parameters.ReadWriteConfig.Offset=0;
    irpSp->Parameters.ReadWriteConfig.Buffer=Buffer;
    irpSp->Parameters.ReadWriteConfig.Length=BufferLength;


    Status=WaitForLowerDriverToCompleteIrp(
        deviceObject,
        irp,
        LEAVE_NEXT_AS_IS
        );


    IoFreeIrp(irp);

    return Status;

}


#if 0
VOID
DumpBuffer(
    PUCHAR    Data,
    ULONG     Length
    )
{
    ULONG     i;

    for (i=0; i<Length; i++) {

        DbgPrint("%02x ",*Data);

        Data++;

        if (((i & 0xf) == 0) && (i != 0)) {

            DbgPrint("\n");
        }
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\irenum\pnp.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"


#pragma alloc_text(PAGE,IrEnumAddDevice)
#pragma alloc_text(PAGE,IrEnumPnP)
#pragma alloc_text(PAGE,IrEnumPower)
#pragma alloc_text(PAGE,IrEnumWmi)

NTSTATUS
IrEnumAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

{
    NTSTATUS       Status;

    PDEVICE_OBJECT Fdo = NULL;

    PDEVICE_OBJECT LowerDevice=NULL;

    //
    // Pointer to the device extension created for this
    // device
    //
    PFDO_DEVICE_EXTENSION DeviceExtension = NULL;

    D_PNP(DbgPrint("IRENUM: AddDevice\n");)

    //
    // Create the device object for this device.
    //

    Status = IoCreateDevice(
                 DriverObject,
                 sizeof(FDO_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_NULL,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &Fdo
                 );

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    LowerDevice=IoAttachDeviceToDeviceStack(
        Fdo,
        Pdo
        );

    if (LowerDevice == NULL) {

        D_ERROR(DbgPrint("IRENUM: Could not attach to PDO\n");)

        Status=STATUS_INSUFFICIENT_RESOURCES;

        goto CleanUp;
    }

    Fdo->Flags |= LowerDevice->Flags;
    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    Fdo->StackSize=LowerDevice->StackSize+1;

    DeviceExtension=Fdo->DeviceExtension;

    DeviceExtension->DoType=DO_TYPE_FDO;

    DeviceExtension->DeviceObject = Fdo;
    DeviceExtension->Pdo=Pdo;
    DeviceExtension->LowerDevice=LowerDevice;

    DeviceExtension->CreateStaticDevice= (EnumStaticDevice != 0) ;

    CreateEnumObject(Fdo,&DeviceExtension->EnumHandle,DeviceExtension->CreateStaticDevice);

    return STATUS_SUCCESS;

CleanUp:

    IoDeleteDevice(Fdo);

    return Status;

}

NTSTATUS
IrEnumPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    ULONG                   i;


    if ((DeviceExtension->DoType==DO_TYPE_PDO) || (DeviceExtension->DoType==DO_TYPE_DEL_PDO)) {
        //
        //  this one is for the child
        //
        return IrEnumPdoPnp(
                   DeviceObject,
                   Irp
                   );
    }

    if (DeviceExtension->DoType != DO_TYPE_FDO) {

        DbgPrint("IRENUM: IrEnumPnp: Bad DevObj\n");

        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );


        return STATUS_SUCCESS;

    }


    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);



        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_QUERY_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_STOP_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;
            PDEVICE_RELATIONS    NewRelations=NULL;

            D_PNP(DbgPrint("IRENUM: IRP_MN_QUERY_DEVICE_RELATIONS type=%d\n",irpSp->Parameters.QueryDeviceRelations.Type);)
            D_PNP(DbgPrint("                                     Information=%p\n",Irp->IoStatus.Information);)


            switch (irpSp->Parameters.QueryDeviceRelations.Type ) {

                case BusRelations: {

                    if (DeviceExtension->EnumHandle != NULL) {

                        status=GetDeviceList(
                            DeviceExtension->EnumHandle,
                            Irp
                            );

                        Irp->IoStatus.Status = status;

                        if (!NT_SUCCESS(status)) {

                            IoCompleteRequest(
                                Irp,
                                IO_NO_INCREMENT
                                );

                            return status;
                        }

                    }

                    return ForwardIrp(DeviceExtension->LowerDevice, Irp);
                }

                case TargetDeviceRelation:
                default: {

                    return ForwardIrp(DeviceExtension->LowerDevice, Irp);
                }
            }

            break;

        }


        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("IRENUM: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        case IRP_MN_SURPRISE_REMOVAL: {

            D_PNP(DbgPrint("IRENUM: IRP_MN_SURPRISE_REMOVAL\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);

        }
        break;


        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;

            D_PNP(DbgPrint("IRENUM: IRP_MN_REMOVE_DEVICE\n");)
            //
            //  removing now for sure
            //
            DeviceExtension->Removing=TRUE;
            DeviceExtension->Removed=TRUE;


            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=IoCallDriver(DeviceExtension->LowerDevice, Irp);

            //
            //  detach from the driver below
            //
            IoDetachDevice(DeviceExtension->LowerDevice);

            DeviceExtension->DoType=DO_TYPE_DEL_FDO;

            if (DeviceExtension->EnumHandle != NULL) {

                CloseEnumObject(DeviceExtension->EnumHandle);
            }

            //
            //  delete our device object
            //
            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("IRENUM: IRP_MN_REMOVE_DEVICE exit, %08lx\n",status);)

            return status;

        }


        default:
            D_PNP(DbgPrint("IRENUM: Sending to PDO PnP IRP, MN func=%d\n",irpSp->MinorFunction);)

            return ForwardIrp(DeviceExtension->LowerDevice, Irp);
    }



    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

NTSTATUS
IrEnumPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;

    if ((DeviceExtension->DoType==DO_TYPE_PDO) || (DeviceExtension->DoType==DO_TYPE_DEL_PDO)) {
        //
        //  this one is for the child
        //
        return IrEnumPdoPower(
                   DeviceObject,
                   Irp
                   );
    }


    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(DeviceExtension->LowerDevice, Irp);

}

NTSTATUS
IrEnumWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PFDO_DEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp=IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                Status;

    if ((DeviceExtension->DoType==DO_TYPE_PDO) || (DeviceExtension->DoType==DO_TYPE_DEL_PDO)) {

        return IrEnumPdoWmi(
                    DeviceObject,
                    Irp
                    );
    }

    if (irpSp->Parameters.WMI.ProviderId == (ULONG_PTR)DeviceObject) {
        //
        //  The irp was targeted at this device, but we don't support wmi
        //
        Status = Irp->IoStatus.Status;

        IoCompleteRequest(Irp,IO_NO_INCREMENT);

    } else {
        //
        //  the irp is targeted at another device object in the stack
        //
        Status=ForwardIrp(DeviceExtension->LowerDevice, Irp);
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\util\tdiutil.c ===
#define UNICODE 1

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>


#define UINT ULONG //tmp
#include <irioctl.h>

#include <ircommtdi.h>
#include <ircommdbg.h>

NTSTATUS
IrdaOpenControlChannel(
    HANDLE     *ControlHandle
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             Iosb;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              DeviceName;    

    RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes, &DeviceName, 
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    
    Status = ZwCreateFile(
                 ControlHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &ObjectAttributes,
                 &Iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,
                 0
                 );

    return Status;

}


NTSTATUS
IrdaDiscoverDevices(
    PDEVICELIST pDevList,
    PULONG       pDevListLen
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             Iosb;
    HANDLE                      ControlHandle;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              DeviceName;    

    RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes, &DeviceName, 
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    
    Status = ZwCreateFile(
                 &ControlHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &ObjectAttributes,
                 &Iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,
                 0
                 );

    Status = ZwDeviceIoControlFile(
                    ControlHandle,
                    NULL,                            // EventHandle
                    NULL,                            // APC Routine
                    NULL,                            // APC Context
                    &Iosb,
                    IOCTL_IRDA_GET_INFO_ENUM_DEV,
                    pDevList,
                    *pDevListLen,
                    pDevList,                            // OutputBuffer
                    *pDevListLen                         // OutputBufferLength
                    );

    if (Status == STATUS_PENDING ) 
    {
        Status = ZwWaitForSingleObject(ControlHandle, TRUE, NULL);
        ASSERT(NT_SUCCESS(Status) );
        Status = Iosb.Status;
    }
    
    ZwClose(ControlHandle);    
    
    
    return Status;
}    


NTSTATUS
IrdaIASStringQuery(
    ULONG   DeviceID,
    PSTR    ClassName,
    PSTR    AttributeName,
    PWSTR  *ReturnString
    )

{

    NTSTATUS            Status;
    IO_STATUS_BLOCK     Iosb;
    HANDLE              AddressHandle;
    IAS_QUERY           IasQuery;

    *ReturnString=NULL;

    Status=IrdaOpenControlChannel(&AddressHandle);


    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("IRCOMM: IrdaCreateAddress() failed %08lx\n",Status);)

        return Status;
    }

    RtlCopyMemory(&IasQuery.irdaDeviceID[0],&DeviceID,sizeof(IasQuery.irdaDeviceID));
    strcpy(IasQuery.irdaClassName,ClassName);
    strcpy(IasQuery.irdaAttribName,AttributeName);

    Status = ZwDeviceIoControlFile(
                    AddressHandle,
                    NULL,                            // EventHandle
                    NULL,                            // APC Routine
                    NULL,                            // APC Context
                    &Iosb,
                    IOCTL_IRDA_QUERY_IAS,
                    &IasQuery,
                    sizeof(IasQuery),
                    &IasQuery,                            // OutputBuffer
                    sizeof(IasQuery)                       // OutputBufferLength
                    );

    if (Status == STATUS_PENDING ) {

        ZwWaitForSingleObject(AddressHandle, TRUE, NULL);
        Status = Iosb.Status;
    }
    
    ZwClose(AddressHandle);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    {
        WCHAR             TempBuffer[IAS_MAX_USER_STRING+1];
        UNICODE_STRING    UnicodeString;

        UnicodeString.Length=0;

        if (IasQuery.irdaAttribute.irdaAttribUsrStr.CharSet == LmCharSetUNICODE) {

            UnicodeString.MaximumLength=(USHORT)(IasQuery.irdaAttribute.irdaAttribUsrStr.Len+2)/sizeof(WCHAR);

        } else {

            UnicodeString.MaximumLength=(USHORT)(IasQuery.irdaAttribute.irdaAttribUsrStr.Len+1)*sizeof(WCHAR);
        }

        UnicodeString.Buffer=ALLOCATE_PAGED_POOL(UnicodeString.MaximumLength);

        if (UnicodeString.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(UnicodeString.Buffer,UnicodeString.MaximumLength);

        //
        //  zero out the temp buffer, so we can copy the remote device name,
        //  so we can be sure it is null terminated
        //
        RtlZeroMemory(TempBuffer,sizeof(TempBuffer));

        RtlCopyMemory(TempBuffer,IasQuery.irdaAttribute.irdaAttribUsrStr.UsrStr,IasQuery.irdaAttribute.irdaAttribUsrStr.Len);

        if (IasQuery.irdaAttribute.irdaAttribUsrStr.CharSet == LmCharSetUNICODE) {
            //
            //  the name is unicode
            //
            Status=RtlAppendUnicodeToString(&UnicodeString,TempBuffer);

        } else {
            //
            //  the name is ansi, need to convert unicode
            //
            ANSI_STRING    AnsiString;

            RtlInitAnsiString(
                &AnsiString,
                (PCSZ)TempBuffer
                );

            Status=RtlAnsiStringToUnicodeString(
                &UnicodeString,
                &AnsiString,
                FALSE
                );

        }

        if (NT_SUCCESS(Status)) {

            *ReturnString=UnicodeString.Buffer;

        } else {

            FREE_POOL(UnicodeString.Buffer);

        }

    }

    return Status;

}

NTSTATUS
IrdaIASIntegerQuery(
    ULONG   DeviceID,
    PSTR    ClassName,
    PSTR    AttributeName,
    LONG   *ReturnValue
    )

{

    NTSTATUS            Status;
    IO_STATUS_BLOCK     Iosb;
    HANDLE              AddressHandle;
    IAS_QUERY           IasQuery;

    *ReturnValue=0;

    Status=IrdaOpenControlChannel(&AddressHandle);


    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("IRCOMM: IrdaCreateAddress() failed %08lx\n",Status);)

        return Status;
    }

    RtlCopyMemory(&IasQuery.irdaDeviceID[0],&DeviceID,sizeof(IasQuery.irdaDeviceID));
    strcpy(IasQuery.irdaClassName,ClassName);
    strcpy(IasQuery.irdaAttribName,AttributeName);

    Status = ZwDeviceIoControlFile(
                    AddressHandle,
                    NULL,                            // EventHandle
                    NULL,                            // APC Routine
                    NULL,                            // APC Context
                    &Iosb,
                    IOCTL_IRDA_QUERY_IAS,
                    &IasQuery,
                    sizeof(IasQuery),
                    &IasQuery,                            // OutputBuffer
                    sizeof(IasQuery)                       // OutputBufferLength
                    );

    if (Status == STATUS_PENDING ) {

        ZwWaitForSingleObject(AddressHandle, TRUE, NULL);
        Status = Iosb.Status;
    }
    
    ZwClose(AddressHandle);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    if (IasQuery.irdaAttribType != IAS_ATTRIB_INT) {

        return STATUS_UNSUCCESSFUL;
    }

    *ReturnValue=IasQuery.irdaAttribute.irdaAttribInt;

    return STATUS_SUCCESS;
}

NTSTATUS
IrdaIASStringSet(
    HANDLE  AddressHandle,
    PSTR    ClassName,
    PSTR    AttributeName,
    PSTR    StringToSet
    )

{

    NTSTATUS            Status;
    IO_STATUS_BLOCK     Iosb;
    IAS_SET             IasSet;


    strcpy(IasSet.irdaClassName,ClassName);
    strcpy(IasSet.irdaAttribName,AttributeName);
    IasSet.irdaAttribType=IAS_ATTRIB_STR;
    IasSet.irdaAttribute.irdaAttribUsrStr.CharSet=LmCharSetASCII;
    IasSet.irdaAttribute.irdaAttribUsrStr.Len=(UCHAR)strlen(StringToSet);
    strcpy(IasSet.irdaAttribute.irdaAttribUsrStr.UsrStr,StringToSet);


    Status = ZwDeviceIoControlFile(
                    AddressHandle,
                    NULL,                            // EventHandle
                    NULL,                            // APC Routine
                    NULL,                            // APC Context
                    &Iosb,
                    IOCTL_IRDA_SET_IAS,
                    &IasSet,
                    sizeof(IasSet),
                    &IasSet,                            // OutputBuffer
                    sizeof(IasSet)                       // OutputBufferLength
                    );

    if (Status == STATUS_PENDING ) {

        ZwWaitForSingleObject(AddressHandle, TRUE, NULL);
        Status = Iosb.Status;
    }

    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("IRENUM:IrdaIASStringSet() failed %08lx\n",Status);)

    }

    return Status;

}



VOID
IrdaLazyDiscoverDevices(
    HANDLE             ControlHandle,
    HANDLE             Event,
    PIO_STATUS_BLOCK   Iosb,
    PDEVICELIST        pDevList,
    ULONG              DevListLen
    )
{

    ZwDeviceIoControlFile(
                    ControlHandle,
                    Event,                           // EventHandle
                    NULL,                            // APC Routine
                    NULL,                            // APC Context
                    Iosb,
                    IOCTL_IRDA_LAZY_DISCOVERY,
                    NULL,
                    0,
                    pDevList,                            // OutputBuffer
                    DevListLen                         // OutputBufferLength
                    );


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\link\link.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    link.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

//#include "internal.h"

#define UNICODE 1

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>


#define UINT ULONG //tmp
#include <irioctl.h>

#include <ircommtdi.h>

#include <ircomm.h>
#include <ircommdbg.h>
#include "buffer.h"
#include <ntddser.h>

#include "link.h"



typedef enum  {
    LINK_IDLE,
    LINK_PRE_CONNECT,
    LINK_ACCEPTED,
    LINK_ACCEPT_FAILED,
    LINK_CONNECTED,
    LINK_DISCONNECTING,
    LINK_CLOSING
    } LINK_STATE ;


typedef struct {

    LONG                  ReferenceCount;
    LINK_STATE            State;

    BUFFER_POOL_HANDLE    SendBufferPool;
    BUFFER_POOL_HANDLE    ControlBufferPool;
    BUFFER_POOL_HANDLE    ReceiveBufferPool;

} CONNECTION_OBJECT; *PCONNECTION_OBJECT;


typedef struct _LINK_OBJECT {

    KSPIN_LOCK      Lock;

    LONG            ReferenceCount;
    KEVENT          CloseEvent;
    BOOLEAN         Closing;

    HANDLE          AddressFileHandle;
    PFILE_OBJECT    AddressFileObject;

    PFILE_OBJECT    ConnectionFileObject;

    PVOID           Context;
    PLINK_RECEIVE   LinkReceiveHandler;
    PLINK_STATE     LinkStateHandler;

    WORK_QUEUE_ITEM WorkItem;

    ULONG           SendBuffers;
    ULONG           ControlBuffers;
    ULONG           ReceiveBuffers;

    CONNECTION_OBJECT     Connection;

} LINK_OBJECT, *PLINK_OBJECT;


VOID
RemoveReferenceFromConnection(
    PLINK_OBJECT      LinkObject
    );


NTSTATUS
GetMaxSendPdu(
    PFILE_OBJECT      FileObject,
    PULONG            MaxPdu
    );


NTSTATUS
ClientEventReceive (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
LinkEventDisconnect(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
LinkEventConnect(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

NTSTATUS
IrdaCompleteAcceptIrp(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    );


NTSTATUS
IrdaSetEventHandler (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

VOID
ConnectionPassiveWorkRoutine(
    PVOID             Context
    );


NTSTATUS
IrdaCreateAddress(
    IN  PTDI_ADDRESS_IRDA pRequestedIrdaAddr,
    OUT PHANDLE           pAddrHandle
    )

{
    NTSTATUS                    Status;
    UNICODE_STRING              DeviceName;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             Iosb;
    UCHAR                       EaBuf[sizeof(FILE_FULL_EA_INFORMATION)-1 +
                                          TDI_TRANSPORT_ADDRESS_LENGTH+1 +
                                          sizeof(TRANSPORT_ADDRESS) +
                                          sizeof(TDI_ADDRESS_IRDA)];
                                            
    PFILE_FULL_EA_INFORMATION   pEa = (PFILE_FULL_EA_INFORMATION) EaBuf;
    ULONG                       EaBufLen = sizeof(EaBuf);
    TRANSPORT_ADDRESS         UNALIGNED * pTranAddr = (PTRANSPORT_ADDRESS)
                                    &(pEa->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1]);
    TDI_ADDRESS_IRDA         UNALIGNED *  pIrdaAddr = (PTDI_ADDRESS_IRDA)
                                    pTranAddr->Address[0].Address;
    
    pEa->NextEntryOffset = 0;
    pEa->Flags = 0;
    pEa->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    
    RtlCopyMemory(pEa->EaName,
                  TdiTransportAddress,
                  pEa->EaNameLength + 1);


    pEa->EaValueLength = sizeof(TRANSPORT_ADDRESS) + sizeof(TDI_ADDRESS_IRDA);
 
    pTranAddr->TAAddressCount = 1;
    pTranAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IRDA);
    pTranAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IRDA;

    RtlCopyMemory(pIrdaAddr,
                  pRequestedIrdaAddr,
                  sizeof(TDI_ADDRESS_IRDA));
    
    RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes, &DeviceName, 
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    
    Status = ZwCreateFile(
                 pAddrHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &ObjectAttributes,
                 &Iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 pEa,
                 EaBufLen);

        
    return Status;
}

NTSTATUS
IrdaCreateConnection(
    OUT PHANDLE pConnHandle,
    IN PVOID ClientContext)
{
    NTSTATUS                    Status;
    UNICODE_STRING              DeviceName;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             Iosb;
    UCHAR                       EaBuf[sizeof(FILE_FULL_EA_INFORMATION)-1 +
                                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                                    sizeof(CONNECTION_CONTEXT)];        
    PFILE_FULL_EA_INFORMATION   pEa = (PFILE_FULL_EA_INFORMATION) EaBuf;
    ULONG                       EaBufLen = sizeof(EaBuf);
    CONNECTION_CONTEXT UNALIGNED *ctx;

    pEa->NextEntryOffset = 0;
    pEa->Flags = 0;
    pEa->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEa->EaValueLength = sizeof(CONNECTION_CONTEXT);    

    RtlCopyMemory(pEa->EaName, TdiConnectionContext, pEa->EaNameLength + 1);
    
    ctx = (CONNECTION_CONTEXT UNALIGNED *)&pEa->EaName[pEa->EaNameLength + 1];
    *ctx = (CONNECTION_CONTEXT) ClientContext;
    
    RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes, &DeviceName, 
                               OBJ_CASE_INSENSITIVE, NULL, NULL);
    

    Status = ZwCreateFile(pConnHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &ObjectAttributes,
                 &Iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 pEa,
                 EaBufLen);

            
    return Status;
}


NTSTATUS
IrdaDisconnect(
    PFILE_OBJECT   ConnectionFileObject
    )
{
    PIRP            pIrp;
    KEVENT          Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS        Status;
     
    
    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

    pIrp = TdiBuildInternalDeviceControlIrp(
            TDI_DISCONNECT,
            IoGetRelatedDeviceObject(ConnectionFileObject),
            ConnectionFileObject,
            &Event,
            &Iosb
            );

    if (pIrp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    TdiBuildDisconnect(
        pIrp,
        IoGetRelatedDeviceObject(ConnectionFileObject),
        ConnectionFileObject,
        NULL,
        NULL,
        NULL,
        TDI_DISCONNECT_ABORT,
        NULL,
        NULL
        );
        
    IoCallDriver(IoGetRelatedDeviceObject(ConnectionFileObject), pIrp);

    KeWaitForSingleObject((PVOID) &Event, Executive, KernelMode,  FALSE, NULL);

    Status = Iosb.Status;
    
    return Status;
}


NTSTATUS
IrdaAssociateAddress(
    PFILE_OBJECT   ConnectionFileObject,
    HANDLE         AddressHandle
    )
{
    PIRP            pIrp;
    KEVENT          Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS        Status;
     
    
    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

    pIrp = TdiBuildInternalDeviceControlIrp(
            TDI_ASSOCIATE_ADDRESS,
            IoGetRelatedDeviceObject(ConnectionFileObject),
            ConnectionFileObject,
            &Event,
            &Iosb);

    if (pIrp == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;
    
    TdiBuildAssociateAddress(
        pIrp,
        IoGetRelatedDeviceObject(ConnectionFileObject),
        ConnectionFileObject,
        NULL,
        NULL,
        AddressHandle);
        
    Status = IoCallDriver(IoGetRelatedDeviceObject(ConnectionFileObject), pIrp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject((PVOID) &Event, Executive, KernelMode,  FALSE, NULL);
    }
    else
    {
        ASSERT(NT_ERROR(Status) || KeReadStateEvent(&Event));
    }
    
    if (NT_SUCCESS(Status))
    {
        Status = Iosb.Status;
    }
    
    return Status;
}


NTSTATUS
IrdaCreateConnectionForAddress(
    HANDLE             AddressFileHandle,
    PVOID              Context,
    PFILE_OBJECT      *ConnectionFileObject
    )
{
    NTSTATUS            Status;
    HANDLE              ConnectionFileHandle;

    *ConnectionFileObject=NULL;

    Status = IrdaCreateConnection(&ConnectionFileHandle, Context);

    if (!NT_SUCCESS(Status)) {

        goto done;
    }
            
    Status = ObReferenceObjectByHandle(
                 ConnectionFileHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 ConnectionFileObject,
                 NULL
                 );


    ZwClose(ConnectionFileHandle);

    if (!NT_SUCCESS(Status)) {

        goto done;
    }  
        
    Status = IrdaAssociateAddress(*ConnectionFileObject, AddressFileHandle);
    
    if (!NT_SUCCESS(Status)) {

        ObDereferenceObject(*ConnectionFileObject);
        *ConnectionFileObject=NULL;
    }                    

done:
    return Status;
}

NTSTATUS
InitiateConnection(
    PFILE_OBJECT    ConnectionFileObject,
    ULONG           DeviceAddress,
    PSTR            ServiceName
    )

{
    UCHAR                       AddrBuf[sizeof(TRANSPORT_ADDRESS) + sizeof(TDI_ADDRESS_IRDA)];
    PTRANSPORT_ADDRESS          pTranAddr = (PTRANSPORT_ADDRESS) AddrBuf;
    PTDI_ADDRESS_IRDA           pIrdaAddr = (PTDI_ADDRESS_IRDA) pTranAddr->Address[0].Address;
    TDI_CONNECTION_INFORMATION  ConnInfo;

    PIRP                        Irp;
    NTSTATUS                    Status;
    KEVENT                      Event;
    IO_STATUS_BLOCK             Iosb;

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );


    Irp = TdiBuildInternalDeviceControlIrp(
            TDI_CONNECT,
            IoGetRelatedDeviceObject(ConnectionFileObject),
            ConnectionFileObject,
            &Event,
            &Iosb
            );

    if (Irp == NULL) {

        D_ERROR(DbgPrint("IRCOMM: TdiBuildInternalDeviceControlIrp Failed\n");)

        Status=STATUS_INSUFFICIENT_RESOURCES;
        goto CleanUp;
    }

    RtlZeroMemory(pIrdaAddr,sizeof(*pIrdaAddr));
    RtlCopyMemory(pIrdaAddr->irdaDeviceID, &DeviceAddress, 4);

    strcpy(pIrdaAddr->irdaServiceName,ServiceName);


    pTranAddr->TAAddressCount = 1;

    ConnInfo.UserDataLength = 0;
    ConnInfo.UserData = NULL;
    ConnInfo.OptionsLength = 0;
    ConnInfo.Options = NULL;
    ConnInfo.RemoteAddressLength = sizeof(AddrBuf);
    ConnInfo.RemoteAddress = pTranAddr;

    TdiBuildConnect(
        Irp,
        IoGetRelatedDeviceObject(ConnectionFileObject),
        ConnectionFileObject,
        NULL,   // CompRoutine
        NULL,   // Context
        NULL,   // Timeout
        &ConnInfo,
        NULL);  // ReturnConnectionInfo

    Status = IoCallDriver(IoGetRelatedDeviceObject(ConnectionFileObject), Irp);

    //
    // If necessary, wait for the I/O to complete.
    //

    D_ERROR(DbgPrint("IRCOMM: status %08lx, %08lx\n",Status,Iosb.Status);)

    KeWaitForSingleObject(
        &Event,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    Status = Iosb.Status;

CleanUp:

    return Status;
}


VOID
RemoveReferenceOnLink(
    PLINK_OBJECT           LinkObject
    )

{

    LONG    Count=InterlockedDecrement(&LinkObject->ReferenceCount);

    if (Count == 0) {

        ASSERT(LinkObject->Closing);

        KeSetEvent(
            &LinkObject->CloseEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }

    return;
}




NTSTATUS
CreateTdiLink(
    ULONG                  DeviceAddress,
    CHAR                  *ServiceName,
    BOOLEAN                OutGoingConnection,
    LINK_HANDLE           *LinkHandle,
    PVOID                  Context,
    PLINK_RECEIVE          LinkReceiveHandler,
    PLINK_STATE            LinkStateHandler,
    ULONG                  SendBuffers,
    ULONG                  ControlBuffers,
    ULONG                  ReceiveBuffers
    )

{

    NTSTATUS               Status;
    PLINK_OBJECT           LinkObject;

    UCHAR                  AddrBuf[sizeof(TRANSPORT_ADDRESS) + sizeof(TDI_ADDRESS_IRDA)];

    PTRANSPORT_ADDRESS     TranAddr = (PTRANSPORT_ADDRESS) AddrBuf;
    PTDI_ADDRESS_IRDA      IrdaAddr = (PTDI_ADDRESS_IRDA) TranAddr->Address[0].Address;



    *LinkHandle=NULL;

    LinkObject=ALLOCATE_NONPAGED_POOL(sizeof(*LinkObject));

    if (LinkObject == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(LinkObject,sizeof(*LinkObject));

    KeInitializeSpinLock(&LinkObject->Lock);

    ExInitializeWorkItem(
        &LinkObject->WorkItem,
        ConnectionPassiveWorkRoutine,
        LinkObject
        );

    LinkObject->ReferenceCount=1;

    KeInitializeEvent(
        &LinkObject->CloseEvent,
        NotificationEvent,
        FALSE
        );

    LinkObject->Connection.State=LINK_IDLE;

    LinkObject->LinkReceiveHandler=LinkReceiveHandler;
    LinkObject->LinkStateHandler=LinkStateHandler;
    LinkObject->Context=Context;

    LinkObject->SendBuffers=SendBuffers;
    LinkObject->ControlBuffers=ControlBuffers;
    LinkObject->ReceiveBuffers=ReceiveBuffers;


    if (OutGoingConnection) {

        IrdaAddr->irdaServiceName[0] = 0; // tells irda.sys addrObj is a client

    } else {

        strcpy(IrdaAddr->irdaServiceName,ServiceName);
    }

    //
    //  open the tdi address and get a handle
    //
    Status=IrdaCreateAddress(
        IrdaAddr,
        &LinkObject->AddressFileHandle
        );

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    //
    //  get the file object the handle refers to
    //
    Status = ObReferenceObjectByHandle(
                 LinkObject->AddressFileHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 (PVOID *)&LinkObject->AddressFileObject,
                 NULL
                 );

    
    if (Status != STATUS_SUCCESS) {

        D_ERROR(DbgPrint("IRCOMM: ObReferenceObjectByHandle Failed %08lx\n",Status);)

        goto CleanUp;
    }

    //
    //  create a connection object and associate it with the address
    //
    Status=IrdaCreateConnectionForAddress(
        LinkObject->AddressFileHandle,
        LinkObject,
        &LinkObject->ConnectionFileObject
        );

    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("IRCOMM: IrdaCreateConnectionForAddress Failed %08lx\n",Status);)

        goto CleanUp;
    }

    IrdaSetEventHandler(
        LinkObject->AddressFileObject,
        TDI_EVENT_RECEIVE,
        ClientEventReceive,
        LinkObject
        );

    IrdaSetEventHandler(
        LinkObject->AddressFileObject,
        TDI_EVENT_DISCONNECT,
        LinkEventDisconnect,
        LinkObject
        );

    //
    //  save this now, since we may get a callbacks for a connection already
    //
    *LinkHandle=LinkObject;

    if (!OutGoingConnection) {
        //
        //  we are going to be waiting for an incoming connection
        //
        IrdaIASStringSet(
            LinkObject->AddressFileHandle,
            "PnP",
            "Name",
            "Windows 2000"
            );

        IrdaIASStringSet(
            LinkObject->AddressFileHandle,
            "PnP",
            "DeviceID",
            "IR_NULL_OUT"
            );

        IrdaSetEventHandler(
            LinkObject->AddressFileObject,
            TDI_EVENT_CONNECT,
            LinkEventConnect,
            LinkObject
            );

        Status=STATUS_SUCCESS;

    } else {
        //
        //  we are creating an outgoing connection
        //
        Status=InitiateConnection(
            LinkObject->ConnectionFileObject,
            DeviceAddress,
            ServiceName
            );

        if (NT_SUCCESS(Status)) {

            KIRQL     OldIrql;

            KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

            //
            //  we a connection begining now
            //
            InterlockedIncrement(&LinkObject->Connection.ReferenceCount);

            //
            //  the connection counts against the link
            //
            InterlockedIncrement(&LinkObject->ReferenceCount);

            LinkObject->Connection.State=LINK_PRE_CONNECT;

            KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

            ExQueueWorkItem(
                &LinkObject->WorkItem,
                DelayedWorkQueue
                );

        } else {
            //
            //  could not create the connection
            //
            *LinkHandle=NULL;

            goto CleanUp;
        }

    }



    return Status;

CleanUp:


    if (LinkObject->ConnectionFileObject != NULL) {

        ObDereferenceObject(LinkObject->ConnectionFileObject);
    }

    if (LinkObject->AddressFileObject != NULL) {

        ObDereferenceObject(LinkObject->AddressFileObject);
    }

    if (LinkObject->AddressFileHandle != NULL) {

        ZwClose(LinkObject->AddressFileHandle);
    }

    FREE_POOL(LinkObject);

    return Status;
}






VOID
CloseTdiLink(
    LINK_HANDLE   LinkHandle
    )

{
    PLINK_OBJECT           LinkObject=LinkHandle;
    KIRQL                  OldIrql;
    BOOLEAN                Release=FALSE;

    LinkObject->Closing=TRUE;

    IrdaSetEventHandler(
        LinkObject->AddressFileObject,
        TDI_EVENT_RECEIVE,
        NULL,
        NULL
        );

    IrdaSetEventHandler(
        LinkObject->AddressFileObject,
        TDI_EVENT_DISCONNECT,
        NULL,
        NULL
        );

    IrdaSetEventHandler(
        LinkObject->AddressFileObject,
        TDI_EVENT_CONNECT,
        NULL,
        NULL
        );



    KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

    switch  (LinkObject->Connection.State) {

        case LINK_IDLE:
        case LINK_DISCONNECTING:
        case LINK_ACCEPT_FAILED:

            break;

        case LINK_CONNECTED:
            //
            //  it is in the connected state, we need to get it cleaned up
            //
            LinkObject->Connection.State=LINK_DISCONNECTING;
            Release=TRUE;

        default:

            break;
    }



    KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

    if (Release) {

        RemoveReferenceFromConnection(LinkObject);
    }


    RemoveReferenceOnLink(LinkObject);

    KeWaitForSingleObject(
        &LinkObject->CloseEvent,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    //  the link should now be inactive
    //
    LinkObject->Connection.State=LINK_CLOSING;

    if (LinkObject->ConnectionFileObject != NULL) {

        ObDereferenceObject(LinkObject->ConnectionFileObject);
    }

    if (LinkObject->AddressFileObject != NULL) {

        ObDereferenceObject(LinkObject->AddressFileObject);
    }

    if (LinkObject->AddressFileHandle != NULL) {

        ZwClose(LinkObject->AddressFileHandle);
    }

    FREE_POOL(LinkObject);

    return;
}


CONNECTION_HANDLE
GetCurrentConnection(
    LINK_HANDLE    LinkHandle
    )

{

    PLINK_OBJECT           LinkObject=LinkHandle;
    CONNECTION_HANDLE      ConnectionHandle=NULL;
    KIRQL                  OldIrql;

    KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

    if (LinkObject->Connection.State == LINK_CONNECTED) {

        InterlockedIncrement(&LinkObject->Connection.ReferenceCount);



        ConnectionHandle=LinkHandle;
    }

    KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

    return ConnectionHandle;
}

VOID
ReleaseConnection(
    CONNECTION_HANDLE    ConnectionHandle
    )

{
    PLINK_OBJECT           LinkObject=ConnectionHandle;

    RemoveReferenceFromConnection(LinkObject);

    return;
}


PFILE_OBJECT
ConnectionGetFileObject(
    CONNECTION_HANDLE   ConnectionHandle
    )
{

    PLINK_OBJECT           LinkObject=ConnectionHandle;
    PFILE_OBJECT           FileObject;

    FileObject=LinkObject->ConnectionFileObject;

    ObReferenceObject(FileObject);

    return FileObject;

}

VOID
ConnectionReleaseFileObject(
    CONNECTION_HANDLE   ConnectionHandle,
    PFILE_OBJECT   FileObject
    )
{

    PLINK_OBJECT           LinkObject=ConnectionHandle;

    ObDereferenceObject(FileObject);

    return;
}

PIRCOMM_BUFFER
ConnectionGetBuffer(
    CONNECTION_HANDLE   ConnectionHandle,
    BUFFER_TYPE         BufferType
    )

{

    PLINK_OBJECT           LinkObject=ConnectionHandle;

    switch (BufferType) {

        case BUFFER_TYPE_SEND:

            return GetBuffer(LinkObject->Connection.SendBufferPool);

        case BUFFER_TYPE_CONTROL:

            return GetBuffer(LinkObject->Connection.ControlBufferPool);

        case BUFFER_TYPE_RECEIVE:

            return GetBuffer(LinkObject->Connection.ReceiveBufferPool);

        default:

            return NULL;
    }

    return NULL;

}



NTSTATUS
IrdaRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    //
    // N.B.  This routine can never be demand paged because it can be
    // called before any endpoints have been placed on the global
    // list--see IrdaAllocateEndpoint() and it's call to
    // IrdaGetTransportInfo().
    //

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return STATUS_SUCCESS;

} // IrdaRestartDeviceControl



NTSTATUS
IrdaIssueDeviceControl (
    IN HANDLE FileHandle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction
    )

/*++

Routine Description:

    Issues a device control returst to a TDI provider and waits for the
    request to complete.

    Note that while FileHandle and FileObject are both marked as optional,
    in reality exactly one of these must be specified.

Arguments:

    FileHandle - a TDI handle.

    FileObject - a pointer to the file object corresponding to a TDI
        handle

    IrpParameters - information to write to the parameters section of the
        stack location of the IRP.

    IrpParametersLength - length of the parameter information.  Cannot be
        greater than 16.

    MdlBuffer - if non-NULL, a buffer of nonpaged pool to be mapped
        into an MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - the size of the buffer pointed to by MdlBuffer.

    MinorFunction - the minor function code for the request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    KEVENT                  event;
    IO_STATUS_BLOCK         ioStatusBlock;
    PDEVICE_OBJECT          deviceObject;
    PMDL                    mdl;

    PAGED_CODE( );

    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    if( FileHandle != NULL ) {

        ASSERT( FileObject == NULL );

        //
        // Get the file object corresponding to the directory's handle.
        // Referencing the file object every time is necessary because the
        // IO completion routine dereferences it.
        //

        status = ObReferenceObjectByHandle(
                     FileHandle,
                     0L,                        // DesiredAccess
                     NULL,                      // ObjectType
                     KernelMode,
                     (PVOID *)&fileObject,
                     NULL
                     );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }

    } else {

        ASSERT( FileObject != NULL );

        //
        // Reference the passed in file object. This is necessary because
        // the IO completion routine dereferences it.
        //

        ObReferenceObject( FileObject );

        fileObject = FileObject;

    }

    //
    // Set the file object event to a non-signaled state.
    //

    (VOID) KeResetEvent( &fileObject->Event );

    //
    // Attempt to allocate and initialize the I/O Request Packet (IRP)
    // for this operation.
    //

    deviceObject = IoGetRelatedDeviceObject ( fileObject );

    irp = IoAllocateIrp( (deviceObject)->StackSize, TRUE );
    if ( irp == NULL ) {
        ObDereferenceObject( fileObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = &event;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

/*
    DEBUG ioStatusBlock.Status = STATUS_UNSUCCESSFUL;
    DEBUG ioStatusBlock.Information = (ULONG)-1;
*/
    //
    // If an MDL buffer was specified, get an MDL, map the buffer,
    // and place the MDL pointer in the IRP.
    //

    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            IoFreeIrp( irp );
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        irp->MdlAddress = NULL;
    }

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Fill in the service-dependent parameters for the request.
    //

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    //
    // Set up a completion routine which we'll use to free the MDL
    // allocated previously.
    //

    IoSetCompletionRoutine( irp, IrdaRestartDeviceControl, NULL, TRUE, TRUE, TRUE );

    //
    // Queue the IRP to the thread and pass it to the driver.
    //

    IoEnqueueIrp( irp );

    status = IoCallDriver( deviceObject, irp );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject( (PVOID)&event, UserRequest, KernelMode,  FALSE, NULL );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    return status;

} // IrdaIssueDeviceControl







NTSTATUS
IrdaSetEventHandler (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )

/*++

Routine Description:

    Sets up a TDI indication handler on a connection or address object
    (depending on the file handle).  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT parameters;

    PAGED_CODE( );

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;

    return IrdaIssueDeviceControl(
               NULL,
               FileObject,
               &parameters,
               sizeof(parameters),
               NULL,
               0,
               TDI_SET_EVENT_HANDLER
               );

} // IrdaSetEventHandler





NTSTATUS
ClientEventReceive (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PLINK_OBJECT        LinkObject=(PLINK_OBJECT)ConnectionContext;
    NTSTATUS            Status;

    if (!LinkObject->Closing) {

        InterlockedIncrement(&LinkObject->ReferenceCount);

        Status= (LinkObject->LinkReceiveHandler)(
                    LinkObject->Context,
                    ReceiveFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket
                    );

        RemoveReferenceOnLink(LinkObject);

    } else {

        Status=STATUS_SUCCESS;
        *BytesTaken=BytesAvailable;
    }

    return Status;

}

NTSTATUS
LinkEventDisconnect(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )

{
    PLINK_OBJECT        LinkObject=(PLINK_OBJECT)ConnectionContext;
    KIRQL               OldIrql;
    BOOLEAN             Release=FALSE;

    if (!LinkObject->Closing) {

        KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

        if (LinkObject->Connection.State == LINK_CONNECTED) {

            LinkObject->Connection.State=LINK_DISCONNECTING;

            Release=TRUE;

        }

        KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

        if (Release) {

            RemoveReferenceFromConnection(LinkObject);
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LinkEventConnect(
    IN PVOID          TdiEventContext,
    IN int            RemoteAddressLength,
    IN PVOID          RemoteAddress,
    IN int            UserDataLength,
    IN PVOID          UserData,
    IN int            OptionsLength,
    IN PVOID          Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP         *AcceptIrp
    )

{
    PLINK_OBJECT      LinkObject=(PLINK_OBJECT)TdiEventContext;
    PIRP              Irp;
    PDEVICE_OBJECT    DeviceObject=IoGetRelatedDeviceObject ( LinkObject->ConnectionFileObject);
    KIRQL             OldIrql;

    Irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize), FALSE);
    
    if ( Irp == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

    if ((LinkObject->Connection.State != LINK_IDLE) || LinkObject->Closing) {

         KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

         IoFreeIrp(Irp);

         return STATUS_CONNECTION_REFUSED;
    }

    LinkObject->Connection.State=LINK_ACCEPTED;

    //
    //  we now have a connection starting, in the refcount
    //
    InterlockedIncrement(&LinkObject->Connection.ReferenceCount);

    //
    //  the connection counts agains the link
    //
    InterlockedIncrement(&LinkObject->ReferenceCount);

    KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

    TdiBuildAccept(
        Irp,
        DeviceObject,
        LinkObject->ConnectionFileObject,
        IrdaCompleteAcceptIrp,
        LinkObject,
        NULL, // request connection information
        NULL  // return connection information
        );
    
    
    IoSetNextIrpStackLocation(Irp);

    //
    // Set the return IRP so the transport processes this accept IRP.
    //

    *AcceptIrp = Irp;

    //
    // Set up the connection context as a pointer to the connection block
    // we're going to use for this connect request.  This allows the
    // TDI provider to which connection object to use.
    //
    
    *ConnectionContext = (CONNECTION_CONTEXT) LinkObject;
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IrdaCompleteAcceptIrp(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    )

{
    PLINK_OBJECT      LinkObject=(PLINK_OBJECT)Context;
    KIRQL             OldIrql;

    KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        LinkObject->Connection.State=LINK_PRE_CONNECT;

        ExQueueWorkItem(
            &LinkObject->WorkItem,
            DelayedWorkQueue
            );

    } else {

        LinkObject->Connection.State=LINK_ACCEPT_FAILED;
    }

    KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        //
        //  no connection anymore
        //
        RemoveReferenceFromConnection(LinkObject);
    }

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}




NTSTATUS
GetMaxSendPdu(
    PFILE_OBJECT      FileObject,
    PULONG            MaxPdu
    )

{

    PIRP              Irp;
    IO_STATUS_BLOCK   IoStatus;
    KEVENT            Event;

    *MaxPdu=50;

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    Irp=IoBuildDeviceIoControlRequest(
        IOCTL_IRDA_GET_SEND_PDU_LEN,
        IoGetRelatedDeviceObject(FileObject),
        NULL,
        0,
        MaxPdu,
        sizeof(*MaxPdu),
        FALSE,
        &Event,
        &IoStatus
        );

    if (Irp != NULL) {

        PIO_STACK_LOCATION   IrpSp=IoGetNextIrpStackLocation(Irp);

        IrpSp->FileObject=FileObject;

        IoCallDriver(
            IoGetRelatedDeviceObject(FileObject),
            Irp
            );

        KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        DbgPrint("IRCOMM: maxsendpdu=%d\n",*MaxPdu);

        return IoStatus.Status;
    }

    return STATUS_INSUFFICIENT_RESOURCES;

}




VOID
ConnectionPassiveWorkRoutine(
    PVOID             Context
    )

{
    PLINK_OBJECT      LinkObject=Context;
    KIRQL             OldIrql;
    ULONG             MaxSendPdu=50;
    BOOLEAN           Connected;

    KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

    switch (LinkObject->Connection.State) {

        case LINK_PRE_CONNECT:

            KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

            GetMaxSendPdu(LinkObject->ConnectionFileObject,&MaxSendPdu);

            LinkObject->Connection.SendBufferPool=CreateBufferPool(
                IoGetRelatedDeviceObject(LinkObject->ConnectionFileObject)->StackSize,
                MaxSendPdu,
                LinkObject->SendBuffers
                );

            LinkObject->Connection.ControlBufferPool=CreateBufferPool(
                IoGetRelatedDeviceObject(LinkObject->ConnectionFileObject)->StackSize,
                MaxSendPdu,
                LinkObject->ControlBuffers
                );

            LinkObject->Connection.ReceiveBufferPool=CreateBufferPool(
                IoGetRelatedDeviceObject(LinkObject->ConnectionFileObject)->StackSize,
                1,
                LinkObject->ReceiveBuffers
                );


            LinkObject->Connection.State=LINK_CONNECTED;

            Connected=TRUE;

            break;

        case LINK_DISCONNECTING:

            Connected=FALSE;

            KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

            IrdaDisconnect(LinkObject->ConnectionFileObject);

            if (LinkObject->Connection.SendBufferPool != NULL) {

                FreeBufferPool(LinkObject->Connection.SendBufferPool);
                LinkObject->Connection.SendBufferPool=NULL;
            }

            if (LinkObject->Connection.ControlBufferPool != NULL) {

                FreeBufferPool(LinkObject->Connection.ControlBufferPool);
                LinkObject->Connection.ControlBufferPool=NULL;
            }


            if (LinkObject->Connection.ReceiveBufferPool != NULL) {

                FreeBufferPool(LinkObject->Connection.ReceiveBufferPool);
                LinkObject->Connection.ReceiveBufferPool=NULL;
            }


            LinkObject->Connection.State=LINK_IDLE;

            break;

        case LINK_ACCEPT_FAILED:

            Connected=FALSE;
            LinkObject->Connection.State=LINK_IDLE;

            KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

            break;


        default:

            ASSERT(0);
            Connected=FALSE;
            KeReleaseSpinLock(&LinkObject->Lock,OldIrql);

            break;


    }

    if (!LinkObject->Closing) {
        //
        //  tell the client about the state change
        //
        InterlockedIncrement(&LinkObject->ReferenceCount);

        (LinkObject->LinkStateHandler)(
                  LinkObject->Context,
                  Connected,
                  MaxSendPdu
                  );
        RemoveReferenceOnLink(LinkObject);
    }

    if (!Connected) {
        //
        //  we have completed the disconnection, remove the reference the connection
        //  has to the link
        //
        RemoveReferenceOnLink(LinkObject);
    }

    return;
}

VOID
RemoveReferenceFromConnection(
    PLINK_OBJECT      LinkObject
    )

{
    KIRQL                  OldIrql;
    LONG                   Count;

    KeAcquireSpinLock(&LinkObject->Lock,&OldIrql);

    Count=InterlockedDecrement(&LinkObject->Connection.ReferenceCount);

    if (Count == 0) {

        ExQueueWorkItem(
            &LinkObject->WorkItem,
            DelayedWorkQueue
            );

    }

    KeReleaseSpinLock(&LinkObject->Lock,OldIrql);


    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\util\debug.c ===
#include <wdm.h>

VOID
DumpBuffer(
    PUCHAR    Data,
    ULONG     Length
    )
{
    ULONG     i;

    for (i=0; i<Length; i++) {

        DbgPrint("%02x ",*Data);

        Data++;

        if (((i & 0xf) == 0) && (i != 0)) {

            DbgPrint("\n");
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\link\internal.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    internal.h

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#define UNICODE 1

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>


#define UINT ULONG //tmp
#include <irioctl.h>

#include <ircommtdi.h>

#include <ircomm.h>
#include <ircommdbg.h>
#include "buffer.h"
#include <ntddser.h>

#include "link.h"

typedef struct _SEND_TRACKER {

    LONG                ReferenceCount;

    PIRP                CurrentWriteIrp;
    LONG                IrpReferenceCount;

    PVOID               CompletionContext;
    CONNECTION_CALLBACK CompletionRoutine;

    LONG                BuffersOutstanding;
    LONG                BytesRemainingInIrp;



    KTIMER              Timer;
    KDPC                TimerDpc;
    BOOLEAN             TimerSet;

    NTSTATUS            LastStatus;

#if DBG
    BOOLEAN             TimerExpired;
    BOOLEAN             IrpCanceled;
#endif
    struct _TDI_CONNECTION *Connection;

} SEND_TRACKER, *PSEND_TRACKER;

typedef struct _SEND_CONTROL {

    PSEND_TRACKER       CurrentSendTracker;

    LONG                ProcessSendEntryCount;

    KSPIN_LOCK          ControlLock;

    WORK_QUEUE_ITEM     WorkItem;
    LONG                WorkItemCount;

    BOOLEAN             OutOfBuffers;

} SEND_CONTROL, *PSEND_CONTROL;

typedef struct _UART_CONTROL {

    PIRP                CurrentIrp;
    PVOID               CompletionContext;
    CONNECTION_CALLBACK CompletionRoutine;

    LONG                DtrState;
    LONG                RtsState;
    ULONG               BaudRate;
    SERIAL_LINE_CONTROL LineControl;

} UART_CONTROL, *PUART_CONTROL;

typedef struct _TDI_CONNECTION {

    LINK_HANDLE       LinkHandle;

    RECEIVE_CALLBACK  ReceiveCallBack;
    PVOID             ReceiveContext;

    EVENT_CALLBACK    EventCallBack;
    PVOID             EventContext;

    ULONG             MaxSendPdu;

    BOOLEAN           LinkUp;

    SEND_CONTROL      Send;

    UART_CONTROL      Uart;

} TDI_CONNECTION, *PTDI_CONNECTION;



VOID
SendWorkItemRountine(
    PVOID    Context
    );

VOID
ProcessSendAtPassive(
    PTDI_CONNECTION          Connection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\irenum\util.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"

#pragma alloc_text(PAGE, WaitForLowerDriverToCompleteIrp)


NTSTATUS
IoCompletionSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{


#if DBG
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    UCHAR    *Pnp="PnP";
    UCHAR    *Power="Power";
    UCHAR    *Create="Create";
    UCHAR    *Close="Close";
    UCHAR    *Other="Other";


    PUCHAR   IrpType;

    switch(irpSp->MajorFunction) {

        case IRP_MJ_PNP:

            IrpType=Pnp;
            break;

        case IRP_MJ_CREATE:

            IrpType=Create;
            break;

        case IRP_MJ_CLOSE:

            IrpType=Close;
            break;

        default:

            IrpType=Other;
            break;

    }

    D_PNP(DbgPrint("IRENUM: Setting event for %s wait, completed with %08lx\n",IrpType,Irp->IoStatus.Status);)
#endif

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    )

{
    NTSTATUS         Status;
    KEVENT           Event;

#if DBG
    PIO_STACK_LOCATION  IrpSp=IoGetCurrentIrpStackLocation(Irp);
#endif

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );


    if (CopyCurrentToNext) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(
                 Irp,
                 IoCompletionSetEvent,
                 &Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         D_ERROR(DbgPrint("IRENUM: Waiting for PDO\n");)

         KeWaitForSingleObject(
             &Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

#if DBG
    ASSERT(IrpSp == IoGetCurrentIrpStackLocation(Irp));

    RtlZeroMemory(&Event,sizeof(Event));
#endif

    return Irp->IoStatus.Status;

}




#if DBG

NTSTATUS
UnhandledPnpIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    D_PNP(DbgPrint("IRENUM: Forwarded IRP, MN func=%d, completed with %08lx\n",irpSp->MinorFunction,Irp->IoStatus.Status);)

    return STATUS_SUCCESS;

}

#endif

NTSTATUS
ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    )

{

#if DBG
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(
                         Irp,
                         UnhandledPnpIrpCompletion,
                         NULL,
                         TRUE,
                         TRUE,
                         TRUE
                         );

            IoCallDriver(NextDevice, Irp);

            return STATUS_PENDING;
#else
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(NextDevice, Irp);
#endif

}


NTSTATUS
GetRegistryKeyValue (
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_PARTIAL_INFORMATION     PartialInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    HANDLE                      Handle;

    PAGED_CODE();


    ntStatus = IoOpenDeviceRegistryKey(
        Pdo,
        DevInstKeyType,
        STANDARD_RIGHTS_READ,
        &Handle
        );


    if (NT_SUCCESS(ntStatus)) {

        RtlInitUnicodeString (&keyName, KeyNameString);

        length = sizeof(KEY_VALUE_FULL_INFORMATION) + DataLength;

        PartialInfo = ALLOCATE_PAGED_POOL(length);

        if (PartialInfo) {
            ntStatus = ZwQueryValueKey (Handle,
                                        &keyName,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        length,
                                        &length);

            if (NT_SUCCESS(ntStatus)) {
                //
                // If there is enough room in the data buffer, copy the output
                //

                if (DataLength >= PartialInfo->DataLength) {

                    RtlCopyMemory (Data,
                                   PartialInfo->Data,
                                   PartialInfo->DataLength);
                } else {

                    ntStatus=STATUS_BUFFER_TOO_SMALL;
                }
            } else {

                D_ERROR(DbgPrint("IRENUM: could not query value, %08lx\n",ntStatus);)
            }

            FREE_POOL(PartialInfo);
        }

        ZwClose(Handle);

    } else {

        D_ERROR(DbgPrint("IRENUM: could open device reg key, %08lx\n",ntStatus);)
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\vuart\control.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"


typedef VOID (*CONTROL_CALLBACK)(
    PVOID       Context,
    NTSTATUS    Status
    );

VOID
SendControlInfo(
    CONNECTION_HANDLE        ConnectionHandle,
    CONTROL_CALLBACK         CompletionRoutine,
    PVOID                    Context,
    UCHAR                    PI,
    UCHAR                    PL,
    UCHAR                   *PV
    );

VOID
UartStateCompletion(
    PVOID       Context,
    NTSTATUS    Status
    );





VOID
AccessUartState(
    IRDA_HANDLE            Handle,
    PIRP                   Irp,
    CONNECTION_CALLBACK    Callback,
    PVOID                  Context
    )

{
    PTDI_CONNECTION          Connection=Handle;
    PIO_STACK_LOCATION       IrpSp=IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                 Status=STATUS_SUCCESS;
    CONNECTION_HANDLE        ConnectionHandle;

    PUCHAR                   SystemBuffer = Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information=0;

    ADD_REFERENCE_TO_CONNECTION(Connection);

    ASSERT(Connection->Uart.CompletionRoutine == NULL);

    Connection->Uart.CurrentIrp=Irp;
    Connection->Uart.CompletionContext=Context;
    Connection->Uart.CompletionRoutine=Callback;

    ConnectionHandle=GetCurrentConnection(Connection->LinkHandle);


    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_SET_RTS:
        case IOCTL_SERIAL_CLR_RTS: {

            LONG        NewState= IrpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_SERIAL_SET_RTS ? 1 : 0;
            LONG        OldState;

            OldState=InterlockedExchange(&Connection->Uart.RtsState,NewState);

            if (NewState != OldState) {
                //
                //  state change
                //

                UCHAR                    ControlBuffer[1];

                ControlBuffer[0] =   PV_DTESetting_Delta_RTS;
                ControlBuffer[0] |=  NewState ? PV_DTESetting_RTS_High : 0;
                ControlBuffer[0] |=  Connection->Uart.DtrState ? PV_DTESetting_DTR_High : 0;

                Status=STATUS_PENDING;

                SendControlInfo(
                    ConnectionHandle,
                    UartStateCompletion,
                    Connection,
                    PI_DTESettings,
                    1,
                    ControlBuffer
                    );

            }

            break;
        }

        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR: {

            LONG                     NewState= IrpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_SERIAL_SET_DTR ? 1 : 0;
            LONG                     OldState;

            OldState=InterlockedExchange(&Connection->Uart.DtrState,NewState);

            if (NewState != OldState) {
                //
                //  state change
                //
                UCHAR                    ControlBuffer[1];

                ControlBuffer[0] =   PV_DTESetting_Delta_DTR;
                ControlBuffer[0] |=  Connection->Uart.RtsState ? PV_DTESetting_RTS_High : 0;

                if (NewState) {

                    ControlBuffer[0] |=  PV_DTESetting_DTR_High;
                }

                Status=STATUS_PENDING;

                SendControlInfo(
                    ConnectionHandle,
                    UartStateCompletion,
                    Connection,
                    PI_DTESettings,
                    1,
                    ControlBuffer
                    );

            }


            break;
        }

        case IOCTL_SERIAL_GET_DTRRTS:

            (*(PULONG)SystemBuffer) =  Connection->Uart.DtrState ? SERIAL_DTR_STATE : 0;
            (*(PULONG)SystemBuffer) |= Connection->Uart.RtsState ? SERIAL_RTS_STATE : 0;

            Irp->IoStatus.Information=sizeof(ULONG);
            Status=STATUS_SUCCESS;
            break;

        case IOCTL_SERIAL_GET_BAUD_RATE:

            (*(PULONG)SystemBuffer) =  Connection->Uart.BaudRate;

            Irp->IoStatus.Information=sizeof(ULONG);
            Status=STATUS_SUCCESS;
            break;


        case IOCTL_SERIAL_SET_BAUD_RATE: {

            ULONG   NewRate=(*(PULONG)SystemBuffer);

            if (NewRate != Connection->Uart.BaudRate) {
                //
                //  rate change
                //
                UCHAR                    ControlBuffer[4];

                Connection->Uart.BaudRate=NewRate;

                ControlBuffer[0]=(UCHAR)( NewRate >> 24);
                ControlBuffer[1]=(UCHAR)( NewRate >> 16);
                ControlBuffer[2]=(UCHAR)( NewRate >>  8);
                ControlBuffer[3]=(UCHAR)( NewRate >>  0);

                Status=STATUS_PENDING;

                SendControlInfo(
                    ConnectionHandle,
                    UartStateCompletion,
                    Connection,
                    PI_DataRate,
                    4,
                    ControlBuffer
                    );

            }
            break;
        }

        case IOCTL_SERIAL_GET_LINE_CONTROL: {

            PSERIAL_LINE_CONTROL    LineControl=(PSERIAL_LINE_CONTROL)SystemBuffer;

            RtlCopyMemory(
                LineControl,
                &Connection->Uart.LineControl,
                sizeof(*LineControl)
                );

            Irp->IoStatus.Information=sizeof(*LineControl);
            Status=STATUS_SUCCESS;
            break;
        }


        case IOCTL_SERIAL_SET_LINE_CONTROL: {

            PSERIAL_LINE_CONTROL    LineControl=(PSERIAL_LINE_CONTROL)SystemBuffer;

            if ((LineControl->StopBits != Connection->Uart.LineControl.StopBits)
                ||
                (LineControl->Parity != Connection->Uart.LineControl.Parity)
                ||
                (LineControl->WordLength != Connection->Uart.LineControl.WordLength)
                ) {

                UCHAR                    ControlBuffer[1];

                RtlCopyMemory(
                    &Connection->Uart.LineControl,
                    LineControl,
                    sizeof(*LineControl)
                    );

                ControlBuffer[0] = (LineControl->WordLength - 5) & 0x03;

                ControlBuffer[0] |= (LineControl->Parity == NO_PARITY) ? PV_DataFormat_No_Parity : PV_DataFormat_Yes_Parity;
                ControlBuffer[0] |= (LineControl->StopBits == STOP_BIT_1) ? PV_DataFormat_1_Stop : PV_DataFormat_2_Stop;

                if (LineControl->Parity != NO_PARITY) {
                    //
                    //  set the parity type
                    //
                    ControlBuffer[0] |= ((LineControl->Parity -1) & 0x03) << 4;
                }

                Status=STATUS_PENDING;

                SendControlInfo(
                    ConnectionHandle,
                    UartStateCompletion,
                    Connection,
                    PI_DataFormat,
                    1,
                    ControlBuffer
                    );
            }
            break;
        }

        case IOCTL_SERIAL_GET_MODEMSTATUS:

            *(PULONG)SystemBuffer=Connection->Uart.ModemStatus;

            Irp->IoStatus.Information=sizeof(ULONG);
            Status=STATUS_SUCCESS;
            break;


        default:

            ASSERT(0);
            Status=STATUS_UNSUCCESSFUL;
            break;
    }

    if (Status != STATUS_PENDING) {

        Irp->IoStatus.Status=Status;

        UartStateCompletion(
            Connection,
            Status
            );

    }

    if (ConnectionHandle != NULL) {

        ReleaseConnection(ConnectionHandle);
    }

    return;
}


VOID
UartStateCompletion(
    PVOID       Context,
    NTSTATUS    Status
    )

{

    PTDI_CONNECTION          Connection = Context;
    CONNECTION_CALLBACK      Callback   = Connection->Uart.CompletionRoutine;
    PVOID                    UartContext= Connection->Uart.CompletionContext;
    PIRP                     Irp        = Connection->Uart.CurrentIrp;

    Connection->Uart.CompletionRoutine=NULL;

    Irp->IoStatus.Status=Status;

    (Callback)(
        UartContext,
        Irp
        );

    REMOVE_REFERENCE_TO_CONNECTION(Connection);

    return;

}


NTSTATUS
SendControlIrpCompletionRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              BufferIrp,
    PVOID             Context
    )

{
    PIRCOMM_BUFFER           Buffer=Context;
    CONTROL_CALLBACK         CompletionRoutine=Buffer->Context2;
    PVOID                    CompletionContext=Buffer->Context;
    NTSTATUS                 Status=BufferIrp->IoStatus.Status;

    D_TRACE(DbgPrint("IRCOMM: ControlCompletionRoutine\n");)


    Buffer->FreeBuffer(Buffer);

    (CompletionRoutine)(
        CompletionContext,
        Status
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}




VOID
SendControlInfo(
    CONNECTION_HANDLE        ConnectionHandle,
    CONTROL_CALLBACK         CompletionRoutine,
    PVOID                    Context,
    UCHAR                    PI,
    UCHAR                    PL,
    UCHAR                   *PV
    )

{
    PFILE_OBJECT             FileObject;
    PUCHAR                   Current;
    PIRCOMM_BUFFER           Buffer;

    D_TRACE(
        DbgPrint("IRCOMM: send Control, PI=%x, PL=%d, PV= ",PI,PL);

        DumpBuffer(PV,PL);
        DbgPrint("\n");
    )


    if (ConnectionHandle == NULL) {
        //
        //  link down
        //
        (*CompletionRoutine)(
            Context,
            STATUS_SUCCESS
            );

        return;
    }

    Buffer=ConnectionGetBuffer(ConnectionHandle,BUFFER_TYPE_CONTROL);

    if (Buffer == NULL) {

        (*CompletionRoutine)(
            Context,
            STATUS_INSUFFICIENT_RESOURCES
            );

        return;
    }

    FileObject=ConnectionGetFileObject(ConnectionHandle);
    //
    //  actual data starts one byte in, after the length byte
    //
    Current=&Buffer->Data[1];


    *Current=PI;
    *(Current+1)=PL;

    RtlCopyMemory(
        Current+2,
        &PV[0],
        PL
        );

    //
    //  set the length of the control data, 2 bytes for PI and PL plus the length of PV
    //
    Buffer->Data[0]=2+PL;

    //
    //  Length of the control data plus 1 for the length
    //
    Buffer->Mdl->ByteCount = Buffer->Data[0] + 1;

    Buffer->Context  = Context;
    Buffer->Context2 = CompletionRoutine;

    {
        PDEVICE_OBJECT     IrdaDeviceObject=IoGetRelatedDeviceObject(FileObject);
        ULONG              SendLength;

        IoReuseIrp(Buffer->Irp,STATUS_SUCCESS);

        Buffer->Irp->Tail.Overlay.OriginalFileObject = FileObject;

        SendLength = MmGetMdlByteCount(Buffer->Mdl);

        TdiBuildSend(
            Buffer->Irp,
            IrdaDeviceObject,
            FileObject,
            SendControlIrpCompletionRoutine,
            Buffer,
            Buffer->Mdl,
            0, // send flags
            SendLength
            );

        IoCallDriver(IrdaDeviceObject, Buffer->Irp);
    }

    ConnectionReleaseFileObject(ConnectionHandle,FileObject);

    return;
}

typedef struct _SYNC_COMPLETION_BLOCK {

    KEVENT    Event;
    NTSTATUS  Status;

} SYNC_COMPLETION_BLOCK, *PSYNC_COMPLETION_BLOCK;

VOID
SetEventCompletion(
    PVOID             Context,
    NTSTATUS          Status
    )

{
    PSYNC_COMPLETION_BLOCK   CompletionBlock=Context;

    D_TRACE(DbgPrint("IRCOMM: SetEventCompletionRoutine\n");)

    CompletionBlock->Status=Status;
    KeSetEvent(&CompletionBlock->Event,IO_NO_INCREMENT,FALSE);

    return;


}


NTSTATUS
SendSynchronousControlInfo(
    CONNECTION_HANDLE        ConnectionHandle,
    UCHAR               PI,
    UCHAR               PL,
    UCHAR              *PV
    )

{
    SYNC_COMPLETION_BLOCK   CompletionBlock;


    KeInitializeEvent(
        &CompletionBlock.Event,
        NotificationEvent,
        FALSE
        );

    SendControlInfo(
        ConnectionHandle,
        SetEventCompletion,
        &CompletionBlock,
        PI,
        PL,
        PV
        );


    KeWaitForSingleObject(
        &CompletionBlock.Event,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );


    return CompletionBlock.Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\util\buffer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include <ntddk.h>
#include <buffer.h>
#include <ircommdbg.h>


typedef  struct _BUFFER_POOL {

    KSPIN_LOCK     SpinLock;
    SLIST_HEADER   ListHead;
    LONG           ReferenceCount;

#if DBG
    LONG                  TotalBuffers;
    LONG                  BufferInUse;
    BOOLEAN               Freed;
#endif


} BUFFER_POOL, *PBUFFER_POOL;


VOID
FreeBuffer(
    PIRCOMM_BUFFER        Buffer
    );


VOID
RemoveReferenceOnBufferPool(
    PBUFFER_POOL   BufferPool
    )

{

    LONG    Count=InterlockedDecrement(&BufferPool->ReferenceCount);

    if (Count == 0) {

        PSINGLE_LIST_ENTRY    ListEntry;

        ASSERT(BufferPool->Freed);

        ListEntry=ExInterlockedPopEntrySList(
            &BufferPool->ListHead,
            &BufferPool->SpinLock
            );


        while (ListEntry != NULL) {

            PIRCOMM_BUFFER  Buffer=CONTAINING_RECORD(ListEntry,IRCOMM_BUFFER,ListEntry);

            IoFreeIrp(Buffer->Irp);

            IoFreeMdl(Buffer->Mdl);

            FREE_POOL(Buffer);

            ListEntry=ExInterlockedPopEntrySList(
                &BufferPool->ListHead,
                &BufferPool->SpinLock
                );

        }

        FREE_POOL(BufferPool);
    }

    return;
}


BUFFER_POOL_HANDLE
CreateBufferPool(
    ULONG      StackDepth,
    ULONG      BufferSize,
    ULONG      BufferCount
    )

{
    PBUFFER_POOL   BufferPool;
    ULONG          i;


    BufferPool=ALLOCATE_NONPAGED_POOL(sizeof(*BufferPool));

    if (BufferPool == NULL) {

        return NULL;
    }

    BufferPool->ReferenceCount=1;
#if DBG
    BufferPool->BufferInUse=0;
    BufferPool->TotalBuffers=BufferCount;
    BufferPool->Freed=FALSE;
#endif

    KeInitializeSpinLock(
        &BufferPool->SpinLock
        );

    ExInitializeSListHead(
        &BufferPool->ListHead
        );


    for (i=0; i<BufferCount; i++) {

        PIRCOMM_BUFFER   Buffer;

        Buffer=ALLOCATE_NONPAGED_POOL(FIELD_OFFSET(IRCOMM_BUFFER,Data[0])+BufferSize);

        if (Buffer == NULL) {

            goto CleanUp;
        }

        Buffer->BufferLength=BufferSize;
#if !DBG
        Buffer->FreeBuffer=FreeBuffer;
#endif
        Buffer->BufferPool=BufferPool;

        Buffer->Irp=IoAllocateIrp((CCHAR)StackDepth,FALSE);

        if (Buffer->Irp == NULL) {

           FREE_POOL(Buffer);

           goto CleanUp;
       }

        Buffer->Mdl=IoAllocateMdl(
            &Buffer->Data[0],
            BufferSize,
            FALSE,       // primary
            FALSE,        // chage quota
            NULL
            );

       if (Buffer->Mdl == NULL) {

           IoFreeIrp(Buffer->Irp);

           FREE_POOL(Buffer);

           goto CleanUp;
       }

       MmBuildMdlForNonPagedPool(
           Buffer->Mdl
           );

       ExInterlockedPushEntrySList(
           &BufferPool->ListHead,
           &Buffer->ListEntry,
           &BufferPool->SpinLock
           );


    }

    return BufferPool;

CleanUp:

    FreeBufferPool(BufferPool);

    return NULL;

}



VOID
FreeBufferPool(
    BUFFER_POOL_HANDLE    Handle
    )

{
    PBUFFER_POOL          BufferPool=Handle;

#if DBG
    BufferPool->Freed=TRUE;
#endif

    RemoveReferenceOnBufferPool(BufferPool);

    return;

}



PIRCOMM_BUFFER
GetBuffer(
    BUFFER_POOL_HANDLE    Handle
    )

{

    PBUFFER_POOL          BufferPool=Handle;
    PSINGLE_LIST_ENTRY    ListEntry;

    InterlockedIncrement(&BufferPool->ReferenceCount);

    ListEntry=ExInterlockedPopEntrySList(
        &BufferPool->ListHead,
        &BufferPool->SpinLock
        );


    if (ListEntry != NULL) {

        PIRCOMM_BUFFER  Buffer=CONTAINING_RECORD(ListEntry,IRCOMM_BUFFER,ListEntry);

#if DBG
        InterlockedIncrement(&BufferPool->BufferInUse);
        Buffer->FreeBuffer=FreeBuffer;
#endif

        return Buffer;
    }

    RemoveReferenceOnBufferPool(BufferPool);

    return NULL;

}

VOID
FreeBuffer(
    PIRCOMM_BUFFER        Buffer
    )

{


    PBUFFER_POOL          BufferPool=Buffer->BufferPool;

#if DBG
    Buffer->FreeBuffer=NULL;
    Buffer->Context=NULL;
    IoReuseIrp(Buffer->Irp,STATUS_CANCELLED);
    InterlockedDecrement(&BufferPool->BufferInUse);
#endif


    ExInterlockedPushEntrySList(
        &BufferPool->ListHead,
        &Buffer->ListEntry,
        &BufferPool->SpinLock
        );

    RemoveReferenceOnBufferPool(BufferPool);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\vuart\internal.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    internal.h

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#define UNICODE 1
#define NO_INTERLOCKED_INTRINSICS

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>


#define UINT ULONG //tmp
#include <irioctl.h>

//#include <ircommtdi.h>
#include <vuart.h>

#include <ircomm.h>
#include <ircommdbg.h>
#include "buffer.h"
#include <ntddser.h>

#include "link.h"

typedef struct _SEND_TRACKER {

    LONG                ReferenceCount;

    PIRP                CurrentWriteIrp;
    LONG                IrpReferenceCount;

    PVOID               CompletionContext;
    CONNECTION_CALLBACK CompletionRoutine;

    LONG                BuffersOutstanding;
    LONG                BytesRemainingInIrp;



    KTIMER              Timer;
    KDPC                TimerDpc;
    BOOLEAN             TimerSet;

    NTSTATUS            LastStatus;

#if DBG
    BOOLEAN             TimerExpired;
    BOOLEAN             IrpCanceled;
    BOOLEAN             SendAborted;
#endif
    struct _TDI_CONNECTION *Connection;

} SEND_TRACKER, *PSEND_TRACKER;

typedef struct _SEND_CONTROL {

    PSEND_TRACKER       CurrentSendTracker;

    LONG                ProcessSendEntryCount;

    KSPIN_LOCK          ControlLock;

    WORK_QUEUE_ITEM     WorkItem;
    LONG                WorkItemCount;

    BOOLEAN             OutOfBuffers;

} SEND_CONTROL, *PSEND_CONTROL;

typedef struct _UART_CONTROL {

    PIRP                CurrentIrp;
    PVOID               CompletionContext;
    CONNECTION_CALLBACK CompletionRoutine;

    LONG                DtrState;
    LONG                RtsState;
    ULONG               BaudRate;
    SERIAL_LINE_CONTROL LineControl;

    ULONG               ModemStatus;

} UART_CONTROL, *PUART_CONTROL;

typedef struct _TDI_CONNECTION {

    LONG              ReferenceCount;
    KEVENT            CloseEvent;

    LINK_HANDLE       LinkHandle;

    RECEIVE_CALLBACK  ReceiveCallBack;
    PVOID             ReceiveContext;

    EVENT_CALLBACK    EventCallBack;
    PVOID             EventContext;

    ULONG             MaxSendPdu;

    BOOLEAN           LinkUp;

    SEND_CONTROL      Send;

    UART_CONTROL      Uart;

} TDI_CONNECTION, *PTDI_CONNECTION;



VOID
SendWorkItemRountine(
    PVOID    Context
    );

VOID
ProcessSendAtPassive(
    PTDI_CONNECTION          Connection
    );


VOID
RemoveRefereneToConnection(
    PTDI_CONNECTION    Connection
    );

#define ADD_REFERENCE_TO_CONNECTION(_connection) InterlockedIncrement(&_connection->ReferenceCount)
#define REMOVE_REFERENCE_TO_CONNECTION(_connection) RemoveRefereneToConnection(_connection)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\vuart\tdi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tdi.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"



VOID
RemoveRefereneToConnection(
    PTDI_CONNECTION    Connection
    )

{

    LONG   Count;

    Count=InterlockedDecrement(&Connection->ReferenceCount);

    if (Count == 0) {

        KeSetEvent(
            &Connection->CloseEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }

    return;
}

VOID
HandleControlInformation(
    PTDI_CONNECTION    Connection,
    PUCHAR    Buffer,
    ULONG     Length
    )

{
    PUCHAR    Current=Buffer;

    while (Current < Buffer+Length) {

        UCHAR    PI=*Current;

        UCHAR    PL=*(Current+1);

        D_TRACE1(
            DbgPrint("IRCOMM: Receive Control, PI=%x, PL=%d, PV= ",PI,PL);

            DumpBuffer(Current+2,PL);
            DbgPrint("\n");
        )


        if ((Connection->EventCallBack != NULL)
            &&
            ((PI == PI_DTESettings) || (PI == PI_DCESettings))) {

            UCHAR    PV=*(Current+2);
            UCHAR    NewPV;
            ULONG    LineDelta=0;

            if (PI == PI_DTESettings) {
                //
                //  the other machine is a DTE as well. mundge the control lines
                //
                PI=PI_DCESettings;

                NewPV  = PV & PV_DTESetting_Delta_DTR ? PV_DCESetting_Delta_DSR : 0;
                NewPV |= PV & PV_DTESetting_Delta_RTS ? PV_DCESetting_Delta_CTS : 0;

                NewPV |= PV & PV_DTESetting_DTR_High  ? PV_DCESetting_DSR_State : 0;
                NewPV |= PV & PV_DTESetting_RTS_High  ? PV_DCESetting_CTS_State : 0;

            } else {
                //
                //  the other device is a DCE, just report the value straight back
                //
                NewPV=PV;

            }


            //
            //  save the current state of the control line here
            //
            Connection->Uart.ModemStatus=NewPV & 0xf0;


            if (NewPV & PV_DCESetting_Delta_CTS ) {

                LineDelta |= SERIAL_EV_CTS;
            }

            if (NewPV & PV_DCESetting_Delta_DSR ) {

                LineDelta |= SERIAL_EV_DSR;
            }

            if (NewPV & PV_DCESetting_Delta_RI ) {

                LineDelta |= SERIAL_EV_RING;
            }

            if (NewPV & PV_DCESetting_Delta_CD ) {

                LineDelta |= SERIAL_EV_RLSD;
            }

            (*Connection->EventCallBack)(
                Connection->EventContext,
                LineDelta
                );


        }

        Current+=2+PL;
    }

    return;
}


NTSTATUS
LinkReceiveHandler(
    PVOID    Context,
    ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PTDI_CONNECTION    Connection=Context;
    PUCHAR             Data=Tsdu;
    NTSTATUS           Status;
    ULONG              ClientDataUsed;

    *IoRequestPacket=NULL;

    *BytesTaken=BytesAvailable;


    D_TRACE(DbgPrint("IRCOMM: receive event, ind=%d, Avail=%d\n",BytesIndicated,BytesAvailable);)

    if (BytesIndicated < 1) {
        //
        //  ircomm frames should at least have the control length byte
        //
        D_ERROR(DbgPrint("IRCOMM: ClientEventRecieve: less than one byte indicated\n");)
        return STATUS_SUCCESS;
    }

    if ((ULONG)((*Data) + 1) > BytesIndicated) {
        //
        //   The control information is larger than the whole frame
        //
        D_ERROR(DbgPrint("IRCOMM: ClientEventRecieve: control length more than frame length, %d > %d\n",(ULONG)((*Data) + 1) , BytesIndicated);)
        return STATUS_SUCCESS;
    }

    if ((*Data > 0) && (*Data < 3)) {
        //
        //  There is control data, but it is less than a minimal PI,PL, and a one byte PV
        //
        D_ERROR(DbgPrint("IRCOMM: ClientEventRecieve: Control data is less than 3 bytes\n");)
        return STATUS_SUCCESS;
    }


    if (Connection->ReceiveCallBack != NULL) {
        //
        //  indicate the packet to the client
        //
        ULONG     ClientDataLength=(BytesIndicated-*Data)-1;

        if (ClientDataLength > 0) {

            Status=(*Connection->ReceiveCallBack)(
                        Connection->ReceiveContext,
                        Data+1+*Data,
                        ClientDataLength,
                        &ClientDataUsed
                        );

            if (Status == STATUS_DATA_NOT_ACCEPTED) {
                //
                //  the clients buffer is full, let the tdi driver buffer the data
                //
                *BytesTaken=0;

                //
                //  return now, before processing any control info so it will only be done once
                //  when the client request more data
                //
                return Status;
            }

            ASSERT(Status == STATUS_SUCCESS);
        }

    }

    //
    //  process the control data now
    //
    HandleControlInformation(Connection,Data+1,*Data);

    return STATUS_SUCCESS;

}


VOID
LinkStateHandler(
    PVOID     Context,
    BOOLEAN   LinkUp,
    ULONG     MaxSendPdu
    )

{

    PTDI_CONNECTION    Connection=Context;

    D_ERROR(DbgPrint("IRCOMM: LinkState %d\n",LinkUp);)

    Connection->LinkUp=LinkUp;

    if (!LinkUp) {
        //
        //  link down
        //
        if (Connection->EventCallBack != NULL) {
            //
            //  indicate that CTS, DSR, and CD are now low.
            //
            ULONG    LineDelta;

            Connection->Uart.ModemStatus=0;

            LineDelta  = SERIAL_EV_CTS;

            LineDelta |= SERIAL_EV_DSR;

            LineDelta |= SERIAL_EV_RING;

            LineDelta |= SERIAL_EV_RLSD;

            (*Connection->EventCallBack)(
                Connection->EventContext,
                LineDelta
                );
        }

    } else {

        UCHAR                ControlBuffer[4];
        CONNECTION_HANDLE    ConnectionHandle;

        Connection->MaxSendPdu=MaxSendPdu;

        ConnectionHandle=GetCurrentConnection(Connection->LinkHandle);

        if (ConnectionHandle != NULL) {

            ControlBuffer[0]=PV_ServiceType_9_Wire;

            SendSynchronousControlInfo(
                ConnectionHandle,
                PI_ServiceType,
                1,
                ControlBuffer
                );


            ControlBuffer[0]=(UCHAR)( Connection->Uart.BaudRate >> 24);
            ControlBuffer[1]=(UCHAR)( Connection->Uart.BaudRate >> 16);
            ControlBuffer[2]=(UCHAR)( Connection->Uart.BaudRate >>  8);
            ControlBuffer[3]=(UCHAR)( Connection->Uart.BaudRate >>  0);

            SendSynchronousControlInfo(
                ConnectionHandle,
                PI_DataRate,
                4,
                ControlBuffer
                );

            ControlBuffer[0] =  Connection->Uart.RtsState ? PV_DTESetting_RTS_High : 0;
            ControlBuffer[0] |= Connection->Uart.DtrState ? PV_DTESetting_DTR_High : 0;


            SendSynchronousControlInfo(
                ConnectionHandle,
                PI_DTESettings,
                1,
                ControlBuffer
                );

            ReleaseConnection(ConnectionHandle);
        }

        ProcessSendAtPassive(Connection);

    }

    return;
}



NTSTATUS
IrdaConnect(
    ULONG                  DeviceAddress,
    CHAR                  *ServiceName,
    BOOLEAN                OutGoingConnection,
    IRDA_HANDLE           *ConnectionHandle,
    RECEIVE_CALLBACK       ReceiveCallBack,
    EVENT_CALLBACK         EventCallBack,
    PVOID                  CallbackContext
    )
{

    NTSTATUS                    Status=STATUS_SUCCESS;
    PIRP                        pIrp;
    KEVENT                      Event;
    IO_STATUS_BLOCK             Iosb;
    TDI_CONNECTION_INFORMATION  ConnInfo;
    UCHAR                       AddrBuf[sizeof(TRANSPORT_ADDRESS) +
                                        sizeof(TDI_ADDRESS_IRDA)];
    PTRANSPORT_ADDRESS pTranAddr = (PTRANSPORT_ADDRESS) AddrBuf;
    PTDI_ADDRESS_IRDA pIrdaAddr = (PTDI_ADDRESS_IRDA) pTranAddr->Address[0].Address;                                    
    


    PTDI_CONNECTION    Connection=NULL;

    *ConnectionHandle=NULL;

    Connection=ALLOCATE_NONPAGED_POOL(sizeof(*Connection));

    if (Connection == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(Connection,sizeof(*Connection));

    KeInitializeSpinLock(&Connection->Send.ControlLock);

    ExInitializeWorkItem(
        &Connection->Send.WorkItem,
        SendWorkItemRountine,
        Connection
        );

    Connection->ReceiveContext=CallbackContext;
    Connection->ReceiveCallBack=ReceiveCallBack;

    Connection->EventContext=CallbackContext;
    Connection->EventCallBack=EventCallBack;

    Connection->Uart.BaudRate=115200;
    Connection->Uart.DtrState=1;
    Connection->Uart.RtsState=1;
    Connection->Uart.LineControl.WordLength=8;
    Connection->Uart.LineControl.StopBits=NO_PARITY;
    Connection->Uart.LineControl.Parity=STOP_BIT_1;
    Connection->Uart.ModemStatus=0;

    Connection->ReferenceCount=1;

    KeInitializeEvent(
        &Connection->CloseEvent,
        NotificationEvent,
        FALSE
        );

    *ConnectionHandle=Connection;

    Status=CreateTdiLink(
        DeviceAddress,
        ServiceName,
        OutGoingConnection,  //outgoing
        &Connection->LinkHandle,
        Connection,
        LinkReceiveHandler,
        LinkStateHandler,
        7,
        3,
        3
        );

    if (!NT_SUCCESS(Status)) {

        *ConnectionHandle=NULL;

        goto CleanUp;
    }

    return Status;

CleanUp:


    FreeConnection(Connection);

    return Status;

}




VOID
FreeConnection(
    IRDA_HANDLE    Handle
    )

{

    PTDI_CONNECTION    Connection=Handle;

    RemoveRefereneToConnection(
        Connection
        );

    //
    //  wait for recount to goto zero
    //
    KeWaitForSingleObject(
        &Connection->CloseEvent,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    if (Connection->LinkHandle != NULL) {

        CloseTdiLink(Connection->LinkHandle);
    }


    FREE_POOL(Connection);

    return;

}


NTSTATUS
ReceiveCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              BufferIrp,
    PVOID             Context
    )
{
    PIRCOMM_BUFFER           Buffer=Context;
    PTDI_CONNECTION          Connection=Buffer->Context;

    D_ERROR(DbgPrint("IRCOMM: receive restart complete\n");)

    Buffer->FreeBuffer(Buffer);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
IndicateReceiveBufferSpaceAvailible(
    IRDA_HANDLE    Handle
    )

{

    PTDI_CONNECTION          Connection=Handle;
    CONNECTION_HANDLE        ConnectionHandle;
    //
    //  we will send a receive irp with a zero length to irda,
    //  this will get it to start indicating packets again
    //
    ConnectionHandle=GetCurrentConnection(Connection->LinkHandle);

    if (ConnectionHandle != NULL) {
        //
        //  we have a good connection
        //
        PFILE_OBJECT             FileObject;
        PIRCOMM_BUFFER           Buffer;

        FileObject=ConnectionGetFileObject(ConnectionHandle);

        Buffer=ConnectionGetBuffer(ConnectionHandle,BUFFER_TYPE_RECEIVE);

        if (Buffer != NULL) {

            PDEVICE_OBJECT     IrdaDeviceObject=IoGetRelatedDeviceObject(FileObject);
            ULONG              Length=0;

            IoReuseIrp(Buffer->Irp,STATUS_SUCCESS);

            Buffer->Irp->Tail.Overlay.OriginalFileObject = FileObject;
            Buffer->Context=Connection;

            TdiBuildReceive(
                Buffer->Irp,
                IrdaDeviceObject,
                FileObject,
                ReceiveCompletion,
                Buffer,
                Buffer->Mdl,
                0, // send flags
                Length
                );

            IoCallDriver(IrdaDeviceObject, Buffer->Irp);

        } else {

            //
            //  we could not get a buffer, We preallocate 3 of these so this should not happen
            //  If there are not any availibe, then they should be in use telling irda we want
            //  packets as well
            //
            ASSERT(0);
        }

        ConnectionReleaseFileObject(ConnectionHandle,FileObject);
        ReleaseConnection(ConnectionHandle);

    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\dbgcon\dbgcon.c ===
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <wchar.h>

#define NT
//#include <tdi.h>

//#include <winsock2.h>
//#include <wsahelp.h>

//#include <tdistat.h>
//#include <tdiinfo.h>
//#include <llinfo.h>
#include <irioctl.h>

//#include <irda.h>
//#include <irlmp.h>

#define DBG_OUTPUT_DEBUGGER     1
#define DBG_OUTPUT_BUFFER       2



#define DBG_NDIS        0x00000002 // keep in sync with test\irdakdx
#define DBG_TIMER       0x00000004
#define DBG_IRMAC       0x00000008

#define DBG_IRLAP       0x00000010
#define DBG_IRLAPLOG    0x00000020
#define DBG_RXFRAME     0x00000040
#define DBG_TXFRAME     0x00000080

#define DBG_IRLMP       0x00000100
#define DBG_IRLMP_CONN  0x00000200
#define DBG_IRLMP_CRED  0x00000400
#define DBG_IRLMP_IAS   0x00000800

#define DBG_DISCOVERY   0x00001000
#define DBG_PRINT       0x00002000
#define DBG_ADDR        0x00004000

#define DBG_REF         0x00010000

#define DBG_TDI         0x00020000
#define DBG_TDI_IRP     0x00040000

#define DBG_ALLOC       0x10000000
#define DBG_FUNCTION    0x20000000
#define DBG_WARN        0x40000000
#define DBG_ERROR       0x80000000


#define IRDA_DEVICE_NAME    TEXT("\\Device\\IrDA")
#define IRWAN_DEVICE_NAME   TEXT("\\Device\\IrWAN")

OBJECT_ATTRIBUTES   ObjAttr;
UNICODE_STRING      DeviceName;
HANDLE              DeviceHandle;
UINT                i;
HANDLE              hFile = 0;
BOOLEAN             ConsoleOutput = TRUE;
DWORD               KBThreadId;
UINT                Dbgs[2];
UINT                *pDbgSettings = Dbgs;
UINT                *pDbgOutput = Dbgs+1;

HANDLE              hMsgsEvent;
CRITICAL_SECTION    Cs;
int                 State;

#define ST_RUNNING  0
#define ST_SETTING  1
#define ST_DONE     2 

char Buf[2048];

#define ONOFF(bit)  (bit & *pDbgSettings ? "On ": "Off")

void
DispCurrentSettings()
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;

    Status = NtDeviceIoControlFile(
                DeviceHandle,    // HANDLE FileHandle
                NULL,            // HANDLE Event OPTIONAL
                NULL,            // PIO_APC_ROUTINE ApcRoutine
                NULL,            // PVOID ApcContext
                &IoStatusBlock,  // PIO_STATUS_BLOCK IoStatusBlock
                IOCTL_IRDA_GET_DBG_SETTINGS,           // ULONG IoControlCode
                NULL,            // PVOID InputBuffer
                0,               // ULONG InputBufferLength
                Dbgs,             // PVOID OutputBuffer
                sizeof(Dbgs));    // ULONG OutputBufferLength

    if (!NT_SUCCESS(Status))    
    {
        printf("Ioctl failed %x\n", Status);
        return;
    }
    printf("\nCurrent settings:\n");
    printf("   A. RXFRAME...:%s        B. TXFRAME...:%s\n", 
            ONOFF(DBG_RXFRAME), ONOFF(DBG_TXFRAME));
    printf("   C. MAC.......:%s        D. NDIS......:%s\n",
            ONOFF(DBG_IRMAC), ONOFF(DBG_NDIS));
    printf("   E. LAPLOG....:%s        F. LAP.......:%s\n",
            ONOFF(DBG_IRLAPLOG), ONOFF(DBG_IRLAP));
    printf("   G. LMP.......:%s        H. LMP_CONN..:%s\n",
            ONOFF(DBG_IRLMP), ONOFF(DBG_IRLMP_CONN));
    printf("   I. LMP_CREDIT:%s        J. LMP_IAS:...%s\n",
            ONOFF(DBG_IRLMP_CRED), ONOFF(DBG_IRLMP_IAS));
    printf("   K. TDI.......:%s        L. TDI_IRP...:%s\n",
            ONOFF(DBG_TDI), ONOFF(DBG_TDI_IRP));
    printf("   M. WARN......:%s        N. ERROR.....:%s\n",
            ONOFF(DBG_WARN), ONOFF(DBG_ERROR));
    printf("   Output:\n");
    printf("   O. Debugger..:%s\n",
        *pDbgOutput & DBG_OUTPUT_DEBUGGER? "On" : "Off");
    printf("   P. Console...:%s\n\n",
        *pDbgOutput & DBG_OUTPUT_BUFFER? "On" : "Off");
        
    printf("   <Enter> to continue\n");

    return;
}

ULONG WINAPI
KBThread(LPVOID pvarg)
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    int Key;

    while (1)
    {   
        Key = _getch();
        
        if (Key == 'q' || Key =='Q')
        {
            EnterCriticalSection(&Cs);
            State = ST_DONE;
            LeaveCriticalSection(&Cs);
            SetEvent(hMsgsEvent);
            return 0;
        }
            
        if (State != ST_SETTING && Key != 27)
        {
            continue;
        }    
        
        switch (Key)
        {
            case 13:
                EnterCriticalSection(&Cs);
                State = ST_RUNNING;
                printf("running\n");
                LeaveCriticalSection(&Cs);
                continue;;
            
            case 27:
                EnterCriticalSection(&Cs);
                if (State != ST_SETTING)
                {
                    State = ST_SETTING;                
                    DispCurrentSettings();
                }    
                LeaveCriticalSection(&Cs);
                continue;
                
            case 'a':
            case 'A':
                *pDbgSettings ^= DBG_RXFRAME;
                break;    

            case 'b':
            case 'B':
                *pDbgSettings ^= DBG_TXFRAME;
                break;    
                
            case 'c':
            case 'C':
                *pDbgSettings ^= DBG_IRMAC;
                break;    
                
            case 'd':
            case 'D':
                *pDbgSettings ^= DBG_NDIS;
                break;    
                
            case 'e':
            case 'E':
                *pDbgSettings ^= DBG_IRLAPLOG;
                break;    
                
            case 'f':
            case 'F':
                *pDbgSettings ^= DBG_IRLAP;
                break;    
                
            case 'g':
            case 'G':
                *pDbgSettings ^= DBG_IRLMP;
                break;    

            case 'h':
            case 'H':
                *pDbgSettings ^= DBG_IRLMP_CONN;
                break;    

            case 'i':
            case 'I':
                *pDbgSettings ^= DBG_IRLMP_CRED;
                break;    

            case 'j':
            case 'J':
                *pDbgSettings ^= DBG_IRLMP_IAS;
                break;    
                
            case 'k':
            case 'K':
                *pDbgSettings ^= DBG_TDI;
                break;    

            case 'l':
            case 'L':
                *pDbgSettings ^= DBG_TDI_IRP;
                break;    

            case 'm':
            case 'M':
                *pDbgSettings ^= DBG_WARN;
                break;    
                
            case 'n':
            case 'N':
                *pDbgSettings ^= DBG_ERROR;
                break;    
            
            case 'o':
            case 'O':
                *pDbgOutput ^= DBG_OUTPUT_DEBUGGER;
                break;    
            
            case 'p':
            case 'P':
                *pDbgOutput ^= DBG_OUTPUT_BUFFER;
                break;

            default:
                continue;
        }

        Status = NtDeviceIoControlFile(
                DeviceHandle,    // HANDLE FileHandle
                NULL,            // HANDLE Event OPTIONAL
                NULL,            // PIO_APC_ROUTINE ApcRoutine
                NULL,            // PVOID ApcContext
                &IoStatusBlock,  // PIO_STATUS_BLOCK IoStatusBlock
                IOCTL_IRDA_SET_DBG_SETTINGS,           // ULONG IoControlCode
                Dbgs,            // PVOID InputBuffer
                sizeof(Dbgs),               // ULONG InputBufferLength
                NULL,             // PVOID OutputBuffer
                0);    // ULONG OutputBufferLength
        
        DispCurrentSettings();
        
    }

    return 0;
} 


_cdecl main(int argc, char *argv[])
{    
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
/*                    
    if (argc > 1)
    {
        hFile = CreateFile(argv[1],
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            printf("Couldn't open file %s\n", argv[1]);
            return 1;
        }
    }
    
    if (argc == 3)
        ConsoleOutput = FALSE;
*/          

    InitializeCriticalSection(&Cs);
    
    State = ST_RUNNING;

    hMsgsEvent = CreateEvent(NULL, FALSE, FALSE, NULL);    

    RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);
//    RtlInitUnicodeString(&DeviceName, IRWAN_DEVICE_NAME);    
      
    InitializeObjectAttributes(
        &ObjAttr,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
        
    Status = NtCreateFile(
                &DeviceHandle,                  // PHANDLE FileHandle
                GENERIC_READ | GENERIC_WRITE,  // ACCESS_MASK DesiredAccess
                &ObjAttr,                       // POBJECT_ATTRIBUTES ObjAttr
                &IoStatusBlock,                 // PIO_STATUS_BLOCK IoStatusBlock
                NULL,                           // PLARGE_INTEGER AllocationSize
                FILE_ATTRIBUTE_NORMAL,          // ULONG FileAttributes
                FILE_SHARE_DELETE | FILE_SHARE_READ |
                FILE_SHARE_WRITE,               // ULONG ShareAccess
                FILE_OPEN_IF,                   // ULONG CreateDisposition
                0,   // ULONG CreateOptions
                NULL,                           // PVOID EaBuffer
                0);                             // ULONG EaLength

    if (!NT_SUCCESS(Status))
    {
        printf("failed to open irda.sys\n");
        return 1;
    }

    CreateThread(NULL, 0, KBThread, 0, 0, &KBThreadId);
    

    printf("<Esc> to enter settings mode, <q> to quit\n");
    
    while (1)
    {
        Status = NtDeviceIoControlFile(
                DeviceHandle,    // HANDLE FileHandle
                hMsgsEvent,      // HANDLE Event OPTIONAL
                NULL,           // PIO_APC_ROUTINE ApcRoutine
                Buf,            // PVOID ApcContext
                &IoStatusBlock,  // PIO_STATUS_BLOCK IoStatusBlock
                IOCTL_IRDA_GET_DBG_MSGS,           // ULONG IoControlCode
                NULL,            // PVOID InputBuffer
                0,               // ULONG InputBufferLength
                Buf,             // PVOID OutputBuffer
                sizeof(Buf));    // ULONG OutputBufferLength
                

        if (Status != STATUS_PENDING && Status != STATUS_SUCCESS)
        {
            printf("ioctl failed %X\n", Status);
            break;
        }    
       
        if (Status == STATUS_PENDING)
        {
            WaitForSingleObject(hMsgsEvent, INFINITE);     
            
            EnterCriticalSection(&Cs);
            
            if (State == ST_DONE)
            {
                return 0;
            }
            else    
            {
                LeaveCriticalSection(&Cs);
            }
        }
            
        if (IoStatusBlock.Information >= 2048)
        {
            printf("wow, too big\n");
            break;
        }    
            
        if (ConsoleOutput && State == ST_RUNNING)
            fwrite(Buf, IoStatusBlock.Information, 1, stdout);

/*
        if (hFile)
            fwrite(Buf, 1, IoStatusBlock.Information, stdout);        
*/            
    }

    NtClose(DeviceHandle);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\eventlog\makefile.inc ===
$(O)\eventlog.h: eventlog.h1 eventlog.mc
    $(MC) -v -e h2 -h $(O) -r $(O) eventlog.mc
    cat eventlog.h1 $(O)\eventlog.h2 >$(O)\eventlog.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\comm\vuart\send.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"


VOID
RemoveReferenceForBuffers(
    PSEND_TRACKER            SendTracker
    );

VOID
ProcessSend(
    PTDI_CONNECTION          Connection
    );

VOID
ProcessSendAtPassive(
    PTDI_CONNECTION          Connection
    );


VOID
SendBufferToTdi(
    PFILE_OBJECT    FileObject,
    PIRCOMM_BUFFER  Buffer
    );

NTSTATUS
SendCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    );



VOID
TryToCompleteCurrentIrp(
    PSEND_TRACKER            SendTracker
    );


VOID
RemoveReferenceOnTracker(
    PSEND_TRACKER            SendTracker
    )


{
    LONG     Count;

    Count=InterlockedDecrement(&SendTracker->ReferenceCount);

    if (Count == 0) {

        REMOVE_REFERENCE_TO_CONNECTION(SendTracker->Connection);

        FREE_POOL(SendTracker);

    }

    return;
}


PIRP
GetCurrentIrpAndAddReference(
    PSEND_TRACKER            SendTracker
    )

{
    KIRQL    OldIrql;
    PIRP     Irp;

    KeAcquireSpinLock(
        &SendTracker->Connection->Send.ControlLock,
        &OldIrql
        );

    Irp=SendTracker->CurrentWriteIrp;

    if (Irp != NULL) {
        //
        //  irp is still around, add a ref coun to keep it around for a while.
        //
        SendTracker->IrpReferenceCount++;
    }


    KeReleaseSpinLock(
        &SendTracker->Connection->Send.ControlLock,
        OldIrql
        );

    return Irp;
}

VOID
ReleaseIrpReference(
    PSEND_TRACKER    SendTracker
    )

{
    KIRQL                  OldIrql;
    PIRP                   Irp=NULL;
    CONNECTION_CALLBACK    Callback=NULL;
    PVOID                  Context;

    KeAcquireSpinLock(
        &SendTracker->Connection->Send.ControlLock,
        &OldIrql
        );

    SendTracker->IrpReferenceCount--;

    if (SendTracker->IrpReferenceCount==0) {
        //
        //  done, with irp complete it now with the current status
        //
        Irp=SendTracker->CurrentWriteIrp;

        SendTracker->CurrentWriteIrp=NULL;

        Callback=SendTracker->CompletionRoutine;
        Context=SendTracker->CompletionContext;

#if DBG
        SendTracker->CompletionRoutine=NULL;
#endif

        SendTracker->Connection->Send.CurrentSendTracker=NULL;
    }


    KeReleaseSpinLock(
        &SendTracker->Connection->Send.ControlLock,
        OldIrql
        );

    if (Irp != NULL) {
        //
        //  The ref count has gone to zero, complete the irp
        //
        (Callback)(
            Context,
            Irp
            );

        //
        //  release the reference for the irp
        //
        RemoveReferenceOnTracker(SendTracker);
    }

    return;
}

VOID
SetIrpAndRefcounts(
    PSEND_TRACKER            SendTracker,
    PIRP                     Irp
    )

{
    //
    //  set the tracker refcount to 2, one for the irp, and one for the rountine that called this
    //
    SendTracker->ReferenceCount=2;
    //
    //  Set the irp count to one for the rountine that called this, it will release when it done
    //  setting up the tracker block
    //
    SendTracker->IrpReferenceCount=1;

    //
    //  save the irp
    //
    SendTracker->CurrentWriteIrp=Irp;

    return;
}


VOID
SendTimerProc(
    PKDPC    Dpc,
    PVOID    Context,
    PVOID    SystemParam1,
    PVOID    SystemParam2
    )

{
    PSEND_TRACKER            SendTracker=Context;
    PIRP                     Irp;
    KIRQL                    OldIrql;

    D_ERROR(DbgPrint("IRCOMM: SendTimerProc\n");)

    ASSERT(SendTracker->TimerSet);
#if DBG
    SendTracker->TimerExpired=TRUE;
#endif

    SendTracker->TimerSet=FALSE;

    //
    //  try to get a hold of the irp so we can set the status
    //
    Irp=GetCurrentIrpAndAddReference(SendTracker);

    Irp->IoStatus.Status=STATUS_TIMEOUT;

    //
    //  release on reference for the one we just added
    //
    ReleaseIrpReference(SendTracker);

    TryToCompleteCurrentIrp(
        SendTracker
        );

    //
    //  release the second reference for the timer being set in the first place
    //
    ReleaseIrpReference(SendTracker);

    return;
}

VOID
SendCancelRoutine(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{
    PSEND_TRACKER            SendTracker=Irp->Tail.Overlay.DriverContext[0];
    KIRQL                    OldIrql;

    D_ERROR(DbgPrint("IRCOMM: SendCancelRoutine\n");)

#if DBG
    SendTracker->IrpCanceled=TRUE;
#endif

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status=STATUS_CANCELLED;

    //
    //  clean up the timer
    //
    TryToCompleteCurrentIrp(SendTracker);

    //
    //  release the reference held for the cancel routine
    //
    ReleaseIrpReference(SendTracker);

    //
    //  send tracker maybe freed at this point
    //

    return;

}

VOID
TryToCompleteCurrentIrp(
    PSEND_TRACKER            SendTracker
    )

{

    KIRQL                    OldIrql;
    PVOID                    OldCancelRoutine=NULL;
    PIRP                     Irp;
    BOOLEAN                  TimerCanceled=FALSE;

    Irp=GetCurrentIrpAndAddReference(SendTracker);

    KeAcquireSpinLock(
        &SendTracker->Connection->Send.ControlLock,
        &OldIrql
        );

    if (SendTracker->TimerSet) {

        TimerCanceled=KeCancelTimer(
            &SendTracker->Timer
            );

        if (TimerCanceled) {
            //
            //  We ended up canceling the timer
            //
            SendTracker->TimerSet=FALSE;

        } else {
            //
            //  The timer is already running, we will just let it complete
            //  and do the clean up.
            //

        }
    }

    if (Irp != NULL) {
        //
        //  the irp has not already been completed
        //
        OldCancelRoutine=IoSetCancelRoutine(
            Irp,
            NULL
            );
    }

    KeReleaseSpinLock(
        &SendTracker->Connection->Send.ControlLock,
        OldIrql
        );

    if (TimerCanceled) {
        //
        //  we canceled the timer before it could run, remove the reference for it
        //
        ReleaseIrpReference(SendTracker);
    }

    if (Irp != NULL) {

        if (OldCancelRoutine != NULL) {
            //
            //  since the cancel rountine had not run, release its reference to the irp
            //
            ReleaseIrpReference(SendTracker);
        }

        //
        //  if this routine got the irp, release the reference to it
        //
        ReleaseIrpReference(SendTracker);
    }

    return;
}


VOID
SendOnConnection(
    IRDA_HANDLE            Handle,
    PIRP                   Irp,
    CONNECTION_CALLBACK    Callback,
    PVOID                  Context,
    ULONG                  Timeout
    )

{

    PTDI_CONNECTION          Connection=Handle;
    PIO_STACK_LOCATION       IrpSp=IoGetCurrentIrpStackLocation(Irp);
    PSEND_TRACKER            SendTracker;
    BOOLEAN                  AlreadyCanceled;
    KIRQL                    OldIrql;
    KIRQL                    OldCancelIrql;


    if (Connection->Send.CurrentSendTracker != NULL) {
        //
        //  called when we already have an irp
        //
        (Callback)(
            Context,
            Irp
            );

        return;
    }

    SendTracker=ALLOCATE_NONPAGED_POOL(sizeof(*SendTracker));

    if (SendTracker == NULL) {

        Irp->IoStatus.Status=STATUS_INSUFFICIENT_RESOURCES;

        (Callback)(
            Context,
            Irp
            );

        return;
    }

    RtlZeroMemory(SendTracker,sizeof(*SendTracker));


    KeInitializeTimer(
        &SendTracker->Timer
        );

    KeInitializeDpc(
        &SendTracker->TimerDpc,
        SendTimerProc,
        SendTracker
        );

    //
    //  set the irp and initialize the refcounts
    //
    SetIrpAndRefcounts(SendTracker,Irp);

    ADD_REFERENCE_TO_CONNECTION(Connection);

    //
    //  initialize these values
    //
    SendTracker->Connection=Connection;
    SendTracker->BuffersOutstanding=0;

    SendTracker->CompletionContext   = Context;
    SendTracker->CompletionRoutine   = Callback;
    SendTracker->BytesRemainingInIrp = IrpSp->Parameters.Write.Length;

    if (Timeout > 0) {
        //
        //  add a reference for the timer
        //
        GetCurrentIrpAndAddReference(SendTracker);
    }

    //
    //  add a reference to the irp for the cancel rountine
    //
    GetCurrentIrpAndAddReference(SendTracker);


    KeAcquireSpinLock(
        &Connection->Send.ControlLock,
        &OldIrql
        );

    Connection->Send.CurrentSendTracker=SendTracker;

    if (Timeout > 0) {
        //
        //  need to set a timer
        //
        LARGE_INTEGER    DueTime;

        DueTime.QuadPart= (LONGLONG)(Timeout+100) * -10000;

        SendTracker->TimerSet=TRUE;


        KeSetTimer(
            &SendTracker->Timer,
            DueTime,
            &SendTracker->TimerDpc
            );
    }


    Irp->Tail.Overlay.DriverContext[0]=SendTracker;

    IoAcquireCancelSpinLock(&OldCancelIrql);


    AlreadyCanceled=Irp->Cancel;

    if (!AlreadyCanceled) {

        PIRCOMM_BUFFER           Buffer;

        //
        //  the irp has not been canceled already, set the cancel routine
        //
        IoSetCancelRoutine(
            Irp,
            SendCancelRoutine
            );


    } else {
        //
        //  it was canceled when we got it
        //
        Irp->IoStatus.Status=STATUS_CANCELLED;
    }

    IoReleaseCancelSpinLock(OldCancelIrql);

    KeReleaseSpinLock(
        &Connection->Send.ControlLock,
        OldIrql
        );

    if (AlreadyCanceled) {
        //
        //  The irp has already been canceled, just call the cancel rountine so the normal code runs
        //
        D_ERROR(DbgPrint("IRCOMM: SendOnConnection: irp already canceled\n");)

        IoAcquireCancelSpinLock(&Irp->CancelIrql);

        SendCancelRoutine(
            NULL,
            Irp
            );

        //
        //  the cancel rountine will release the cancel spinlock
        //

    }

    //
    //  release the reference for this routine
    //
    ReleaseIrpReference(SendTracker);

    ProcessSendAtPassive(Connection);

    RemoveReferenceOnTracker(SendTracker);

    return;
}

VOID
ProcessSendAtPassive(
    PTDI_CONNECTION          Connection
    )

{
    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        //
        //  less than dispatch, just call directly
        //
        ProcessSend(Connection);

    } else {
        //
        //  Called at dispatch, queue the work item
        //
        LONG     Count=InterlockedIncrement(&Connection->Send.WorkItemCount);

        if (Count == 1) {

            ExQueueWorkItem(&Connection->Send.WorkItem,CriticalWorkQueue);
        }

    }
    return;
}

VOID
SendWorkItemRountine(
    PVOID    Context
    )

{
    PTDI_CONNECTION          Connection=Context;

    //
    //  the work item has run set the count to zero
    //
    InterlockedExchange(&Connection->Send.WorkItemCount,0);

    ProcessSend(Connection);
}


VOID
ProcessSend(
    PTDI_CONNECTION          Connection
    )

{
    PSEND_TRACKER            SendTracker;
    PIRP                     Irp;
    PIO_STACK_LOCATION       IrpSp;
    PLIST_ENTRY              ListEntry;
    ULONG                    BytesUsedInBuffer;
    PIRCOMM_BUFFER           Buffer;
    BOOLEAN                  ExitLoop;
    PFILE_OBJECT             FileObject;
    CONNECTION_HANDLE        ConnectionHandle;
    KIRQL                    OldIrql;


    KeAcquireSpinLock(
        &Connection->Send.ControlLock,
        &OldIrql
        );

    if (Connection->Send.ProcessSendEntryCount == 0) {

        Connection->Send.ProcessSendEntryCount++;

        while ((Connection->Send.CurrentSendTracker != NULL)
               &&
               (!Connection->Send.OutOfBuffers)
               &&
                (Connection->LinkUp)
               &&
                (Connection->Send.CurrentSendTracker->BytesRemainingInIrp > 0)) {


            SendTracker=Connection->Send.CurrentSendTracker;

            InterlockedIncrement(&SendTracker->ReferenceCount);

            KeReleaseSpinLock(
                &Connection->Send.ControlLock,
                OldIrql
                );

            Irp=GetCurrentIrpAndAddReference(SendTracker);

            if (Irp != NULL) {
                //
                //  got the current irp
                //
                IrpSp=IoGetCurrentIrpStackLocation(Irp);

                ConnectionHandle=GetCurrentConnection(Connection->LinkHandle);

                if (ConnectionHandle != NULL) {
                    //
                    //  we have a good connection
                    //
                    FileObject=ConnectionGetFileObject(ConnectionHandle);

                    Buffer=ConnectionGetBuffer(ConnectionHandle,BUFFER_TYPE_SEND);

                    if (Buffer != NULL) {

                        LONG     BytesToCopy=min(SendTracker->BytesRemainingInIrp, (LONG)Buffer->BufferLength - 1);

                        //
                        //  this buffer is going to be outstanding, set this before the bytes
                        //  remaining count goes to zero
                        //
                        InterlockedIncrement(&SendTracker->BuffersOutstanding);

                        //
                        //  start with a zero length of control bytes
                        //
                        Buffer->Data[0]=0;

                        //
                        //  actual data starts one byte in, after the length byte
                        //
                        //  move the data
                        //
                        RtlCopyMemory(
                            &Buffer->Data[1],
                            (PUCHAR)Irp->AssociatedIrp.SystemBuffer+(IrpSp->Parameters.Write.Length - SendTracker->BytesRemainingInIrp),
                            BytesToCopy
                            );

                        //
                        //  the count has to include the control byte
                        //
                        Buffer->Mdl->ByteCount= 1 + BytesToCopy;

#if DBG
                        RtlFillMemory(
                            &Buffer->Data[Buffer->Mdl->ByteCount],
                            Buffer->BufferLength-Buffer->Mdl->ByteCount,
                            0xfb
                            );

#endif

                        InterlockedExchangeAdd(&SendTracker->BytesRemainingInIrp, -BytesToCopy);


                        Buffer->Mdl->Next=NULL;

                        Buffer->Context=SendTracker;


                        InterlockedIncrement(&SendTracker->ReferenceCount);

                        ASSERT(SendTracker->CurrentWriteIrp != NULL);

                        SendBufferToTdi(
                            FileObject,
                            Buffer
                            );
#if DBG
                        Buffer=NULL;
#endif

                    } else {
                        //
                        //  No more buffers availible
                        //
                        Connection->Send.OutOfBuffers=TRUE;

                    }

                    ConnectionReleaseFileObject(ConnectionHandle,FileObject);
                    ReleaseConnection(ConnectionHandle);

                } else {
                    //
                    //  The connection, must be down
                    //
                    D_ERROR(DbgPrint("IRCOMM: ProcessSend: Link down\n");)
                    Connection->LinkUp=FALSE;
                }

                ReleaseIrpReference(SendTracker);

            } else {
                //
                //  the irp has already been completed from this tracking block
                //
                D_ERROR(DbgPrint("IRCOMM: ProcessSend: no irp\n");)

                ASSERT(SendTracker->TimerExpired || SendTracker->IrpCanceled || SendTracker->SendAborted);
            }

            RemoveReferenceOnTracker(SendTracker);

            KeAcquireSpinLock(
                &Connection->Send.ControlLock,
                &OldIrql
                );

        } // while

        Connection->Send.ProcessSendEntryCount--;

    }



    KeReleaseSpinLock(
        &Connection->Send.ControlLock,
        OldIrql
        );


    return;
}


VOID
SendBufferToTdi(
    PFILE_OBJECT    FileObject,
    PIRCOMM_BUFFER  Buffer
    )

{
    PDEVICE_OBJECT     IrdaDeviceObject=IoGetRelatedDeviceObject(FileObject);
    ULONG              SendLength;

    IoReuseIrp(Buffer->Irp,STATUS_SUCCESS);

    Buffer->Irp->Tail.Overlay.OriginalFileObject = FileObject;


    SendLength = MmGetMdlByteCount(Buffer->Mdl);

    TdiBuildSend(
        Buffer->Irp,
        IrdaDeviceObject,
        FileObject,
        SendCompletion,
        Buffer,
        Buffer->Mdl,
        0, // send flags
        SendLength
        );


    IoCallDriver(IrdaDeviceObject, Buffer->Irp);

    return;
}

NTSTATUS
SendCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              BufferIrp,
    PVOID             Context
    )

{
    PIRCOMM_BUFFER           Buffer=Context;
    PSEND_TRACKER            SendTracker=Buffer->Context;
    PTDI_CONNECTION          Connection=SendTracker->Connection;
    LONG                     BuffersOutstanding;

    //
    //  save off the status for the sub transerfer
    //
    SendTracker->LastStatus=BufferIrp->IoStatus.Status;

    D_TRACE(DbgPrint("IRCOMM: SendComplete: Status=%08lx, len=%d\n",BufferIrp->IoStatus.Status,BufferIrp->IoStatus.Information);)

#if DBG
    RtlFillMemory(
        &Buffer->Data[0],
        Buffer->BufferLength,
        0xfe
        );
#endif
    //
    //  return the buffer
    //
    Buffer->FreeBuffer(Buffer);

    Connection->Send.OutOfBuffers=FALSE;

#if DBG
    Buffer=NULL;
    BufferIrp=NULL;
#endif

    BuffersOutstanding=InterlockedDecrement(&SendTracker->BuffersOutstanding);

    if ((BuffersOutstanding == 0) && (SendTracker->BytesRemainingInIrp == 0)) {
        //
        //  All of the data in the irp has been sent and all of the irps send to
        //  the irda stack have completed
        //
        //  Done with the irp in this tracker
        //
        PIRP                     Irp;
        PIO_STACK_LOCATION       IrpSp;

        Irp=GetCurrentIrpAndAddReference(SendTracker);

        if (Irp != NULL) {

            IrpSp=IoGetCurrentIrpStackLocation(Irp);

            Irp->IoStatus.Information=IrpSp->Parameters.Write.Length;

            Irp->IoStatus.Status=SendTracker->LastStatus;

            ReleaseIrpReference(SendTracker);

            TryToCompleteCurrentIrp(SendTracker);

        } else {
            //
            //  the irp has already been completed from this tracking block
            //
            D_ERROR(DbgPrint("IRCOMM: SendCompletion: no irp\n");)

            //
            //  this should only happen if the timer expired or the irp was canceled
            //
            ASSERT(SendTracker->TimerExpired || SendTracker->IrpCanceled || SendTracker->SendAborted);

        }
    }

    RemoveReferenceOnTracker(SendTracker);

    ProcessSendAtPassive(Connection);

    return STATUS_MORE_PROCESSING_REQUIRED;
}






VOID
AbortSend(
    IRDA_HANDLE            Handle
    )

{

    PTDI_CONNECTION          Connection=Handle;
    PSEND_TRACKER            SendTracker=NULL;
    KIRQL                    OldIrql;

    KeAcquireSpinLock(
        &Connection->Send.ControlLock,
        &OldIrql
        );


    SendTracker=Connection->Send.CurrentSendTracker;

    if (SendTracker != NULL) {

        InterlockedIncrement(&SendTracker->ReferenceCount);
    }


    KeReleaseSpinLock(
        &Connection->Send.ControlLock,
        OldIrql
        );


    if (SendTracker != NULL) {

#if DBG
        SendTracker->SendAborted=TRUE;
#endif

        TryToCompleteCurrentIrp(SendTracker);

        RemoveReferenceOnTracker(SendTracker);
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\eventlog\eventlog.cpp ===
//--------------------------------------------------------------------
// Copyright (C) Microsoft Corporation, 1999 - 1999, All Rights Reserved
//
// eventlog.cpp
//
// Implementation of a simple event logging class.
//
//--------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include "eventlog.h"

//--------------------------------------------------------------------
// EVENT_LOG::EVENT_LOG()
//
//--------------------------------------------------------------------
EVENT_LOG::EVENT_LOG( WCHAR *pwsEventSourceName,
                    DWORD *pdwStatus )
    {
    *pdwStatus = 0;

    m_hEventLog = RegisterEventSourceW( NULL, pwsEventSourceName );
    if (!m_hEventLog)
        {
        *pdwStatus = GetLastError();
        }
    }

//--------------------------------------------------------------------
// EVENT_LOG:;~EVENT_LOG()
//
//--------------------------------------------------------------------
EVENT_LOG::~EVENT_LOG()
    {
    if (m_hEventLog)
        {
        DeregisterEventSource(m_hEventLog);
        }
    }

//--------------------------------------------------------------------
// EVENT_LOG::CheckConfiguration()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::CheckConfiguration( WCHAR *pwszEventSourceName,
                                     WCHAR *pwszCatalogPath,
                                     DWORD  dwCategoryCount,
                                     DWORD  dwTypesSupported )
    {
    WCHAR wszRegKey[256];
    HKEY  hKey;
    DWORD dwDisposition;
    DWORD dwStatus;

    wcscpy(wszRegKey,WS_EVENTLOG_KEY);
    wcscat(wszRegKey,L"\\");
    wcscat(wszRegKey,pwszEventSourceName);

    //
    // First make sure the event source exists in the registry:
    //
    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                              wszRegKey,
                              0,
                              KEY_READ,
                              &hKey );
    if (dwStatus == ERROR_SUCCESS)
        {
        //
        // Key is already present, so we are Ok, just quit...
        //
        RegCloseKey(hKey);
        return 0;
        }

    dwStatus = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                wszRegKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition );
    if (dwStatus != ERROR_SUCCESS)
        {
        RegCloseKey(hKey);
        return dwStatus;
        }

    dwStatus = RegSetValueExW( hKey,
                               WSZ_CATEGORY_COUNT,
                               0,
                               REG_DWORD,
                               (UCHAR*)&dwCategoryCount,
                               sizeof(DWORD) );
    if (dwStatus != ERROR_SUCCESS)
        {
        RegCloseKey(hKey);
        return dwStatus;
        }

    dwStatus = RegSetValueExW( hKey,
                               WSZ_TYPES_SUPPORTED,
                               0,
                               REG_DWORD,
                               (UCHAR*)&dwTypesSupported,
                               sizeof(DWORD) );
    if (dwStatus != ERROR_SUCCESS)
        {
        RegCloseKey(hKey);
        return dwStatus;
        }

    DWORD  dwSize = sizeof(WCHAR)*(1+wcslen(pwszCatalogPath));
    dwStatus = RegSetValueExW( hKey,
                               WSZ_CATEGORY_MESSAGE_FILE,
                               0,
                               REG_EXPAND_SZ,
                               (UCHAR*)pwszCatalogPath,
                               dwSize );
    if (dwStatus != ERROR_SUCCESS)
        {
        RegCloseKey(hKey);
        return dwStatus;
        }

    dwStatus = RegSetValueExW( hKey,
                               WSZ_EVENT_MESSAGE_FILE,
                               0,
                               REG_EXPAND_SZ,
                               (UCHAR*)pwszCatalogPath,
                               dwSize );

    RegCloseKey(hKey);
    return dwStatus;
    }

//--------------------------------------------------------------------
// EVENT_LOG::ReportError()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::ReportError(  WORD  wCategoryId,
                               DWORD dwEventId )
    {
    return ReportError( wCategoryId,
                        dwEventId,
                        0,
                        NULL,
                        0,
                        NULL );
    }

//--------------------------------------------------------------------
// EVENT_LOG::ReportError()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::ReportError( WORD  wCategoryId,
                              DWORD dwEventId,
                              DWORD dwValue1 )
    {
    WCHAR   wszValue[20];
    WCHAR  *pwszValue = (WCHAR*)wszValue;

    wsprintfW(wszValue,L"%d",dwValue1);

    return ReportError( wCategoryId,
                        dwEventId,
                        1,
                        &pwszValue,
                        0,
                        NULL );
    }

//--------------------------------------------------------------------
// EVENT_LOG::ReportError()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::ReportError( WORD   wCategoryId,
                              DWORD  dwEventId,
                              WCHAR *pwszString )
    {
    if (pwszString)
        {
        WCHAR **ppwszStrings = &pwszString;

        return ReportError( wCategoryId,
                            dwEventId,
                            1,
                            ppwszStrings,
                            0,
                            NULL );
        }
    else
        {
        return ERROR_INVALID_PARAMETER;
        }
    }

//--------------------------------------------------------------------
// EVENT_LOG::ReportError()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::ReportError( WORD    wCategoryId,
                              DWORD   dwEventId,
                              WORD    wNumStrings,
                              WCHAR **ppwszStrings )
    {
    return ReportError( wCategoryId,
                        dwEventId,
                        wNumStrings,
                        ppwszStrings,
                        0,
                        NULL );
    }

//--------------------------------------------------------------------
// EVENT_LOG::ReportError()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::ReportError( WORD    wCategoryId,
                              DWORD   dwEventId,
                              WORD    wNumStrings,
                              WCHAR **ppwszStrings,
                              DWORD   dwDataSize,
                              VOID   *pvData )
    {
    if (! ::ReportEventW(m_hEventLog,
                         EVENTLOG_ERROR_TYPE,
                         wCategoryId, // Message ID for category.
                         dwEventId,   // Message ID for event.
                         NULL,        // pSID (not used).
                         wNumStrings, // Number of strings.
                         dwDataSize,  // Binary Data Size.
                         (const WCHAR**)ppwszStrings,
                         pvData ) )   // Binary Data (none).
        {
        return GetLastError();
        }
    else
        {
        return 0;
        }
    }

//--------------------------------------------------------------------
// EVENT_LOG::ReportInfo()
//
//--------------------------------------------------------------------
DWORD EVENT_LOG::ReportInfo( WORD    wCategoryId,
                             DWORD   dwEventId )
    {
    if (! ::ReportEventW(m_hEventLog,
                         EVENTLOG_INFORMATION_TYPE,
                         wCategoryId, // Message ID for category.
                         dwEventId,   // Message ID for event.
                         NULL,        // pSID (not used).
                         (WORD)0,     // Number of strings.
                         (DWORD)0,    // Binary Data Size.
                         NULL,        // Array of strings.
                         NULL   ) )   // Binary Data (none).
        {
        return GetLastError();
        }
    else
        {
        return 0;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\hint\stdafx.h ===
#include <stdio.h>

#include <windows.h>
#include <winsock2.h>
#include <af_irda.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irdatdi.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    irdatdi.h

Abstract:

    Library of routines that abstracts the tdi client interface to
    the IrDA stack. Used by rasirda.sys
    
Author:

    mbert 9-97    

--*/


#define IRDA_DEVICE_NAME        TEXT("\\Device\\IrDA")
#define IRDA_NAME               TEXT("IrDA")
#define TDI_ADDRESS_TYPE_IRDA   26 // wmz - the following belongs in tdi.h
#define IRDA_DEV_SERVICE_LEN    26
#define IRDA_MAX_DATA_SIZE      2044
#define TTP_RECV_CREDITS        14

typedef struct _TDI_ADDRESS_IRDA
{
	UCHAR   irdaDeviceID[4];
	CHAR 	irdaServiceName[IRDA_DEV_SERVICE_LEN];
} TDI_ADDRESS_IRDA, *PTDI_ADDRESS_IRDA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\dbgmsg.h ===
#define DBG_MSG_CNT         512
#define MAX_MSG_LEN         256
#define DBG_TIMER_INTERVAL  400

#if DBG

extern int DbgSettings;
extern int DbgOutput;

#define DBG_OUTPUT_DEBUGGER     1
#define DBG_OUTPUT_BUFFER       2

VOID        DbgMsgInit();
VOID        DbgMsgUninit();
VOID        DbgMsg(CHAR *Format, ...);
NTSTATUS    DbgMsgIrp(PIRP pIrp, PIO_STACK_LOCATION  pIrpSp);


#define DEBUGMSG(dbgs,format) (((dbgs) & DbgSettings) ? DbgMsg format:0)

#else

#define DEBUGMSG(d,f)   (0)
#define DbgMsgInit()    (0)
#define DbgMsgUninit()  (0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\hint\irda.cpp ===
// irda.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#define  MAX_ATTRIB_LEN  (64)

CHAR* Hint1[]={"PnP",
	           "PDA",
               "Computer",
			   "Printer",
			   "Modem",
			   "Fax",
			   "Lan",
			   "Extension"
};

CHAR* Hint2[]={"Phone",
               "File server",
			   "IrCOMM",
			   "Message",
			   "HTTP",
			   "OBEX",
			   "Unknown1",
			   "Extension"
};

char* Classes[]={"IrDA:IrCOMM",
                 "IrDA:IrCOMM",
                 "OBEX:IrXfer",
                 "OBEX",
                 "JetSend",
				 "IrNetv1",
				 "IrModem",
                 "IrLAN",
				 "IrLPT",
				 "IrLPT",
                 "IrTranPv1"
};

char* Attributes[]={"IrDA:TinyTP:LsapSel",
                    "IrDA:IRLMP:LsapSel",
                    "IrDA:TinyTP:LsapSel",
                    "IrDA:TinyTP:LsapSel",
                    "IrDA:TinyTP:LsapSel",
                    "IrDA:TinyTP:LsapSel",
                    "IrDA:TinyTP:LsapSel",
                    "IrDA:TinyTP:LsapSel",
                    "IrDA:IrLMP:LsapSel",
                    "IrDA:IrLMP:lsapSel",
                    "IrDA:TinyTP:LsapSel"
};

typedef enum {
	CLASS_IRCOMM,
	CLASS_OBEX,
	CLASS_Netv1,
	CLASS_IrModem
} IRDA_CLASSES;

int
QueryIASForBinaryData(
    SOCKET   QuerySock,
    u_char  *pirdaDeviceID,
    char    *pClassName,
    char    *pAttribute,
	BYTE    *Buffer,
	ULONG   *BufferLength
	)

{
    IAS_QUERY   IASQuery;
	int         QueryLength=sizeof(IASQuery);
    int         Result;

	ZeroMemory(&IASQuery,sizeof(IASQuery));

    lstrcpyA(
		IASQuery.irdaClassName,
		pClassName
		);

	lstrcpyA(
		IASQuery.irdaAttribName,
		pAttribute
		);

	CopyMemory(
		&IASQuery.irdaDeviceID[0],
		pirdaDeviceID,
		4
		);


	Result=getsockopt(
		QuerySock,
		SOL_IRLMP,
		IRLMP_IAS_QUERY,
		(char*)&IASQuery,
		&QueryLength
		);

	if (Result == SOCKET_ERROR) {

		return Result;

	}

    if (IASQuery.irdaAttribType != IAS_ATTRIB_OCTETSEQ) {

		return SOCKET_ERROR;
	}

    if (IASQuery.irdaAttribute.irdaAttribOctetSeq.Len > *BufferLength) {

		return SOCKET_ERROR;
	}

	CopyMemory(
		Buffer,
        &IASQuery.irdaAttribute.irdaAttribOctetSeq.OctetSeq[0],
        IASQuery.irdaAttribute.irdaAttribOctetSeq.Len
		);

	*BufferLength=IASQuery.irdaAttribute.irdaAttribOctetSeq.Len;

    return 0;
}


int
QueryIASForInteger(SOCKET   QuerySock,
                   u_char  *pirdaDeviceID,
                   char    *pClassName,
                   char    *pAttribute,
                   int     *pValue)
{
    BYTE        IASQueryBuff[sizeof(IAS_QUERY) - 3 + MAX_ATTRIB_LEN];
    int          IASQueryLen = sizeof(IASQueryBuff);
    PIAS_QUERY  pIASQuery   = (PIAS_QUERY) &IASQueryBuff;


    RtlCopyMemory(&pIASQuery->irdaDeviceID[0], pirdaDeviceID, 4);

	lstrcpyA(&pIASQuery->irdaClassName[0],  pClassName);
	lstrcpyA(&pIASQuery->irdaAttribName[0], pAttribute);


    if (getsockopt(QuerySock, SOL_IRLMP, IRLMP_IAS_QUERY,
                   (char *) pIASQuery, &IASQueryLen) == SOCKET_ERROR)
    {
#if 0
        printf("IRMON: IAS Query [\"%s\",\"%s\"] failed\n",
                 pIASQuery->irdaClassName,
                 pIASQuery->irdaAttribName
				 );
#endif                 
        return SOCKET_ERROR;
    }

    if (pIASQuery->irdaAttribType != IAS_ATTRIB_INT)
    {
        printf("IRMON: IAS Query [\"%s\",\"%s\"] irdaAttribType not int (%d)\n",
                 pIASQuery->irdaClassName,
                 pIASQuery->irdaAttribName,
               pIASQuery->irdaAttribType
			   );
        return SOCKET_ERROR;
    }

    *pValue = pIASQuery->irdaAttribute.irdaAttribInt;

    return(0);
}

int
QueryIASForString(SOCKET    QuerySock,
                  u_char   *pirdaDeviceID,
                  char     *pClassName,
                  char     *pAttribute,
                  char     *pValue,
                  int      *pValueLen)          // including trailing NULL
{
    BYTE        IASQueryBuff[sizeof(IAS_QUERY) - 3 + MAX_ATTRIB_LEN];
    int         IASQueryLen = sizeof(IASQueryBuff);
    PIAS_QUERY  pIASQuery   = (PIAS_QUERY) &IASQueryBuff;


    RtlCopyMemory(&pIASQuery->irdaDeviceID[0], pirdaDeviceID, 4);

	lstrcpyA(&pIASQuery->irdaClassName[0],  pClassName);
	lstrcpyA(&pIASQuery->irdaAttribName[0], pAttribute);

 
    if (getsockopt(QuerySock, SOL_IRLMP, IRLMP_IAS_QUERY,
                   (char *) pIASQuery, &IASQueryLen) == SOCKET_ERROR)
    {
//        DEBUGMSG(("IRMON: IAS Query [\"%s\",\"%s\"] failed %ws\n",
//                 pIASQuery->irdaClassName,
//                 pIASQuery->irdaAttribName,
//                 GetLastErrorText()));
        return SOCKET_ERROR;
    }

    if (pIASQuery->irdaAttribType != IAS_ATTRIB_STR)
    {
//        DEBUGMSG(("IRMON: IAS Query [\"%s\",\"%s\"] irdaAttribType not string (%d)\n",
//                 pIASQuery->irdaClassName,
//                 pIASQuery->irdaAttribName,
//                 pIASQuery->irdaAttribType));
        return SOCKET_ERROR;
    }

    if (pIASQuery->irdaAttribute.irdaAttribUsrStr.CharSet != LmCharSetASCII)
    {
//        DEBUGMSG(("IRMON: IAS Query [\"%s\",\"%s\"] CharSet not ASCII (%d)\n",
//                 pIASQuery->irdaClassName,
//                 pIASQuery->irdaAttribName,
//                 pIASQuery->irdaAttribute.irdaAttribUsrStr.CharSet));
        return SOCKET_ERROR;

    }

    // set ValueLen to data bytes to copy, allow room for NULL
    if (pIASQuery->irdaAttribute.irdaAttribUsrStr.Len + 1 >= (unsigned) *pValueLen)
    {
        // allow room for NULL
        (*pValueLen)--;
    }
    else
    {
        *pValueLen = pIASQuery->irdaAttribute.irdaAttribUsrStr.Len;
    }

    RtlCopyMemory(pValue, pIASQuery->irdaAttribute.irdaAttribUsrStr.UsrStr, *pValueLen);

    // append NULL
    pValue[(*pValueLen)++] = 0;

    return(0);
}


int __cdecl main(int argc, char* argv[])
{

	SOCKET  SocketHandle=INVALID_SOCKET;
    WORD        WSAVerReq = MAKEWORD(2,0);
    WSADATA     WSAData;
    INT         Result;
    UCHAR       Temp[4096];
    PDEVICELIST DeviceList=(PDEVICELIST)Temp;
    int         DeviceListSize=sizeof(Temp);
    UINT        i;

    Result=WSAStartup(
        WSAVerReq,
        &WSAData
        );

    if (Result != 0) {

        printf("WSAStartUp() Failed %d\n",Result);

        goto CleanUp;
    }

	SocketHandle=socket(
        AF_IRDA,
        SOCK_STREAM,
        0
        );

    if (SocketHandle == INVALID_SOCKET) {

        printf("socket() faled %d\n",WSAGetLastError());
    }


    Result=getsockopt(
        SocketHandle,
        SOL_IRLMP,
        IRLMP_ENUMDEVICES,
        (char*)DeviceList,
        &DeviceListSize
        );

    if (Result == SOCKET_ERROR) {

        goto CleanUp;
    }

	printf("\n%d Irda devices found\n\n",DeviceList->numDevice);

    for (i=0; i< DeviceList->numDevice; i++) {

        PIRDA_DEVICE_INFO    DeviceInfo=&DeviceList->Device[i];
        PULONG               DeviceId=(PULONG)&DeviceInfo->irdaDeviceID;
		int                  LsapSel=-1;
		UINT                 j;
		int                  k;

        if ((DeviceInfo->irdaCharSet == 0xff)) {

		    wprintf(L"Device Name(UNICODE): %s\n",&DeviceInfo->irdaDeviceName[0]);

		} else {

            printf("Device Name(ANSI): %s\n",&DeviceInfo->irdaDeviceName[0]);
		}

		printf("Hints:\n");

		for (j=0; j<7; j++) {

			if ( DeviceInfo->irdaDeviceHints1 & (1 << j)) {
				printf("\t%s\n",Hint1[j]);
            }   
        }


		for (j=0; j<7; j++) {

			if ( DeviceInfo->irdaDeviceHints2 & (1 << j)) {
				printf("\t%s\n",Hint2[j]);
            }   
        }

        printf("\nDoing IAS queries\n");

        for (j=0; j<sizeof(Classes)/sizeof(char*); j++) {

            Result=QueryIASForInteger(
			    SocketHandle,
			    &DeviceInfo->irdaDeviceID[0],
                Classes[j],
			    Attributes[j],
			    &LsapSel
			    );

            if (Result == 0) {

                printf("\tResult for %13s -- %s : %d\n",Classes[j],Attributes[j],LsapSel);

		    }
		}

        if ((DeviceInfo->irdaDeviceHints2 & 4) || (DeviceInfo->irdaDeviceHints1 & LM_HB1_Printer)) {
 
			BYTE   Buffer[4096];
			ULONG  BufferLength=sizeof(Buffer);
            CHAR   InstanceName[256];
            int    InstanceLength;

            printf("\nChecking for IrComm Parameters\n");

            Result=QueryIASForBinaryData(
				SocketHandle,
                &DeviceInfo->irdaDeviceID[0],
                Classes[0],
			    "Parameters",
				&Buffer[0],
				&BufferLength
				);

			if (Result == 0) {

				ULONG   k;

				for (k=0; k < BufferLength; ) {

					switch (Buffer[k]) {

			    		case 0:
							printf("\tServiceType- %s, %s, %s, %s\n",
								Buffer[k+2] & 1 ? "3 Wire raw" : "",
                                Buffer[k+2] & 2 ? "3 Wire" : "",
                                Buffer[k+2] & 4 ? "9 Wire" : "",
                                Buffer[k+2] & 8 ? "Centronics" : ""
				    			);
							break;

						case 1:

							printf("\tPort Type- %s, %s\n",
								Buffer[k+2] & 1 ?  "Serial" : "",
                                Buffer[k+2] & 2 ?  "Parallel" : ""
					    		);

							break;

						case 2:

							printf("\tPort Name- %s\n",&Buffer[k+2]);
							break;

						default:

                            printf("\tPI=%x, pl=%d\n",Buffer[k],Buffer[k+1]);
							break;

					}

					k+=Buffer[k+1]+2;

                }
        	}

            InstanceLength=sizeof(InstanceName);

            Result=QueryIASForString(
				SocketHandle,
                &DeviceInfo->irdaDeviceID[0],
                Classes[0],
			    "IrDA:IrLMP:InstanceName",
				&InstanceName[0],
				&InstanceLength
				);

			if (Result == 0) {

                printf("\tInstanceName: %s\n",InstanceName);
			}

        }
        if (1) {
        //if (DeviceInfo->irdaDeviceHints1 & LM_HB1_PnP) {

			CHAR    DeviceId[100];
			int     BufferSize=sizeof(DeviceId);
			int     CompatIds=0;

            printf("\nChecking PnP parameters\n");

            Result=QueryIASForString(
			    SocketHandle,
			    &DeviceInfo->irdaDeviceID[0],
                "PnP",
			    "Name",
                DeviceId,
				&BufferSize
				);

			if (Result == 0) {

				printf("\tName: %s\n",DeviceId);
			}


            BufferSize=sizeof(DeviceId);

            Result=QueryIASForString(
			    SocketHandle,
			    &DeviceInfo->irdaDeviceID[0],
                "PnP",
			    "Manufacturer",
                DeviceId,
				&BufferSize
				);

			if (Result == 0) {

				printf("\tManufactured by: %s\n",DeviceId);
			}


            BufferSize=sizeof(DeviceId);


            Result=QueryIASForString(
			    SocketHandle,
			    &DeviceInfo->irdaDeviceID[0],
                "PnP",
			    "DeviceID",
                DeviceId,
				&BufferSize
				);

			if (Result == 0) {

				printf("\tPnP device id is %s\n",DeviceId);
			}

            Result=QueryIASForInteger(
			    SocketHandle,
			    &DeviceInfo->irdaDeviceID[0],
                "PnP",
			    "CompCnt",
			    &CompatIds
				);

			if (Result == 0) {

				printf("\tDevice has %d compatible ids\n",CompatIds);
			}


			for (k=0; k<CompatIds; k++) {

                CHAR    Attribute[100];

				wsprintfA(Attribute,"Comp#%02d",k+1);
 
                BufferSize=sizeof(DeviceId);

                Result=QueryIASForString(
			        SocketHandle,
			        &DeviceInfo->irdaDeviceID[0],
                    "PnP",
			        Attribute,
                    DeviceId,
				    &BufferSize
				    );

			    if (Result == 0) {

				    printf("\tCompatible id for %s, device id is %s\n",Attribute,DeviceId);

				} else {

   				    printf("\tcould not get Compatible id for %s\n",Attribute);
				}


            }

		}


		printf("\n");
		

    }








CleanUp:


	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\decdirda.h ===
// returns pointers pOutStr
TCHAR *DecodeIRDA(int  *pFrameType,// return frame type (-1 = bad frame)
				UCHAR *pFrameBuf, // pointer to buffer containing IRLAP frame
				UINT FrameLen, 	 // length of buffer 
				TCHAR *pOutStr,	 // string where decode packet is placed	
                UINT DecodeLayer,// 2-LAP only, 3-LAP/LMP, 4-LAP/LMP/TTP
				int fNoConnAddr,// TRUE->Don't show conn address in str
                int DispMode    // DISP_ASCII/HEX/BOTH
);

#define IAS_SEL     0

#define DISP_ASCII  1
#define DISP_HEX    2
#define DISP_BOTH   3

extern UINT BaudBitField;

#define IRLAP_BOF 0xC0
#define IRLAP_EOF 0xC1
#define IRLAP_ESC 0x7D
#define IRLAP_COMP_BIT 0x20 

#define IRLAP_BROADCAST      0xfe
#define _IRLAP_CMD           0x01
#define _IRLAP_RSP           0x00

#define IRLAP_I_FRM          0x00
#define IRLAP_S_FRM          0x01
#define IRLAP_U_FRM          0x03

/*
** Unnumbered Frame types with P/F bit set to 0
*/
#define IRLAP_UI             0x03
#define IRLAP_XID_CMD        0x2f
#define IRLAP_TEST           0xe3
#define IRLAP_SNRM           0x83
#define IRLAP_DISC           0x43
#define IRLAP_UA             0x63
#define IRLAP_FRMR           0x87
#define IRLAP_DM             0x0f
#define IRLAP_XID_RSP        0xaf

/*
** Supervisory Frames
*/
#define IRLAP_RR             0x01
#define IRLAP_RNR            0x05
#define IRLAP_REJ            0x09
#define IRLAP_SREJ           0x0d


#define IRLAP_GET_ADDR(addr)       (addr >> 1)
#define IRLAP_GET_CRBIT(addr)      (addr & 1) 
#define IRLAP_GET_PFBIT(cntl)      ((cntl >>4) & 1)
#define IRLAP_GET_UCNTL(cntl)      (cntl & 0xEF)
#define IRLAP_GET_SCNTL(cntl)      (cntl & 0x0F)
#define IRLAP_FRAME_TYPE(cntl)     (cntl & 0x01 ? (cntl & 3) : 0)
#define IRLAP_GET_NR(cntl)         ((cntl & 0xE0) >> 5)
#define IRLAP_GET_NS(cntl)         ((cntl & 0xE) >> 1)     

/*
** XID stuff
*/
#define XID_DISCV_FORMAT_ID     0x01
#define XID_NEGPARMS_FORMAT_ID 0x02

typedef struct 
{
    UCHAR    SrcAddr[4];
    UCHAR    DestAddr[4];
    UCHAR    NoOfSlots:2;
    UCHAR    GenNewAddr:1;
    UCHAR    Reserved:5;
    UCHAR    SlotNo;
    UCHAR    Version;
} XID_DISCV_FORMAT;

/*
** SNRM
*/
typedef struct
{
    UCHAR     SrcAddr[4];
    UCHAR     DestAddr[4];
    UCHAR     ConnAddr;
    UCHAR     FirstPI;
} SNRM_FORMAT;

/*
** UA
*/
typedef struct
{
    UCHAR     SrcAddr[4];
    UCHAR     DestAddr[4];
    UCHAR     FirstPI;
} UA_FORMAT;

/*
** LM-PDU stuff
*/
typedef struct
{
    UCHAR    DLSAP_SEL:7;    
    UCHAR    CntlBit:1;
    UCHAR    SLSAP_SEL:7;
    UCHAR    RsvrdBi1:1;    
} LM_HEADER;

/* LM-PDU frame types */
#define LM_PDU_CNTL_FRAME 1
#define LM_PDU_DATA_FRAME 0

typedef struct
{
    UCHAR    OpCode:7;
    UCHAR    ABit:1;
} LM_CNTL_FORMAT;

/* Opcodes */
#define LM_PDU_CONNECT    1
#define LM_PDU_DISCONNECT 2
#define LM_PDU_ACCESSMODE 3

#define LM_PDU_REQUEST 0
#define LM_PDU_CONFIRM 1

#define LM_PDU_SUCCESS        0
#define LM_PDU_FAILURE        1
#define LM_PDU_UNSUPPORTED 0xFF

#define LM_PDU_MULTIPLEXED 0
#define LM_PDU_EXCLUSIVE   1

/* Max disconnect reason code, see _LM_PDU_DscReason[] in decdirda.c */
#define LM_PDU_MAX_DSC_REASON  0x8

/*
** Negotiation Parameter Identifiers
*/
#define NEG_PI_BAUD        0x01
#define NEG_PI_MAX_TAT     0x82
#define NEG_PI_DATA_SZ     0x83
#define NEG_PI_WIN_SZ      0x84
#define NEG_PI_BOFS        0x85
#define NEG_PI_MIN_TAT     0x86
#define NEG_PI_DISC_THRESH 0x08

// Tiny TP!

#define TTP_PFLAG_NO_PARMS  0
#define TTP_PFLAG_PARMS     1

#define TTP_MBIT_NOT_FINAL  1
#define TTP_MBIT_FINAL      0

typedef struct
{
    UCHAR    InitialCredit : 7;
    UCHAR    ParmFlag      : 1;
} TTP_CONN_HEADER;

typedef struct
{
    UCHAR    AdditionalCredit : 7;
    UCHAR    MoreBit          : 1;
} TTP_DATA_HEADER;

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
#define net_short(x) 		((((x)&0xff) << 8) | (((x)&0xff00) >> 8))

#define net_long(x) 		(((((DWORD UNALIGNED)(x))&0xffL)<<24) | \
							((((DWORD UNALIGNED)(x))&0xff00L)<<8) | \
							((((DWORD UNALIGNED)(x))&0xff0000L)>>8) | \
							((((DWORD UNALIGNED)(x))&0xff000000L)>>24))

#endif
typedef struct
{
    UCHAR   OpCode  : 6;
    UCHAR   Ack     : 1;
    UCHAR   Last    : 1;
} IAS_CNTL_HEADER;

#define LM_GETVALUEBYCLASS  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\devlist.h ===
#define MAX_OBEX_DEVICES    (64)
#if 0

#define MAX_DEVICE_NAME_LENGTH  (64)

typedef enum {
    TYPE_IRDA,
    TYPE_IP

} OBEX_DEVICE_TYPE;

typedef struct _OBEX_DEVICE_SPECIFIC {

    union {

        struct {

            ULONG           DeviceId;
            UCHAR           Hint1;
            UCHAR           Hint2;
            BOOL            ObexSupport;

        } Irda;

        struct {

            ULONG           IpAddress;
            USHORT          Port;

        } Ip;
    };

} OBEX_DEVICE_SPECIFIC;

typedef struct _OBEX_DEVICE {

    OBEX_DEVICE_TYPE        DeviceType;
    WCHAR                   DeviceName[MAX_DEVICE_NAME_LENGTH];

    OBEX_DEVICE_SPECIFIC    DeviceSpecific;

} OBEX_DEVICE, *POBEX_DEVICE;





typedef struct _OBEX_DEVICE_LIST {

    ULONG        DeviceCount;

    OBEX_DEVICE  DeviceList[1];

} OBEX_DEVICE_LIST, *POBEX_DEVICE_LIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irerr.h ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irerr.h
*
*  Description: IR error defines
*
*  Author: mmiller
*
*  Date:   4/25/95
*
*/

#ifndef SUCCESS
#define SUCCESS 0
#endif

#define IR_ERROR_BASE       20000
#define IRLAP_ERROR_BASE    IR_ERROR_BASE + 100
#define IRLMP_ERROR_BASE    IR_ERROR_BASE + 200

#define IRMAC_TX_OVERFLOW                       (IR_ERROR_BASE+0)
#define IRMAC_WRITE_FAILED                      (IR_ERROR_BASE+1)
#define IRMAC_READ_FAILED                       (IR_ERROR_BASE+2)
#define IRMAC_BAD_FCS                           (IR_ERROR_BASE+3)
#define IRMAC_RX_OVERFLOW                       (IR_ERROR_BASE+4)
#define IRMAC_TIMEOUT                           (IR_ERROR_BASE+5)
#define IRMAC_BAD_PRIM                          (IR_ERROR_BASE+6)
#define IRMAC_BAD_OP                            (IR_ERROR_BASE+7)
#define IRMAC_OPEN_PORT_FAILED                  (IR_ERROR_BASE+8)
#define IRMAC_SET_BAUD_FAILED                   (IR_ERROR_BASE+9)
#define IRMAC_MALLOC_FAILED                     (IR_ERROR_BASE+10)
#define IRMAC_ALREADY_INIT                      (IR_ERROR_BASE+11)
#define IRMAC_BAD_TIMER                         (IR_ERROR_BASE+12)
#define IRMAC_NOT_INITIALIZED                   (IR_ERROR_BASE+13)
#define IRMAC_LINK_RESET                        (IR_ERROR_BASE+14)

#define IRLAP_NOT_INITIALIZED                   (IRLAP_ERROR_BASE + 0)
#define IRLAP_BAD_PRIM                          (IRLAP_ERROR_BASE + 1)
#define IRLAP_BAD_STATE                         (IRLAP_ERROR_BASE + 2)
#define IRLAP_BAD_OPSTATUS                      (IRLAP_ERROR_BASE + 3)
#define IRLAP_BAD_OP                            (IRLAP_ERROR_BASE + 4)
#define IRLAP_MALLOC_FAILED                     (IRLAP_ERROR_BASE + 5)
#define IRLAP_BAUD_NEG_ERR                      (IRLAP_ERROR_BASE + 6)
#define IRLAP_DISC_NEG_ERR                      (IRLAP_ERROR_BASE + 7)
#define IRLAP_MAXTAT_NEG_ERR	                (IRLAP_ERROR_BASE + 8)
#define IRLAP_MINTAT_NEG_ERR	                (IRLAP_ERROR_BASE + 9)
#define IRLAP_DATASIZE_NEG_ERR	                (IRLAP_ERROR_BASE + 10)
#define IRLAP_WINSIZE_NEG_ERR	                (IRLAP_ERROR_BASE + 11)
#define IRLAP_BOFS_NEG_ERR                      (IRLAP_ERROR_BASE + 12)
#define IRLAP_LINECAP_ERR                       (IRLAP_ERROR_BASE + 13)
#define IRLAP_BAD_SLOTNO                        (IRLAP_ERROR_BASE + 14)
#define IRLAP_XID_CMD_NOT_P                     (IRLAP_ERROR_BASE + 15)
#define IRLAP_SNRM_NO_QOS                       (IRLAP_ERROR_BASE + 16)
#define IRLAP_UA_NO_QOS                         (IRLAP_ERROR_BASE + 17)
#define IRLAP_XID_CMD_RSP                       (IRLAP_ERROR_BASE + 18)
#define IRLAP_SNRM_NOT_CMD                      (IRLAP_ERROR_BASE + 19)
#define IRLAP_SNRM_NOT_P                        (IRLAP_ERROR_BASE + 20)
#define IRLAP_UA_NOT_RSP                        (IRLAP_ERROR_BASE + 21)
#define IRLAP_UA_NOT_F                          (IRLAP_ERROR_BASE + 22)
#define IRLAP_MSG_LIST_EMPTY                    (IRLAP_ERROR_BASE + 23)
#define IRLAP_MSG_LIST_FULL                     (IRLAP_ERROR_BASE + 24)
#define IRLAP_RXD_BAD_FRAME                     (IRLAP_ERROR_BASE + 25)
#define IRLAP_BAD_CRBIT_IFRAME                  (IRLAP_ERROR_BASE + 26)
#define IRLAP_BAD_DATA_REQUEST                  (IRLAP_ERROR_BASE + 27)
#define IRLAP_DISC_CMD_RSP                      (IRLAP_ERROR_BASE + 28)
#define IRLAP_DISC_CMD_NOT_P                    (IRLAP_ERROR_BASE + 29)
#define IRLAP_DM_RSP_NOT_F                      (IRLAP_ERROR_BASE + 30)
#define IRLAP_DM_RSP_CMD                        (IRLAP_ERROR_BASE + 31)
#define IRLAP_FRMR_RSP_CMD                      (IRLAP_ERROR_BASE + 32)
#define IRLAP_FRMR_RSP_NOT_F                    (IRLAP_ERROR_BASE + 33)
#define IRLAP_BAD_QOS                           (IRLAP_ERROR_BASE + 34)
#define IRLAP_NULL_MSG                          (IRLAP_ERROR_BASE + 35)
#define IRLAP_BAD_MAX_SLOT                      (IRLAP_ERROR_BASE + 36)
#define IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR  (IRLAP_ERROR_BASE + 37)
#define IRLAP_REMOTE_CONNECTION_IN_PROGRESS_ERR (IRLAP_ERROR_BASE + 38)
#define IRLAP_REMOTE_BUSY                       (IRLAP_ERROR_BASE + 39)

#define IRLMP_NOT_INITIALIZED                   (IRLMP_ERROR_BASE + 0)
#define IRLMP_LSAP_BAD_STATE                    (IRLMP_ERROR_BASE + 1)
#define IRLMP_USER_DATA_LEN_EXCEEDED            (IRLMP_ERROR_BASE + 2)
#define IRLMP_LINK_IN_USE                       (IRLMP_ERROR_BASE + 3)
#define IRLMP_TIMER_START_FAILED                (IRLMP_ERROR_BASE + 4)
#define IRLMP_ALLOC_FAILED                      (IRLMP_ERROR_BASE + 5)
#define IRLMP_LINK_BAD_STATE                    (IRLMP_ERROR_BASE + 6)
#define IRLMP_LSAP_SEL_IN_USE                   (IRLMP_ERROR_BASE + 7)
#define IRLMP_CREDIT_CALC_ERROR                 (IRLMP_ERROR_BASE + 8)
#define IRLMP_NO_TX_CREDIT                      (IRLMP_ERROR_BASE + 9)
#define IRLMP_TX_DATA_LEN_EXCEEDED              (IRLMP_ERROR_BASE + 10)
#define IRLMP_DATA_IND_BAD_FRAME                (IRLMP_ERROR_BASE + 11)
#define IRLMP_SCHEDULE_EVENT_FAILED             (IRLMP_ERROR_BASE + 12)
#define IRLMP_LOCAL_BUSY                        (IRLMP_ERROR_BASE + 13)
#define IRLMP_BAD_PRIM                          (IRLMP_ERROR_BASE + 14)
#define IRLMP_BAD_ACCESSMODE                    (IRLMP_ERROR_BASE + 15)
#define IRLMP_LINK_BUSY                         (IRLMP_ERROR_BASE + 16)
#define IRLMP_IN_MULTIPLEXED_MODE               (IRLMP_ERROR_BASE + 17)
#define IRLMP_IN_EXCLUSIVE_MODE                 (IRLMP_ERROR_BASE + 18)
#define IRLMP_NOT_LSAP_IN_EXCLUSIVE_MODE        (IRLMP_ERROR_BASE + 19)
#define IRLMP_INVALID_LSAP_CB                   (IRLMP_ERROR_BASE + 20)
#define IRLMP_REMOTE_BUSY                       (IRLMP_ERROR_BASE + 21)
#define IRLMP_TIMER_STOP_FAILED                 (IRLMP_ERROR_BASE + 22)
#define IRLMP_BAD_IAS_OBJECT_ID                 (IRLMP_ERROR_BASE + 23)
#define IRLMP_NO_SUCH_IAS_CLASS                 (IRLMP_ERROR_BASE + 24)
#define IRLMP_NO_SUCH_IAS_ATTRIBUTE             (IRLMP_ERROR_BASE + 25)
#define IRLMP_UNSUPPORTED_IAS_OPERATION         (IRLMP_ERROR_BASE + 26)
#define IRLMP_BAD_IAS_QUERY_FROM_REMOTE         (IRLMP_ERROR_BASE + 27)
#define IRLMP_IAS_QUERY_IN_PROGRESS             (IRLMP_ERROR_BASE + 28)
#define IRLMP_UNSOLICITED_IAS_RESPONSE          (IRLMP_ERROR_BASE + 29)
#define IRLMP_SHUTDOWN_IN_PROGESS               (IRLMP_ERROR_BASE + 30)
#define IRLMP_BAD_DEV_ADDR                      (IRLMP_ERROR_BASE + 31)
#define IRLMP_IAS_ATTRIB_ALREADY_EXISTS         (IRLMP_ERROR_BASE + 32)
#define IRLMP_IAS_MAX_ATTRIBS_REACHED           (IRLMP_ERROR_BASE + 33)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irlap.h ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlap.h
*
*  Description: IRLAP Protocol and control block definitions
*
*  Author: mbert
*
*  Date:   4/15/95
*
*/

// Sequence number modulus
#define IRLAP_MOD                   8 
#define PV_TABLE_MAX_BIT            9

extern UINT vBaudTable[];
extern UINT vMaxTATTable[];
extern UINT vMinTATTable[];
extern UINT vDataSizeTable[];
extern UINT vWinSizeTable[];
extern UINT vBOFSTable[];
extern UINT vDiscTable[];
extern UINT vThreshTable[];
extern UINT vBOFSDivTable[];

VOID IrlapOpenLink(
    OUT PNTSTATUS       Status,
    IN  PIRDA_LINK_CB   pIrdaLinkCb,
    IN  IRDA_QOS_PARMS  *pQos,
    IN  UCHAR           *pDscvInfo,
    IN  int             DscvInfoLen,
    IN  UINT            MaxSlot,
    IN  UCHAR           *pDeviceName,
    IN  int             DeviceNameLen,
    IN  UCHAR           CharSet);

UINT IrlapDown(IN PVOID Context,
               IN PIRDA_MSG);

VOID IrlapUp(IN PVOID Context,
             IN PIRDA_MSG);

VOID IrlapCloseLink(PIRDA_LINK_CB pIrdaLinkCb);

UINT IrlapGetQosParmVal(UINT[], UINT, UINT *);

VOID IrlapDeleteInstance(PVOID Context);

VOID IrlapGetLinkStatus(PIRLINK_STATUS);

BOOLEAN IrlapConnectionActive(PVOID Context);

void IRLAP_PrintState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irlaplog.h ===
/*****************************************************************************
* 
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlaplog.h 
*
*  Description: IRLAP state machine logging and errors
*
*  Author: mbert
*
*  Date:   4/15/95
*
*/

#if DBG

extern TCHAR *IRDA_PrimStr[];
extern TCHAR *IRLAP_StateStr[];
extern TCHAR *MAC_OpStr[];
extern TCHAR *IRDA_TimerStr[];
extern TCHAR *IRDA_StatStr[];

#define SPRINT_BUF_LEN				1000

#define EXPAND_ADDR(Addr)	        Addr[0],Addr[1],Addr[2],Addr[3]

void IRLAP_EventLogStart(PIRLAP_CB, TCHAR *pFormat, ...);
void __cdecl IRLAP_LogAction(PIRLAP_CB, TCHAR *pFormat, ...);
void IRLAP_EventLogComplete(PIRLAP_CB);
TCHAR *FrameToStr(IRDA_MSG *);

#define IRLAP_LOG_START(X)			    IRLAP_EventLogStart X
#define IRLAP_LOG_ACTION(X) 			IRLAP_LogAction X
#define IRLAP_LOG_COMPLETE(X)			IRLAP_EventLogComplete(X)

#else

#define IRLAP_LOG_START(X)			    (0)
#define IRLAP_LOG_ACTION(X)			   	(0)
#define IRLAP_LOG_COMPLETE(X)			(0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irda.h ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irda.h
*
*  Description: Definitions used across the IRDA stack
*
*  Author: mbert
*
*  Date:   4/15/95
*
*  This file primarily defines the IRDA message (IRDA_MSG) used for 
*  communicating with the stack and communication between the layers
*  of the stack. IRDA_MSG provides the following services: 
*       MAC_CONTROL_SERVICE
*       IRLAP_DISCOVERY_SERVICE   
*       IRDA_DISCONNECT_SERVICE   
*       IRDA_CONNECT_SERVICE      
*       IRDA_DATA_SERVICE
*       IRLMP_ACCESSMODE_SERVICE
*       IRLMP_IAS_SERVICE
*
*  IRDA_MSG usage:
*
*  +-------+
*  | IRLAP |
*  +-------+
*      | 
*      |  IrmacDown(IRDA_MSG)
*     \|/
*  +-------+
*  | IRMAC |
*  +-------+
*  |*************************************************************************|
*  | Prim                     | MsgType and parameters                       |
*  |=========================================================================|
*  | MAC_DATA_REQ             | IRDA_DATA_SERVICE                            |
*  |                          |   o IRDA_MSG_pHdrRead = start of IRDA headers|
*  |                          |   o IRDA_MSG_pHdrWrite = end of header       |
*  |                          |   o IRDA_MSG_pRead = start of data           |
*  |                          |   o IRDA_MSG_pWrite = end of data            |
*  |--------------------------+----------------------------------------------|
*  | MAC_DATA_RESP            | no parms (completetion of DATA_IND)          |
*  |--------------------------+----------------------------------------------|
*  | MAC_CONTROL_REQ          | MAC_CONTROL_SERVICE                          |
*  |                          |   o IRDA_MSG_Op = MAC_INITIALIZIE_LINK       |
*  |                          |     - IRDA_MSG_Port                          |
*  |                          |     - IRDA_MSG_Baud                          |
*  |                          |     - IRDA_MSG_MinTat = min turn time        |
*  |                          |     - IRDA_MSG_NumBOFs = # added when tx'ing |
*  |                          |     - IRDA_MSG_DataSize = max rx frame       |
*  |                          |     - IRDA_MSG_SetIR = TRUE/FALSE (does an   |
*  |                          |         EscapeComm(SETIR) to select int/ext  |
*  |                          |         dongle)                              |
*  |                          |   o IRDA_MSG_Op = MAC_MEDIA_SENSE            |
*  |                          |     - IRDA_MSG_SenseTime (in ms)             |
*  |                          |   o IRDA_MSG_Op = MAC_RECONFIG_LINK          |
*  |                          |     - IRDA_MSG_Baud                          |
*  |                          |     - IRDA_MSG_NumBOFs = # added when tx'ing |
*  |                          |     - IRDA_MSG_DataSize = max rx frame       |
*  |                          |     - IRDA_MSG_MinTat = min turn time        |
*  |                          |   o IRDA_MSG_OP = MAC_CLOSE_LINK             |
*  |-------------------------------------------------------------------------|
*
*  +-------+
*  | IRLAP |
*  +-------+
*     /|\
*      |  IrlapUp(IRDA_MSG)
*      | 
*  +-------+
*  | IRMAC |
*  +-------+
*  |*************************************************************************|
*  | Prim                     | MsgType and parameters                       |
*  |=========================================================================|
*  | MAC_DATA_IND             | IRDA_DATA_SERVICE                            |
*  |                          |   o IRDA_MSG_pRead  = start of frame         |
*  |                          |                       (includes IRLAP header)|
*  |                          |   o IRDA_MSG_pWrite = end of frame           |
*  |                          |                       (excludes FCS)         |
*  |--------------------------+----------------------------------------------|
*  | MAC_CONTROL_CONF         | MAC_CONTROL_SERVICE                          |
*  |                          |   o IRDA_MSG_Op = MAC_MEDIA_SENSE            |
*  |                          |     - IRDA_MSG_OpStatus = MAC_MEDIA_BUSY     |
*  |                          |                           MAC_MEDIA_CLEAR    |
*  |--------------------------+----------------------------------------------|
*  | MAC_DATA_CONF            | no parms                                     |
*  |-------------------------------------------------------------------------|
*
*  +-------+
*  | IRLMP |
*  +-------+
*      | 
*      |  IrlapDown(IRDA_MSG)
*     \|/
*  +-------+
*  | IRLAP |
*  +-------+
*  |*************************************************************************|
*  | Prim                     | MsgType and parameters                       |
*  |=========================================================================|
*  | IRLAP_DISCOVERY_REQ      | IRLAP_DISCOVERY_SERVICE                      |
*  |  IRLAP_Down() returns    |   o IRDA_MSG_SenseMedia = TRUE/FALSE         |
*  |  IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR or                              |
*  |  IRLAP_REMOTE_CONNECT_IN_PROGRESS_ERR when indicated                    |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_CONNECT_REQ        | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_RemoteDevAddr                   |
*  |  IRLAP_Down() returns    |                                              |
*  |  IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR when indicated                  |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_CONNECT_RESP       | no parms                                     |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_DISCONNECT_REQ     | no parms                                     |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_DATA_REQ           | IRDA_DATA_SERVICE                            |
*  | IRLAP_UDATA_REQ          |   o IRDA_MSG_pHdrRead = start of IRLMP header|
*  |  IRLAP_Down() returns    |   o IRDA_MSG_pHdrWrite = end of header       |
*  |  IRLAP_REMOTE_BUSY to    |   o IRDA_MSG_pRead = start of data           |
*  |  to flow off LMP.        |   o IRDA_MSG_pWrite = end of data            |
*  |                          |   o IRDA_MSG_Expedited=TRUE/FALSE            |
*  |-------------------------------------------------------------------------|
*  | IRLAP_FLOWON_REQ         | no parms                                     |
*  |-------------------------------------------------------------------------|
*
*  +-------+
*  | IRLMP |
*  +-------+
*     /|\
*      |  IrlmpUp(IRDA_MSG)
*      | 
*  +-------+
*  | IRLAP |
*  +-------+
*  |*************************************************************************|
*  | Prim                     | MsgType and parameters                       |
*  |=========================================================================|
*  | IRLAP_DISCOVERY_IND      | IRLAP_DISCOVERY_SERVICE                      |
*  |                          |   o pDevList = Discovery info of device that |
*  |                          |                initiated discovery           |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_DISCOVERY_CONF     | IRLAP_DISCOVERY_SERVICE                      |
*  |                          |   o IRDA_MSG_pDevList = list of discovered   |
*  |                          |       devices, NULL when                     |
*  |                          |       status != IRLAP_DISCOVERY_COMPLETED    |
*  |                          |   o IRDA_MSG_DscvStatus =                    |
*  |                          |       MAC_MEDIA_BUSY                         |
*  |                          |       IRLAP_REMOTE_DISCOVERY_IN_PROGRESS     |
*  |                          |       IRLAP_DISCOVERY_COLLISION              |
*  |                          |       IRLAP_REMOTE_CONNECTION_IN_PROGRESS    |
*  |                          |       IRLAP_DISCOVERY_COMPLETED              |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_CONNECT_IND        | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_RemoteDevAddr                   |
*  |                          |   o IRDA_MSG_pQos = Negotiated QOS           |
*  |-------------------------------------------------------------------------|
*  | IRLAP_CONNECT_CONF       | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_pQos = Negotiated QOS, only when|
*  |                          |                     successful               |
*  |                          |   o IRDA_MSG_ConnStatus =                    |
*  |                          |                     IRLAP_CONNECTION_COMPLETE|
*  |--------------------------+----------------------------------------------|
*  | IRLAP_DISCONNECT_IND     | IRDA_DISCONNECT_SERVICE                      |
*  |                          |   o IRDA_MSG_DiscStatus =                    |
*  |                          |       IRLAP_DISCONNECT_COMPLETED             |
*  |                          |       IRLAP_REMOTED_INITIATED                |
*  |                          |       IRLAP_PRIMARY_CONFLICT                 |
*  |                          |       IRLAP_REMOTE_DISCOVERY_IN_PROGRESS     |
*  |                          |       IRLAP_NO_RESPONSE                      |
*  |                          |       IRLAP_DECLINE_RESET                    |
*  |                          |       MAC_MEDIA_BUSY                         |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_DATA_IND           | IRDA_DATA_SERVICE                            |
*  | IRLAP_UDATA_IND          |   o IRDA_MSG_pRead  = start of IRLMP packet  |
*  |                          |   o IRDA_MSG_pWrite = end of IRLMP packet    |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_DATA_CONF          | IRDA_DATA_SERVICE                            |
*  | IRLAP_UDATA_CONF         |   o IRDA_MSG_DataStatus =                    |
*  |                          |       ILAP_DATA_REQUEST_COMPLETED            |
*  |                          |       IRLAP_DATA_REQUEST_FAILED_LINK_RESET   |
*  |--------------------------+----------------------------------------------|
*  | IRLAP_STATUS_IND         | IRDA_MSG_pLinkStatus                         |
*  |-------------------------------------------------------------------------|
*
*      +-----+
*      | Tdi |
*      +-----+
*         |   
*         |  IrlmpDown(IRLMPContext, IRDA_MSG)
*        \|/
*     +-------+
*     | IRLMP |
*     +-------+
*  |*************************************************************************|
*  | Prim                     | MsgType and parameters                       |
*  |=========================================================================|
*  | IRLMP_DISCOVERY_REQ      | IRLAP_DISCOVERY_SERVICE                      |
*  |                          |   o IRDA_MSG_SenseMedia = TRUE/FALSE         |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_CONNECT_REQ        | IRDA_CONNECT_SERVICE                         |
*  |   IRLMP_Down() returns   |   o IRDA_MSG_RemoteDevAddr                   |
*  |   IRLMP_LINK_IN_USE      |   o IRDA_MSG_RemoteLsapSel                   |
*  |   when the requested     |   o IRDA_MSG_pQos (may be NULL)              |
*  |   connection is to a     |   o IRDA_MSG_pConnData                       |
*  |   remote device other    |   o IRDA_MSG_ConnDataLen                     |
*  |   than the one the link  |   o IRDA_MSG_LocalLsapSel                    |
*  |   is currently connected |   o IRDA_MSG_pContext                        |
*  |   or connecting to.      |   o IRDA_MSG_UseTtp                          |
*  |                          | * o IRDA_MSG_TtpCredits                      |
*  |                          |   o IRDA_MSG_MaxSDUSize - Max size that this |
*  |                          |        IRLMP client can receive.             |
*  |                          |                                              |
*  |                          | * even if not using TTP, TtpCredits are spec-|
*  |                          |   ified for flow control in exclusive mode   |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_CONNECT_RESP       | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_pConnData                       |
*  |                          |   o IRDA_MSG_ConnDataLen                     |
*  |                          |   o IRDA_MSG_pContext                        |
*  |                          |   o IRDA_MSG_MaxSDUSize - Max size that this |
*  |                          |        IRLMP client can receive.             |
*  |                          | * o IRDA_MSG_TtpCredits                      |
*  |                          | * see above                                  |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_DISCONNECT_REQ     | IRDA_DISCONNECT_SERVICE                      |
*  |                          |   o IRDA_MSG_pDiscData                       |
*  |                          |   o IRDA_MSG_DiscDataLen                     |
*  |                          |   o IRDA_MSG_pDiscContext                    |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_DATA/UDATA_REQ     | IRDA_DATA_SERVICE                            |
*  |   IRLMP_Down() may return|   o IRDA_MSG_pDataContext =ptr to NDIS_BUFFER|
*  |   IRLMP_REMOTE_BUSY,     |   o IRDA_MSG_IrCOMM_9Wire = TRUE/FALSE       |
*  |    when tx cred exhausted|                                              |
*  |    in multiplexed mode.  |                                              |
*  |   IRLAP_REMOTE_BUSY,     |                                              |
*  |    when remote IRLAP     |                                              |
*  |    flowed off in exclMode|                                              |
*  |   In either case the req |                                              |
*  |   was successful.        |                                              |
*  |-------------------------------------------------------------------------|
*  | IRLMP_ACCESSMODE_REQ     | IRLMP_ACCESSMODE_SERVICE                     |
*  |   IRLMP_Down() may return|   o IRDA_MSG_AccessMode = IRLMP_MULTIPLEXED  |
*  |   IRLMP_IN_EXCLUSIVE_MODE|                           IRLMP_EXCLUSIVE    |
*  |   if already in excl-mode|   o IRDA_MSG_IrLPTMode - TRUE, doesn't send  |
*  |   IRLMP_IN_MULTIPLEXED...|                          the Access PDU      |
*  |   if other LSAPs exist or|                                              |
*  |   requesting trans to this state when already in it.                    |
*  |-------------------------------------------------------------------------|
*  | IRLMP_MORECREDIT_REQ     | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_TtpCredits                      |
*  |-------------------------------------------------------------------------|
*  | IRLMP_GETVALUEBYCLASS_REQ| IRDA_IAS_SERVICE                             |
*  |                          |   o IRDA_MSG_pIasQuery                       |
*  |                          |   o IRDA_MSG_AttribLen                       |
*  |-------------------------------------------------------------------------|
*  | IRLMP_REGISTERLSAP_REQ   | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_LocalLsapSel                    |
*  |                          |   o IRDA_MSG_UseTtp                          |
*  |-------------------------------------------------------------------------|
*  | IRLMP_DEREGISTERLSAP_REQ | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_LocalLsapSel                    |
*  |-------------------------------------------------------------------------|
*  | IRLMP_ADDATTRIBUTE_REQ   | IRDA_IAS_SERVICE                             |
*  |                          |   o IRDA_MSG_pIasSet                         |
*  |                          |   o IRDA_MSG_pAttribHandle (return value)    |
*  |-------------------------------------------------------------------------|
*  | IRLMP_DELATTRIBUTE_REQ   | IRDA_IAS_SERVICE                             |
*  |                          |   o IRDA_MSG_AttribHandle                    |
*  |-------------------------------------------------------------------------|
*  | IRLMP_CLOSELSAP_REQ      | no parms                                     |
*  |-------------------------------------------------------------------------|
*  | IRLMP_FLUSHDSCV_REQ      | no parms                                     |
*  |-------------------------------------------------------------------------|
*  | IRLAP_STATUS_REQ         | IRDA_MSG_pLinkStatus                         |
*  |-------------------------------------------------------------------------|
*
*
*      +-----+
*      | Tdi |
*      +-----+
*        /|\   
*         |  TdiUp(TransportAPIContext, IRDA_MSG)
*         | 
*     +-------+
*     | IRLMP |
*     +-------+
*  |*************************************************************************|
*  | Prim                     | MsgType and parameters                       |
*  |=========================================================================|
*  | IRLMP_DISCOVERY_IND      | IRLAP_DISCOVERY_SERVICE                      |
*  |                          |   o pDevList = aged Discovery list           |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_DISCOVERY_CONF     | same as IRLAP_DISCOVERY_CONF. The device list|
*  |                          | however is the one maintained in IRLMP       |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_DISCONNECT_IND     | IRDA_DISCONNECT_SERVICE                      |
*  |                          |   o IRDA_MSG_DiscReason =                    |
*  |                          |       see IRLMP_DISC_REASON below            |
*  |                          |   o IRDA_MSG_pDiscData - may be NULL         |
*  |                          |   o IRDA_MSG_DiscDataLen                     |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_CONNECT_IND        | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_RemoteDevAddr                   |
*  |                          |   o IRDA_MSG_RemoteLsapSel;                  |
*  |                          |   o IRDA_MSG_LocalLsapSel;                   |
*  |                          |   o IRDA_MSG_pQos                            |
*  |                          |   o IRDA_MSG_pConnData                       |
*  |                          |   o IRDA_MSG_ConnDataLen                     |
*  |                          |   o IRDA_MSG_pContext                        |
*  |                          |   o IRDA_MSG_MaxSDUSize - Max size that this |
*  |                          |        IRLMP client can send to peer         |
*  |                          |   o IRDA_MSG_MaxPDUSize                      |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_CONNECT_CONF       | IRDA_CONNECT_SERVICE                         |
*  |                          |   o IRDA_MSG_pQos                            |
*  |                          |   o IRDA_MSG_pConnData                       |
*  |                          |   o IRDA_MSG_ConnDataLen                     |
*  |                          |   o IRDA_MSG_pContext                        |
*  |                          |   o IRDA_MSG_MaxSDUSize - Max size that this |
*  |                          |        IRLMP client can send to peer         |
*  |                          |   o IRDA_MSG_MaxPDUSize                      |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_DATA_IND           | IRDA_DATA_SERVICE                            |
*  |                          |   o IRDA_MSG_pRead  = start of User Data     |
*  |                          |   o IRDA_MSG_pWrite = end of User Data       |
*  |                          |   o IRDA_MSG_SegFlags = 0 or SEG_FINAL       |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_DATA_CONF          | IRDA_DATA_SERVICE                            |
*  |                          |   o IRDA_MSG_pDataContext =ptr to NDIS_BUFFER|
*  |                          |   o IRDA_MSG_DataStatus =                    |
*  |                          |       IRLMP_DATA_REQUEST_COMPLETED           |
*  |                          |       IRLMP_DATA_REQUEST_FAILED              |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_ACCESSMODE_IND     | IRLMP_ACCESSMODE_SERVICE                     |
*  |                          |   o IRDA_MSG_AccessMode =                    |
*  |                          |         IRLMP_EXCLUSIVE                      |
*  |                          |         IRLMP_MULTIPLEXED                    |
*  |--------------------------+----------------------------------------------|
*  | IRLMP_ACCESSMODE_CONF    | IRLMP_ACCESSMODE_SERVICE                     |
*  |                          |   o IRDA_MSG_AccessMode =                    |
*  |                          |         IRLMP_EXCLUSIVE                      |
*  |                          |         IRLMP_MULTIPLEXED                    |
*  |                          |   o IRDA_MSG_ModeStatus =                    |
*  |                          |         IRLMP_ACCESSMODE_SUCCESS             |
*  |                          |         IRLMP_ACCESSMODE_FAILURE             |
*  |--------------------------+----------------------------------------------|
*  |IRLMP_GETVALUEBYCLASS_CONF| IRDA_DATA_SERVICE                            |
*  |                          |   o IRDA_MSG_pIasQuery                       |
*  |                          |   o IRDA_MSG_IASStatus = An IRLMP_DISC_REASON|
*  |                          |                          (see below)         |
*  |-------------------------------------------------------------------------|
*/

#include <ntddk.h>
#include <cxport.h>
#include <ndis.h>
#include <af_irda.h>
#include <irerr.h>
#include <irmem.h>
#include <dbgmsg.h>
#include <refcnt.h>

#define IRDA_MSG_DATA_SIZE_INTERNAL sizeof(IRDA_MSG)+128 // can this be smaller?

//#define TEMPERAMENTAL_SERIAL_DRIVER // drivers busted. intercharacter delays cause
                                    // IrLAP to reset.


#if DBG
// Prototypes for Debugging Output
void IRDA_DebugOut (TCHAR *pFormat, ...);
void IRDA_DebugStartLog (void);
void IRDA_DebugEndLog (void *, void *);
#endif

//#define DBG_CHECKSUM    1
//#define DBG_BADDRIVER   1  

#define DBG_NDIS        0x00000002 // keep in sync with test\irdakdx
#define DBG_TIMER       0x00000004
#define DBG_IRMAC       0x00000008

#define DBG_IRLAP       0x00000010
#define DBG_IRLAPLOG    0x00000020
#define DBG_RXFRAME     0x00000040
#define DBG_TXFRAME     0x00000080

#define DBG_IRLMP       0x00000100
#define DBG_IRLMP_CONN  0x00000200
#define DBG_IRLMP_CRED  0x00000400
#define DBG_IRLMP_IAS   0x00000800

#define DBG_DISCOVERY   0x00001000
#define DBG_PRINT       0x00002000
#define DBG_ADDR        0x00004000

#define DBG_REF         0x00010000

#define DBG_TDI         0x00020000
#define DBG_TDI_IRP     0x00040000

#define DBG_ALLOC       0x10000000
#define DBG_FUNCTION    0x20000000
#define DBG_WARN        0x40000000
#define DBG_ERROR       0x80000000

#define STATIC 

typedef struct
{
    CTETimer            CteTimer;
    CTEEvent            CteEvent;
    VOID                (*ExpFunc)(PVOID Context);
    PVOID               Context;
    UINT                Timeout;
    BOOLEAN             Late;
    struct IrdaLinkCb   *pIrdaLinkCb;
#if DBG    
    char            *pName;
#endif    
} IRDA_TIMER, *PIRDA_TIMER;

typedef struct
{
    CTEEvent        CteEvent; // Must be first field
    VOID            (*Callback)(PVOID Context);
} IRDA_EVENT, *PIRDA_EVENT;

#define IRMAC_CONTEXT(ilcb)     ((ilcb)->IrmacContext)
#define IRLAP_CONTEXT(ilcb)     ((ilcb)->IrlapContext)
#define IRLMP_CONTEXT(ilcb)     ((ilcb)->IrlmpContext)

// Device/Discovery Information
#define IRLAP_DSCV_INFO_LEN             32
#define IRDA_DEV_ADDR_LEN               4

typedef struct
{
    LIST_ENTRY      Linkage;
    UCHAR           DevAddr[IRDA_DEV_ADDR_LEN];
    int             DscvMethod;
    int             IRLAP_Version;
    UCHAR           DscvInfo[IRLAP_DSCV_INFO_LEN];
    int             DscvInfoLen;
    int             NotSeenCnt;  // used by IRLMP to determine when to remove
                                 // the device from its list
} IRDA_DEVICE;

#define IRDA_NDIS_BUFFER_POOL_SIZE   8
#define IRDA_NDIS_PACKET_POOL_SIZE   8
#define IRDA_MSG_LIST_LEN            2
#define IRDA_MSG_DATA_SIZE           64

typedef struct
{
    LIST_ENTRY                  Linkage;
    struct irda_msg             *pMsg;
#if DBG_TIMESTAMP
    int                         TimeStamp[4];
#endif        
    MEDIA_SPECIFIC_INFORMATION  MediaInfo;
} IRDA_PROTOCOL_RESERVED, *PIRDA_PROTOCOL_RESERVED;

#define IRDA_RX_SYSTEM_THREAD

typedef struct IrdaLinkCb
{
    LIST_ENTRY      Linkage;
    PVOID           IrlapContext;
    PVOID           IrlmpContext;    
    NDIS_SPIN_LOCK  SpinLock;
    KMUTEX          Mutex;
    NDIS_HANDLE     UnbindContext;
    NDIS_HANDLE     NdisBindingHandle;
    NDIS_EVENT      OpenCloseEvent;
    NDIS_STATUS     OpenCloseStatus;
    NDIS_EVENT      ResetEvent;
    PVOID           PnpContext;
    IRDA_TIMER      MediaSenseTimer;
    int             MediaBusy;
    NDIS_HANDLE     BufferPool;
    NDIS_HANDLE     PacketPool;
    LIST_ENTRY      PacketList;
    LIST_ENTRY      TxMsgFreeList;
    int             TxMsgFreeListLen;
    LIST_ENTRY      RxMsgFreeList;
    int             RxMsgFreeListLen;
    LIST_ENTRY      RxMsgList;
#ifdef IRDA_RX_SYSTEM_THREAD
    KEVENT          EvRxMsgReady;
    KEVENT          EvKillRxThread;
    HANDLE          hRxThread;    
#else
    IRDA_EVENT      EvRxMsgReady;
#endif    
    int             RxMsgDataSize;
    UINT            ExtraBofs;   // These should be per connection for
    UINT            MinTat;      // multipoint
    BOOLEAN         WaitMinTat;
    BOOLEAN         LowPowerSt;
    LONG            SendOutCnt;
    PNET_PNP_EVENT  pNetPnpEvent;     
    REF_CNT         RefCnt;    
#if DBG
    int             LastTime;
    int             DelayedRxFrameCnt;
#endif        
} IRDA_LINK_CB, *PIRDA_LINK_CB;    

// IRLAP Quality of Service
#define BIT_0       1
#define BIT_1       2
#define BIT_2       4
#define BIT_3       8
#define BIT_4       16
#define BIT_5       32
#define BIT_6       64
#define BIT_7       128
#define BIT_8       256

#define BPS_2400            BIT_0   // Baud Rates
#define BPS_9600            BIT_1
#define BPS_19200           BIT_2
#define BPS_38400           BIT_3
#define BPS_57600           BIT_4
#define BPS_115200          BIT_5
#define BPS_4000000         BIT_8

#define MAX_TAT_500         BIT_0   // Maximum Turnaround Time (millisecs)
#define MAX_TAT_250         BIT_1
#define MAX_TAT_100         BIT_2
#define MAX_TAT_50          BIT_3
#define MAX_TAT_25          BIT_4
#define MAX_TAT_10          BIT_5
#define MAX_TAT_5           BIT_6

#define DATA_SIZE_64        BIT_0   // Data Size (bytes)
#define DATA_SIZE_128       BIT_1
#define DATA_SIZE_256       BIT_2
#define DATA_SIZE_512       BIT_3
#define DATA_SIZE_1024      BIT_4
#define DATA_SIZE_2048      BIT_5

#define FRAMES_1            BIT_0   // Window Size
#define FRAMES_2            BIT_1
#define FRAMES_3            BIT_2
#define FRAMES_4            BIT_3
#define FRAMES_5            BIT_4
#define FRAMES_6            BIT_5
#define FRAMES_7            BIT_6

#define BOFS_48             BIT_0   // Additional Beginning of Frame Flags
#define BOFS_24             BIT_1
#define BOFS_12             BIT_2
#define BOFS_5              BIT_3
#define BOFS_3              BIT_4
#define BOFS_2              BIT_5
#define BOFS_1              BIT_6
#define BOFS_0              BIT_7

#define MIN_TAT_10          BIT_0   // Minumum Turnaround Time (millisecs)
#define MIN_TAT_5           BIT_1
#define MIN_TAT_1           BIT_2
#define MIN_TAT_0_5         BIT_3
#define MIN_TAT_0_1         BIT_4
#define MIN_TAT_0_05        BIT_5
#define MIN_TAT_0_01        BIT_6
#define MIN_TAT_0           BIT_7

#define DISC_TIME_3         BIT_0   // Link Disconnect/Threshold Time (seconds)
#define DISC_TIME_8         BIT_1
#define DISC_TIME_12        BIT_2
#define DISC_TIME_16        BIT_3
#define DISC_TIME_20        BIT_4
#define DISC_TIME_25        BIT_5
#define DISC_TIME_30        BIT_6
#define DISC_TIME_40        BIT_7

typedef struct
{
    UINT        bfBaud;
    UINT        bfMaxTurnTime;
    UINT        bfDataSize;
    UINT        bfWindowSize;
    UINT        bfBofs;
    UINT        bfMinTurnTime;
    UINT        bfDisconnectTime; // holds threshold time also
} IRDA_QOS_PARMS;


// IrDA Message Primitives
typedef enum
{
    MAC_DATA_REQ = 0,  // Keep in sync with table in irlaplog.c
    MAC_DATA_IND,
    MAC_DATA_RESP,
    MAC_DATA_CONF,
    MAC_CONTROL_REQ,
    MAC_CONTROL_CONF,
    IRLAP_DISCOVERY_REQ,
    IRLAP_DISCOVERY_IND,
    IRLAP_DISCOVERY_CONF,
    IRLAP_CONNECT_REQ,
    IRLAP_CONNECT_IND,
    IRLAP_CONNECT_RESP,
    IRLAP_CONNECT_CONF,
    IRLAP_DISCONNECT_REQ,
    IRLAP_DISCONNECT_IND,
    IRLAP_DATA_REQ,    // Don't fuss with the order, CONF must be 2 from REQ
    IRLAP_DATA_IND,
    IRLAP_DATA_CONF,
    IRLAP_UDATA_REQ,
    IRLAP_UDATA_IND,
    IRLAP_UDATA_CONF,
    IRLAP_STATUS_REQ,
    IRLAP_STATUS_IND,
    IRLAP_FLOWON_REQ,
    IRLMP_DISCOVERY_REQ,
    IRLMP_DISCOVERY_IND,
    IRLMP_DISCOVERY_CONF,
    IRLMP_CONNECT_REQ,
    IRLMP_CONNECT_IND,
    IRLMP_CONNECT_RESP,
    IRLMP_CONNECT_CONF,
    IRLMP_DISCONNECT_REQ,
    IRLMP_DISCONNECT_IND,
    IRLMP_DATA_REQ,
    IRLMP_DATA_IND,
    IRLMP_DATA_CONF,
    IRLMP_UDATA_REQ,
    IRLMP_UDATA_IND,
    IRLMP_UDATA_CONF,
    IRLMP_ACCESSMODE_REQ,
    IRLMP_ACCESSMODE_IND,
    IRLMP_ACCESSMODE_CONF,
    IRLMP_MORECREDIT_REQ,
    IRLMP_GETVALUEBYCLASS_REQ,
    IRLMP_GETVALUEBYCLASS_CONF,
    IRLMP_REGISTERLSAP_REQ,
    IRLMP_DEREGISTERLSAP_REQ,
    IRLMP_ADDATTRIBUTE_REQ,
    IRLMP_DELATTRIBUTE_REQ,    
    IRLMP_CLOSELSAP_REQ,
    IRLMP_FLUSHDSCV_REQ    
} IRDA_SERVICE_PRIM;

typedef enum
{
    MAC_MEDIA_BUSY,         // keep in sync with IRDA_StatStr in irlaplog.c
    MAC_MEDIA_CLEAR,
    IRLAP_DISCOVERY_COLLISION,
    IRLAP_REMOTE_DISCOVERY_IN_PROGRESS,
    IRLAP_REMOTE_CONNECT_IN_PROGRSS,
    IRLAP_DISCOVERY_COMPLETED,
    IRLAP_REMOTE_CONNECTION_IN_PROGRESS,
    IRLAP_CONNECTION_COMPLETED,
    IRLAP_REMOTE_INITIATED,
    IRLAP_PRIMARY_CONFLICT,
    IRLAP_DISCONNECT_COMPLETED,
    IRLAP_NO_RESPONSE,
    IRLAP_DECLINE_RESET,
    IRLAP_DATA_REQUEST_COMPLETED,
    IRLAP_DATA_REQUEST_FAILED_LINK_RESET,
    IRLAP_DATA_REQUEST_FAILED_REMOTE_BUSY,
    IRLMP_NO_RESPONSE,
    IRLMP_ACCESSMODE_SUCCESS,
    IRLMP_ACCESSMODE_FAILURE,
    IRLMP_DATA_REQUEST_COMPLETED,
    IRLMP_DATA_REQUEST_FAILED
} IRDA_SERVICE_STATUS;

// MAC Control Service Request Message - MAC_CONTROL_REQ/CONF
typedef enum
{
    MAC_INITIALIZE_LINK,  // keep in sync with MAC_OpStr in irlaplog.c
    MAC_CLOSE_LINK,
    MAC_RECONFIG_LINK,
    MAC_MEDIA_SENSE,
} MAC_CONTROL_OPERATION;

typedef struct
{
    MAC_CONTROL_OPERATION   Op;
    int                     Port;
    int                     Baud;
    int                     NumBOFs;
    int                     MinTat;
    int                     DataSize;
    int                     SenseTime;
    IRDA_SERVICE_STATUS     OpStatus;
    BOOLEAN                 SetIR;
} MAC_CONTROL_SERVICE;

// IRLAP Discovery Service Request Message - IRLAP_DISCOVERY_IND/CONF
typedef struct
{
    LIST_ENTRY             *pDevList;
    IRDA_SERVICE_STATUS     DscvStatus;
    BOOLEAN                 SenseMedia;
} IRLAP_DISCOVERY_SERVICE;

// IRDA Connection Service Request Message - IRLAP_CONNECT_REQ/IND/CONF
//                                           IRLMP_CONNECT_REQ/CONF
typedef struct
{
    UCHAR                   RemoteDevAddr[IRDA_DEV_ADDR_LEN];
    IRDA_QOS_PARMS          *pQos;
    int                     LocalLsapSel; 
    int                     RemoteLsapSel;
    UCHAR                   *pConnData;   
    int                     ConnDataLen;  
    void                    *pContext; 
    int                     MaxPDUSize;
    int                     MaxSDUSize;
    int                     TtpCredits;
    IRDA_SERVICE_STATUS     ConnStatus;
    BOOLEAN                 UseTtp;
} IRDA_CONNECT_SERVICE;

// IRDA Disconnection Service Request Message - IRLAP_DISCONNECT_REQ/IND
//                                              IRLMP_DISCONNECT_REQ/IND
typedef enum
{
    IRLMP_USER_REQUEST = 1,
    IRLMP_UNEXPECTED_IRLAP_DISC,
    IRLMP_IRLAP_CONN_FAILED,
    IRLMP_IRLAP_RESET,
    IRLMP_LM_INITIATED_DISC,
    IRLMP_DISC_LSAP,
    IRLMP_NO_RESPONSE_LSAP,
    IRLMP_NO_AVAILABLE_LSAP,
    IRLMP_MAC_MEDIA_BUSY,
    IRLMP_IRLAP_REMOTE_DISCOVERY_IN_PROGRESS,

    IRLMP_IAS_NO_SUCH_OBJECT, // these are added for the IAS_GetValueByClass.Conf
    IRLMP_IAS_NO_SUCH_ATTRIB,
    IRLMP_IAS_FAILED,
    IRLMP_IAS_SUCCESS,
    IRLMP_IAS_SUCCESS_LISTLEN_GREATER_THAN_ONE,
   
    IRLMP_UNSPECIFIED_DISC = 0xFF
} IRLMP_DISC_REASON;

    
typedef struct
{
    UCHAR                   *pDiscData;     // IRLMP_DISCONNECT_REQ/IND only
    int                     DiscDataLen;    // IRLMP_DISCONNECT_REQ/IND only
    IRLMP_DISC_REASON       DiscReason;     // IRLMP_DISCONNECT_REQ/IND only
    IRDA_SERVICE_STATUS     DiscStatus;     // Indication only
    void                    *pDiscContext;     
} IRDA_DISCONNECT_SERVICE;

// IRDA Data Service Request Message
#define IRLAP_HEADER_LEN       2
#define IRLMP_HEADER_LEN       6
#define TTP_HEADER_LEN         8
#define IRDA_HEADER_LEN        IRLAP_HEADER_LEN+IRLMP_HEADER_LEN+TTP_HEADER_LEN+1
                                             // + 1 IRComm WACK!!

#define SEG_FINAL               1
#define SEG_LOCAL               2

typedef struct
{
    void                    *pOwner;
    int                     SegCount;      // Number of segments
    UINT                    SegFlags;
    UCHAR                   *pBase;
    UCHAR                   *pLimit;
    UCHAR                   *pRead;
    UCHAR                   *pWrite;
    void                    *pTdiSendComp;
    void                    *pTdiSendCompCnxt;
    LONG                    RefCnt;
    BOOLEAN                 IrCOMM_9Wire;
    BOOLEAN                 Expedited;
#ifdef TEMPERAMENTAL_SERIAL_DRIVER
    int                     FCS;
#endif    
    IRDA_SERVICE_STATUS     DataStatus; // for CONF
    //                      |------------------------|
    //                      | pRead                o-------------
    //                      |------------------------|           |
    //                      | pWrite               o----------   |
    //                      |------------------------|        |  |
    //                      | pBase                o-------   |  |
    //                      |------------------------|     |  |  |
    //                      | pLimit               o----   |  |  |
    //                      |------------------------|  |  |  |  |
    //                                               |  |  |  |  |
    //                       ------------------------   |  |  |  |
    //                      |                        |<----   |  |
    //                      |                        |  |     |  |
    //                      |                        |<--------<-
    //                      |                        |  |
    //                      |                        |<-
    //                       ------------------------
    UCHAR                   *pHdrRead;
    UCHAR                   *pHdrWrite;
    UCHAR                   Header[IRDA_HEADER_LEN];
    //                      |------------------------|
    //                      | pHdrRead              o-------------
    //                      |------------------------|           |
    //                      | pHdrWrite            o----------   |
    //                      |------------------------|        |  |
    //            Header--->|                        |        |  |
    //                      |                        |        |  |
    //                      |                        |<--------<-
    //                      |                        |        |
    //                      |                        |<-------
    //                       ------------------------
    //
    //                      On the receive side, all headers are contained
    //                      at pRead, not in the above Header array
    //
} IRDA_DATA_SERVICE;

typedef enum
{
    IRLMP_MULTIPLEXED,
    IRLMP_EXCLUSIVE
} IRLMP_ACCESSMODE;

typedef struct
{
    IRLMP_ACCESSMODE    AccessMode;
    IRDA_SERVICE_STATUS ModeStatus;     
    BOOLEAN             IrLPTMode;  // if true don't send PDU
} IRLMP_ACCESSMODE_SERVICE;

typedef struct
{
    IAS_SET             *pIasSet;
    CHAR                *pClassName;
    IAS_QUERY           *pIasQuery;
    int                 AttribLen;      // OctetSeq or UsrStr len
    IRLMP_DISC_REASON   IASStatus;
    PVOID               AttribHandle;
    PVOID               *pAttribHandle;    
} IRLMP_IAS_SERVICE;

typedef struct irda_msg
{
    LIST_ENTRY          Linkage;
    IRDA_SERVICE_PRIM   Prim;
    PVOID               DataContext;
    union
    {
        MAC_CONTROL_SERVICE             MAC_ControlService;
        IRLAP_DISCOVERY_SERVICE         IRLAP_DiscoveryService;
        IRDA_DISCONNECT_SERVICE         IRDA_DisconnectService;
        IRDA_CONNECT_SERVICE            IRDA_ConnectService;
        IRDA_DATA_SERVICE               IRDA_DataService;
        IRLMP_ACCESSMODE_SERVICE        IRLMP_AccessModeService;
        IRLMP_IAS_SERVICE               IRLMP_IASService;
        PVOID                           pLinkStatus;
    } MsgType;

} IRDA_MSG, *PIRDA_MSG;

#define IRDA_MSG_Op                 MsgType.MAC_ControlService.Op
#define IRDA_MSG_Port               MsgType.MAC_ControlService.Port
#define IRDA_MSG_Baud               MsgType.MAC_ControlService.Baud
#define IRDA_MSG_NumBOFs            MsgType.MAC_ControlService.NumBOFs
#define IRDA_MSG_MinTat             MsgType.MAC_ControlService.MinTat 
#define IRDA_MSG_DataSize           MsgType.MAC_ControlService.DataSize
#define IRDA_MSG_OpStatus           MsgType.MAC_ControlService.OpStatus
#define IRDA_MSG_SetIR              MsgType.MAC_ControlService.SetIR
#define IRDA_MSG_SenseTime          MsgType.MAC_ControlService.SenseTime

#define IRDA_MSG_pOwner             MsgType.IRDA_DataService.pOwner  
#define IRDA_MSG_SegCount           MsgType.IRDA_DataService.SegCount
#define IRDA_MSG_SegFlags           MsgType.IRDA_DataService.SegFlags
#define IRDA_MSG_pHdrRead           MsgType.IRDA_DataService.pHdrRead
#define IRDA_MSG_pHdrWrite          MsgType.IRDA_DataService.pHdrWrite
#define IRDA_MSG_Header             MsgType.IRDA_DataService.Header
#define IRDA_MSG_pBase              MsgType.IRDA_DataService.pBase
#define IRDA_MSG_pLimit             MsgType.IRDA_DataService.pLimit
#define IRDA_MSG_pRead              MsgType.IRDA_DataService.pRead
#define IRDA_MSG_pWrite             MsgType.IRDA_DataService.pWrite
#define IRDA_MSG_DataStatus         MsgType.IRDA_DataService.DataStatus
#define IRDA_MSG_pTdiSendComp       MsgType.IRDA_DataService.pTdiSendComp
#define IRDA_MSG_pTdiSendCompCnxt   MsgType.IRDA_DataService.pTdiSendCompCnxt
#define IRDA_MSG_RefCnt             MsgType.IRDA_DataService.RefCnt      
#define IRDA_MSG_IrCOMM_9Wire       MsgType.IRDA_DataService.IrCOMM_9Wire
#define IRDA_MSG_Expedited          MsgType.IRDA_DataService.Expedited   
#ifdef TEMPERAMENTAL_SERIAL_DRIVER
#define IRDA_MSG_FCS                MsgType.IRDA_DataService.FCS
#endif

#define IRDA_MSG_pDevList           MsgType.IRLAP_DiscoveryService.pDevList
#define IRDA_MSG_DscvStatus         MsgType.IRLAP_DiscoveryService.DscvStatus
#define IRDA_MSG_SenseMedia         MsgType.IRLAP_DiscoveryService.SenseMedia

#define IRDA_MSG_RemoteDevAddr      MsgType.IRDA_ConnectService.RemoteDevAddr
#define IRDA_MSG_pQos               MsgType.IRDA_ConnectService.pQos
#define IRDA_MSG_LocalLsapSel       MsgType.IRDA_ConnectService.LocalLsapSel
#define IRDA_MSG_RemoteLsapSel      MsgType.IRDA_ConnectService.RemoteLsapSel
#define IRDA_MSG_pConnData          MsgType.IRDA_ConnectService.pConnData
#define IRDA_MSG_ConnDataLen        MsgType.IRDA_ConnectService.ConnDataLen
#define IRDA_MSG_ConnStatus         MsgType.IRDA_ConnectService.ConnStatus
#define IRDA_MSG_pContext           MsgType.IRDA_ConnectService.pContext
#define IRDA_MSG_UseTtp             MsgType.IRDA_ConnectService.UseTtp
#define IRDA_MSG_MaxSDUSize         MsgType.IRDA_ConnectService.MaxSDUSize
#define IRDA_MSG_MaxPDUSize         MsgType.IRDA_ConnectService.MaxPDUSize
#define IRDA_MSG_TtpCredits         MsgType.IRDA_ConnectService.TtpCredits

#define IRDA_MSG_pDiscData          MsgType.IRDA_DisconnectService.pDiscData
#define IRDA_MSG_DiscDataLen        MsgType.IRDA_DisconnectService.DiscDataLen
#define IRDA_MSG_DiscReason         MsgType.IRDA_DisconnectService.DiscReason
#define IRDA_MSG_DiscStatus         MsgType.IRDA_DisconnectService.DiscStatus
#define IRDA_MSG_pDiscContext       MsgType.IRDA_DisconnectService.pDiscContext

#define IRDA_MSG_AccessMode         MsgType.IRLMP_AccessModeService.AccessMode
#define IRDA_MSG_ModeStatus         MsgType.IRLMP_AccessModeService.ModeStatus
#define IRDA_MSG_IrLPTMode          MsgType.IRLMP_AccessModeService.IrLPTMode

#define IRDA_MSG_pIasSet            MsgType.IRLMP_IASService.pIasSet
#define IRDA_MSG_pClassName         MsgType.IRLMP_IASService.pClassName
#define IRDA_MSG_pIasQuery          MsgType.IRLMP_IASService.pIasQuery
#define IRDA_MSG_AttribLen          MsgType.IRLMP_IASService.AttribLen
#define IRDA_MSG_IASStatus          MsgType.IRLMP_IASService.IASStatus
#define IRDA_MSG_AttribHandle       MsgType.IRLMP_IASService.AttribHandle
#define IRDA_MSG_pAttribHandle      MsgType.IRLMP_IASService.pAttribHandle

#define IRDA_MSG_pLinkStatus        MsgType.pLinkStatus

extern PDRIVER_OBJECT               pIrdaDriverObject;
extern LIST_ENTRY                   IrdaLinkCbList;
extern KSPIN_LOCK                   gSpinLock;
extern NDIS_HANDLE                  NdisIrdaHandle;
extern PVOID                        IrdaMsgPool;

VOID IrdaTimerInitialize(PIRDA_TIMER     pTimer,
                         VOID            (*ExpFunc)(PVOID Context),
                         UINT            Timeout,
                         PVOID           Context,
                         PIRDA_LINK_CB   pIrdaLinkCb);

VOID IrdaTimerStart(PIRDA_TIMER pTimer);

VOID IrdaTimerStop(PIRDA_TIMER pTimer);

VOID IrdaTimerRestart(PIRDA_TIMER pTimer);

VOID IrdaEventInitialize(PIRDA_EVENT pIrdaEvent,
                         VOID        (*Callback)(PVOID Context));
    
VOID IrdaEventSchedule(PIRDA_EVENT pIrdaEvent, PVOID Context);


NTSTATUS
IrdaInitialize(
    IN PNDIS_STRING,
    IN PUNICODE_STRING,
    OUT PUINT);

VOID
IrdaShutdown();

UINT
TdiUp(void *pContext, IRDA_MSG *pMsg);

IRDA_MSG *
AllocTxMsg(
    PIRDA_LINK_CB);

VOID
IrmacDown(
    IN  PVOID   IrmacContext,
    PIRDA_MSG   pMsg);

_inline
VOID
INIT_LINK_LOCK(PIRDA_LINK_CB pIrdaLinkCb)
{
    KeInitializeMutex(&pIrdaLinkCb->Mutex, 1);
}

_inline
VOID
LOCK_LINK(PIRDA_LINK_CB pIrdaLinkCb)
{
    NTSTATUS Status;

    Status =  KeWaitForSingleObject(&pIrdaLinkCb->Mutex,
                Executive,
                KernelMode,
                FALSE,
                NULL);
                
    ASSERT(Status == STATUS_SUCCESS);
}

_inline
VOID
UNLOCK_LINK(PIRDA_LINK_CB pIrdaLinkCb)
{
    KeReleaseMutex(&pIrdaLinkCb->Mutex, FALSE);
}

#if DBG
typedef struct
{
    NPAGED_LOOKASIDE_LIST   Lookaside;
    UINT                    Allocd;    
} DBG_BUF_POOL, *PDBG_BUF_POOL;

#endif
__inline
PVOID
CreateIrdaBufPool(ULONG Size, ULONG Tag)
{               
#if DBG        
    PDBG_BUF_POOL            pDbgBufPool;
#else    
    PNPAGED_LOOKASIDE_LIST  pLookaside;
#endif

#if DBG        

    pDbgBufPool =  ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(DBG_BUF_POOL),
                                         MT_IRDA_LAL);
//DEBUGMSG(1, ("Created pool %x\n", pDbgBufPool));
    if (!pDbgBufPool)
        return NULL;
#else
    pLookaside = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(NPAGED_LOOKASIDE_LIST),
                                       MT_IRDA_LAL);
    if (!pLookaside)
        return NULL;
#endif


	ExInitializeNPagedLookasideList(
#if DBG
        &pDbgBufPool->Lookaside,
#else            
		pLookaside,
#endif        
		NULL,
		NULL,
		0,
		Size,
		Tag,
		4); // doesn't do anything

#if DBG
    pDbgBufPool->Allocd = 0;
    
    return pDbgBufPool;
#else            
    return pLookaside;
#endif    
}

__inline
VOID
DeleteIrdaBufPool(PVOID pBufPool)
{
#if DBG
    PDBG_BUF_POOL    pDbgBufPool = pBufPool;

//DEBUGMSG(1, ("Deleted pool %x\n", pDbgBufPool));
    
    ExDeleteNPagedLookasideList(&pDbgBufPool->Lookaside);
    ExFreePool(pDbgBufPool);
#else
    ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST) pBufPool);
    ExFreePool(pBufPool);    
#endif   
}

__inline
PVOID
AllocIrdaBuf(PVOID pBufPool)
{
#if DBG
    PDBG_BUF_POOL    pDbgBufPool = pBufPool;
    
    pDbgBufPool->Allocd++;
    
//    DEBUGMSG(1, ("+Pool %x, cnt %d\n", pBufPool, pDbgBufPool->Allocd));
    
    return ExAllocateFromNPagedLookasideList(&pDbgBufPool->Lookaside);
#else
    return ExAllocateFromNPagedLookasideList(
            (PNPAGED_LOOKASIDE_LIST) pBufPool);
#endif                            
}

__inline
VOID
FreeIrdaBuf(PVOID pBufPool, PVOID Buf)
{
#if DBG
    PDBG_BUF_POOL    pDbgBufPool = pBufPool;
    
    pDbgBufPool->Allocd--;
//    DEBUGMSG(1, ("-Pool %x, cnt %d\n", pBufPool, pDbgBufPool->Allocd));
    ExFreeToNPagedLookasideList(&pDbgBufPool->Lookaside, Buf);
#else    
    ExFreeToNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)pBufPool, Buf);
#endif    
}


// I'm wrapping lookaside lists so I don't have to keep track of
// which pool to free to.
/*
__inline
PVOID
CreateMsgPool(ULONG Size,
             USHORT Depth,
             ULONG Tag)
{
    PNPAGED_LOOKASIDE_LIST  pLookaside;

    pLookaside = ExAllocatePool(NonPagedPool, sizeof(NPAGED_LOOKASIDE_LIST));

    if (!pLookaside)
        return NULL;

	ExInitializeNPagedLookasideList(
		pLookaside,
		NULL,
		NULL,
		0,
		Size + sizeof(PVOID),
		Tag,
		Depth);

    DEBUGMSG(0, ("CreateMsgPool %x\n", pLookaside));
    
    return pLookaside;
}

__inline
VOID
DeleteMsgPool(PVOID pLookaside)
{
    DEBUGMSG(0, ("DeleteMsgPool %x\n", pLookaside));
    
    ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST) pLookaside);

    ExFreePool(pLookaside);
}

__inline
PVOID
AllocFromMsgPool(PVOID pLookaside)
{
    PVOID   pEntry;

    pEntry = ExAllocateFromNPagedLookasideList(pLookaside);

    if (!pEntry)
        return NULL;

    // store lookaside with entry
    
    *(PVOID *) pEntry = pLookaside;

    DEBUGMSG(0, ("Alloc %x: Total %d, AllocMiss %d, FreeTot %d, FreeMiss %d Depth%d\n",
                 pLookaside,
                 ((PNPAGED_LOOKASIDE_LIST)pLookaside)->L.TotalAllocates,
                 ((PNPAGED_LOOKASIDE_LIST)pLookaside)->L.AllocateMisses,
                 ((PNPAGED_LOOKASIDE_LIST)pLookaside)->L.TotalFrees,
                 ((PNPAGED_LOOKASIDE_LIST)pLookaside)->L.FreeMisses,
                 ((PNPAGED_LOOKASIDE_LIST)pLookaside)->L.Depth));

    return ++(PVOID *)pEntry;
}

__inline
VOID
FreeToMsgPool(PVOID pEntry)
{
    PNPAGED_LOOKASIDE_LIST pLookaside;

    pEntry = --(PVOID *) pEntry;
    
    pLookaside = *(PVOID *) pEntry;

    DEBUGMSG(1, ("Listdepth %d, depth %d\n",
                 ExQueryDepthSList(&pLookaside->L.ListHead),
                 pLookaside->L.Depth));
    
    ExFreeToNPagedLookasideList(pLookaside, pEntry);

    DEBUGMSG(0, ("FREE %x: Total %d, AllocMiss %d, FreeTot %d, FreeMiss %d Depth %d\n",
                 pLookaside,
             pLookaside->L.TotalAllocates, pLookaside->L.AllocateMisses,
             pLookaside->L.TotalFrees, pLookaside->L.FreeMisses, pLookaside->L.Depth));
             
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irmem.h ===
// really should have a CTEAllocMemWithTag
#define IRDA_ALLOC_MEM(ptr, sz, id) ((ptr) = ExAllocatePoolWithTag(NonPagedPool,sz,id))
#define IRDA_FREE_MEM(ptr)          ExFreePool((ptr))

#define MT_IRLAP_DEVICE         '1DrI'
#define MT_IRLMP_REGLSAP        '2DrI'
#define MT_IRLMP_LSAP_CB        '3DrI'
#define MT_IRLMP_DEVICE         '4DrI'
#define MT_IRLMP_IAS_OBJECT     '5DrI'
#define MT_IRLMP_IAS_CLASSNAME  '6DrI'
#define MT_IRLMP_IAS_ATTRIB     '7DrI'
#define MT_IRLMP_IAS_ATTRIBNAME '8DrI'
#define MT_IRLMP_IAS_ATTRIBVAL  '9DrI'
#define MT_IRNDIS_TX_IMSG       'aDrI'
#define MT_IRNDIS_LINKCB        'bDrI'
#define MT_IRNDIS_RX_IMSG       'cDrI'
#define MT_IRLMPCB              'dDrI'
#define MT_TDI_ADDROBJ          'eDrI'
#define MT_TDI_CONNOBJ          'fDrI'
#define MT_TDICL_ENDP           'gDrI'
#define MT_TDICL_CONN           'hDrI'
#define MT_TDICL_RXBUF          'iDrI'
#define MT_TDICL_RXIND          'jDrI'
#define MT_RASIR_ADAPTER        'kDrI'
#define MT_RASIR_CALLPARMS      'lDrI'
#define MT_RASIR_VC             'mDrI'
#define MT_IMSG_POOL            'nDrI'
#define MT_RXBUF_POOL           'oDrI'
#define MT_IRLAPCB              'pDrI'
#define MT_RASIR_WORKITEM       'qDrI'
#define MT_IRNDIS_PNP_EVENT     'rDrI'
#define MT_IRDA_LAL             'sDrI'  
#define MT_TDI_IAS              'tDrI'
#define MT_RASIR_ASYNCBUF       'uDrI'
#define MT_DEV_RELATIONS        'vDrI'
#define MT_RASIR_ENDP           'wDrI'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irioctl.h ===
/*++                                          
Copyright (c) 1998  Microsoft Corporation

Module Name:

    irioctl.h

Abstract:

    Contains definitions for private ioctls for the IrDA TDI driver used
    by irmon and the IrDA winsock helper dll.

Author:

    mbert   9-98

--*/

typedef struct
{
    ULONG    Flags;
        #define     LF_CONNECTED    0x00000001
        #define     LF_TX           0x00000002
        #define     LF_RX           0x00000004
        #define     LF_INTERRUPTED  0x00000008
        #define     LF_NO_UI        0x80000000
    ULONG   ConnectSpeed;
    CHAR    ConnectedDeviceId[4];
} IRLINK_STATUS, *PIRLINK_STATUS;

#define FSCTL_IRDA_BASE     FILE_DEVICE_NETWORK

#define _IRDA_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IRDA_BASE, function, method, access)

#define IOCTL_IRDA_GET_INFO_ENUM_DEV \
            _IRDA_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_SET_OPTIONS \
            _IRDA_CTL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_GET_SEND_PDU_LEN \
            _IRDA_CTL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_QUERY_IAS \
            _IRDA_CTL_CODE(3, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_SET_IAS \
            _IRDA_CTL_CODE(4, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_DEL_IAS_ATTRIB \
            _IRDA_CTL_CODE(5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_LAZY_DISCOVERY \
            _IRDA_CTL_CODE(6, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_LINK_STATUS \
            _IRDA_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_SET_LAZY_DISCOVERY_INTERVAL \
            _IRDA_CTL_CODE(11, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_LINK_STATUS_NB \
            _IRDA_CTL_CODE(12, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_FLUSH_DISCOVERY_CACHE \
            _IRDA_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)                         

#define IOCTL_IRDA_GET_DBG_MSGS \
            _IRDA_CTL_CODE(20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IRDA_GET_DBG_SETTINGS \
            _IRDA_CTL_CODE(21, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#define IOCTL_IRDA_SET_DBG_SETTINGS \
            _IRDA_CTL_CODE(22, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
            
#define OPT_IRLPT_MODE      0x01
#define OPT_9WIRE_MODE      0x02

#define LINK_STATUS_IDLE            0
#define LINK_STATUS_DISCOVERING     1
#define LINK_STATUS_CONNECTED       2
#define LINK_STATUS_INTERRUPTED     3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irlmp.h ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlmp.h
*
*  Description: IRLMP Protocol and control block definitions
*
*  Author: mbert
*
*  Date:   4/15/95
*
*/

#define IRLMP_MAX_USER_DATA_LEN      53

// IrLMP Entry Points

VOID
IrlmpInitialize();

VOID
IrlmpOpenLink(
    OUT PNTSTATUS         Status,
    IN  PIRDA_LINK_CB     pIrdaLinkCb,  
    IN  UCHAR             *pDeviceName,
    IN  int               DeviceNameLen,
    IN  UCHAR             CharSet);
              
VOID
IrlmpCloseLink(
    IN PIRDA_LINK_CB     pIrdaLinkCb);              

UINT 
IrlmpUp(
    PIRDA_LINK_CB pIrdaLinkCb, PIRDA_MSG pIMsg);

UINT 
IrlmpDown(
    PVOID IrlmpContext, PIRDA_MSG pIrdaMsg);

VOID
IrlmpDeleteInstance(
    PVOID Context);
    
VOID
IrlmpGetPnpContext(
    PVOID IrlmpContext,
    PVOID *pPnpContext);    

#if DBG
void IRLMP_PrintState();
#endif

// IAS

#define IAS_ASCII_CHAR_SET          0

// IAS Attribute value types
#define IAS_ATTRIB_VAL_MISSING      0
#define IAS_ATTRIB_VAL_INTEGER      1
#define IAS_ATTRIB_VAL_BINARY       2
#define IAS_ATTRIB_VAL_STRING       3

// IAS Operation codes
#define IAS_OPCODE_GET_VALUE_BY_CLASS   4   // The only one I do

extern CHAR IasClassName_Device[];
extern CHAR IasAttribName_DeviceName[];
extern CHAR IasAttribName_IrLMPSupport[];
extern CHAR IasAttribName_TTPLsapSel[];
extern CHAR IasAttribName_IrLMPLsapSel[];
extern CHAR IasAttribName_IrLMPLsapSel2[];


extern UCHAR IasClassNameLen_Device;
extern UCHAR IasAttribNameLen_DeviceName;
extern UCHAR IasAttribNameLen_IRLMPSupport;
extern UCHAR IasAttribNameLen_TTPLsapSel;
extern UCHAR IasAttribNameLen_IrLMPLsapSel;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irmon.h ===
#ifdef __cplusplus

extern "C" {

#endif


typedef
VOID
(*ADHOC_CALLBACK)(
    PVOID    Context,
    BOOL     Availible
    );


typedef
void (* SET_TRAY_STATUS_FN) (
    PVOID    Context,
    BOOL     TrayOn
    );

typedef
VOID (*SET_SOUND_STATUS_FN)(
    PVOID    Context,
    BOOL     SoundOn
    );

typedef void (* SET_LOGON_STATUS_FN)( BOOL x );

typedef BOOL (* IRXFER_INIT_FN)( SET_LOGON_STATUS_FN x,
                                 SET_TRAY_STATUS_FN y
                                 );


void
UpdateDiscoveredDevices(
    const OBEX_DEVICE_LIST *IrDevices,
    const OBEX_DEVICE_LIST *IpDevices
    );

BOOL
InitializeIrxfer(
                  PVOID    Context,
                  ADHOC_CALLBACK       AdhocCallback,
                  SET_LOGON_STATUS_FN  x,
                  SET_TRAY_STATUS_FN   y,
                  SET_SOUND_STATUS_FN  SetSounfCallback,
                  PVOID               *IrxferContext
                );

BOOL
UninitializeIrxfer(
    PVOID    IrXferContext
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\irtdicl.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    irtdicl.h

Abstract:

    public definitions for the irda tdi client library.
    
Author:

    mbert 9-97    

--*/
    
#define DBG_INIT        0x00000002
#define DBG_CONFIG      0x00000004
#define DBG_CONNECT     0x00000008
#define DBG_SEND        0x00000010
#define DBG_RECV        0x00000020
#define DBG_LIB_OBJ     0x00000100
#define DBG_LIB_CONNECT 0x00000200
#define DBG_LIB_SEND    0x00000400
#define DBG_LIB_RECV    0x00080000
#define DBG_ERROR       0x80000000

#define IRTDI_RECV_BUF_CNT    6

typedef struct
{
    LIST_ENTRY  Linkage;
    CHAR        Buf[IRDA_MAX_DATA_SIZE];
    ULONG       BufLen;
} IRDA_RECVBUF, *PIRDA_RECVBUF;

// external routines called by library
NTSTATUS
IrdaIncomingConnection(
    PVOID       ClEndpContext,
    PVOID       ConnectionContext,
    PVOID       *ClConnContext);

VOID
IrdaConnectionClosed(
    PVOID       ConnectionContext);
    
VOID
IrdaSendComplete(
    PVOID       ClConnContext,
    PVOID       SendContext,
    NTSTATUS    Status);
    
VOID
IrdaReceiveIndication(
    PVOID           ConnectionContext,
    PIRDA_RECVBUF   pRecvBuf,
    BOOLEAN         LastBuf);

VOID
IrdaCloseConnectionComplete(
    IN PVOID        ClConnContext);
    
VOID
IrdaCloseEndpointComplete(
    IN PVOID        ClEndpContext);    

VOID
IrdaCloseAddresses();

// IrDA TDI Client library public functions
NTSTATUS
IrdaClientInitialize();

VOID
IrdaClientShutdown();

NTSTATUS
IrdaOpenEndpoint(
    IN  PVOID               ClEndpContext,
    IN  PTDI_ADDRESS_IRDA   pRequestedIrdaAddr,
    OUT PVOID               *pEndpContext);

NTSTATUS
IrdaCloseEndpoint(
    OUT PVOID   pEndpContext);
    
NTSTATUS    
IrdaDiscoverDevices(
    PDEVICELIST pDevList,
    PULONG      pDevListLen);
    
NTSTATUS
IrdaOpenConnection(
    PTDI_ADDRESS_IRDA   pIrdaAddr,
    PVOID               ClConnContext,
    PVOID               *pConnectContext,
    BOOLEAN             IrCommMode);
    
VOID
IrdaCloseConnection(
    IN PVOID    ConnectContext);    
    
VOID
IrdaSend(
    PVOID       ConnectionContext,
    PMDL        pMdl,
    PVOID       SendContext);
    
VOID
IrdaReceiveComplete(
    PVOID           ConnectionContext,
    PIRDA_RECVBUF   pRcvBuf);
    
ULONG
IrdaGetConnectionSpeed(
    PVOID       ConnectionContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\ssdp.h ===
#ifdef __cplusplus

extern "C" {

#endif


BOOL
RegisterWithSsdp(
    const IN_ADDR     *IpAddress,
    SOCKET  *listenSocket,
    HANDLE  *SsdpHandle,
    DWORD    dwPort
    );

#if 0
BOOL
RegisterWithSsdp(
    const SOCKADDR_IN    *IpAddress,
    SOCKET  *listenSocket,
    HANDLE  *SsdpHandle,
    DWORD    dwPort
    );
#endif

VOID
UnregisterWithSsdp(
    HANDLE    SsdpHandle
    );



HANDLE
CreateSsdpDiscoveryObject(
    LPSTR    Service,
    HWND     hWnd,
    UINT     Msg
    );

VOID
CloseSsdpDiscoveryObject(
    HANDLE    Context
    );

LONG
GetSsdpDevices(
    HANDLE    Context,
    POBEX_DEVICE_LIST    DeviceList,
    ULONG               *ListLength
    );

LONG
RefreshSsdp(
    VOID
    );


VOID
UnRegisterForAdhocNetworksNotification(
    HANDLE     RegistrationHandle
    );


typedef BOOL (*NEW_ADDRESS_CALLBACK)(
    HANDLE         Context,
    SOCKET         ListenSocket,
    HANDLE        *NewAddressContext
    );

typedef VOID (*ADDRESS_GONE_CALLBACK)(
    HANDLE         RegistraitionContext,
    HANDLE         AddressContext
    );




HANDLE
RegisterForAdhocNetworksNotification(
    HANDLE                 RegistrationContext,
    NEW_ADDRESS_CALLBACK   NewAddressCallback,
    ADDRESS_GONE_CALLBACK  AddressGoneCallback
    );



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\inc\refcnt.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Edward Buchwalter (v-edbuc)    15-Aug-1996

Revision History:

--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 8
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    LONG       	Count;
    PVOID       Instance;
    VOID        (*DeleteHandler)( PVOID );
#if DBG    
    int         Sig;
    REF_TAG     Tags[TAG_CNT];
    CTELock     Lock;
#endif     
}
REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID ) 
);

VOID
ReferenceAdd
(
    IN 	PREF_CNT  pRefCnt
);

VOID
ReferenceAddCount
(
    IN 	PREF_CNT    pRefCnt,
	IN	UINT	    Count
);

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
);

VOID
ReferenceApiTest
( 
	VOID 
);

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag);

#define REFADD(Rc, Tag)     ReferenceAddDbg(Rc, Tag)
#define REFDEL(Rc, Tag)     ReferenceRemoveDbg(Rc, Tag)

#else

#define REFADD(Rc, Tag)  ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)  ReferenceRemove(Rc);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irclass\irclass.c ===
/*****************************************************************************
*
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*       @doc
*       @module   IRCLASS.C
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Date:     1/26/1998 (created)
*
*       Contents: CoClassInstaller and Property Pages for IRSIR
*
*****************************************************************************/

#include <objbase.h>
#include <windows.h>
#include <tchar.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <regstr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stddef.h>
#include <stdarg.h>

#include "irclass.h"

//
// Instantiate device class GUIDs (we need infrared class GUID).
//
#include <initguid.h>
#include <devguid.h>

HANDLE ghDllInst = NULL;

TCHAR gszTitle[40];
TCHAR gszOutOfMemory[512];
TCHAR gszHelpFile[40];

TCHAR *BaudTable[] = {
    TEXT("2400"),
    TEXT("9600"),
    TEXT("19200"),
    TEXT("38400"),
    TEXT("57600"),
    TEXT("115200")
};

#define NUM_BAUD_RATES (sizeof(BaudTable)/sizeof(TCHAR*))
#define DEFAULT_MAX_CONNECT_RATE BaudTable[NUM_BAUD_RATES-1]

TCHAR szHelpFile[] = TEXT("INFRARED.HLP");

#define IDH_DEVICE_MAXIMUM_CONNECT_RATE       1201
#define IDH_DEVICE_COMMUNICATIONS_PORT          1202

const DWORD HelpIDs[] =
{
    IDC_MAX_CONNECT,        IDH_DEVICE_MAXIMUM_CONNECT_RATE,
    IDC_RATE_TEXT,          IDH_DEVICE_MAXIMUM_CONNECT_RATE,
    IDC_PORT,               IDH_DEVICE_COMMUNICATIONS_PORT,
    IDC_SELECT_PORT_TEXT,   IDH_DEVICE_COMMUNICATIONS_PORT,
    IDC_PORT_TEXT,          IDH_DEVICE_COMMUNICATIONS_PORT,
    IDC_DEVICE_DESC,        -1,
    IDC_PORT_BOX,           -1,
    IDC_IRDA_ICON,          -1,
    0, 0
};

void InitStrings(HINSTANCE hInst)
/*++

Routine Description: InitStrings

            Loads default strings from resource table

Arguments:
            hInst - DLL Instance

Return Value: NONE

--*/
{
    LoadString(hInst, IDS_TITLE, gszTitle, sizeof(gszTitle)/sizeof(gszTitle[0]));
    LoadString(hInst, IDS_MEM_ERROR, gszOutOfMemory, sizeof(gszOutOfMemory)/sizeof(gszOutOfMemory[0]));
}

//==========================================================================
//                                Dll Entry Point
//==========================================================================
BOOL APIENTRY LibMain( HANDLE hDll, DWORD dwReason, LPVOID lpReserved )
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            ghDllInst = hDll;
            InitStrings(ghDllInst);
            DisableThreadLibraryCalls(ghDllInst);
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_THREAD_ATTACH:
            break;

        default:
            break;
    }

    return TRUE;
}

int MyLoadString(HINSTANCE hInst, UINT uID, LPTSTR *ppBuffer)
/*++

Routine Description: MyLoadString

            LoadString wrapper which allocs properly sized buffer and loads
            string from resource table

Arguments:
            hInst - DLL Instanace
            uID - Resource ID
            ppBuffer - returns allocated buffer containing string.

Return Value:
            ERROR_SUCCESS on success
            ERROR_* on failure.

--*/
{
    UINT Length = 8;
    int LoadResult = 0;
    HLOCAL hLocal = NULL;

    do
    {
        Length <<= 1;

        if (hLocal)
        {
            LocalFree(hLocal);
        }

        hLocal = LocalAlloc(LMEM_FIXED, Length*sizeof(TCHAR));

        if (hLocal)
        {
            LoadResult = LoadString(hInst, uID, (LPTSTR)hLocal, Length);
        }
        else
        {
            MessageBox(GetFocus(), OUT_OF_MEMORY_MB);
        }
    } while ( (UINT)LoadResult==Length-1 && Length<4096 && hLocal);

    if (LoadResult==0 && hLocal)
    {
        LocalFree(hLocal);
        hLocal = NULL;
    }

    *ppBuffer = (LPTSTR)hLocal;

    return LoadResult;
}

int MyMessageBox(HWND hWnd, UINT uText, UINT uCaption, UINT uType)
/*++

Routine Description: MyMessageBox

    MessageBox wrapper which takes string resource IDs as parameters

Arguments:
    hWnd - Parent window
    uText - Message box body text ID
    uCaption - Message box caption ID
    uType - As in MessageBox()

Return Value:
    Result of MessageBox call

--*/
{
    LPTSTR szText=NULL, szCaption=NULL;
    int Result = 0;

    MyLoadString(ghDllInst, uText, &szText);

    if (szText != NULL) {

        MyLoadString(ghDllInst, uCaption, &szCaption);

        if (szCaption != NULL) {

            Result = MessageBox(hWnd, szText, szCaption, uType);

            LocalFree(szCaption);
        }
        LocalFree(szText);
    }

    return Result;
}

LONG
MyRegQueryValueEx(
                  IN    HKEY    hKey,
                  IN    LPCTSTR Value,
                  IN    LPDWORD lpdwReserved,
                  IN    LPDWORD lpdwType,
                  OUT   LPBYTE *lpbpData,
                  OUT   LPDWORD lpcbLength)
/*++

Routine Description:

    RegQueryValueEx wrapper which automatically queries data size and
    LocalAllocs a buffer.

Arguments:

    hKey - handle of open key
    Value - text name of value
    lpdwReserved - Must be NULL
    lpdwType - Returns type of value queried
    lpbpData - Returns alloced buffer containing query data
    lpcbLength - Returns length of data returned/size of buffer alloced.

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY on failure to alloc buffer
    result of RegQueryValueEx call

--*/
{
    LONG Result;

    *lpcbLength = 0;

    Result = RegQueryValueEx(hKey,
                             Value,
                             lpdwReserved,
                             lpdwType,
                             NULL,
                             lpcbLength);
    if (Result==ERROR_SUCCESS)
    {
        *lpbpData = LocalAlloc(LMEM_FIXED, *lpcbLength);

        if (!*lpbpData)
        {
            Result = ERROR_OUTOFMEMORY;
        }
        else
        {
            Result = RegQueryValueEx(hKey,
                                     Value,
                                     lpdwReserved,
                                     lpdwType,
                                     *lpbpData,
                                     lpcbLength);
        }
    }

    return Result;
}

LPTSTR GetDIFString(IN DI_FUNCTION Func)
/*++

Routine Description:

    Given a DI_FUNCTION value, returns a text representation.

Arguments:

    Func - DI_FUNCTON value

Return Value:

    Text string if value is known.  Hex representation if not.

--*/
{
    static TCHAR buf[32];
#define MakeCase(d)  case d: return TEXT(#d)
    switch (Func)
    {
        MakeCase(DIF_SELECTDEVICE);
        MakeCase(DIF_INSTALLDEVICE);
        MakeCase(DIF_ASSIGNRESOURCES);
        MakeCase(DIF_PROPERTIES);
        MakeCase(DIF_REMOVE);
        MakeCase(DIF_FIRSTTIMESETUP);
        MakeCase(DIF_FOUNDDEVICE);
        MakeCase(DIF_SELECTCLASSDRIVERS);
        MakeCase(DIF_VALIDATECLASSDRIVERS);
        MakeCase(DIF_INSTALLCLASSDRIVERS);
        MakeCase(DIF_CALCDISKSPACE);
        MakeCase(DIF_DESTROYPRIVATEDATA);
        MakeCase(DIF_VALIDATEDRIVER);
        MakeCase(DIF_MOVEDEVICE);
        MakeCase(DIF_DETECT);
        MakeCase(DIF_INSTALLWIZARD);
        MakeCase(DIF_DESTROYWIZARDDATA);
        MakeCase(DIF_PROPERTYCHANGE);
        MakeCase(DIF_ENABLECLASS);
        MakeCase(DIF_DETECTVERIFY);
        MakeCase(DIF_INSTALLDEVICEFILES);
        MakeCase(DIF_UNREMOVE);
        MakeCase(DIF_SELECTBESTCOMPATDRV);
        MakeCase(DIF_ALLOW_INSTALL);
        MakeCase(DIF_REGISTERDEVICE);
        MakeCase(DIF_INSTALLINTERFACES);
        MakeCase(DIF_DETECTCANCEL);
        MakeCase(DIF_REGISTER_COINSTALLERS);
        MakeCase(DIF_NEWDEVICEWIZARD_FINISHINSTALL);
        default:
            wsprintf(buf, TEXT("%x"), Func);
            return buf;
    }
}

void EnumValues(
                IN     HDEVINFO                     DeviceInfoSet,
                IN     PSP_DEVINFO_DATA             DeviceInfoData
                )
/*++

Routine Description:

    Function mainly for debugging purposes which will print to debugger
    a list of values found in the device's Class/{GUID}/Instance key.

Arguments:

    DeviceInfoSet - As passed in to IrSIRClassCoInstaller
    DeviceInfoData - As passed in to IrSIRClassCoInstaller

Return Value:

    NONE

--*/
{
    HKEY hKey;
    DWORD i, dwReserved = 0, dwType;
    TCHAR Value[MAX_PATH];
    TCHAR Data[MAX_PATH];
    DWORD ValueLength = sizeof(Value)/sizeof(TCHAR);
    DWORD DataLength = sizeof(Data);
    TCHAR buf[100];

    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DEV,
                                KEY_READ);
    if (hKey == INVALID_HANDLE_VALUE)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller:EnumValues:SetupDiOpenDevRegKey failed\n"));
#endif
        return;
    }


    for (i=0,
         dwType=REG_SZ;
         RegEnumValue(hKey,
                      i,
                      Value,
                      &ValueLength,
                      NULL,
                      &dwType,
                      (LPBYTE)Data,
                      &DataLength
                     )==ERROR_SUCCESS;
        i++, dwType=REG_SZ
        )
    {
#if DBG
        if (dwType==REG_SZ)
        {
            wsprintf(buf, TEXT("Value(%d):%s Data:%s\n"), i, Value, Data);
            OutputDebugString(buf);
        }
#endif

        ValueLength = sizeof(Value)/sizeof(TCHAR);
        DataLength = sizeof(Data);
    }
    RegCloseKey(hKey);
}

LONG
EnumSerialDevices(
                 IN     PPROPPAGEPARAMS              pPropParams,
                 IN     HWND                         hDlg,
                 OUT    PULONG                       pNumFound
                 )
/*++

Routine Description:

    Function which fills in the IDC_PORT control of the dialiog box with
    valid COM names.

Arguments:

    pPropParams - Context data
    hDlg - Dialog box containing IDC_PORT
    pNumFound - Count of COM names added to IDC_PORT

Return Value:

    ERROR_SUCCESS or failure code

--*/
{
    LRESULT lResult;
    LONG Result = ERROR_SUCCESS, tmpResult;
    HKEY hKey = INVALID_HANDLE_VALUE;
    HKEY hkSerialComm = INVALID_HANDLE_VALUE;
    TCHAR Buf[100];
    LPTSTR CurrentPort = NULL;
    DWORD dwLength, dwType, dwDisposition;
    HDEVINFO hPorts;
    SP_DEVINFO_DATA PortData;

    *pNumFound = 0;

    hKey = SetupDiOpenDevRegKey(pPropParams->DeviceInfoSet,
                                pPropParams->DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_ALL_ACCESS);

    if (hKey == INVALID_HANDLE_VALUE)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller:EnumSerial:SetupDiOpenDevRegKey failed\n"));
#endif
        Result = GetLastError();
    }
    else
    {
        // Read the current port.  If it's empty, we'll start with an empty value.
        // Failure is ok.

        (void)MyRegQueryValueEx(hKey,
                                TEXT("Port"),
                                NULL,
                                NULL,
                                (LPBYTE*)&CurrentPort,
                                &dwLength);

        Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("HARDWARE\\DEVICEMAP\\SERIALCOMM"),
                              0,
                              KEY_ALL_ACCESS,
                              &hkSerialComm);
    }

    if (Result != ERROR_SUCCESS)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller:RegOpenKeyEx on SERIALCOMM failed\n"));
#endif
    }
    else
    {
        DWORD i, dwReserved = 0, dwType;
        TCHAR Value[MAX_PATH];
        TCHAR Data[MAX_PATH];
        DWORD ValueLength = sizeof(Value)/sizeof(TCHAR);
        DWORD DataLength = sizeof(Data);


        for (i=0,
             dwType=REG_SZ;
             RegEnumValue(hkSerialComm,
                          i,
                          Value,
                          &ValueLength,
                          NULL,
                          &dwType,
                          (LPBYTE)Data,
                          &DataLength
                         )==ERROR_SUCCESS;
            i++, dwType=REG_SZ
            )
        {
            if (dwType==REG_SZ)
            {
                (*pNumFound)++;
                SendDlgItemMessage(hDlg,
                                   IDC_PORT,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM)Data);

            }

            ValueLength = sizeof(Value)/sizeof(TCHAR);
            DataLength = sizeof(Data);
        }

        lResult = SendDlgItemMessage(hDlg,
                                     IDC_PORT,
                                     LB_FINDSTRINGEXACT,
                                     0,
                                     (LPARAM)CurrentPort);
        if (lResult==LB_ERR)
        {
            i = 0;
            pPropParams->PortInitialValue = -1;
        }
        else
        {
            i = (DWORD)lResult;
            pPropParams->PortInitialValue = i;
        }

        SendDlgItemMessage(hDlg,
                           IDC_PORT,
                           LB_SETCURSEL,
                           i,
                           0);
    }

    if (CurrentPort)
    {
        LocalFree(CurrentPort);
    }

    if (hkSerialComm!=INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hkSerialComm);
    }

    if (hKey!=INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hKey);
    }

    return Result;
}

BOOL
IsPortValueSet(
              IN     HDEVINFO                     DeviceInfoSet,
              IN     PSP_DEVINFO_DATA             DeviceInfoData
             )
{
    HKEY hKey = INVALID_HANDLE_VALUE;
    BOOL bResult = FALSE;
    LPTSTR CurrentPort = NULL;
    DWORD dwLength;
    LONG Result;

    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_ALL_ACCESS);

    if (hKey != INVALID_HANDLE_VALUE)
    {
        // Read the current port.  If it's empty, we'll start with an empty value.
        // Failure is ok.

        Result = MyRegQueryValueEx(hKey,
                                   TEXT("Port"),
                                   NULL,
                                   NULL,
                                   (LPBYTE*)&CurrentPort,
                                   &dwLength);

        if (Result == ERROR_SUCCESS && CurrentPort!=NULL)
        {
            bResult = TRUE;
            LocalFree(CurrentPort);
        }

        RegCloseKey(hKey);
    }
    return bResult;
}

LONG
InitMaxConnect(
              IN     PPROPPAGEPARAMS              pPropParams,
              IN     HWND                         hDlg
              )
/*++

Routine Description:

    Function which fills in the IDC_MAX_CONNECT control of the dialiog box with
    valid baud rates for this device.

Arguments:
    pPropParams - Context data
    hDlg - Dialog box containing IDC_MAX_CONNECT

Return Value:

    ERROR_SUCCESS or failure code

--*/
{
    LRESULT lResult;
    LONG Result = ERROR_SUCCESS;
    HKEY hKey = INVALID_HANDLE_VALUE;
    TCHAR Buf[100];
    LPTSTR CurrentMaxConnectRate = NULL;
    LPTSTR MaxConnectList = NULL;
    DWORD dwLength;
    LONG i;

    hKey = SetupDiOpenDevRegKey(pPropParams->DeviceInfoSet,
                                pPropParams->DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_ALL_ACCESS);

    if (hKey == INVALID_HANDLE_VALUE)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller:InitMaxConnect:SetupDiOpenDevRegKey failed\n"));
#endif
        Result = GetLastError();
    }
    else
    {
        LONG TmpResult;

        // Read the MaxConnectRate.  If it doesn't exist, we'll use the BaudTable instead.

        TmpResult = MyRegQueryValueEx(
                              hKey,
                              TEXT("MaxConnectList"),
                              NULL,
                              NULL,
                              (LPBYTE*)&MaxConnectList,
                              &dwLength);

        if (TmpResult == ERROR_SUCCESS)
        {
            i = 0;


            // Parse the MULTI_SZ, and add each string to IDC_MAX_CONNECT
            // We assume the values are ordered.

            while (MaxConnectList[i])
            {
                SendDlgItemMessage(hDlg,
                                   IDC_MAX_CONNECT,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM)&MaxConnectList[i]);

                while (MaxConnectList[i]) i++;

                i++;  // advance past the null

                if ((unsigned)i>=dwLength)
                {
                    break;
                }
            }
        }
        else
        {
            // Key not found, use default baud table.

            for (i=NUM_BAUD_RATES-1; i>=0; i--)
            {
                SendDlgItemMessage(hDlg,
                                   IDC_MAX_CONNECT,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM)BaudTable[i]);
            }
        }

        TmpResult = MyRegQueryValueEx(
                              hKey,
                              TEXT("MaxConnectRate"),
                              NULL,
                              NULL,
                              (LPBYTE*)&CurrentMaxConnectRate,
                              &dwLength);

        lResult = SendDlgItemMessage(
                               hDlg,
                               IDC_MAX_CONNECT,
                               LB_FINDSTRINGEXACT,
                               0,
                               (LPARAM)CurrentMaxConnectRate);


        if (lResult==LB_ERR)
        {
            i = 0;
            pPropParams->MaxConnectInitialValue = -1;
        }
        else
        {
            i = (LONG)lResult;
            pPropParams->MaxConnectInitialValue = i;
        }

        SendDlgItemMessage(hDlg,
                           IDC_MAX_CONNECT,
                           LB_SETCURSEL,
                           i,
                           0);
    }

    if (CurrentMaxConnectRate)
    {
        LocalFree(CurrentMaxConnectRate);
    }

    if (MaxConnectList)
    {
        LocalFree(MaxConnectList);
    }

    if (hKey!=INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hKey);
    }

    return Result;
}

BOOL
EnablePortSelection(
                   IN     HDEVINFO                     DeviceInfoSet,
                   IN     PSP_DEVINFO_DATA             DeviceInfoData,
                   IN     HWND                         hDlg
                   )
/*++

Routine Description:

    This function determines whether the dialog box should have a port
    selection entry, and if so enables the appropriate controls:
    IDC_PORT_BOX, IDC_PORT_TEXT, IDC_PORT.

Arguments:

    DeviceInfoSet - As passed in to IrSIRClassCoInstaller
    DeviceInfoData - As passed in to IrSIRClassCoInstaller
    hDlg - Dialog box containing IDC_PORT and associated controls

Return Value:

    TRUE if PortSelection was enabled.

--*/
{
    LONG Result = ERROR_SUCCESS;
    HKEY hKey = INVALID_HANDLE_VALUE;
    TCHAR Buf[100];
    TCHAR SerialBased[16] = TEXT("");
    DWORD dwLength;
    LONG i;
    BOOL bSerialBased = FALSE;

    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_ALL_ACCESS);

    if (hKey == INVALID_HANDLE_VALUE)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller:EnablePortSelection:SetupDiOpenDevRegKey failed\n"));
#endif
    }
    else
    {
        // Read the MaxConnectRate.  If it's empty, we'll start with an empty value.

        dwLength = sizeof(SerialBased);

        Result = RegQueryValueEx(hKey,
                                TEXT("SerialBased"),
                                NULL,
                                NULL,
                                (LPBYTE)SerialBased,
                                &dwLength);

        bSerialBased = (Result==ERROR_SUCCESS) ? _ttol(SerialBased) : TRUE;

        if (bSerialBased)
        {
            DWORD ControlsToShow[] = { IDC_PORT_BOX, IDC_PORT_TEXT, IDC_PORT };

            for (i=0; i<sizeof(ControlsToShow)/sizeof(ControlsToShow[0]); i++)
            {
                ShowWindow(GetDlgItem(hDlg, ControlsToShow[i]),
                           SW_SHOWNA);
            }
        }
    }

    if (hKey!=INVALID_HANDLE_VALUE)
    {
        RegCloseKey(hKey);
    }

    return bSerialBased;
}

LONG
InitDescription(
               IN     HDEVINFO                     DeviceInfoSet,
               IN     PSP_DEVINFO_DATA             DeviceInfoData,
               IN     HWND                         hDlg
               )
/*++

Routine Description:

    Function to fill the IDC_DEVICE_DESC box with an appropriate description
    of the device being configured.

Arguments:

    DeviceInfoSet - As passed in to IrSIRClassCoInstaller
    DeviceInfoData - As passed in to IrSIRClassCoInstaller
    hDlg - Dialog box containing IDC_DEVICE_DESC

Return Value:

    ERROR_SUCCESS or failure code

--*/
{
    LONG Result = ERROR_SUCCESS;
    TCHAR Description[LINE_LEN] = TEXT("Failed to retrive description");
    DWORD dwLength;

    if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,
                                          (LPBYTE)Description,
                                          sizeof(Description),
                                          &dwLength))
    {
        Result = GetLastError();
#if DBG
        {
            TCHAR buf[100];
            wsprintf(buf, TEXT("IrSIRCoClassInstaller:InitDescription:SetupDiGetDeviceRegistryProperty failed (0x%08x)\n"), Result);
            OutputDebugString(buf);
        }
#endif
    }
    // Display it
    SetDlgItemText(hDlg, IDC_DEVICE_DESC, Description);

    return Result;
}

LONG
WriteRegistrySettings(
                      IN HWND             hDlg,
                      IN PPROPPAGEPARAMS  pPropParams
                     )
/*++

Routine Description:

    Function to write Port and MaxConnectRate values to the devnode key.
    This also ensures that the miniport is restarted to pick up these changes.
    It usually means someone has changed a value in the device manager.

Arguments:

    hDlg - Dialog box containing IDC_PORT and associated controls
    pPropParams - Local context data for this devnode

Return Value:

    ERROR_SUCCESS or failure code

--*/
{
    TCHAR szPort[16], szMaxConnectRate[16];
    HKEY hKey;
    LRESULT lResult;
    DWORD i;
    LONG Result = ERROR_SUCCESS;
    BOOL PropertiesChanged = FALSE;
    TCHAR buf[100];

#if DBG
    OutputDebugString(TEXT("IrSIRCoClassInstaller:WriteRegistrySettings\n"));
#endif
    //
    // Write out the com port options to the registry.  These options
    // are read by the NDIS miniport via NdisReadConfiguration()
    //
    if (pPropParams->SerialBased)
    {
        lResult = SendDlgItemMessage(hDlg,
                                     IDC_PORT,
                                     LB_GETCURSEL,
                                     0, 0);
        SendDlgItemMessage(hDlg,
                           IDC_PORT,
                           LB_GETTEXT,
                           (UINT)lResult, (LPARAM)szPort);

        if ((unsigned)lResult!=pPropParams->PortInitialValue)
        {
            PropertiesChanged = TRUE;
        }
    }

    if (pPropParams->FirstTimeInstall)
    {
        lstrcpy(szMaxConnectRate, DEFAULT_MAX_CONNECT_RATE);
    }
    else
    {
        lResult = SendDlgItemMessage(hDlg,
                               IDC_MAX_CONNECT,
                               LB_GETCURSEL,
                               0, 0);
        SendDlgItemMessage(hDlg,
                           IDC_MAX_CONNECT,
                           LB_GETTEXT,
                           (UINT)lResult, (LPARAM)szMaxConnectRate);
        if ((unsigned)lResult!=pPropParams->MaxConnectInitialValue)
        {
            PropertiesChanged = TRUE;
        }
    }

    hKey = SetupDiOpenDevRegKey(pPropParams->DeviceInfoSet,
                                pPropParams->DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_ALL_ACCESS);

    if (hKey == INVALID_HANDLE_VALUE)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller:WriteRegistrySettings:SetupDiOpenDevRegKey failed\n"));
#endif
    }
    else
    {
        if (pPropParams->SerialBased)
        {
            TCHAR szLocation[128], *pszLocationFmt;


            Result = RegSetValueEx(hKey,
                                   TEXT("Port"),
                                   0,
                                   REG_SZ,
                                   (LPBYTE)szPort,
                                   lstrlen(szPort)*sizeof(szPort[0]));
#if 0
            if(MyLoadString(ghDllInst, IDS_LOCATION_FORMAT, &pszLocationFmt))
            {
                wsprintf(szLocation, pszLocationFmt, szPort);
                LocalFree(pszLocationFmt);
            }
            else
            {
                szLocation[0] = 0;
            }
#else
            lstrcpy(szLocation,szPort);
#endif
            SetupDiSetDeviceRegistryProperty(pPropParams->DeviceInfoSet,
                                             pPropParams->DeviceInfoData,
                                             SPDRP_LOCATION_INFORMATION,
                                             (LPBYTE)szLocation,
                                             (lstrlen(szLocation)+1)*sizeof(TCHAR));
        }

        if (Result==ERROR_SUCCESS)
        {
            Result = RegSetValueEx(hKey,
                                   TEXT("MaxConnectRate"),
                                   0,
                                   REG_SZ,
                                   (LPBYTE)szMaxConnectRate,
                                   lstrlen(szMaxConnectRate)*sizeof(szMaxConnectRate[0]));
        }
        RegCloseKey(hKey);
    }


    if (Result==ERROR_SUCCESS && PropertiesChanged)
    {
        if (pPropParams->FirstTimeInstall)
        {
            // On a first time install, NT may not look for the PROPCHANGE_PENDING bit.
            // Instead we will notify that the driver needs to be restarted ourselves,
            // so that the changes we're writing get picked up.
            SP_DEVINSTALL_PARAMS DevInstallParams;
            SP_PROPCHANGE_PARAMS PropChangeParams;

            ZeroMemory(&PropChangeParams, sizeof(SP_PROPCHANGE_PARAMS));

            PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            PropChangeParams.StateChange = DICS_PROPCHANGE;
            PropChangeParams.Scope = DICS_FLAG_GLOBAL;

            if (SetupDiSetClassInstallParams(pPropParams->DeviceInfoSet,
                                             pPropParams->DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                             sizeof(SP_PROPCHANGE_PARAMS))
                )
            {

                DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if(SetupDiGetDeviceInstallParams(pPropParams->DeviceInfoSet,
                                                 pPropParams->DeviceInfoData,
                                                 &DevInstallParams))
                {
                    DevInstallParams.Flags |= DI_CLASSINSTALLPARAMS;

                    SetupDiSetDeviceInstallParams(pPropParams->DeviceInfoSet,
                                                  pPropParams->DeviceInfoData,
                                                  &DevInstallParams);
                }
                else
                {
#if DBG
                    OutputDebugString(TEXT("IrSIRCoClassInstaller:WriteRegistrySettings:SetupDiGetDeviceInstallParams failed 1\n"));
#endif
                }

                SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                          pPropParams->DeviceInfoSet,
                                          pPropParams->DeviceInfoData);

                if(SetupDiGetDeviceInstallParams(pPropParams->DeviceInfoSet,
                                                 pPropParams->DeviceInfoData,
                                                 &DevInstallParams))
                {
                    DevInstallParams.Flags |= DI_PROPERTIES_CHANGE;

                    SetupDiSetDeviceInstallParams(pPropParams->DeviceInfoSet,
                                                  pPropParams->DeviceInfoData,
                                                  &DevInstallParams);
                }
                else
                {
#if DBG
                    OutputDebugString(TEXT("IrSIRCoClassInstaller:WriteRegistrySettings:SetupDiGetDeviceInstallParams failed 2\n"));
#endif
                }

            }
            else
            {
#if DBG
                OutputDebugString(TEXT("IrSIRCoClassInstaller:WriteRegistrySettings:SetupDiSetClassInstallParams failed \n"));
#endif
            }
        }
        else
        {
            // This is the case where the user has changed settings in the property
            // sheet.  Life is much easier.
            SP_DEVINSTALL_PARAMS DevInstallParams;
            //
            // The changes are written, notify the world to reset the driver.
            //

            DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(SetupDiGetDeviceInstallParams(pPropParams->DeviceInfoSet,
                                             pPropParams->DeviceInfoData,
                                             &DevInstallParams))
            {
                LONG ChangeResult;
                DevInstallParams.FlagsEx |= DI_FLAGSEX_PROPCHANGE_PENDING;

                ChangeResult =
                SetupDiSetDeviceInstallParams(pPropParams->DeviceInfoSet,
                                              pPropParams->DeviceInfoData,
                                              &DevInstallParams);
#if DBG
                {
                    wsprintf(buf, TEXT("SetupDiSetDeviceInstallParams(DI_FLAGSEX_PROPCHANGE_PENDING)==%d %x\n"), ChangeResult, GetLastError());
                    OutputDebugString(buf);
                }
#endif
            }
            else
            {
#if DBG
                OutputDebugString(TEXT("IrSIRCoClassInstaller:WriteRegistrySettings:SetupDiGetDeviceInstallParams failed 2\n"));
#endif
            }
        }


    }

#if DBG
    {
        wsprintf(buf, TEXT("IrSIRCoClassInstaller:Result==%x FirstTimeInstall==%d Changed==%d\n"),
                 Result, pPropParams->FirstTimeInstall, PropertiesChanged);
        OutputDebugString(buf);
    }
#endif

    return Result;
}


INT_PTR APIENTRY PortDlgProc(IN HWND   hDlg,
                             IN UINT   uMessage,
                             IN WPARAM wParam,
                             IN LPARAM lParam)
/*++

Routine Description:

    The windows control function for the IrDA Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
{
    ULONG i;
    TCHAR  CharBuffer[LINE_LEN];
    PPROPPAGEPARAMS pPropParams;
    TCHAR buf[100];

    pPropParams = (PPROPPAGEPARAMS)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
        case WM_INITDIALOG:

            //
            // lParam points to one of two possible objects.  If we're a property
            // page, it points to the PropSheetPage structure.  If we're a regular
            // dialog box, it points to the PROPPAGEPARAMS structure.  We can
            // verify which because the first field of PROPPAGEPARAMS is a signature.
            //
            // In either case, once we figure out which, we store the value into
            // DWL_USER so we only have to do this once.
            //
            pPropParams = (PPROPPAGEPARAMS)lParam;
            if (pPropParams->Signature!=PPParamsSignature)
            {
                pPropParams = (PPROPPAGEPARAMS)((LPPROPSHEETPAGE)lParam)->lParam;
                if (pPropParams->Signature!=PPParamsSignature)
                {
#if DBG
                    OutputDebugString(TEXT("IRCLASS.DLL: PortDlgProc Signature not found!\n"));
#endif
                    return FALSE;
                }
            }
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pPropParams);



            if (!pPropParams->FirstTimeInstall)
            {
                InitMaxConnect(pPropParams, hDlg);

                pPropParams->SerialBased = EnablePortSelection(pPropParams->DeviceInfoSet,
                                                               pPropParams->DeviceInfoData,
                                                               hDlg);
                if (pPropParams->SerialBased)
                {
                    EnumSerialDevices(pPropParams, hDlg, &i);
                }

                InitDescription(pPropParams->DeviceInfoSet,
                                pPropParams->DeviceInfoData,
                                hDlg);
            }
            else
            {
                pPropParams->SerialBased = TRUE;
                EnumSerialDevices(pPropParams, hDlg, &i);

                if (i > 0) {
                    //
                    //  there were some port availible
                    //
                    // Enable next and cancel wizard buttons.  BACK is not valid here,
                    // since the device is already installed at this point.  Cancel
                    // will cause the device to be removed.
                    //
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                }
                EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
            }

            return TRUE;  // No need for us to set the focus.

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case LBN_SELCHANGE:
                    {
#if DBG
                        OutputDebugString(TEXT("IrSIRCoClassInstaller:PropertySheet Changed\n"));
#endif
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    return TRUE;

                default:
                    break;
            }

            switch (LOWORD(wParam))
            {
                    //
                    // Because this is a prop sheet, we should never get this.
                    // All notifications for ctrols outside of the sheet come through
                    // WM_NOTIFY
                    //
                case IDCANCEL:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    EndDialog(hDlg, uMessage);
                    return TRUE;
                case IDOK:
                {
                    WriteRegistrySettings(hDlg, pPropParams);

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    EndDialog(hDlg, uMessage);
                    return TRUE;
                }

                default:
                    return FALSE;
            }

        case WM_NOTIFY:

            switch (((NMHDR *)lParam)->code)
            {
                //
                // Sent when the user clicks on Apply OR OK !!
                //
                case PSN_WIZNEXT:
                    if (!pPropParams->FirstTimeInstall)
                    {
                        break;
                    }
                case PSN_APPLY:
                {
                    WriteRegistrySettings(hDlg, pPropParams);

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
                }

                default:
                    return FALSE;
            }

        case WM_DESTROY:
            //
            // free the description of the com ports.  If any msgs are processed
            // after WM_DESTROY, do not reference pPropParams!!!  To enforce this,
            // set the DWL_USER stored long to 0
            //
            LocalFree(pPropParams);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);

        case WM_HELP:
            if (lParam)
            {
                return WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                               (LPCTSTR)szHelpFile,
                               HELP_WM_HELP,
                               (ULONG_PTR)HelpIDs);
            }
            else
            {
                return FALSE;
            }
        case WM_CONTEXTMENU:
            return WinHelp((HWND)wParam,
                           (LPCTSTR)szHelpFile,
                           HELP_CONTEXTMENU,
                           (ULONG_PTR)HelpIDs);

        default:
            return FALSE;
    }

} /* PortDialogProc */


void PortSelectionDlg(
                       HDEVINFO DeviceInfoSet,
                       PSP_DEVINFO_DATA DeviceInfoData
                      )
/*++

Routine Description:

    PropSheet setup for devnode configuration.

Arguments:

    DeviceInfoSet - As passed in to IrSIRClassCoInstaller
    DeviceInfoData - As passed in to IrSIRClassCoInstaller

Return Value:

--*/
{
    HKEY hKey = 0;
    PPROPPAGEPARAMS  pPropParams = NULL;
    PROPSHEETHEADER  PropHeader;
    PROPSHEETPAGE    PropSheetPage;
    TCHAR            buf[100];
    LPTSTR   Title=NULL;
    LPTSTR   SubTitle=NULL;



    SP_NEWDEVICEWIZARD_DATA WizData;

    WizData.ClassInstallHeader.cbSize = sizeof(WizData.ClassInstallHeader);

    if (!SetupDiGetClassInstallParams(DeviceInfoSet,
                                      DeviceInfoData,
                                      (PSP_CLASSINSTALL_HEADER)&WizData,
                                      sizeof(WizData),
                                      NULL)
        || WizData.ClassInstallHeader.InstallFunction!=DIF_NEWDEVICEWIZARD_FINISHINSTALL)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller: Failed to get ClassInstall params\n"));
#endif
        return;
    }

#if DBG
    OutputDebugString(TEXT("IrSIRCoClassInstaller: PortSelectionDlg\n"));
#endif

    pPropParams = LocalAlloc(LMEM_FIXED, sizeof(PROPPAGEPARAMS));
    if (!pPropParams)
    {
        return;
    }

    pPropParams->Signature = PPParamsSignature;
    pPropParams->DeviceInfoSet =  DeviceInfoSet;
    pPropParams->DeviceInfoData = DeviceInfoData;
    pPropParams->FirstTimeInstall = TRUE;

    if (WizData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
    {
        //
        // Setup the advanced properties window information
        //
        BOOLEAN bResult;
        DWORD   RequiredSize = 0;
        DWORD   dwTotalSize = 0;
        LONG    lResult;

        memset(&PropSheetPage, 0, sizeof(PropSheetPage));
        //
        // Add the Port Settings property page
        //
        PropSheetPage.dwSize      = sizeof(PROPSHEETPAGE);
        PropSheetPage.dwFlags     = PSP_DEFAULT; //PSP_USECALLBACK; // | PSP_HASHELP;
        PropSheetPage.hInstance   = ghDllInst;
        PropSheetPage.pszTemplate = MAKEINTRESOURCE(IDD_INSTALL_PORT_SELECT);

        //
        // following points to the dlg window proc
        //
        PropSheetPage.hIcon      = NULL;
        PropSheetPage.pfnDlgProc = PortDlgProc;
        PropSheetPage.lParam     = (LPARAM)pPropParams;

        //
        // following points to some control callback of the dlg window proc
        //
        PropSheetPage.pfnCallback = NULL;

        PropSheetPage.pcRefParent = NULL;

        if ( 0 != MyLoadString(ghDllInst, IDS_SELECT_PORT_TITLE, &Title)) {

            // We don't use these, but if we wanted to...
            PropSheetPage.dwFlags |= PSP_USEHEADERTITLE;
            PropSheetPage.pszHeaderTitle = Title;

        }

        if (0 != MyLoadString(ghDllInst, IDS_SELECT_PORT_SUBTITLE, &SubTitle)) {

            PropSheetPage.dwFlags |= PSP_USEHEADERSUBTITLE;
            PropSheetPage.pszHeaderSubTitle = SubTitle;

        }

        WizData.DynamicPages[WizData.NumDynamicPages] = CreatePropertySheetPage(&PropSheetPage);
        if (WizData.DynamicPages[WizData.NumDynamicPages])
        {
            WizData.NumDynamicPages++;
        }

        SetupDiSetClassInstallParams(DeviceInfoSet,
                                     DeviceInfoData,
                                     (PSP_CLASSINSTALL_HEADER)&WizData,
                                     sizeof(WizData));

        if (Title != NULL) {

            LocalFree(Title);
        }

        if (SubTitle != NULL) {

            LocalFree(SubTitle);
        }

    }
    else
    {
        LocalFree(pPropParams);
    }
} /* PortSelectionDlg */


VOID
DestroyPrivateData(PCOINSTALLER_PRIVATE_DATA pPrivateData)
/*++

Routine Description:

    Function to dealloc/destroy context data

Arguments:

    pPrivateData - Context buffer to dealloc/destroy

Return Value:

    none

--*/
{
    if (pPrivateData)
    {
        if (pPrivateData->hInf!=INVALID_HANDLE_VALUE)
        {
            SetupCloseInfFile(pPrivateData->hInf);
        }
        LocalFree(pPrivateData);
        pPrivateData = NULL;
    }
}

PCOINSTALLER_PRIVATE_DATA
CreatePrivateData(
                  IN     HDEVINFO                     DeviceInfoSet,
                  IN     PSP_DEVINFO_DATA             DeviceInfoData OPTIONAL
                  )
/*++

Routine Description:

    Allocs and initailizes private context data buffer

Arguments:

    DeviceInfoSet - As passed in to IrSIRClassCoInstaller
    DeviceInfoData - As passed in to IrSIRClassCoInstaller

Return Value:

    Pointer to alloced context data, or NULL if failure.  Call GetLastError()
    for extended error information.

--*/
{
    PCOINSTALLER_PRIVATE_DATA pPrivateData;
    BOOL Status = TRUE;
    UINT ErrorLine;
    TCHAR buf[100];

    pPrivateData = LocalAlloc(LPTR, sizeof(COINSTALLER_PRIVATE_DATA));

    if (!pPrivateData)
    {
#if DBG
        OutputDebugString(TEXT("IrSIRCoClassInstaller: Insufficient Memory\n"));
#endif
        Status = FALSE;
    }
    else
    {
        pPrivateData->DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        Status = SetupDiGetSelectedDriver(DeviceInfoSet,
                                          DeviceInfoData,
                                          &pPrivateData->DriverInfoData);
        if (!Status)
        {
#if DBG
            wsprintf(buf, TEXT("IrSIRCoClassInstaller:SetupDiGetSelectedDriver failed (%d)\n"), GetLastError());
            OutputDebugString(buf);
#endif
        }
    }

    if (Status)
    {
        pPrivateData->DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        Status = SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                            DeviceInfoData,
                                            &pPrivateData->DriverInfoData,
                                            &pPrivateData->DriverInfoDetailData,
                                            sizeof(SP_DRVINFO_DETAIL_DATA),
                                            NULL);

        if (!Status)
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                // We don't need the extended information.  Ignore.
                Status = TRUE;
            }
            else
            {
#if DBG
                wsprintf(buf, TEXT("IrSIRCoClassInstaller:SetupDiGetDriverInfoDetail failed (%d)\n"), GetLastError());
                OutputDebugString(buf);
#endif
            }
        }
    }


    if (Status)
    {
        pPrivateData->hInf = SetupOpenInfFile(pPrivateData->DriverInfoDetailData.InfFileName,
                                              NULL,
                                              INF_STYLE_WIN4,
                                              &ErrorLine);

        if (pPrivateData->hInf==INVALID_HANDLE_VALUE)
        {
            Status = FALSE;
#if DBG
            wsprintf(buf, TEXT("IrSIRCoClassInstaller:SetupOpenInfFile failed (%d) ErrorLine==%d\n"), GetLastError(), ErrorLine);
            OutputDebugString(buf);
#endif
        }
    }

    if (Status)
    {
        // Translate to the .NT name, if present.
        Status = SetupDiGetActualSectionToInstall(pPrivateData->hInf,
                                                  pPrivateData->DriverInfoDetailData.SectionName,
                                                  pPrivateData->InfSectionWithExt,
                                                  LINE_LEN,
                                                  NULL,
                                                  NULL);

        if (!Status)
        {
#if DBG
            OutputDebugString(TEXT("IrSIRCoClassInstaller:SetupDiGetActualSectionToInstall failed\n"));
#endif
        }

    }

    if (!Status)
    {
        // We experienced some failure.  Cleanup.

        DestroyPrivateData(pPrivateData);
        pPrivateData = NULL;
    }

    return pPrivateData;
}

DWORD
IrSIRClassCoInstaller(
                     IN     DI_FUNCTION                  InstallFunction,
                     IN     HDEVINFO                     DeviceInfoSet,
                     IN     PSP_DEVINFO_DATA             DeviceInfoData OPTIONAL,
                     IN OUT PCOINSTALLER_CONTEXT_DATA    pContext
                     )
/*++

Routine Description:

    This routine acts as the class coinstaller for SIR devices.  This is set up
    to be called by the INF:

[MS_Devices]
; DisplayName           Section       	DeviceID
; -----------           -------       	--------
%*PNP0510.DevDesc%    = PNP,      	*PNP0510

[PNP.NT.CoInstallers]
AddReg                = IRSIR.CoInstallers.reg

[IRSIR.CoInstallers.reg]
HKR,,CoInstallers32,0x00010000,"IRCLASS.dll,IrSIRClassCoInstaller"


Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    ERROR_DI_DO_DEFAULT, ERROR_DI_POSTPROCESSING_REQUIRED, or error code

--*/
{
    TCHAR buf[100];
    DWORD Result = ERROR_SUCCESS;
    LONG lResult;
    PCOINSTALLER_PRIVATE_DATA pPrivateData;
    INFCONTEXT InfContext;

#if DBG
    wsprintf(buf, TEXT("IrSIRCoClassInstaller:InstallFunction(%s) PostProcessing:%d\n"), GetDIFString(InstallFunction), pContext->PostProcessing);
    OutputDebugString(buf);
#endif


    switch (InstallFunction)
    {
        case DIF_INSTALLDEVICE:
        {
            UINT ErrorLine;

            // Private data for coinstallers is only kept across a single call,
            // pre and post processing.  The private data that we create here
            // is not any good for any other DIF_ call.
            pContext->PrivateData = CreatePrivateData(DeviceInfoSet,
                                                      DeviceInfoData);

            if (!pContext->PrivateData)
            {
                return GetLastError();
            }

            pPrivateData = pContext->PrivateData;

            {
                // NOTE on the use of UPPERFILTERS and LOWERFILTERS
                // A filter driver is a driver that is loaded as a shim above
                // or below another driver, in this case SERIAL below IRSIR.
                // It does special processing on IRPs and can give added
                // functionality or is a means to avoid duplicate functionality
                // in multiple drivers.  UPPERFILTERS and LOWERFILTERS values
                // are used by the PnP system to identify and load filter
                // drivers.  These values could be set via the INF in a .HW
                // section, but setting them via the coinstaller may give you
                // more control, i.e. you could remove one of several filter
                // drivers from a list.
                //
                // If your driver isn't a filter driver, or doesn't use filter
                // drivers, you won't need to clear these values as is done
                // here.


                // Always clear UpperFilters.  If this is an upgrade from
                // a post-1671, the IrDA device could have been installed as
                // a serial port, with a serenum upper filter.  This will
                // blow up NDIS, so clear it.
                //
                // This is atypical behavior for a class coinstaller.  Normally
                // the upperfilter/lowerfilter values do not need to be touched.

                // Note that it is possible to do this from the INF.  This
                // is here more for demo purpose.

                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 0);
            }

            if (SetupFindFirstLine(pPrivateData->hInf,
                                   pPrivateData->InfSectionWithExt,
                                   TEXT("LowerFilters"),
                                   &InfContext))
            {
                TCHAR LowerFilters[LINE_LEN];
                DWORD BytesNeeded;
                if (!SetupGetMultiSzField(&InfContext, 1, LowerFilters, LINE_LEN, &BytesNeeded))
                {
                    // Lowerfilters value was not found in the inf.
                    // This means we do not want a lowerfilters value in
                    // the registry.  (Unique to IRSIR.SYS and NETIRSIR.INF)

                    // Setting lowerfilters here for demo purpose only.
                    // Normally done from INF, if necessary at all.
                    if (!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                          DeviceInfoData,
                                                          SPDRP_LOWERFILTERS,
                                                          NULL,
                                                          0)
                       )
                    {
#if DBG
                        OutputDebugString(TEXT("IrSIRCoClassInstaller: Failed to set lowerfilter\n"));
#endif
                    }

                }
                else
                {
                    // Setting lowerfilters here for demo purpose only.
                    // Normally done from INF, if necessary at all.
                    if (!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                          DeviceInfoData,
                                                          SPDRP_LOWERFILTERS,
                                                          (LPBYTE)LowerFilters,
                                                          ((BytesNeeded<LINE_LEN) ?
                                                           BytesNeeded : LINE_LEN)*sizeof(TCHAR))
                       )
                    {
#if DBG
                        OutputDebugString(TEXT("IrSIRCoClassInstaller: Failed to set lowerfilter\n"));
#endif
                    }
                }
            }
            else
            {
                // No lowerfilters value present.  Clear it.
                // Setting lowerfilters here for demo purpose only.
                // Normally done from INF, if necessary at all.
                if (!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                      DeviceInfoData,
                                                      SPDRP_LOWERFILTERS,
                                                      NULL,
                                                      0)
                   )
                {
#if DBG
                    OutputDebugString(TEXT("IrSIRCoClassInstaller: Failed to set lowerfilter\n"));
#endif
                }
            }

            DestroyPrivateData(pContext->PrivateData);
            pContext->PrivateData = NULL;
            break;
        }
        case DIF_NEWDEVICEWIZARD_FINISHINSTALL:
        {
            pContext->PrivateData = CreatePrivateData(DeviceInfoSet,
                                                      DeviceInfoData);

            if (!pContext->PrivateData)
            {
                return GetLastError();
            }

            pPrivateData = pContext->PrivateData;

            if (!SetupFindFirstLine(pPrivateData->hInf,
                                    pPrivateData->InfSectionWithExt,
                                    TEXT("PromptForPort"),
                                    &InfContext))
            {
#if DBG
                OutputDebugString(TEXT("IrSIRCoClassInstaller:failed to find PromptForPort in .INF\n"));
#endif
            }
            else
            {
                if (!SetupGetIntField(&InfContext, 1, &pPrivateData->PromptForPort))
                {
#if DBG
                    OutputDebugString(TEXT("IrSIRCoClassInstaller:failed to read PromptForPort in .INF\n"));
#endif

                    // Default to true
                    pPrivateData->PromptForPort = TRUE;
                }

                // If we have a COM port we need to query the user, UNLESS
                // this is an upgrade.
                if (pPrivateData->PromptForPort && !IsPortValueSet(DeviceInfoSet, DeviceInfoData))
                {
                    PortSelectionDlg(DeviceInfoSet, DeviceInfoData);
                }
            }
            if (!pPrivateData->PromptForPort)
            {
                TCHAR *pszLocation;
                if (MyLoadString(ghDllInst, IDS_INTERNAL_PORT, &pszLocation))
                {
                    SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_LOCATION_INFORMATION,
                                                     (LPBYTE)pszLocation,
                                                     (1+lstrlen(pszLocation))*sizeof(TCHAR));
                    LocalFree(pszLocation);
                }

            }

            DestroyPrivateData(pContext->PrivateData);
            pContext->PrivateData = NULL;
            break;
        }
        default:
        {
            break;
        }
    }
#if DBG
    wsprintf(buf, TEXT("IrSIRCoClassInstaller:returning:0x%08x\n"), Result);
    OutputDebugString(buf);
#endif
    return Result;
}


BOOL APIENTRY IrSIRPortPropPageProvider(LPVOID               pinfo,
                                        LPFNADDPROPSHEETPAGE pfnAdd,
                                        LPARAM               lParam
                                       )
/*++

Routine Description:

    Entry-point for adding additional device manager property
    sheet pages.  This entry-point gets called only when the Device
    Manager asks for additional property pages.  The INF associated with
    this causes it to be called by specifying it in an AddReg section:

[IRSIR.reg]
HKR,  ,               EnumPropPages32,	,	"IRCLASS.dll,IrSIRPortPropPageProvider"


Arguments:

    pinfo  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    pfnAdd - function ptr to call to add sheet.
    lParam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
{
    PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
    HKEY hKey = 0;
    PROPSHEETPAGE    PropSheetPage;
    HPROPSHEETPAGE   hspPropSheetPage;
    PPROPPAGEPARAMS  pPropParams = NULL;

    pPropParams = LocalAlloc(LMEM_FIXED, sizeof(PROPPAGEPARAMS));
    if (!pPropParams)
    {
        return FALSE;
    }

    pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) pinfo;

    pPropParams->Signature = PPParamsSignature;
    pPropParams->DeviceInfoSet = pprPropPageRequest->DeviceInfoSet;
    pPropParams->DeviceInfoData = pprPropPageRequest->DeviceInfoData;
    pPropParams->FirstTimeInstall = FALSE;

    if (pprPropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
    {
        //
        // Setup the advanced properties window information
        //
        BOOLEAN bResult;
        DWORD   RequiredSize = 0;
        DWORD   dwTotalSize = 0;

        memset(&PropSheetPage, 0, sizeof(PropSheetPage));
        //
        // Add the Port Settings property page
        //
        PropSheetPage.dwSize      = sizeof(PROPSHEETPAGE);
        PropSheetPage.dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
        PropSheetPage.hInstance   = ghDllInst;
        PropSheetPage.pszTemplate = MAKEINTRESOURCE(IDD_PP_IRDA_SETTINGS);

        //
        // following points to the dlg window proc
        //
        PropSheetPage.pfnDlgProc = PortDlgProc;
        PropSheetPage.lParam     = (LPARAM)pPropParams;

        //
        // following points to some control callback of the dlg window proc
        //
        PropSheetPage.pfnCallback = NULL;

        //
        // allocate our "Ports Setting" sheet
        //
        hspPropSheetPage = CreatePropertySheetPage(&PropSheetPage);
        if (!hspPropSheetPage)
        {
            return FALSE;
        }

        //
        // add the thing in.
        //
        if (!pfnAdd(hspPropSheetPage, lParam))
        {
            DestroyPropertySheetPage(hspPropSheetPage);
            return FALSE;
        }
    }
    else
    {
        LocalFree(pPropParams);
    }

    return TRUE;

} /* IrSIRPortPropPageProvider */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irclass\irclass.h ===
#include "resource.h"

#define PPParamsSignature       'IrDA'

typedef struct
{
    ULONG                       Signature;
    HDEVINFO                    DeviceInfoSet;
    PSP_DEVINFO_DATA            DeviceInfoData;
    BOOL                        FirstTimeInstall;
    BOOL                        SerialBased;
    ULONG                       MaxConnectInitialValue;
    ULONG                       PortInitialValue;
} PROPPAGEPARAMS, *PPROPPAGEPARAMS;

typedef struct 
{
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DRVINFO_DETAIL_DATA  DriverInfoDetailData;
    HINF                    hInf;
    TCHAR                   InfSectionWithExt[LINE_LEN];
    UINT                    PromptForPort;
} COINSTALLER_PRIVATE_DATA, *PCOINSTALLER_PRIVATE_DATA;

#define OUT_OF_MEMORY_MB gszOutOfMemory, gszTitle, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irenum\enum.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the irenum driver

Author:

    Brian Lieuallen, 7-13-2000

Environment:

    Kernel mode

Revision History :

--*/

#include "internal.h"

#define UINT ULONG //tmp

#include <irioctl.h>

//#include <af_irda.h>
//#include <irdatdi.h>

//#include <ircommtdi.h>

#define MAX_DEVICES  16

#define STATIC_DEVICE_NAME  L"Incoming IRCOMM"
#define STATIC_HARDWARE_ID  L"IR_NULL_IN"

int sprintf(char *, ...);

typedef struct _ENUM_OBJECT {

    PVOID    ThreadObject;
    KEVENT   WaitEvent;
    KTIMER   Timer;

    PDEVICE_OBJECT    Fdo;

    ULONG             DeviceCount;
    IR_DEVICE         Devices[MAX_DEVICES];

    PASSIVE_LOCK      PassiveLock;

} ENUM_OBJECT, *PENUM_OBJECT;


VOID
WorkerThread(
    PVOID    Context
    );

NTSTATUS
EnumIrda(
    PENUM_OBJECT    EnumObject
    );

NTSTATUS
DoIasQueries(
    PIR_DEVICE    IrDevice
    );


NTSTATUS
CreatePdo(
    PDEVICE_OBJECT    Fdo,
    PIR_DEVICE        IrDevice
    );


NTSTATUS
CreateStaticDevice(
    PENUM_OBJECT    EnumObject
    )

{
    NTSTATUS          Status;
    ULONG             DeviceId=0;
    PIR_DEVICE        IrDevice=&EnumObject->Devices[0];

    //
    //  zero the whole thing
    //
    RtlZeroMemory(IrDevice,sizeof(*IrDevice));

    //
    //  inuse now
    //
    IrDevice->InUse=TRUE;

    IrDevice->Present=TRUE;

    IrDevice->Static=TRUE;

    EnumObject->DeviceCount++;


    RtlCopyMemory(&IrDevice->DeviceId,&DeviceId,4);


    RtlCopyMemory(
        IrDevice->DeviceName,
        STATIC_DEVICE_NAME,
        sizeof(STATIC_DEVICE_NAME)
        );


    IrDevice->Name=ALLOCATE_PAGED_POOL(sizeof(STATIC_DEVICE_NAME));

    if (IrDevice->Name == NULL) {

        Status=STATUS_NO_MEMORY;
        goto CleanUp;
    }

    RtlCopyMemory(
        IrDevice->Name,
        STATIC_DEVICE_NAME,
        sizeof(STATIC_DEVICE_NAME)
        );


    IrDevice->HardwareId=ALLOCATE_PAGED_POOL(sizeof(STATIC_HARDWARE_ID));

    if (IrDevice->HardwareId == NULL) {

        Status=STATUS_NO_MEMORY;
        goto CleanUp;
    }

    RtlCopyMemory(
        IrDevice->HardwareId,
        STATIC_HARDWARE_ID,
        sizeof(STATIC_HARDWARE_ID)
        );


    Status=CreatePdo(
        EnumObject->Fdo,
        IrDevice
        );

    if (NT_SUCCESS(Status)) {

        return Status;
    }

CleanUp:

    if (IrDevice->Name != NULL) {

        FREE_POOL(IrDevice->Name);
    }


    if (IrDevice->HardwareId != NULL) {

        FREE_POOL(IrDevice->HardwareId);
    }

    RtlZeroMemory(IrDevice,sizeof(&IrDevice));

    EnumObject->DeviceCount--;

    return Status;
}

NTSTATUS
CreateEnumObject(
    PDEVICE_OBJECT  Fdo,
    ENUM_HANDLE    *Object,
    BOOLEAN         StaticDevice
    )

{
    NTSTATUS        Status;
    PENUM_OBJECT    EnumObject;
    HANDLE          ThreadHandle;

    *Object=NULL;

    EnumObject=ALLOCATE_NONPAGED_POOL(sizeof(*EnumObject));

    if (EnumObject==NULL) {

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(EnumObject,sizeof(*EnumObject));

    EnumObject->Fdo=Fdo;

    if (StaticDevice) {

        CreateStaticDevice(EnumObject);
    }

    INIT_PASSIVE_LOCK(&EnumObject->PassiveLock);

    KeInitializeEvent(
        &EnumObject->WaitEvent,
        NotificationEvent,
        FALSE
        );

    KeInitializeTimer(
        &EnumObject->Timer
        );


    Status=PsCreateSystemThread(
        &ThreadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        NULL,
        NULL,
        WorkerThread,
        EnumObject
        );

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    Status=ObReferenceObjectByHandle(
        ThreadHandle,
        0,
        NULL,
        KernelMode,
        &EnumObject->ThreadObject,
        NULL
        );

    ZwClose(ThreadHandle);
    ThreadHandle=NULL;

    if (!NT_SUCCESS(Status)) {

        goto CleanUp;
    }

    *Object=EnumObject;

    return Status;


CleanUp:

    KeSetEvent(
        &EnumObject->WaitEvent,
        IO_NO_INCREMENT,
        FALSE
        );

    //
    //  make sure we really got the object
    //
    if (EnumObject->ThreadObject != NULL) {

        KeWaitForSingleObject(
            EnumObject->ThreadObject,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        ObDereferenceObject(EnumObject->ThreadObject);

    } else {

        ASSERT(0);
    }

    FREE_POOL(EnumObject);


    return Status;

}


VOID
CloseEnumObject(
    ENUM_HANDLE    Handle
    )

{
    PENUM_OBJECT    EnumObject=Handle;
    ULONG           j;

    KeSetEvent(
        &EnumObject->WaitEvent,
        IO_NO_INCREMENT,
        FALSE
        );


    KeWaitForSingleObject(
        EnumObject->ThreadObject,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );


    ObDereferenceObject(EnumObject->ThreadObject);

    for (j=0; j< MAX_DEVICES; j++) {
        //
        //  if remove it
        //
        if (EnumObject->Devices[j].InUse) {
            //
            //  not enumerated any more since tha parent is going away
            //
            EnumObject->Devices[j].Enumerated=FALSE;

            RemoveDevice(EnumObject,&EnumObject->Devices[j]);
        }
    }


    FREE_POOL(EnumObject);

    return;
}






VOID
WorkerThread(
    PVOID    Context
    )

{

    NTSTATUS        Status;
    PENUM_OBJECT    EnumObject=Context;

    PVOID           ObjectArray[2];

    D_PNP(DbgPrint("IRENUM: WorkerThread: started\n");)

    ObjectArray[0]=&EnumObject->WaitEvent;
    ObjectArray[1]=&EnumObject->Timer;

    while (1) {

        LARGE_INTEGER  DueTime;
        DueTime.QuadPart = -10*1000*10000;

        KeSetTimer(
            &EnumObject->Timer,
            DueTime,
            NULL
            );


        Status=KeWaitForMultipleObjects(
            2,
            &ObjectArray[0],
            WaitAny,
            Executive,
            KernelMode,
            FALSE,
            NULL,
            NULL
            );

        if (Status == 0) {
            //
            //  the event was signaled, time to exit
            //
            break;

        } else {

            if (Status == 1) {
                //
                //  the time expired, check for devices
                //
//                D_PNP(DbgPrint("IRENUM: WorkerThread: Timer expired\n");)

                ACQUIRE_PASSIVE_LOCK(&EnumObject->PassiveLock);

                EnumIrda(EnumObject);

                RELEASE_PASSIVE_LOCK(&EnumObject->PassiveLock);

            } else {

                ASSERT(0);
            }
        }
    }

    KeCancelTimer(&EnumObject->Timer);

    D_PNP(DbgPrint("IRENUM: WorkerThread: stopping\n");)

    PsTerminateSystemThread(STATUS_SUCCESS);

    return;

}


NTSTATUS
DeviceNameFromDeviceInfo(
    PIRDA_DEVICE_INFO   DeviceInfo,
    PWCHAR              DeviceName,
    ULONG               NameLength
    )

{

    NTSTATUS          Status=STATUS_SUCCESS;
    WCHAR             TempBuffer[23];
    UNICODE_STRING    UnicodeString;

    //
    //  zero out the temp buffer, so we can copy the remote device name,
    //  so we can be sure it is null terminated
    //
    RtlZeroMemory(TempBuffer,sizeof(TempBuffer));

    RtlCopyMemory(TempBuffer,DeviceInfo->irdaDeviceName,sizeof(DeviceInfo->irdaDeviceName));

    UnicodeString.Length=0;
    UnicodeString.MaximumLength=(USHORT)(NameLength-1)*sizeof(WCHAR);
    UnicodeString.Buffer=DeviceName;

    RtlZeroMemory(UnicodeString.Buffer,UnicodeString.MaximumLength);

    if (DeviceInfo->irdaCharSet == LmCharSetUNICODE) {
        //
        //  the name is unicode
        //
        Status=RtlAppendUnicodeToString(&UnicodeString,TempBuffer);

    } else {
        //
        //  the name is ansi, need to convert unicode
        //
        ANSI_STRING    AnsiString;

        RtlInitAnsiString(
            &AnsiString,
            (PCSZ)TempBuffer
            );

        Status=RtlAnsiStringToUnicodeString(
            &UnicodeString,
            &AnsiString,
            FALSE
            );

    }
    return Status;
}


NTSTATUS
EnumIrda(
    PENUM_OBJECT    EnumObject
    )

{
    NTSTATUS   Status;

    UCHAR           DevListBuf[512];

    PDEVICELIST     pDevList = (PDEVICELIST) DevListBuf;
    ULONG           DevListLen = sizeof(DevListBuf);
    ULONG           i;
    ULONG           j;
    BOOLEAN         InvalidateDeviceRelations=FALSE;

    Status = IrdaDiscoverDevices(pDevList, &DevListLen);

    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("IRENUM: DiscoveryFailed %08lx\n",Status);)

        return Status;
    }

//    D_PNP(DbgPrint("IRENUM: Found %d devices\n",pDevList->numDevice);)

    for (j=0; j< MAX_DEVICES; j++) {
        //
        //  first mark all the device not present
        //
        if (!EnumObject->Devices[j].Static) {
            //
            //  only non-static device go away
            //
            EnumObject->Devices[j].Present=FALSE;
        }
    }

    for (i=0; i < pDevList->numDevice; i++) {

        PIRDA_DEVICE_INFO   DeviceInfo=&pDevList->Device[i];
        ULONG               DeviceId;

        RtlCopyMemory(&DeviceId, &DeviceInfo->irdaDeviceID[0],4);

        for (j=0; j< MAX_DEVICES; j++) {

            WCHAR    TempBuffer[24];

            if (EnumObject->Devices[j].InUse) {

                DeviceNameFromDeviceInfo(
                        DeviceInfo,
                        TempBuffer,
                        sizeof(TempBuffer)/sizeof(WCHAR)
                        );

                if (0 == wcscmp(TempBuffer, EnumObject->Devices[j].DeviceName)) {
                    //
                    //  Already present
                    //
                    EnumObject->Devices[j].Present=TRUE;

                    if (DeviceId != EnumObject->Devices[j].DeviceId) {

                        D_ERROR(DbgPrint("IRENUM: Found Dup device %x devices\n",DeviceId);)
                        RtlCopyMemory(&EnumObject->Devices[j].DeviceId,&DeviceInfo->irdaDeviceID[0],4);
                    }

                    break;
                }
            }
        }

        if ( j < MAX_DEVICES) {
            //
            //  We found a match, skip this one
            //
            continue;
        }

        //
        //  at this point we have a new device
        //
        if ((DeviceInfo->irdaDeviceHints2 & 4)) {
            //
            //  it is an ircomm device
            //
            for (j=0; j< MAX_DEVICES; j++) {
                //
                //  find a slot not in use
                //
                if (!EnumObject->Devices[j].InUse) {
                    //
                    //  found a slot for it, zero the info
                    //
                    RtlZeroMemory(&EnumObject->Devices[j],sizeof(EnumObject->Devices[j]));

                    //
                    //  inuse now
                    //
                    EnumObject->Devices[j].InUse=TRUE;

                    EnumObject->Devices[j].Present=TRUE;

                    RtlCopyMemory(&EnumObject->Devices[j].DeviceId,&DeviceInfo->irdaDeviceID[0],4);

                    EnumObject->Devices[j].Hint1=DeviceInfo->irdaDeviceHints1;
                    EnumObject->Devices[j].Hint2=DeviceInfo->irdaDeviceHints2;

                    DeviceNameFromDeviceInfo(
                        DeviceInfo,
                        EnumObject->Devices[j].DeviceName,
                        sizeof(EnumObject->Devices[j].DeviceName)/sizeof(WCHAR)
                        );

                    DoIasQueries(
                        &EnumObject->Devices[j]
                        );

                    if (EnumObject->Devices[j].HardwareId != NULL) {

                        Status=CreatePdo(
                            EnumObject->Fdo,
                            &EnumObject->Devices[j]
                            );

                        D_PNP(DbgPrint(
                                  "IRENUM: Name %ws, device id=%08lx, hint1=%x, hint2=%x\n",
                                  EnumObject->Devices[j].DeviceName,
                                  EnumObject->Devices[j].DeviceId,
                                  EnumObject->Devices[j].Hint1,
                                  EnumObject->Devices[j].Hint2
                                  );)

                        //
                        //  new device
                        //
                        InvalidateDeviceRelations=TRUE;

                        EnumObject->DeviceCount++;

                    } else {
                        //
                        //  the device did not report a pnp hardware id
                        //
                        RtlZeroMemory(&EnumObject->Devices[j],sizeof(EnumObject->Devices[j]));
                    }

                    break;

                }
            }
        }
    }

    for (j=0; j< MAX_DEVICES; j++) {
        //
        //  lets see if any thing disappeared
        //
        if (EnumObject->Devices[j].InUse) {
            //
            //  found a slot that is in use
            //
            if (!EnumObject->Devices[j].Present) {
                //
                //  but it does not have a device present
                //
                InvalidateDeviceRelations=TRUE;
            }
        }
    }


    if (InvalidateDeviceRelations) {
        //
        //  tell the system to check the device relations because a device has appeared or
        //  disappeared
        //
        PFDO_DEVICE_EXTENSION FdoExtension=EnumObject->Fdo->DeviceExtension;

        IoInvalidateDeviceRelations(FdoExtension->Pdo,BusRelations);
    }


    return Status;
}


NTSTATUS
CreatePdo(
    PDEVICE_OBJECT    Fdo,
    PIR_DEVICE        IrDevice
    )

{
    NTSTATUS          Status;

    PDEVICE_OBJECT    NewPdo;

    Status = IoCreateDevice(
                 Fdo->DriverObject,
                 sizeof(PDO_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_BUS_EXTENDER,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &NewPdo
                 );

    if (NT_SUCCESS(Status)) {
        //
        //  got the device
        //
        PPDO_DEVICE_EXTENSION   PdoExtension=NewPdo->DeviceExtension;

        PdoExtension->DoType=DO_TYPE_PDO;

        PdoExtension->ParentFdo=Fdo;

//        PdoExtension->UnEnumerated=FALSE;

        PdoExtension->DeviceDescription=IrDevice;

        IrDevice->Pdo = NewPdo;

        NewPdo->Flags |= DO_POWER_PAGABLE;

        NewPdo->Flags &= ~DO_DEVICE_INITIALIZING;


    } else {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: IoCreateDevice() failed %08lx\n",Status);)

    }

    return Status;

}

VOID
FixupDeviceId(
    PWSTR   HardwareId
    )

{
    //
    // munge the hardware id to make sure it is compatable with the os requirements
    //
    while (*HardwareId != L'\0') {

        if ((*HardwareId < L' ') || (*HardwareId > 127) || (*HardwareId == L',')) {

            *HardwareId = L'?';
        }

        HardwareId++;
    }
    return;
}

NTSTATUS
DoIasQueries(
    PIR_DEVICE    IrDevice
    )

{
    NTSTATUS      Status;
    LONG          CompatCount;

    Status=IrdaIASStringQuery(
        IrDevice->DeviceId,
        "PnP",
        "Manufacturer",
        &IrDevice->Manufacturer
        );

    if (NT_SUCCESS(Status)) {

        DbgPrint("IRENUM: got pnp manufacturer %ws\n",IrDevice->Manufacturer);
    }

    Status=IrdaIASStringQuery(
        IrDevice->DeviceId,
        "PnP",
        "Name",
        &IrDevice->Name
        );

    if (NT_SUCCESS(Status)) {

        DbgPrint("IRENUM: got pnp name %ws\n",IrDevice->Name);
    }

    Status=IrdaIASStringQuery(
        IrDevice->DeviceId,
        "PnP",
        "DeviceID",
        &IrDevice->HardwareId
        );

    if (NT_SUCCESS(Status)) {

        DbgPrint("IRENUM: got pnp id %ws\n",IrDevice->HardwareId);

        FixupDeviceId(IrDevice->HardwareId);
    }

    //
    //  check for compat id's
    //
    IrDevice->CompatIdCount=0;

    Status=IrdaIASIntegerQuery(
        IrDevice->DeviceId,
        "PnP",
        "CompCnt",
        &CompatCount
        );

    if (NT_SUCCESS(Status)) {

        LONG   i;

        if ( CompatCount > 16) {

            CompatCount=16;

        } else {

            if ( CompatCount < 0) {

                CompatCount = 0;
            }
        }

        for (i=0; i< CompatCount; i++) {

            CHAR    Attribute[20];

            sprintf(Attribute,"Comp#%02d",i+1);

            Status=IrdaIASStringQuery(
                IrDevice->DeviceId,
                "PnP",
                Attribute,
                &IrDevice->CompatId[IrDevice->CompatIdCount]
                );

            if (NT_SUCCESS(Status)) {

                DbgPrint("IRENUM: got compat pnp id %ws\n",IrDevice->CompatId[IrDevice->CompatIdCount]);
                FixupDeviceId(IrDevice->CompatId[IrDevice->CompatIdCount]);

                IrDevice->CompatIdCount++;

            } else {

                D_ERROR(DbgPrint("IRENUM: could not get id for %s\n",Attribute);)
            }
        }
    }

    //
    //  Create a standard compat ID for all devices, so we can load a standard driver
    //
    IrDevice->CompatId[IrDevice->CompatIdCount]=ALLOCATE_PAGED_POOL(sizeof(IRENUM_COMPAT_ID));

    if (IrDevice->CompatId[IrDevice->CompatIdCount] != NULL) {

        RtlCopyMemory(IrDevice->CompatId[IrDevice->CompatIdCount],IRENUM_COMPAT_ID,sizeof(IRENUM_COMPAT_ID));
        IrDevice->CompatIdCount++;
    }


    return STATUS_SUCCESS;
}


NTSTATUS
GetDeviceList(
    ENUM_HANDLE    Handle,
    PIRP           Irp
    )

{
    PENUM_OBJECT    EnumObject=Handle;
    NTSTATUS        Status=STATUS_SUCCESS;

    PDEVICE_RELATIONS    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;
    PDEVICE_RELATIONS    NewRelations=NULL;
    ULONG                DeviceCount=EnumObject->DeviceCount;
    ULONG                i;

    ACQUIRE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    if (CurrentRelations != NULL) {
        //
        //  we need to allocate a new relations structure and copy the old one to the new one
        //
        DeviceCount+=CurrentRelations->Count;
    }

    NewRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS)+sizeof(PDEVICE_OBJECT)*DeviceCount);

    if (NewRelations == NULL) {

        Status= STATUS_INSUFFICIENT_RESOURCES;

    } else {

        NewRelations->Count=0;

        if (CurrentRelations != NULL) {

            D_PNP(DbgPrint("IRENUM: GetDeviceList: %d existing devices\n",CurrentRelations->Count);)

            for (i=0; i < CurrentRelations->Count; i++) {

                NewRelations->Objects[i]=CurrentRelations->Objects[i];
                NewRelations->Count++;
            }

            FREE_POOL(CurrentRelations);
        }


        for (i=0; i < MAX_DEVICES; i++) {

            if ((EnumObject->Devices[i].Pdo != NULL) && EnumObject->Devices[i].Present) {

                EnumObject->Devices[i].Enumerated=TRUE;

                D_PNP(DbgPrint("IRENUM: GetDeviceList: reporting DO %p\n",EnumObject->Devices[i].Pdo);)

                NewRelations->Objects[NewRelations->Count]=EnumObject->Devices[i].Pdo;
                ObReferenceObject(NewRelations->Objects[NewRelations->Count]);
                NewRelations->Count++;

            }  else {
                //
                //  the device is no longer present
                //
                EnumObject->Devices[i].Enumerated=FALSE;
            }
        }

        Irp->IoStatus.Information=(ULONG_PTR)NewRelations;
    }

    RELEASE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    return Status;
}



VOID
RemoveDevice(
    ENUM_HANDLE    Handle,
    PIR_DEVICE     IrDevice
    )

{
    PENUM_OBJECT    EnumObject=Handle;

    ACQUIRE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    if (IrDevice->Enumerated) {
        //
        //  the device is still present
        //
        //  Just leave it alone
        //
    } else {
        //
        //  the parent is not enumerating the device anymore
        //
        PPDO_DEVICE_EXTENSION   PdoDeviceExtension=IrDevice->Pdo->DeviceExtension;
        ULONG                   i;

        for (i=0; i < MAX_DEVICES; i++) {
            //
            //  find this device in the array
            //
            if (EnumObject->Devices[i].Pdo == IrDevice->Pdo) {

                break;
            }
        }

        if (IrDevice->HardwareId != NULL) {

            FREE_POOL(IrDevice->HardwareId);
        }

        if (IrDevice->Name != NULL) {

            FREE_POOL(IrDevice->Name);
        }

        if (IrDevice->Manufacturer != NULL) {

            FREE_POOL(IrDevice->Manufacturer);
        }


        PdoDeviceExtension->DoType=DO_TYPE_DEL_PDO;

        IoDeleteDevice(IrDevice->Pdo);

        RtlZeroMemory(&EnumObject->Devices[i],sizeof(IR_DEVICE));

        EnumObject->DeviceCount--;

    }

    RELEASE_PASSIVE_LOCK(&EnumObject->PassiveLock);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\commandline.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    commandline.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// CommandLine.h: interface for the CCommandLine class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COMMANDLINE_H__A2EA0BFB_9DE5_11D1_A5EE_00C04FC252BD__INCLUDED_)
#define AFX_COMMANDLINE_H__A2EA0BFB_9DE5_11D1_A5EE_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CCommandLine : public CCommandLineInfo
{
public:
    void ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast);
    CCommandLine();
    virtual ~CCommandLine();

public:
    friend BOOL CIrftpApp::InitInstance (void);

private:
    BOOL m_fFilesProvided;
    BOOL m_fShowSettings;
    BOOL m_fHideApp;
    BOOL m_fInvalidParams;
    CString m_FileNames;
    TCHAR* m_lpszFilesList; //if files are provided, then this contains a null separated list of files terminated by two null characters.
    ULONG m_iListLen;
};

#endif // !defined(AFX_COMMANDLINE_H__A2EA0BFB_9DE5_11D1_A5EE_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irclass\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by irclass.rc
//
#define IDS_MEM_ERROR                   1
#define IDS_TITLE                       2
#define IDS_PORT_TAB                    3
#define IDS_DLL                         4
#define IDS_PPSTART                     5
#define IDS_PPENDOK                     6
#define IDS_LOCATION_FORMAT             7
#define IDS_INTERNAL_PORT               8
#define IDS_SELECT_PORT_TITLE           9
#define IDS_SELECT_PORT_SUBTITLE        10
#define IDD_PP_IRDA_SETTINGS            101
#define IDD_INSTALL_PORT_SELECT         102
#define IDI_IRDA                        103
#define IDC_PORT                        1000
#define IDC_MAX_CONNECT                 1001
#define IDC_DEVICE_DESC                 1002
#define IDC_PORT_BOX                    1003
#define IDC_PORT_TEXT                   1004
#define IDC_IRDA_ICON                   1005
#define IDC_RATE_TEXT                   1006
#define IDC_SELECT_PORT_TEXT            1007
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\commandline.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    commandline.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// CommandLine.cpp: implementation of the CCommandLine class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCommandLine::CCommandLine() : m_fInvalidParams(FALSE), m_iListLen(0),
                                m_fHideApp (FALSE), m_fShowSettings(FALSE),
                                m_fFilesProvided (FALSE), m_lpszFilesList(NULL)
{
}

CCommandLine::~CCommandLine()
{
    if (m_lpszFilesList)
        delete [] m_lpszFilesList;
}

void CCommandLine::ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast)
{
    TCHAR* lpszTemp;

    if(bFlag)
    {
        if (!lstrcmp(lpszParam, TEXT("h")) || !lstrcmp(lpszParam, TEXT("H")))
            m_fHideApp = TRUE;
        else if (!lstrcmp(lpszParam, TEXT("s")) || !lstrcmp(lpszParam, TEXT("S")))
            m_fShowSettings = TRUE;
        else
            m_fInvalidParams = TRUE;
    }
    else    //lpszParam is a file/folder name.
    {
        m_fFilesProvided = TRUE;
        m_FileNames = m_FileNames + lpszParam + "\"";   //use quotes as filename separator for now.
    }

    if (bLast && m_fFilesProvided)  //invalid combination of parameters
        if (m_fShowSettings)
            m_fInvalidParams = TRUE;
        else
        {
            m_lpszFilesList = new TCHAR[m_iListLen = (lstrlen((LPCTSTR)m_FileNames) + 1)];
            lstrcpy(m_lpszFilesList, LPCTSTR(m_FileNames));
            for (lpszTemp = m_lpszFilesList; *lpszTemp; lpszTemp++)
                if ('\"' == *lpszTemp)
                    *lpszTemp = '\0';   //create a null separated list of files
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\controller.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    controller.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// Controller.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DEFAULT_TIMEOUT     30000   //30 seconds.
#define TIMER_ID            7       //randomly chosen id for the timer

///////////////////
// Module wide structure.
//
FLASHWINFO  fwinfo = {
                        sizeof (FLASHWINFO),
                        NULL,               // Window handle initialized later.
                        FLASHW_ALL,
                        3,
                        0
                     };
/////////////////////////////////////////////////////////////////////////////
//type for loading CPlApplet function declaration: declared in irprops.cpl
typedef LONG (*LPROCCPLAPPLET) (HWND , UINT , LPARAM, LPARAM);

inline CIrRecvProgress *
ValidateRecvCookie( COOKIE cookie)
{
    CIrRecvProgress * window = (CIrRecvProgress *) cookie;

    __try
        {
        if (RECV_MAGIC_ID != window->m_dwMagicID)
            {
            window = 0;
            }
        }
    __except (EXCEPTION_EXECUTE_HANDLER)
        {
        window = 0;
        }

    return window;
}

/////////////////////////////////////////////////////////////////////////////
// CController dialog

//bNoForeground specifies whether the dialog should give focus back to the
//app. which had the focus before irftp started. If set to true, the focus
//is given back. This is necessary because an irftp is usually started with
//the /h option by the irmon service and it is a bad user experience if the
//an app. which the user is running suddenly loses focus to a window which
//is not even visible.
CController::CController(BOOL bNoForeground, CController* pParent /*=NULL*/) : m_pParent(pParent), m_lAppIsDisplayed(-1)
#if 0
, m_pDlgRecvProgress(NULL)
#endif
{
    m_hLibApplet = NULL;
    m_fHaveTimer = FALSE;
    m_lTimeout = DEFAULT_TIMEOUT;
    HWND hwnd = NULL;
    InterlockedIncrement (&g_lUIComponentCount);
    if (appController)
    {
        appController->PostMessage (WM_APP_KILL_TIMER);
    }
    else
    {
        InitTimeout();  //initializes the timeout period
        //the app kills itself if there are no devices in range and no UI has
        // been put up for a period specified by the timeout period
        //note: we only need to initialize the timeout period for the main
        //app window. The other windows will never even have a timer.
    }

    //hack. the call to create steals the focus from the current
    //foreground window. This is bad if we are not going to put up any
    //UI. Therefore, in this case, we get the foreground window just before the
    //call to create and give it back its focus immediately after the call.
    //the whole operation takes only about 35 milliseconds, so the loss of
    //focus in the other app. is almost imperceptible.
    hwnd = ::GetForegroundWindow ();
    Create(IDD);
    if (bNoForeground && hwnd)
        ::SetForegroundWindow (hwnd);
        //{{AFX_DATA_INIT(CController)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

void CController::InitTimeout (void)
{
    m_fHaveTimer = FALSE;   //we have not obtained a timer yet.
    m_lTimeout = DEFAULT_TIMEOUT;   //set it to the default

    //then see if a different value has been set in the registry
    HKEY hftKey = NULL;
    DWORD iSize = sizeof(DWORD);
    DWORD data = 0;

    RegOpenKeyEx (HKEY_CURRENT_USER,
                  TEXT("Control Panel\\Infrared\\File Transfer"),
                  0, KEY_READ, &hftKey);

    if (!hftKey)
        return;     //we did not find a value in the registry, so use defaults

    if (hftKey && ERROR_SUCCESS ==
                RegQueryValueEx (hftKey, TEXT("AppTimeout"), NULL, NULL,
                                    (LPBYTE)&data, &iSize))
    {
        m_lTimeout = (LONG)data;
        if (m_lTimeout < 10000)
            m_lTimeout = 10000;
    }

    if (hftKey)
        RegCloseKey(hftKey);
}


void CController::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CController)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CController, CDialog)
        //{{AFX_MSG_MAP(CController)
        ON_WM_CLOSE()
        ON_WM_ENDSESSION()
        ON_MESSAGE(WM_APP_TRIGGER_UI, OnTriggerUI)
        ON_MESSAGE(WM_APP_DISPLAY_UI, OnDisplayUI)
        ON_MESSAGE(WM_APP_TRIGGER_SETTINGS, OnTriggerSettings)
        ON_MESSAGE(WM_APP_DISPLAY_SETTINGS, OnDisplaySettings)
        ON_MESSAGE(WM_APP_RECV_IN_PROGRESS, OnRecvInProgress)
        ON_MESSAGE(WM_APP_GET_PERMISSION, OnGetPermission)
        ON_MESSAGE(WM_APP_RECV_FINISHED, OnRecvFinished)
        ON_MESSAGE(WM_APP_START_TIMER, OnStartTimer)
        ON_MESSAGE(WM_APP_KILL_TIMER, OnKillTimer)
        ON_WM_COPYDATA()
        ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CController message handlers

void CController::PostNcDestroy()
{
    if (m_hLibApplet)
    {
        FreeLibrary (m_hLibApplet);
        m_hLibApplet = NULL;
    }

    if (this != appController)
    {
        BOOL fNoUIComponents = (0 == InterlockedDecrement (&g_lUIComponentCount));
        if (fNoUIComponents && !g_deviceList.GetDeviceCount())
        {
            //there are no UI components displayed and there are no devices in
            //range. Start the timer. If the timer expires, the app. will quit.
            appController->PostMessage (WM_APP_START_TIMER);
        }
    }

    delete this;
}

void CController::OnEndSession(BOOL Ending)
{
//    OutputDebugStringA("OnEndSession\n");
    RemoveLinks();
}


void CController::OnClose()
{
    //if the WM_CLOSE message was posted from the RPC thread's ShutdownUi
    //routine, then it might be a good idea to wait for a couple of seconds
    //before killing the app. so that the RPC stack can unwind. 3 seconds seems
    //like a reasonable amount of time.  - 6/22/1998 : rahulth & jroberts

//    OutputDebugStringA("OnClose\n");
    RemoveLinks();
    Sleep (3000);
    if (AppUI.m_pParentWnd)
        AppUI.m_pParentWnd->PostMessage(WM_QUIT);

    CWnd::OnClose();
}

void CController::OnCancel()
{
    DestroyWindow();        //For modeless boxes
}

void CController::OnDisplayUI(WPARAM wParam, LPARAM lParam)
{
    ASSERT (m_pParent);

    AppUI.m_ofn.hInstance = g_hInstance;
    AppUI.DoModal();
    AppUI.m_pParentWnd = NULL;

    InterlockedDecrement(&m_lAppIsDisplayed);
    InterlockedDecrement(&(m_pParent->m_lAppIsDisplayed));
    DestroyWindow();
}

void CController::OnTriggerUI (WPARAM wParam, LPARAM lParam)
{
    CWnd * pWnd = NULL;
    BOOL fAppIsDisplayed = (0 != InterlockedIncrement(&m_lAppIsDisplayed));

    if (fAppIsDisplayed)
    {
        InterlockedDecrement(&m_lAppIsDisplayed);   //decrement the count before leaving.
        if (NULL != (pWnd = AppUI.m_pParentWnd))
        {
            //this will usually be true except in the case where the displayed
            //window is just getting destroyed at the same time. In that case,
            //we must go ahead and create it again.
            pWnd->SetActiveWindow();
            return;
        }
    }

    //the app is not displayed
    CController* dlgSubController = new CController(FALSE, this);
    InterlockedIncrement(&(dlgSubController->m_lAppIsDisplayed));
    dlgSubController->ShowWindow (SW_HIDE);
    dlgSubController->PostMessage(WM_APP_DISPLAY_UI);
}

void CController::OnTriggerSettings(WPARAM wParam, LPARAM lParam)
{
    CController* dlgSettingsController = new CController(FALSE, this);
    dlgSettingsController->ShowWindow(SW_HIDE);
    dlgSettingsController->PostMessage(WM_APP_DISPLAY_SETTINGS);
}

void CController::OnDisplaySettings(WPARAM wParam, LPARAM lParam)
{
    LPROCCPLAPPLET  pProcApplet = NULL;
    CString         szApplet;
    CError          error (this);
#if 0
    szApplet = TEXT("irprops.cpl");

    if(NULL == (m_hLibApplet = LoadLibrary((LPCTSTR) szApplet)))
    {
        error.ShowMessage (IDS_APPLET_ERROR);
    }
    else
    {
        if (NULL != (pProcApplet = (LPROCCPLAPPLET)GetProcAddress (m_hLibApplet, "CPlApplet")))
        {
            if((*pProcApplet)(m_hWnd, CPL_INIT, NULL, NULL))
                (*pProcApplet)(m_hWnd, CPL_DBLCLK, NULL, NULL);
            else
            {
                error.ShowMessage (IDS_MISSING_PROTOCOL);
            }
        }
        else
        {
            error.ShowMessage (IDS_APPLET_ERROR);
        }
    }
#else

    {

        PROCESS_INFORMATION    ProcessInformation;
        STARTUPINFO            StartupInfo;
        BOOL                   bResult;
        TCHAR                  Path[MAX_PATH];

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));

        StartupInfo.cb=sizeof(StartupInfo);

        GetSystemDirectory(
            Path,
            sizeof(Path)/sizeof(TCHAR)
            );

        lstrcat(Path,TEXT("\\rundll32.exe"));

        bResult=CreateProcess(
            Path,
            TEXT("rundll32.exe shell32.dll,Control_RunDLL irprops.cpl "),
            NULL,
            NULL,
            FALSE,
            NORMAL_PRIORITY_CLASS,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInformation
            );

        if (bResult) {


            CloseHandle(ProcessInformation.hProcess);
            CloseHandle(ProcessInformation.hThread);

        } else {

            error.ShowMessage (IDS_APPLET_ERROR);
        }
    }

#endif
    DestroyWindow();

}

void CController::OnRecvInProgress (WPARAM wParam, LPARAM lParam)
{
    DWORD   dwShowRecv;

    struct MSG_RECEIVE_IN_PROGRESS * msg = (struct MSG_RECEIVE_IN_PROGRESS *) wParam;

    dwShowRecv = GetIRRegVal (TEXT("ShowRecvStatus"), 1);
    if (!dwShowRecv)
    {
        msg->status = 0;
        return;
    }

    if (wcslen(msg->MachineName) > IRDA_DEVICE_NAME_LENGTH)
        {
        msg->status = ERROR_INVALID_PARAMETER;
        return;
        }

    CIrRecvProgress * pDlgRecvProgress = new CIrRecvProgress(msg->MachineName,
                                                             msg->bSuppressRecvConf);
    if (!pDlgRecvProgress)
        {
        msg->status = ERROR_NOT_ENOUGH_MEMORY;
        return;
        }

    SetForegroundWindow();
    pDlgRecvProgress->SetActiveWindow();
    pDlgRecvProgress->SetWindowPos(&appController->wndTop, -1, -1, -1, -1, SWP_NOSIZE | SWP_NOMOVE);
    fwinfo.hwnd = pDlgRecvProgress->m_hWnd;
    FlashWindowEx (&fwinfo);

    *(msg->pCookie) = (COOKIE) pDlgRecvProgress;

    msg->status = 0;
}

void CController::OnGetPermission( WPARAM wParam, LPARAM lParam )
{
    DWORD   dwShowRecv;

    struct MSG_GET_PERMISSION * msg = (MSG_GET_PERMISSION *) wParam;

    dwShowRecv = GetIRRegVal (TEXT("ShowRecvStatus"), 1);
    if (!dwShowRecv)
    {
        msg->status = 0;
        return;
    }

    SetForegroundWindow();
    CIrRecvProgress * pDlgRecvProgress = ValidateRecvCookie(msg->Cookie);
    if (!pDlgRecvProgress)
        {
        msg->status = ERROR_INVALID_PARAMETER;
        return;
        }

    msg->status = pDlgRecvProgress->GetPermission( msg->Name, msg->fDirectory );
}

void CController::OnRecvFinished (WPARAM wParam, LPARAM lParam)
{
    DWORD   dwShowRecv;

    struct MSG_RECEIVE_FINISHED * msg = (struct MSG_RECEIVE_FINISHED *) wParam;

    dwShowRecv = GetIRRegVal (TEXT("ShowRecvStatus"), 1);
    if (!dwShowRecv)
    {
        msg->status = 0;
        return;
    }

    CIrRecvProgress * pDlgRecvProgress = ValidateRecvCookie(msg->Cookie);
    if (!pDlgRecvProgress)
        {
        msg->status = ERROR_INVALID_PARAMETER;
        return;
        }

    //
    // Preset the error code to ERROR_SUCCESS -- no error popup
    //
    DWORD Win32Error = ERROR_SUCCESS;

    //
    // first, filter out unwarranted errors. These error codes
    // are treated as ERROR_SUCCESS.
    // We have three so far:
    // ERROR_SCEP_UNSPECIFIED_DISCONNECT,
    // ERROR_SCEP_USER_DISCONNECT and
    // ERROR_SCEP_PROVIDER_DISCONNECT.

    //
    // ERROR_SCEP_UNSPECIFIED_DISCONNECT is the error code
    // we encounter most of the time because users usually do
    // (1) move the device within IR range
    // (2) do image transfer
    // (3) move the device out of IR range.
    //
    if (ERROR_SCEP_UNSPECIFIED_DISCONNECT != (DWORD)msg->ReceiveStatus &&
        ERROR_SCEP_USER_DISCONNECT        != (DWORD)msg->ReceiveStatus &&
        ERROR_SCEP_PROVIDER_DISCONNECT    != (DWORD)msg->ReceiveStatus)
        {
        Win32Error = (DWORD)msg->ReceiveStatus;
        }

    pDlgRecvProgress->DestroyAndCleanup(Win32Error);
    pDlgRecvProgress = NULL;

    msg->status = 0;
}

BOOL CController::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct)
{
    int iCharCount;
    TCHAR* lpszFileNames = new TCHAR [iCharCount = (int)pCopyDataStruct->dwData];
    CSendProgress* dlgProgress;

    memcpy ((LPVOID)lpszFileNames, pCopyDataStruct->lpData, pCopyDataStruct->cbData);
    dlgProgress = new CSendProgress(lpszFileNames, iCharCount);
    dlgProgress->ShowWindow(SW_SHOW);
    dlgProgress->SetFocus();
    dlgProgress->SetWindowPos (&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE);
    fwinfo.hwnd = dlgProgress->m_hWnd;
    ::FlashWindowEx (&fwinfo);
    return TRUE;
}

void CController::OnStartTimer (WPARAM wParam, LPARAM lParam)
{
    //update the state of the help window
    if (g_hwndHelp && ! ::IsWindow (g_hwndHelp))
        g_hwndHelp = NULL;

    if (!m_fHaveTimer)
    {
        m_fHaveTimer = SetTimer (TIMER_ID,
                                 m_lTimeout,
                                 NULL       //want WM_TIMER messages
                                 )?TRUE:FALSE;
    }
}

void CController::OnKillTimer (WPARAM wParam, LPARAM lParam)
{
    //update the state of the help window
    if (g_hwndHelp && ! ::IsWindow (g_hwndHelp))
        g_hwndHelp = NULL;

    if (m_fHaveTimer)
    {
        KillTimer(TIMER_ID);
        m_fHaveTimer = FALSE;
    }
}

void CController::OnTimer (UINT nTimerID)
{
    //there is only one timer, so we don't have to check for it.
    //the timer has expired, so kill self
    //however, first make sure that the help window (if it was put up)
    //is gone.
    if (g_hwndHelp && ::IsWindow (g_hwndHelp))
    {
        //the help window is around. restart the timer.
        //this is the only way we can kill ourselves when the window
        //is finally destroyed.
        m_fHaveTimer = FALSE;
        this->OnStartTimer (NULL, NULL);
    }
    else
    {
        g_hwndHelp = NULL;
        this->PostMessage(WM_CLOSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\errorcodes.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    errorcodes.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#ifndef __ERRORCODES_H__
#define __ERRORCODES_H__

#define errIRFTP_NODEVICE   -1
#define errIRFTP_SELECTIONCANCELLED -2
#define errIRFTP_MULTDEVICES    -3

#endif  //__ERRORCODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\devicelist.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    devicelist.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// DeviceList.h: interface for the CDeviceList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DEVICELIST_H__D790FBDD_BAA9_11D1_A60E_00C04FC252BD__INCLUDED_)
#define AFX_DEVICELIST_H__D790FBDD_BAA9_11D1_A60E_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RpcHeaders.h"


class CDeviceList
{
public:

    BOOL
    GetDeviceType(
        LONG iDevID,
        OBEX_DEVICE_TYPE  *Type
        );

    ULONG GetDeviceID (int iDevIndex);
    LONG SelectDevice (CWnd* pWnd, TCHAR* lpszDevName);
    ULONG GetDeviceCount (void);
    CDeviceList& operator =(POBEX_DEVICE_LIST pDevList);
    CDeviceList();
    virtual ~CDeviceList();
    friend class CMultDevices;

private:
    void GetDeviceName (LONG iDevID, TCHAR* lpszDevName);
    POBEX_DEVICE                   m_pDeviceInfo;

    int m_lNumDevices;
    CRITICAL_SECTION m_criticalSection;
};

#endif // !defined(AFX_DEVICELIST_H__D790FBDD_BAA9_11D1_A60E_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\helparr.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    helparr.h

Abstract:

    #defines for context help

Author:

    Rahul Thombre (RahulTh) 10/13/1998

Revision History:

    10/13/1998  RahulTh         Created this module.

--*/


#ifndef __HELPARR_H__
#define __HELPARR_H__

#define IDH_DISABLEHELP     ((DWORD)-1)
#define IDH_SEND_BUTTON     202 // Untitled: "Send" (Button)
#define IDH_SETTINGS_BUTTON 203 // Untitled: "Settings" (Button)
#define IDH_CLOSE_BUTTON    204 // Untitled: "Close" (Button)
#define IDH_HELP_BUTTON     205 // Untitled: "Help" (Button)
#define IDH_DEVICELIST      301 // device list in device chooser dlg

#endif //__HELPARR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\controller.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    controller.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#if !defined(AFX_CONTROLLER_H__90D62E7C_AEEC_11D1_A60A_00C04FC252BD__INCLUDED_)
#define AFX_CONTROLLER_H__90D62E7C_AEEC_11D1_A60A_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define MAIN_WINDOW_TITLE   L"Wireless Link Main Window"

// Controller.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CController dialog

class CController : public CDialog
{
// Construction
public:
    LONG m_lAppIsDisplayed;
    HINSTANCE m_hLibApplet;
    CController(BOOL bNoForeground, CController* pParent = NULL);   // standard constructor
    friend class CIrRecvProgress;

// Dialog Data
        //{{AFX_DATA(CController)
        enum { IDD = IDD_CONTROLLER };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CController)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual void PostNcDestroy();
        //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CController)
    virtual void OnCancel();
    afx_msg void OnEndSession(BOOL Ending);
    afx_msg void OnClose ();
    afx_msg void OnTimer (UINT nTimerID);
    afx_msg void OnTriggerUI(WPARAM wParam, LPARAM lParam);
    afx_msg void OnDisplayUI(WPARAM wParam, LPARAM lParam);
    afx_msg void OnTriggerSettings(WPARAM wParam, LPARAM lParam);
    afx_msg void OnDisplaySettings(WPARAM wParam, LPARAM lParam);
    afx_msg void OnRecvInProgress (WPARAM wParam, LPARAM lParam);
    afx_msg void OnGetPermission (WPARAM wParam, LPARAM lParam);
    afx_msg void OnRecvFinished (WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
    afx_msg void OnStartTimer (WPARAM wParam, LPARAM lParam);
    afx_msg void OnKillTimer (WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    //member functions
    void InitTimeout (void);
    //data members
#if 0
    CIrRecvProgress* m_pDlgRecvProgress;
#endif
    CController* m_pParent;
    BOOL m_fHaveTimer;
    LONG m_lTimeout;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


struct MSG_RECEIVE_IN_PROGRESS
{
    wchar_t *       MachineName;
    COOKIE *        pCookie;
    boolean         bSuppressRecvConf;
    error_status_t  status;
};

struct MSG_GET_PERMISSION
{
    COOKIE           Cookie;
    wchar_t *        Name;
    boolean          fDirectory;
    error_status_t   status;
};

struct MSG_RECEIVE_FINISHED
{
    COOKIE          Cookie;
    error_status_t  ReceiveStatus;
    error_status_t  status;
};

#endif // !defined(AFX_CONTROLLER_H__90D62E7C_AEEC_11D1_A60A_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\global.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    global.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#ifndef __GLOBAL_H__
#define __GLOBAL_H__

//this is the size of the buffer used to store a generic error message
//(IDS_NODESC_ERROR) which is displayed when FormatMessage fails. Do
//not use this value to hardcode sizes of buffers passed to FormatMessage.
//since the error messages just might exceed this value and cause FormatMessage
//to fail. For FormatMessage, always use the FORMAT_MESSAGE_ALLOCATE_BUFFER
//flag so that the system can allocate the buffer.
#define ERROR_DESCRIPTION_LENGTH 256


//application defined messages
#define WM_APP_TRIGGER_UI           (WM_APP+1)
#define WM_APP_DISPLAY_UI           (WM_APP+2)
#define WM_APP_TRIGGER_SETTINGS     (WM_APP+3)
#define WM_APP_DISPLAY_SETTINGS     (WM_APP+4)
#define WM_APP_UPDATE_PROGRESS      (WM_APP+5)
#define WM_APP_SEND_COMPLETE        (WM_APP+6)
#define WM_APP_RECV_IN_PROGRESS     (WM_APP+7)
#define WM_APP_RECV_FINISHED        (WM_APP+8)
#define WM_APP_START_TIMER          (WM_APP+9)
#define WM_APP_KILL_TIMER           (WM_APP+10)
#define WM_APP_GET_PERMISSION       (WM_APP+11)

//global variables
extern HINSTANCE g_hInstance;
extern HWND g_hAppWnd;
extern RPC_BINDING_HANDLE g_hIrRpcHandle;  //Handle to the IrXfer service
class CIrftpDlg;        //forward declaration
extern CIrftpDlg AppUI;
class CController;      //forward declaration
extern CController* appController;
extern LONG g_lLinkOnDesktop;
class CDeviceList;  //forward declaration
extern CDeviceList g_deviceList;
extern TCHAR g_lpszDesktopFolder[MAX_PATH];
extern TCHAR g_lpszSendToFolder[MAX_PATH];
extern LONG g_lUIComponentCount;
extern HWND g_hwndHelp;


struct GLOBAL_STRINGS
{
    wchar_t Close[50];
    wchar_t ErrorNoDescription[200];
    wchar_t CompletedSuccess[200];
    wchar_t ReceiveError[150];
    wchar_t Connecting[100];
    wchar_t RecvCancelled [100];
};

extern struct GLOBAL_STRINGS g_Strings;

#endif  //__GLOBAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\devicelist.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    devicelist.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

///////////////////////////////////////////////////////////////////////
// DeviceList.cpp: implementation of the CDeviceList class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDeviceList::CDeviceList()
{
    m_pDeviceInfo = NULL;
    m_lNumDevices = 0;
    InitializeCriticalSection(&m_criticalSection);
}

CDeviceList::~CDeviceList()
{
    if(m_pDeviceInfo)
    {
        delete [] m_pDeviceInfo;
        m_pDeviceInfo = NULL;
        m_lNumDevices = 0;
    }
}

CDeviceList& CDeviceList::operator=(POBEX_DEVICE_LIST pDevList)
{
    CError      error (NULL, IDS_DEFAULT_ERROR_TITLE, ERROR_OUTOFMEMORY);

    EnterCriticalSection(&m_criticalSection);
    if (m_pDeviceInfo)
    {
        delete [] m_pDeviceInfo;
        m_pDeviceInfo = NULL;
        m_lNumDevices = 0;
    }
    LeaveCriticalSection(&m_criticalSection);

    if (!pDevList)
        return *this;

    //if there is a device list
    EnterCriticalSection(&m_criticalSection);
    m_lNumDevices = pDevList->DeviceCount;
    try
    {
        m_pDeviceInfo = new OBEX_DEVICE [m_lNumDevices];
        memcpy ((LPVOID)m_pDeviceInfo, (LPVOID)pDevList->DeviceList, sizeof(OBEX_DEVICE) * m_lNumDevices);
    }
    catch (CMemoryException* e)
    {
        error.ShowMessage (IDS_DEVLIST_ERROR);
        m_pDeviceInfo = NULL;   //the best we can do here is to pretend that there
        m_lNumDevices = 0;  //are no devices and move on
        e->Delete();
    }
    LeaveCriticalSection(&m_criticalSection);

    return *this;
}

ULONG CDeviceList::GetDeviceCount(void)
{
    return m_lNumDevices;
}

LONG CDeviceList::SelectDevice(CWnd * pWnd, TCHAR* lpszDevName)
{
    ASSERT(pWnd);

    int iSel;
    LONG lDeviceID;
    int numDevices;

    lpszDevName[0] = '\0';

    EnterCriticalSection(&m_criticalSection);
    numDevices = m_lNumDevices;

    if (numDevices > 0) {

        if (m_pDeviceInfo->DeviceType == TYPE_IRDA) {

            lDeviceID = m_pDeviceInfo->DeviceSpecific.s.Irda.DeviceId;    //store the id and name of the

        } else {

            lDeviceID = m_pDeviceInfo->DeviceSpecific.s.Ip.IpAddress;
        }
        lstrcpy(lpszDevName,m_pDeviceInfo->DeviceName);
    }
    LeaveCriticalSection(&m_criticalSection);

    if (numDevices == 0)
        return errIRFTP_NODEVICE;      //in the rare case that there are no devices in range, return -1

    if (1 == numDevices)    //there is only one device. No need to choose a device
        return lDeviceID;

    CMultDevices dlgChooseDevice(pWnd, this);

    if (IDOK == dlgChooseDevice.DoModal())
        return errIRFTP_MULTDEVICES;    //OnOK will fill in the required data structures
    else
        return errIRFTP_SELECTIONCANCELLED; //return -1 if cancel was chosen
}

ULONG CDeviceList::GetDeviceID(int iDevIndex)
{
    if (iDevIndex < m_lNumDevices)  //sanity checks
        return m_pDeviceInfo[iDevIndex].DeviceSpecific.s.Irda.DeviceId;
    else
        return -1;
}


///////////////////////////////////////////////////////////////////////////////////
//this function should only be called after a critical section has been
//obtained.
void CDeviceList::GetDeviceName(LONG iDevID, TCHAR* lpszDevName)
{
    int len;
    int i;
    lpszDevName[0] = '\0';  //better be safe

    //EnterCriticalSection(&m_criticalSection);
    for(i = 0; i < m_lNumDevices; i++)
    {
        if(iDevID == (LONG)m_pDeviceInfo[i].DeviceSpecific.s.Irda.DeviceId)
            break;
    }
    if(i == m_lNumDevices)  //the device was not found
        lstrcpy (lpszDevName, TEXT("???"));
    else
    {
        wcscpy(lpszDevName, m_pDeviceInfo[i].DeviceName);
    }
    //LeaveCriticalSection(&m_criticalSection);
}

///////////////////////////////////////////////////////////////////////////////////
//this function should only be called after a critical section has been
//obtained.
BOOL
CDeviceList::GetDeviceType(
    LONG iDevID,
    OBEX_DEVICE_TYPE  *Type
    )
{
    int       i;
    BOOL      bResult;

    *Type=TYPE_UNKNOWN;

    EnterCriticalSection(&m_criticalSection);
    for(i = 0; i < m_lNumDevices; i++)
    {
        if (m_pDeviceInfo[i].DeviceType == TYPE_IRDA) {

            if (iDevID == (LONG)m_pDeviceInfo[i].DeviceSpecific.s.Irda.DeviceId) {

                *Type=m_pDeviceInfo[i].DeviceType;
                break;
            }

        } else {

            if (iDevID == (LONG)m_pDeviceInfo[i].DeviceSpecific.s.Ip.IpAddress) {

                *Type=m_pDeviceInfo[i].DeviceType;
                break;
            }

        }
    }

    if (i == m_lNumDevices) {
        //
        //  the device was not found
        //
        bResult=FALSE;

    } else {

        bResult=TRUE;
    }

    LeaveCriticalSection(&m_criticalSection);
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\irftp.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    irftp.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// irftp.cpp : Defines the class behaviors for the application.
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL LoadGlobalStrings();

/////////////////////////////////////////////////////////////////////////////
// CIrftpApp

BEGIN_MESSAGE_MAP(CIrftpApp, CWinApp)
    //{{AFX_MSG_MAP(CIrftpApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIrftpApp construction

CIrftpApp::CIrftpApp()
{

// TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CIrftpApp object

CIrftpApp theApp;

////////////////////////////////////////////////////////////////////////////
// The instance handle for this app.
HINSTANCE g_hInstance;

////////////////////////////////////////////////////////////////////////////
//RPC handle
RPC_BINDING_HANDLE g_hIrRpcHandle = NULL;

///////////////////////////////////////////////////////////////////////////
//the main application UI. this is now global because it might be
//invoked from multiple file, especially the RPC server functions
CIrftpDlg AppUI;

///////////////////////////////////////////////////////////////////////////
//the controller window for the application. This is necessary to
//create the illusion of parentless send progress dialog boxes.
//actually it is not possible to have parentless and modeless dialog
//boxes. Thus, these dialog boxes actually have the controller window
//as their parent
//This is necessary because the AppUI may come and go and in fact
//never come up at all.
CController* appController = NULL;

////////////////////////////////////////////////////////////////////////////
//global variable that keeps track of the number of UI components displayed
//by irftp at the moment. Note: we start with -1 because we don't want to
//count the first CController window which is the main app. window.
//
LONG g_lUIComponentCount = -1;

////////////////////////////////////////////////////////////////////////////
//global variable that keeps track of the handle to the help window (if any)
//The HtmlHelp window is the only one that cannot be tracked using the
//g_lUIComponentCount. So we need this var. to figure out if the help window
//is still up.
HWND g_hwndHelp = NULL;

////////////////////////////////////////////////////////////////////////////
//global variable that keeps track of whether there is a shortcut to
//the app on the desktop or not
//0 implies that there is a link on the desktop and -1 implies that there
//is no link on the desktop.
//this value is basically an indicator of not only the presence of
//the shortcut on the desktop, but also of the link in the send to
//folder
LONG g_lLinkOnDesktop = -1;
//the path of the desktop folder.
TCHAR g_lpszDesktopFolder[MAX_PATH];
//the path to the send to folder;
TCHAR g_lpszSendToFolder[MAX_PATH];

////////////////////////////////////////////////////////////////////////////
//the list of devices in range
CDeviceList g_deviceList;

/////////////////////////////////////////////////////////////////////////////
// CIrftpApp initialization

BOOL CIrftpApp::InitInstance()
{
    DWORD Status;
    error_status_t err;
    CError      error;
    BOOL        bSetForeground = FALSE;
    int         i = 0;
    HWND        hwndApp = NULL;
    HANDLE      hMutex = NULL;
    BOOL        fFirstInstance = FALSE;

    AfxEnableControlContainer();

    //set the global instance handle
    g_hInstance = AfxGetInstanceHandle();

    CCommandLine cLine;
    ParseCommandLine (cLine);

    if(cLine.m_fInvalidParams)  //if invalid command line parameters, terminate.
    {
        error.ShowMessage (IDS_INVALID_PARAMETERS);
        return FALSE;   //exit the app., first instance or not.
    }

    //check if another instance is already running and act accordingly.
    hMutex = CreateMutex (NULL, FALSE, SINGLE_INST_MUTEX);
    Status = GetLastError();
    if (hMutex)
    {
        fFirstInstance = (ERROR_ALREADY_EXISTS != Status);
    }
    else
    {
        //we could not create the mutex, so must fail.
        return FALSE;
    }

    g_hIrRpcHandle = GetRpcHandle();

    //
    // Load strings.
    //
    if (FALSE == LoadGlobalStrings())
        {
        return FALSE;
        }

    if (!fFirstInstance)
    {
        hwndApp = GetPrimaryAppWindow();
        //note: it is important to successfully set the the first instance of the app. as the foreground window.
        //since the first instance has already started, it is very unlikely that it will be the foreground process
        //therefore it will be unable to set itself as the foreground process and therefore any calls to SetActiveWindow
        //etc. in that instance will not cause any changes in the Z-order or input focus. Therefore, this instance needs
        //to make the first instance the foreground process so that any dialogs etc. put up by the windows do not show
        //up obscured by other apps. or without focus. The current instance is able to set the first instance as the
        //foreground process because this instance is either itself the foreground process or is started by the current
        //foreground process.
        if (hwndApp && (!cLine.m_fHideApp))
        {
            bSetForeground = ::SetForegroundWindow (hwndApp);
        }
        if (cLine.m_fFilesProvided)
                InitiateFileTransfer (g_hIrRpcHandle, cLine.m_iListLen, cLine.m_lpszFilesList);
        else if (cLine.m_fShowSettings)
                DisplaySettings(g_hIrRpcHandle);
        else if (!cLine.m_fHideApp)
                PopupUI (g_hIrRpcHandle);
        //do nothing otherwise.

        //for some reason, SetForegroundWindow does not succeed if the window which we are trying to put in the
        //foreground does not have any visible windows. So if a user transfers some files and then dismisses the
        //wireless link dialog, then at this point, the hidden parent window is not the foreground window. So, we
        //try for 10 seconds to get the window in the foreground. It is okay to spin here because other than getting
        //the window to the top of the Z-order everything else has already been done. Here, we just want to give the
        //shell enough time to put up the common file open dialog. Note that we stop spinning the moment we succeed
        //in setting the first instance as the foreground window.
        if (!bSetForeground && hwndApp && (!cLine.m_fHideApp))
        {
            i = 0;
            do
            {
                if (::SetForegroundWindow (hwndApp))
                    break;
                else
                    Sleep (100);
            } while ( i++ < 100 );
        }

        CloseHandle (hMutex);
        return FALSE;   //exit the app. rather than starting the message pump
    }

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

     //if we reach here, it means that this is the first instance of the app.
    m_pMainWnd = appController = new CController (cLine.m_fHideApp);
    if (!appController)
        {
        return FALSE;
        }
    appController->ShowWindow(SW_HIDE);
    appController->SetWindowText (MAIN_WINDOW_TITLE);
    g_lpszDesktopFolder[0] = '\0';  //precautionary measures
    g_lpszSendToFolder [0] = '\0';

    if(!InitRPCServer())
        {
        return FALSE;   //exit the app. if the RPC server cannot be started
        }

    if (cLine.m_fFilesProvided)
        _InitiateFileTransfer(NULL, cLine.m_iListLen, cLine.m_lpszFilesList);
    else if (cLine.m_fShowSettings)
        _DisplaySettings(NULL);
    else if (!cLine.m_fHideApp)
        _PopupUI(NULL);
    //else do nothing, since the app is supposed to be hidden

    return TRUE;        //start the message pump. RPC server is already running
}

GLOBAL_STRINGS g_Strings;

BOOL
LoadGlobalStrings()
{
#define LOAD_STRING(id, str)                                                     \
    if (0 == LoadString( g_hInstance, id, g_Strings.str, sizeof(g_Strings.str)/sizeof(wchar_t))) \
        {                                                                        \
        return FALSE;                                                            \
        }

    LOAD_STRING( IDS_CLOSE, Close )
    LOAD_STRING( IDS_NODESC_ERROR, ErrorNoDescription )
    LOAD_STRING( IDS_COMPLETED, CompletedSuccess )
    LOAD_STRING( IDS_RECV_ERROR, ReceiveError )
    LOAD_STRING( IDS_CONNECTING, Connecting )
    LOAD_STRING( IDS_RECV_CANCELLED, RecvCancelled )

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\irftp.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    irftp.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// irftp.h : main header file for the IRFTP application
//

#if !defined(AFX_IRFTP_H__10D3BB05_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_)
#define AFX_IRFTP_H__10D3BB05_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

//name of a mutex that is used to ensure that only one instance of the
//app. runs
#define SINGLE_INST_MUTEX   L"IRMutex_1A8452B5_A526_443C_8172_D29657B89F57"

/////////////////////////////////////////////////////////////////////////////
// CIrftpApp:
// See irftp.cpp for the implementation of this class
//

class CIrftpApp : public CWinApp
{
public:
    CIrftpApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CIrftpApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CIrftpApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IRFTP_H__10D3BB05_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\irrecvprogress.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    irrecvprogress.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// IrRecvProgress.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIrRecvProgress dialog


CIrRecvProgress::CIrRecvProgress(wchar_t * MachineName,
                                 boolean bSuppressRecvConf,
                                 CWnd* pParent /*=NULL*/)
    : m_szMachineName (MachineName), m_fFirstXfer (TRUE), m_bDlgDestroyed (TRUE)
{
    DWORD   dwPrompt;

    m_ptl = NULL;
    m_dwMagicID = RECV_MAGIC_ID;
    m_bRecvFromCamera = FALSE;

    if (bSuppressRecvConf)
    {
        m_fDontPrompt = TRUE;
        m_bRecvFromCamera = TRUE;
        if (m_szMachineName.IsEmpty())
        {
            m_szMachineName.LoadString (IDS_CAMERA);
        }
    }
    else
    {
        dwPrompt = GetIRRegVal (TEXT("RecvConf"), 1);
        m_fDontPrompt = dwPrompt ? FALSE : TRUE;
        if (m_szMachineName.IsEmpty())
        {
            m_szMachineName.LoadString (IDS_UNKNOWN_DEVICE);
        }
    }

    //
    // No permitted directory yet.
    //
    m_LastPermittedDirectory[0] = 0;

    appController->PostMessage (WM_APP_KILL_TIMER);
    InterlockedIncrement (&g_lUIComponentCount);

    Create(IDD,appController);

    //{{AFX_DATA_INIT(CIrRecvProgress)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CIrRecvProgress::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CIrRecvProgress)
    DDX_Control(pDX, IDC_RECV_XFERANIM, m_xferAnim);
    DDX_Control(pDX, IDC_SAVEDICON, m_icon);
    DDX_Control(pDX, IDC_DONETEXT, m_DoneText);
    DDX_Control(pDX, IDC_RECV_CONNECTIONTEXT, m_machDesc);
    DDX_Control(pDX, IDC_RECVDESCRIPTION, m_recvDesc);
    DDX_Control(pDX, IDC_XFER_DESC, m_xferDesc);
    DDX_Control(pDX, IDC_MACHNAME, m_Machine);
    DDX_Control(pDX, IDC_FILENAME, m_File);
    DDX_Control(pDX, IDC_CLOSEONCOMPLETE, m_btnCloseOnComplete);
    DDX_Control(pDX, IDC_ABORT, m_btnCancel);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIrRecvProgress, CDialog)
    //{{AFX_MSG_MAP(CIrRecvProgress)
    ON_BN_CLICKED (IDC_ABORT, OnCancel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIrRecvProgress message handlers

void CIrRecvProgress::OnCancel()
{
    m_xferAnim.Stop();
    m_xferAnim.Close();

    CancelReceive( g_hIrRpcHandle, (COOKIE) this );

    DestroyWindow();
}

void CIrRecvProgress::PostNcDestroy()
{
    BOOL fNoUIComponents = (0 == InterlockedDecrement (&g_lUIComponentCount));
    if (fNoUIComponents && !g_deviceList.GetDeviceCount())
    {
        //there are no UI components displayed and there are no devices in
        //range. Start the timer. If the timer expires, the app. will quit.
        appController->PostMessage (WM_APP_START_TIMER);
    }

    delete this;
}

void CIrRecvProgress::ShowProgressControls (int nCmdShow)
{
    m_xferAnim.ShowWindow (nCmdShow);
    m_xferDesc.ShowWindow (nCmdShow);
    m_machDesc.ShowWindow (nCmdShow);
    m_Machine.ShowWindow (nCmdShow);
    m_recvDesc.ShowWindow (nCmdShow);
    m_File.ShowWindow (nCmdShow);
    m_btnCloseOnComplete.ShowWindow (nCmdShow);
}

void CIrRecvProgress::ShowSummaryControls (int nCmdShow)
{
    m_icon.ShowWindow (nCmdShow);
    m_DoneText.ShowWindow (nCmdShow);
}

void CIrRecvProgress::DestroyAndCleanup(
    DWORD status
    )
{
    //AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString     szFormat;
    CString     szDisplay;

    m_xferAnim.Stop();
    m_xferAnim.Close();
    //destroy the window right away if the "Close on complete" check-box is
    //checked.
    if (m_btnCloseOnComplete.GetCheck())
    {
        DestroyWindow();
        return;
    }

    //if we are here, the user wanted the window to stay even after the
    //receive was completed. So hide the progress controls and show the
    //summary controls.
    ShowProgressControls (SW_HIDE);
    ShowSummaryControls (SW_SHOW);

    if (0 == status)
    {
        szFormat = g_Strings.CompletedSuccess;
        szDisplay.Format (szFormat, m_szMachineName);
        m_DoneText.SetWindowText(szDisplay);
    }
    else if (ERROR_CANCELLED == status)
    {
        m_DoneText.SetWindowText (g_Strings.RecvCancelled);
    }
    else
    {
        LPVOID  lpMessageBuffer;
        TCHAR   ErrDesc [ERROR_DESCRIPTION_LENGTH];
        CString ErrorDescription;
        CString Message;

        if (!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,          // ignored
                            status,
                            0,       // try default language ids
                            (LPTSTR) &lpMessageBuffer,
                            0,
                            NULL        // ignored
                            ))
        {
            wsprintf(ErrDesc, g_Strings.ErrorNoDescription, status);
            //using the overloaded CString assignment operator. It is
            //essentially a string copy, but MFC takes care of allocating
            //and freeing the destination buffer.
            ErrorDescription = ErrDesc;
        }
        else
        {
            //Note: this is not a pointer assignment. We are using the
            //overloaded CString assignment operator which essentially
            //does a string copy. (see comments above)
            ErrorDescription = (TCHAR *) lpMessageBuffer;
            LocalFree (lpMessageBuffer);
        }

        Message = g_Strings.ReceiveError;
        //using overloaded CString + operator. Has the same effect as wcscat
        //but MFC takes care of allocating and freeing the destination buffers
        Message += ErrorDescription;

        m_DoneText.SetWindowText(Message);
    }

    m_btnCancel.SetWindowText(g_Strings.Close);
    m_btnCancel.SetFocus();
}

BOOL CIrRecvProgress::DestroyWindow()
{
    if (m_bDlgDestroyed)
        return m_bDlgDestroyed;

    //if a taskbar button had been put up, remove it now.
    if (m_ptl)
    {
        m_ptl->DeleteTab(m_hWnd);
        m_ptl->Release();
        m_ptl = NULL;
    }

    m_bDlgDestroyed=TRUE;
    CWnd::DestroyWindow();

    return TRUE;
}

BOOL CIrRecvProgress::OnInitDialog()
{
    HRESULT     hr = E_FAIL;
    RECT        rc;
    int         newWidth, newHeight, xshift, yshift;
    CWnd    *   pDesktop = NULL;

    CDialog::OnInitDialog();

    m_bDlgDestroyed = FALSE;

    //start with a hidden window if prompting is not turned off.
    if (!m_fDontPrompt)
        ShowWindow (SW_HIDE);
    else
        ShowWindow (SW_SHOW);

    //if the sender is a camera, the cancel operation is not supported,
    //so change the cancel button to Close
    if (m_bRecvFromCamera)
        m_btnCancel.SetWindowText(g_Strings.Close);

    //first display the progress controls and hide the summary controls.
    ShowProgressControls (SW_SHOW);
    ShowSummaryControls (SW_HIDE);

    //set the appropriate values for the progress controls.
    m_xferAnim.Open(IDR_TRANSFER_AVI);
    m_xferAnim.Play(0, -1, -1);
    m_File.SetWindowText (TEXT(""));
    m_Machine.SetWindowText (m_szMachineName);

    //add a button to the taskbar for this window
    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
        hr = CoCreateInstance(CLSID_TaskbarList, 
                              NULL,
                              CLSCTX_INPROC_SERVER, 
                              IID_ITaskbarList, 
                              (LPVOID*)&m_ptl);
    if (SUCCEEDED(hr))
    {
        hr = m_ptl->HrInit();
    }
    else
    {
        m_ptl = NULL;
    }

    if (m_ptl)
    {
        if (SUCCEEDED(hr))
            m_ptl->AddTab(m_hWnd);
        else
        {
            m_ptl->Release();
            m_ptl = NULL;
        }
    }

    //reposition the window so that it is at the center of the screen
    //also push this window to the top after activating it
    GetClientRect (&rc);
    newHeight = rc.bottom;
    newWidth = rc.right;
    pDesktop = GetDesktopWindow();
    pDesktop->GetClientRect (&rc);
    yshift = (rc.bottom - newHeight)/2;
    xshift = (rc.right - newWidth)/2;
    //there might be a problem if someday the dialog should
    //get larger than the desktop. But then, there is no way
    //we can fit that window inside the desktop anyway.
    //So the best we can do is place it at the top left corner
    xshift = (xshift >= 0)?xshift:0;
    yshift = (yshift >= 0)?yshift:0;
    appController->SetForegroundWindow();
    SetActiveWindow();
    SetWindowPos (&wndTop, xshift, yshift, -1, -1,
                  SWP_NOSIZE | SWP_NOOWNERZORDER);
    m_btnCancel.SetFocus();

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD
CIrRecvProgress::GetPermission(
    wchar_t Name[],
    BOOL fDirectory
    )
{
    TCHAR   szCompactName [COMPACT_PATHLEN + 1];
    CString szName;
    DWORD   len;
    DWORD   Status = ERROR_SUCCESS;

    if (Name[0] == '\\')
    {
        ++Name;
    }

    //
    // Don't issue a blanket authorization for files in the RFF,
    // but allow the service to chdir there.
    //
    if (fDirectory && wcslen(Name) == 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // If the file or directory lies outside our last approved directory tree, ask permission.
    //
    if (m_LastPermittedDirectory[0] == 0 ||
        0 != wcsncmp(m_LastPermittedDirectory, Name, wcslen(m_LastPermittedDirectory)))
    {
        Status = PromptForPermission(Name, fDirectory);
    }

    //
    // Update the current file name if we got the permission
    //
    if (ERROR_SUCCESS == Status)
    {
        szName = Name;
        len = wcslen (Name);
        if (COMPACT_PATHLEN < len)
        {
            if (PathCompactPathEx (szCompactName, Name, COMPACT_PATHLEN + 1, 0))
                szName = szCompactName;
        }
        m_File.SetWindowText(szName);
    }

    return Status;
}


DWORD
CIrRecvProgress::PromptForPermission(
    wchar_t Name[],
    BOOL fDirectory
    )
{
    CRecvConf   dlgConfirm (this);
    DWORD       Status = ERROR_SUCCESS;
    DWORD       len;
    BOOL        bUnhide = FALSE;

    if (m_fDontPrompt)
        goto PromptEnd;

    //we need to ask the user for permission.
    if (m_fFirstXfer)
    {
//        dlgConfirm.ShowAllYes (FALSE);
        m_fFirstXfer = FALSE;
        bUnhide = TRUE;
    }

    dlgConfirm.InitNames (m_szMachineName, Name, fDirectory);

    switch (dlgConfirm.DoModal())
    {
    case IDALLYES:
        m_fDontPrompt = TRUE;
    case IDYES:
        Status = ERROR_SUCCESS;
        break;
    case IDCANCEL:
        Status = ERROR_CANCELLED;
        break;
    default:
        Status = GetLastError();
    }

PromptEnd:
    if (fDirectory && ERROR_SUCCESS == Status)
    {
        wcscpy( m_LastPermittedDirectory, Name);
        len = wcslen (Name);
        //make sure that the name is slash terminated.
        if (L'\\' != Name[len - 1])
            wcscat (m_LastPermittedDirectory, TEXT("\\"));
    }

    if (m_fFirstXfer || bUnhide)
        ShowWindow(SW_SHOW);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\irftpdlg.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    irftpdlg.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// irftpDlg.h : header file
//

#if !defined(AFX_IRFTPDLG_H__10D3BB07_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_)
#define AFX_IRFTPDLG_H__10D3BB07_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CIrftpDlg dialog

class CIrftpDlg : public CFileDialog
{
    friend class CController;

// Construction
public:
        CIrftpDlg( );  // standard constructor

        // Dialog Data
        //{{AFX_DATA(CIrftpDlg)
        enum { IDD = IDD_IRDA_DIALOG };
        CButton m_helpBtn;
        CButton m_settingsBtn;
        CButton m_sendBtn;
        CButton m_closeBtn;
        CButton m_locationGroup;
        CStatic m_commFile;
        TCHAR   m_lpszInitialDir [MAX_PATH + 1];
        TCHAR   m_lpstrFile [MAX_PATH + 1];
    //}}AFX_DATA

        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CIrftpDlg)
    protected:
        virtual void DoDataExchange(CDataExchange* pDX);        // DDX/DDV support
        virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CIrftpDlg)
        virtual BOOL OnInitDialog();
        afx_msg void OnHelpButton();
        afx_msg void OnCloseButton();
        afx_msg void OnSendButton();
        afx_msg void OnSettingsButton();
        afx_msg LONG OnContextMenu (WPARAM wParam, LPARAM lParam);
        afx_msg LONG OnHelp (WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
private:
    UINT m_iFileNamesCharCount;
    void UpdateSelection();
    TCHAR m_szFilter[MAX_PATH];
    void LoadFilter();
    TCHAR m_szCaption[MAX_PATH];
    void InitializeUI();
    CWnd* m_pParentWnd;
    ITaskbarList* m_ptl;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IRFTPDLG_H__10D3BB07_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\multdevices.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    multdevices.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#if !defined(AFX_MULTDEVICES_H__43C347D1_B211_11D1_A60A_00C04FC252BD__INCLUDED_)
#define AFX_MULTDEVICES_H__43C347D1_B211_11D1_A60A_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "DeviceList.h"

// MultDevices.h : header file
//

class CSendProgress;    //forward declaration
/////////////////////////////////////////////////////////////////////////////
// CMultDevices dialog

class CMultDevices : public CDialog
{
// Construction
public:
    CMultDevices(CWnd* pParent = NULL, CDeviceList* pDevList = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CMultDevices)
    enum { IDD = IDD_DEVICECHOOSER };
    CListBox    m_lstDevices;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMultDevices)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CMultDevices)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg LONG OnContextMenu (WPARAM wParam, LPARAM lParam);
    afx_msg LONG OnHelp (WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    CSendProgress* m_pParentWnd;
    CDeviceList* m_pDevList;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MULTDEVICES_H__43C347D1_B211_11D1_A60A_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\recvconf.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    recvconf.cpp

Abstract:

    Dialog which prompts the user for receive confirmation.

Author:

    Rahul Thombre (RahulTh) 10/26/1999

Revision History:

    10/26/1999  RahulTh         Created this module.

--*/

#include "precomp.hxx"

CRecvConf::CRecvConf (CWnd * pParent /*= NULL*/)
    : CDialog (CRecvConf::IDD, pParent), m_bShowAllYes (TRUE),
    m_bDirectory (FALSE), m_pParent(pParent)
{
}

void CRecvConf::ShowAllYes (BOOL bShow)
{
    m_bShowAllYes = bShow;
}

void CRecvConf::InitNames (LPCTSTR szMachine, LPTSTR szFile, BOOL fDirectory)
{
    TCHAR   szCompactName [COMPACT_PATHLEN + 1];
    DWORD   len;

    m_szMachine = szMachine;
    m_bDirectory = fDirectory;
    if (m_bDirectory)
    {
        len = wcslen (szFile);
        if (L'\\' == szFile[len - 1])
        {
            szFile[len - 1] = L'\0';
            len--;
        }
    }

    //compact the filename so that we do not overrun the text control
    if (COMPACT_PATHLEN < len &&
        PathCompactPathEx (szCompactName, szFile, COMPACT_PATHLEN + 1, 0))
    {
        m_szFileName = szCompactName;
    }
    else
    {
        m_szFileName = szFile;
    }
}

void CRecvConf::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRecvConf)
    DDX_Control(pDX, IDC_CONFIRMTEXT, m_confirmText);
    DDX_Control(pDX, IDYES, m_btnYes);
    DDX_Control(pDX, IDALLYES, m_btnAllYes);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRecvConf, CDialog)
        //{{AFX_MSG_MAP(CRecvConf)
        ON_BN_CLICKED(IDYES, OnYes)
        ON_BN_CLICKED(IDALLYES, OnAllYes)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CRecvConf::OnInitDialog()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString     szFormat;
    CString     szDisplay;
    CWnd    *   pDesktop = NULL;
    int         newHeight, newWidth, xshift, yshift;
    RECT        rc;

    CDialog::OnInitDialog();

    //display the confirmation text.
    szFormat.LoadString (m_bDirectory ? IDS_CONFIRM_FOLDER : IDS_CONFIRM_FILE);
    szDisplay.Format (szFormat, m_szMachine, m_szFileName);
    m_confirmText.SetWindowText (szDisplay);

    //hide the "Yes To All" button if necessary
    //also move the Yes button in that case.
    if (! m_bShowAllYes)
    {
        RECT    rectAllYes;
        m_btnAllYes.ShowWindow (SW_HIDE);
        m_btnAllYes.GetWindowRect (&rectAllYes);
        ::MapWindowPoints (NULL, m_hWnd, (LPPOINT) &rectAllYes, 2);
        m_btnYes.SetWindowPos (NULL, rectAllYes.left, rectAllYes.top, -1, -1,
                               SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOSIZE);

    }

    //reposition the window so that it is at the center of the screen
    //also push this window to the top after activating it
    GetClientRect (&rc);
    newHeight = rc.bottom;
    newWidth = rc.right;
    pDesktop = GetDesktopWindow();
    pDesktop->GetClientRect (&rc);
    yshift = (rc.bottom - newHeight)/2;
    xshift = (rc.right - newWidth)/2;
    //there might be a problem if someday the dialog should
    //get larger than the desktop. But then, there is no way
    //we can fit that window inside the desktop anyway.
    //So the best we can do is place it at the top left corner
    xshift = (xshift >= 0)?xshift:0;
    yshift = (yshift >= 0)?yshift:0;
    appController->SetForegroundWindow();
    SetActiveWindow();
    SetWindowPos (&wndTop, xshift, yshift, -1, -1,
                  SWP_NOSIZE | SWP_NOOWNERZORDER);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CRecvConf::OnYes ()
{
    EndDialog (IDYES);
}

void CRecvConf::OnAllYes ()
{
    EndDialog (IDALLYES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\irftpdlg.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    irftpdlg.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// irftpDlg.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//the context sensitive help array
const DWORD g_aHelpIDs_IDD_IRDA_DIALOG[]=
{
    IDC_IR_DESC,        IDH_DISABLEHELP,    // Untitled: "You can send..." (Static)
    IDC_LOCATION_GROUP, IDH_DISABLEHELP, // Untitled: "Location" (Button)
    IDB_HELP_BUTTON,    IDH_HELP_BUTTON,    // Untitled: "Help" (Button)
    IDB_SEND_BUTTON,    IDH_SEND_BUTTON,    // Untitled: "Send" (Button)
    IDB_SETTINGS_BUTTON,    IDH_SETTINGS_BUTTON,    // Untitled: "Settings" (Button)
    IDB_CLOSE_BUTTON,   IDH_CLOSE_BUTTON,   // Untitled: "Close" (Button)
    IDC_ADD_DESC,       IDH_DISABLEHELP,    //the second line of text describing the ir dialog
    IDC_IR_ICON,        IDH_DISABLEHELP,    //the icon on the dialog
    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// CIrftpDlg dialog

CIrftpDlg::CIrftpDlg( ) : CFileDialog(TRUE)
{
    //{{AFX_DATA_INIT(CIrftpDlg)
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32

    //get the location of the "My Documents" folder
    //this should be used as the initial dir.
    m_lpszInitialDir[0] = '\0';   //just in case SHGetSpecialFolderPath fails.
    SHGetSpecialFolderPath (NULL, m_lpszInitialDir, CSIDL_PERSONAL, FALSE);
    //if the above call fails, then the common file open dialog box will
    //default to the current directory.


    m_iFileNamesCharCount = 0;
    TCHAR szFile[] = TEXT("\0");

    m_ptl = NULL;
    m_pParentWnd = NULL;

    LoadString(g_hInstance, IDS_CAPTION, m_szCaption, MAX_PATH);
    LoadFilter();
    m_ofn.lStructSize = sizeof(OPENFILENAME);
    m_ofn.hInstance = g_hInstance;
    m_ofn.lpstrFilter = m_szFilter;
    m_ofn.nFilterIndex = 1;
    m_ofn.lpstrFile = m_lpstrFile;
    m_ofn.lpstrFile[0] = '\0';
    m_ofn.nMaxFile = MAX_PATH;
    m_ofn.lpstrInitialDir = m_lpszInitialDir;
    m_ofn.lpstrTitle = m_szCaption;
    m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_IRDA_DIALOG);
    m_ofn.Flags |= OFN_EXPLORER | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK |
        OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_ALLOWMULTISELECT |
        OFN_PATHMUSTEXIST | OFN_NODEREFERENCELINKS;
    m_ofn.Flags &= (~ OFN_ENABLESIZING);

}

void CIrftpDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CIrftpDlg)
        DDX_Control(pDX, IDB_HELP_BUTTON, m_helpBtn);
        DDX_Control(pDX, IDB_SETTINGS_BUTTON, m_settingsBtn);
        DDX_Control(pDX, IDB_SEND_BUTTON, m_sendBtn);
        DDX_Control(pDX, IDB_CLOSE_BUTTON, m_closeBtn);
        DDX_Control(pDX, IDC_LOCATION_GROUP, m_locationGroup);
        DDX_Control(pDX, 1119, m_commFile);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CIrftpDlg, CFileDialog)
        //{{AFX_MSG_MAP(CIrftpDlg)
        //ON_WM_PAINT() //uncomment this line only if the dialog has a bitmap instead of an icon that needs to be drawn transparently.
        ON_BN_CLICKED(IDB_HELP_BUTTON, OnHelpButton)
        ON_BN_CLICKED(IDB_CLOSE_BUTTON, OnCloseButton)
        ON_BN_CLICKED(IDB_SEND_BUTTON, OnSendButton)
        ON_BN_CLICKED(IDB_SETTINGS_BUTTON, OnSettingsButton)
        ON_MESSAGE (WM_HELP, OnHelp)
        ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
        ON_WM_SYSCOMMAND()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIrftpDlg message handlers

BOOL CIrftpDlg::OnInitDialog()
{
        HWND hWndParent;        //handle to the parent window,
                                //viz.the common file dialog box created by explorer
        HRESULT hr = E_FAIL;

        CFileDialog::OnInitDialog();

        //save the pointer to the parent window
        m_pParentWnd = GetParent();
        hWndParent = m_pParentWnd->m_hWnd;

        //Add icons to the parent window
        //to see if we can get the Wireless Link icon on Alt-<Tab>
        m_pParentWnd->ModifyStyle (0, WS_SYSMENU | WS_CAPTION, SWP_NOSIZE | SWP_NOMOVE);

        //hide the Help, Open and Cancel buttons. We will use our own
        //this helps in having a better looking UI
        CommDlg_OpenSave_HideControl(hWndParent, pshHelp);
        CommDlg_OpenSave_HideControl(hWndParent, IDOK);
        CommDlg_OpenSave_HideControl(hWndParent, IDCANCEL);
        CommDlg_OpenSave_HideControl(hWndParent, stc2);
        CommDlg_OpenSave_HideControl(hWndParent, cmb1);

        //Initialize the taskbar list interface
        hr = CoInitialize(NULL);
        if (SUCCEEDED (hr))
            hr = CoCreateInstance(CLSID_TaskbarList, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_ITaskbarList, 
                                  (LPVOID*)&m_ptl);

        if (SUCCEEDED(hr))
        {
            hr = m_ptl->HrInit();
        }
        else
        {
            m_ptl = NULL;
        }

        if (m_ptl)
        {
            if (SUCCEEDED(hr))
                m_ptl->AddTab(m_pParentWnd->m_hWnd);
            else
            {
                m_ptl->Release();
                m_ptl = NULL;
            }
        }

        // return TRUE  unless you set the focus to a control
        return TRUE;
}

BOOL CIrftpDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{

    LPOFNOTIFY lpofn = (LPOFNOTIFY)lParam;

    switch (lpofn->hdr.code)
    {
    case CDN_INITDONE:
        InitializeUI();
        break;
    case CDN_FOLDERCHANGE:
        //clear the edit box whenever the folder is changed
        //using both the controls because of the bug which gives the older
        //file dialog in some cases and the new file dialog in some others
        CommDlg_OpenSave_SetControlText(m_pParentWnd->m_hWnd, edt1, TEXT(""));
        CommDlg_OpenSave_SetControlText(m_pParentWnd->m_hWnd, cmb13, TEXT(""));
        break;
    case CDN_SELCHANGE:
        UpdateSelection();
        break;
    case CDN_FILEOK:
        UpdateSelection();
        OnSendButton();
        *pResult = 1;
        return TRUE;
    default:
        return CFileDialog::OnNotify(wParam, lParam, pResult);
    }

    return TRUE;
}

void CIrftpDlg::OnHelpButton ()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString szHelpFile;

    szHelpFile.LoadString (IDS_HTML_HELPFILE);
    g_hwndHelp = HtmlHelp (m_pParentWnd->m_hWnd, (LPCTSTR) szHelpFile, HH_DISPLAY_TOPIC, 0);
}

void CIrftpDlg::OnCloseButton()
{
        //owing to UI design issues, we chose to use our own Close button
        //rather than the explorer provided Cancel button in the common
        //file dialog box
        //m_pParentWnd->PostMessage(WM_QUIT);
        m_pParentWnd->PostMessage(WM_CLOSE);
}

//this function is invoked when the CDN_INITDONE message is received
//this indicates that explorer has finished placing and resizing the
//controls on the template.
//this function resizes and moves some of the controls to make sure
//that the common file dialog controls and the template controls do
//not overlap
void CIrftpDlg::InitializeUI()
{
        //change the geometry of some of the controls so that the UI looks good
        //and there are no overlapping controls
        RECT rc;
        int newWidth, newHeight, xshift, yshift, btnTop, parentLeft, parentTop;
        CWnd* pParentWnd;
        CWnd* pDesktop;
        CWnd* pTemplateParentWnd;
        UINT commFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER;

        m_commFile.GetClientRect(&rc);
        newWidth = rc.right - rc.left + 20;
        newHeight = rc.bottom - rc.top + 20;

        //resize the Location group box so that the common file controls
        //are inscribed in it
        m_locationGroup.SetWindowPos(NULL, -1, -1, newWidth, newHeight,
                                     SWP_NOMOVE | commFlags);

        //shift the Send, Settings and Close buttons so that the last button
        //is aligned with the right edge of the group box controls.
        pTemplateParentWnd = m_locationGroup.GetParent();
        pParentWnd = GetParent();
        pParentWnd->GetWindowRect(&rc);
        parentLeft = rc.left;
        parentTop = rc.top;
        m_locationGroup.GetWindowRect(&rc);
        btnTop = rc.bottom - 10;
        ::MapWindowPoints(NULL , pTemplateParentWnd->m_hWnd , (LPPOINT) &rc , 2);
        xshift = rc.right;
        m_closeBtn.GetWindowRect(&rc);
        ::MapWindowPoints(NULL , pTemplateParentWnd->m_hWnd , (LPPOINT) &rc , 2);
        xshift -= rc.right;

        m_closeBtn.SetWindowPos(NULL, rc.left + xshift,
                                            btnTop - parentTop, -1, -1,
                                            SWP_NOSIZE | commFlags);

        m_sendBtn.GetWindowRect(&rc);
        ::MapWindowPoints(NULL , pTemplateParentWnd->m_hWnd , (LPPOINT) &rc , 2);
        m_sendBtn.SetWindowPos(NULL, rc.left  + xshift,
                                            btnTop - parentTop, -1, -1,
                                            SWP_NOSIZE | commFlags);

        //move the help button so that its left edge aligns with the left
        //edge of the location group box.
        m_locationGroup.GetWindowRect (&rc);
        ::MapWindowPoints(NULL , pTemplateParentWnd->m_hWnd , (LPPOINT) &rc , 2);
        xshift = rc.left;
        m_helpBtn.GetWindowRect (&rc);
        ::MapWindowPoints(NULL , pTemplateParentWnd->m_hWnd , (LPPOINT) &rc , 2);
        xshift -= rc.left;
        m_helpBtn.SetWindowPos (NULL, rc.left + xshift,
                                btnTop - parentTop,
                                -1, -1, SWP_NOSIZE | commFlags);
        m_settingsBtn.GetWindowRect (&rc);
        ::MapWindowPoints(NULL , pTemplateParentWnd->m_hWnd , (LPPOINT) &rc , 2);
        //move the Settings button so that the distance between the
        //Help and Settings button conforms to the UI guidelines.
        m_settingsBtn.SetWindowPos (NULL, rc.left + xshift,
                                    btnTop - parentTop, -1, -1,
                                    SWP_NOSIZE | commFlags);

        //now that all the controls have been positioned appropriately,
        //reposition the entire window so that it appears at the center
        //of the screen rather than being partially obscured by the screen.
        pParentWnd->GetClientRect (&rc);
        newHeight = rc.bottom;
        newWidth = rc.right;
        pDesktop = GetDesktopWindow();
        pDesktop->GetClientRect (&rc);
        yshift = (rc.bottom - newHeight)/2;
        xshift = (rc.right - newWidth)/2;
        //there might be a problem if someday the dialog should
        //get larger than the desktop. But then, there is no way
        //we can fit that window inside the desktop anyway.
        //So the best we can do is place it at the top left corner
        xshift = (xshift >= 0)?xshift:0;
        yshift = (yshift >= 0)?yshift:0;
        pParentWnd->SetWindowPos (NULL, xshift, yshift,
                                  -1, -1, SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER);
        pParentWnd->SetActiveWindow();
}

void CIrftpDlg::LoadFilter()
{
        int strId;
        TCHAR* curr;
        int step, remainChars;

        for(strId = IDS_FILTER_START + 1, curr = m_szFilter, remainChars = MAX_PATH - 1;
                strId < IDS_FILTER_END;
                strId++, curr += step + 1, remainChars -= (step + 1))
                {
                        step = LoadString(g_hInstance, strId, curr, remainChars);
                }

        *curr = '\0';   //terminated by 2 NULLs
}

void CIrftpDlg::OnSendButton()
{
    int iSize = (m_iFileNamesCharCount>MAX_PATH)?m_iFileNamesCharCount:MAX_PATH;    //kluge
    TCHAR 	*lpszName = NULL;
    TCHAR 	lpszPath[MAX_PATH];
    TCHAR 	*lpszFileList = NULL;
    TCHAR 	*lpszFullPathnamesList;
    int 	iFileCount;
    int 	iCharCount;
	BOOL	bAllocFailed = FALSE;
	
	try 
	{
		lpszName = new TCHAR [iSize];
		lpszFileList = new TCHAR [iSize];
	}
	catch (CMemoryException* e)
	{
		bAllocFailed = TRUE;
		e->Delete();
	}
    if (bAllocFailed || (NULL == lpszName) || (NULL == lpszFileList))
        goto cleanup_onSend;

    CommDlg_OpenSave_GetFolderPath(m_pParentWnd->m_hWnd, lpszPath, MAX_PATH);
    CommDlg_OpenSave_GetSpec (m_pParentWnd->m_hWnd, lpszName, MAX_PATH);
    iFileCount = ParseFileNames(lpszName, lpszFileList, iCharCount);

    if (!iFileCount)
        goto cleanup_onSend;         //no files/dirs have been selected
    else if(1 == iFileCount)    //this is a special case because if there is only one file, then absolute paths/UNC paths are allowed
        lpszFullPathnamesList = ProcessOneFile (lpszPath, lpszFileList, iFileCount, iCharCount);
    else
        lpszFullPathnamesList = GetFullPathnames(lpszPath, lpszFileList, iFileCount, iCharCount);


    CSendProgress* dlgProgress;
    dlgProgress = new CSendProgress(lpszFullPathnamesList, iCharCount);
    dlgProgress->ShowWindow(SW_SHOW);
    dlgProgress->SetFocus();
    dlgProgress->SetWindowPos (&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE);

cleanup_onSend:
    if (lpszName)
        delete [] lpszName;
    if (lpszFileList)
        delete [] lpszFileList;
}

void CIrftpDlg::OnSettingsButton()
{
    appController->PostMessage(WM_APP_TRIGGER_SETTINGS);
}

void CIrftpDlg::UpdateSelection()
{
        CListCtrl* pDirContents;
        pDirContents = (CListCtrl*)(m_pParentWnd->GetDlgItem(lst2))->GetDescendantWindow(1);
        TCHAR lpszPath[MAX_PATH];
        CString szPath;
        CString szFullName;
        CString szEditBoxText;

        //get the path of the folder
        CommDlg_OpenSave_GetFolderPath (m_pParentWnd->m_hWnd, lpszPath, MAX_PATH);
        szPath = lpszPath;  //easier to manipulate CStrings

        LONG nFiles = pDirContents->GetSelectedCount();
        TCHAR pszFileName[MAX_PATH];
        DWORD dwFileAttributes;
        CString szFilesList;
        int iSelectedDirCount = 0;
        int nIndex;
        if (nFiles)
        {
            //go to the point just before the first selected item
            nIndex = pDirContents->GetTopIndex() - 1;
            szEditBoxText.Empty();
            szPath += '\\';
            //first add all the directories
            while (-1 != (nIndex = pDirContents->GetNextItem(nIndex, LVNI_ALL | LVNI_SELECTED)))
            {
                pDirContents->GetItemText(nIndex, 0, pszFileName, MAX_PATH);
                szFullName = szPath + pszFileName;
                //check if it is a directory.
                dwFileAttributes = GetFileAttributes(szFullName);
                if (0xFFFFFFFF != dwFileAttributes &&
                    (FILE_ATTRIBUTE_DIRECTORY & dwFileAttributes))
                {
                    //it is a directory so add it to the edit box text
                    szEditBoxText += '\"';
                    szEditBoxText += pszFileName;
                    szEditBoxText += TEXT("\" ");
                    iSelectedDirCount++;
                }
            }
            //now we have got all the directories, get the files list if any
            if (nFiles > iSelectedDirCount)
            {
                //if nFiles > iSelectedDirCount, it means that all the selected
                //items are not dirs. this check is necessary because the function
                //GetFileName will return the names of the last set of files
                //selected if no file is currently selected. this is clearly
                //not what we want
                szFilesList.Empty();
                szFilesList = GetFileName();
                if ((!szFilesList.IsEmpty()) && '\"' != szFilesList[0])
                {
                    //only one file is selected. we must add the enclosing
                    //double quotes ourselves, since the common file dialog
                    //does not do it for us.
                    szFilesList = '\"' + szFilesList + TEXT("\" ");
                }
                //add the list of files to the end of the list of directories
                szEditBoxText += szFilesList;
            }

            //populate the controls with this list
            CommDlg_OpenSave_SetControlText(m_pParentWnd->m_hWnd, edt1, (LPCTSTR)szEditBoxText);
            CommDlg_OpenSave_SetControlText(m_pParentWnd->m_hWnd, cmb13, (LPCTSTR)szEditBoxText);
            m_iFileNamesCharCount = szEditBoxText.GetLength() + 1;
        }
        else
        {
            m_iFileNamesCharCount = 0;
            CommDlg_OpenSave_SetControlText(m_pParentWnd->m_hWnd, edt1, TEXT(""));
            CommDlg_OpenSave_SetControlText(m_pParentWnd->m_hWnd, cmb13, TEXT(""));
        }
}

void CIrftpDlg::PostNcDestroy()
{
    if (m_ptl)
    {
        m_ptl->DeleteTab(m_pParentWnd->m_hWnd);
        m_ptl->Release();
        m_ptl = NULL;
    }

    CFileDialog::PostNcDestroy();
}

LONG CIrftpDlg::OnHelp (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG        lResult = 0;
    CString     szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDs_IDD_IRDA_DIALOG);

    return lResult;
}

LONG CIrftpDlg::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString(IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_IRDA_DIALOG);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\multdevices.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    multdevices.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// MultDevices.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//the array used for context sensitive help
const DWORD g_aHelpIDs_IDD_DEVICECHOOSER[]=
{
    IDC_CHOOSERDESC,    IDH_DISABLEHELP,
    IDC_DEVICELIST,     IDH_DEVICELIST,
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CMultDevices dialog


CMultDevices::CMultDevices(CWnd* pParent /*=NULL*/, CDeviceList* pDevList /* = NULL*/)
    : CDialog(CMultDevices::IDD, pParent), m_pDevList (pDevList)
{
    m_pParentWnd = (CSendProgress*)pParent;
    //{{AFX_DATA_INIT(CMultDevices)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CMultDevices::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMultDevices)
    DDX_Control(pDX, IDC_DEVICELIST, m_lstDevices);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMultDevices, CDialog)
    //{{AFX_MSG_MAP(CMultDevices)
    ON_MESSAGE (WM_HELP, OnHelp)
    ON_MESSAGE (WM_CONTEXTMENU, OnContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMultDevices message handlers

BOOL CMultDevices::OnInitDialog()
{
    CDialog::OnInitDialog();

    int len, i;
    int index;
    TCHAR devName[MAX_PATH];

    EnterCriticalSection(&(m_pDevList->m_criticalSection));
    for (i = 0; i < m_pDevList->m_lNumDevices; i++)
    {
        wcscpy (devName, m_pDevList->m_pDeviceInfo[i].DeviceName);
        index = m_lstDevices.AddString(devName);
        if (m_pDevList->m_pDeviceInfo[i].DeviceType == TYPE_IRDA) {

            m_lstDevices.SetItemData (index, (DWORD)m_pDevList->m_pDeviceInfo[i].DeviceSpecific.s.Irda.DeviceId);

        } else {

            m_lstDevices.SetItemData (index, (DWORD)m_pDevList->m_pDeviceInfo[i].DeviceSpecific.s.Ip.IpAddress);
        }
    }
    LeaveCriticalSection(&(m_pDevList->m_criticalSection));

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CMultDevices::OnOK()
{
    int iSel;
    iSel = m_lstDevices.GetCurSel();
    m_pParentWnd->m_lSelectedDeviceID = (LONG) m_lstDevices.GetItemData(iSel);
    m_lstDevices.GetText(iSel, m_pParentWnd->m_lpszSelectedDeviceName);
    CDialog::OnOK();
}

LONG CMultDevices::OnHelp (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString (IDS_HELP_FILE);

    ::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_aHelpIDs_IDD_DEVICECHOOSER);

    return lResult;
}

LONG CMultDevices::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    LONG    lResult = 0;
    CString szHelpFile;

    szHelpFile.LoadString (IDS_HELP_FILE);

    ::WinHelp((HWND)wParam,
              (LPCTSTR)szHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_DEVICECHOOSER);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\irrecvprogress.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    irrecvprogress.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#if !defined(AFX_IRRECVPROGRESS_H__92AAA949_B881_11D1_A60D_00C04FC252BD__INCLUDED_)
#define AFX_IRRECVPROGRESS_H__92AAA949_B881_11D1_A60D_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// IrRecvProgress.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIrRecvProgress dialog

#define RECV_MAGIC_ID    0x8999cdef
#define IRDA_DEVICE_NAME_LENGTH 22

class CIrRecvProgress : public CDialog
{
// Construction
public:
    DWORD   m_dwMagicID;

    CIrRecvProgress(wchar_t * MachineName, boolean bSuppressRecvConf,
                    CWnd* pParent = NULL);   // standard constructor
    void DestroyAndCleanup(DWORD status);

    DWORD GetPermission( wchar_t Name[], BOOL fDirectory );
    DWORD PromptForPermission( wchar_t Name[], BOOL fDirectory );


// Dialog Data
    //{{AFX_DATA(CIrRecvProgress)
    enum { IDD = IDD_RECEIVEPROGRESS };
    CAnimateCtrl    m_xferAnim;
    CStatic         m_icon;
    CStatic         m_File;
    CStatic         m_DoneText;
    CStatic         m_machDesc;
    CStatic         m_recvDesc;
    CStatic         m_xferDesc;
    CStatic         m_Machine;
    CButton         m_btnCloseOnComplete;
    CButton         m_btnCancel;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CIrRecvProgress)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CIrRecvProgress)
    virtual void OnCancel();
    virtual BOOL DestroyWindow();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:    //data
    ITaskbarList *  m_ptl;
    wchar_t         m_LastPermittedDirectory[1+MAX_PATH];
    CString         m_szMachineName;
    BOOL            m_fDontPrompt;  //whether the user should be prompted for receive confirmation
    BOOL            m_fFirstXfer;   //if this is the first time we are asking for confirmation
    BOOL            m_bRecvFromCamera;  //indicates if the sender is a camera
    BOOL            m_bDlgDestroyed;    // Indicates that the dialog has already been destroyed. Required to protect against multiple calls to OnRecvFinished
private:    //helper functions
    void ShowProgressControls (int nCmdShow);
    void ShowSummaryControls (int nCmdShow);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IRRECVPROGRESS_H__92AAA949_B881_11D1_A60D_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\recvconf.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    recvconf.h

Abstract:

    Dialog which prompts the user for receive confirmation.

Author:

    Rahul Thombre (RahulTh) 10/26/1999

Revision History:

    10/26/1999  RahulTh         Created this module.

--*/

#if !defined(_RECV_CONF_33fC3E26_AFED_428C_AE07_2C96b6F97969_INCLUDED_)
#define _RECV_CONF_33fC3E26_AFED_428C_AE07_2C96b6F97969_INCLUDED_

#define COMPACT_PATHLEN     35

class CRecvConf : public CDialog
{
public:

    CRecvConf (CWnd * pParent = NULL);
    void ShowAllYes (BOOL bShow = TRUE);
    void InitNames (LPCTSTR szMachine, LPTSTR szFile, BOOL fDirectory);

// Dialog Data
    //{{AFX_DATA(CRecvConf)
    enum { IDD = IDD_CONFIRMRECV };
    CButton         m_btnYes;
    CButton         m_btnAllYes;
    CStatic         m_confirmText;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRecvConf)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CIrRecvProgress)
    virtual BOOL OnInitDialog();
    afx_msg void OnAllYes();
    afx_msg void OnYes();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL        m_bShowAllYes;
    BOOL        m_bDirectory;
    CString     m_szFileName;
    CString     m_szMachine;
    CWnd *      m_pParent;

};

#endif // !defined(_RECV_CONF_33fC3E26_AFED_428C_AE07_2C96b6F97969_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\rpcheaders.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    rpcheaders.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#ifndef     __RPCHEADERS_H__
#define     __RPCHEADERS_H__

#include <irtypes.h>
#include <irsend.h>
#include <irrecv.h>

#endif      //__RPCHEADERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\sendprogress.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    sendprogress.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

#if !defined(AFX_SENDPROGRESS_H__90D62E7B_AEEC_11D1_A60A_00C04FC252BD__INCLUDED_)
#define AFX_SENDPROGRESS_H__90D62E7B_AEEC_11D1_A60A_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define MAGIC_ID    0x89abcdef

// SendProgress.h : header file
//
class CMultDevices; //forward declaration

/////////////////////////////////////////////////////////////////////////////
// CSendProgress dialog

class CSendProgress : public CDialog
{
   friend class CMultDevices;

// Construction
public:
    CSendProgress(LPTSTR lpszFileList = NULL, int iCharCount = 0, CWnd* pParent = NULL);   // standard constructor
    void SetCurrentFileName (wchar_t * pwszCurrFile);
    DWORD   m_dwMagicID;

// Dialog Data
    //{{AFX_DATA(CSendProgress)
    enum { IDD = IDD_SEND_PROGRESS };
    CStatic m_xferPercentage;
    CStatic m_connectedTo;
    CProgressCtrl   m_transferProgress;
    CAnimateCtrl    m_transferAnim;
    CStatic m_fileName;
    CButton m_btnCancel;
    CStatic m_sndTitle;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSendProgress)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSendProgress)
    virtual BOOL OnInitDialog();
    virtual void OnCancel();
    virtual BOOL DestroyWindow();
    afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
    afx_msg void OnUpdateProgress (WPARAM wParam, LPARAM lParam);
    afx_msg void OnSendComplete (WPARAM wParam, LPARAM lParam);
    afx_msg void OnTimer (UINT nTimerID);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:    //data
    TCHAR m_lpszSelectedDeviceName[50];
    int m_iCharCount;
    TCHAR* m_lpszFileList;
    LONG m_lSelectedDeviceID;
    BOOL m_fSendDone;
    BOOL m_fTimerExpired;
    BOOL m_fCancelled;
    ITaskbarList * m_ptl;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SENDPROGRESS_H__90D62E7B_AEEC_11D1_A60A_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\sendprogress.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    sendprogress.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// SendProgress.cpp : implementation file
//

#include "precomp.hxx"
#include "winsock.h"

#define MAX_FILENAME_DISPLAY    35

#define DIALOG_DISPLAY_DURATION 800 //the minimum amount of time a dialog
                                    //should be displayed (in milliseconds)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSendProgress dialog


CSendProgress::CSendProgress(LPTSTR lpszFileList /*=NULL*/, int iCharCount /*=0*/, CWnd* pParent /*=NULL*/)
{
    m_dwMagicID = MAGIC_ID;     //an id used to validate CSendProgress pointers
                                //received over an RPC interface.
    m_lpszFileList = lpszFileList;
    m_iCharCount = iCharCount;
    m_lSelectedDeviceID = errIRFTP_SELECTIONCANCELLED;
    m_lpszSelectedDeviceName[0] = '\0';
    m_fSendDone = FALSE;
    m_fTimerExpired = FALSE;
    m_ptl = NULL;
    m_fCancelled = FALSE;
    appController->PostMessage (WM_APP_KILL_TIMER);
    InterlockedIncrement (&g_lUIComponentCount);
    Create(IDD, appController);
    //{{AFX_DATA_INIT(CSendProgress)
            // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CSendProgress::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CSendProgress)
        DDX_Control(pDX, IDC_XFER_PERCENTAGE, m_xferPercentage);
        DDX_Control(pDX, IDC_CONNECTIONTEXT, m_connectedTo);
        DDX_Control(pDX, IDC_FILESEND_PROGRESS, m_transferProgress);
        DDX_Control(pDX, IDC_FILESEND_ANIM, m_transferAnim);
        DDX_Control(pDX, IDC_FILE_NAME, m_fileName);
        DDX_Control(pDX, IDC_SENDING_TITLE, m_sndTitle);
        DDX_Control(pDX, IDCANCEL, m_btnCancel);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSendProgress, CDialog)
        //{{AFX_MSG_MAP(CSendProgress)
        ON_WM_COPYDATA()
        ON_WM_TIMER()
        ON_MESSAGE(WM_APP_UPDATE_PROGRESS, OnUpdateProgress)
        ON_MESSAGE(WM_APP_SEND_COMPLETE, OnSendComplete)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSendProgress message handlers


ULONG
GetLocationDescription(
    FAILURE_LOCATION Location
    )
{
    switch (Location)
    {
    case locStartup:
        return IDS_LOC_STARTUP;
    case locConnect:
        return IDS_LOC_CONNECT;
    case locFileOpen:
        return IDS_LOC_FILEOPEN;
    case locFileRead:
        return IDS_LOC_FILEREAD;
    case locFileSend:
        return IDS_LOC_FILESEND;
    case locFileRecv:
        return IDS_LOC_FILERECV;
    case locFileWrite:
        return IDS_LOC_FILEWRITE;
    case locUnknown:
    default:
        return IDS_LOC_UNKNOWN;
    }
}

BOOL CSendProgress::OnInitDialog()
{
    TCHAR lpszConnectionInfo[100];
    TCHAR lpszDeviceName[50];
    TCHAR lpszConnecting[50];
    error_status_t err;
    error_status_t sendError;
    LONG lDeviceID;
    FAILURE_LOCATION location=locUnknown;
    CError      error;
    CError      xferError (this);
    CString     szConnect;
    CString     szErrorDesc;
    CString     szLocDesc;
    HRESULT     hr = E_FAIL;
    OBEX_DEVICE_TYPE    DeviceType;

    CDialog::OnInitDialog();

    ::LoadString (g_hInstance, IDS_CONNECTEDTO, lpszConnectionInfo, 100);
    ::LoadString (g_hInstance, IDS_CONNECTING, lpszConnecting, 50);
    szConnect = lpszConnecting;

    m_transferProgress.SetPos(0);
    m_transferAnim.Open (IDR_TRANSFER_AVI);
    m_transferAnim.Play(0, -1, -1);
    m_fileName.SetWindowText (L"");
    m_connectedTo.SetWindowText ((LPCTSTR) szConnect);
    m_xferPercentage.SetWindowText(TEXT("0%"));

    if (!g_deviceList.GetDeviceCount())
    {
        error.ShowMessage (IDS_NODEVICES_ERROR);
        DestroyWindow();
        return TRUE;
    }

    lDeviceID = g_deviceList.SelectDevice(this, lpszDeviceName);

    switch(lDeviceID)
    {
    case errIRFTP_NODEVICE:
        error.ShowMessage (IDS_MISSING_RECIPIENT);

    case errIRFTP_SELECTIONCANCELLED:
        DestroyWindow();
        return TRUE;

    case errIRFTP_MULTDEVICES:  //there were multiple devices in range, one of which was selected

        if (g_deviceList.GetDeviceType(m_lSelectedDeviceID,&DeviceType)) {

            SendFiles (g_hIrRpcHandle, (COOKIE)this, TEXT(""), m_lpszFileList, m_iCharCount, m_lSelectedDeviceID, DeviceType, &sendError, &location);
            lstrcat (lpszConnectionInfo, m_lpszSelectedDeviceName);
            m_connectedTo.SetWindowText(lpszConnectionInfo);

        } else {

            error.ShowMessage (IDS_MISSING_RECIPIENT);
            DestroyWindow();
            return TRUE;
        }
        break;

    default:    //there was only one device in range

        if (g_deviceList.GetDeviceType(lDeviceID,&DeviceType)) {

            SendFiles (g_hIrRpcHandle, (COOKIE)this, TEXT(""), m_lpszFileList, m_iCharCount, lDeviceID, DeviceType, &sendError, &location);
            lstrcat (lpszConnectionInfo, lpszDeviceName);
            m_connectedTo.SetWindowText(lpszConnectionInfo);

        } else {

            error.ShowMessage (IDS_MISSING_RECIPIENT);
            DestroyWindow();
            return TRUE;

        }
        break;
    }

    if (sendError)
    {
        LPVOID  lpMessageBuffer;
        TCHAR   ErrDesc [ERROR_DESCRIPTION_LENGTH];
        CString ErrorDescription;

        if (!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,          // ignored
                            sendError,
                            0,       // try default language ids
                            (LPTSTR) &lpMessageBuffer,
                            0,
                            NULL        // ignored
                            ))
        {
            wsprintf(ErrDesc, g_Strings.ErrorNoDescription, sendError);
            //using the overloaded CString assignment operator. It is
            //essentially a string copy, but MFC takes care of allocating
            //and freeing the destination buffer.
            ErrorDescription = ErrDesc;
        }
        else
        {
            //Note: this is not a pointer assignment. We are using the
            //overloaded CString assignment operator which essentially
            //does a string copy. (see comments above)
            ErrorDescription = (TCHAR *) lpMessageBuffer;
            LocalFree (lpMessageBuffer);
        }

        szLocDesc.LoadString (GetLocationDescription(location));
        xferError.ShowMessage (IDS_XFER_ERROR, (LPCTSTR) szLocDesc,
                               (LPCTSTR) ErrorDescription);
        DestroyWindow();
    }

    //there were no errors.
    //first put up a taskbar button for the dialog
    //Initialize the taskbar list interface
    hr = CoInitialize(NULL);
    if (SUCCEEDED (hr))
        hr = CoCreateInstance(CLSID_TaskbarList, 
                              NULL,
                              CLSCTX_INPROC_SERVER, 
                              IID_ITaskbarList, 
                              (LPVOID*)&m_ptl);
    if (SUCCEEDED(hr))
    {
        hr = m_ptl->HrInit();
    }
    else
    {
        m_ptl = NULL;
    }

    if (m_ptl)
    {
        if (SUCCEEDED(hr))
            m_ptl->AddTab(m_hWnd);
        else
        {
            m_ptl->Release();
            m_ptl = NULL;
        }
    }

    //Also set a timer to go off in half a second
    //this timer is used to ensure that this dialog is displayed for
    //at least half a second so that users can see that the file has been
    //sent
    //if we fail to get a timer, we simply treat this condition as if the
    //timer has expired
    m_fTimerExpired = SetTimer (1, DIALOG_DISPLAY_DURATION, NULL)?FALSE:TRUE;
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CSendProgress::PostNcDestroy()
{
    //do some cleanup
    if (m_lpszFileList)
        delete [] m_lpszFileList;

    BOOL fNoUIComponents = (0 == InterlockedDecrement (&g_lUIComponentCount));
    if (fNoUIComponents &&  ! g_deviceList.GetDeviceCount())
    {
        //there are no UI components displayed and there are no devices in
        //range. Start the timer. If the timer expires, the app. will quit.
        appController->PostMessage (WM_APP_START_TIMER);
    }

    delete this;
}

//removes the taskbar button if one had been put up
BOOL CSendProgress::DestroyWindow()
{
    //stop the animation and close the file.
    m_transferAnim.Stop();
    m_transferAnim.Close();

    //if a taskbar button had been put up, remove that first
    if (m_ptl)
    {
        m_ptl->DeleteTab(m_hWnd);
        m_ptl->Release();
        m_ptl = NULL;
    }

    //then destroy the window
    return CWnd::DestroyWindow();
}

void CSendProgress::OnCancel()
{
    TCHAR   lpszCancel[MAX_PATH];

    CancelSend(g_hIrRpcHandle, (COOKIE)this);
    //important: do not destroy the window here.
    //must wait until confirmation of the cancel
    //is received from the other machine. after that
    //irxfer will call sendcomplete. That is when the
    //window should get destroyed. otherwise, CWnd pointer
    //for this window might get reused and messages from
    //irxfer meant for this window will go to another window
    //which could cause it to get destroyed without the transmission
    //getting interrupted.
    //
    //but make the user aware that an attempt to cancel the send is being made
    m_fCancelled = TRUE;
    m_btnCancel.EnableWindow(FALSE);
    m_sndTitle.SetWindowText (TEXT(""));
    m_fileName.SetWindowText (TEXT(""));
    lpszCancel[0] = '\0';
    ::LoadString (g_hInstance, IDS_SENDCANCEL, lpszCancel, MAX_PATH);
    m_fileName.SetWindowText (lpszCancel);
}


void CSendProgress::OnTimer (UINT nTimerID)
{
    m_fTimerExpired = TRUE;
    //we don't need the timer any more. it needs to go off only once
    KillTimer(1);
    //half a second has elapsed since we started
    //if the send is already complete, then it is this routine's
    //responsibility to destroy the window since the SEND_COMPLETE
    //notification has already been received
    if (m_fSendDone)
        DestroyWindow();
}


BOOL CSendProgress::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    SEND_FAILURE_DATA * pData = (SEND_FAILURE_DATA *) (pCopyDataStruct->lpData);

    LPVOID  lpMessageBuffer;
    TCHAR   ErrDesc [ERROR_DESCRIPTION_LENGTH];
    CString ErrorDescription;
    CString szErrorDesc;
    CString szLocDesc;
    CError  error (this);

    if (m_fCancelled)
        {
        return TRUE;
        }

    if (!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_IGNORE_INSERTS |
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,          // ignored
                        pData->Error,
                        0,       // try default language ids
                        (LPTSTR) &lpMessageBuffer,
                        0,
                        NULL        // ignored
                        ))
    {
        wsprintf(ErrDesc, g_Strings.ErrorNoDescription, pData->Error);
        //using the overloaded CString assignment operator. It is
        //essentially a string copy, but MFC takes care of allocating
        //and freeing the destination buffer.
        ErrorDescription = ErrDesc;
    }
    else
    {
        //Note: this is not a pointer assignment. We are using the
        //overloaded CString assignment operator which essentially
        //does a string copy. (see comments above)
        ErrorDescription = (TCHAR *) lpMessageBuffer;
        LocalFree (lpMessageBuffer);
    }

    szLocDesc.LoadString (GetLocationDescription(pData->Location));
    error.ShowMessage (IDS_SEND_FAILURE, pData->FileName, (LPCTSTR) szLocDesc,
                       (LPCTSTR) ErrorDescription);

    return TRUE;
}

void CSendProgress::OnUpdateProgress (WPARAM wParam, LPARAM lParam)
{
    TCHAR lpszXferPercentage [50];
    wsprintf(lpszXferPercentage, TEXT("%d%%"), (int)lParam);
    m_xferPercentage.SetWindowText (lpszXferPercentage);
    m_transferProgress.SetPos((int)lParam);
}

void CSendProgress::OnSendComplete (WPARAM wParam, LPARAM lParam)
{
    m_fSendDone = TRUE;
    //make sure that the dialog is displayed for at least half a second
    if (m_fTimerExpired)
        DestroyWindow();
}

//+--------------------------------------------------------------------------
//
//  Member:    SetCurrentFileName
//
//  Synopsis:  displays on the progress dialog the name of the file that is
//             currently being transmitted
//
//  Arguments: [in] pwszCurrFile : name of the file being transmitted
//
//  Returns:   nothing
//
//  History:   12/14/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CSendProgress::SetCurrentFileName (wchar_t * pwszCurrFile)
{
   WCHAR *  pwszSource;
   WCHAR *  pwszDest;
   WCHAR *  pwszTemp;
   int      len;
   int      cbStart;
   int      cbEnd;
   int      i;
   const int cbCenter = 5;

   if (m_fCancelled)
   {
       //the user has already hit cancel on this dialog and we are just
       //waiting for confirmation from irxfer. Hence we do not change
       //the file name as that control is now being used to indicate
       //that we are trying to abort the file transfer
       return;
   }

   if (!pwszCurrFile)
   {
      m_fileName.SetWindowText (L"");
      return;
   }

   len = wcslen (pwszCurrFile);

   if (len > MAX_FILENAME_DISPLAY)
   {
      cbStart = MAX_FILENAME_DISPLAY/2 - cbCenter;
      cbEnd = MAX_FILENAME_DISPLAY - cbStart - cbCenter;
      pwszTemp = pwszCurrFile + cbStart;
      pwszTemp [0] = L' ';
      pwszTemp[1] = pwszTemp[2] = pwszTemp[3] = L'.';
      pwszTemp[4] = L' ';
      for (i = 0, pwszSource = pwszCurrFile + len - cbEnd, pwszDest = pwszTemp + cbCenter;
           i <= cbEnd; /*account for the terminating NULL too*/
           i++, pwszSource++, pwszDest++)
         *pwszDest = *pwszSource;
   }

   m_fileName.SetWindowText (pwszCurrFile);
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\stdafx.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    stdafx.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__10D3BB09_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_)
#define AFX_STDAFX_H__10D3BB09_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxpriv.h>        // MFC support for context sensitive help
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <rpc.h>
#include <afxcview.h>
#include <dlgs.h>
#include <cpl.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__10D3BB09_9CFF_11D1_A5ED_00C04FC252BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by irftp.rc
//
#define IDALLYES                        3
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_IRFTP_DIALOG                102
#define IDD_IRDA_DIALOG                 102
#define IDS_FILE_TYPES                  102
#define IDS_CAPTION                     103
#define IDR_MAINFRAME                   128
#define IDB_IR_BMP                      129
#define IDD_SEND_PROGRESS               130
#define IDD_CONTROLLER                  131
#define IDC_ABORT                       132
#define IDD_DEVICECHOOSER               137
#define IDD_RECEIVEPROGRESS             140
#define IDD_CONFIRMRECV                 141
#define IDS_HELP_FILE                   161
#define IDS_HTML_HELPFILE               162
#define IDS_EXE                         163
#define IDS_DESKTOP_SHTCUT              164
#define IDS_SENDTO_SHTCUT               165
#define IDS_DEFAULT_ERROR_TITLE         200
#define IDS_DEFAULT_ERROR               201
#define IDS_APPLET_ERROR                202
#define IDS_MISSING_PROTOCOL            203
#define IDS_DEVLIST_ERROR               204
#define IDS_INVALID_PARAMETERS          205
#define IDS_NODEVICES_ERROR             206
#define IDS_MISSING_RECIPIENT           207
#define IDS_RECV_CANCELLED              208
#define IDS_NODESC_ERROR                209
#define IDS_XFER_ERROR                  210
#define IDS_SEND_FAILURE                211
#define IDS_SENDING                     300
#define IDS_CONNECTING                  301
#define IDS_CONNECTEDTO                 302
#define IDS_SHTCUT_DESC                 303
#define IDS_LOC_STARTUP                 304
#define IDS_LOC_CONNECT                 305
#define IDS_LOC_FILEOPEN                306
#define IDS_LOC_FILEREAD                307
#define IDS_LOC_FILESEND                308
#define IDS_LOC_FILERECV                309
#define IDS_LOC_FILEWRITE               310
#define IDS_LOC_UNKNOWN                 311
#define IDS_SHUTDOWN_MESSAGE            312
#define IDS_CLOSE                       314
#define IDS_COMPLETED                   315
#define IDS_RECV_ERROR                  316
#define IDS_CONFIRM_FOLDER              317
#define IDS_CONFIRM_FILE                318
#define IDC_IR_DESC                     1001
#define IDC_ADD_DESC                    1002
#define IDC_CONNECTION_STATUS           1003
#define IDC_LOCATION_GROUP              1004
#define IDC_CONNECTION_STAT_GROUP       1005
#define IDB_SEND_BUTTON                 1006
#define IDB_SETTINGS_BUTTON             1007
#define IDB_CLOSE_BUTTON                1008
#define IDB_HELP_BUTTON                 1009
#define IDC_FILESEND_PROGRESS           2006
#define IDC_FILESEND_ANIM               2007
#define IDC_FILE_NAME                   2008
#define IDC_CHOOSERDESC                 2010
#define IDC_DEVICELIST                  2011
#define IDC_CONNECTIONTEXT              2012
#define IDC_RECV_XFERANIM               2014
#define IDC_RECVDESCRIPTION             2015
#define IDC_XFER_PERCENTAGE             2016
#define IDC_IR_ICON                     2017
#define IDC_SENDING_TITLE               2018
#define IDC_RECV_FILE_NAME              2019
#define IDC_CLOSEONCOMPLETE             2019
#define IDC_RECV_CONNECTIONTEXT         2020
#define IDC_SAVEDICON                   2021
#define IDC_DONETEXT                    2022
#define IDC_MACHNAME                    2023
#define IDC_FILENAME                    2024
#define IDC_QUESTIONICON                2025
#define IDC_CONFIRMTEXT                 2026
#define IDC_XFER_DESC                   2027
#define IDS_FILTER_START                5001
#define IDS_ALL_FILES                   5002
#define IDS_ALL_FILES_FILTER            5003
#define IDS_FILTER_END                  5004
#define IDS_ERROR_NO_MEMORY             5004
#define IDS_ERROR_DISK_FULL             5005
#define IDS_ERROR_PROTOCOL              5006
#define IDS_ERROR_ABORTED               5007
#define IDS_SENDCANCEL                  5008
#define IDS_CAMERA                      5009
#define IDS_UNKNOWN_DEVICE              5010
#define IDR_TRANSFER_AVI                7001

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         2028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\utils.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    utils.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

    10/12/1998  RahulTh

    added better error handling capabilities : CError etc.

--*/

#ifndef __UTILS_H__
#define __UTILS_H__

class CError
{
public:
    //constructor
    CError (CWnd*   pParentWnd = NULL,
            UINT    titleID = IDS_DEFAULT_ERROR_TITLE,
            DWORD   dwWinErr = ERROR_SUCCESS,
            UINT    nStyle = MB_OK | MB_ICONEXCLAMATION)
    : m_hWndParent(pParentWnd?pParentWnd->m_hWnd:NULL),
      m_msgID (IDS_DEFAULT_ERROR),
      m_titleID (titleID),
      m_winErr (dwWinErr),
      m_nStyle (nStyle)
    {}

    int ShowMessage(UINT errID, ...);

private:
    //data members
    HWND    m_hWndParent; //handle to the parent window
    UINT    m_msgID;  //resource id of the error message
    UINT    m_titleID;//resource id of the title of the error message
    DWORD   m_winErr; //win32 error code if any
    UINT    m_nStyle; //the message box style to be displayed

    //helper functions
    void CError::ConstructMessage (va_list argList, CString& szErrMsg);

};

struct SEND_FAILURE_DATA
{
    TCHAR               FileName[MAX_PATH];
    FAILURE_LOCATION    Location;
    error_status_t      Error;
};

int ParseFileNames (TCHAR* pszInString, TCHAR* pszFilesList, int& iCharCount);
DWORD GetIRRegVal (LPCTSTR szValName, DWORD dwDefVal);
TCHAR* GetFullPathnames (TCHAR* pszPath,   //directory in which the files are located
                const TCHAR* pszFilesList, //NULL separated list of filenames
                int iFileCount,     //number of files in pszFilesList
                int& iCharCount  //number of characters in pszFilesList. also returns the number of characters in the return string
                );
TCHAR* ProcessOneFile (TCHAR* pszPath,   //directory in which the files are located
                const TCHAR* pszFilesList, //NULL separated list of filenames
                int iFileCount,     //number of files in pszFilesList
                int& iCharCount  //number of characters in pszFilesList. also returns the number of characters in the return string
                );
HWND GetPrimaryAppWindow (void);
BOOL InitRPCServer (void);
RPC_BINDING_HANDLE GetRpcHandle (void);
void CreateLinks(void);
void RemoveLinks(void);
HRESULT CreateShortcut (LPCTSTR lpszExe, LPCTSTR lpszLink, LPCTSTR lpszDesc);
BOOL GetShortcutInfo (LPTSTR lpszShortcutName, LPTSTR lpszFullExeName);
BOOL GetSendToInfo (LPTSTR lpszSendToName, LPTSTR lpszFullExeName);

typedef struct tagErrorToStringId
{
    DWORD WinError;
    int   StringId;
} ERROR_TO_STRING_ID, *PERROR_TO_STRING_ID;

#endif  //_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlap\irlap.c ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*       @doc
*       @module irlap.c | Provides IrLAP API
*
*       Author: mbert
*
*       Date: 4/15/95
*
*       @comm
*
*  This module exports the following API's:
*
*       IrlapDown(Message)
*           Receives from LMP:
*               - Discovery request
*               - Connect request/response
*               - Disconnect request
*               - Data/UData request
*
*       IrlapUp(Message)
*           Receives from MAC:
*               - Data indications
*               - Control confirmations
*
*       IrlapTimerExp(Timer)
*           Receives from timer thread timer expiration notifications
*
*       IrlapCloseLink()
*           Shut down IRLAP and IRMAC.
*
*       IrlapGetQosParmVal()
*           Allows IRLMP to decode Qos.
*
*                |---------|
*                |  IRLMP  |
*                |---------|
*                  /|\  |
*                   |   |
*        IrlmpUp()  |   | IrlapDown()
*                   |   |
*                   |  \|/
*                |---------|  IRDA_TimerStart/Stop()   |-------|
*                |         |-------------------------->|       |
*                |  IRLAP  |                           | TIMER |
*                |         |<--------------------------|       |
*                |---------|      XTimerExp()          |-------|
*                  /|\  |
*                   |   |
*        IrlapUp()  |   |IrmacDown()
*                   |   |
*                   |  \|/
*                |---------|
*                |  IRMAC  |
*                |---------|
*
*
*  Discovery Request
*
*  |-------|  IRLAP_DISCOVERY_REQ                                |-------|
*  |       |---------------------------------------------------->|       |
*  | IRLMP |                                                     | IRLAP |
*  |       |<----------------------------------------------------|       |
*  |-------|   IRLAP_DISCOVERY_CONF                              |-------|
*                  DscvStatus = IRLAP_DISCOVERY_COMPLETE
*                               IRLAP_DISCOVERY_COLLISION
*                               MAC_MEDIA_BUSY
*
*  Connect Request
*
*  |-------|  IRLAP_CONNECT_REQ                                  |-------|
*  |       |---------------------------------------------------->|       |
*  | IRLMP |                                                     | IRLAP |
*  |       |<----------------------------------------------------|       |
*  |-------|   IRLAP_CONNECT_CONF                                |-------|
*                  ConnStatus = IRLAP_CONNECTION_COMPLETE
*              IRLAP_DISCONNECT_IND
*                  DiscStatus = IRLAP_NO_RESPONSE
*                               MAC_MEDIA_BUSY
*
*  Disconnect Request
*
*  |-------|  IRLAP_DISCONNECT_REQ                               |-------|
*  |       |---------------------------------------------------->|       |
*  | IRLMP |                                                     | IRLAP |
*  |       |<----------------------------------------------------|       |
*  |-------|   IRLAP_DISCONNECT_IND                              |-------|
*                  DiscStatus = IRLAP_DISCONNECT_COMPLETE
*                               IRLAP_NO_RESPONSE
*
*  UData/Data Request
*
*  |-------|  IRLAP_DATA/UDATA_REQ                               |-------|
*  |       |---------------------------------------------------->|       |
*  | IRLMP |                                                     | IRLAP |
*  |       |<----------------------------------------------------|       |
*  |-------|   IRLAP_DATA_CONF                                   |-------|
*                  DataStatus =  IRLAP_DATA_REQUEST_COMPLETED
*                                IRLAP_DATA_REQUEST_FAILED_LINK_RESET
*
* See irda.h for complete message definitions
*/
#include <irda.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlmp.h>
#include <irlapp.h>
#include <irlapio.h>
#include <irlaplog.h>

#ifdef TEMPERAMENTAL_SERIAL_DRIVER
int TossedDups;
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

BOOLEAN MonitoringLinkStatus;

UINT    IrlapSlotTable[] = {1, 6, 8, 16};

UCHAR   IrlapBroadcastDevAddr[IRDA_DEV_ADDR_LEN] = {0xFF,0xFF,0xFF,0xFF};

// Parameter Value (PV) tables used for negotation
//                      bit0        1       2        3      4
//                         5        6       7        8
//                     --------------------------------------------

UINT vBaudTable[]     = {2400,   9600,   19200,   38400,  57600,\
                         115200, 576000, 1152000, 4000000,16000000};
UINT vMaxTATTable[]   = {500,    250,    100,     50,     25,   \
                         10,     5,      0,       0,      0     };
UINT vMinTATTable[]   = {10000,  5000,   1000,    500,    100,  \
                         50,     10,     0,       0,      0     };
UINT vDataSizeTable[] = {64,     128,    256,     512,    1024, \
                         2048,   0,      0,       0,      0     };
UINT vWinSizeTable[]  = {1,      2,      3,       4,      5,    \
                         6,      7,      0,       0,      0     };
UINT vBOFSTable[]     = {48,     24,     12,      5,      3,    \
                         2,      1,      0,       0,      0     };
UINT vDiscTable[]     = {3,      8,      12,      16,     20,   \
                         25,     30,     40,      0,      0     };
UINT vThreshTable[]   = {0,      3,      3,       3,      3,    \
                         3,      3,      3,       0,      0     };
UINT vBOFSDivTable[]  = {48,     12,     6,       3,      2,    \
                         1,      1,      1,       1,      1     };

// Tables for determining number of BOFS for baud and min turn time
//      min turn time - 10ms   5ms   1ms  0.5ms  0.1ms 0.05ms  0.01ms
//      -------------------------------------------------------------
UINT BOFS_9600[]      = {10,     5,    1,    0,     0,     0,      0};
UINT BOFS_19200[]     = {20,    10,    2,    1,     0,     0,      0};
UINT BOFS_38400[]     = {40,    20,    4,    2,     0,     0,      0};
UINT BOFS_57600[]     = {58,    29,    6,    3,     1,     0,      0};
UINT BOFS_115200[]    = {115,   58,   12,    6,     1,     1,      0};
UINT BOFS_576000[]    = {720,  360,   72,   36,     7,     4,      2};
UINT BOFS_1152000[]   = {1140, 720,  144,   72,    14,     7,      1};
UINT BOFS_4000000[]   = {5000,2500,  500,  250,    50,    25,      5};
UINT BOFS_16000000[]   = {20000,10000,2000,1000,  200,   100,     20};

// Tables for determining maximum line capacity for baud, max turn time
//      max turn time - 500ms   250ms   100ms  50ms  25ms  10ms   5ms
//      -------------------------------------------------------------
UINT MAXCAP_9600[]    = {400,      200,    80,    0,    0,    0,    0};
UINT MAXCAP_19200[]   = {800,      400,   160,    0,    0,    0,    0};
UINT MAXCAP_38400[]   = {1600,     800,   320,    0,    0,    0,    0};
UINT MAXCAP_57600[]   = {2360,    1180,   472,    0,    0,    0,    0};
UINT MAXCAP_115200[]  = {4800,    2400,   960,  480,  240,   96,   48};
UINT MAXCAP_576000[]  = {28800,  11520,  5760, 2880, 1440,  720,  360};
UINT MAXCAP_1152000[] = {57600,  28800, 11520, 5760, 2880, 1440,  720};
UINT MAXCAP_4000000[] = {200000,100000, 40000,20000,10000, 5000, 2500};
UINT MAXCAP_16000000[] ={800000,400000, 160000,80000,40000,20000,10000};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

// prototypes
STATIC VOID InitializeState(PIRLAP_CB, IRLAP_STN_TYPE);
STATIC VOID ReturnRxTxWinMsgs(PIRLAP_CB);
STATIC UINT ProcessConnectReq(PIRLAP_CB, PIRDA_MSG);
STATIC VOID ProcessConnectResp(PIRLAP_CB, PIRDA_MSG);
STATIC UINT ProcessDiscoveryReq(PIRLAP_CB, PIRDA_MSG);
STATIC VOID ProcessDisconnectReq(PIRLAP_CB);
STATIC UINT ProcessDataAndUDataReq(PIRLAP_CB, PIRDA_MSG);
STATIC VOID XmitTxMsgList(PIRLAP_CB, BOOLEAN, BOOLEAN *);
STATIC VOID GotoPCloseState(PIRLAP_CB);
STATIC VOID GotoNDMThenDscvOrConn(PIRLAP_CB);
STATIC VOID ProcessMACControlConf(PIRLAP_CB, PIRDA_MSG);
STATIC VOID ProcessMACDataInd(PIRLAP_CB, PIRDA_MSG);
STATIC VOID ProcessDscvXIDCmd(PIRLAP_CB, IRLAP_XID_DSCV_FORMAT *, UCHAR *);
STATIC VOID ProcessDscvXIDRsp(PIRLAP_CB, IRLAP_XID_DSCV_FORMAT *, UCHAR *);
STATIC VOID ExtractQosParms(IRDA_QOS_PARMS *, UCHAR *, UCHAR *);
STATIC VOID InitDscvCmdProcessing(PIRLAP_CB, IRLAP_XID_DSCV_FORMAT *);
STATIC VOID ExtractDeviceInfo(IRDA_DEVICE *, IRLAP_XID_DSCV_FORMAT *, UCHAR *);
STATIC BOOLEAN DevInDevList(UCHAR[], LIST_ENTRY *);
STATIC VOID AddDevToList(PIRLAP_CB, IRLAP_XID_DSCV_FORMAT *, UCHAR *);
STATIC VOID FreeDevList(LIST_ENTRY *);
STATIC VOID ProcessSNRM(PIRLAP_CB, IRLAP_SNRM_FORMAT *, UCHAR *);
STATIC VOID ProcessUA(PIRLAP_CB, IRLAP_UA_FORMAT *, UCHAR *);
STATIC VOID ProcessDISC(PIRLAP_CB);
STATIC VOID ProcessRD(PIRLAP_CB);
STATIC VOID ProcessRNRM(PIRLAP_CB);
STATIC VOID ProcessDM(PIRLAP_CB);
STATIC VOID ProcessFRMR(PIRLAP_CB);
STATIC VOID ProcessTEST(PIRLAP_CB, PIRDA_MSG, IRLAP_UA_FORMAT *, int, int);
STATIC VOID ProcessUI(PIRLAP_CB, PIRDA_MSG, int, int);
STATIC VOID ProcessREJ_SREJ(PIRLAP_CB, int, PIRDA_MSG, int, int, UINT);
STATIC VOID ProcessRR_RNR(PIRLAP_CB, int, PIRDA_MSG, int, int, UINT);
STATIC VOID ProcessIFrame(PIRLAP_CB, PIRDA_MSG, int, int, UINT, UINT);
STATIC BOOLEAN InvalidNs(PIRLAP_CB, UINT);
STATIC BOOLEAN InvalidNr(PIRLAP_CB, UINT);
STATIC BOOLEAN InWindow(UINT, UINT, UINT);
STATIC VOID ProcessInvalidNsOrNr(PIRLAP_CB, int);
STATIC VOID ProcessInvalidNr(PIRLAP_CB, int);
STATIC VOID InsertRxWinAndForward(PIRLAP_CB, PIRDA_MSG, UINT);
STATIC VOID ResendRejects(PIRLAP_CB, UINT);
STATIC VOID ConfirmAckedTxMsgs(PIRLAP_CB, UINT);
STATIC VOID MissingRxFrames(PIRLAP_CB);
STATIC VOID IFrameOtherStates(PIRLAP_CB, int, int);
STATIC UINT NegotiateQosParms(PIRLAP_CB, IRDA_QOS_PARMS *);
STATIC VOID ApplyQosParms(PIRLAP_CB);
STATIC VOID StationConflict(PIRLAP_CB);
STATIC VOID ApplyDefaultParms(PIRLAP_CB);
STATIC VOID ResendDISC(PIRLAP_CB);
STATIC BOOLEAN IgnoreState(PIRLAP_CB);
STATIC BOOLEAN MyDevAddr(PIRLAP_CB, UCHAR []);
STATIC VOID SlotTimerExp(PVOID);
STATIC VOID FinalTimerExp(PVOID);
STATIC VOID PollTimerExp(PVOID);
STATIC VOID BackoffTimerExp(PVOID);
STATIC VOID WDogTimerExp(PVOID);
STATIC VOID QueryTimerExp(PVOID);
// STATIC VOID StatusTimerExp(PVOID);
STATIC VOID IndicateLinkStatus(PIRLAP_CB);
STATIC VOID StatusReq(PIRLAP_CB, IRDA_MSG *pMsg);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGEIRDA, IrlapOpenLink)
#pragma alloc_text(PAGEIRDA, InitializeState)
#pragma alloc_text(PAGEIRDA, ReturnRxTxWinMsgs)
#pragma alloc_text(PAGEIRDA, ProcessConnectReq)
#pragma alloc_text(PAGEIRDA, ProcessConnectResp)
#pragma alloc_text(PAGEIRDA, ProcessDiscoveryReq)
#pragma alloc_text(PAGEIRDA, ProcessDisconnectReq)
#pragma alloc_text(PAGEIRDA, GotoPCloseState)
#pragma alloc_text(PAGEIRDA, GotoNDMThenDscvOrConn)
#pragma alloc_text(PAGEIRDA, ProcessMACControlConf)
#pragma alloc_text(PAGEIRDA, ExtractQosParms)
#pragma alloc_text(PAGEIRDA, ExtractDeviceInfo)
#pragma alloc_text(PAGEIRDA, FreeDevList)
#pragma alloc_text(PAGEIRDA, ProcessSNRM)
#pragma alloc_text(PAGEIRDA, ProcessUA)
#pragma alloc_text(PAGEIRDA, ProcessRD)
#pragma alloc_text(PAGEIRDA, ProcessRNRM)
#pragma alloc_text(PAGEIRDA, ProcessDM)
#pragma alloc_text(PAGEIRDA, ProcessFRMR)
#pragma alloc_text(PAGEIRDA, ProcessTEST)
#pragma alloc_text(PAGEIRDA, ProcessUI)
#pragma alloc_text(PAGEIRDA, NegotiateQosParms)
#pragma alloc_text(PAGEIRDA, ApplyQosParms)
#pragma alloc_text(PAGEIRDA, StationConflict)
#pragma alloc_text(PAGEIRDA, ApplyDefaultParms)

#endif

#if DBG
void _inline IrlapTimerStart(PIRLAP_CB pIrlapCb, PIRDA_TIMER pTmr)
{
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Start %hs timer for %dms"), pTmr->pName,
                      pTmr->Timeout));
    IrdaTimerStart(pTmr);
}

void _inline IrlapTimerStop(PIRLAP_CB pIrlapCb, PIRDA_TIMER pTmr)
{
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Stop %hs timer"), pTmr->pName));
    IrdaTimerStop(pTmr);
}
#else
#define IrlapTimerStart(c,t)   IrdaTimerStart(t)
#define IrlapTimerStop(c,t)    IrdaTimerStop(t)
#endif

VOID
IrlapOpenLink(OUT PNTSTATUS           Status,
              IN  PIRDA_LINK_CB       pIrdaLinkCb,
              IN  IRDA_QOS_PARMS      *pQos,
              IN  UCHAR               *pDscvInfo,
              IN  int                 DscvInfoLen,
              IN  UINT                MaxSlot,
              IN  UCHAR               *pDeviceName,
              IN  int                 DeviceNameLen,
              IN  UCHAR               CharSet)
{
    UINT        rc = SUCCESS;
    int         i;
    IRDA_MSG    IMsg;
    PIRLAP_CB   pIrlapCb;
    NDIS_STRING AStr = NDIS_STRING_CONST("InfraredTransceiverType");
    
    PAGED_CODE();
    
    DEBUGMSG(DBG_IRLAP, (TEXT("IrlapOpenLink\n")));
    
    if (IRDA_ALLOC_MEM(pIrlapCb, sizeof(IRLAP_CB), MT_IRLAPCB) == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("Alloc failed\n")));
        *Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }
    
    CTEMemSet(pIrlapCb, 0, sizeof(IRLAP_CB));
                
    IrlmpOpenLink(Status,
                  pIrdaLinkCb,
                  pDeviceName,
                  DeviceNameLen,
                  CharSet);

    if (*Status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IrlmpOpenLink failed\n")));
        IRDA_FREE_MEM(pIrlapCb);
        return;
    }
        
    pIrdaLinkCb->IrlapContext = pIrlapCb;

    DscvInfoLen = DscvInfoLen > IRLAP_DSCV_INFO_LEN ?
        IRLAP_DSCV_INFO_LEN : DscvInfoLen;
    
    CTEMemCopy(pIrlapCb->LocalDevice.DscvInfo, pDscvInfo, DscvInfoLen);

    pIrlapCb->LocalDevice.DscvInfoLen = DscvInfoLen;

    CTEMemCopy(&pIrlapCb->LocalQos, pQos, sizeof(IRDA_QOS_PARMS));

    pIrlapCb->MaxSlot       = MaxSlot;
    pIrlapCb->pIrdaLinkCb   = pIrdaLinkCb;
    
    InitializeListHead(&pIrlapCb->TxMsgList);
    
    InitializeListHead(&pIrlapCb->ExTxMsgList);
    
    InitializeListHead(&pIrlapCb->DevList);
    
    for (i = 0; i < IRLAP_MOD; i++)
    {
        pIrlapCb->TxWin.pMsg[i] = NULL;
        pIrlapCb->RxWin.pMsg[i] = NULL;
    }

    // Get the local MAX TAT (for final timeout)
    if ((pIrlapCb->LocalMaxTAT =
         IrlapGetQosParmVal(vMaxTATTable,
                            pIrlapCb->LocalQos.bfMaxTurnTime, NULL)) == -1)
    {
        *Status = STATUS_UNSUCCESSFUL;
        return /*IRLAP_BAD_QOS*/;
    }

    if ((pIrlapCb->LocalWinSize =
         IrlapGetQosParmVal(vWinSizeTable,
                            pIrlapCb->LocalQos.bfWindowSize, NULL)) == -1)
    {
        *Status = STATUS_UNSUCCESSFUL;
        return /*IRLAP_BAD_QOS*/;
    }
        
    // initialize as PRIMARY so UI frames in contention
    // state sends CRBit = cmd
    InitializeState(pIrlapCb, PRIMARY);
    
    pIrlapCb->State = NDM;

    // Generate random local address
    StoreULAddr(pIrlapCb->LocalDevice.DevAddr, (ULONG) GetMyDevAddr(FALSE));

    pIrlapCb->LocalDevice.IRLAP_Version = 0; 

    pIrlapCb->Baud              = IRLAP_CONTENTION_BAUD;
    pIrlapCb->RemoteMaxTAT      = IRLAP_CONTENTION_MAX_TAT;
    pIrlapCb->RemoteDataSize    = IRLAP_CONTENTION_DATA_SIZE;
    pIrlapCb->RemoteWinSize     = IRLAP_CONTENTION_WIN_SIZE; 
    pIrlapCb->RemoteNumBOFS     = IRLAP_CONTENTION_BOFS;

    pIrlapCb->ConnAddr = IRLAP_BROADCAST_CONN_ADDR;

    pIrlapCb->N1 = 0;  // calculated at negotiation
    pIrlapCb->N2 = 0;
    pIrlapCb->N3 = 5;  // recalculated after negotiation ??

#if DBG
    pIrlapCb->PollTimer.pName       = "Poll";
    pIrlapCb->FinalTimer.pName      = "Final" ;
    pIrlapCb->SlotTimer.pName       = "Slot";
    pIrlapCb->QueryTimer.pName      = "Query";
    pIrlapCb->WDogTimer.pName       = "WatchDog";
    pIrlapCb->BackoffTimer.pName    = "Backoff"; 
//    pIrlapCb->StatusTimer.pName     = "Status";   
#endif
    
    IrdaTimerInitialize(&pIrlapCb->PollTimer,
                        PollTimerExp,
                        pIrlapCb->RemoteMaxTAT,
                        pIrlapCb,
                        pIrdaLinkCb);

    IrdaTimerInitialize(&pIrlapCb->FinalTimer,
                        FinalTimerExp,
                        pIrlapCb->LocalMaxTAT,
                        pIrlapCb,
                        pIrdaLinkCb);

    IrdaTimerInitialize(&pIrlapCb->SlotTimer,
                        SlotTimerExp,
                        IRLAP_SLOT_TIMEOUT,
                        pIrlapCb,
                        pIrdaLinkCb);
    
    IrdaTimerInitialize(&pIrlapCb->QueryTimer,
                        QueryTimerExp,
                        (IRLAP_MAX_SLOTS + 4) * IRLAP_SLOT_TIMEOUT*2,
                        pIrlapCb,
                        pIrdaLinkCb);
    
    IrdaTimerInitialize(&pIrlapCb->WDogTimer,
                        WDogTimerExp,
                        3000,
                        pIrlapCb,
                        pIrdaLinkCb);

    IrdaTimerInitialize(&pIrlapCb->BackoffTimer,
                        BackoffTimerExp,
                        0,
                        pIrlapCb,
                        pIrdaLinkCb);

/*
    IrdaTimerInitialize(&pIrlapCb->StatusTimer,
                        StatusTimerExp,
                        250,
                        pIrlapCb,
                        pIrdaLinkCb);

    // Only monitor the link status of the first link
              
    if (!MonitoringLinkStatus)
    {
        MonitoringLinkStatus = TRUE;
        pIrlapCb->MonitorLink = TRUE;        
    
    }   
    else
    {
        pIrlapCb->MonitorLink = FALSE;
    }                                                 
*/

    // Initialize Link
    IMsg.Prim               = MAC_CONTROL_REQ;
    IMsg.IRDA_MSG_Op        = MAC_INITIALIZE_LINK;
    IMsg.IRDA_MSG_Baud      = IRLAP_CONTENTION_BAUD;
    IMsg.IRDA_MSG_NumBOFs   = IRLAP_CONTENTION_BOFS;
    IMsg.IRDA_MSG_DataSize  = IRLAP_CONTENTION_DATA_SIZE;
    IMsg.IRDA_MSG_MinTat    = 0;
    
    IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);

    *Status = STATUS_SUCCESS;
}

/*****************************************************************************
*/
VOID
IrlapCloseLink(PIRDA_LINK_CB pIrdaLinkCb)
{
    IRDA_MSG    IMsg;
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) pIrdaLinkCb->IrlapContext;

    IRLAP_LOG_START((pIrlapCb, TEXT("IRLAP: CloseLink")));

    ReturnRxTxWinMsgs(pIrlapCb);    

    IrlapTimerStop(pIrlapCb, &pIrlapCb->SlotTimer);
    IrlapTimerStop(pIrlapCb, &pIrlapCb->QueryTimer);
    IrlapTimerStop(pIrlapCb, &pIrlapCb->PollTimer);
    IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
    IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
    IrlapTimerStop(pIrlapCb, &pIrlapCb->BackoffTimer);
    
/*
    if (pIrlapCb->MonitorLink)
    {
        IrdaTimerStop(&pIrlapCb->StatusTimer);    
    }    
*/

    IRLAP_LOG_COMPLETE(pIrlapCb);
    
    IMsg.Prim = MAC_CONTROL_REQ;
    IMsg.IRDA_MSG_Op = MAC_CLOSE_LINK;
    IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);    

    return;
}

/*****************************************************************************
*
* Delete memory associated with an Irlap instance
*
*/
VOID
IrlapDeleteInstance(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;
        
#if DBG
    int     i;
    for (i = 0; i < IRLAP_MOD; i++)
    {
        ASSERT(pIrlapCb->TxWin.pMsg[i] == NULL);
        ASSERT(pIrlapCb->RxWin.pMsg[i] == NULL);
    }    
#endif

    FreeDevList(&pIrlapCb->DevList);
    
    DEBUGMSG(DBG_ERROR, (TEXT("IRLAP: Delete instance %X\n"), pIrlapCb));
    
    IRDA_FREE_MEM(pIrlapCb);    
}

/*****************************************************************************
*
* InitializeState - resets link control block
*
*/
VOID
InitializeState(PIRLAP_CB pIrlapCb,
                IRLAP_STN_TYPE StationType)
{
    PAGED_CODE();

    pIrlapCb->StationType = StationType;

    if (StationType == PRIMARY)
        pIrlapCb->CRBit = IRLAP_CMD;
    else
        pIrlapCb->CRBit = IRLAP_RSP;

    pIrlapCb->RemoteBusy        = FALSE;
    pIrlapCb->LocalBusy         = FALSE;
    pIrlapCb->ClrLocalBusy      = FALSE;
    pIrlapCb->NoResponse        = FALSE;
    pIrlapCb->LocalDiscReq      = FALSE;
    pIrlapCb->ConnAfterClose    = FALSE;
    pIrlapCb->DscvAfterClose    = FALSE;
    pIrlapCb->GenNewAddr        = FALSE;
    pIrlapCb->StatusSent        = FALSE;    
    pIrlapCb->Vs                = 0;
    pIrlapCb->Vr                = 0;
    pIrlapCb->WDogExpCnt        = 0;    
    pIrlapCb->StatusFlags       = 0;
    pIrlapCb->FastPollCount     = 0;

    FreeDevList(&pIrlapCb->DevList);

    memset(&pIrlapCb->RemoteQos, 0, sizeof(IRDA_QOS_PARMS));
    memset(&pIrlapCb->NegotiatedQos, 0, sizeof(IRDA_QOS_PARMS));

    // Return msgs on tx list and in tx/rx windows
    ReturnRxTxWinMsgs(pIrlapCb);
}

/*****************************************************************************
*
*  IrlapDown - Entry point into IRLAP for LMP
*
*/
UINT
IrlapDown(PVOID     Context,
          PIRDA_MSG pMsg)
{
    PIRLAP_CB   pIrlapCb    = (PIRLAP_CB) Context;
    UINT        rc          = SUCCESS;

    IRLAP_LOG_START((pIrlapCb, IRDA_PrimStr[pMsg->Prim]));

    switch (pMsg->Prim)
    {
      case IRLAP_DISCOVERY_REQ:
        rc = ProcessDiscoveryReq(pIrlapCb, pMsg);
        break;

      case IRLAP_CONNECT_REQ:
        rc = ProcessConnectReq(pIrlapCb, pMsg);
        break;

      case IRLAP_CONNECT_RESP:
        ProcessConnectResp(pIrlapCb, pMsg);
        break;

      case IRLAP_DISCONNECT_REQ:
        ProcessDisconnectReq(pIrlapCb);
        break;

      case IRLAP_DATA_REQ:
      case IRLAP_UDATA_REQ:
        rc = ProcessDataAndUDataReq(pIrlapCb, pMsg);
        break;

      case IRLAP_FLOWON_REQ:
        if (pIrlapCb->LocalBusy)
        {
            IRLAP_LOG_ACTION((pIrlapCb,TEXT("Local busy condition cleared")));
            pIrlapCb->LocalBusy = FALSE;
            pIrlapCb->ClrLocalBusy = TRUE;
        }
        break;

      case IRLAP_STATUS_REQ:
          StatusReq(pIrlapCb, pMsg);
          break;

      default:
        ASSERT(0);
        rc = IRLAP_BAD_PRIM;

    }

    IRLAP_LOG_COMPLETE(pIrlapCb);

    return rc;
}
/*****************************************************************************
*
*  IrlapUp - Entry point into IRLAP for MAC
*
*/
VOID
IrlapUp(PVOID Context, PIRDA_MSG pMsg)
{
    PIRLAP_CB   pIrlapCb    = (PIRLAP_CB) Context;


    switch (pMsg->Prim)
    {
      case MAC_DATA_IND:
//        IRLAP_LOG_START((pIrlapCb, TEXT("MAC_DATA_IND: %s"), FrameToStr(pMsg)));
        IRLAP_LOG_START((pIrlapCb, TEXT("MAC_DATA_IND")));

        ProcessMACDataInd(pIrlapCb, pMsg);

        break;
        
      case MAC_DATA_CONF:
        
        IRLAP_LOG_START((pIrlapCb, TEXT("IRLAP: MAC_DATA_CONF pMsg:%X"), pMsg));
        
        ASSERT(pMsg->IRDA_MSG_RefCnt == 0);

        pMsg->Prim = IRLAP_DATA_CONF;
        pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_COMPLETED;
            
        IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg);                    
        break;  

      case MAC_CONTROL_CONF:
        IRLAP_LOG_START((pIrlapCb, IRDA_PrimStr[pMsg->Prim]));
        ProcessMACControlConf(pIrlapCb, pMsg);
        break;

      default:
        IRLAP_LOG_START((pIrlapCb, IRDA_PrimStr[pMsg->Prim]));
        ASSERT(0); //rc = IRLAP_BAD_PRIM;

    }

    IRLAP_LOG_COMPLETE(pIrlapCb);
}

/*****************************************************************************
*
*/
VOID
ReturnRxTxWinMsgs(PIRLAP_CB pIrlapCb)
{
    int         i;
    IRDA_MSG   *pMsg;

    PAGED_CODE();
    
    // Return messages on ExTxMsgList and TxMsgList to LMP

    pMsg = (PIRDA_MSG) RemoveHeadList(&pIrlapCb->ExTxMsgList);
               
    while (pMsg != (PIRDA_MSG) &pIrlapCb->ExTxMsgList)
    {
        pMsg->Prim += 2; // make it a confirm
        pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_FAILED_LINK_RESET;
        IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg); 
        pMsg = (PIRDA_MSG) RemoveHeadList(&pIrlapCb->ExTxMsgList);
    }

    pMsg = (PIRDA_MSG) RemoveHeadList(&pIrlapCb->TxMsgList);
               
    while (pMsg != (PIRDA_MSG) &pIrlapCb->TxMsgList)
    {
        pMsg->Prim += 2; // make it a confirm
        pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_FAILED_LINK_RESET;
        IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg); 
        pMsg = (PIRDA_MSG) RemoveHeadList(&pIrlapCb->TxMsgList);
    }

    pIrlapCb->TxWin.Start = 0;
    pIrlapCb->TxWin.End = 0;
    
    // Transmit window
    for (i = 0; i < IRLAP_MOD; i++)
    {
        pMsg = pIrlapCb->TxWin.pMsg[i];
        
        pIrlapCb->TxWin.pMsg[i] = NULL;        
        
        if (pMsg != NULL)
        {
            ASSERT(pMsg->IRDA_MSG_RefCnt);

            if (InterlockedDecrement(&pMsg->IRDA_MSG_RefCnt) == 0)
            {
                pMsg->Prim = IRLAP_DATA_CONF;
                pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_FAILED_LINK_RESET;
                    
                IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg); 
            }
            #if DBG
            else
            {
                DEBUGMSG(DBG_ERROR, (TEXT("IRLAP: Outstanding msg %X, SendCnt is %d at disconnect\n"), 
                     pMsg, pMsg->IRDA_MSG_RefCnt));
            }
            #endif
        }
    }
    
    // Cleanup RxWin
    pIrlapCb->RxWin.Start = 0;
    pIrlapCb->RxWin.End = 0;
    for (i = 0; i < IRLAP_MOD; i++)
    {
        // Receive window
        if ((pMsg = pIrlapCb->RxWin.pMsg[i]) != NULL)
        {
            pMsg->IRDA_MSG_RefCnt = 0;
            pMsg->Prim = MAC_DATA_RESP;
            IrmacDown(pIrlapCb->pIrdaLinkCb, pMsg);
            pIrlapCb->RxWin.pMsg[i] = NULL;
        }
    }

    return;
}

/*****************************************************************************
*
* MyDevAddr - Determines if DevAddr matches the local
*             device address or is the broadcast
*
* TRUE if address is mine or broadcast else FALS
*
*
*/
BOOLEAN
MyDevAddr(PIRLAP_CB pIrlapCb,
          UCHAR       DevAddr[])
{
    if (CTEMemCmp(DevAddr, IrlapBroadcastDevAddr,
                  IRDA_DEV_ADDR_LEN) &&
        CTEMemCmp(DevAddr, pIrlapCb->LocalDevice.DevAddr,
                  IRDA_DEV_ADDR_LEN))
    {
        return FALSE;
    }
    return TRUE;
}

/*****************************************************************************
*
*    ProcessConnectReq - Process connect request from LMP
*
*/
UINT
ProcessConnectReq(PIRLAP_CB pIrlapCb,
                  PIRDA_MSG pMsg)
{
    IRDA_MSG IMsg;
    
    PAGED_CODE();

    DEBUGMSG(DBG_IRLAP, (TEXT("IRLAP: ProcessConnectReq: state=%d\n"),pIrlapCb->State));

    switch (pIrlapCb->State)
    {
      case NDM:
        // Save Remote Address for later use
        CTEMemCopy(pIrlapCb->RemoteDevice.DevAddr,
                      pMsg->IRDA_MSG_RemoteDevAddr,
                      IRDA_DEV_ADDR_LEN);

        IMsg.Prim = MAC_CONTROL_REQ;
        IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
        IMsg.IRDA_MSG_SenseTime = IRLAP_MEDIA_SENSE_TIME;
        
        IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
        pIrlapCb->State = CONN_MEDIA_SENSE;
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_CONTROL_REQ (media sense)")));
        break;

      case DSCV_REPLY:
        return IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR;

      case P_CLOSE:
        CTEMemCopy(pIrlapCb->RemoteDevice.DevAddr,
                       pMsg->IRDA_MSG_RemoteDevAddr, IRDA_DEV_ADDR_LEN);
        pIrlapCb->ConnAfterClose = TRUE;
        break;

      case CONN_MEDIA_SENSE:

        IRLAP_LOG_ACTION((pIrlapCb, TEXT("already doing media sense")));

        ASSERT(0);
        return IRLAP_BAD_STATE;
        break;
        
      default:
        ASSERT(0);
        return IRLAP_BAD_STATE;
    }

    return SUCCESS;
}
/*****************************************************************************
*
*   ProcessConnectResp - Process connect response from LMP
*
*/
VOID
ProcessConnectResp(PIRLAP_CB pIrlapCb,
                   PIRDA_MSG pMsg)
{
    PAGED_CODE();

    DEBUGMSG(DBG_IRLAP, (TEXT("IRLAP: ProcessConnectResp: state=%d\n"),pIrlapCb->State));

    if (pIrlapCb->State != SNRM_RECEIVED)
    {
        ASSERT(0);
        return;
    }

    pIrlapCb->ConnAddr = pIrlapCb->SNRMConnAddr;
    SendUA(pIrlapCb, TRUE);
    ApplyQosParms(pIrlapCb);

    InitializeState(pIrlapCb, SECONDARY);
    // start watchdog timer with poll timeout
    IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
    pIrlapCb->State = S_NRM;
}
/*****************************************************************************
*
*   ProcessDiscoveryReq - Process Discovery request from LMP
*
*/
UINT
ProcessDiscoveryReq(PIRLAP_CB pIrlapCb,
                    PIRDA_MSG pMsg)
{
    IRDA_MSG    IMsg;
    
    PAGED_CODE();

    DEBUGMSG(DBG_IRLAP, (TEXT("IRLAP: ProcessDiscoveryReq: state=%d\n"),pIrlapCb->State));

    switch (pIrlapCb->State)
    {
      case NDM:
        if (pMsg->IRDA_MSG_SenseMedia == TRUE)
        {
            IMsg.Prim = MAC_CONTROL_REQ;
            IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
            IMsg.IRDA_MSG_SenseTime = IRLAP_MEDIA_SENSE_TIME;            
            IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
            pIrlapCb->State = DSCV_MEDIA_SENSE;
            IRLAP_LOG_ACTION((pIrlapCb,TEXT("MAC_CONTROL_REQ (mediasense)")));
        }
        else
        {
            pIrlapCb->SlotCnt = 0;
            pIrlapCb->GenNewAddr = FALSE;

            FreeDevList(&pIrlapCb->DevList);

            SendDscvXIDCmd(pIrlapCb);

            IMsg.Prim = MAC_CONTROL_REQ;
            IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
            IMsg.IRDA_MSG_SenseTime = IRLAP_DSCV_SENSE_TIME;
            IRLAP_LOG_ACTION((pIrlapCb,TEXT("MAC_CONTROL_REQ (dscvsense)")));
            IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);

            pIrlapCb->State = DSCV_QUERY;
        }
        break;

      case DSCV_REPLY:
        return IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR;

      case SNRM_RECEIVED:
        return IRLAP_REMOTE_CONNECTION_IN_PROGRESS_ERR;

      case P_CLOSE:
        pIrlapCb->DscvAfterClose = TRUE;
        break;
        
      default:
        ASSERT(0);
        return IRLAP_BAD_STATE;
    }
    return SUCCESS;
}
/*****************************************************************************
*
*   ProcessDisconnectReq - Process disconnect request from LMP
*
*/
VOID
ProcessDisconnectReq(PIRLAP_CB pIrlapCb)
{
    ReturnRxTxWinMsgs(pIrlapCb);

    DEBUGMSG(DBG_IRLAP, (TEXT("IRLAP: ProcessDisconnectReq: state=%d\n"),pIrlapCb->State));

    switch (pIrlapCb->State)
    {
      case NDM:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        break;

      case SNRM_SENT:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->State = NDM;
        break;

      case DSCV_REPLY:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->QueryTimer);      
        pIrlapCb->State = NDM;
        break;
              
      case DSCV_MEDIA_SENSE:
      case DSCV_QUERY:
      case CONN_MEDIA_SENSE:
        pIrlapCb->State = NDM;
        break;

      case BACKOFF_WAIT:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->BackoffTimer);
        pIrlapCb->State = NDM;
        break;

      case SNRM_RECEIVED:
        pIrlapCb->ConnAddr = pIrlapCb->SNRMConnAddr;
        SendDM(pIrlapCb);
        pIrlapCb->ConnAddr = IRLAP_BROADCAST_CONN_ADDR;
        pIrlapCb->State = NDM;
        break;

      case P_XMIT:
        pIrlapCb->LocalDiscReq = TRUE;
        IrlapTimerStop(pIrlapCb, &pIrlapCb->PollTimer);
        SendDISC(pIrlapCb);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->RetryCnt = 0;
        pIrlapCb->State = P_CLOSE;
        break;

      case P_RECV:
        pIrlapCb->LocalDiscReq = TRUE;
        pIrlapCb->State = P_DISCONNECT_PEND;
        break;

      case S_NRM:
        pIrlapCb->LocalDiscReq = TRUE;
        pIrlapCb->State = S_DISCONNECT_PEND;
        break;

      default:
        ASSERT(0);
        // return IRLAP_BAD_STATE;
    }
}
/*****************************************************************************
*
*   ProcessDataReq - Process data request from LMP
*
*/
UINT
ProcessDataAndUDataReq(PIRLAP_CB pIrlapCb,
                       PIRDA_MSG pMsg)
{
    BOOLEAN LinkTurned;
    LONG_PTR  DataSize = (pMsg->IRDA_MSG_pHdrWrite - pMsg->IRDA_MSG_pHdrRead) +
                    (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead);

    DEBUGMSG(DBG_IRLAP, (TEXT("IRLAP: ProcessDataAndUDataReq: state=%d\n"),pIrlapCb->State));

    if (DataSize > pIrlapCb->RemoteDataSize)
    {
        return IRLAP_BAD_DATA_REQUEST;
    }

    switch (pIrlapCb->State)
    {
      case P_XMIT:
        // Enque message, then drain the message list. If the link
        // was turned in the process of draining messages stop Poll Timer,
        // start Final Timer and enter P_RECV. Otherwise we'll stay in P_XMIT
        // waiting for more data requests from LMP or Poll Timer expiration
        if (pMsg->IRDA_MSG_Expedited)
        {
            InsertTailList(&pIrlapCb->ExTxMsgList, &pMsg->Linkage);
        }
        else
        {
            InsertTailList(&pIrlapCb->TxMsgList, &pMsg->Linkage);
        }

        XmitTxMsgList(pIrlapCb, FALSE, &LinkTurned);

        if (LinkTurned)
        {
           IrlapTimerStop(pIrlapCb, &pIrlapCb->PollTimer);
           IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
           pIrlapCb->State = P_RECV;
        }
        return SUCCESS;

      case P_DISCONNECT_PEND: //For pending disc states, take the message.
      case S_DISCONNECT_PEND: // They will be returned when the link discs
      case P_RECV:
      case S_NRM:
        // Que the message for later transmission

        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Queueing request")));

        if (pMsg->IRDA_MSG_Expedited)
        {
            InsertTailList(&pIrlapCb->ExTxMsgList, &pMsg->Linkage);
        }
        else
        {
            InsertTailList(&pIrlapCb->TxMsgList, &pMsg->Linkage);
        }

        return SUCCESS;

      default:
        if (pMsg->Prim == IRLAP_DATA_REQ)
        {
            ASSERT(0);
            return IRLAP_BAD_STATE;
        }
        else
        {
            if (pIrlapCb->State == NDM)
            {
                SendUIFrame(pIrlapCb, pMsg);
            }
            else
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
            }
        }
    }
    return SUCCESS;
}
/*****************************************************************************
*
*/
VOID
XmitTxMsgList(PIRLAP_CB pIrlapCb, BOOLEAN AlwaysTurnLink,
              BOOLEAN *pLinkTurned)
{
    IRDA_MSG    *pMsg;
    BOOLEAN     LinkTurned;

    LinkTurned = FALSE;

    // If the remote is not busy send data
    // If we need to clear the local busy condition, don't send data send RR
    if (!pIrlapCb->RemoteBusy && !pIrlapCb->ClrLocalBusy)
    {
        while (!LinkTurned)
        {
            if (!IsListEmpty(&pIrlapCb->ExTxMsgList))
            {
                pMsg = (PIRDA_MSG) RemoveHeadList(&pIrlapCb->ExTxMsgList);
            }
            else if (!IsListEmpty(&pIrlapCb->TxMsgList))
            {
                pMsg = (PIRDA_MSG) RemoveHeadList(&pIrlapCb->TxMsgList);
            }
            else
            {
                break;
            }

            pIrlapCb->FastPollCount = IRLAP_FAST_POLL_COUNT;
            pIrlapCb->PollTimer.Timeout = IRLAP_FAST_POLL_TIME > 
                pIrlapCb->RemoteMaxTAT ? pIrlapCb->RemoteMaxTAT : IRLAP_FAST_POLL_TIME;
            
            if (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead)
                pIrlapCb->StatusFlags |= LF_TX;
            
            if (pMsg->Prim == IRLAP_DATA_REQ)
            {
                // Insert message into transmit window
                pIrlapCb->TxWin.pMsg[pIrlapCb->Vs] = pMsg;
                
                pMsg->IRDA_MSG_RefCnt = 1;

                // Send message. If full window or there are no
                // more data requests, send with PF Set (turns link).
                if ((pIrlapCb->Vs == (pIrlapCb->TxWin.Start +
                      pIrlapCb->RemoteWinSize-1) % IRLAP_MOD) ||
                      (IsListEmpty(&pIrlapCb->TxMsgList) &&
                       IsListEmpty(&pIrlapCb->ExTxMsgList)))
                {
                    SendIFrame(pIrlapCb,
                               pMsg,
                               pIrlapCb->Vs,
                               IRLAP_PFBIT_SET);
                    LinkTurned = TRUE;
                }
                else
                {
                    SendIFrame(pIrlapCb,
                               pMsg,
                               pIrlapCb->Vs,
                               IRLAP_PFBIT_CLEAR);
                }
                pIrlapCb->Vs = (pIrlapCb->Vs + 1) % IRLAP_MOD;
            }
            else // IRLAP_UDATA_REQUEST
            {
                // For now, always turn link
                SendUIFrame(pIrlapCb, pMsg);
                pMsg->Prim = IRLAP_UDATA_CONF;
                pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_COMPLETED;
                IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg);
                LinkTurned = TRUE;
            }
        }
        pIrlapCb->TxWin.End = pIrlapCb->Vs;
    }

    if ((AlwaysTurnLink && !LinkTurned) || pIrlapCb->ClrLocalBusy)
    {
        SendRR_RNR(pIrlapCb);
        LinkTurned = TRUE;
        if (pIrlapCb->ClrLocalBusy)
        {
            pIrlapCb->ClrLocalBusy = FALSE;
        }
    }

    if (pLinkTurned != NULL)
    {
        *pLinkTurned = LinkTurned;
    }
}

VOID
GotoPCloseState(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG IMsg;
    
    PAGED_CODE();
    
    if (!pIrlapCb->LocalDiscReq)
    {
        IMsg.Prim = IRLAP_DISCONNECT_IND;
        IMsg.IRDA_MSG_DiscStatus = IRLAP_REMOTE_INITIATED;
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
    }
    
    ReturnRxTxWinMsgs(pIrlapCb);    

    pIrlapCb->State = P_CLOSE;
}

VOID
GotoNDMThenDscvOrConn(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG IMsg;
    
    PAGED_CODE();
    
    if (pIrlapCb->ConnAfterClose)
    {
        pIrlapCb->ConnAfterClose = FALSE;
        IMsg.Prim = MAC_CONTROL_REQ;
        IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
        IMsg.IRDA_MSG_SenseTime = IRLAP_MEDIA_SENSE_TIME;
        
        IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
        pIrlapCb->State = CONN_MEDIA_SENSE;
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_CONTROL_REQ (conn media sense)")));
        return;
    }

    if (pIrlapCb->DscvAfterClose)
    {
        pIrlapCb->DscvAfterClose = FALSE;
        IMsg.Prim = MAC_CONTROL_REQ;
        IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
        IMsg.IRDA_MSG_SenseTime = IRLAP_MEDIA_SENSE_TIME;        
        IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
        pIrlapCb->State = DSCV_MEDIA_SENSE;
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_CONTROL_REQ (disc media sense)")));
        return;
    }
    pIrlapCb->State = NDM;
    return;
}

/*****************************************************************************
*
*   ProcessMACControlConf - Process a control confirm from MAC
*
*/
VOID
ProcessMACControlConf(PIRLAP_CB pIrlapCb, PIRDA_MSG pMsg)
{
    IRDA_MSG    IMsg;
    
    PAGED_CODE();
    
    if (pMsg->IRDA_MSG_Op != MAC_MEDIA_SENSE)
    {
        ASSERT(0);
        return; //IRLAP_BAD_OP;
    }

    switch (pIrlapCb->State)
    {
      case DSCV_MEDIA_SENSE:
        switch (pMsg->IRDA_MSG_OpStatus)
        {
          case MAC_MEDIA_CLEAR:
          
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_MEDIA_CLEAR")));
            
            //IndicateLinkStatus(pIrlapCb, LINK_STATUS_DISCOVERING);
            
            
            pIrlapCb->SlotCnt = 0;
            pIrlapCb->GenNewAddr = FALSE;

            FreeDevList(&pIrlapCb->DevList);

            SendDscvXIDCmd(pIrlapCb);

            IMsg.Prim = MAC_CONTROL_REQ;
            IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
            IMsg.IRDA_MSG_SenseTime = IRLAP_DSCV_SENSE_TIME;
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_CONTROL_REQ (dscvsense)")));
            IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
            pIrlapCb->State = DSCV_QUERY;
            break;

          case MAC_MEDIA_BUSY:
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_MEDIA_BUSY")));          
            pIrlapCb->State = NDM;          
            IMsg.Prim = IRLAP_DISCOVERY_CONF;
            IMsg.IRDA_MSG_pDevList = NULL;
            IMsg.IRDA_MSG_DscvStatus = MAC_MEDIA_BUSY;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            break;

          default:
            ASSERT(0);
            return;// IRLAP_BAD_OPSTATUS;
        }
        break;

      case CONN_MEDIA_SENSE:
        switch (pMsg->IRDA_MSG_OpStatus)
        {
          case MAC_MEDIA_CLEAR:

            // Generate a random connection address
            pIrlapCb->ConnAddr = IRLAP_RAND(1, 0x7e);

            pIrlapCb->RetryCnt = 0;

            SendSNRM(pIrlapCb, TRUE);
            IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
            pIrlapCb->State = SNRM_SENT;
            break;

          case MAC_MEDIA_BUSY:
            pIrlapCb->State = NDM;          
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = MAC_MEDIA_BUSY;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            break;

          default:
            ASSERT(0);
            return;// IRLAP_BAD_OPSTATUS;
        }
        break;

      case DSCV_QUERY:
        switch (pMsg->IRDA_MSG_OpStatus)
        {
          case MAC_MEDIA_CLEAR:
            // Nobody responded, procede as if the slot timer expired

            IRLAP_LOG_ACTION((pIrlapCb,
                              TEXT("Media clear, making fake slot exp")));
              
            SlotTimerExp(pIrlapCb);
            break;

          case MAC_MEDIA_BUSY:
            // Some responding, give'm more time

            IRLAP_LOG_ACTION((pIrlapCb,
                              TEXT("Media busy, starting slot timer")));
            
            IrlapTimerStart(pIrlapCb, &pIrlapCb->SlotTimer);
            break;
        }
        break;
      
      default:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
    }
}
/*****************************************************************************
*
*   ProcessMACDataInd - Processes MAC Data
*
*
*/
VOID
ProcessMACDataInd(PIRLAP_CB pIrlapCb, PIRDA_MSG pMsg)
{
    UCHAR Addr        = IRLAP_GET_ADDR(*(pMsg->IRDA_MSG_pRead));
    UCHAR CRBit       = IRLAP_GET_CRBIT(*(pMsg->IRDA_MSG_pRead));
    UCHAR Cntl        = *(pMsg->IRDA_MSG_pRead + 1);
    UCHAR PFBit       = IRLAP_GET_PFBIT(Cntl);
    UCHAR FrameType   = IRLAP_FRAME_TYPE(Cntl);
    UINT Ns           = IRLAP_GET_NS(Cntl);
    UINT Nr           = IRLAP_GET_NR(Cntl);
    UCHAR XIDFormatID     = *(pMsg->IRDA_MSG_pRead+2);
    IRLAP_XID_DSCV_FORMAT *pXIDFormat  = (IRLAP_XID_DSCV_FORMAT *)
                                          (pMsg->IRDA_MSG_pRead + 3);
    IRLAP_SNRM_FORMAT     *pSNRMFormat = (IRLAP_SNRM_FORMAT *)
                                          (pMsg->IRDA_MSG_pRead + 2);
    IRLAP_UA_FORMAT       *pUAFormat   = (IRLAP_UA_FORMAT *)
                                          (pMsg->IRDA_MSG_pRead + 2);
                                          
    if (Addr != pIrlapCb->ConnAddr && Addr != IRLAP_BROADCAST_CONN_ADDR)
    {
        IRLAP_LOG_ACTION((pIrlapCb,
                          TEXT("Ignoring, connection address %02X"), Addr));
        return;
    }

    pIrlapCb->StatusSent = FALSE; 

    pIrlapCb->Frmr.CntlField = Cntl; // for later maybe

    // Peer has sent a frame so clear the NoResponse condition
    // Unnumbered frame shouldn't reset the no response condition
    // (ie only frames received in the connected state).
    if (pIrlapCb->NoResponse && FrameType != IRLAP_U_FRAME)
    {
        pIrlapCb->NoResponse = FALSE;
        pIrlapCb->RetryCnt = 0;
        pIrlapCb->WDogExpCnt = 0;
        
        pIrlapCb->StatusFlags = LF_CONNECTED;
        IndicateLinkStatus(pIrlapCb);
    }

    switch (FrameType)
    {
      /*****************/
      case IRLAP_I_FRAME:
      /*****************/
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: I-frame)")));
        ProcessIFrame(pIrlapCb, pMsg, CRBit, PFBit, Ns, Nr);
        return;

      /*****************/
      case IRLAP_S_FRAME:
      /*****************/
        switch (IRLAP_GET_SCNTL(Cntl))
        {
          /*-----------*/
          case IRLAP_RR:
          case IRLAP_RNR:
          /*-----------*/
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(RR/RNR-frame)")));
            ProcessRR_RNR(pIrlapCb, IRLAP_GET_SCNTL(Cntl),
                          pMsg, CRBit, PFBit, Nr);
            return;
            
          /*------------*/
          case IRLAP_SREJ:
          case IRLAP_REJ:
          /*------------*/
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(SJREJ/REJ-frame)")));
            ProcessREJ_SREJ(pIrlapCb, IRLAP_GET_SCNTL(Cntl),
                            pMsg, CRBit, PFBit, Nr);
            return;
        }
        break;

      /*****************/
      case IRLAP_U_FRAME:
      /*****************/
        switch (IRLAP_GET_UCNTL(Cntl))
        {
          /*---------------*/
          case IRLAP_XID_CMD:
          /*---------------*/
            // Should always be a command
            if (CRBit != IRLAP_CMD)
            {
                IRLAP_LOG_ACTION((pIrlapCb,
                                  TEXT("Received XID cmd with CRBit = rsp")));
                ASSERT(0);
                return; // IRLAP_XID_CMD_RSP;
            }
            // Poll bit should always be set
            if (PFBit != IRLAP_PFBIT_SET)
            {
                IRLAP_LOG_ACTION((pIrlapCb, 
                   TEXT("Received XID command without Poll set")));
                ASSERT(0);
                return; // IRLAP_XID_CMD_NOT_P;
            }

            if (XIDFormatID == IRLAP_XID_DSCV_FORMAT_ID)
            {
                // Slot No is less than max slot or 0xff
                if (pXIDFormat->SlotNo > IrlapSlotTable[pXIDFormat->NoOfSlots]
                    && pXIDFormat->SlotNo != IRLAP_END_DSCV_SLOT_NO)
                {
                    IRLAP_LOG_ACTION((pIrlapCb,
                                      TEXT("Invalid slot number %d"),
                                      pXIDFormat->SlotNo));
                    ASSERT(0);
                    return;// IRLAP_BAD_SLOTNO;
                }
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: DscvXidCmd slot=%d)"),pXIDFormat->SlotNo));
                ProcessDscvXIDCmd(pIrlapCb, pXIDFormat,
                                  pMsg->IRDA_MSG_pWrite);
                return;
            }
            else
            {
                return; // ignore per errata
            }

          /*---------------*/
          case IRLAP_XID_RSP:
          /*---------------*/
            if (XIDFormatID == IRLAP_XID_DSCV_FORMAT_ID)
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: DscvXidRsp)")));
                ProcessDscvXIDRsp(pIrlapCb, pXIDFormat,pMsg->IRDA_MSG_pWrite);
                return;
            }
            else
            {
                return; // ignore per errata
            }

          /*------------*/
          case IRLAP_SNRM: // or IRLAP_RNRM
          /*------------*/
            if (IRLAP_PFBIT_SET != PFBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb,
                                  TEXT("Received SNRM/RNRM without P set")));
                return;// IRLAP_SNRM_NOT_P;
            }
            if (IRLAP_CMD == CRBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: SNRM)")));
                ProcessSNRM(pIrlapCb, pSNRMFormat, pMsg->IRDA_MSG_pWrite);
                return;
            }
            else
            {
                ProcessRNRM(pIrlapCb);
                return;
            }

          /*----------*/
          case IRLAP_UA:
          /*----------*/
            if (CRBit != IRLAP_RSP)
            {
                IRLAP_LOG_ACTION((pIrlapCb,
                                  TEXT("Received UA as a command")));
                return;// IRLAP_UA_NOT_RSP;
            }
            if (PFBit != IRLAP_PFBIT_SET)
            {
                IRLAP_LOG_ACTION((pIrlapCb,
                                  TEXT("Received UA without F set")));
                return;// IRLAP_UA_NOT_F;
            }
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: UA)")));
            ProcessUA(pIrlapCb, pUAFormat, pMsg->IRDA_MSG_pWrite);
            return;

          /*------------*/
          case IRLAP_DISC: // or IRLAP_RD
          /*------------*/
            if (IRLAP_PFBIT_SET != PFBit)
            {
              IRLAP_LOG_ACTION((pIrlapCb, 
                   TEXT("Received DISC/RD command without Poll set")));
              return;// IRLAP_DISC_CMD_NOT_P;
            }
            if (IRLAP_CMD == CRBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: DISC)")));
                ProcessDISC(pIrlapCb);
                return;
            }
            else
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: RD)")));
                ProcessRD(pIrlapCb);
                return;
            }

          /*----------*/
          case IRLAP_UI:
          /*----------*/
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: UI)")));
            ProcessUI(pIrlapCb, pMsg, CRBit, PFBit);
            return;

          /*------------*/
          case IRLAP_TEST:
          /*------------*/
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: TEST)")));
//            ProcessTEST(pIrlapCb, pMsg, pUAFormat, CRBit, PFBit);
            return;

          /*------------*/
          case IRLAP_FRMR:
          /*------------*/
            if (IRLAP_RSP != CRBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb,
                                  TEXT("Received FRMR cmd (must be resp)")));
                return;// IRLAP_FRMR_RSP_CMD;
            }
            if (IRLAP_PFBIT_SET != PFBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb, 
                     TEXT("Received FRMR resp without Final set")));
                return;// IRLAP_FRMR_RSP_NOT_F;
            }
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: FRMR)")));
            ProcessFRMR(pIrlapCb);
            return;

          /*----------*/
          case IRLAP_DM:
          /*----------*/
            if (IRLAP_RSP != CRBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb, 
                     TEXT("Received DM command (must be response)")));
                return;// IRLAP_DM_RSP_CMD;
            }
            if (IRLAP_PFBIT_SET != PFBit)
            {
                IRLAP_LOG_ACTION((pIrlapCb, 
                      TEXT("Received DM response without Final set")));
                return;// IRLAP_DM_RSP_NOT_F;
            }
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("(Rx: DM)")));
            ProcessDM(pIrlapCb);
            return;
        }
        break;
    }
}
/*****************************************************************************
*
*  ProcessDscvXIDCmd - Process received XID Discovery command
*
*/
VOID
ProcessDscvXIDCmd(PIRLAP_CB pIrlapCb,
                  IRLAP_XID_DSCV_FORMAT *pXidFormat,
                  UCHAR *pEndDscvInfoUCHAR)
{
    IRDA_MSG    IMsg;
    
    if (!MyDevAddr(pIrlapCb, pXidFormat->DestAddr))
    {
/*        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring XID addressed to:%02X%02X%02X%02X"),
                          EXPAND_ADDR(pXidFormat->DestAddr)));*/
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring XID addressed to %X"),
                          pXidFormat->DestAddr));        
        return;
    }

    if (pXidFormat->SlotNo == IRLAP_END_DSCV_SLOT_NO)
    {
        pIrlapCb->GenNewAddr = FALSE;
        switch (pIrlapCb->State)
        {
          case DSCV_QUERY:
            IrlapTimerStop(pIrlapCb, &pIrlapCb->SlotTimer);

            IMsg.Prim = IRLAP_DISCOVERY_CONF;
            IMsg.IRDA_MSG_pDevList = NULL;
            IMsg.IRDA_MSG_DscvStatus =
                IRLAP_REMOTE_DISCOVERY_IN_PROGRESS;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            // fall through. Send indication to LMP

          case DSCV_REPLY:
            if (pIrlapCb->State == DSCV_REPLY)
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->QueryTimer);
            }

            // Place the device information in the control block
            ExtractDeviceInfo(&pIrlapCb->RemoteDevice, pXidFormat,
                              pEndDscvInfoUCHAR);

            if (!DevInDevList(pXidFormat->SrcAddr, &pIrlapCb->DevList))
            {
                AddDevToList(pIrlapCb, pXidFormat, pEndDscvInfoUCHAR);
            }

            // Notifiy LMP
            pIrlapCb->State = NDM;
                        
            IMsg.Prim = IRLAP_DISCOVERY_IND;
            IMsg.IRDA_MSG_pDevList = &pIrlapCb->DevList;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            break;

          default:
            IRLAP_LOG_ACTION((pIrlapCb,
                              TEXT("Ignoring End XID in this state")));
        }
    }
    else // in middle of discovery process
    {
        switch (pIrlapCb->State)
        {
          case DSCV_MEDIA_SENSE:
            IMsg.Prim = IRLAP_DISCOVERY_CONF;
            IMsg.IRDA_MSG_pDevList = NULL;
            IMsg.IRDA_MSG_DscvStatus =
                IRLAP_REMOTE_DISCOVERY_IN_PROGRESS;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            // fall through

          case NDM:
            InitDscvCmdProcessing(pIrlapCb, pXidFormat);
            pIrlapCb->State = DSCV_REPLY;
            break;

          case DSCV_QUERY:
            pIrlapCb->State = NDM;          
            IMsg.Prim = IRLAP_DISCOVERY_CONF;
            IMsg.IRDA_MSG_pDevList = NULL;
            IMsg.IRDA_MSG_DscvStatus = IRLAP_DISCOVERY_COLLISION;
            IrlapTimerStop(pIrlapCb, &pIrlapCb->SlotTimer);
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            break;

          case DSCV_REPLY:
            if (pXidFormat->GenNewAddr)
            {
                pIrlapCb->GenNewAddr = TRUE;
                IrlapTimerStop(pIrlapCb, &pIrlapCb->QueryTimer);
                InitDscvCmdProcessing(pIrlapCb, pXidFormat);
            }
            else
            {
                if (pIrlapCb->RespSlot <= pXidFormat->SlotNo &&
                    !pIrlapCb->DscvRespSent)
                {
                    SendDscvXIDRsp(pIrlapCb);
                    pIrlapCb->DscvRespSent = TRUE;
                }
            }
            break;

          default:
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        }
    }
    return;
}
/*****************************************************************************
*
*
*/
void
ExtractDeviceInfo(IRDA_DEVICE *pDevice, IRLAP_XID_DSCV_FORMAT *pXidFormat,
                  UCHAR *pEndDscvInfoUCHAR)
{
    PAGED_CODE();
    
    CTEMemCopy(pDevice->DevAddr, pXidFormat->SrcAddr, IRDA_DEV_ADDR_LEN);
    pDevice->IRLAP_Version = pXidFormat->Version;

    // ??? what about DscvMethod

    pDevice->DscvInfoLen =
        pEndDscvInfoUCHAR > &pXidFormat->FirstDscvInfoByte ?
        (int) (pEndDscvInfoUCHAR-&pXidFormat->FirstDscvInfoByte) : 0;
    
    if (pDevice->DscvInfoLen > IRLAP_DSCV_INFO_LEN)
    {
        pDevice->DscvInfoLen = IRLAP_DSCV_INFO_LEN;
    }

    CTEMemCopy(pDevice->DscvInfo, &pXidFormat->FirstDscvInfoByte,
           pDevice->DscvInfoLen);
}
/*****************************************************************************
*
*
*/
VOID
InitDscvCmdProcessing(PIRLAP_CB pIrlapCb,
                      IRLAP_XID_DSCV_FORMAT *pXidFormat)
{
    pIrlapCb->RemoteMaxSlot = IrlapSlotTable[pXidFormat->NoOfSlots];

    pIrlapCb->RespSlot = IRLAP_RAND(pXidFormat->SlotNo,
                                   pIrlapCb->RemoteMaxSlot - 1);

    CTEMemCopy(pIrlapCb->RemoteDevice.DevAddr, pXidFormat->SrcAddr,
                  IRDA_DEV_ADDR_LEN);

    IRLAP_LOG_ACTION((pIrlapCb,
                      TEXT("Responding in slot %d to dev %02X%02X%02X%02X"),
                      pIrlapCb->RespSlot,
                      pIrlapCb->RemoteDevice.DevAddr[0],
                      pIrlapCb->RemoteDevice.DevAddr[1],
                      pIrlapCb->RemoteDevice.DevAddr[2],
                      pIrlapCb->RemoteDevice.DevAddr[3]));

    if (pIrlapCb->RespSlot == pXidFormat->SlotNo)
    {
        SendDscvXIDRsp(pIrlapCb);
        pIrlapCb->DscvRespSent = TRUE;
    }
    else
    {
        pIrlapCb->DscvRespSent = FALSE;
    }

    IrlapTimerStart(pIrlapCb, &pIrlapCb->QueryTimer);
}
/*****************************************************************************
*
*/
VOID
ProcessDscvXIDRsp(PIRLAP_CB pIrlapCb,
                  IRLAP_XID_DSCV_FORMAT *pXidFormat,
                  UCHAR *pEndDscvInfoUCHAR)
{
    IRDA_MSG    IMsg;
    
    if (pIrlapCb->State == DSCV_QUERY)
    {

        if (DevInDevList(pXidFormat->SrcAddr, &pIrlapCb->DevList))
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->SlotTimer);
            pIrlapCb->SlotCnt = 0;
            pIrlapCb->GenNewAddr = TRUE;
            FreeDevList(&pIrlapCb->DevList);
            SendDscvXIDCmd(pIrlapCb);

            IMsg.Prim = MAC_CONTROL_REQ;
            IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
            IMsg.IRDA_MSG_SenseTime = IRLAP_DSCV_SENSE_TIME;
            IRLAP_LOG_ACTION((pIrlapCb,
                              TEXT("MAC_CONTROL_REQ (dscv sense)")));
            IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);            
        }
        else
        {
            AddDevToList(pIrlapCb, pXidFormat, pEndDscvInfoUCHAR);
        }
    }
    else
    {
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
    }
}
/*****************************************************************************
*
*   DevInDevList - Determines if given device is already in list
*
*/
BOOLEAN
DevInDevList(UCHAR DevAddr[], LIST_ENTRY *pDevList)
{
    IRDA_DEVICE *pDevice;

    pDevice = (IRDA_DEVICE *) pDevList->Flink;

    while (pDevList != (LIST_ENTRY *) pDevice)
    {
        if (CTEMemCmp(pDevice->DevAddr, DevAddr,
                      IRDA_DEV_ADDR_LEN) == 0)
            return (TRUE);

        pDevice = (IRDA_DEVICE *) pDevice->Linkage.Flink;
    }
    return (FALSE);
}
/*****************************************************************************
*
*   AddDevToList - Adds elements in a device list
*
*/
VOID
AddDevToList(PIRLAP_CB pIrlapCb,
             IRLAP_XID_DSCV_FORMAT *pXidFormat,
             UCHAR *pEndDscvInfoUCHAR)
{
    IRDA_DEVICE *pDevice;

    if (IRDA_ALLOC_MEM(pDevice, sizeof(IRDA_DEVICE), MT_IRLAP_DEVICE) == NULL)
    {
        ASSERT(0);
        
        return;// (IRLAP_MALLOC_FAILED);
    }
    else
    {
        ExtractDeviceInfo(pDevice, pXidFormat, pEndDscvInfoUCHAR);

        InsertTailList(&pIrlapCb->DevList, &(pDevice->Linkage));

        IRLAP_LOG_ACTION((pIrlapCb,
                          TEXT("%02X%02X%02X%02X added to Device List"),
                          EXPAND_ADDR(pDevice->DevAddr)));
    }
}
/*****************************************************************************
*
*/
void
FreeDevList(LIST_ENTRY *pDevList)
{
    IRDA_DEVICE *pDevice;
    
    PAGED_CODE();

    while (IsListEmpty(pDevList) == FALSE)
    {
        pDevice = (IRDA_DEVICE *) RemoveHeadList(pDevList);
        IRDA_FREE_MEM(pDevice);
    }

    //IRLAP_LOG_ACTION((pIrlapCb, TEXT("Device list cleared")));
}

/*****************************************************************************
*
*/
int
AddressGreaterThan(UCHAR A1[], UCHAR A2[])
{
    int i;
    
    for (i = 0; i < IRDA_DEV_ADDR_LEN; i++)
    {
        if (A1[i] > A2[i])
            return TRUE;
        if (A1[i] != A2[1])
            return FALSE;
    }
    return FALSE;
}
/*****************************************************************************
*
*/
VOID
ProcessSNRM(PIRLAP_CB pIrlapCb,
            IRLAP_SNRM_FORMAT *pSnrmFormat,
            UCHAR *pEndQosUCHAR)
{
    IRDA_MSG    IMsg;
    BOOLEAN     QosInSNRM = &pSnrmFormat->FirstQosByte < pEndQosUCHAR;
    BOOLEAN     AddrsInSNRM = (UCHAR *)pSnrmFormat < pEndQosUCHAR;
    UINT        rc;
    
    PAGED_CODE();

    if (AddrsInSNRM)
    {
        if (!MyDevAddr(pIrlapCb, pSnrmFormat->DestAddr))
        {
            IRLAP_LOG_ACTION((pIrlapCb, 
                       TEXT("Ignoring SNRM addressed to:%02X%02X%02X%02X"),
                              EXPAND_ADDR(pSnrmFormat->DestAddr)));
            return;
        }
        CTEMemCopy(pIrlapCb->RemoteDevice.DevAddr,
                  pSnrmFormat->SrcAddr, IRDA_DEV_ADDR_LEN);
    }

    switch (pIrlapCb->State)
    {
      case DSCV_MEDIA_SENSE:
      case DSCV_QUERY:
        // In the middle of discovery... End discovery and reply to SNRM
        IMsg.Prim = IRLAP_DISCOVERY_CONF;
        IMsg.IRDA_MSG_pDevList = NULL;
        IMsg.IRDA_MSG_DscvStatus = IRLAP_REMOTE_CONNECTION_IN_PROGRESS;
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        // fall through and send connect indication
      case DSCV_REPLY:
      case NDM:
        if (pIrlapCb->State == DSCV_REPLY)
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->QueryTimer);
        }
        
        if (AddrsInSNRM)
        {
            pIrlapCb->SNRMConnAddr =
                (int)IRLAP_GET_ADDR(pSnrmFormat->ConnAddr);
        }
        if (QosInSNRM)
        {
            ExtractQosParms(&pIrlapCb->RemoteQos, &pSnrmFormat->FirstQosByte,
                        pEndQosUCHAR);

            if ((rc = NegotiateQosParms(pIrlapCb, &pIrlapCb->RemoteQos)))
            {
                DEBUGMSG(1, (TEXT("IRLAP: SNRM/UA negotiation failed, rc=%d\n"), rc));
#if DBG
                DbgPrint("IRLAP: SNRM/UA negotiation failed, rc=%d\n", rc);
#endif
                return;
            }
        }

        CTEMemCopy(IMsg.IRDA_MSG_RemoteDevAddr,
               pIrlapCb->RemoteDevice.DevAddr, IRDA_DEV_ADDR_LEN);
        IMsg.IRDA_MSG_pQos = &pIrlapCb->NegotiatedQos;
        IMsg.Prim = IRLAP_CONNECT_IND;
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        pIrlapCb->State = SNRM_RECEIVED;
        break;

      case BACKOFF_WAIT:   // CROSSED SNRM
        // if Remote address greater than mine we'll respond to SNRM
        if (AddrsInSNRM)
        {
            if (AddressGreaterThan(pSnrmFormat->SrcAddr,
                                   pIrlapCb->LocalDevice.DevAddr))
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->BackoffTimer);
            }
        }
        // fall through
      case CONN_MEDIA_SENSE:   // CROSSED SNRM
      case SNRM_SENT:
        // if Remote address greater than mine we'll respond to SNRM
        if (AddrsInSNRM && AddressGreaterThan(pSnrmFormat->SrcAddr,
                                              pIrlapCb->LocalDevice.DevAddr))
        {
            if (pIrlapCb->State != BACKOFF_WAIT)
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
            }
            InitializeState(pIrlapCb, SECONDARY);

            if (QosInSNRM)
            {
                ExtractQosParms(&pIrlapCb->RemoteQos,
                                &pSnrmFormat->FirstQosByte, pEndQosUCHAR);
                if ((rc = NegotiateQosParms(pIrlapCb, &pIrlapCb->RemoteQos)))
                {
                    DEBUGMSG(1, (TEXT("IRLAP: SNRM/UA negotiation failed, rc=%d\n"), rc));
                    ASSERT(0);
                    pIrlapCb->State = NDM;
                    return;
                }
            }

            if (AddrsInSNRM)
            {
                pIrlapCb->ConnAddr =
                    (int)IRLAP_GET_ADDR(pSnrmFormat->ConnAddr);
            }

            SendUA(pIrlapCb, TRUE);
            
            if (QosInSNRM)
            {
                ApplyQosParms(pIrlapCb);
            }
            
            IMsg.IRDA_MSG_pQos = &pIrlapCb->NegotiatedQos;
            IMsg.Prim = IRLAP_CONNECT_CONF;
            IMsg.IRDA_MSG_ConnStatus = IRLAP_CONNECTION_COMPLETED;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);

            IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
            pIrlapCb->State = S_NRM;
        }
        break;

      case P_RECV:
      case P_DISCONNECT_PEND:
      case P_CLOSE:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->State = NDM;        
        StationConflict(pIrlapCb);
        ReturnRxTxWinMsgs(pIrlapCb);
        if (pIrlapCb->State == P_CLOSE)
        {
            GotoNDMThenDscvOrConn(pIrlapCb);
        }
        break;

      case S_NRM:
      case S_CLOSE:
      case S_DISCONNECT_PEND:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        SendDM(pIrlapCb);
        ApplyDefaultParms(pIrlapCb);
        IMsg.Prim = IRLAP_DISCONNECT_IND;
        if (pIrlapCb->State == S_NRM)
        {
            IMsg.IRDA_MSG_DiscStatus = IRLAP_DECLINE_RESET;
        }
        else
        {
            IMsg.IRDA_MSG_DiscStatus = IRLAP_DISCONNECT_COMPLETED;
        }
        pIrlapCb->State = NDM;        
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        break;

      case S_ERROR:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
        pIrlapCb->State = S_NRM;
        break;

      default:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("SNRM ignored in this state")));
    }

    return;
}
/*****************************************************************************
*
*/
VOID
ProcessUA(PIRLAP_CB pIrlapCb,
          IRLAP_UA_FORMAT *pUAFormat,
          UCHAR *pEndQosUCHAR)
{
    BOOLEAN        QosInUA = &pUAFormat->FirstQosByte < pEndQosUCHAR;
    BOOLEAN        AddrsInUA = (UCHAR *)pUAFormat < pEndQosUCHAR;
    int         Tmp;
    IRDA_MSG    IMsg;
    UINT        rc;
    
    PAGED_CODE();

    if (AddrsInUA && !MyDevAddr(pIrlapCb, pUAFormat->DestAddr))
    {
        IRLAP_LOG_ACTION((pIrlapCb,
                          TEXT("Ignoring UA addressed to:%02X%02X%02X%02X"),
                          EXPAND_ADDR(pUAFormat->DestAddr)));
        return;
    }

    switch (pIrlapCb->State)
    {
      case BACKOFF_WAIT:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->BackoffTimer);
        // fall through
      case SNRM_SENT:
        if (pIrlapCb->State != BACKOFF_WAIT)
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        }

        InitializeState(pIrlapCb, PRIMARY);

        if (QosInUA)
        {
            ExtractQosParms(&pIrlapCb->RemoteQos, &pUAFormat->FirstQosByte,
                            pEndQosUCHAR);

            if ((rc = NegotiateQosParms(pIrlapCb, &pIrlapCb->RemoteQos)))
            {
                DEBUGMSG(1, (TEXT("IRLAP: SNRM/UA negotiation failed, rc=%d\n"), rc));
                ASSERT(0);
                pIrlapCb->State = NDM;
                return;
            }
            ApplyQosParms(pIrlapCb);
        }

        IMsg.IRDA_MSG_pQos = &pIrlapCb->NegotiatedQos;

        IMsg.Prim = IRLAP_CONNECT_CONF;
        IMsg.IRDA_MSG_ConnStatus = IRLAP_CONNECTION_COMPLETED;

        // notify LMP of connection
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);

        // send RR (turn link), start FinalTimer/2
        SendRR_RNR(pIrlapCb);
        
        Tmp = pIrlapCb->FinalTimer.Timeout;
        pIrlapCb->FinalTimer.Timeout = pIrlapCb->FinalTimer.Timeout/2;
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->FinalTimer.Timeout = Tmp;
        
        pIrlapCb->State = P_RECV;
        break;

      case P_RECV: // Unsolicited UA, may want to do something else ???
        IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->PollTimer);
        pIrlapCb->State = P_XMIT;
        break;

      case P_DISCONNECT_PEND:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        SendDISC(pIrlapCb);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->RetryCnt = 0;
        GotoPCloseState(pIrlapCb);
        break;

      case P_CLOSE:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        ApplyDefaultParms(pIrlapCb);
        if (pIrlapCb->LocalDiscReq == TRUE)
        {
            pIrlapCb->LocalDiscReq = FALSE;
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_DISCONNECT_COMPLETED;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        }
        GotoNDMThenDscvOrConn(pIrlapCb);
        break;

      case S_NRM:
      case S_DISCONNECT_PEND:
      case S_ERROR:
      case S_CLOSE:
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        break;

      default:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("UA ignored in this state")));
    }

}

UCHAR *
GetPv(UCHAR *pQosUCHAR,
      UINT *pBitField)
{
    int     Pl = (int) *pQosUCHAR++;

    *pBitField = 0;
    
    if (Pl == 1)
    {
        *pBitField = (UINT) *pQosUCHAR;
    }
    else
    {
        *pBitField = ((UINT) *(pQosUCHAR+1))<<8;
        *pBitField |= (UINT) *(pQosUCHAR);
    }
    
    return pQosUCHAR + Pl;
}
/*****************************************************************************
*
*           THIS WILL BREAK IF PARAMETER LENGTH (PL) IS GREATER THAN 2
*/
void
ExtractQosParms(IRDA_QOS_PARMS *pQos,
                UCHAR *pQosUCHAR,
                UCHAR *pEndQosUCHAR)
{
    PAGED_CODE();
    
    while (pQosUCHAR + 2 < pEndQosUCHAR)
    {
        switch (*pQosUCHAR)
        {
          case QOS_PI_BAUD:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfBaud);
            break;

          case QOS_PI_MAX_TAT:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfMaxTurnTime);
            break;

          case QOS_PI_DATA_SZ:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfDataSize);
            break;

          case QOS_PI_WIN_SZ:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfWindowSize);
            break;

          case QOS_PI_BOFS:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfBofs);
            break;

          case QOS_PI_MIN_TAT:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfMinTurnTime);
            break;

          case QOS_PI_DISC_THRESH:
            pQosUCHAR = GetPv(pQosUCHAR+1, &pQos->bfDisconnectTime);
            break;

          default:
              DEBUGMSG(1, (TEXT("IRLAP: Invalid Qos parameter type %X\n"), *pQosUCHAR));
              ASSERT(0);
              
              pQosUCHAR = pEndQosUCHAR;
        }
    }
}
/*****************************************************************************
*
*   @func   UINT | NegotiateQosParms | Take the received Qos build
*                                      negotiated Qos.
*
*   @rdesc  SUCCESS, otherwise one of the folowing:
*   @flag   IRLAP_BAUD_NEG_ERR     | Failed to negotiate baud
*   @flag   IRLAP_DISC_NEG_ERR     | Failed to negotiate disconnect time
*   @flag   IRLAP_MAXTAT_NEG_ERR   | Failed to negotiate max turn time
*   @flag   IRLAP_DATASIZE_NEG_ERR | Failed to negotiate data size
*   @flag   IRLAP_WINSIZE_NEG_ERR  | Failed to negotiate window size
*   @flag   IRLAP_BOFS_NEG_ERR     | Failed to negotiate number of BOFS
*   @flag   IRLAP_WINSIZE_NEG_ERR  | Failed to window size
*   @flag   IRLAP_LINECAP_ERR      | Failed to determine valid line capacity
*
*   @parm   IRDA_QOS_PARMS * | pRemoteQos | Pointer to QOS parm struct
*/
UINT
NegotiateQosParms(PIRLAP_CB         pIrlapCb,
                  IRDA_QOS_PARMS    *pRemoteQos)
{
    UINT BitSet;
    BOOLEAN ParmSet = FALSE;
    UINT BOFSDivisor = 1;
    UINT MaxLineCap = 0;
    UINT LineCapacity;
    UINT DataSizeBit = 0;
    UINT WinSizeBit = 0;
#ifdef GET_LARGEST_DATA_SIZE    
    UINT WSBit;
#else
    UINT DataBit;
#endif        
    int  RemoteDataSize = 0;
    int  RemoteWinSize = 0;
    
    PAGED_CODE();

    // Baud rate is Type 0 parm
    
    pIrlapCb->Baud = IrlapGetQosParmVal(vBaudTable,
                        pIrlapCb->LocalQos.bfBaud & pRemoteQos->bfBaud,
                        &BitSet);
    BOFSDivisor = IrlapGetQosParmVal(vBOFSDivTable,
                    pIrlapCb->LocalQos.bfBaud & pRemoteQos->bfBaud,
                    &BitSet);
    pIrlapCb->NegotiatedQos.bfBaud = BitSet;

    if (-1 == pIrlapCb->Baud)
    {
        return IRLAP_BAUD_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Negotiated Baud:%d"), pIrlapCb->Baud));

    // Disconnect/Threshold time is Type 0 parm
    pIrlapCb->DisconnectTime = IrlapGetQosParmVal(vDiscTable,
                pIrlapCb->LocalQos.bfDisconnectTime & pRemoteQos->bfDisconnectTime,
                &BitSet);
    pIrlapCb->ThresholdTime = IrlapGetQosParmVal(vThreshTable,
                pIrlapCb->LocalQos.bfDisconnectTime & pRemoteQos->bfDisconnectTime,
                &BitSet);
    pIrlapCb->NegotiatedQos.bfDisconnectTime = BitSet;

    if (-1 == pIrlapCb->DisconnectTime)
    {
        return IRLAP_DISC_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb,
                      TEXT("Negotiated Disconnect/Threshold time:%d/%d"),
                      pIrlapCb->DisconnectTime, pIrlapCb->ThresholdTime));

    pIrlapCb->RemoteMaxTAT = IrlapGetQosParmVal(vMaxTATTable,
                                          pRemoteQos->bfMaxTurnTime,
                                          &BitSet);
    pIrlapCb->NegotiatedQos.bfMaxTurnTime = BitSet;
    if (-1 == pIrlapCb->RemoteMaxTAT)
    {
        return IRLAP_MAXTAT_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Remote max turnaround time:%d"),
                      pIrlapCb->RemoteMaxTAT));

    pIrlapCb->RemoteMinTAT = IrlapGetQosParmVal(vMinTATTable,
                                          pRemoteQos->bfMinTurnTime,
                                          &BitSet);
    pIrlapCb->NegotiatedQos.bfMinTurnTime = BitSet;
    if (-1 == pIrlapCb->RemoteMinTAT)
    {
        return IRLAP_MINTAT_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Remote min turnaround time:%d"),
                      pIrlapCb->RemoteMinTAT));

    // DataSize ISNOT A TYPE 0 PARAMETER. BUT WIN95's IRCOMM implementation
    // ASSUMES THAT IT IS. SO FOR NOW, NEGOTIATE IT. grrrr..
    /* WIN95 out
    pIrlapCb->RemoteDataSize = IrlapGetQosParmVal(vDataSizeTable,
                                (UCHAR) (pIrlapCb->LocalQos.bfDataSize &
                                     pRemoteQos->bfDataSize), &BitSet);  
    */
    pIrlapCb->RemoteDataSize = IrlapGetQosParmVal(vDataSizeTable,
                                            pRemoteQos->bfDataSize, &BitSet);
    DataSizeBit = BitSet;
    pIrlapCb->NegotiatedQos.bfDataSize = BitSet;
    if (-1 == pIrlapCb->RemoteDataSize)
    {
        return IRLAP_DATASIZE_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb,
                      TEXT("Remote data size:%d"), pIrlapCb->RemoteDataSize));

    pIrlapCb->RemoteWinSize = IrlapGetQosParmVal(vWinSizeTable,
                                          pRemoteQos->bfWindowSize, &BitSet);
    WinSizeBit = BitSet;
    pIrlapCb->NegotiatedQos.bfWindowSize = BitSet;
    if (-1 == pIrlapCb->RemoteWinSize)
    {
        return IRLAP_WINSIZE_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb,
                      TEXT("Remote window size:%d"),
                      pIrlapCb->RemoteWinSize));

    pIrlapCb->RemoteNumBOFS=(IrlapGetQosParmVal(vBOFSTable,
                                          pRemoteQos->bfBofs, &BitSet)
                                    / BOFSDivisor)+1;
    pIrlapCb->NegotiatedQos.bfBofs = BitSet;
    if (-1 == pIrlapCb->RemoteNumBOFS)
    {
        return IRLAP_BOFS_NEG_ERR;
    }
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Remote number of BOFS:%d"),
                      pIrlapCb->RemoteNumBOFS));

    // The maximum line capacity is in UCHARs and comes from a table in spec.
    // (can't calc because table isn't linear). It is determined by the
    // maximum line capacity and baud rate.
    //
    // Later note: Errata corrected table so values could be calculated.
    // Could get rid of tables
    switch (pIrlapCb->Baud)
    {
      case 9600:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_9600,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;

      case 19200:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_19200,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;

      case 38400:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_38400,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;

      case 57600:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_57600,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;

      case 115200:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_115200,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;
        
      case 576000:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_576000,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;
        
      case 1152000:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_1152000,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;
        
      case 4000000:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_4000000,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;
        
      case 16000000:
        MaxLineCap = IrlapGetQosParmVal(MAXCAP_16000000,
                                   pRemoteQos->bfMaxTurnTime, &BitSet);
        break;
        
      default:
        ASSERT(0);
    }

    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Maximum line capacity:%d"), MaxLineCap));
    LineCapacity = LINE_CAPACITY(pIrlapCb);
    IRLAP_LOG_ACTION((pIrlapCb,
                      TEXT("Requested line capacity:%d"), LineCapacity));

    if (LineCapacity > MaxLineCap)
    {
        ParmSet = FALSE;
        // Adjust data and window size to fit within the line capacity.
#ifdef GET_LARGEST_DATA_SIZE        
        // Get largest possible datasize
        for (; DataSizeBit != 0 && !ParmSet; DataSizeBit >>= 1)
        {
            pIrlapCb->RemoteDataSize = IrlapGetQosParmVal(vDataSizeTable,
                                                          DataSizeBit, NULL);
            // Start with smallest window
            for (WSBit=1; WSBit <= WinSizeBit; WSBit <<=1)
            {
                pIrlapCb->RemoteWinSize = IrlapGetQosParmVal(vWinSizeTable,
                                                             WSBit, NULL);
                LineCapacity = LINE_CAPACITY(pIrlapCb);

                IRLAP_LOG_ACTION((pIrlapCb, 
                  TEXT("adjusted data size=%d, window size= %d, line cap=%d"),
                        pIrlapCb->RemoteDataSize, pIrlapCb->RemoteWinSize, 
                        LineCapacity));

                if (LineCapacity > MaxLineCap)
                {
                    // Get a smaller data size (only if ParmSet is false)
                    break; 
                }
                ParmSet = TRUE;
                // Save the last good one,then loop and try a larger window
                RemoteDataSize = pIrlapCb->RemoteDataSize;
                RemoteWinSize  = pIrlapCb->RemoteWinSize;
                pIrlapCb->NegotiatedQos.bfWindowSize = WSBit;
                pIrlapCb->NegotiatedQos.bfDataSize = DataSizeBit;
            }
        }
#else
        // Get largest possible windowsize
        for (; WinSizeBit != 0 && !ParmSet; WinSizeBit >>= 1)
        {
            pIrlapCb->RemoteWinSize = IrlapGetQosParmVal(vWinSizeTable,
                                                          WinSizeBit, NULL);
            // Start with smallest datasize
            for (DataBit=1; DataBit <= DataSizeBit; DataBit <<=1)
            {
                pIrlapCb->RemoteDataSize = IrlapGetQosParmVal(vDataSizeTable,
                                                             DataBit, NULL);
                LineCapacity = LINE_CAPACITY(pIrlapCb);

                IRLAP_LOG_ACTION((pIrlapCb, 
                  TEXT("adjusted data size=%d, window size= %d, line cap=%d"),
                        pIrlapCb->RemoteDataSize, pIrlapCb->RemoteWinSize, 
                        LineCapacity));

                if (LineCapacity > MaxLineCap)
                {
                    // Get a smaller window size (only if ParmSet is false)
                    break; 
                }
                ParmSet = TRUE;
                // Save the last good one,then loop and try a larger Data size
                RemoteWinSize  = pIrlapCb->RemoteWinSize;                
                RemoteDataSize = pIrlapCb->RemoteDataSize;
                pIrlapCb->NegotiatedQos.bfDataSize = DataBit;
                pIrlapCb->NegotiatedQos.bfWindowSize = WinSizeBit;                
            }
        }
#endif        
        if (!ParmSet)
        {
            return IRLAP_LINECAP_ERR;
        }

        pIrlapCb->RemoteDataSize = RemoteDataSize;
        pIrlapCb->RemoteWinSize = RemoteWinSize;

        IRLAP_LOG_ACTION((pIrlapCb,
                   TEXT("final data size=%d, window size= %d, line cap=%d"),
                          pIrlapCb->RemoteDataSize, pIrlapCb->RemoteWinSize, 
                          LINE_CAPACITY(pIrlapCb)));
    }

    return SUCCESS;
}
/*****************************************************************************
*
*
*/
VOID
ApplyQosParms(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    IMsg;
    
    PAGED_CODE();
    
    pIrlapCb->PollTimer.Timeout     = pIrlapCb->RemoteMaxTAT;
    pIrlapCb->FinalTimer.Timeout    = pIrlapCb->LocalMaxTAT;

    if (pIrlapCb->Baud <= 115200)
    {
        pIrlapCb->FinalTimer.Timeout += 150; // fudge factor for SIR
    } 
    
    // convert disconnect/threshold time to ms and divide by final timer
    // to get number of retries
    pIrlapCb->N1 = pIrlapCb->ThresholdTime * 1000 / pIrlapCb->FinalTimer.Timeout;
    pIrlapCb->N2 = pIrlapCb->DisconnectTime * 1000 / pIrlapCb->FinalTimer.Timeout;       

    IMsg.Prim              = MAC_CONTROL_REQ;
    IMsg.IRDA_MSG_Op       = MAC_RECONFIG_LINK;
    IMsg.IRDA_MSG_Baud     = pIrlapCb->Baud;
    IMsg.IRDA_MSG_NumBOFs  = pIrlapCb->RemoteNumBOFS;  // Number of BOFS
                                                          // to add to tx
    IMsg.IRDA_MSG_DataSize = pIrlapCb->RemoteDataSize; // Max rx size packet
                                                      // causes major heap
                                                      // problems later
    IMsg.IRDA_MSG_MinTat   = pIrlapCb->RemoteMinTAT;
    IRLAP_LOG_ACTION((pIrlapCb,
        TEXT("Reconfig link for Baud:%d, Remote BOFS:%d"),
                      pIrlapCb->Baud, pIrlapCb->RemoteNumBOFS));

    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Retry counts N1=%d, N2=%d"),
                      pIrlapCb->N1, pIrlapCb->N2));
    
    IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
    
/*
    if (pIrlapCb->MonitorLink)
    {
        IrdaTimerStart(&pIrlapCb->StatusTimer);    
    }    
*/    
}
/*****************************************************************************
*
*   @func   UINT | IrlapGetQosParmVal |    
*                   retrieves the parameters value from table
*
*   @rdesc  value contained in parmeter value table, 0 if not found
*           (0 is a valid parameter in some tables though)
*
*   @parm   UINT [] | PVTable | table containing parm values
*           USHORT  | BitField | contains bit indicating which parm to select
*
*   @comm
*/
UINT
IrlapGetQosParmVal(UINT PVTable[], UINT BitField, UINT *pBitSet)
{
    int     i;
    UINT    Mask;

    for (i = PV_TABLE_MAX_BIT, Mask = (1<<PV_TABLE_MAX_BIT);
         Mask > 0; i--, Mask = Mask >> 1)
    {
        if (Mask & BitField)
        {
            if (pBitSet != NULL)
            {
                *pBitSet = Mask;
            }
            return (PVTable[i]);
        }
    }
    
    *pBitSet = 0;
    
    return (UINT) -1;
}
/*****************************************************************************
*
*/
VOID
ProcessTEST(PIRLAP_CB       pIrlapCb,
            PIRDA_MSG       pMsg,
            IRLAP_UA_FORMAT *pTestFormat,
            int             CRBit,
            int             PFBit)
{

    PAGED_CODE();    

    if (IRLAP_CMD == CRBit && IRLAP_PFBIT_SET == PFBit)
    {
        // bounce it back
        
        *(pMsg->IRDA_MSG_pRead) ^= 1; // swap cr bit    
    
        // copy the header to the header portion for an outbound message
        
        pMsg->IRDA_MSG_pHdrRead = pMsg->IRDA_MSG_Header;

        *pMsg->IRDA_MSG_pHdrRead     = *pMsg->IRDA_MSG_pRead;
        *(pMsg->IRDA_MSG_pHdrRead+1) = *(pMsg->IRDA_MSG_pRead+1);

        pMsg->IRDA_MSG_pHdrWrite = pMsg->IRDA_MSG_Header + 2;

        pMsg->IRDA_MSG_pRead+=2;

        pMsg->Prim = MAC_DATA_REQ;

        IrmacDown(pIrlapCb->pIrdaLinkCb, pMsg);
    }
    else
    {
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring")));
    }

    // Not implementing TEST responses for now
}
/*****************************************************************************
*
*/
VOID
ProcessUI(PIRLAP_CB pIrlapCb,
          PIRDA_MSG pMsg,
          int       CRBit,
          int       PFBit)
{
    BOOLEAN LinkTurned = TRUE;
    
    PAGED_CODE();

    pMsg->IRDA_MSG_pRead += 2; // chop the IRLAP header

    switch (pIrlapCb->State)
    {
      case NDM:
      case DSCV_MEDIA_SENSE:
      case DSCV_QUERY:
      case DSCV_REPLY:
      case CONN_MEDIA_SENSE:
      case SNRM_SENT:
      case BACKOFF_WAIT:
      case SNRM_RECEIVED:
        pMsg->Prim = IRLAP_UDATA_IND;
        IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg);
        return;
        
      case P_XMIT:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        return;
    }

    if (PRIMARY == pIrlapCb->StationType)
    {
        // stop timers if PF bit set or invalid CRBit (matches mine)
        if (IRLAP_PFBIT_SET == PFBit || pIrlapCb->CRBit == CRBit)
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        }
    }
    else
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
    }

    if (pIrlapCb->CRBit == CRBit)
    {
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    // Send the Unnumber information to LMP
    pMsg->Prim = IRLAP_UDATA_IND;
    IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg);

    if (IRLAP_PFBIT_SET == PFBit)
    {
        switch (pIrlapCb->State)
        {
          case P_RECV:
            XmitTxMsgList(pIrlapCb, FALSE, &LinkTurned);
            break;

          case P_DISCONNECT_PEND:
            SendDISC(pIrlapCb);
            pIrlapCb->RetryCnt = 0;
            GotoPCloseState(pIrlapCb);
            break;

          case P_CLOSE:
            ResendDISC(pIrlapCb);
            break;

          case S_NRM:
            XmitTxMsgList(pIrlapCb, TRUE, NULL);
            break;

          case S_DISCONNECT_PEND:
            SendRD(pIrlapCb);
            pIrlapCb->State = S_CLOSE;
            break;

          case S_ERROR:
            SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
            pIrlapCb->State = S_NRM;
            break;

          case S_CLOSE:
            SendRD(pIrlapCb);
        }
    }

    if (PRIMARY == pIrlapCb->StationType)
    {
        if (IRLAP_PFBIT_SET == PFBit && pIrlapCb->State != NDM)
        {
            if (LinkTurned)
            {
                IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
            }
            else
            {
                IrlapTimerStart(pIrlapCb, &pIrlapCb->PollTimer);
                pIrlapCb->State = P_XMIT;
            }
        }
    }
    else
    {
        IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
    }

    return;
}
/*****************************************************************************
*
*/
VOID
ProcessDM(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    IMsg;
    BOOLEAN        LinkTurned;
    
    PAGED_CODE();

    switch (pIrlapCb->State)
    {
      case NDM:
      case DSCV_MEDIA_SENSE:
      case DSCV_QUERY:
      case DSCV_REPLY:
      case CONN_MEDIA_SENSE:
      case BACKOFF_WAIT:
      case SNRM_RECEIVED:
      case P_XMIT:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        return;
    }

    if (PRIMARY != pIrlapCb->StationType)
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);

    switch (pIrlapCb->State)
    {
      case P_RECV: // I'm not sure why I am doing this ???
        XmitTxMsgList(pIrlapCb, FALSE, &LinkTurned);
        if (LinkTurned)
        {
            IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        }
        else
        {
            IrlapTimerStart(pIrlapCb, &pIrlapCb->PollTimer);
            pIrlapCb->State = P_XMIT;
        }
        break;

      case P_DISCONNECT_PEND:
        pIrlapCb->RetryCnt = 0;
        SendDISC(pIrlapCb);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        GotoPCloseState(pIrlapCb);
        break;

      case SNRM_SENT:
        ApplyDefaultParms(pIrlapCb);
        
        pIrlapCb->State = NDM;
                
        if (pIrlapCb->LocalDiscReq || pIrlapCb->State == SNRM_SENT)
        {
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_REMOTE_INITIATED;
        
            pIrlapCb->LocalDiscReq = FALSE;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        }
        break;
        
      case P_CLOSE:

        pIrlapCb->State = NDM;
                
        ApplyDefaultParms(pIrlapCb);

        if (pIrlapCb->LocalDiscReq || pIrlapCb->State == SNRM_SENT)
        {
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_DISCONNECT_COMPLETED;
        
            pIrlapCb->LocalDiscReq = FALSE;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        }
        
        GotoNDMThenDscvOrConn(pIrlapCb);
        break;
    }
}
/*****************************************************************************
*
*
*/
VOID
ProcessDISC(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    IMsg;
    
    if (IgnoreState(pIrlapCb))
    {
        return;
    }

    if (SECONDARY != pIrlapCb->StationType)
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);

    // Acknowledge primary's disconnect request
    SendUA(pIrlapCb, FALSE /* No Qos */);

    // notify LMP of disconnect
    IMsg.Prim = IRLAP_DISCONNECT_IND;
    if (pIrlapCb->LocalDiscReq)
    {
        IMsg.IRDA_MSG_DiscStatus = IRLAP_DISCONNECT_COMPLETED;
        pIrlapCb->LocalDiscReq = FALSE;
    }
    else
    {
        IMsg.IRDA_MSG_DiscStatus = IRLAP_REMOTE_INITIATED;
    }

    pIrlapCb->State = NDM;
    
    IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
    
    ReturnRxTxWinMsgs(pIrlapCb);
    ApplyDefaultParms(pIrlapCb);
    
    return;
}
/*****************************************************************************
*
*   @func   ret_type | func_name | funcdesc
*
*   @rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
*
*   @parm   data_type | parm_name | description
*
*   @comm
*           comments
*
*   @ex
*           example
*/
VOID
ProcessRD(PIRLAP_CB pIrlapCb)
{
    PAGED_CODE();
    
    if (IgnoreState(pIrlapCb))
    {
        return;
    }

    if (PRIMARY != pIrlapCb->StationType)
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);

    if (pIrlapCb->State == P_CLOSE)
    {
        ResendDISC(pIrlapCb);
    }
    else
    {
        ReturnRxTxWinMsgs(pIrlapCb);
        pIrlapCb->RetryCnt = 0;
        SendDISC(pIrlapCb);
        GotoPCloseState(pIrlapCb);
    }
    if (pIrlapCb->State != NDM)
    {
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
    }
}
/*****************************************************************************
*
*/
VOID
ProcessFRMR(PIRLAP_CB pIrlapCb)
{
    PAGED_CODE();
    
    if (IgnoreState(pIrlapCb))
    {
        return;
    }

    if (PRIMARY != pIrlapCb->StationType)
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);

    switch (pIrlapCb->State)
    {
      case P_RECV:
        ReturnRxTxWinMsgs(pIrlapCb);
        // fall through

      case P_DISCONNECT_PEND:
        pIrlapCb->RetryCnt = 0;
        SendDISC(pIrlapCb);
        GotoPCloseState(pIrlapCb);
        break;

      case P_CLOSE:
        ResendDISC(pIrlapCb);
        break;
    }

    if (pIrlapCb->State != NDM)
    {
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
    }
}
/*****************************************************************************
*
*/
VOID
ProcessRNRM(PIRLAP_CB pIrlapCb)
{
    PAGED_CODE();
    
    if (IgnoreState(pIrlapCb))
    {
        return;
    }

    if (PRIMARY != pIrlapCb->StationType)
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);

    switch (pIrlapCb->State)
    {
      case P_RECV:
      case P_DISCONNECT_PEND:
        pIrlapCb->RetryCnt = 0;
        SendDISC(pIrlapCb);
        GotoPCloseState(pIrlapCb);
        break;

      case P_CLOSE:
        ResendDISC(pIrlapCb);
        break;
    }

    if (pIrlapCb->State != NDM)
    {
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
    }

    return;
}
/*****************************************************************************
*
*/
VOID
ProcessREJ_SREJ(PIRLAP_CB   pIrlapCb,
                int         FrameType,
                PIRDA_MSG   pMsg,
                int         CRBit,
                int         PFBit,
                UINT        Nr)
{
    if (IgnoreState(pIrlapCb))
    {
        return;
    }

    if (PRIMARY == pIrlapCb->StationType)
    {
        // stop timers if PF bit set or invalid CRBit (matches mine)
        if (IRLAP_PFBIT_SET == PFBit || pIrlapCb->CRBit == CRBit)
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        }
    }
    else
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
    }

    if (pIrlapCb->CRBit == CRBit)
    {
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    switch (pIrlapCb->State)
    {
      case P_RECV:
      case S_NRM:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            if (InvalidNr(pIrlapCb,Nr) || Nr == pIrlapCb->TxWin.End)
            {
                ProcessInvalidNr(pIrlapCb, PFBit);
            }
            else
            {
                ConfirmAckedTxMsgs(pIrlapCb, Nr);
                if (FrameType == IRLAP_REJ)
                {
                    ResendRejects(pIrlapCb, Nr); // link turned here
                }
                else // selective reject
                {
                    IRLAP_LOG_ACTION((pIrlapCb, TEXT("RETRANSMISSION:")));
                    SendIFrame(pIrlapCb,
                               pIrlapCb->TxWin.pMsg[Nr],
                               Nr, IRLAP_PFBIT_SET);
                }
            }
        }
        break;

      case P_DISCONNECT_PEND:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            pIrlapCb->RetryCnt = 0;
            SendDISC(pIrlapCb);
            GotoPCloseState(pIrlapCb);
        }
        break;

      case P_CLOSE:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            ResendDISC(pIrlapCb);
        }
        break;

      case S_DISCONNECT_PEND:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            SendRD(pIrlapCb);
            pIrlapCb->State = S_CLOSE;
        }
        break;

      case S_ERROR:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
            pIrlapCb->State = S_NRM;
        }
        break;

      case S_CLOSE:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            SendRD(pIrlapCb);
        }
        break;

    }
    if (PRIMARY == pIrlapCb->StationType)
    {
        if (IRLAP_PFBIT_SET == PFBit && pIrlapCb->State != NDM)
        {
            IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        }
    }
    else
    {
        IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
    }
}
/*****************************************************************************
*
*/
VOID
ProcessRR_RNR(PIRLAP_CB pIrlapCb,
              int       FrameType,
              PIRDA_MSG pMsg,
              int       CRBit,
              int       PFBit,
              UINT      Nr)
{
    BOOLEAN LinkTurned = TRUE;    
    
    if (IgnoreState(pIrlapCb))
    {
        return;
    }

    if (pIrlapCb->FastPollCount == 0)
    {
        pIrlapCb->PollTimer.Timeout = pIrlapCb->RemoteMaxTAT;
    }
    else
    {
        pIrlapCb->FastPollCount -= 1;
    }    

    if (PRIMARY == pIrlapCb->StationType)
    {
        // stop timers if PF bit set or invalid CRBit (matches mine)
        if (IRLAP_PFBIT_SET == PFBit || pIrlapCb->CRBit == CRBit)
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
        }
    }
    else // SECONDARY, restart WDog
    {
        IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        if (pIrlapCb->CRBit != CRBit)
        {
            IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
        }
    }

    if (pIrlapCb->CRBit == CRBit)
    {
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;
        return;
    }

    if (FrameType == IRLAP_RR)
    {
        pIrlapCb->RemoteBusy = FALSE;
    }
    else // RNR
    {
        pIrlapCb->RemoteBusy = TRUE;
    }

    switch (pIrlapCb->State)
    {
      case P_RECV:
      case S_NRM:
        if (PFBit == IRLAP_PFBIT_SET)
        {
            if (InvalidNr(pIrlapCb, Nr))
            {
                ProcessInvalidNr(pIrlapCb, PFBit);
            }
            else
            {
                ConfirmAckedTxMsgs(pIrlapCb,Nr);

                if (Nr != pIrlapCb->Vs) // Implicit reject
                {
                    if (PRIMARY == pIrlapCb->StationType &&
                        IRLAP_RNR == FrameType)
                    {
                        LinkTurned = FALSE;
                    }
                    else
                    {
                        ResendRejects(pIrlapCb, Nr); // always turns link
                    }
                }
                else
                {
                    if (pIrlapCb->Vr != pIrlapCb->RxWin.End)
                    {
                        MissingRxFrames(pIrlapCb); // Send SREJ or REJ
                    }
                    else
                    {
                        if (PRIMARY == pIrlapCb->StationType)
                        {
                            LinkTurned = FALSE;
                            if (IRLAP_RR == FrameType)
                            {
                                XmitTxMsgList(pIrlapCb, FALSE, &LinkTurned);
                            }
                        }
                        else
                        {
                            // Always turn link if secondary
                            // with data or an RR if remote is busy
                            if (IRLAP_RR == FrameType)
                            {
                                XmitTxMsgList(pIrlapCb, TRUE, NULL);
                            }
                            else
                            {
                                SendRR_RNR(pIrlapCb);
                            }
                        }
                    }
                }
            }
            // If the link was turned, restart Final timer,
            // else start the Poll timer and enter the transmit state
            if (PRIMARY == pIrlapCb->StationType)
            {
                if (LinkTurned)
                {
                    IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
                }
                else
                {
                    IrlapTimerStart(pIrlapCb, &pIrlapCb->PollTimer);
                    pIrlapCb->State = P_XMIT;
                }
            }
        }
        break;

      case P_DISCONNECT_PEND:
        SendDISC(pIrlapCb);
        pIrlapCb->RetryCnt = 0;
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        GotoPCloseState(pIrlapCb);
        break;

      case P_CLOSE:
        ResendDISC(pIrlapCb);
        if (pIrlapCb->State != NDM)
        {
            IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        }
        break;

      case S_DISCONNECT_PEND:
      case S_CLOSE:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            SendRD(pIrlapCb);
            if (pIrlapCb->State != S_CLOSE)
                pIrlapCb->State = S_CLOSE;
        }
        break;

      case S_ERROR:
        if (IRLAP_PFBIT_SET == PFBit)
        {
            SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
            pIrlapCb->State = S_NRM;
        }
        break;

      default:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));

    }
}
/*****************************************************************************
*
*/
VOID
ProcessInvalidNr(PIRLAP_CB pIrlapCb,
                 int PFBit)
{
    DEBUGMSG(DBG_ERROR, (TEXT("IRLAP: ERROR, Invalid Nr\r\n")));
    
    ReturnRxTxWinMsgs(pIrlapCb);

    if (PRIMARY == pIrlapCb->StationType)
    {
        if (PFBit == IRLAP_PFBIT_SET)
        {
            SendDISC(pIrlapCb);
            pIrlapCb->RetryCnt = 0;
            // F-timer will be started by caller
            GotoPCloseState(pIrlapCb);
        }
        else
        {
            pIrlapCb->State = P_DISCONNECT_PEND;
        }
    }
    else // SECONDARY
    {
        if (PFBit == IRLAP_PFBIT_SET)
        {
            pIrlapCb->Frmr.Vs = (UCHAR) pIrlapCb->Vs;
            pIrlapCb->Frmr.Vr = (UCHAR) pIrlapCb->Vr;
            pIrlapCb->Frmr.W = 0;
            pIrlapCb->Frmr.X = 0;
            pIrlapCb->Frmr.Y = 0;
            pIrlapCb->Frmr.Z = 1; // bad NR
            SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
        }
    }
}
/*****************************************************************************
*
*/
VOID
ProcessIFrame(PIRLAP_CB pIrlapCb,
              PIRDA_MSG pMsg,
              int       CRBit,
              int       PFBit,
              UINT      Ns,
              UINT      Nr)
{
#if DBG_OUT
    UCHAR    *p1, *p2;
#endif

    if ((pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead) > IRDA_HEADER_LEN)
    {
        pIrlapCb->StatusFlags |= LF_RX;    
    }
                
    pMsg->IRDA_MSG_pRead += IRLAP_HEADER_LEN; // chop the IRLAP header
    
#if DBG_CHECKSUM
    // print first and last 4 bytes of frame to help isolate 
    // data corruption problem. Should be used with sledge
    if ((pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead) > 20)
        DEBUGMSG(1, (TEXT("R(%X): %c%c%c%c, %c%c%c%c\n"),
            pMsg->IRDA_MSG_pRead+3,
            *(pMsg->IRDA_MSG_pRead+3),    
            *(pMsg->IRDA_MSG_pRead+4),    
            *(pMsg->IRDA_MSG_pRead+5),    
            *(pMsg->IRDA_MSG_pRead+6),
            *(pMsg->IRDA_MSG_pWrite-4),    
            *(pMsg->IRDA_MSG_pWrite-3),    
            *(pMsg->IRDA_MSG_pWrite-2),    
            *(pMsg->IRDA_MSG_pWrite-1)));
#endif            
    

    switch (pIrlapCb->State)
    {
      case S_NRM:
      case P_RECV:
        // Stop Timers: if PFSet stop Final (I frame from secondary)
        // Always stop WDog (I from primary)
                
        if (PRIMARY == pIrlapCb->StationType)
        {
            if (PFBit == IRLAP_PFBIT_SET)
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
            }
        }
        else
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        }

        if (pIrlapCb->CRBit == CRBit)
        {
            StationConflict(pIrlapCb);
            pIrlapCb->State = NDM;
            return;
        }
        
        if (InvalidNs(pIrlapCb, Ns))
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRLAP: ignoring invalid NS frame\n")));
        }
        else if (InvalidNr(pIrlapCb, Nr))
        {
#if DBG_OUT
            p1 = pMsg->IRDA_MSG_pRead - 2; // Get header back
            p2 = pMsg->IRDA_MSG_pWrite + 2; // and FCS
            
            while (p1 < p2)
                DEBUGMSG(1, (TEXT("%02X "), *p1++));
            DEBUGMSG(1, (TEXT("\n")));
#endif

#ifdef TEMPERAMENTAL_SERIAL_DRIVER
            if (pIrlapCb->RxWin.FCS[Ns] == pMsg->IRDA_MSG_FCS)
                TossedDups++;
            else
                ProcessInvalidNsOrNr(pIrlapCb, PFBit);
#else
            ProcessInvalidNsOrNr(pIrlapCb, PFBit);
#endif            
        }
        else
        {
            ConfirmAckedTxMsgs(pIrlapCb, Nr);
            
            if (PFBit == IRLAP_PFBIT_SET)
            {
                InsertRxWinAndForward(pIrlapCb, pMsg, Ns);

                if (Nr != pIrlapCb->Vs)
                {
                    ResendRejects(pIrlapCb, Nr); // always turns link
                }
                else // Nr == Vs, Good Nr
                {
                    // Link will always be turned here
                    if (pIrlapCb->Vr != pIrlapCb->RxWin.End)
                    {
                        MissingRxFrames(pIrlapCb);
                    }
                    else
                    {
                        XmitTxMsgList(pIrlapCb, TRUE, NULL);
                    }
                }
            }
            else // PF Bit not set
            {
                InsertRxWinAndForward(pIrlapCb, pMsg, Ns);
            }
        }
        // Start Timers: If PFBit set, link was turned so start final
        //               WDog is always stopped, so restart
        if (PRIMARY == pIrlapCb->StationType)
        {
            if (PFBit == IRLAP_PFBIT_SET)
            {
                IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
            }
        }
        else // command from primary
        {
            IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
        }
        break;

      default:
        IFrameOtherStates(pIrlapCb, CRBit, PFBit);
    }
}
/*****************************************************************************
*
*/
BOOLEAN
InvalidNs(PIRLAP_CB pIrlapCb,
              UINT      Ns)
{
    // Valididate ns
    if (!InWindow(pIrlapCb->Vr,
       (pIrlapCb->RxWin.Start + pIrlapCb->LocalWinSize-1) % IRLAP_MOD, Ns)
        || !InWindow(pIrlapCb->RxWin.Start,
       (pIrlapCb->RxWin.Start + pIrlapCb->LocalWinSize-1) % IRLAP_MOD, Ns))
    {
        DEBUGMSG(DBG_ERROR, 
           (TEXT("IRLAP: ERROR, Invalid Ns=%d! Vr=%d, RxStrt=%d Win=%d\r\n"),
                Ns, pIrlapCb->Vr, pIrlapCb->RxWin.Start,
            pIrlapCb->LocalWinSize));
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("** INVALID Ns **")));
        return TRUE;
    }
    return FALSE;
}
/*****************************************************************************
*
*/
BOOLEAN
InvalidNr(PIRLAP_CB pIrlapCb,
          UINT Nr)
{
    if (!InWindow(pIrlapCb->TxWin.Start, pIrlapCb->Vs, Nr))
    {
        DEBUGMSG(DBG_ERROR, 
                 (TEXT("IRLAP: ERROR, Invalid Nr=%d! Vs=%d, TxStrt=%d\r\n"),
                  Nr, pIrlapCb->Vs, pIrlapCb->TxWin.Start));
        return TRUE; // Invalid Nr
    }
    return FALSE;
}
/*****************************************************************************
*
*/
BOOLEAN
InWindow(UINT Start, UINT End, UINT i)
{
    if (Start <= End)
    {
        if (i >= Start && i <= End)
            return TRUE;
    }
    else
    {
        if (i >= Start || i <= End)
            return TRUE;
    }
    return FALSE;
}
/*****************************************************************************
*
*/
VOID
ProcessInvalidNsOrNr(PIRLAP_CB pIrlapCb,
                     int PFBit)
{
    ReturnRxTxWinMsgs(pIrlapCb);

    if (PRIMARY == pIrlapCb->StationType)
    {
        if (PFBit == IRLAP_PFBIT_SET)
        {
            SendDISC(pIrlapCb);
            pIrlapCb->RetryCnt = 0;
            // F-timer will be started by caller
            GotoPCloseState(pIrlapCb);
        }
        else
        {
            pIrlapCb->State = P_DISCONNECT_PEND;
        }
    }
    else // SECONDARY
    {
        pIrlapCb->Frmr.Vs = (UCHAR) pIrlapCb->Vs;
        pIrlapCb->Frmr.Vr = (UCHAR) pIrlapCb->Vr;
        pIrlapCb->Frmr.W = 0;
        pIrlapCb->Frmr.X = 0;
        pIrlapCb->Frmr.Y = 0;
        pIrlapCb->Frmr.Z = 1; // bad NR
        if (PFBit == IRLAP_PFBIT_SET)
        {
            SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
        }
        else
        {
            pIrlapCb->State = S_ERROR;
        }
    }
}
/*****************************************************************************
*
*/
VOID
InsertRxWinAndForward(PIRLAP_CB pIrlapCb,
                      PIRDA_MSG pIrdaMsg,
                      UINT      Ns)
{
    UINT        rc = SUCCESS;
    PIRDA_MSG   pMsg;

    if (pIrlapCb->RxWin.pMsg[Ns] != NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLAP: RxFrame Ns:%d already in RxWin\n"),Ns));
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ns:%d already in window\n"), Ns));
        return;
    }

    // insert message into receive window
    pIrlapCb->RxWin.pMsg[Ns] = pIrdaMsg;
    
#ifdef TEMPERAMENTAL_SERIAL_DRIVER
    pIrlapCb->RxWin.FCS[Ns] = pIrdaMsg->IRDA_MSG_FCS;
#endif    

#if DBG_BADDRIVER
    // What if the MAC driver modifies the buffer that we may hold onto?
    {
        UINT    CheckVal = 0;
        UCHAR   *pByte = pIrdaMsg->IRDA_MSG_pRead;
        
        while (pByte != pIrdaMsg->IRDA_MSG_pWrite)
        {
            CheckVal += *pByte++;
        }
        
        *(UINT *) pIrdaMsg->IRDA_MSG_Header = CheckVal; 
    }
#endif
    // Advance RxWin.End to Ns+1 if Ns is at or beyond RxWin.End
    if (!InWindow(pIrlapCb->RxWin.Start, pIrlapCb->RxWin.End, Ns) ||
        Ns == pIrlapCb->RxWin.End)
    {
        pIrlapCb->RxWin.End = (Ns + 1) % IRLAP_MOD;
    }

    //
    // Increment reference. It may be out of sequence so
    // we'll will have to hold onto it.
    //
    
    ASSERT(pIrdaMsg->IRDA_MSG_RefCnt == 1);
    
    pIrdaMsg->IRDA_MSG_RefCnt += 1;
    
    // Forward in sequence frames starting from Vr
    pMsg = pIrlapCb->RxWin.pMsg[pIrlapCb->Vr];
    
    while (pMsg != NULL && !pIrlapCb->LocalBusy)
    {

#if DBG_BADDRIVER
    // What if the MAC driver modifies the buffer that we may hold onto?
    {
        UINT    CheckVal = 0;
        UCHAR   *pByte = pMsg->IRDA_MSG_pRead;
        
        while (pByte != pMsg->IRDA_MSG_pWrite)
        {
            CheckVal += *pByte++;
        }
        
        if (CheckVal != *(UINT *) pMsg->IRDA_MSG_Header)
        {
            DEBUGMSG(1, (TEXT("IRLAP: MAC driver has modified buffer owned by IrLAP! SEVERE ERROR\n")));
            ASSERT(0); 
        }
    }
#endif
        pMsg->Prim = IRLAP_DATA_IND;

        rc = IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg);
        
        if (rc == SUCCESS || rc == IRLMP_LOCAL_BUSY)
        {
            // Delivered successfully. Done with this message. Remove it from
            // the RxWin and return msg to MAC. Update Vr
            pIrlapCb->RxWin.pMsg[pIrlapCb->Vr] = NULL;
            
            
            ASSERT(pMsg->IRDA_MSG_RefCnt);
            
            pMsg->IRDA_MSG_RefCnt -=1;
            
            if (pMsg->IRDA_MSG_RefCnt == 0)
            {
                // if this is the current irda message then don't
                // do the data_response. It will be taken care of
                // by the caller.

                pMsg->Prim = MAC_DATA_RESP;
                IrmacDown(pIrlapCb->pIrdaLinkCb, pMsg);
            }    

            pIrlapCb->Vr = (pIrlapCb->Vr + 1) % IRLAP_MOD;
            
            pMsg = pIrlapCb->RxWin.pMsg[pIrlapCb->Vr];
            
            // LMP doesn't want anymore messages
            if (rc == IRLMP_LOCAL_BUSY)
            {
                // The receive window will be cleaned out when RNR is sent
                pIrlapCb->LocalBusy = TRUE;
            }
        }
        else
        {
            ASSERT(0);
            return;  
        }
    }
    
    if (pIrdaMsg->IRDA_MSG_RefCnt > 1)
    {
        //
        // The message was not indicated to Irlmp.
        // We'll have to copy the data out of the buffer
        // since some miniports can't handle us
        // holding onto the packets
        
        if (pIrdaMsg->DataContext)
        {
            UCHAR       *pCurRead, *pCurWrite;
            LONG_PTR    Len;
            
            pCurRead = pIrdaMsg->IRDA_MSG_pRead;
            pCurWrite = pIrdaMsg->IRDA_MSG_pWrite;
            
            Len = pCurWrite - pCurRead;
            
            ASSERT(Len <= pIrlapCb->pIrdaLinkCb->RxMsgDataSize);
            
            pIrdaMsg->IRDA_MSG_pRead = (UCHAR *) pIrdaMsg + sizeof(IRDA_MSG);
            
            ASSERT(pIrdaMsg->IRDA_MSG_pRead != pCurRead);
            
            CTEMemCopy(pIrdaMsg->IRDA_MSG_pRead, pCurRead, Len);
            
            pIrdaMsg->IRDA_MSG_pWrite = pIrdaMsg->IRDA_MSG_pRead + Len;
            
        }
    }
}
/*****************************************************************************
*
*/
VOID
ResendRejects(PIRLAP_CB pIrlapCb, UINT Nr)
{
    if (!pIrlapCb->RemoteBusy)
    {
        // Set Vs back

        for (pIrlapCb->Vs=Nr; pIrlapCb->Vs !=
                 (pIrlapCb->TxWin.End-1)%IRLAP_MOD;
             pIrlapCb->Vs = (pIrlapCb->Vs + 1) % IRLAP_MOD)
        {
            pIrlapCb->RetranCnt++;
            
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("RETRANSMISSION:")));
            SendIFrame(pIrlapCb,
                       pIrlapCb->TxWin.pMsg[pIrlapCb->Vs],
                       pIrlapCb->Vs,
                       IRLAP_PFBIT_CLEAR);
        }

        IRLAP_LOG_ACTION((pIrlapCb, TEXT("RETRANSMISSION:")));
        // Send last one with PFBit set
        SendIFrame(pIrlapCb, pIrlapCb->TxWin.pMsg[pIrlapCb->Vs],
                   pIrlapCb->Vs, IRLAP_PFBIT_SET);

        pIrlapCb->Vs = (pIrlapCb->Vs + 1) % IRLAP_MOD; // Vs == TxWin.End
    }
    else
    {
        SendRR_RNR(pIrlapCb);
    }
}
/*****************************************************************************
*
*/
VOID
ConfirmAckedTxMsgs(PIRLAP_CB pIrlapCb,
                UINT Nr)
{
    UINT        i = pIrlapCb->TxWin.Start;
    IRDA_MSG    *pMsg;

    while (i != Nr)
    {
        pMsg = pIrlapCb->TxWin.pMsg[i];
        pIrlapCb->TxWin.pMsg[i] = NULL;        
        
        if (pMsg != NULL)
        {            
            ASSERT(pMsg->IRDA_MSG_RefCnt);
            
            if (InterlockedDecrement(&pMsg->IRDA_MSG_RefCnt) == 0)
            {
                pMsg->Prim = IRLAP_DATA_CONF;
                pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_COMPLETED;
            
                IrlmpUp(pIrlapCb->pIrdaLinkCb, pMsg);
            }
            #if DBG
            else
            {
                pIrlapCb->DelayedConf++;
            }
            #endif               
        }
        
        i = (i + 1) % IRLAP_MOD;
    }
    pIrlapCb->TxWin.Start = i;
}
/*****************************************************************************
*
*/
VOID
MissingRxFrames(PIRLAP_CB pIrlapCb)
{
    int MissingFrameCnt = 0;
    int MissingFrame = -1;
    UINT i;

    i = pIrlapCb->Vr;

    // Count missing frame, determine first missing frame

    for (i = pIrlapCb->Vr; (i + 1) % IRLAP_MOD != pIrlapCb->RxWin.End;
         i = (i+1) % IRLAP_MOD)
    {
        if (pIrlapCb->RxWin.pMsg[i] == NULL)
        {
            MissingFrameCnt++;
            if (MissingFrame == -1)
            {
                MissingFrame = i;
            }
        }
    }

    // if there are missing frames send SREJ (1) or RR (more than 1)
    // and turn link around
    if (MissingFrameCnt == 1 && !pIrlapCb->LocalBusy)
    {
        // we don't want to send the SREJ when local is busy because
        // peer *MAY* interpret it as a clearing of the local busy condition
        SendSREJ(pIrlapCb, MissingFrame);
    }
    else
    {
        // The RR/RNR will serve as an implicit REJ
        SendRR_RNR(pIrlapCb); 
    }
}
/*****************************************************************************
*
*/
VOID
IFrameOtherStates(PIRLAP_CB pIrlapCb,
                  int       CRBit,
                  int       PFBit)
{
    switch (pIrlapCb->State)
    {
      case NDM:
      case DSCV_MEDIA_SENSE:
      case DSCV_QUERY:
      case DSCV_REPLY:
      case CONN_MEDIA_SENSE:
      case SNRM_SENT:
      case BACKOFF_WAIT:
      case SNRM_RECEIVED:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        return;
    }

    if (pIrlapCb->CRBit == CRBit) // should be opposite of mine
    {
        if (pIrlapCb->StationType == PRIMARY)
        {
            if (pIrlapCb->State == P_XMIT)
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->PollTimer);
            }
            else
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
            }
        }
        else
        {
            IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
        }
        StationConflict(pIrlapCb);
        pIrlapCb->State = NDM;

        return;
    }

    if (pIrlapCb->StationType == PRIMARY) // I'm PRIMARY, this is a
    {                                    // response from secondary
        switch (pIrlapCb->State)
        {
          case P_DISCONNECT_PEND:
            if (PFBit == IRLAP_PFBIT_CLEAR)
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
            }
            else
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
                SendDISC(pIrlapCb);
                pIrlapCb->RetryCnt = 0;
                IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
                GotoPCloseState(pIrlapCb);
            }
            break;

          case P_CLOSE:
            if (PFBit == IRLAP_PFBIT_CLEAR)
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
            }
            else
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->FinalTimer);
                ResendDISC(pIrlapCb);
                if (pIrlapCb->State != NDM)
                {
                    IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
                }
            }
            break;

          case S_CLOSE:
            IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
            break;

          default:
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        }
    }
    else
    {
        switch (pIrlapCb->State)
        {
          case S_DISCONNECT_PEND:
            if (IRLAP_PFBIT_SET == PFBit)
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
                SendRD(pIrlapCb);
                IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
                pIrlapCb->State = S_CLOSE;
            }
            else
            {
                IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
            }
            break;

          case S_ERROR:
            if (IRLAP_PFBIT_SET == PFBit)
            {
                SendFRMR(pIrlapCb, &pIrlapCb->Frmr);
                pIrlapCb->State = S_NRM;
            }
            else
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
                IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
            }
            break;

          case S_CLOSE:
            if (IRLAP_PFBIT_SET == PFBit)
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
                SendRD(pIrlapCb);
                IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
            }
            else
            {
                IrlapTimerStop(pIrlapCb, &pIrlapCb->WDogTimer);
                IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
            }
          default:
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignore in this state")));
        }
    }
}
/*****************************************************************************
*
*/
VOID
StationConflict(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    IMsg;
    
    PAGED_CODE();
    
    InitializeState(pIrlapCb, PRIMARY); // Primary doesn't mean anything here

    ApplyDefaultParms(pIrlapCb);
    IMsg.Prim = IRLAP_DISCONNECT_IND;
    IMsg.IRDA_MSG_DiscStatus = IRLAP_PRIMARY_CONFLICT;
    IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
}
/*****************************************************************************
*
*/
VOID
ApplyDefaultParms(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    IMsg;
    
    PAGED_CODE();

    //IndicateLinkStatus(pIrlapCb, LINK_STATUS_IDLE);
    pIrlapCb->StatusFlags = 0;
        
    pIrlapCb->Baud              = IRLAP_CONTENTION_BAUD;
    pIrlapCb->RemoteMaxTAT      = IRLAP_CONTENTION_MAX_TAT;
    pIrlapCb->RemoteDataSize    = IRLAP_CONTENTION_DATA_SIZE;
    pIrlapCb->RemoteWinSize     = IRLAP_CONTENTION_WIN_SIZE;
    pIrlapCb->RemoteNumBOFS     = IRLAP_CONTENTION_BOFS;
    pIrlapCb->ConnAddr          = IRLAP_BROADCAST_CONN_ADDR;

    pIrlapCb->NoResponse        = FALSE;

    IMsg.Prim               = MAC_CONTROL_REQ;
    IMsg.IRDA_MSG_Op        = MAC_RECONFIG_LINK;
    IMsg.IRDA_MSG_Baud      = IRLAP_CONTENTION_BAUD;
    IMsg.IRDA_MSG_NumBOFs   = IRLAP_CONTENTION_BOFS;
    IMsg.IRDA_MSG_DataSize  = IRLAP_CONTENTION_DATA_SIZE;
    IMsg.IRDA_MSG_MinTat    = 0;

    IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_CONTROL_REQ - reconfig link")));

    IrmacDown(pIrlapCb->pIrdaLinkCb, &IMsg);
}
/*****************************************************************************
*
*/
VOID
ResendDISC(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    IMsg;
    
    if (pIrlapCb->RetryCnt >= pIrlapCb->N3)
    {
        ApplyDefaultParms(pIrlapCb);
        pIrlapCb->RetryCnt = 0;
        IMsg.Prim = IRLAP_DISCONNECT_IND;
        IMsg.IRDA_MSG_DiscStatus = IRLAP_NO_RESPONSE;
        pIrlapCb->State = NDM;        
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
    }
    else
    {
        SendDISC(pIrlapCb);
        pIrlapCb->RetryCnt++;
    }
}

/*****************************************************************************
*
*/
BOOLEAN
IgnoreState(PIRLAP_CB pIrlapCb)
{
    switch (pIrlapCb->State)
    {
      case NDM:
      case DSCV_MEDIA_SENSE:
      case DSCV_QUERY:
      case DSCV_REPLY:
      case CONN_MEDIA_SENSE:
      case SNRM_SENT:
      case BACKOFF_WAIT:
      case SNRM_RECEIVED:
      case P_XMIT:
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring in this state")));
        return TRUE;
    }
    return FALSE;
}
/*****************************************************************************
*
*/
VOID
QueryTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;

    IRLAP_LOG_START((pIrlapCb, TEXT("Query timer expired")));
    
    if (pIrlapCb->State == DSCV_REPLY)
    {
        pIrlapCb->State = NDM;
    }
    else
    {
        IRLAP_LOG_ACTION((pIrlapCb, 
            TEXT("Ignoring QueryTimer Expriation in state %s"),
            IRLAP_StateStr[pIrlapCb->State]));
    }
    
    IRLAP_LOG_COMPLETE(pIrlapCb);

    return;
}
/*****************************************************************************
*
*/
VOID
SlotTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;
    IRDA_MSG    IMsg;
    
    IRLAP_LOG_START((pIrlapCb, TEXT("Slot timer expired, slot=%d"),pIrlapCb->SlotCnt+1));

    if (pIrlapCb->State == DSCV_QUERY)
    {
        pIrlapCb->SlotCnt++;
        SendDscvXIDCmd(pIrlapCb);
        if (pIrlapCb->SlotCnt < pIrlapCb->MaxSlot)
        {
            IMsg.Prim = MAC_CONTROL_REQ;
            IMsg.IRDA_MSG_Op = MAC_MEDIA_SENSE;
            IMsg.IRDA_MSG_SenseTime = IRLAP_DSCV_SENSE_TIME;
            IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_CONTROL_REQ (dscv sense)")));            
            IrmacDown(pIrlapCb->pIrdaLinkCb,&IMsg);            
        }
        else
        {
            //IndicateLinkStatus(pIrlapCb, LINK_STATUS_IDLE);
        
            pIrlapCb->GenNewAddr = FALSE;

            IMsg.Prim = IRLAP_DISCOVERY_CONF;
            IMsg.IRDA_MSG_pDevList = &pIrlapCb->DevList;
            IMsg.IRDA_MSG_DscvStatus = IRLAP_DISCOVERY_COMPLETED;

            // Change state now so IRLMP can do DISCOVERY_REQ on this thread
            pIrlapCb->State = NDM;

            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        }
    }
    else
    {
        IRLAP_LOG_ACTION((pIrlapCb, TEXT("Ignoring SlotTimer Expriation in state %s"),
                          IRLAP_StateStr[pIrlapCb->State]));
        ; // maybe return bad state ???
    }
    IRLAP_LOG_COMPLETE(pIrlapCb);
    return;
}
/*****************************************************************************
*
*/
VOID
FinalTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;
    IRDA_MSG    IMsg;
    
    IRLAP_LOG_START((pIrlapCb, TEXT("Final timer expired")));
    
    pIrlapCb->NoResponse = TRUE;
    
    pIrlapCb->FTimerExpCnt++;

    switch (pIrlapCb->State)
    {
      case SNRM_SENT:
        if (pIrlapCb->RetryCnt < pIrlapCb->N3)
        {
            pIrlapCb->BackoffTimer.Timeout = IRLAP_BACKOFF_TIME();
            IrlapTimerStart(pIrlapCb, &pIrlapCb->BackoffTimer);
            pIrlapCb->State = BACKOFF_WAIT;
        }
        else
        {
            ApplyDefaultParms(pIrlapCb);

            pIrlapCb->RetryCnt = 0;
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_NO_RESPONSE;
            pIrlapCb->State = NDM;            
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        }
        break;

      case P_RECV:
        if (pIrlapCb->RetryCnt == pIrlapCb->N2)
        {
            pIrlapCb->RetryCnt = 0; // Don't have to, do it for logger
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_NO_RESPONSE;
            pIrlapCb->State = NDM;            
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            ReturnRxTxWinMsgs(pIrlapCb);            
            ApplyDefaultParms(pIrlapCb);
        }
        else
        {
            pIrlapCb->RetryCnt++;
            IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
            SendRR_RNR(pIrlapCb);
            if (pIrlapCb->RetryCnt == pIrlapCb->N1)
            {
                pIrlapCb->StatusFlags = LF_INTERRUPTED;
                IndicateLinkStatus(pIrlapCb);
            }
        }
        break;

      case P_DISCONNECT_PEND:
        SendDISC(pIrlapCb);
        pIrlapCb->RetryCnt = 0;
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        GotoPCloseState(pIrlapCb);
        break;

      case P_CLOSE:
        if (pIrlapCb->RetryCnt >= pIrlapCb->N3)
        {
            ApplyDefaultParms(pIrlapCb);

            pIrlapCb->RetryCnt = 0; // Don't have to, do it for logger
            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_NO_RESPONSE;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            GotoNDMThenDscvOrConn(pIrlapCb);
        }
        else
        {
            pIrlapCb->RetryCnt++;
            SendDISC(pIrlapCb);
            IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        }
        break;

      default:
        IRLAP_LOG_ACTION((pIrlapCb,
                          TEXT("Ignoring Final Expriation in state %s"),
                          IRLAP_StateStr[pIrlapCb->State]));
    }
    
    IRLAP_LOG_COMPLETE(pIrlapCb);
    return;
}
/*****************************************************************************
*
*/
VOID
PollTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;

    IRLAP_LOG_START((pIrlapCb, TEXT("Poll timer expired")));
    
    if (pIrlapCb->State == P_XMIT)
    {
        SendRR_RNR(pIrlapCb);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->State = P_RECV;
    }
    else
    {
        IRLAP_LOG_ACTION((pIrlapCb,
                          TEXT("Ignoring Poll Expriation in state %s"),
                          IRLAP_StateStr[pIrlapCb->State]));
    }
    
    IRLAP_LOG_COMPLETE(pIrlapCb);    
    return;
}
/*****************************************************************************
*
*/
VOID
BackoffTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;
    
    IRLAP_LOG_START((pIrlapCb, TEXT("Backoff timer expired")));

    if (pIrlapCb->State == BACKOFF_WAIT)
    {
        SendSNRM(pIrlapCb, TRUE);
        IrlapTimerStart(pIrlapCb, &pIrlapCb->FinalTimer);
        pIrlapCb->RetryCnt += 1;
        pIrlapCb->State = SNRM_SENT;
    }
    else
    {
        IRLAP_LOG_ACTION((pIrlapCb, 
              TEXT("Ignoring BackoffTimer Expriation in this state ")));
    }
    IRLAP_LOG_COMPLETE(pIrlapCb);
    return;
}
/*****************************************************************************
*
*/
VOID
WDogTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;
    IRDA_MSG    IMsg;
    
    IRLAP_LOG_START((pIrlapCb, TEXT("WDog timer expired")));

    pIrlapCb->NoResponse = TRUE;

    switch (pIrlapCb->State)
    {
      case S_DISCONNECT_PEND:
      case S_NRM:
        pIrlapCb->WDogExpCnt++;
        // Disconnect/threshold time is in seconds
        if (pIrlapCb->WDogExpCnt * (int)pIrlapCb->WDogTimer.Timeout >=
            pIrlapCb->DisconnectTime * 1000)
        {
            pIrlapCb->State = NDM;        

            IMsg.Prim = IRLAP_DISCONNECT_IND;
            IMsg.IRDA_MSG_DiscStatus = IRLAP_NO_RESPONSE;
            IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
            
            ReturnRxTxWinMsgs(pIrlapCb);            
            ApplyDefaultParms(pIrlapCb);
        }
        else
        {
            if ((pIrlapCb->WDogExpCnt * (int) pIrlapCb->WDogTimer.Timeout >=
                 pIrlapCb->ThresholdTime * 1000) && !pIrlapCb->StatusSent)
            {
                pIrlapCb->StatusFlags = LF_INTERRUPTED;
                IndicateLinkStatus(pIrlapCb);           
                pIrlapCb->StatusSent = TRUE;
            }
            IrlapTimerStart(pIrlapCb, &pIrlapCb->WDogTimer);
        }
        break;

      case S_CLOSE:
        ApplyDefaultParms(pIrlapCb);

        IMsg.Prim = IRLAP_DISCONNECT_IND;
        IMsg.IRDA_MSG_DiscStatus = IRLAP_NO_RESPONSE;
        pIrlapCb->State = NDM;        
        IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
        break;

      default:
        IRLAP_LOG_ACTION((pIrlapCb,
                          TEXT("Ignore WDogTimer expiration in state %s"),
                          IRLAP_StateStr[pIrlapCb->State]));
    }
    IRLAP_LOG_COMPLETE(pIrlapCb);
    return;
}

/*
VOID
StatusTimerExp(PVOID Context)
{
    PIRLAP_CB   pIrlapCb = (PIRLAP_CB) Context;

    IndicateLinkStatus(pIrlapCb);
}
*/

/*****************************************************************************
*
*   @func   ret_type | func_name | funcdesc
*
*   @rdesc  return desc
*   @flag   val | desc
*
*   @parm   data_type | parm_name | description
*
*   @comm
*           comments
*
*   @ex
*           example
*/
/* !!!
void
IRLAP_PrintState()
{
#if DBG    
    DEBUGMSG(1, (TEXT("IRLAP State %s\n"), IRLAP_StateStr[pIrlapCb->State]));
#else
    DEBUGMSG(1, (TEXT("IRLAP State %d\n"), pIrlapCb->State));
#endif    
    DEBUGMSG(1,
             (TEXT("  Vs=%d Vr=%d RxWin(%d,%d) TxWin(%d,%d) TxMsgListLen=%d RxMsgFreeListLen=%d\r\n"), 
              pIrlapCb->Vs, pIrlapCb->Vr,
              pIrlapCb->RxWin.Start, pIrlapCb->RxWin.End, 
              pIrlapCb->TxWin.Start, pIrlapCb->TxWin.End,
              pIrlapCb->TxMsgList.Len, pIrlapCb->RxMsgFreeList.Len));
    
#ifdef TEMPERAMENTAL_SERIAL_DRIVER    
    DEBUGMSG(1, (TEXT("  Tossed duplicates %d\n"), TossedDups));
#endif
    
    IRMAC_PrintState();
    
    return;
}
*/
int
GetMyDevAddr(BOOLEAN New)
{
#ifndef UNDER_CE    
    int             DevAddr, NewDevAddr;
    LARGE_INTEGER   li;

    KeQueryTickCount(&li);

    NewDevAddr = (int) li.LowPart;

    DevAddr = NewDevAddr;
#else 
    int             DevAddr    = GetTickCount();
	HKEY	        hKey;
	LONG	        hRes;
	TCHAR	        KeyName[32];
    ULONG           RegDevAddr = 0;
    TCHAR           ValName[]  = TEXT("DevAddr");

    // Get the device address from the registry. If the key exists and the
    // value is 0, store a new random address. If no key, then return
    // a random address.
    _tcscpy (KeyName, COMM_REG_KEY);
	_tcscat (KeyName, TEXT("IrDA"));
    
	hRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, KeyName, 0, 0, &hKey);

    if (hRes == ERROR_SUCCESS &&
        GetRegDWORDValue(hKey, ValName, &RegDevAddr))
    {
        if (RegDevAddr == 0)
        {
            RegDevAddr = GetTickCount();
            SetRegDWORDValue(hKey, ValName, RegDevAddr);
        }
        RegCloseKey(hKey);

        DevAddr = (int) RegDevAddr;
    }
#endif

    return DevAddr;
}

VOID
StatusReq(
    PIRLAP_CB   pIrlapCb,
    IRDA_MSG    *pMsg)
{
    PIRLINK_STATUS pLinkStatus = (IRLINK_STATUS *) pMsg->IRDA_MSG_pLinkStatus;

    CTEMemCopy(pLinkStatus->ConnectedDeviceId,
               pIrlapCb->RemoteDevice.DevAddr,
               IRDA_DEV_ADDR_LEN);

    pLinkStatus->ConnectSpeed = pIrlapCb->Baud;
}

VOID 
IndicateLinkStatus(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG IMsg;
    IRLINK_STATUS   LinkStatus;
    
    CTEMemCopy(LinkStatus.ConnectedDeviceId,
               pIrlapCb->RemoteDevice.DevAddr,
               IRDA_DEV_ADDR_LEN);
    
    LinkStatus.ConnectSpeed = pIrlapCb->Baud;  
    
    if (pIrlapCb->StatusFlags & LF_INTERRUPTED)
    {
        LinkStatus.Flags = LF_INTERRUPTED;
    }
    else 
    {
        if (pIrlapCb->State >= P_XMIT)
        {    
            LinkStatus.Flags = LF_CONNECTED;
        }        
        else
        {
            LinkStatus.Flags = 0;
        }
        
        LinkStatus.Flags |= pIrlapCb->StatusFlags;
        
        pIrlapCb->StatusFlags = 0;            
    }    
    

    IMsg.Prim = IRLAP_STATUS_IND;
    IMsg.IRDA_MSG_pLinkStatus = &LinkStatus;            
    
    IrlmpUp(pIrlapCb->pIrdaLinkCb, &IMsg);
    
/*
    if (pIrlapCb->State >= P_XMIT && pIrlapCb->MonitorLink)
    {
        IrdaTimerStart(&pIrlapCb->StatusTimer);
    }    
*/    
}    
/*
VOID
IrlapGetLinkStatus(PIRLINK_STATUS pLinkStatus)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
    PIRLAP_CB       pIrlapCb = (PIRLAP_CB) pIrdaLinkCb->IrlapContext;
    
    pLinkStatus->Flags = 0;
    
    if (IrdaLinkCbList.Flink == &IrdaLinkCbList)
    {
        return;
    }       
    
    CTEMemCopy(pLinkStatus->ConnectedDeviceId,
               pIrlapCb->RemoteDevice.DevAddr,
               IRDA_DEV_ADDR_LEN);
  
    pLinkStatus->ConnectSpeed = pIrlapCb->Baud;  
    
    if (pIrlapCb->StatusFlags & LF_INTERRUPTED)
    {
        pLinkStatus->Flags = LF_INTERRUPTED;
        return;
    }
    else if (pIrlapCb->State >= P_XMIT)
    {    
        pLinkStatus->Flags = LF_CONNECTED;
    }        
    
    pLinkStatus->Flags |= pIrlapCb->StatusFlags;    
    pIrlapCb->StatusFlags = 0;    
    
    return;
}    

BOOLEAN
IrlapConnectionActive(PVOID Context)
{
    PIRLAP_CB    pIrlapCb = Context;
    
    if (pIrlapCb->State >= P_XMIT)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }        
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irftp\utils.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    utils.cpp

Abstract:



Author:

    Rahul Thombre (RahulTh) 4/30/1998

Revision History:

    4/30/1998   RahulTh

    Created this module.

    10/12/98    RahulTh

    Better error handling capabilities added : CError etc.

--*/

#include "precomp.hxx"

#define VALIDATE_SEND_COOKIE(cookie) \
    {   \
        __try   \
          { \
              *pStatus = ERROR_INVALID_DATA;    \
              if (MAGIC_ID != ((CSendProgress *)cookie)->m_dwMagicID)   \
                  return;   \
              *pStatus = ERROR_SUCCESS; \
          } \
        __except (EXCEPTION_EXECUTE_HANDLER) \
          {  \
              return;   \
          } \
    }

////////////////////////////////////////////////////////////////////////
//
//RPC Functions
//
///////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t Size)
{
    return new char[Size];
}

void __RPC_USER MIDL_user_free( void __RPC_FAR * buf)
{
    delete [] buf;
}

//
//  wireless link specific errors
//

ERROR_TO_STRING_ID g_ErrorToStringId[] =
{
    {ERROR_IRTRANP_OUT_OF_MEMORY,   IDS_ERROR_NO_MEMORY},
    {ERROR_IRTRANP_DISK_FULL,       IDS_ERROR_DISK_FULL},
    {ERROR_SCEP_CANT_CREATE_FILE,   IDS_ERROR_DISK_FULL},
    {ERROR_SCEP_ABORT,          IDS_ERROR_ABORTED},
    {ERROR_SCEP_INVALID_PROTOCOL,   IDS_ERROR_PROTOCOL},
    {ERROR_SCEP_PDU_TOO_LARGE,      IDS_ERROR_PROTOCOL},
    {ERROR_BFTP_INVALID_PROTOCOL,   IDS_ERROR_PROTOCOL},
    {ERROR_BFTP_NO_MORE_FRAGMENTS,  IDS_ERROR_PROTOCOL},
    {ERROR_SUCCESS,                 -1}
};


////////////////////////////////////////////////////////////////////
//
//Miscellaneous useful functions
//
///////////////////////////////////////////////////////////////////
int ParseFileNames (TCHAR* pszInString, TCHAR* pszFilesList, int& iCharCount)
{

    ASSERT(pszFilesList != NULL);
    ASSERT(pszInString != NULL);

    BOOL fInQuotes = FALSE;
    BOOL fIgnoreSpaces = FALSE;
    TCHAR* pszSource = pszInString;
    TCHAR* pszTarget = pszFilesList;
    int iFileCount = 0;
    TCHAR curr;

    //ignore leading whitespaces
    while(' ' == *pszSource || '\t' == *pszSource)
        pszSource++;

    iCharCount = 0;
    *pszTarget = '\0';  //precautionary measures

    if ('\0' == *pszSource)     //special case : if this was an empty string, return 0
        return iFileCount;

    //parse the string to get filenames
    while(curr = *pszSource)
    {
        if('\"' == curr)
        {
            fInQuotes = fInQuotes?FALSE:TRUE;
        }
        else if(' ' == curr && !fInQuotes)
        {
                if(!fIgnoreSpaces)
                {
                    *pszTarget++ = 0;
                    iFileCount++;
                    iCharCount++;
                    fIgnoreSpaces = TRUE;
                }
        }
        else
        {
            *pszTarget++ = curr;
            iCharCount++;
            fIgnoreSpaces = FALSE;
        }

        pszSource++;
    }

    if(' ' != *(pszSource-1))   //if there was no trailing space
    {
        *pszTarget++ = '\0';    //then the last file was not accounted for.
        iCharCount++;           //so we do it here
        iFileCount++;
    }

    *pszTarget++ = '\0';    //should have 2 terminating nulls
    iCharCount++;

    return iFileCount;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIRRegVal
//
//  Synopsis:   gets the specified registry value from the IR subtree in HKCU
//
//  Arguments:  [in] szValName : the name of the value.
//              [in] dwDefVal  : the default value to be returned if the read
//                               from the registry fails or if the value is
//                               missing.
//
//  Returns:    the actual value stored in the registry or the default value
//              if the read fails.
//
//  History:    10/27/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD GetIRRegVal (LPCTSTR szValName, DWORD dwDefVal)
{
    HKEY    hftKey = NULL;
    DWORD   iSize = sizeof(DWORD);
    DWORD   data = 0;
    DWORD   Status;

    RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Control Panel\\Infrared\\File Transfer"),
                  0, KEY_READ, &hftKey);

    if (!hftKey)
        return dwDefVal;

    Status = RegQueryValueEx (hftKey, szValName, NULL, NULL,
                              (LPBYTE)&data, &iSize);

    if (ERROR_SUCCESS != Status)
        data = dwDefVal;

    RegCloseKey (hftKey);

    return data;
}


TCHAR* GetFullPathnames (TCHAR* pszPath, //directory in which the files are located
                const TCHAR* pszFilesList, //NULL separated list of filenames
                int iFileCount,     //number of files in pszFilesList
                int& iCharCount  //number of characters in pszFilesList. also returns the number of chars in the return string
                )
{
    int iChars;
    int iPathLen = lstrlen(pszPath);
    if (pszPath[iPathLen - 1] != '\\')      //append a '\' character to the path if not already present
    {
        pszPath[iPathLen++] = '\\';
        pszPath[iPathLen] = '\0';
    }
    int iSize = (iChars = iFileCount*iPathLen + iCharCount);
    TCHAR* pszFilePathList = new TCHAR[iSize];
    TCHAR* pszTemp = pszFilePathList;

    int iLen;

    while(*pszFilesList)
    {
        lstrcpy(pszTemp, pszPath);
        pszTemp += iPathLen;
        lstrcpy(pszTemp, pszFilesList);
        iLen = lstrlen(pszFilesList);
        pszFilesList += iLen + 1;
        pszTemp += iLen + 1;
    }
    *pszTemp = '\0';    //should be terminated by 2 null characters
    iCharCount = (int)(pszTemp - pszFilePathList) + 1;      //return the actual char count of this string

    return pszFilePathList;
}

TCHAR* ProcessOneFile (TCHAR* pszPath,   //directory in which the files are located
                const TCHAR* pszFilesList, //NULL separated list of filenames
                int iFileCount,     //number of files in pszFilesList
                int& iCharCount  //number of characters in pszFilesList. also returns the number of characters in the return string
                )
{
    int iFileLen, iPathLen;
    TCHAR* pszFullFileName;

    iFileLen = lstrlen (pszFilesList);
    iPathLen = lstrlen (pszPath);
    ASSERT (iFileLen);
    ASSERT (iPathLen);

    if(':' == pszFilesList[1] //this is an absolute path starting with the drive letter;
       || ('\\' == pszFilesList[0] && '\\' == pszFilesList[1]) //UNC path
       )
    {
        pszFullFileName = new TCHAR [iFileLen + 2];
        lstrcpy (pszFullFileName, pszFilesList);
        pszFullFileName[iFileLen + 1] = '\0';   //we need to have 2 terminating nulls
        iCharCount = iFileLen + 2;
    }
    else if('\\' == pszFilesList[0]) //path relative to the root
    {
        iCharCount = iFileLen + 2 /*drive letter and colon*/ + 2 /*terminating nulls*/;
        pszFullFileName = new TCHAR [iCharCount];
        pszFullFileName[0] = pszPath[0];
        pszFullFileName[1] = pszPath[1];
        lstrcpy (pszFullFileName + 2, pszFilesList);
        pszFullFileName[iCharCount - 1] = '\0';   //we need to have 2 terminating nulls
    }
    else    //ordinary file name
    {
        iCharCount = iPathLen + iFileLen + 2;   //2 terminating nulls
        iCharCount += ('\\' == pszPath[iPathLen - 1])?0:1;  //sometimes the path does not have a \ at the end, so we need to add these ourselves
        pszFullFileName = new TCHAR [iCharCount];
        lstrcpy (pszFullFileName, pszPath);
        if('\\' != pszPath[iPathLen - 1])   //we need to add the \ ourselves
        {
            pszFullFileName[iPathLen] = '\\';
            lstrcpy(pszFullFileName + iPathLen + 1, pszFilesList);
        }
        else
            lstrcpy (pszFullFileName + iPathLen, pszFilesList);

        pszFullFileName[iCharCount - 1] = '\0'; //2  terminating nulls
    }

    return pszFullFileName;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetPrimaryAppWindow
//
//  Synopsis:   gets the handle to the main window of an existing instance of
//              irftp
//
//  Arguments:  none.
//
//  Returns:    handle to the window if it finds one. otherwise NULL.
//
//  History:    6/30/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
HWND GetPrimaryAppWindow (void)
{
    HWND hwnd = NULL;
    int i = 1;

    //try to find the window for 5 seconds.
    do
    {
        hwnd = FindWindow (L"#32770",   //the dialog class
                           MAIN_WINDOW_TITLE);
        if (hwnd)
            break;
        Sleep (500);
    } while ( i++ <= 10 );

    return hwnd;
}

/////////////////////////////////////////////////////////////////////////
// Initialize the RPC server
////////////////////////////////////////////////////////////////////////
BOOL InitRPCServer (void)
{
    DWORD Status;

    Status = RpcServerRegisterIf( _IrNotifications_v1_0_s_ifspec, 0, 0);
    if (Status)
        {
        return FALSE;
        }

    Status = RpcServerUseAllProtseqsIf( RPC_C_PROTSEQ_MAX_REQS_DEFAULT, _IrNotifications_v1_0_s_ifspec, 0);
    if (Status)
        {
        return FALSE;
        }

    Status = RpcServerListen( 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if (Status)
        {
        return FALSE;
        }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////
//Connect to the RPC server running on the first instance of the app
//this function is called only if this is not the first instance of the app
//////////////////////////////////////////////////////////////////////////////////
RPC_BINDING_HANDLE GetRpcHandle (void)
{
    DWORD Status;
    RPC_BINDING_HANDLE Binding;

    Status = RpcBindingFromStringBinding(L"ncalrpc:", &Binding);

    if (Status)
        return NULL;
    else
        return Binding;

}

///////////////////////////////////////////////////////////////////////////////////////
// RPC Server functions
//////////////////////////////////////////////////////////////////////////////////////
void _PopupUI (handle_t Binding)
{
    int nResponse;

    appController->PostMessage(WM_APP_TRIGGER_UI);
    return;
}

void _InitiateFileTransfer (handle_t Binding, ULONG lSize, wchar_t __RPC_FAR lpszFilesList[])
{
        COPYDATASTRUCT cStruct;
        cStruct.dwData = lSize;
        cStruct.cbData = lSize * sizeof(wchar_t);
        cStruct.lpData = (LPVOID)(lpszFilesList);
        appController->SendMessage(WM_COPYDATA, (WPARAM)NULL, (LPARAM)(&cStruct));
}

void _DisplaySettings (handle_t Binding)
{
    appController->PostMessage(WM_APP_TRIGGER_SETTINGS);
}

void _UpdateSendProgress (
                          handle_t      RpcBinding,
                          COOKIE        Cookie,
                          wchar_t       CurrentFile[],
                          __int64       BytesInTransfer,
                          __int64       BytesTransferred,
                          error_status_t*       pStatus
                          )
{
    VALIDATE_SEND_COOKIE (Cookie)

    CSendProgress* progressDlg = (CSendProgress*)Cookie;
    int percentComplete;

    if (BytesInTransfer)
        {
        percentComplete = (int)((BytesTransferred*100.0)/BytesInTransfer);
        }
    else
        {
        percentComplete = 100;
        }

    progressDlg->PostMessage(WM_APP_UPDATE_PROGRESS, (WPARAM) 0, (LPARAM) percentComplete);
    if (100 > percentComplete)
    {
       progressDlg->SetCurrentFileName (CurrentFile);
    }
    *pStatus = 0;
}

void _OneSendFileFailed(
                       handle_t         RpcBinding,
                       COOKIE           Cookie,
                       wchar_t          FileName[],
                       error_status_t   ErrorCode,
                       FAILURE_LOCATION Location,
                       error_status_t * pStatus
                       )
{
    VALIDATE_SEND_COOKIE (Cookie)

    struct SEND_FAILURE_DATA Data;

    COPYDATASTRUCT cStruct;
    CWnd* progressDlg = (CWnd*)Cookie;

    lstrcpy(Data.FileName, FileName);
    Data.Location = Location;
    Data.Error    = ErrorCode;

    cStruct.cbData = sizeof(SEND_FAILURE_DATA);
    cStruct.lpData = &Data;

    progressDlg->SendMessage(WM_COPYDATA, (WPARAM) 0, (LPARAM)(&cStruct));
    *pStatus = 0;
}

void _SendComplete(
                   handle_t             RpcBinding,
                   COOKIE               Cookie,
                   __int64              BytesTransferred,
                   error_status_t*   pStatus
                   )
{
    VALIDATE_SEND_COOKIE (Cookie)

    CWnd* progressDlg = (CWnd*)Cookie;
    progressDlg->PostMessage(WM_APP_SEND_COMPLETE);
    *pStatus = 0;
}

error_status_t
_ReceiveInProgress(
    handle_t        RpcBinding,
    wchar_t         MachineName[],
    COOKIE *        pCookie,
    boolean         bSuppressRecvConf
    )
{
    struct MSG_RECEIVE_IN_PROGRESS msg;

    msg.MachineName = MachineName;
    msg.pCookie     = pCookie;
    msg.bSuppressRecvConf = bSuppressRecvConf;
    msg.status      = ~0UL;

    appController->SendMessage( WM_APP_RECV_IN_PROGRESS, (WPARAM) &msg );

    return msg.status;
}

error_status_t
_GetPermission(
                      handle_t         RpcBinding,
                      COOKIE           Cookie,
                      wchar_t          Name[],
                      boolean          fDirectory
                      )
{
    struct MSG_GET_PERMISSION msg;

    msg.Cookie     = Cookie;
    msg.Name       = Name;
    msg.fDirectory = fDirectory;
    msg.status     = ~0UL;

    appController->SendMessage( WM_APP_GET_PERMISSION, (WPARAM) &msg );

    return msg.status;
}

error_status_t
_ReceiveFinished(
              handle_t        RpcBinding,
              COOKIE          Cookie,
              error_status_t  Status
              )
{
    struct MSG_RECEIVE_FINISHED msg;

    msg.Cookie     = Cookie;
    msg.ReceiveStatus = Status;
    msg.status     = ~0UL;

    appController->SendMessage( WM_APP_RECV_FINISHED, (WPARAM) &msg );

    return msg.status;
}

void _DeviceInRange(
                    handle_t RpcBinding,
                    POBEX_DEVICE_LIST device,
                    error_status_t* pStatus
                    )
{
    appController->PostMessage (WM_APP_KILL_TIMER);
    BOOL fLinkOnDesktop = (0 != InterlockedIncrement(&g_lLinkOnDesktop));
    if(!fLinkOnDesktop)
        CreateLinks();
    else
        InterlockedDecrement(&g_lLinkOnDesktop); //don't allow the value to exceed 0

    g_deviceList = device;
    *pStatus = 0;
}

void _NoDeviceInRange(
                      handle_t RpcBinding,
                      error_status_t* pStatus
                      )
{
    RemoveLinks();
    InterlockedDecrement(&g_lLinkOnDesktop);
    g_deviceList = NULL;
    if (0 == g_lUIComponentCount)
        appController->PostMessage (WM_APP_START_TIMER);
    *pStatus = 0;
}

void _Message(
              handle_t RpcBinding,
              wchar_t   String[]
              )
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    CString szTitle;

    szTitle.LoadString (IDS_CAPTION);

    InterlockedIncrement (&g_lUIComponentCount);
    ::MessageBox (NULL, String, (LPCTSTR) szTitle, MB_OK);
    BOOL fNoUIComponents = (0 == InterlockedDecrement (&g_lUIComponentCount));
    if (appController && fNoUIComponents &&  ! g_deviceList.GetDeviceCount())
    {
        //there are no UI components displayed and there are no devices in
        //range. Start the timer. If the timer expires, the app. will quit.
        appController->PostMessage (WM_APP_START_TIMER);
    }

}

error_status_t
_ShutdownUi(handle_t RpcBinding)
{
    appController->PostMessage( WM_CLOSE );
    return 0;
}

error_status_t
_ShutdownRequested(
    handle_t RpcBinding,
    boolean * pAnswer
    )
{
    WCHAR   pwszCaption [50];
    WCHAR pwszMessage [MAX_PATH];

    *pAnswer = TRUE;

    if (appController)
    {
        appController->PostMessage (WM_APP_KILL_TIMER);
    }

    if (! ::LoadString ( g_hInstance, IDS_CAPTION, pwszCaption, 50))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (! ::LoadString ( g_hInstance, IDS_SHUTDOWN_MESSAGE, pwszMessage, MAX_PATH))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //display a message box with YES / NO buttons
    if (IDYES == ::MessageBox (appController->m_hWnd, pwszMessage, pwszCaption,
                        MB_ICONEXCLAMATION | MB_YESNO | MB_SYSTEMMODAL | MB_SETFOREGROUND))
    {
        *pAnswer = TRUE;
    }
    else
    {
        *pAnswer = FALSE;
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//Create links on the desktop and in the Send To menu to this executable file

void CreateLinks(void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    TCHAR lpszFullExeName [MAX_PATH];
    TCHAR lpszShortcutName[MAX_PATH];
    CString szDesc;

    szDesc.LoadString (IDS_SHTCUT_DESC);

    //create the desktop link
    if (GetShortcutInfo(lpszShortcutName, lpszFullExeName))
        CreateShortcut (lpszFullExeName, lpszShortcutName, (LPCTSTR) szDesc);

    //create the send to link
    if (GetSendToInfo(lpszShortcutName, lpszFullExeName))
        CreateShortcut (lpszFullExeName, lpszShortcutName, (LPCTSTR) szDesc);
}

//////////////////////////////////////////////////////////////////////////////
// CreateShortcut - uses the shell's IShellLink and IPersistFile interfaces
//   to create and store a shortcut to the specified object.
HRESULT CreateShortcut (LPCTSTR lpszExe, LPCTSTR lpszLink, LPCTSTR lpszDesc)
{
    HRESULT hres;
    IShellLink* psl;

    hres = CoInitialize(NULL);

	if (FAILED(hres))
		return hres;

    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID*)&psl);
    if (SUCCEEDED(hres)) {
        IPersistFile* ppf;

        // Set the path to the shortcut target and add the
        // description.
        psl->SetPath(lpszExe);
        psl->SetDescription(lpszDesc);

       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
        hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);

        if (SUCCEEDED(hres)) {
           // Save the link by calling IPersistFile::Save.
            hres = ppf->Save(lpszLink, TRUE);
            ppf->Release();
        }
        psl->Release();
    }
    return SUCCEEDED(hres)?S_OK:E_FAIL;
}

void RemoveLinks (void)
{
        TCHAR lpszShortcutName[2 * MAX_PATH];
        TCHAR lpszFullExeName[2 * MAX_PATH];

        //delete the desktop shortcut
        if(GetShortcutInfo (lpszShortcutName, lpszFullExeName))
            DeleteFile (lpszShortcutName);

        //delete the send to shortcut
        if (GetSendToInfo (lpszShortcutName, lpszFullExeName))
            DeleteFile (lpszShortcutName);
}

BOOL GetShortcutInfo (LPTSTR lpszShortcutName, LPTSTR lpszFullExeName)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    *lpszShortcutName = '\0';       //precautionary measures
    *lpszFullExeName = '\0';
    CString     szExe;
    CString     szShtCut;
    int         len;

    szExe.LoadString (IDS_EXE);
    szShtCut.LoadString (IDS_DESKTOP_SHTCUT);

    len = GetSystemDirectory (lpszFullExeName, MAX_PATH);
    if(0 == len)
        return FALSE;
    lstrcat(lpszFullExeName, LPCTSTR (szExe));

    if('\0' == g_lpszDesktopFolder[0])  //try once again if we had failed before, or maybe this is the first time
    {
        if (FAILED(SHGetSpecialFolderPath(NULL, g_lpszDesktopFolder,
                                          CSIDL_DESKTOPDIRECTORY, 0)))
        {
            g_lpszDesktopFolder[0] = '\0';  //we failed so give up.
            return FALSE;
        }
    }


    lstrcpy (lpszShortcutName, g_lpszDesktopFolder);
    lstrcat (lpszShortcutName, (LPCTSTR) szShtCut);

    return TRUE;
}

BOOL GetSendToInfo (LPTSTR lpszSendToName, LPTSTR lpszFullExeName)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    *lpszSendToName = '\0';     //precautionary measures
    *lpszFullExeName = '\0';
    CString     szExe;
    CString     szSendTo;
    int len;

    szExe.LoadString (IDS_EXE);
    szSendTo.LoadString (IDS_SENDTO_SHTCUT);

    len = GetSystemDirectory (lpszFullExeName, MAX_PATH);
    if (0 == len)
        return FALSE;
    lstrcat (lpszFullExeName, (LPCTSTR) szExe);

    if ('\0' == g_lpszSendToFolder[0])     //try once again if we had failed before, or maybe this is the first time
    {
        if (FAILED(SHGetSpecialFolderPath(NULL, g_lpszSendToFolder,
                                          CSIDL_SENDTO, 0)))
        {
            g_lpszSendToFolder[0] = '\0';
            return FALSE;
        }
    }

    lstrcpy (lpszSendToName, g_lpszSendToFolder);
    lstrcat (lpszSendToName, (LPCTSTR) szSendTo);

    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::ConstructMessage
//
//  Synopsis:   this is an internal helper function that constructs a message
//              from the available error codes it is called by both ShowMessage
//
//  Arguments:  [in] argList : the va_list of arguments
//              [out] szErrMsg : the formatted error message
//
//  Returns:    nothing
//
//  History:    10/2/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CError::ConstructMessage (va_list argList, CString& szErrMsg)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    TCHAR   lpszMessage[2048];

    szErrMsg.LoadString (m_msgID);

    wvsprintf (lpszMessage, (LPCTSTR) szErrMsg, argList);

    szErrMsg = lpszMessage;

    if (ERROR_SUCCESS != m_winErr)
    {
        LPVOID lpMsgBuf;
        DWORD dwRet;
        dwRet = ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL,
                                 m_winErr,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPTSTR) &lpMsgBuf,
                                 0,
                                 NULL
                               );
        if (dwRet)
        {
            szErrMsg += TEXT("\n\n");
            szErrMsg += (LPCTSTR) lpMsgBuf;
            LocalFree (lpMsgBuf);
        }
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CError::ShowMessage
//
//  Synopsis:   displays an error message in a message box based on the
//              members of the object
//
//  Arguments:  message id for the error + more
//
//  Returns:    the return value of the message box
//
//  History:    10/1/1998  RahulTh  created
//
//  Notes:      if the resultant message is longer than 2048 characters
//              then result is unpredictable and may also cause AVs.
//              but this is a limitation of wvsprintf. However, this is not
//              so bad since we can make sure that we do not have any error
//              message that exceed this self imposed limit
//
//---------------------------------------------------------------------------
int CError::ShowMessage (UINT errID, ...)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    va_list argList;
    CString szErrMsg;
    CString szTitle;

    m_msgID = errID;    //update the message ID with the new one

    szTitle.LoadString (m_titleID);

    va_start (argList, errID);
    ConstructMessage (argList, szErrMsg);
    va_end (argList);

    return ::MessageBox (m_hWndParent, (LPCTSTR)szErrMsg,
                         (LPCTSTR) szTitle, m_nStyle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlap\irlapio.h ===
/*****************************************************************************
* 
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlapio.h 
*
*  Description: prototypes for IRLAP I/O routines 
*
*  Author: mbert
*
*  Date:   4/25/95
*
*/
void SetMsgPointers(PIRLAP_CB, PIRDA_MSG);
VOID SendDscvXIDCmd(PIRLAP_CB);
VOID SendDscvXIDRsp(PIRLAP_CB);
VOID SendSNRM(PIRLAP_CB, BOOLEAN);
VOID SendUA(PIRLAP_CB, BOOLEAN);
VOID SendDM(PIRLAP_CB);
VOID SendRD(PIRLAP_CB);
VOID SendRR(PIRLAP_CB);
VOID SendRR_RNR(PIRLAP_CB);
VOID SendDISC(PIRLAP_CB);
VOID SendRNRM(PIRLAP_CB);
VOID SendIFrame(PIRLAP_CB, PIRDA_MSG, int, int);
VOID SendSREJ(PIRLAP_CB, int);
VOID SendREJ(PIRLAP_CB);
VOID SendFRMR(PIRLAP_CB, IRLAP_FRMR_FORMAT *);
VOID SendUIFrame(PIRLAP_CB, PIRDA_MSG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlap\irlapio.c ===
/*****************************************************************************
* 
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlapio.c 
*
*  Description: IRLAP I/O routines 
*
*  Author: mbert
*
*  Date:   4/25/95
*
*/
#include <irda.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlmp.h>
#include <irlapp.h>
#include <irlapio.h>
#include <irlaplog.h>

extern UCHAR IrlapBroadcastDevAddr[];

__inline
VOID
SendFrame(PIRLAP_CB pIrlapCb, PIRDA_MSG pMsg)
{
    pMsg->Prim = MAC_DATA_REQ;
  
	IrmacDown(pIrlapCb->pIrdaLinkCb, pMsg);

//    IRLAP_LOG_ACTION((pIrlapCb, TEXT("MAC_DATA_REQ: %s"), FrameToStr(pMsg)));

}

/*****************************************************************************
* 
*	@func	ret_type | func_name | funcdesc
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*	@parm	data_type | parm_name | description
*               
*	@comm 
*           comments
*/
VOID
ClearRxWindow(PIRLAP_CB pIrlapCb)
{
    UINT i;
    
    // Remove everything from Rx window
    for (i = pIrlapCb->Vr; i != pIrlapCb->RxWin.End; i = (i+1) % IRLAP_MOD)
    {   
        if (pIrlapCb->RxWin.pMsg[i] != NULL)
        {
            
            ASSERT(pIrlapCb->RxWin.pMsg[i]->IRDA_MSG_RefCnt);
        
            pIrlapCb->RxWin.pMsg[i]->IRDA_MSG_RefCnt -= 1;
            
            if (pIrlapCb->RxWin.pMsg[i]->IRDA_MSG_RefCnt == 0)
            {
                pIrlapCb->RxWin.pMsg[i]->Prim = MAC_DATA_RESP;
                IrmacDown(pIrlapCb->pIrdaLinkCb, pIrlapCb->RxWin.pMsg[i]);
            }    

            pIrlapCb->RxWin.pMsg[i] = NULL;     
        }
        pIrlapCb->RxWin.End = pIrlapCb->Vr;
    }
}
/*****************************************************************************
* 
*	@func	ret_type | func_name | funcdesc
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*	@parm	data_type | parm_name | description
*               
*	@comm 
*           comments
*/
VOID
SendDscvXIDCmd(PIRLAP_CB pIrlapCb)
{
	UINT                    rc = SUCCESS;
	IRLAP_XID_DSCV_FORMAT   XIDFormat;
	CHAR                    *DscvInfo;
    int                     DscvInfoLen;
    IRDA_MSG                *pIMsg;

	RtlCopyMemory(XIDFormat.SrcAddr, pIrlapCb->LocalDevice.DevAddr,
                  IRDA_DEV_ADDR_LEN);
	RtlCopyMemory(XIDFormat.DestAddr, IrlapBroadcastDevAddr,
                  IRDA_DEV_ADDR_LEN);

	XIDFormat.NoOfSlots = IRLAP_SLOT_FLAG(pIrlapCb->MaxSlot);
	XIDFormat.GenNewAddr = pIrlapCb->GenNewAddr;
    XIDFormat.Reserved = 0;
    
	if (pIrlapCb->SlotCnt == pIrlapCb->MaxSlot)
	{
		DscvInfo = pIrlapCb->LocalDevice.DscvInfo;
        DscvInfoLen = pIrlapCb->LocalDevice.DscvInfoLen;
		XIDFormat.SlotNo = IRLAP_END_DSCV_SLOT_NO;
	}
	else
	{
		DscvInfo = NULL;
        DscvInfoLen = 0;
		XIDFormat.SlotNo = (UCHAR) pIrlapCb->SlotCnt;
	}
	XIDFormat.Version = (UCHAR) pIrlapCb->LocalDevice.IRLAP_Version;		

	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;
    	
	pIMsg->IRDA_MSG_pWrite = Format_DscvXID(pIMsg, 
                                              IRLAP_BROADCAST_CONN_ADDR,
                                              IRLAP_CMD, IRLAP_PFBIT_SET,
                                              &XIDFormat, DscvInfo, 
                                              DscvInfoLen);
    
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: DscvXidCmd")));
    
	SendFrame(pIrlapCb, pIMsg);
}
/****************************************************************************S*
* 
*	@func	ret_type | func_name | funcdesc
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*	@parm	data_type | parm_name | description
*               
*	@comm 
*           comments
*/
VOID
SendDscvXIDRsp(PIRLAP_CB pIrlapCb)
{
	IRLAP_XID_DSCV_FORMAT   XIDFormat;
    IRDA_MSG                *pIMsg;
    
    XIDFormat.GenNewAddr = pIrlapCb->GenNewAddr;
	if (pIrlapCb->GenNewAddr)
	{
		StoreULAddr(pIrlapCb->LocalDevice.DevAddr, GetMyDevAddr(TRUE));
        pIrlapCb->GenNewAddr = FALSE;
	}
	RtlCopyMemory(XIDFormat.SrcAddr, pIrlapCb->LocalDevice.DevAddr,
                  IRDA_DEV_ADDR_LEN);
	RtlCopyMemory(XIDFormat.DestAddr, pIrlapCb->RemoteDevice.DevAddr,
                  IRDA_DEV_ADDR_LEN);
	XIDFormat.NoOfSlots = IRLAP_SLOT_FLAG(pIrlapCb->RemoteMaxSlot);
    XIDFormat.Reserved = 0;
	XIDFormat.SlotNo = (UCHAR) pIrlapCb->RespSlot;
	XIDFormat.Version = (UCHAR) pIrlapCb->LocalDevice.IRLAP_Version;

	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_DscvXID(
        pIMsg, 
        IRLAP_BROADCAST_CONN_ADDR,
        IRLAP_RSP, IRLAP_PFBIT_SET,
        &XIDFormat, 
        pIrlapCb->LocalDevice.DscvInfo,
        pIrlapCb->LocalDevice.DscvInfoLen);
    
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: DscvXidRsp")));
        
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendSNRM | formats a SNRM frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*	@parm	UCHAR | ConnAddr | Connection address
*               
*	@comm 
*           The ConnAddr can be different than that in the control block.
*			For reset, its the same, but set to broadcast for initial 
*			connection.
*/
VOID
SendSNRM(PIRLAP_CB pIrlapCb, BOOLEAN SendQos)
{
    IRDA_QOS_PARMS *pQos    =   NULL;
    int            ConnAddr =   pIrlapCb->ConnAddr;
    IRDA_MSG                    *pIMsg;
    
    if (SendQos)
    {
        ConnAddr = IRLAP_BROADCAST_CONN_ADDR;
        pQos = &pIrlapCb->LocalQos;
    }
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_SNRM(pIMsg, ConnAddr, 
                                         IRLAP_CMD, 
                                         IRLAP_PFBIT_SET, 
                                         pIrlapCb->LocalDevice.DevAddr,
                                         pIrlapCb->RemoteDevice.DevAddr,
                                         pIrlapCb->ConnAddr,
                                         pQos);
                                         	
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: SNRM")));
                                             
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendUA | formats a UA frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
*
*	@parm	BOOLEAN | SendQos | Send the Qos  
*               
*	@comm 
*           comments
*/
VOID
SendUA(PIRLAP_CB pIrlapCb, BOOLEAN SendQos)
{
	IRDA_QOS_PARMS NegQos;
    IRDA_QOS_PARMS *pNegQos = NULL;
    UCHAR *pSrcAddr = NULL;
    UCHAR *pDestAddr = NULL;
    IRDA_MSG *pIMsg;

	if (SendQos)
	{
		// Put all parms (type 0 and 1) in NegQos
		RtlCopyMemory(&NegQos, &pIrlapCb->LocalQos, sizeof(IRDA_QOS_PARMS));
		// Overwrite type 0 parameters that have already been negotiated
		NegQos.bfBaud = pIrlapCb->NegotiatedQos.bfBaud;
		NegQos.bfDisconnectTime = pIrlapCb->NegotiatedQos.bfDisconnectTime;
        pNegQos = &NegQos;
	}

    // This will be moved into the "if" above when the spec is clarified
    pSrcAddr = pIrlapCb->LocalDevice.DevAddr;
    pDestAddr = pIrlapCb->RemoteDevice.DevAddr;
    //------------------------------------------------------------------

	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_UA(pIMsg, 
                                       pIrlapCb->ConnAddr,
                                       IRLAP_RSP, 
                                       IRLAP_PFBIT_SET, 
                                       pSrcAddr, pDestAddr, pNegQos);

    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: UA")));
        
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendDM | formats a DM frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendDM(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    *pIMsg;
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_DM(pIMsg, 
                                       pIrlapCb->ConnAddr,
                                       IRLAP_RSP, 
                                       IRLAP_PFBIT_SET);
                                       
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: DM")));	
    
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendRD | formats a RD frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendRD(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG    *pIMsg;
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_RD(pIMsg, 
                                       pIrlapCb->ConnAddr,
                                       IRLAP_RSP, 
                                       IRLAP_PFBIT_SET);
	
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: RD")));
        
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendRR | formats a RR frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendRR(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG *pIMsg;
    
    ClearRxWindow(pIrlapCb);
    
    pIrlapCb->RxWin.Start = pIrlapCb->Vr; // RxWin.Start = what we've acked

	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_RR(pIMsg, pIrlapCb->ConnAddr,
									   pIrlapCb->CRBit, IRLAP_PFBIT_SET,
									   pIrlapCb->Vr);
	
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: RR")));
        
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendRNR | formats a RNR frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendRR_RNR(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG *pIMsg;
    
    UCHAR    *(*pFormatRR_RNR)();
    
    if (pIrlapCb->LocalBusy)
    {
        pFormatRR_RNR = Format_RNR;
    }
    else
    {
        pFormatRR_RNR = Format_RR;
    }
    
    ClearRxWindow(pIrlapCb);
    
    pIrlapCb->RxWin.Start = pIrlapCb->Vr; // RxWin.Start = what we've acked

	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

    pIMsg->IRDA_MSG_pWrite = (*pFormatRR_RNR)(pIMsg, pIrlapCb->ConnAddr,
                                            pIrlapCb->CRBit, IRLAP_PFBIT_SET,
                                            pIrlapCb->Vr);	
    
    IRLAP_LOG_ACTION((pIrlapCb, (TEXT("Tx: %s"), pFormatRR_RNR == Format_RNR? TEXT("RNR"):TEXT("RR"))));
    
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendDISC | formats a DISC frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendDISC(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG *pIMsg;
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;
   
	pIMsg->IRDA_MSG_pWrite = Format_DISC(pIMsg, pIrlapCb->ConnAddr,
										 IRLAP_CMD, IRLAP_PFBIT_SET);
	
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: DISC")));
    
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendRNRM | formats a RNRM frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendRNRM(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG *pIMsg;
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;
   
	pIMsg->IRDA_MSG_pWrite = Format_RNRM(pIMsg, pIrlapCb->ConnAddr,
										 IRLAP_RSP, IRLAP_PFBIT_SET);
	    
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: RNRM")));
	
    SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendREJ | formats a REJ frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*               
*	@comm 
*           comments
*/
VOID
SendREJ(PIRLAP_CB pIrlapCb)
{
    IRDA_MSG *pIMsg;
    
    ClearRxWindow(pIrlapCb);
    
    pIrlapCb->RxWin.Start = pIrlapCb->Vr; // RxWin.Start = what we've acked

	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

	pIMsg->IRDA_MSG_pWrite = Format_REJ(pIMsg, pIrlapCb->ConnAddr,
                                        pIrlapCb->CRBit, IRLAP_PFBIT_SET,
                                        pIrlapCb->Vr);	
    
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: REJ")));
    
	SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendSREJ | formats a SREJ frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*   @parm   int | Nr | Nr to be placed in SREJ frame
*               
*	@comm 
*           comments
*/
VOID
SendSREJ(PIRLAP_CB pIrlapCb, int Nr)
{
    IRDA_MSG *pIMsg;
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;
   
	pIMsg->IRDA_MSG_pWrite = Format_SREJ(pIMsg, pIrlapCb->ConnAddr,
										 pIrlapCb->CRBit, IRLAP_PFBIT_SET,
                                         Nr);
	
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: SREJ")));
	
    SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendFRMR | formats a FRMR frame and sends it
*
*	@rdesc  SUCCESS, otherwise one of the following errors:
*   @flag   val | desc
* 
*   @parm   int | Nr | Nr to be placed in SREJ frame
*               
*	@comm 
*           comments
*/
VOID
SendFRMR(PIRLAP_CB pIrlapCb, IRLAP_FRMR_FORMAT *pFRMRFormat)
{
    IRDA_MSG *pIMsg;
    
	if (!(pIMsg = AllocTxMsg(pIrlapCb->pIrdaLinkCb)))
        return;

    pIMsg->IRDA_MSG_pWrite = Format_FRMR(pIMsg, pIrlapCb->ConnAddr, 
                                         pIrlapCb->CRBit, IRLAP_PFBIT_SET,
                                         pFRMRFormat);
        
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: FRMR")));
    
    SendFrame(pIrlapCb, pIMsg);
}
/*****************************************************************************
* 
*	@func	UINT | SendIFrame | Builds and sends an I frame to MAC 
*
*	@rdesc  SUCCESS otherwise one of the following errors:
*   @flag   val | desc
* 
*	@parm   | | 
*               
*	@comm 
*           comments
*/	
VOID
SendIFrame(PIRLAP_CB pIrlapCb, PIRDA_MSG pMsg, int Ns, int PFBit)
{
    if (NULL == pMsg)
    {
        ASSERT(0);
        return; // LOG AN ERROR !!!
    }

    ClearRxWindow(pIrlapCb);
    
    pIrlapCb->RxWin.Start = pIrlapCb->Vr; // RxWin.Start = what we've acked
    
    (void) Format_I(pMsg, pIrlapCb->ConnAddr, pIrlapCb->CRBit, PFBit,
                    pIrlapCb->Vr, Ns);
 
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: IFrame pMsg:%X"), pMsg));
    
    InterlockedIncrement(&pMsg->IRDA_MSG_RefCnt);

#if DBG_CHECKSUM
    // print first and last 4 bytes of frame to help isolate 
    // data corruption problem. Should be used with sledge
    if ((pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead) > 3)
        DEBUGMSG(1, ("T(%X): %c%c%c%c, %c%c%c%c\n",
            pMsg->IRDA_MSG_pRead,
            *(pMsg->IRDA_MSG_pRead),    
            *(pMsg->IRDA_MSG_pRead+1),    
            *(pMsg->IRDA_MSG_pRead+2),    
            *(pMsg->IRDA_MSG_pRead+3),
            *(pMsg->IRDA_MSG_pWrite-4),    
            *(pMsg->IRDA_MSG_pWrite-3),    
            *(pMsg->IRDA_MSG_pWrite-2),    
            *(pMsg->IRDA_MSG_pWrite-1)));
#endif            
                                
    SendFrame(pIrlapCb, pMsg);
    
    pMsg->IRDA_MSG_pHdrRead +=2; // uglyness.. chop header in case frame
                                 // requires retransmission
    return;
}
/*****************************************************************************
* 
*	@func	UINT | SendUIFrame | Builds and sends an UI frame to MAC 
*
*	@rdesc  SUCCESS otherwise one of the following errors:
*   @flag   val | desc
* 
*	@parm   | | 
*               
*	@comm 
*           comments
*/	
VOID
SendUIFrame(PIRLAP_CB pIrlapCb, PIRDA_MSG pMsg)
{
    if (NULL == pMsg)
    {
        ASSERT(0);
        return;        
    }
    (void) Format_UI(pMsg, pIrlapCb->ConnAddr,
                     pIrlapCb->CRBit,IRLAP_PFBIT_SET);
    
    InterlockedIncrement(&pMsg->IRDA_MSG_RefCnt);    
    
    IRLAP_LOG_ACTION((pIrlapCb, TEXT("Tx: UIFrame")));
    
    SendFrame(pIrlapCb, pMsg);
}
/*****************************************************************************
* 
*	@func	UINT | _IRLMP_Up | Adds logging to the IRLMP_Up
*
*	@rdesc  returns of IRLMP_Up
* 
*	@parm	PIRDA_MSG  | pMsg | pointer to IRDA message 
*               
*	@comm 
*           comments
*/
/*
UINT
_IRLMP_Up(PIRDA_MSG pMsg)
{
	IRLAP_LOG_ACTION((TEXT("%s%s"), IRDA_PrimStr[pMsg->Prim],
	   pMsg->Prim == IRLAP_DISCOVERY_CONF ?
			 IRDA_StatStr[pMsg->IRDA_MSG_DscvStatus] :
	   pMsg->Prim == IRLAP_CONNECT_CONF ?
					 IRDA_StatStr[pMsg->IRDA_MSG_ConnStatus] :
	   pMsg->Prim == IRLAP_DISCONNECT_IND ?
					 IRDA_StatStr[pMsg->IRDA_MSG_DiscStatus] : 
       pMsg->Prim == IRLAP_DATA_CONF || pMsg->Prim == IRLAP_UDATA_CONF ?
                     IRDA_StatStr[pMsg->IRDA_MSG_DataStatus] : TEXT("")));	

	return (IRLMP_Up(pMsg));
}
*/

UCHAR *
BuildTuple(UCHAR *pBuf, UCHAR Pi, UINT BitField) 
{
    *pBuf++ = Pi;
    
    if (BitField > 0xFF)
    {
        *pBuf++ = 2; // Pl
        *pBuf++ = (UCHAR) (BitField);        
        *pBuf++ = (UCHAR) (BitField >> 8);        
    }
    else
    {
        *pBuf++ = 1; // Pl
        *pBuf++ = (UCHAR) (BitField);
    }
    return pBuf;
}
        
UCHAR *
BuildNegParms(UCHAR *pBuf, IRDA_QOS_PARMS *pQos)
{
    pBuf = BuildTuple(pBuf, QOS_PI_BAUD,        pQos->bfBaud);
    pBuf = BuildTuple(pBuf, QOS_PI_MAX_TAT,     pQos->bfMaxTurnTime);
	pBuf = BuildTuple(pBuf, QOS_PI_DATA_SZ,     pQos->bfDataSize);
	pBuf = BuildTuple(pBuf, QOS_PI_WIN_SZ,      pQos->bfWindowSize);
	pBuf = BuildTuple(pBuf, QOS_PI_BOFS,        pQos->bfBofs);
	pBuf = BuildTuple(pBuf, QOS_PI_MIN_TAT,     pQos->bfMinTurnTime);
	pBuf = BuildTuple(pBuf, QOS_PI_DISC_THRESH, pQos->bfDisconnectTime);

	return pBuf;
}

void
StoreULAddr(UCHAR Addr[], ULONG ULAddr)
{
	Addr[0] = (UCHAR) ( 0xFF       & ULAddr);
	Addr[1] = (UCHAR) ((0xFF00     & ULAddr) >> 8);
	Addr[2] = (UCHAR) ((0xFF0000   & ULAddr) >> 16);
	Addr[3] = (UCHAR) ((0xFF000000 & ULAddr) >> 24);
}

UCHAR *
_PutAddr(UCHAR *pBuf, UCHAR Addr[])
{
	*pBuf++ = Addr[0];
	*pBuf++ = Addr[1];
	*pBuf++ = Addr[2];
	*pBuf++ = Addr[3];
	
	return (pBuf);
}

void
BuildUHdr(IRDA_MSG *pMsg, int FrameType, int Addr, int CRBit, int PFBit) 
{
    if (pMsg->IRDA_MSG_pHdrRead != NULL)
    {
        pMsg->IRDA_MSG_pHdrRead -= 2;

        ASSERT(pMsg->IRDA_MSG_pHdrRead >= pMsg->IRDA_MSG_Header);

        *(pMsg->IRDA_MSG_pHdrRead)   = (UCHAR) _MAKE_ADDR(Addr, CRBit);
        *(pMsg->IRDA_MSG_pHdrRead+1) = (UCHAR) _MAKE_UCNTL(FrameType, PFBit);
    }
    else
    {
        pMsg->IRDA_MSG_pRead -= 2;
        *(pMsg->IRDA_MSG_pRead)   = (UCHAR) _MAKE_ADDR(Addr, CRBit);
        *(pMsg->IRDA_MSG_pRead+1) = (UCHAR) _MAKE_UCNTL(FrameType, PFBit);
    }
    return;
}

void
BuildSHdr(IRDA_MSG *pMsg, int FrameType, int Addr, int CRBit, int PFBit,
          int Nr)
{
    if (pMsg->IRDA_MSG_pHdrRead != NULL)
    {
        pMsg->IRDA_MSG_pHdrRead -= 2;

        ASSERT(pMsg->IRDA_MSG_pHdrRead >= pMsg->IRDA_MSG_Header);

        *(pMsg->IRDA_MSG_pHdrRead)   = (UCHAR) _MAKE_ADDR(Addr, CRBit);
        *(pMsg->IRDA_MSG_pHdrRead+1) = (UCHAR) _MAKE_SCNTL(FrameType,
                                                           PFBit, Nr);
    }
    else
    {
        pMsg->IRDA_MSG_pRead -= 2;
        *(pMsg->IRDA_MSG_pRead)   = (UCHAR) _MAKE_ADDR(Addr, CRBit);
        *(pMsg->IRDA_MSG_pRead+1) = (UCHAR) _MAKE_SCNTL(FrameType, PFBit, Nr);
    }
    return;
}

UCHAR *
Format_SNRM(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, UCHAR SAddr[], 
			UCHAR DAddr[], int CAddr, IRDA_QOS_PARMS *pQos)
{
    BuildUHdr(pMsg, IRLAP_SNRM, Addr, CRBit, PFBit);
    
	if (pQos != NULL)
    {
        pMsg->IRDA_MSG_pWrite = _PutAddr(pMsg->IRDA_MSG_pWrite, SAddr);
        pMsg->IRDA_MSG_pWrite = _PutAddr(pMsg->IRDA_MSG_pWrite, DAddr);
        *pMsg->IRDA_MSG_pWrite++ = CAddr << 1; // Thats what the f'n spec says
	    pMsg->IRDA_MSG_pWrite = BuildNegParms(pMsg->IRDA_MSG_pWrite, pQos);
    }
    
	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_DISC(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit)
{
    BuildUHdr(pMsg, IRLAP_DISC, Addr, CRBit, PFBit);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_UI(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit)
{
    BuildUHdr(pMsg, IRLAP_UI, Addr, CRBit, PFBit);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_DscvXID(IRDA_MSG *pMsg, int ConnAddr, int CRBit, int PFBit, 
			   IRLAP_XID_DSCV_FORMAT *pXIDFormat, 
               CHAR DscvInfo[], int DscvInfoLen)
{
    if (pMsg->IRDA_MSG_pHdrRead != NULL)
    {
        pMsg->IRDA_MSG_pHdrRead -= 2;

        ASSERT(pMsg->IRDA_MSG_pHdrRead >= pMsg->IRDA_MSG_Header);

        *(pMsg->IRDA_MSG_pHdrRead)   = (UCHAR) _MAKE_ADDR(ConnAddr, CRBit);
        if (CRBit)
	        *(pMsg->IRDA_MSG_pHdrRead+1)= 
                   (UCHAR) _MAKE_UCNTL(IRLAP_XID_CMD, PFBit);
        else
	        *(pMsg->IRDA_MSG_pHdrRead+1)= 
            (UCHAR) _MAKE_UCNTL(IRLAP_XID_RSP, PFBit);
    }
    else
    {
        pMsg->IRDA_MSG_pRead -= 2;
        *(pMsg->IRDA_MSG_pRead)   = (UCHAR) _MAKE_ADDR(ConnAddr, CRBit);
        if (CRBit)
	        *(pMsg->IRDA_MSG_pRead+1)= 
                   (UCHAR) _MAKE_UCNTL(IRLAP_XID_CMD, PFBit);
        else
	        *(pMsg->IRDA_MSG_pRead+1)= 
            (UCHAR) _MAKE_UCNTL(IRLAP_XID_RSP, PFBit);
    }

	*pMsg->IRDA_MSG_pWrite++ = IRLAP_XID_DSCV_FORMAT_ID;
	
	RtlCopyMemory(pMsg->IRDA_MSG_pWrite, (CHAR *) pXIDFormat, 
		   sizeof(IRLAP_XID_DSCV_FORMAT) - 1); // Subtract for FirstDscvUCHAR
                                               // in structure
	pMsg->IRDA_MSG_pWrite += sizeof(IRLAP_XID_DSCV_FORMAT) - 1;

	if (DscvInfo != NULL)
	{
		RtlCopyMemory(pMsg->IRDA_MSG_pWrite, DscvInfo, DscvInfoLen);
		pMsg->IRDA_MSG_pWrite += DscvInfoLen;
	}
	
	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_TEST(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, 
			UCHAR SAddr[], UCHAR DAddr[])
{
    BuildUHdr(pMsg, IRLAP_TEST, Addr, CRBit, PFBit);

	pMsg->IRDA_MSG_pWrite = _PutAddr(pMsg->IRDA_MSG_pWrite, SAddr);
	pMsg->IRDA_MSG_pWrite = _PutAddr(pMsg->IRDA_MSG_pWrite, DAddr);

	return (pMsg->IRDA_MSG_pWrite);
}	

UCHAR *
Format_RNRM(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit)
{
    BuildUHdr(pMsg, IRLAP_RNRM, Addr, CRBit, PFBit);

	return (pMsg->IRDA_MSG_pWrite);
}	

UCHAR *
Format_UA(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, UCHAR SAddr[], 
			UCHAR DAddr[], IRDA_QOS_PARMS *pQos)
{
    BuildUHdr(pMsg, IRLAP_UA, Addr, CRBit, PFBit);
    
    if (SAddr != NULL)
    {
        pMsg->IRDA_MSG_pWrite = _PutAddr(pMsg->IRDA_MSG_pWrite, SAddr);
    }
    if (DAddr != NULL)
    {
        pMsg->IRDA_MSG_pWrite = _PutAddr(pMsg->IRDA_MSG_pWrite, DAddr);
    }
    
	if (pQos != NULL)
	    pMsg->IRDA_MSG_pWrite = BuildNegParms(pMsg->IRDA_MSG_pWrite, pQos);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_FRMR(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, 
            IRLAP_FRMR_FORMAT *pFormat)
{
    BuildUHdr(pMsg, IRLAP_FRMR, Addr, CRBit, PFBit);

	RtlCopyMemory(pMsg->IRDA_MSG_pWrite, (CHAR *)pFormat,
                  sizeof(IRLAP_FRMR_FORMAT));
	pMsg->IRDA_MSG_pWrite += sizeof(IRLAP_FRMR_FORMAT);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_DM(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit)
{
    BuildUHdr(pMsg, IRLAP_DM, Addr, CRBit, PFBit);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_RD(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit)
{
    BuildUHdr(pMsg, IRLAP_RD, Addr, CRBit, PFBit);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_RR(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr)
{
    BuildSHdr(pMsg, IRLAP_RR, Addr, CRBit, PFBit, Nr);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_RNR(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr)
{
    BuildSHdr(pMsg, IRLAP_RNR, Addr, CRBit, PFBit, Nr);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_REJ(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr)
{
    BuildSHdr(pMsg, IRLAP_REJ, Addr, CRBit, PFBit, Nr);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_SREJ(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr)
{
    BuildSHdr(pMsg, IRLAP_SREJ, Addr, CRBit, PFBit, Nr);

	return (pMsg->IRDA_MSG_pWrite);
}

UCHAR *
Format_I(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr, int Ns)
{
    if (pMsg->IRDA_MSG_pHdrRead != NULL)
    {
        pMsg->IRDA_MSG_pHdrRead -= 2;

        ASSERT(pMsg->IRDA_MSG_pHdrRead >= pMsg->IRDA_MSG_Header);

        *(pMsg->IRDA_MSG_pHdrRead)   = (UCHAR) _MAKE_ADDR(Addr, CRBit);
        *(pMsg->IRDA_MSG_pHdrRead+1) = (UCHAR) (((Ns & 7) << 1) + 
                                               ((PFBit & 1)<< 4) + (Nr <<5));
    }
    else
    {
        pMsg->IRDA_MSG_pRead -= 2;
        *(pMsg->IRDA_MSG_pRead)   = (UCHAR) _MAKE_ADDR(Addr, CRBit);
        *(pMsg->IRDA_MSG_pRead+1) = (UCHAR) (((Ns & 7) << 1) + 
                                               ((PFBit & 1)<< 4) + (Nr <<5));
    }    
	return (pMsg->IRDA_MSG_pWrite);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlap\irlaplog.c ===
/*****************************************************************************
* 
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlaplog.c 
*
*  Description: IRLAP state machine logging and errors
*
*  Author: mbert
*
*  Date:   4/15/95
*
*/
#include <irda.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlapp.h>
#include <irlaplog.h>
#include <decdirda.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#define _IRLAPLOG_C_

#if DBG

TCHAR _ABuf[512];

#ifndef PEG
TCHAR _DecodeStr1[1000];
TCHAR _DecodeStr2[1000];
#else
TCHAR _DecodeStr1[] = TEXT("(null)");
TCHAR _DecodeStr2[] = TEXT("(null)");
#endif

// Keep in sync with IRLAP_STATE in irlap.h
TCHAR *IRLAP_StateStr[] = { 
   TEXT("NDM"), 
   TEXT("DSCV_MEDIA_SENSE"), 
   TEXT("DSCV_QUERY"), 
   TEXT("DSCV_REPLY"),
   TEXT("CONN_MEDIA_SENSE"),
   TEXT("SNRM_SENT"),
   TEXT("BACKOFF_WAIT"),
   TEXT("SNRM_RECEIVED"),
   TEXT("P_XMIT"),
   TEXT("P_RECV"),
   TEXT("P_DISCONNECT_PEND"),
   TEXT("P_CLOSE"),
   TEXT("S_NRM"),
   TEXT("S_DISCONNECT_PEND"),
   TEXT("S_ERROR"),
   TEXT("S_CLOSE") 
};

// Keep in sync with IRDA_SERVICE_PRIM in irda.h
TCHAR *IRDA_PrimStr[] = 
{
    TEXT("MAC_DATA_REQ"),
    TEXT("MAC_DATA_IND"),
    TEXT("MAC_DATA_RESP"),    
    TEXT("MAC_DATA_CONF"),
    TEXT("MAC_CONTROL_REQ"),
    TEXT("MAC_CONTROL_CONF"),
    TEXT("IRLAP_DISCOVERY_REQ"),
    TEXT("IRLAP_DISCOVERY_IND"),
    TEXT("IRLAP_DISCOVERY_CONF"),
    TEXT("IRLAP_CONNECT_REQ"),
    TEXT("IRLAP_CONNECT_IND"),
    TEXT("IRLAP_CONNECT_RESP"),
    TEXT("IRLAP_CONNECT_CONF"),
    TEXT("IRLAP_DISCONNECT_REQ"),
    TEXT("IRLAP_DISCONNECT_IND"),
    TEXT("IRLAP_DATA_REQ"),
    TEXT("IRLAP_DATA_IND"),
    TEXT("IRLAP_DATA_CONF"),
    TEXT("IRLAP_UDATA_REQ"),
    TEXT("IRLAP_UDATA_IND"),
    TEXT("IRLAP_UDATA_CONF"),
    TEXT("IRLAP_STATUS_REQ"),    
    TEXT("IRLAP_STATUS_IND"),
    TEXT("IRLAP_FLOWON_REQ"),
    TEXT("IRLMP_DISCOVERY_REQ"),
    TEXT("IRLMP_DISCOVERY_CONF"),
    TEXT("IRLMP_CONNECT_REQ"),
    TEXT("IRLMP_CONNECT_IND"),
    TEXT("IRLMP_CONNECT_RESP"),
    TEXT("IRLMP_CONNECT_CONF"),
    TEXT("IRLMP_DISCONNECT_REQ"),
    TEXT("IRLMP_DISCONNECT_IND"),
    TEXT("IRLMP_DATA_REQ"),
    TEXT("IRLMP_DATA_IND"),
    TEXT("IRLMP_DATA_CONF"),
    TEXT("IRLMP_UDATA_REQ"),
    TEXT("IRLMP_UDATA_IND"),
    TEXT("IRLMP_UDATA_CONF"),
    TEXT("IRLMP_ACCESSMODE_REQ"),
    TEXT("IRLMP_ACCESSMODE_IND"),
    TEXT("IRLMP_ACCESSMODE_CONF"),
};

// keep in sync with IRDA_ServiceStatus in irda.h
TCHAR *IRDA_StatStr[] =
{
    TEXT(" - MEDIA_BUSY"),
    TEXT(" - MEDIA_CLEAR"),
    TEXT(" - DISCOVERY_COLLISION"),
    TEXT(" - REMOTE_DISCOVERY_IN_PROGRESS"),
    TEXT(" - REMOTE_CONNECT_IN_PROGRSS"),
    TEXT(" - DISCOVERY_COMPLETED"),
    TEXT(" - REMOTE_CONNECTION_IN_PROGRESS"),
    TEXT(" - CONNECTION_COMPLETED"),
    TEXT(" - REMOTE_INITIATED"),
    TEXT(" - PRIMARY_CONFLICT"),
    TEXT(" - DISCONNECT_COMPLETE"),
    TEXT(" - NO_RESPONSE"),
    TEXT(" - IRLAP_DECLINE_RESET"),
    TEXT(" - DATA_REQUEST_COMPLETED"),
    TEXT(" - DATA_REQUEST_FAILED_LINK_RESET"),
    TEXT(" - DATA_REQUEST_FAILED_REMOTE_BUSY")
};

// Keep in sync with MAC_CONTROL_OPERATION in irda.h
TCHAR *MAC_OpStr[] = 
{
    TEXT("initialize link"),
    TEXT("close link"),
    TEXT("reconfig link"),
    TEXT("media sense")
};  

TCHAR 
*FrameToStr(IRDA_MSG *pMsg)    
{
#ifndef PEG   
    UCHAR *ptr;
    int i = 0;
    int j;
    TCHAR *pD1 = _DecodeStr1;
    TCHAR *pD2 = _DecodeStr2;
    
    // copy the frame to a contiguous buffer

    ptr = pMsg->IRDA_MSG_pHdrRead;
    while (ptr != pMsg->IRDA_MSG_pHdrWrite)
    {
        _ABuf[i++] = *ptr++;
    }
    ptr = pMsg->IRDA_MSG_pRead;
    while (ptr != pMsg->IRDA_MSG_pWrite)
    {
        _ABuf[i++] = *ptr++;
    }
    
//    DecodeIRDA(&_FrameType, (char *)_ABuf, i, _DecodeStr1, 2, FALSE, 1);

    // insert spaces and break-up into multiple lines
    i = 0;
    do
    {
        if (i++%69 == 0)
        {   
            *pD2++ = TEXT('\r');
            *pD2++ = TEXT('\n');
            for (j = 0; j<7;j++)
            {
                *pD2++ = TEXT(' ');
            }
        }
        *pD2++ = *pD1++;
    } while (*pD1 != TEXT('\0'));
    
    *pD2 = TEXT('\0');
#endif  
    return (_DecodeStr2);
}
void 
IRLAP_EventLogStart(PIRLAP_CB pIrlapCb, TCHAR *pFormat, ...)
{
    va_list ArgList;

    if (!(DbgSettings & DBG_IRLAPLOG))
    {
        return;
    }    
    
    va_start (ArgList, pFormat);
    
    if (++pIrlapCb->NestedEvent == 1)
    {
        DEBUGMSG(DBG_IRLAPLOG, (TEXT("----------------\r\n")));    
    }
    else
    {
        DEBUGMSG(DBG_IRLAPLOG, (TEXT("!!!!!!!!!!!!!!!!\r\n")));
    }
    
    DEBUGMSG(DBG_IRLAPLOG, (TEXT("Ev%d: "), pIrlapCb->NestedEvent));

    pIrlapCb->ActCnt[pIrlapCb->NestedEvent] = 0;
    
    vsprintf(_ABuf, pFormat, ArgList);
    DEBUGMSG(DBG_IRLAPLOG, (_ABuf));
    
    DEBUGMSG(DBG_IRLAPLOG, (TEXT("\r\nStart State: %s\r\nActions:\r\n"), 
                  IRLAP_StateStr[pIrlapCb->State]));

    va_end (ArgList);
}

void __cdecl
IRLAP_LogAction(PIRLAP_CB pIrlapCb, TCHAR *pFormat, ...)
{
    va_list ArgList;
    
    if (!(DbgSettings & DBG_IRLAPLOG))
    {
        return;
    }    
    
    va_start (ArgList, pFormat);

    DEBUGMSG(DBG_IRLAPLOG, (TEXT("  %d. "), ++pIrlapCb->ActCnt[pIrlapCb->NestedEvent]));

    vsprintf(_ABuf, pFormat, ArgList);
    DEBUGMSG(DBG_IRLAPLOG, (_ABuf));

    DEBUGMSG(DBG_IRLAPLOG, (TEXT("\r\n")));
    
    va_end (ArgList);
}

#define PRINT_IF_TRUE(bool, str)    (bool == TRUE ? str : TEXT(""))

void
IRLAP_EventLogComplete(PIRLAP_CB pIrlapCb)
{
    if (!(DbgSettings & DBG_IRLAPLOG))
    {
        return;
    }    

    DEBUGMSG(DBG_IRLAPLOG, 
                  (TEXT("Vs=%d Vr=%d RxWin(%d,%d) TxWin(%d,%d) \r\n"), 
                  pIrlapCb->Vs, pIrlapCb->Vr,
                  pIrlapCb->RxWin.Start, pIrlapCb->RxWin.End, 
                  pIrlapCb->TxWin.Start, pIrlapCb->TxWin.End));

    DEBUGMSG(DBG_IRLAPLOG, (TEXT("Ev%d End St: %s\r\n"),
                            pIrlapCb->NestedEvent, IRLAP_StateStr[pIrlapCb->State]));

    if (--pIrlapCb->NestedEvent > 0)
    {
        DEBUGMSG(DBG_IRLAPLOG, (TEXT("!!!!!!!!!!!!!!!!\r\n")));
    }    
    
    ASSERT(pIrlapCb->NestedEvent >= 0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlap\irlapp.h ===
/*****************************************************************************
* 
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlap.h 
*
*  Description: IRLAP Protocol and control block definitions
*
*  Author: mbert
*
*  Date:   4/15/95
*
*/

#define UNICODE_CHAR_SET                0xFF
#define IRLAP_MEDIA_SENSE_TIME          500
#define IRLAP_SLOT_TIMEOUT              50
#define IRLAP_DSCV_SENSE_TIME           110
#define IRLAP_FAST_POLL_TIME            10
#define IRLAP_FAST_POLL_COUNT           10

// XID Format
#define IRLAP_XID_DSCV_FORMAT_ID     0x01
#define IRLAP_XID_NEGPARMS_FORMAT_ID 0x02
typedef struct 
{
    UCHAR    SrcAddr[IRDA_DEV_ADDR_LEN];
    UCHAR    DestAddr[IRDA_DEV_ADDR_LEN];
    UCHAR    NoOfSlots:2;
    UCHAR    GenNewAddr:1;
    UCHAR    Reserved:5;
    UCHAR    SlotNo;
    UCHAR    Version;
    UCHAR    FirstDscvInfoByte;
} IRLAP_XID_DSCV_FORMAT;

// Frame Reject Format
typedef struct
{
    UCHAR    CntlField;
    UCHAR    Fill1:1;
    UCHAR    Vs:3;
    UCHAR    CRBit:1;
    UCHAR    Vr:3;
    UCHAR    W:1;
    UCHAR    X:1;
    UCHAR    Y:1;
    UCHAR    Z:1;
    UCHAR    Fill2:4;
} IRLAP_FRMR_FORMAT;

// SNRM Frame Format
typedef struct
{
    UCHAR    SrcAddr[IRDA_DEV_ADDR_LEN];
    UCHAR    DestAddr[IRDA_DEV_ADDR_LEN];
    UCHAR    ConnAddr; // actually shifted for CRBit !!
    UCHAR    FirstQosByte;
} IRLAP_SNRM_FORMAT;

// UA Frame Format
typedef struct
{
    UCHAR    SrcAddr[IRDA_DEV_ADDR_LEN];
    UCHAR    DestAddr[IRDA_DEV_ADDR_LEN];
    UCHAR    FirstQosByte;
} IRLAP_UA_FORMAT;

#define IRLAP_MAX_TX_MSG_LIST_LEN       8
#define IRLAP_MAX_DATA_SIZE             4096
#define IRLAP_MAX_SLOTS                 16
#define IRLAP_CONTENTION_BAUD           9600
#define IRLAP_CONTENTION_DATA_SIZE      64
#define IRLAP_CONTENTION_MAX_TAT        500
#define IRLAP_CONTENTION_BOFS           10
#define IRLAP_CONTENTION_WIN_SIZE       1

// Default Qos if not found in registry
#define IRLAP_DEFAULT_DATASIZE          (DATA_SIZE_64  | DATA_SIZE_128 | \
                                         DATA_SIZE_256 | DATA_SIZE_512 | \
                                         DATA_SIZE_1024| DATA_SIZE_2048)
#define IRLAP_DEFAULT_WINDOWSIZE        (FRAMES_1 | FRAMES_2 | FRAMES_3 | \
                                         FRAMES_4 | FRAMES_5 | FRAMES_6 | \
                                         FRAMES_7)
#define IRLAP_DEFAULT_MAXTAT            (MAX_TAT_500)
#define IRLAP_DEFAULT_SLOTS             6
#define IRLAP_DEFAULT_HINTCHARSET       0x8425ff // computer, IrCOMM, Obex, and telephony
#define IRLAP_DEFAULT_DISCONNECTTIME    DISC_TIME_12 | DISC_TIME_8  | DISC_TIME_3

// Macros for extracting various fields
#define IRLAP_GET_ADDR(addr)        (addr >> 1)
#define IRLAP_GET_CRBIT(addr)       (addr & 1) 
#define IRLAP_GET_PFBIT(cntl)       ((cntl >>4) & 1)
#define IRLAP_GET_UCNTL(cntl)       (cntl & 0xEF)
#define IRLAP_GET_SCNTL(cntl)       (cntl & 0x0F)
#define IRLAP_FRAME_TYPE(cntl)      (cntl & 0x01 ? (cntl & 3) : 0)
#define IRLAP_GET_NR(cntl)          ((cntl & 0xE0) >> 5)
#define IRLAP_GET_NS(cntl)          ((cntl & 0xE) >> 1)     

// IRLAP constants
#define IRLAP_BROADCAST_CONN_ADDR   0x7F
#define IRLAP_END_DSCV_SLOT_NO      0xFF
#define IRLAP_CMD                   1
#define IRLAP_RSP                   0
#define IRLAP_PFBIT_SET             1
#define IRLAP_PFBIT_CLEAR           0
#define IRLAP_GEN_NEW_ADDR          1
#define IRLAP_NO_NEW_ADDR           0

// Macro for creating Number of Slots of Discovery Flags Field of XID Format
// if S(Slots) <= 1 return 0, <= 6 return 1, <= 8 return 2, else return 3
#define IRLAP_SLOT_FLAG(S)  (S <= 1 ? 0 : (S <= 6 ? 1 : (S <= 8 ? 2 : 3)))

int _inline IRLAP_RAND(int Min, int Max)
{
    LARGE_INTEGER   li;

    KeQueryTickCount(&li);
    
    return ((li.LowPart % (Max+1-Min)) + Min);
}

// Backoff time is a random time between 0.5 and 1.5 times the time to
// send a SNRM. _SNRM_TIME() is actually half (1000ms/2) time to send
// SNRM_LEN of characters at 9600 (9600/10 bits per char).
#define _SNRM_LEN               32
#define _SNRM_TIME()            (_SNRM_LEN*500/960)
#define IRLAP_BACKOFF_TIME()    IRLAP_RAND(_SNRM_TIME(), 3*_SNRM_TIME())

#define QOS_PI_BAUD        0x01
#define QOS_PI_MAX_TAT     0x82
#define QOS_PI_DATA_SZ     0x83
#define QOS_PI_WIN_SZ      0x84
#define QOS_PI_BOFS        0x85
#define QOS_PI_MIN_TAT     0x86
#define QOS_PI_DISC_THRESH 0x08


#define IRLAP_I_FRAME         		0x00
#define IRLAP_S_FRAME         		0x01
#define IRLAP_U_FRAME         		0x03

// Unnumbered Frame types with P/F bit set to 0
#define IRLAP_UI             0x03
#define IRLAP_XID_CMD        0x2f
#define IRLAP_TEST           0xe3
#define IRLAP_SNRM           0x83
#define IRLAP_RNRM			 0x83
#define IRLAP_DISC           0x43
#define IRLAP_RD			 0x43
#define IRLAP_UA             0x63
#define IRLAP_FRMR           0x87
#define IRLAP_DM             0x0f
#define IRLAP_XID_RSP        0xaf

// Supervisory Frames
#define IRLAP_RR             0x01
#define IRLAP_RNR            0x05
#define IRLAP_REJ            0x09
#define IRLAP_SREJ           0x0d

#define _MAKE_ADDR(Addr, CRBit)		 ((Addr << 1) + (CRBit & 1))
#define _MAKE_UCNTL(Cntl, PFBit)	 (Cntl + ((PFBit & 1)<< 4))
#define _MAKE_SCNTL(Cntl, PFBit, Nr) (Cntl + ((PFBit & 1)<< 4) + (Nr <<5))

#define IRLAP_CB_SIG    0x7f2a364bUL

// IRLAP Control Block
typedef struct
{
    IRDA_MSG        *pMsg[IRLAP_MOD];
    UINT            Start;
    UINT            End;
#ifdef TEMPERAMENTAL_SERIAL_DRIVER
    int             FCS[IRLAP_MOD];
#endif    
} IRLAP_WINDOW;

typedef enum
{
    PRIMARY,
    SECONDARY
} IRLAP_STN_TYPE;

typedef enum // KEEP IN SYNC with IRLAP_StateStr in irlaplog.c
{
    NDM,                // Normal Disconnect Mode
    DSCV_MEDIA_SENSE,   // Discovery Media Sense (Before Discovery)
    DSCV_QUERY,         // Discovery Query (Discovery initiated)
    DSCV_REPLY,         // Discovery Reply (Received DSCV XID cmd from Remote)
    CONN_MEDIA_SENSE,   // Connect Media Sense (Before connection estab)
    SNRM_SENT,          // SNRM sent - waiting for UA or DM from Remote
    BACKOFF_WAIT,       // Waiting random backoff before sending next SNRM
    SNRM_RECEIVED,      // SNRM rcvd - waiting for response from upper layer
    P_XMIT,             // Primary transmit
    P_RECV,             // Primary receive
    P_DISCONNECT_PEND,  // Upper layer request disconnect while in P_RECV
    P_CLOSE,            // Sent DISC, waiting for response
    S_NRM,              // Secondary Normal Response Mode XMIT/RECV
    S_DISCONNECT_PEND,  // Upper layer request disconnect while in S_NRM
    S_ERROR,            // Waiting for PF bit then send a FRMR
    S_CLOSE,            // Requested disconnect (RD) waiting for DISC command
} IRLAP_STATE;

typedef struct IrlapControlBlock
{
  IRLAP_STATE       State;
  IRDA_DEVICE       LocalDevice;
  IRDA_DEVICE       RemoteDevice;
  PIRDA_LINK_CB     pIrdaLinkCb;
  IRDA_QOS_PARMS    LocalQos;      // QOS from LMP
  IRDA_QOS_PARMS    RemoteQos;     // QOS of remote taken from SNRM/UA
  IRDA_QOS_PARMS    NegotiatedQos; // Union of remote and local QOS
  int               Baud;          // Type 0 negotiation parm
  int               DisconnectTime;// Type 0 negotiation parm
  int               ThresholdTime; // Type 0 negotiotion parm
  int               LocalMaxTAT;   // Type 1 negotiation parm
  int               LocalDataSize; // Type 1 negotiation parm
  int               LocalWinSize;  // Type 1 negotiation parm
  int               LocalNumBOFS;  // Type 1 negotiation parm
  int               RemoteMaxTAT;  // Type 1 negotiation parm
  int               RemoteDataSize;// Type 1 negotiation parm
  int               RemoteWinSize; // Type 1 negotiation parm
  int               RemoteNumBOFS; // Type 1 negotiation parm
  int               RemoteMinTAT;  // Type 1 negotiation parm
  IRLAP_STN_TYPE    StationType;   // PRIMARY or SECONDARY
  int               ConnAddr;      // Connection Address
  int               SNRMConnAddr;  // Connection address contained in SNRM
                                   // save it until CONNECT_RESP is received
  int               CRBit;         // Primary = 1, Secondary = 0
  int               RespSlot;      // Secondary. Slot to respond in
  int               SlotCnt;       // Primary. Current slot number
  int               MaxSlot;       // Maximum slots to send in Dscv
  int               RemoteMaxSlot; // Number of Dscv's remote will send
  LIST_ENTRY        DevList;       // Discovered device list
  UINT              Vs;            // send state variable
  UINT              Vr;            // receive state variable
  IRLAP_WINDOW      RxWin;         // Holds out of sequence rxd frames
  IRLAP_WINDOW      TxWin;         // Holds unacked txd frames
  LIST_ENTRY        TxMsgList;     // DATA_REQ, UDATA_REQ queued here
  LIST_ENTRY        ExTxMsgList;   // Expidited DATA_REQ, UDATA_REQ queued here
  int               RetryCnt;      // Count of number of retrans of DSCV,SNRM
  int               N1;            // const# retries before sending status up
  int               N2;            // const# retries before disconnecting
  int               N3;            // const# of connection retries
  int               FastPollCount;
  IRDA_TIMER        SlotTimer;
  IRDA_TIMER        QueryTimer;
  IRDA_TIMER        PollTimer;
  IRDA_TIMER        FinalTimer;
  IRDA_TIMER        WDogTimer;
  IRDA_TIMER        BackoffTimer;
  IRDA_TIMER        StatusTimer;
  int               WDogExpCnt;    // Count of WDog expirations
  int               StatusSent;    // Status ind has been sent
  int               StatusFlags;
  int               FTimerExpCnt;   
  int               RetranCnt;
  IRLAP_FRMR_FORMAT Frmr;
  BOOLEAN           GenNewAddr;    // Flag indicating whether to set new addr
  BOOLEAN           DscvRespSent;  // Secondary. Sent XID Discv response
  BOOLEAN           RemoteBusy;    // Remote has sent a RNR
  BOOLEAN           LocalBusy;     // Local busy condition, we sent RNR
  BOOLEAN           ClrLocalBusy;  // Send RR 
  BOOLEAN           LocalDiscReq;  // why 2ndary got DISC
  BOOLEAN           ConnAfterClose;// Conn req while in p_close
  BOOLEAN           DscvAfterClose;// Dscv_req while in p_close
  BOOLEAN           NoResponse;    // Final/WD timer exp'd, used with RetryCnt
  BOOLEAN           MonitorLink;
  #if DBG
  int               DelayedConf;
  int               ActCnt[10];
  int               NestedEvent;
  #endif
} IRLAP_CB, *PIRLAP_CB;

#define LINE_CAPACITY(icb)     (icb->RemoteWinSize * \
                               (icb->RemoteDataSize + \
                                6+icb->RemoteNumBOFS))


UCHAR *BuildNegParms(UCHAR *pBuf, IRDA_QOS_PARMS *pQos);

void StoreULAddr(UCHAR Addr[], ULONG ULAddr);

UCHAR *Format_SNRM(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, 
				  UCHAR SAddr[], UCHAR DAddr[], int CAddr, 
				  IRDA_QOS_PARMS *pQos);

UCHAR *Format_DISC(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit);

UCHAR *Format_UI(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit);

UCHAR *Format_DscvXID(IRDA_MSG *pMsg, int ConnAddr, int CRBit, int PFBit, 
					 IRLAP_XID_DSCV_FORMAT *pXidFormat, CHAR DscvInfo[], 
                     int Len);

UCHAR *Format_TEST(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, 
				  UCHAR SAddr[], UCHAR DAddr[]);

UCHAR *Format_RNRM(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit);

UCHAR *Format_UA(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, 
				UCHAR SAddr[], UCHAR DAddr[], IRDA_QOS_PARMS *pQos);

UCHAR *Format_FRMR(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, 
				  IRLAP_FRMR_FORMAT *pFormat);

UCHAR *Format_DM(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit);

UCHAR *Format_RD(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit);

UCHAR *Format_RR(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr);

UCHAR *Format_RNR(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr);

UCHAR *Format_REJ(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr);

UCHAR *Format_SREJ(IRDA_MSG *pMsg, int Addr, int CRBit, int PFBit, int Nr);

UCHAR * Format_I(IRDA_MSG *pMsg, int Addr, int CRBit, 
				int PFBit, int Nr, int Ns);

int GetMyDevAddr(BOOLEAN New);

#if DBG

CHAR *DecodeIRDA(int  *pFrameType,// returned frame type (-1=bad frame)
                UCHAR *pFrameBuf, // pointer to buffer containing IRLAP frame
                UINT FrameLen,   // length of buffer 
                CHAR *pOutStr,  // string where decoded packet is placed   
                UINT DecodeLayer,// 1,LAP only, 2 LAP/LMP, 3, LAP/LMP/TTP
                int fNoConnAddr,// TRUE->Don't show connection address in str
                int  DispMode 
);

_inline
VOID
DBG_FRAME(
    PIRDA_LINK_CB pIrdaLinkCb,
    int Dir, 
    UCHAR *pFrame, 
    UINT HdrLen, 
    UINT DataLen)
{    
    LARGE_INTEGER   li;
    int             CurrTime, Diff, Inc;
    
    Inc = KeQueryTimeIncrement();
    
    KeQueryTickCount(&li);
    
    CurrTime = (int) li.LowPart * Inc;
    
    Diff = CurrTime - pIrdaLinkCb->LastTime;
    
    pIrdaLinkCb->LastTime = CurrTime;
    
    if ((DbgSettings & DBG_TXFRAME) == Dir ||
        (DbgSettings & DBG_RXFRAME) == Dir || Dir == 0)
    {
        UCHAR StrBuf[256];
        int FrameType;
          
        DecodeIRDA(&FrameType,
                   pFrame, 
                   HdrLen,
                   StrBuf,
                   0,
                   TRUE,
                   1);
                   
        DEBUGMSG(1, ("%03d %s %s len:%d\n", Diff/10000,
                 Dir == DBG_TXFRAME?"Tx:": Dir == DBG_RXFRAME? "Rx:" :"R2",
                 (char*)StrBuf, 
                 DataLen));
    }
}                   
#else
#define DBG_FRAME(lcb,d,p,hl,l) (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\internal.h ===
#if DBG
#define DEBUGMSG(s)     DbgPrint s
//#define DEBUGMSG(s)     printf s
//#define DEBUGMSG(s)     (0)
#else
#define DEBUGMSG(s)         (0)
#endif


typedef UINT (* WAVE_NUM_DEV_FN)(VOID);
typedef BOOL (* PLAY_SOUND_FN)( IN LPCWSTR pszSound, IN HMODULE hmod, IN DWORD fdwSound);

extern HINSTANCE                   ghInstance;
extern HKEY                        ghCurrentUserKey;


typedef enum
{
    INRANGE_SOUND,
    OUTOFRANGE_SOUND,
    INTERRUPTED_SOUND,
    END_INTERRUPTED_SOUND
} IRSOUND_EVENT;



VOID
PlayIrSound(
    IRSOUND_EVENT SoundEvent
    );

VOID
CreateRegSoundData(
    VOID
    );

VOID
GetRegSoundData(
    HANDLE   Event
    );


VOID
LoadSoundApis(
    VOID
    );



BOOL
InitializeSound(
    HKEY   CurrentUserKey,
    HANDLE Event
    );

VOID
UninitializeSound(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlmp\irlmpp.h ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  File:   irlmp.h
*
*  Description: IRLMP Protocol and control block definitions
*
*  Author: mbert
*
*  Date:   6/12/95
*
*/

#define IRLMP_MAX_TX_MSG_LIST_LEN       8

#define LSAP_RESPONSE_TIMEOUT           7000
// This is the time that:
//    (1) the IRLMP client has to respond to an IRLMP_CONNECT_IND, or
//    (2) the peer LSAP has to respond to an IRLMP LM-Connect request PDU, or
//    (3) the peer LSAP has to respond to an LM-Access request PDU
// On expiration:
//    (1) send peer LSAP an IRLMP LM-Disconnect indication PDU. Or
//    (2) notify IRLMP client with a IRLMP_DISCONNECT_IND
//    (3) notify IRLMP client with a IRLMP_ACCESSMODE_CONF 

#define IRLMP_DISCONNECT_DELAY_TIMEOUT  2000
// When the final LSAP-LSAP connection is terminated, wait before
// disconnecting link in case another LSAP connection is made.
// This is primarily used when the remote connects to the IAS
// and then disconnects followed by a new LSAP connection.

#define IRLMP_NOT_SEEN_THRESHOLD      3 // The number of times that a device
                                        // is not seen in a discovery before
                                        // it is removed from the aged list
                                        // maintained by IRLMP

typedef struct IAS_Attribute
{
    struct IAS_Attribute        *pNext;
    CHAR                        *pAttribName;
    void                        *pAttribVal;
    int                         AttribValLen;
    int                         CharSet;
    UCHAR                       AttribValType;
} IAS_ATTRIBUTE, *PIAS_ATTRIBUTE;

typedef struct IAS_Object
{
    LIST_ENTRY                  Linkage;
    CHAR                        *pClassName;
    IAS_ATTRIBUTE               *pAttributes;
    UINT                        ObjectId;
} IAS_OBJECT, *PIAS_OBJECT;

typedef struct
{
    LIST_ENTRY                  Linkage;
    int                         Lsap;
    UINT                        Flags; // see IRLMP_LSAP_CB.Flags
} IRLMP_REGISTERED_LSAP, *PIRLMP_REGISTERED_LSAP;

// IRLMP Control Block
typedef enum
{
    LSAP_CREATED,
    LSAP_DISCONNECTED,          
    LSAP_IRLAP_CONN_PEND,       // waiting for IRLAP_CONNECT_CONF from IRLAP
    LSAP_LMCONN_CONF_PEND,      // waiting for IRLMP Conn conf PDU from peer
    LSAP_CONN_RESP_PEND,        // waiting for IRLMP_CONNECT_RESP from client
    LSAP_CONN_REQ_PEND,         // Got IRLMP_CONNECT_REQ when link is either
                                // in discovery or disconnecting
    LSAP_EXCLUSIVEMODE_PEND,    // Pending response from peer
    LSAP_MULTIPLEXEDMODE_PEND,  // Pending response from peer
    LSAP_READY,                 // CONNECTED STATES SHOULD ALWAYS FOLLOW THIS    
    LSAP_NO_TX_CREDIT           // IRLMP_DATA_REQ with no transmit credit
} IRLMP_LSAP_STATE;

typedef enum
{
    LINK_DOWN,
    LINK_DISCONNECTED,      
    LINK_DISCONNECTING,     // Sent IRLAP_DISCONNECT_REQ, waiting for IND
    LINK_IN_DISCOVERY,      // Sent IRLAP_DISCOVERY_REQ, waiting for CONF
    LINK_CONNECTING,        // Sent IRLAP_CONNECT_REQ, waiting for CONF
    LINK_READY              // Received CONF
} IRLMP_LINK_STATE;

#define LSAPSIG                 0xEEEEAAAA
#define VALIDLSAP(l)            ASSERT(l->Sig == LSAPSIG)


typedef struct
{
    LIST_ENTRY                  Linkage;
    struct IrlmpLinkCb          *pIrlmpCb;
    IRLMP_LSAP_STATE            State;
#ifdef DBG
    int                         Sig;
#endif            
    int                         UserDataLen;
    int                         LocalLsapSel;
    int                         RemoteLsapSel;
    int                         AvailableCredit; // additional credit that
                                                 // can be advanced to remote
    int                         LocalTxCredit;   // credit for transmitting
    int                         RemoteTxCredit;  // what remote has for txing
    LIST_ENTRY                  TxMsgList;       // messages from client waiting
                                                 // for ack
    LIST_ENTRY                  SegTxMsgList;    // above messages that have been
                                                 // segmented, but not sent because
                                                 // there is no credit available
    int                         TxMaxSDUSize;
    int                         RxMaxSDUSize;
    IRLMP_DISC_REASON           DiscReason;
    IRDA_TIMER                  ResponseTimer;
    PVOID                       TdiContext;
    REF_CNT                     RefCnt;
    UINT                        Flags;
        #define LCBF_USE_TTP    1
        #define LCBF_TDI_OPEN   2
    UCHAR                       UserData[IRLMP_MAX_USER_DATA_LEN];
} IRLMP_LSAP_CB, *PIRLMP_LSAP_CB;

typedef struct IrlmpLinkCb
{
    LIST_ENTRY                  LsapCbList;
    PIRDA_LINK_CB               pIrdaLinkCb;    
    IRLMP_LINK_STATE            LinkState;
    UCHAR                       ConnDevAddr[IRDA_DEV_ADDR_LEN];
    IRDA_QOS_PARMS              RequestedQOS;
    IRDA_QOS_PARMS              NegotiatedQOS;
    int                         MaxSlot;
    int                         MaxPDUSize;
    int                         WindowSize;
    IRDA_TIMER                  DiscDelayTimer;
    IRLMP_LSAP_CB               *pExclLsapCb;   // pointer to LSAP_CB that has
                                                // link in exclusive mode
    IAS_QUERY                   *pIasQuery;
    UINT                        AttribLen;
    UINT                        AttribLenWritten;
    int                         QueryListLen;
    UCHAR                       IasQueryDevAddr[IRDA_DEV_ADDR_LEN];    
    int                         IasRetryCnt;
    PVOID                       hAttribDeviceName;
    PVOID                       hAttribIrlmpSupport;
    LIST_ENTRY                  DeviceList;
    UINT                        DiscoveryFlags;
        #define DF_NORMAL_DSCV     1
        #define DF_NO_SENSE_DSCV   2
    BOOLEAN                     ConnDevAddrSet;
    BOOLEAN                     ConnReqScheduled;
    BOOLEAN                     FirstIasRespReceived;
    BOOLEAN                     AcceptConnection;
} IRLMP_LINK_CB, *PIRLMP_LINK_CB;

// IRLMP-PDU types (CntlBit)
#define IRLMP_CNTL_PDU        1
#define IRLMP_DATA_PDU        0
typedef struct
{
    UCHAR    DstLsapSel:7;
    UCHAR    CntlBit:1;
    UCHAR    SrcLsapSel:7;
    UCHAR    RsvrdBit:1;
} IRLMP_HEADER;

// Control IRLMP-PDU types (OpCode)
#define IRLMP_CONNECT_PDU           1
#define IRLMP_DISCONNECT_PDU        2
#define IRLMP_ACCESSMODE_PDU        3
// A Bit
#define IRLMP_ABIT_REQUEST          0
#define IRLMP_ABIT_CONFIRM          1
// Status
#define IRLMP_RSVD_PARM             0x00
#define IRLMP_STATUS_SUCCESS        0x00
#define IRLMP_STATUS_FAILURE        0x01
#define IRLMP_STATUS_UNSUPPORTED    0xFF

typedef struct
{
    UCHAR    OpCode:7;
    UCHAR    ABit:1;
    UCHAR    Parm1;
    UCHAR    Parm2;
} IRLMP_CNTL_FORMAT;

// Tiny TP!

#define TTP_PFLAG_NO_PARMS      0
#define TTP_PFLAG_PARMS         1

#define TTP_MBIT_NOT_FINAL      1
#define TTP_MBIT_FINAL          0

typedef struct
{
    UCHAR    InitialCredit:7;
    UCHAR    ParmFlag:1;
} TTP_CONN_HEADER;

typedef struct
{
    UCHAR    AdditionalCredit:7;
    UCHAR    MoreBit:1;
} TTP_DATA_HEADER;

#define TTP_MAX_SDU_SIZE_PI     1
#define TTP_MAX_SDU_SIZE_PL     4   // I'm hardcoding this. Seems unecessary
                                    // to make it variable. I will handle
                                    // receiving varialbe sized however
typedef struct
{
    UCHAR    PLen;
    UCHAR    PI;
    UCHAR    PL;
    UCHAR    PV[TTP_MAX_SDU_SIZE_PL];
} TTP_CONN_PARM;

// IAS

#define IAS_SUCCESS                 0
#define IAS_NO_SUCH_OBJECT          1
#define IAS_NO_SUCH_ATTRIB          2

#define IAS_MSGBUF_LEN              50

#define IAS_LSAP_SEL                0
#define IAS_LOCAL_LSAP_SEL          3

#define IAS_IRLMP_VERSION           1
#define IAS_SUPPORT_BIT_FIELD       0   // No other IAS support
#define IAS_LMMUX_SUPPORT_BIT_FIELD 1   // Exclusive mode only

typedef struct
{
    UCHAR        OpCode:6;
    UCHAR        Ack:1;
    UCHAR        Last:1;
} IAS_CONTROL_FIELD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\irdisc.h ===
HANDLE
CreateIrDiscoveryObject(
    HWND    WindowHandle,
    UINT    DiscoveryWindowMessage,
    UINT    LinkWindowMessage
    );



VOID
CloseIrDiscoveryObject(
    HANDLE    Object
    );

LONG
GetDeviceList(
    HANDLE    Object,
    OBEX_DEVICE_LIST *   List,
    ULONG    *ListBufferSize
    );

VOID
GetLinkStatus(
    HANDLE    Object,
    IRLINK_STATUS  *LinkStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlap\irndis.c ===
/*****************************************************************************
*
*  Copyright (c) 1996 Microsoft Corporation
*
*  Module: irndis.c
*
*  Author: mbert 8-96
*
*  This modules provides the MAC interface of IrLAP (formerly IrMAC
*  of Pegasus). It is now an Ndis protocol interface for communicating
*  with Miniport Ir framers.
*
*                         |---------|                               
*                         |         |                               
*                         |  IrLAP  |                               
*                         |         |                               
*                         |---------|                               
*                           /|\  |                                  
*                            |   |                                  
*      IrlapUp(IrlapContext, |   | IrmacDown(LinkContext,           
*              IrdaMsg)      |   |           IrdaMsg)               
*                            |   |                                  
*                            |  \|/                                 
*                         |----------|                              
*                         |          |                              
*                         |  IrNDIS  |                                
*                         |          |                              
*                         |----------|                              
*                            /|\  |                                 
*                             |   | Ndis Interface for transports   
*                             |   |                                  
*                             |  \|/                                
*                  |---------------------------|                   
*                  |      Ndis Wrapper         |                   
*                  |---------------------------|                   
*                        |------------|                            
*                        |            |
*                        |  Miniport  |                            
*                        |   Framer   |
*                        |            |                           
*                        |------------|                            
*                                                                   
*                                                                   
*
*
*/
#include <irda.h>
#include <ntddndis.h>
#include <ndis.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlapp.h>
#include <irlmp.h>
#include <irmem.h>

#define WORK_BUF_SIZE   256
#define NICK_NAME_LEN   18

#define DISABLE_CODE_PAGING     1
#define DISABLE_DATA_PAGING     2

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

NDIS_HANDLE             NdisIrdaHandle; // Handle to identify Irda to Ndis
                                        // when opening adapters 
UINT                    DisconnectTime; // WARNING: This variable is used
                                        // to lock down all pageable data
                                        // (see MmLockPageDataSection below)
UINT                    HintCharSet;
UINT                    Slots;
UCHAR                   NickName[NICK_NAME_LEN + 1];
UINT                    NickNameLen;
UINT                    MaxWindow;
UINT                    NoCopyCnt;
UINT                    CopyCnt;

extern VOID (*CloseRasIrdaAddresses)();


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif


typedef struct _IRDA_REQUEST {

    NDIS_REQUEST    NdisRequest;
    NDIS_STATUS     Status;
    NDIS_EVENT      Event;

} IRDA_REQUEST, *PIRDA_REQUEST;


VOID
OidToLapQos(
    UINT        ParmTable[],
    UINT        ValArray[],
    UINT        Cnt,
    PUINT       pBitField,
    BOOLEAN     MaxVal);
    
NDIS_STATUS
IrdaQueryOid(
    IN      PIRDA_LINK_CB   pIrdaLinkCb,
    IN      NDIS_OID        Oid,
    OUT     PUINT           pQBuf,
    IN OUT  PUINT           pQBufLen);    
    
NDIS_STATUS
IrdaSetOid(
    IN  PIRDA_LINK_CB   pIrdaLinkCb,
    IN  NDIS_OID        Oid,
    IN  UINT            Val);    
    
VOID IrdaSendComplete(
    IN  NDIS_HANDLE             Context,
    IN  PNDIS_PACKET            NdisPacket,
    IN  NDIS_STATUS             Status
    );

VOID InitializeLocalQos(
    IN OUT  IRDA_QOS_PARMS      *pQos,
    IN      PNDIS_STRING        ConfigPath);
    
VOID IrdaBindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            AdapterName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2);
    
VOID
MacControlRequest(
    PIRDA_LINK_CB   pIrdaLinkCb,
    PIRDA_MSG       pMsg);
    
VOID
ConfirmDataRequest(
    PIRDA_LINK_CB   pIrdaLinkCb,
    PIRDA_MSG       pMsg);
    
VOID
MediaSenseExp(PVOID Context);            

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, IrdaInitialize)

#pragma alloc_text(PAGEIRDA, OidToLapQos)   // WARNING: This function is used
                                            // to lock all paged code down
                                            // (see MmLockPagableCodeSection
                                            // below)
#pragma alloc_text(PAGEIRDA, IrdaQueryOid)
#pragma alloc_text(PAGEIRDA, IrdaSetOid)
#pragma alloc_text(PAGEIRDA, MacControlRequest)
#pragma alloc_text(PAGEIRDA, MediaSenseExp)
#pragma alloc_text(PAGEIRDA, InitializeLocalQos)

#endif



/***************************************************************************
*
*   Translate the result of an OID query to IrLAP QOS definition
*
*/
VOID
OidToLapQos(
    UINT        ParmTable[],
    UINT        ValArray[],
    UINT        Cnt,
    PUINT       pBitField,
    BOOLEAN     MaxVal)
{
    UINT    i, j;
    
    PAGED_CODE();

    *pBitField = 0;  
    for (i = 0; i < Cnt; i++)
    {
        for (j = 0; j <= PV_TABLE_MAX_BIT; j++)
        {
            if (ValArray[i] == ParmTable[j])
            {
                *pBitField |= 1<<j;
                if (MaxVal)
                    return;
            }
            else if (MaxVal)
            {
                *pBitField |= 1<<j;
            }
        }
    }            
}

/***************************************************************************
*
*   Perform a synchronous request for an OID
*
*/
NDIS_STATUS
IrdaQueryOid(
    IN      PIRDA_LINK_CB   pIrdaLinkCb,
    IN      NDIS_OID        Oid,
    OUT     PUINT           pQBuf,
    IN OUT  PUINT           pQBufLen)
{
    IRDA_REQUEST    Request;

    NDIS_STATUS     Status;
    
    PAGED_CODE();

    NdisInitializeEvent(&Request.Event);
    NdisResetEvent(&Request.Event);
    
    Request.NdisRequest.RequestType = NdisRequestQueryInformation;
    Request.NdisRequest.DATA.QUERY_INFORMATION.Oid = Oid;
    Request.NdisRequest.DATA.QUERY_INFORMATION.InformationBuffer = pQBuf;
    Request.NdisRequest.DATA.QUERY_INFORMATION.InformationBufferLength = *pQBufLen * sizeof(UINT);


    NdisRequest(&Status, pIrdaLinkCb->NdisBindingHandle, &Request.NdisRequest);

    if (Status == NDIS_STATUS_PENDING) {

        NdisWaitEvent(&Request.Event, 0);
        Status = Request.Status;
    }

    *pQBufLen = Request.NdisRequest.DATA.QUERY_INFORMATION.BytesWritten / sizeof(UINT);

    
    return Status;
}

/***************************************************************************
*
*   Perform a synchronous request to sent an OID
*
*/
NDIS_STATUS
IrdaSetOid(
    IN  PIRDA_LINK_CB   pIrdaLinkCb,
    IN  NDIS_OID        Oid,
    IN  UINT            Val)
{
    IRDA_REQUEST    Request;

    NDIS_STATUS     Status;
    
    PAGED_CODE();

    NdisInitializeEvent(&Request.Event);
    NdisResetEvent(&Request.Event);
    
    Request.NdisRequest.RequestType = NdisRequestSetInformation;
    Request.NdisRequest.DATA.SET_INFORMATION.Oid = Oid;
    Request.NdisRequest.DATA.SET_INFORMATION.InformationBuffer = &Val;
    Request.NdisRequest.DATA.SET_INFORMATION.InformationBufferLength = sizeof(UINT);

    NdisRequest(&Status, pIrdaLinkCb->NdisBindingHandle, &Request.NdisRequest);

    if (Status == NDIS_STATUS_PENDING) {

        NdisWaitEvent(&Request.Event, 0);
        Status = Request.Status;
    }

    return Status;
}
        
/***************************************************************************
*
*   Allocate an Irda message for IrLap to use for control frames.
*   This modules owns these so IrLAP doesn't have to deal with the
*   Ndis send complete.
*
*/ 
IRDA_MSG *
AllocTxMsg(PIRDA_LINK_CB pIrdaLinkCb)
{
    IRDA_MSG                *pMsg;

    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->TxMsgFreeList, &pIrdaLinkCb->SpinLock);
    
    if (pMsg == NULL)
    {
        if (pIrdaLinkCb->TxMsgFreeListLen > 10)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: too many tx msgs\n")));
            return NULL;
        }
        
        NdisAllocateMemoryWithTag(&pMsg, 
                                  sizeof(IRDA_MSG) + IRDA_MSG_DATA_SIZE,
                                  MT_IRNDIS_TX_IMSG);
        if (pMsg == NULL)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: Aloc tx msg failed\n")));
            return NULL;
        }    
        pIrdaLinkCb->TxMsgFreeListLen++;
    }

    // Indicate driver owns message
    pMsg->IRDA_MSG_pOwner = &pIrdaLinkCb->TxMsgFreeList;

    // Initialize pointers 
    pMsg->IRDA_MSG_pHdrWrite    = \
    pMsg->IRDA_MSG_pHdrRead     = pMsg->IRDA_MSG_Header + IRDA_HEADER_LEN;
	pMsg->IRDA_MSG_pBase        = \
	pMsg->IRDA_MSG_pRead        = \
	pMsg->IRDA_MSG_pWrite       = (UCHAR *) pMsg + sizeof(IRDA_MSG);
	pMsg->IRDA_MSG_pLimit       = pMsg->IRDA_MSG_pBase + IRDA_MSG_DATA_SIZE-1;

    return pMsg;
}


/***************************************************************************
*
*
*/
#if DBG
VOID
CleanupRxMsgList(
    PIRDA_LINK_CB   pIrdaLinkCb,
    BOOLEAN         LinkClose)
#else
VOID
CleanupRxMsgList(
    PIRDA_LINK_CB   pIrdaLinkCb)
#endif    
{
    PIRDA_MSG   pMsg, pMsgNext;
    
    NdisAcquireSpinLock(&pIrdaLinkCb->SpinLock);

    for (pMsg = (PIRDA_MSG) pIrdaLinkCb->RxMsgList.Flink;
         pMsg != (PIRDA_MSG) &pIrdaLinkCb->RxMsgList;
         pMsg = pMsgNext)
    {
        pMsgNext = (PIRDA_MSG) pMsg->Linkage.Flink;
        
        if (pMsg->Prim == MAC_DATA_IND)
        {
            RemoveEntryList(&pMsg->Linkage);
            
            pMsg->Prim = MAC_DATA_RESP;
            
            NdisReleaseSpinLock(&pIrdaLinkCb->SpinLock);            
                        
            IrmacDown(pIrdaLinkCb, pMsg);
            
            NdisAcquireSpinLock(&pIrdaLinkCb->SpinLock);            
            
            #if DBG            
            if (!LinkClose)
            {
                ++pIrdaLinkCb->DelayedRxFrameCnt;
            }
            #endif
        }   
        else
        {
            DbgPrint("IRNDIS: MAC_DATA_CONF on RxMsgList, not completing!\n");
        } 
    }        
    
    NdisReleaseSpinLock(&pIrdaLinkCb->SpinLock);                
}    
    
/***************************************************************************
*
*   Process MAC_CONTROL_REQs from IrLAP
*
*/
VOID
MacControlRequest(
    PIRDA_LINK_CB   pIrdaLinkCb,
    PIRDA_MSG       pMsg)
{
    NDIS_STATUS     Status;
    
    PAGED_CODE();
    
    switch (pMsg->IRDA_MSG_Op)
    {
      case MAC_INITIALIZE_LINK:
      case MAC_RECONFIG_LINK:        
        pIrdaLinkCb->ExtraBofs  = pMsg->IRDA_MSG_NumBOFs;
        pIrdaLinkCb->MinTat     = pMsg->IRDA_MSG_MinTat;
        Status = IrdaSetOid(pIrdaLinkCb,
                          OID_IRDA_LINK_SPEED,
                          (UINT) pMsg->IRDA_MSG_Baud);
        return;

      case MAC_MEDIA_SENSE:
        pIrdaLinkCb->MediaBusy = FALSE;
        IrdaSetOid(pIrdaLinkCb, OID_IRDA_MEDIA_BUSY, 0); 
        pIrdaLinkCb->MediaSenseTimer.Timeout = pMsg->IRDA_MSG_SenseTime;
        IrdaTimerStart(&pIrdaLinkCb->MediaSenseTimer);
        return;
        
      case MAC_CLOSE_LINK:
      
        DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: Closelink %X\n"), pIrdaLinkCb));
        
        IrdaTimerStop(&pIrdaLinkCb->MediaSenseTimer);        
        
        NdisResetEvent(&pIrdaLinkCb->OpenCloseEvent);
        
        #ifdef IRDA_RX_SYSTEM_THREAD
        KeSetEvent(&pIrdaLinkCb->EvKillRxThread, 0, FALSE);
        #endif
        
        #if DBG
        CleanupRxMsgList(pIrdaLinkCb, TRUE);
        #else
        CleanupRxMsgList(pIrdaLinkCb);        
        #endif
               
        NdisCloseAdapter(&Status, pIrdaLinkCb->NdisBindingHandle);

        if (Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&pIrdaLinkCb->OpenCloseEvent, 0);
            Status = pIrdaLinkCb->OpenCloseStatus;
        }                            
        
        if (pIrdaLinkCb->UnbindContext != NULL)
        {
            NdisCompleteUnbindAdapter(pIrdaLinkCb->UnbindContext, NDIS_STATUS_SUCCESS);
            
            DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: NdisCompleteUndindAdapter for link %X called\n"),
                     pIrdaLinkCb));
        }
        
        REFDEL(&pIrdaLinkCb->RefCnt, 'DNIB');
        
        return;
    }
    ASSERT(0);
}

VOID
ConfirmDataRequest(
    PIRDA_LINK_CB   pIrdaLinkCb,
    PIRDA_MSG       pMsg)
{
    if (pMsg->IRDA_MSG_pOwner == &pIrdaLinkCb->TxMsgFreeList)
    {
        // If TxMsgFreeList is the owner, then this is a control
        // frame which isn't confirmed.
        
        NdisInterlockedInsertTailList(&pIrdaLinkCb->TxMsgFreeList,
                                      &pMsg->Linkage,
                                      &pIrdaLinkCb->SpinLock);        
        return;
    }    
    
    ASSERT(pMsg->IRDA_MSG_RefCnt);
    
    if (InterlockedDecrement(&pMsg->IRDA_MSG_RefCnt) == 0)
    {
        pMsg->Prim = MAC_DATA_CONF;    
        
        NdisInterlockedInsertTailList(&pIrdaLinkCb->RxMsgList,
                                  &pMsg->Linkage,
                                  &pIrdaLinkCb->SpinLock);
                                  
        #ifdef IRDA_RX_SYSTEM_THREAD
    
        KeSetEvent(&pIrdaLinkCb->EvRxMsgReady, 0, FALSE);
        
        #else
    
        IrdaEventSchedule(&pIrdaLinkCb->EvRxMsgReady, pIrdaLinkCb);
        
        #endif 
    }       
}

/***************************************************************************
*
*   Process control and data requests from IrLAP
*
*/
VOID
IrmacDown(
    IN  PVOID   Context,
    PIRDA_MSG   pMsg)
{
    NDIS_STATUS             Status;
    PNDIS_PACKET            NdisPacket = NULL;
    PNDIS_BUFFER            NdisBuffer = NULL;
    PIRDA_PROTOCOL_RESERVED pReserved;
    PNDIS_IRDA_PACKET_INFO  IrdaPacketInfo;
    PIRDA_LINK_CB           pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    
    DEBUGMSG(DBG_FUNCTION, (TEXT("IrmacDown()\n")));

    switch (pMsg->Prim)
    {
      case MAC_CONTROL_REQ:
        MacControlRequest(pIrdaLinkCb, pMsg);
        return;
        
      case MAC_DATA_RESP:
        // A data response from IrLAP is the mechanism used to
        // return ownership of received packets back to Ndis
        if (pMsg->DataContext)
        {
            DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: return packet %X\n"), pMsg->DataContext));
            
            NdisReturnPackets(&((PNDIS_PACKET)pMsg->DataContext), 1);
        }   
         
        NdisInterlockedInsertTailList(&pIrdaLinkCb->RxMsgFreeList,
                                      &pMsg->Linkage,
                                      &pIrdaLinkCb->SpinLock);
        pIrdaLinkCb->RxMsgFreeListLen++;
        
        return;

      case MAC_DATA_REQ:
      
        Status = NDIS_STATUS_FAILURE;

        // IrDA is half duplex. If there is something on the 
        // receive list when we go to transmit then something
        // went very wrong (delay in the miniport somewhere).
        // Return these frames back to the miniport. 

        #if DBG
        CleanupRxMsgList(pIrdaLinkCb, FALSE);
        #else
        CleanupRxMsgList(pIrdaLinkCb);        
        #endif

        if (pIrdaLinkCb->UnbindContext || pIrdaLinkCb->LowPowerSt)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: Dropping MAC_DATA_REQ, link closing or low power state\n")));
            ConfirmDataRequest(pIrdaLinkCb, pMsg);
            return;
        }
      
        pReserved = (PIRDA_PROTOCOL_RESERVED) NdisInterlockedRemoveHeadList(
                                &pIrdaLinkCb->PacketList, &pIrdaLinkCb->SpinLock);
                                
        if (pReserved == NULL)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: NdisPacket pool has been depleted\n")));
            ConfirmDataRequest(pIrdaLinkCb, pMsg);
            return;
        }                            
        
        NdisPacket = CONTAINING_RECORD(pReserved, NDIS_PACKET, ProtocolReserved);
        
        ASSERT(pMsg->IRDA_MSG_pHdrWrite-pMsg->IRDA_MSG_pHdrRead);

        // Allocate buffer for frame header
        NdisAllocateBuffer(&Status, &NdisBuffer, pIrdaLinkCb->BufferPool,
                           pMsg->IRDA_MSG_pHdrRead,
                           (UINT) (pMsg->IRDA_MSG_pHdrWrite-pMsg->IRDA_MSG_pHdrRead));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: NdisAllocateBuffer failed\n")));
            ASSERT(0);
            ConfirmDataRequest(pIrdaLinkCb, pMsg);
            return;
        }
        NdisChainBufferAtFront(NdisPacket, NdisBuffer);

        // if frame contains data, alloc buffer for data
        if (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead)
        {

            NdisAllocateBuffer(&Status, &NdisBuffer, pIrdaLinkCb->BufferPool,
                               pMsg->IRDA_MSG_pRead,
                               (UINT) (pMsg->IRDA_MSG_pWrite-pMsg->IRDA_MSG_pRead));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: NdisAllocateBuffer failed\n")));
                ASSERT(0);
                ConfirmDataRequest(pIrdaLinkCb, pMsg);
                return;
            }
            NdisChainBufferAtBack(NdisPacket, NdisBuffer);
        }

        pReserved =
            (PIRDA_PROTOCOL_RESERVED)(NdisPacket->ProtocolReserved);
    
        pReserved->pMsg = pMsg;
    
        IrdaPacketInfo = (PNDIS_IRDA_PACKET_INFO) \
            (pReserved->MediaInfo.ClassInformation);
    
        IrdaPacketInfo->ExtraBOFs = pIrdaLinkCb->ExtraBofs;
        
#if DBG_TIMESTAMP
        {
            LARGE_INTEGER   li;

            KeQueryTickCount(&li);
            
            pReserved->TimeStamp[0] =  (int) li.LowPart * KeQueryTimeIncrement();
        }
#endif            
        
        if (pIrdaLinkCb->WaitMinTat)
        {
            IrdaPacketInfo->MinTurnAroundTime = pIrdaLinkCb->MinTat;
            pIrdaLinkCb->WaitMinTat = FALSE;
        }
        else
        {
            IrdaPacketInfo->MinTurnAroundTime = 0;        
        }    

        NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(
            NdisPacket,
            &pReserved->MediaInfo,
            sizeof(MEDIA_SPECIFIC_INFORMATION) -1 +
            sizeof(NDIS_IRDA_PACKET_INFO));
        
        DBG_FRAME(
                pIrdaLinkCb,
                DBG_TXFRAME, 
                pMsg->IRDA_MSG_pHdrRead,
                (UINT) (pMsg->IRDA_MSG_pHdrWrite-pMsg->IRDA_MSG_pHdrRead),
                (UINT) ((pMsg->IRDA_MSG_pHdrWrite-pMsg->IRDA_MSG_pHdrRead) +
                (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead)) - 
                IRLAP_HEADER_LEN);
        
        InterlockedIncrement(&pIrdaLinkCb->SendOutCnt);

#if DBG
        {
            ULONG   PacketLength;

            NdisQueryPacket(NdisPacket,NULL,NULL,NULL,&PacketLength);

            ASSERT(PacketLength <= 2048);
        }
#endif
        NdisSend(&Status, pIrdaLinkCb->NdisBindingHandle, NdisPacket);

        DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: NdisSend(%X)\n"), NdisPacket));

        if (Status != NDIS_STATUS_PENDING)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: NdisSend returned %x, not STATUS_PENDING\n"),
                     Status));
                     
            IrdaSendComplete(pIrdaLinkCb, 
                             NdisPacket, 
                             NDIS_STATUS_FAILURE);
            return;
        }
    }
}

/***************************************************************************
*
*   Callback for media sense timer expirations
*
*/
VOID
MediaSenseExp(PVOID Context)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    IRDA_MSG        IMsg;
    UINT            MediaBusy;
    UINT            Cnt = 1;

    PAGED_CODE();
    
    IMsg.Prim               = MAC_CONTROL_CONF;   
    IMsg.IRDA_MSG_Op        = MAC_MEDIA_SENSE;
    IMsg.IRDA_MSG_OpStatus  = MAC_MEDIA_BUSY;

    if (pIrdaLinkCb->MediaBusy == FALSE)
    {
        if (IrdaQueryOid(pIrdaLinkCb, OID_IRDA_MEDIA_BUSY, &MediaBusy, 
                         &Cnt) == NDIS_STATUS_SUCCESS && !MediaBusy)
        {
            IMsg.IRDA_MSG_OpStatus = MAC_MEDIA_CLEAR;
        }
    }

    LOCK_LINK(pIrdaLinkCb);
    
    IrlapUp(pIrdaLinkCb->IrlapContext, &IMsg);
    
    UNLOCK_LINK(pIrdaLinkCb);    
}

/***************************************************************************
*
*   Protocol open adapter complete handler
*
*/
VOID IrdaOpenAdapterComplete(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    )
{
    PIRDA_LINK_CB  pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;
    
    DEBUGMSG(DBG_NDIS,
             (TEXT("+IrdaOpenAdapterComplete() BindingContext %x, Status %x\n"),
              IrdaBindingContext, Status));

    pIrdaLinkCb->OpenCloseStatus = Status;
    NdisSetEvent(&pIrdaLinkCb->OpenCloseEvent);
    
    DEBUGMSG(DBG_NDIS, (TEXT("-IrdaOpenAdapterComplete()\n")));
              
    return;
}

/***************************************************************************
*
*   Protocol close adapter complete handler
*
*/
VOID IrdaCloseAdapterComplete(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  NDIS_STATUS             Status
    )
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;
    
    DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: IrdaCloseAdapterComplete()\n")));

    pIrdaLinkCb->OpenCloseStatus = Status;
    NdisSetEvent(&pIrdaLinkCb->OpenCloseEvent);
    
    return;
}

/***************************************************************************
*
*   Protocol send complete handler
*
*/
VOID IrdaSendComplete(
    IN  NDIS_HANDLE             Context,
    IN  PNDIS_PACKET            NdisPacket,
    IN  NDIS_STATUS             Status
    )
{
    PIRDA_LINK_CB           pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    PIRDA_PROTOCOL_RESERVED pReserved = \
        (PIRDA_PROTOCOL_RESERVED) NdisPacket->ProtocolReserved;
    PIRDA_MSG               pMsg = pReserved->pMsg;
    PNDIS_BUFFER            NdisBuffer;
#if DBG_TIMESTAMP    
    LARGE_INTEGER           li;
#endif    
    //ASSERT(Status == NDIS_STATUS_SUCCESS);
    
    ConfirmDataRequest(pIrdaLinkCb, pMsg);

#if DBG_TIMESTAMP
    
    KeQueryTickCount(&li);
            
    pReserved->TimeStamp[1] =  (int) li.LowPart * KeQueryTimeIncrement();
    
    DEBUGMSG(1, (TEXT("C: %d\n"), 
             (pReserved->TimeStamp[1] - pReserved->TimeStamp[0])/10000));
    
#endif
     
    if (NdisPacket)
    {
        NdisUnchainBufferAtFront(NdisPacket, &NdisBuffer);
        while (NdisBuffer)
        {
            NdisFreeBuffer(NdisBuffer);
            NdisUnchainBufferAtFront(NdisPacket, &NdisBuffer);
        }

        NdisReinitializePacket(NdisPacket);
        
        NdisInterlockedInsertTailList(&pIrdaLinkCb->PacketList,
                                      &pReserved->Linkage,
                                      &pIrdaLinkCb->SpinLock);
    }
    
            
    InterlockedDecrement(&pIrdaLinkCb->SendOutCnt);    
    
    ASSERT(pIrdaLinkCb->SendOutCnt >= 0);
    
    NdisAcquireSpinLock(&pIrdaLinkCb->SpinLock);

    if (pIrdaLinkCb->SendOutCnt == 0 &&
        pIrdaLinkCb->pNetPnpEvent)
    {
        PNET_PNP_EVENT   pNetPnpEvent;
    
        ASSERT(pIrdaLinkCb->LowPowerSt == TRUE);
        
        pNetPnpEvent = pIrdaLinkCb->pNetPnpEvent;
        
        pIrdaLinkCb->pNetPnpEvent = NULL;
        
        NdisReleaseSpinLock(&pIrdaLinkCb->SpinLock);        
        
        DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: Completing set power async\n")));
        
        NdisCompletePnPEvent(
            NDIS_STATUS_SUCCESS,
            pIrdaLinkCb->NdisBindingHandle,
            pNetPnpEvent);
    }        
    else
    {
        NdisReleaseSpinLock(&pIrdaLinkCb->SpinLock);
    }
            
    DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: IrdaSendComplete(%X)\n"), NdisPacket));
    
    return;
}

/***************************************************************************
*
*   Protocol transfer complete handler
*
*/
VOID IrdaTransferDataComplete(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    )
{
    DEBUGMSG(DBG_NDIS, (TEXT("+IrdaTransferDataComplete()\n")));
    
    ASSERT(0);
    return;
}

/***************************************************************************
*
*   Protocol reset complete handler
*
*/
void IrdaResetComplete(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  NDIS_STATUS             Status
    )
{
    PIRDA_LINK_CB  pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;
    DEBUGMSG(DBG_ERROR, (TEXT("+IrdaResetComplete()\n")));

    NdisSetEvent(&pIrdaLinkCb->ResetEvent);

    return;
}

/***************************************************************************
*
*   Protocol request complete handler
*
*/
void IrdaRequestComplete(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  NDIS_STATUS             Status
    )
{
    PIRDA_LINK_CB  pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;

    PIRDA_REQUEST  Request=CONTAINING_RECORD(NdisRequest,IRDA_REQUEST,NdisRequest);

    //DEBUGMSG(DBG_NDIS, (TEXT("+IrdaRequestComplete()\n")));
    
    Request->Status = Status;
    
    NdisSetEvent(&Request->Event);
        
    return;
}

/***************************************************************************
*
*   Protocol receive handler - This asserts if I don't get all data in the
*   lookahead buffer.
*
*/
NDIS_STATUS IrdaReceive(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
{
    DEBUGMSG(DBG_NDIS, (TEXT("+IrdaReceive()\n")));
    
    DEBUGMSG(DBG_ERROR, (TEXT("ProtocolReceive is not supported by irda\n")));
    
    ASSERT(0);
    
    return NDIS_STATUS_NOT_ACCEPTED;
    
    /*
    PIRDA_LINK_CB   pIrdaLinkCb = IrdaBindingContext;    
    PIRDA_MSG       pMsg;
    
    pIrdaLinkCb->WaitMinTat = TRUE;

    if (PacketSize + HeaderBufferSize > (UINT) pIrdaLinkCb->RxMsgDataSize)
    {
        DEBUGMSG(1, (TEXT("Packet+Header(%d) > RxMsgDataSize(%d)\n"), 
                PacketSize + HeaderBufferSize, pIrdaLinkCb->RxMsgDataSize));
        
        ASSERT(0);
        return NDIS_STATUS_NOT_ACCEPTED;
    }
    
    // Allocate an IrdaMsg and initialize data pointers
    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->RxMsgFreeList, &pIrdaLinkCb->SpinLock);    

    if (pMsg == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("RxMsgFreeList has been depleted\n")));
        return NDIS_STATUS_NOT_ACCEPTED;
    }
    pIrdaLinkCb->RxMsgFreeListLen--;
    
    pMsg->IRDA_MSG_pRead  = \
    pMsg->IRDA_MSG_pWrite = (UCHAR *)pMsg + sizeof(IRDA_MSG);

    // Copy header and data    
    NdisMoveMemory(pMsg->IRDA_MSG_pWrite,
                   HeaderBuffer,
                   HeaderBufferSize);
    
    pMsg->IRDA_MSG_pWrite += HeaderBufferSize;

    NdisMoveMemory(pMsg->IRDA_MSG_pWrite,
                   LookaheadBuffer,
                   LookaheadBufferSize);
    pMsg->IRDA_MSG_pWrite += LookaheadBufferSize;

    if (LookaheadBufferSize == PacketSize)
    {        
        pMsg->Prim        = MAC_DATA_IND;
        pMsg->DataContext = NULL; // i.e. I own this and there is no
                                  // Ndis packet assocaited with it 
                                  // (see MAC_DATA_RESP)
        NdisInterlockedInsertTailList(&pIrdaLinkCb->RxMsgList,
                                      &pMsg->Linkage,
                                      &pIrdaLinkCb->SpinLock);
                                      
        DBG_FRAME(pIrdaLinkCb,
                  DBG_RXFRAME, pMsg->IRDA_MSG_pRead,
                  pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead,
                  (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead) - IRLAP_HEADER_LEN);        
                                      
                                      
        #ifdef IRDA_RX_SYSTEM_THREAD
    
        KeSetEvent(&pIrdaLinkCb->EvRxMsgReady, 0, FALSE);
        
        #else
    
        IrdaEventSchedule(&pIrdaLinkCb->EvRxMsgReady, pIrdaLinkCb);

        #endif                                  
    }
    else
    {
        DEBUGMSG(DBG_ERROR, (TEXT("LookaheadBufferSize(%d) != PacketSize(%d)\n"),
                 LookaheadBufferSize, PacketSize));
        ASSERT(0);
    }
    
    return NDIS_STATUS_SUCCESS;
    */
}

/***************************************************************************
*
*   Protocol receive complete handler - what is this for?
*
*/
VOID IrdaReceiveComplete(
    IN  NDIS_HANDLE             IrdaBindingContext
    )
{
    DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: IrdaReceiveComplete()\n")));
    
    return;
}

/***************************************************************************
*
*   Protocol status handler
*
*/
VOID IrdaStatus(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;
    
    if (GeneralStatus == NDIS_STATUS_MEDIA_BUSY)
    {
        DEBUGMSG(DBG_NDIS, (TEXT("STATUS_MEDIA_BUSY\n")));
        pIrdaLinkCb->MediaBusy = TRUE;
    }
    else
    {
        DEBUGMSG(DBG_NDIS, (TEXT("Unknown Status indication\n")));
    }
    
    return;
}

/***************************************************************************
*
*   Protocol status complete handler
*
*/
VOID IrdaStatusComplete(
    IN  NDIS_HANDLE             IrdaBindingContext
    )
{
    DEBUGMSG(DBG_NDIS, (TEXT("IrdaStatusComplete()\n")));
    
    return;
}

/***************************************************************************
*
*   RxThread - Hands received frames to Irlap for processing. This is
*   the callback of an exec worker thread running at passive level
*   which allows us to get a mutex in order to single thread
*   events through the stack.
*           OR
*   This is an actual system thread created a bind time that waits on
*   2 events:
*       1 - EvRxMsgReady, an inbound frame is ready on RxMsgList
*       2 - EvKillRxThread
*
*/
VOID
RxThread(void *Arg)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Arg;
    PIRDA_MSG       pMsg;
    BOOLEAN         Done = FALSE;
#ifdef IRDA_RX_SYSTEM_THREAD    
    NTSTATUS        Status;
    PKEVENT         EventList[2] = {&pIrdaLinkCb->EvRxMsgReady,
                                    &pIrdaLinkCb->EvKillRxThread};
    BOOLEAN         DataIndication;                                
                                    
    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);
    
#endif    

    while (!Done)
    {                    
        pMsg = (PIRDA_MSG) NdisInterlockedRemoveHeadList(
                                        &pIrdaLinkCb->RxMsgList,
                                        &pIrdaLinkCb->SpinLock);                                        
        while (pMsg)
        {    
            if (pMsg->Prim == MAC_DATA_IND)
            {
                DataIndication = TRUE;
                
                pMsg->IRDA_MSG_RefCnt = 1;
                
                DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: Indicate packet %X\n"), pMsg->DataContext));
            }    
            else
            {
                DataIndication = FALSE;
            }    
                   
            LOCK_LINK(pIrdaLinkCb);

            IrlapUp(pIrdaLinkCb->IrlapContext, pMsg);

            UNLOCK_LINK(pIrdaLinkCb);
            
            if (DataIndication)
            {
                //
                // no protection needed for refcount cuz this
                // is the only thread that operates on it
                //
                
                ASSERT(pMsg->IRDA_MSG_RefCnt);
                
                pMsg->IRDA_MSG_RefCnt -= 1;
                
                if (pMsg->IRDA_MSG_RefCnt && pMsg->DataContext)
                {
                    CopyCnt++;
                    
                    // Irlap had to hold the data because of missing
                    // frames. Some miniports can't handle the stack
                    // owning the frames for any length of time. 
                
                    DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: return packet %X\n"), pMsg->DataContext));
                
                    NdisReturnPackets(&((PNDIS_PACKET)pMsg->DataContext),
                                      1);
                                      
                    pMsg->DataContext = NULL;                  
                }
                else
                {
                    NoCopyCnt++;
                }
            
                if (pMsg->IRDA_MSG_RefCnt == 0)
                {
                    pMsg->Prim = MAC_DATA_RESP;
                    
                    IrmacDown(pIrdaLinkCb, pMsg);
                }    
            }    
        
            pMsg = (PIRDA_MSG) NdisInterlockedRemoveHeadList(
                &pIrdaLinkCb->RxMsgList, &pIrdaLinkCb->SpinLock);
        }
        
        #ifdef IRDA_RX_SYSTEM_THREAD
        
            Status = KeWaitForMultipleObjects(2, EventList, WaitAny,
                                          Executive, KernelMode,
                                          FALSE, NULL, NULL);
        
            if (Status != 0)
            {
                if (Status != 1)
                {
                    DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: KeWaitForMultObj return %X\n"), Status));
                }

                DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: Terminating RxThread\n")));
                
                PsTerminateSystemThread(STATUS_SUCCESS); 
            }    

        #else
            Done = TRUE;
            
        #endif    
    }    
}

/***************************************************************************
*
*   Protocol receive packet handler - Called at DPC, put the message on
*   RxList and have Exec worker thread process it at passive level.
*
*/
INT
IrdaReceivePacket(
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  PNDIS_PACKET            Packet)
{
    UINT            BufCnt, TotalLen, BufLen;
    PNDIS_BUFFER    pNdisBuf;
    PIRDA_MSG       pMsg;
    UCHAR            *pData;
    PIRDA_LINK_CB   pIrdaLinkCb = IrdaBindingContext;
    
    DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: IrdaReceivePacket(%X)\n"), Packet));

    if (pIrdaLinkCb->UnbindContext)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: Ignoring received packet, link closing\n")));
        return 0;
    }

    NdisQueryPacket(Packet, NULL, &BufCnt, &pNdisBuf, &TotalLen);

    ASSERT(BufCnt == 1);
    
    NdisQueryBufferSafe(pNdisBuf, &pData, &BufLen, NormalPagePriority);
    
    if (pData == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: NdisQueryBufferSafe failed\n")));
        return 0;
    }    

    pIrdaLinkCb->WaitMinTat = TRUE;
    
    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->RxMsgFreeList, &pIrdaLinkCb->SpinLock);    

    if (pMsg == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: RxMsgFreeList depleted!\n")));
        return 0;
    }
    pIrdaLinkCb->RxMsgFreeListLen--;

    pMsg->Prim                  = MAC_DATA_IND;
    pMsg->IRDA_MSG_pRead        = pData;
    pMsg->IRDA_MSG_pWrite       = pData + BufLen;
    pMsg->DataContext           = Packet;
    
    NdisInterlockedInsertTailList(&pIrdaLinkCb->RxMsgList,
                                  &pMsg->Linkage,
                                  &pIrdaLinkCb->SpinLock);
                                  
    DBG_FRAME(pIrdaLinkCb,
              DBG_RXFRAME, pMsg->IRDA_MSG_pRead,
              (UINT) (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead),
              (UINT) ((pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead))
                         - IRLAP_HEADER_LEN);        

    #ifdef IRDA_RX_SYSTEM_THREAD
    
        KeSetEvent(&pIrdaLinkCb->EvRxMsgReady, 0, FALSE);
        
    #else
    
        IrdaEventSchedule(&pIrdaLinkCb->EvRxMsgReady, pIrdaLinkCb);
        
    #endif    

    return 1; // Ownership reference count of packet
}

/***************************************************************************
*
*   Delete all control blocks for a given link
*
*/
VOID
DeleteIrdaLink(PVOID Arg)
{
    PIRDA_LINK_CB           pIrdaLinkCb = (PIRDA_LINK_CB) Arg;
    int                     i;
    PIRDA_MSG               pMsg;
        
    DEBUGMSG(1, (TEXT("IRNDIS: Delete instance %X\n"), pIrdaLinkCb));

    NdisFreeBufferPool(pIrdaLinkCb->BufferPool);
    
    for (i = 0; i < IRDA_NDIS_PACKET_POOL_SIZE; i++)
    {
        PIRDA_PROTOCOL_RESERVED pReserved;
        PNDIS_PACKET            NdisPacket;
    
        pReserved = (PIRDA_PROTOCOL_RESERVED) NdisInterlockedRemoveHeadList(
                                &pIrdaLinkCb->PacketList, &pIrdaLinkCb->SpinLock);
                                
        if (pReserved == NULL)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("Not all NdisPackets were on list when deleting\n")));
            ASSERT(0);
            break;
        }                            

        NdisPacket = CONTAINING_RECORD(pReserved, NDIS_PACKET, ProtocolReserved);
        
        NdisFreePacket(NdisPacket);
    }
    
    NdisFreePacketPool(pIrdaLinkCb->PacketPool);

    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->TxMsgFreeList, &pIrdaLinkCb->SpinLock);
    while (pMsg != NULL)
    {
        NdisFreeMemory(pMsg, sizeof(IRDA_MSG) + IRDA_MSG_DATA_SIZE, 0);
        pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
            &pIrdaLinkCb->TxMsgFreeList, &pIrdaLinkCb->SpinLock);        
    }

    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->RxMsgFreeList, &pIrdaLinkCb->SpinLock);
    while (pMsg != NULL)
    {
        NdisFreeMemory(pMsg, sizeof(IRDA_MSG), 0);
        pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
            &pIrdaLinkCb->RxMsgFreeList, &pIrdaLinkCb->SpinLock);        
    }


    IrlapDeleteInstance(pIrdaLinkCb->IrlapContext);
    
    IrlmpDeleteInstance(pIrdaLinkCb->IrlmpContext);

    NdisFreeSpinLock(&pIrdaLinkCb->SpinLock);
        
    NdisFreeMemory(pIrdaLinkCb, sizeof(IRDA_LINK_CB), 0);
}    

/***************************************************************************
*
*   Initialize local Qos with info from adapters register and globals
*   initialized at driver entry time (from protocol's registery)
*
*/
VOID InitializeLocalQos(
    IN OUT  IRDA_QOS_PARMS      *pQos,
    IN      PNDIS_STRING        ConfigPath)
{
    NDIS_HANDLE             ConfigHandle;
    NDIS_STRING             DataSizeStr = NDIS_STRING_CONST("DATASIZE");
    NDIS_STRING             WindowSizeStr = NDIS_STRING_CONST("WINDOWSIZE");
    NDIS_STRING             MaxTatStr = NDIS_STRING_CONST("MAXTURNTIME");
    NDIS_STRING             BofsStr = NDIS_STRING_CONST("BOFS");    
	PNDIS_CONFIGURATION_PARAMETER ParmVal;
    NDIS_STATUS             Status;
    
    PAGED_CODE();

    pQos->bfDisconnectTime  = DisconnectTime;
    pQos->bfDataSize        = IRLAP_DEFAULT_DATASIZE;
    pQos->bfWindowSize      = IRLAP_DEFAULT_WINDOWSIZE;
    pQos->bfMaxTurnTime     = IRLAP_DEFAULT_MAXTAT;
    pQos->bfBofs            = BOFS_0;

//    DbgPrint("irda: adapter config path- %ws",ConfigPath->Buffer);

    NdisOpenProtocolConfiguration(&Status,
                                  &ConfigHandle,
                                  ConfigPath);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisReadConfiguration(&Status, 
                              &ParmVal,
                              ConfigHandle, 
                              &DataSizeStr,
                              NdisParameterInteger);

        if (Status == NDIS_STATUS_SUCCESS)
            pQos->bfDataSize = ParmVal->ParameterData.IntegerData;

        NdisReadConfiguration(&Status, 
                              &ParmVal,
                              ConfigHandle, 
                              &WindowSizeStr,
                              NdisParameterInteger);    

        if (Status == NDIS_STATUS_SUCCESS)
            pQos->bfWindowSize = ParmVal->ParameterData.IntegerData;

        NdisReadConfiguration(&Status, 
                              &ParmVal,
                              ConfigHandle, 
                              &MaxTatStr,
                              NdisParameterInteger);    

        if (Status == NDIS_STATUS_SUCCESS)
            pQos->bfMaxTurnTime = ParmVal->ParameterData.IntegerData;

        NdisReadConfiguration(&Status, 
                              &ParmVal,
                              ConfigHandle, 
                              &BofsStr,
                              NdisParameterInteger);    

        if (Status == NDIS_STATUS_SUCCESS)
            pQos->bfBofs = ParmVal->ParameterData.IntegerData;    

        NdisCloseConfiguration(ConfigHandle);
    }
    
    DEBUGMSG(DBG_NDIS, (TEXT("DataSize %x, WindowSize %x, MaxTat %x\n"),
                        pQos->bfDataSize, pQos->bfWindowSize,
                        pQos->bfMaxTurnTime));
    
}

/***************************************************************************
*
*   Protocol bind adapter handler
*
*/
VOID IrdaBindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            AdapterName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )
{
    NDIS_STATUS             OpenErrorStatus;
    NDIS_MEDIUM             MediumArray[] = {NdisMediumIrda};
    UINT                    SelectedMediumIndex;
    PIRDA_LINK_CB           pIrdaLinkCb;
    UINT                    UintArray[16];
    UINT                    UintArrayCnt;
    IRDA_MSG                *pMsg;
    int                     i, WinSize;
    IRDA_QOS_PARMS          LocalQos;    
    UCHAR                   DscvInfoBuf[64];
    int                     DscvInfoLen;
    ULONG                   Val, Mask;
    NDIS_STATUS             CloseStatus;
    ULONG                   BytesToCopy;
#ifdef IRDA_RX_SYSTEM_THREAD
    HANDLE                  hSysThread;
#endif 
    
    DEBUGMSG(1, (TEXT("IRNDIS: IrdaBindAdapter() \"%ws\"\n"), AdapterName->Buffer));
    
    NdisAllocateMemoryWithTag((PVOID *)&pIrdaLinkCb, 
                              sizeof(IRDA_LINK_CB), 
                              MT_IRNDIS_LINKCB);

    if (!pIrdaLinkCb)
    {
        *pStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit10;
    }

    NdisZeroMemory(pIrdaLinkCb, sizeof(IRDA_LINK_CB));
    
    ReferenceInit(&pIrdaLinkCb->RefCnt, pIrdaLinkCb, DeleteIrdaLink);
    REFADD(&pIrdaLinkCb->RefCnt, 'DNIB');

    pIrdaLinkCb->UnbindContext = NULL;
    pIrdaLinkCb->WaitMinTat = FALSE;
    pIrdaLinkCb->PnpContext = SystemSpecific2;
    
    NdisInitializeEvent(&pIrdaLinkCb->OpenCloseEvent);

    NdisResetEvent(&pIrdaLinkCb->OpenCloseEvent);

    NdisInitializeEvent(&pIrdaLinkCb->ResetEvent);

    NdisResetEvent(&pIrdaLinkCb->ResetEvent);


    NdisAllocateSpinLock(&pIrdaLinkCb->SpinLock);

    INIT_LINK_LOCK(pIrdaLinkCb);
    
    NdisInitializeListHead(&pIrdaLinkCb->TxMsgFreeList);
    NdisInitializeListHead(&pIrdaLinkCb->RxMsgFreeList);
    NdisInitializeListHead(&pIrdaLinkCb->RxMsgList);    
    
#ifdef IRDA_RX_SYSTEM_THREAD
    KeInitializeEvent(&pIrdaLinkCb->EvRxMsgReady, SynchronizationEvent, FALSE);
    KeInitializeEvent(&pIrdaLinkCb->EvKillRxThread, SynchronizationEvent, FALSE);    
#else
    IrdaEventInitialize(&pIrdaLinkCb->EvRxMsgReady, RxThread);
#endif    

#if DBG
    pIrdaLinkCb->MediaSenseTimer.pName = "MediaSense";
#endif    
    IrdaTimerInitialize(&pIrdaLinkCb->MediaSenseTimer,
                        MediaSenseExp,
                        0,
                        pIrdaLinkCb,
                        pIrdaLinkCb);
    
    NdisAllocateBufferPool(pStatus,
                           &pIrdaLinkCb->BufferPool,
                           IRDA_NDIS_BUFFER_POOL_SIZE);
    
    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("NdisAllocateBufferPool failed\n")));
        goto error10; 
    }
    
    NdisAllocatePacketPool(pStatus,
                           &pIrdaLinkCb->PacketPool,
                           IRDA_NDIS_PACKET_POOL_SIZE,
                           sizeof(IRDA_PROTOCOL_RESERVED)-1 + \
                           sizeof(NDIS_IRDA_PACKET_INFO));
    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("NdisAllocatePacketPool failed\n")));        
        goto error20; 
    }
    
    NdisInitializeListHead(&pIrdaLinkCb->PacketList);    

    for (i = 0; i < IRDA_NDIS_PACKET_POOL_SIZE; i++)
    {
        PIRDA_PROTOCOL_RESERVED pReserved;
        PNDIS_PACKET            NdisPacket;
        
        NdisAllocatePacket(pStatus, &NdisPacket, pIrdaLinkCb->PacketPool);
        
        if (*pStatus != NDIS_STATUS_SUCCESS)
        {
            ASSERT(0);
            goto error30;
        }    
        
        pReserved =
            (PIRDA_PROTOCOL_RESERVED)(NdisPacket->ProtocolReserved);
        
        NdisInterlockedInsertTailList(&pIrdaLinkCb->PacketList,
                                      &pReserved->Linkage,
                                      &pIrdaLinkCb->SpinLock);
    }

    // Allocate a list of Irda messages w/ data for internally
    // generated LAP messages
    pIrdaLinkCb->TxMsgFreeListLen = 0;
    for (i = 0; i < IRDA_MSG_LIST_LEN; i++)
    {
        NdisAllocateMemoryWithTag(&pMsg, sizeof(IRDA_MSG) + IRDA_MSG_DATA_SIZE,
                                  MT_IRNDIS_TX_IMSG);
        if (pMsg == NULL)
        {
            *pStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto error40;
        }
        NdisInterlockedInsertTailList(&pIrdaLinkCb->TxMsgFreeList,
                                      &pMsg->Linkage,
                                      &pIrdaLinkCb->SpinLock);
        pIrdaLinkCb->TxMsgFreeListLen++;
    }

    // Build the discovery info    
    Val = HintCharSet;
    DscvInfoLen = 0;
    for (i = 0, Mask = 0xFF000000; i < 4; i++, Mask >>= 8)
    {
        if (Mask & Val || DscvInfoLen > 0)
        {
            DscvInfoBuf[DscvInfoLen++] = (UCHAR)
                ((Mask & Val) >> (8 * (3-i)));
        }
    }

    BytesToCopy= sizeof(DscvInfoBuf)-DscvInfoLen < NickNameLen ?
                     sizeof(DscvInfoBuf)-DscvInfoLen : NickNameLen;

    RtlCopyMemory(DscvInfoBuf+DscvInfoLen, NickName, BytesToCopy);
    DscvInfoLen += BytesToCopy;

    NdisOpenAdapter(
        pStatus,
        &OpenErrorStatus,
        &pIrdaLinkCb->NdisBindingHandle,
        &SelectedMediumIndex,
        MediumArray,
        1,
        NdisIrdaHandle,
        pIrdaLinkCb,
        AdapterName,
        0,
        NULL);
    
    DEBUGMSG(DBG_NDIS, (TEXT("NdisOpenAdapter(%X), status %x\n"),
                        pIrdaLinkCb->NdisBindingHandle, *pStatus));

    if (*pStatus == NDIS_STATUS_PENDING)
    {
        NdisWaitEvent(&pIrdaLinkCb->OpenCloseEvent, 0);
        *pStatus = pIrdaLinkCb->OpenCloseStatus;
    }

    if (*pStatus != NDIS_STATUS_SUCCESS)
    { 
        DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: Failed %X\n"), *pStatus));
        goto error40;
    }

    InitializeLocalQos(&LocalQos, (PNDIS_STRING) SystemSpecific1);

    //
    // Query adapters capabilities and store in LocalQos
    //

    //
    //  query the adpater for the spuuported speeds
    //
    UintArrayCnt = sizeof(UintArray)/sizeof(UINT);
    *pStatus = IrdaQueryOid(pIrdaLinkCb,
                            OID_IRDA_SUPPORTED_SPEEDS,
                            UintArray, &UintArrayCnt);
    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR,
                 (TEXT("Query IRDA_SUPPORTED_SPEEDS failed %x\n"),
                  *pStatus));
        goto error50;
    }

    OidToLapQos(vBaudTable,
                UintArray,
                UintArrayCnt,
                &LocalQos.bfBaud,
                FALSE);

    //
    //  query the adapter for min turn araound time
    //
    UintArrayCnt = sizeof(UintArray)/sizeof(UINT);
    *pStatus = IrdaQueryOid(pIrdaLinkCb,
                            OID_IRDA_TURNAROUND_TIME,
                            UintArray, &UintArrayCnt);

    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR,
                 (TEXT("Query IRDA_IRDA_TURNARROUND_TIME failed %x\n"),
                  *pStatus));
        goto error50;
    }

    OidToLapQos(vMinTATTable,
                UintArray,
                UintArrayCnt,
                &LocalQos.bfMinTurnTime,
                FALSE);            

    //
    //  query the adapter for max receive window size
    //
    UintArrayCnt = sizeof(UintArray)/sizeof(UINT);
    *pStatus = IrdaQueryOid(pIrdaLinkCb,
                            OID_IRDA_MAX_RECEIVE_WINDOW_SIZE,
                            UintArray, &UintArrayCnt);
    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        // Not fatal
        DEBUGMSG(DBG_WARN,
                 (TEXT("Query IRDA_MAX_RECEIVE_WINDOW_SIZE failed %x\n"),
                  *pStatus));
    }
    else
    {
        OidToLapQos(vWinSizeTable,
                    UintArray,
                    UintArrayCnt,
                    &LocalQos.bfWindowSize,
                    TRUE);
    }            


    //
    //  query the adapter for extra bofs
    //
    UintArrayCnt = sizeof(UintArray)/sizeof(UINT);
    *pStatus = IrdaQueryOid(pIrdaLinkCb,
                            OID_IRDA_EXTRA_RCV_BOFS,
                            UintArray, &UintArrayCnt);
    if (*pStatus != NDIS_STATUS_SUCCESS)
    {
        // Not fatal
        DEBUGMSG(DBG_WARN,
                 (TEXT("Query OID_IRDA_EXTRA_RCV_BOFS failed %x\n"),
                  *pStatus));
    }
    else
    {
        OidToLapQos(vBOFSTable,
                    UintArray,
                    UintArrayCnt,
                    &LocalQos.bfBofs,
                    FALSE
                    );
    }            




    if (MaxWindow)
    {
        LocalQos.bfWindowSize &= MaxWindow;
    }

    // Get the window size and data size to determine the number
    // and size of Irda messages to allocate for receiving frames
    WinSize = IrlapGetQosParmVal(vWinSizeTable,
                                 LocalQos.bfWindowSize,
                                 NULL);

    pIrdaLinkCb->RxMsgDataSize = IrlapGetQosParmVal(vDataSizeTable,
                                                    LocalQos.bfDataSize,
                                                    NULL) + IRLAP_HEADER_LEN;

    pIrdaLinkCb->RxMsgFreeListLen = 0;
    for (i = 0; i < WinSize + 1; i++)
    {
        // Allocate room for data in case we get indicated data
        // that must be copied (IrdaReceive vs. IrdaReceivePacket)
        // LATER NOTE: We don't support IrdaReceive now to save locked mem
        NdisAllocateMemoryWithTag(&pMsg, sizeof(IRDA_MSG) +
                           pIrdaLinkCb->RxMsgDataSize,
                           MT_IRNDIS_RX_IMSG);
        if (pMsg == NULL)
        {
            *pStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto error50;
        }
        NdisInterlockedInsertTailList(&pIrdaLinkCb->RxMsgFreeList,
                                      &pMsg->Linkage,
                                      &pIrdaLinkCb->SpinLock);
        pIrdaLinkCb->RxMsgFreeListLen++;
    }

    // Create an instance of IrLAP
    IrlapOpenLink(pStatus,
                  pIrdaLinkCb,
                  &LocalQos,
                  DscvInfoBuf,
                  DscvInfoLen,
                  Slots,
                  NickName,
                  NickNameLen,
                  (UCHAR)(HintCharSet & 0xFF));

    if (*pStatus != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: IrlapOpenLink failed %X\n"), *pStatus));
        goto error50;
    }

#ifdef IRDA_RX_SYSTEM_THREAD
    *pStatus = (NDIS_STATUS) PsCreateSystemThread(
                                &pIrdaLinkCb->hRxThread,
                                (ACCESS_MASK) 0L,
                                NULL,
                                NULL,
                                NULL,
                                RxThread,
                                pIrdaLinkCb);
    
    if (*pStatus != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRNDIS: failed create system thread\n")));
        goto error60;
    }    
#endif    
    
    goto exit10;
    
error60:

    LOCK_LINK(pIrdaLinkCb);

    IrlmpCloseLink(pIrdaLinkCb);
    
    UNLOCK_LINK(pIrdaLinkCb);
    
    goto exit10;    
    
error50:
    
    NdisCloseAdapter(&CloseStatus, pIrdaLinkCb->NdisBindingHandle);
    

    if (CloseStatus == NDIS_STATUS_PENDING)
    {
        NdisWaitEvent(&pIrdaLinkCb->OpenCloseEvent, 0);
        DEBUGMSG(DBG_NDIS, ("IRNDIS: Close wait complete\n"));        
    }


error40:

    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->TxMsgFreeList, &pIrdaLinkCb->SpinLock);
    while (pMsg != NULL)
    {
        NdisFreeMemory(pMsg, sizeof(IRDA_MSG) + IRDA_MSG_DATA_SIZE, 0);
        pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
            &pIrdaLinkCb->TxMsgFreeList, &pIrdaLinkCb->SpinLock);        
    }

    pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
        &pIrdaLinkCb->RxMsgFreeList, &pIrdaLinkCb->SpinLock);
    while (pMsg != NULL)
    {
        NdisFreeMemory(pMsg, sizeof(IRDA_MSG), 0);
        pMsg = (IRDA_MSG *) NdisInterlockedRemoveHeadList(
            &pIrdaLinkCb->RxMsgFreeList, &pIrdaLinkCb->SpinLock);        
    }

error30:
    for (i = 0; i < IRDA_NDIS_PACKET_POOL_SIZE; i++)
    {
        PIRDA_PROTOCOL_RESERVED pReserved;
        PNDIS_PACKET            NdisPacket;
    
        pReserved = (PIRDA_PROTOCOL_RESERVED) NdisInterlockedRemoveHeadList(
                                &pIrdaLinkCb->PacketList, &pIrdaLinkCb->SpinLock);
                                
        if (pReserved == NULL)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("Not all NdisPackets were on list when deleting\n")));
            ASSERT(0);
            break;;
        }                            

        NdisPacket = CONTAINING_RECORD(pReserved, NDIS_PACKET, ProtocolReserved);
        
        NdisFreePacket(NdisPacket);
    }

    NdisFreePacketPool(pIrdaLinkCb->PacketPool);
    
error20:
    NdisFreeBufferPool(pIrdaLinkCb->BufferPool);
    
error10:

    NdisFreeMemory(pIrdaLinkCb, sizeof(IRDA_LINK_CB), 0);
    
exit10:
    DEBUGMSG(DBG_NDIS, (TEXT("IRNDIS: -IrdaBindAdapter() status %x\n"),
                        *pStatus));
    
    return;
}

/***************************************************************************
*
*   Protocol unbind adapter handler
*
*/
VOID IrdaUnbindAdapter(
    OUT PNDIS_STATUS            pStatus,
    IN  NDIS_HANDLE             IrdaBindingContext,
    IN  NDIS_HANDLE             UnbindContext
    )
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;
    
    DEBUGMSG(1, (TEXT("+IrdaUnbindAdapter()\n")));
    
    pIrdaLinkCb->UnbindContext = UnbindContext;

    #ifdef IRDA_RX_SYSTEM_THREAD
    KeSetEvent(&pIrdaLinkCb->EvKillRxThread, 0, FALSE);
    #endif
    
    LOCK_LINK(pIrdaLinkCb);
    
    IrlmpCloseLink(pIrdaLinkCb);
    
    UNLOCK_LINK(pIrdaLinkCb);
    
    *pStatus = NDIS_STATUS_PENDING;

    DEBUGMSG(1, (TEXT("-IrdaUnbindAdapter() Status %x\n"),
                        *pStatus));

    return;
}

NDIS_STATUS
IrdaPnpEvent(
    IN NDIS_HANDLE      IrdaBindingContext,
    IN PNET_PNP_EVENT   pNetPnpEvent
    )
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) IrdaBindingContext;
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    
    DEBUGMSG(1, (TEXT("IRNDIS: PnpEvent:%X, NetEvent:%d Buffer:%X(%d)\n"), 
            pNetPnpEvent,
            pNetPnpEvent->NetEvent,
            pNetPnpEvent->Buffer, 
            pNetPnpEvent->BufferLength));
            
    switch (pNetPnpEvent->NetEvent)
    {

        case NetEventQueryPower:
            break;

        case NetEventSetPower:
        {
            PNET_DEVICE_POWER_STATE pPowerState = pNetPnpEvent->Buffer;
            
            ASSERT(pPowerState);
            
            if (*pPowerState == NetDeviceStateD0)
            {
                DEBUGMSG(1, (TEXT("IRNDIS: NetEventSetPower, full power state\n")));
                pIrdaLinkCb->LowPowerSt = FALSE;
            }
            else
            {
                NDIS_STATUS    ResetStatus;

                DEBUGMSG(1, (TEXT("IRNDIS: NetEventSetPower, low power state\n")));            
                pIrdaLinkCb->LowPowerSt = TRUE;

                if (pIrdaLinkCb->SendOutCnt > 0) {

                    NdisResetEvent(&pIrdaLinkCb->ResetEvent);

                    NdisReset(
                        &ResetStatus,
                        pIrdaLinkCb->NdisBindingHandle
                        );

                    if (ResetStatus == NDIS_STATUS_PENDING) {

                        NdisWaitEvent(&pIrdaLinkCb->ResetEvent,0);
                    }
                }

                NdisAcquireSpinLock(&pIrdaLinkCb->SpinLock);
            
                if (pIrdaLinkCb->SendOutCnt)
                {
                    pIrdaLinkCb->pNetPnpEvent = pNetPnpEvent;
                    Status = NDIS_STATUS_PENDING;
                }                
            
                NdisReleaseSpinLock(&pIrdaLinkCb->SpinLock);
            }
        }    
    }
      
    return Status;
}

/***************************************************************************
*
*   IrdaInitialize - register Irda with Ndis, get Irlap parms from registry
*
*/
NTSTATUS IrdaInitialize(
    PNDIS_STRING    ProtocolName,
    PUNICODE_STRING RegistryPath,
    PUINT           pLazyDscvInterval)
{
    NDIS_STATUS                     Status;
    NDIS_PROTOCOL_CHARACTERISTICS   pc;
    OBJECT_ATTRIBUTES               ObjectAttribs;
    HANDLE                          KeyHandle;
    UNICODE_STRING                  ValStr;
    PKEY_VALUE_FULL_INFORMATION     FullInfo;
    ULONG                           Result;
    UCHAR                           Buf[WORK_BUF_SIZE];
    WCHAR                           StrBuf[WORK_BUF_SIZE];
    UNICODE_STRING                  Path;
    ULONG                           i, Multiplier;
    ULONG                           PagingFlags = 0;

    DEBUGMSG(DBG_NDIS,(TEXT("+IrdaInitialize()\n")));

    // Get protocol configuration from registry
    Path.Buffer         = StrBuf;
    Path.MaximumLength  = WORK_BUF_SIZE;
    Path.Length         = 0;

    RtlAppendUnicodeStringToString(&Path, RegistryPath);

    RtlAppendUnicodeToString(&Path, L"\\Parameters");
    
    InitializeObjectAttributes(&ObjectAttribs,
                               &Path,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&KeyHandle, KEY_READ, &ObjectAttribs);

    Slots           = IRLAP_DEFAULT_SLOTS;
    HintCharSet     = IRLAP_DEFAULT_HINTCHARSET;
    DisconnectTime  = IRLAP_DEFAULT_DISCONNECTTIME;
    
    *pLazyDscvInterval = 0;
    
    if (Status == STATUS_SUCCESS)
    {
        RtlInitUnicodeString(&ValStr, L"PagingFlags");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        if (Status == STATUS_SUCCESS && FullInfo->Type == REG_DWORD)
        {
            PagingFlags = *((ULONG UNALIGNED *) ((PCHAR)FullInfo +
                                           FullInfo->DataOffset)); 
            DEBUGMSG(1, (TEXT("IRDA: Registry PagingFlags %X\n"), PagingFlags));
            
        }
        
        RtlInitUnicodeString(&ValStr, L"DiscoveryRate");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        if (Status == STATUS_SUCCESS && FullInfo->Type == REG_DWORD)
        {
            *pLazyDscvInterval = *((ULONG UNALIGNED *) ((PCHAR)FullInfo +
                                           FullInfo->DataOffset)); 
            DEBUGMSG(1, (TEXT("IRDA: Registry LasyDscvInterval %d\n"), *pLazyDscvInterval));
        }
    
        RtlInitUnicodeString(&ValStr, L"Slots");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        if (Status == STATUS_SUCCESS && FullInfo->Type == REG_DWORD)
        {
            Slots = *((ULONG UNALIGNED *) ((PCHAR)FullInfo +
                                           FullInfo->DataOffset));
            DEBUGMSG(1, (TEXT("IRDA: Registry slots %d\n"), Slots));
        }

        RtlInitUnicodeString(&ValStr, L"HINTCHARSET");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;        
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        if (Status == STATUS_SUCCESS && FullInfo->Type == REG_DWORD)
        {
            HintCharSet = *((ULONG UNALIGNED *) ((PCHAR)FullInfo +
                                                 FullInfo->DataOffset));
            DEBUGMSG(1, (TEXT("IRDA: Registry HintCharSet %X\n"), HintCharSet));
        }
        
        RtlInitUnicodeString(&ValStr, L"DISCONNECTTIME");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;        
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        
        if (Status == STATUS_SUCCESS && FullInfo->Type == REG_DWORD)
        {
            DisconnectTime = *((ULONG UNALIGNED *) ((PCHAR)FullInfo +
                                                    FullInfo->DataOffset));
            DEBUGMSG(1, (TEXT("IRDA: Registry DisconnectTime %X\n"), DisconnectTime));
        }
        
        RtlInitUnicodeString(&ValStr, L"WindowSize");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;        
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        
        if (Status == STATUS_SUCCESS && FullInfo->Type == REG_DWORD)
        {
            MaxWindow = *((ULONG UNALIGNED *) ((PCHAR)FullInfo +
                                                    FullInfo->DataOffset));
            DEBUGMSG(1, (TEXT("IRDA: Registry MaxWindow %X\n"), MaxWindow));
        }
        
        ZwClose(KeyHandle);
    }
    else
        DEBUGMSG(1, (TEXT("Failed to open key %x\n"), Status));
    
    DEBUGMSG(DBG_NDIS, (TEXT("Slots %x, HintCharSet %x, Disconnect %x\n"),
                        Slots, HintCharSet, DisconnectTime));

    //
    //  adjust the Slots value to make sure it is valid. Can only be 1, 6, 8, 16
    //
    if (Slots > 8) {

        Slots = 16;

    } else {

        if (Slots > 6) {

            Slots = 8;

        } else {

            if (Slots > 1) {

                Slots = 6;

            } else {

                Slots = 1;
            }
        }
    }

    //
    // Use the ComputerName as the discovery nickname
    //
    RtlZeroMemory(&NickName,sizeof(NickName));
    NickNameLen     = 0;

    RtlInitUnicodeString(
        &Path,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName");
    
    InitializeObjectAttributes(&ObjectAttribs,
                               &Path,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&KeyHandle, KEY_READ, &ObjectAttribs);
    
    if (Status == STATUS_SUCCESS)
    {

        RtlInitUnicodeString(&ValStr, L"ComputerName");
        FullInfo = (PKEY_VALUE_FULL_INFORMATION) Buf;
        Status = ZwQueryValueKey(KeyHandle,
                                 &ValStr,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 WORK_BUF_SIZE,
                                 &Result);
        NickNameLen = 0;


        HintCharSet &= ~0xff;
        //
        //  check to see if any of the machine name characters are non ansi, if so
        //  use unicode. Otherwise, send as ansi so more characters can be displayed.
        //
        for (i=0; i< FullInfo->DataLength/sizeof(WCHAR); i++) {

            PWCHAR   SourceString=(PWCHAR)((PUCHAR)FullInfo + FullInfo->DataOffset);

            if (SourceString[i] > 127) {

                HintCharSet |= UNICODE_CHAR_SET;
                break;
            }
        }

        if ((HintCharSet & 0XFF) == UNICODE_CHAR_SET) {

            PWCHAR   SourceString=(PWCHAR)((PUCHAR)FullInfo + FullInfo->DataOffset);
            PWCHAR   DestString=(PWCHAR)NickName;

            for (i=0; i< FullInfo->DataLength/sizeof(WCHAR) && i < NICK_NAME_LEN/sizeof(WCHAR) ; i++) {

                DestString[i]=SourceString[i];
                NickNameLen+=sizeof(WCHAR);
            }

        } else {

            UNICODE_STRING   SourceString;
            ANSI_STRING      DestString;

            SourceString.Length=(USHORT)FullInfo->DataLength;
            SourceString.MaximumLength=SourceString.Length;
            SourceString.Buffer=(PWCHAR)((PUCHAR)FullInfo + FullInfo->DataOffset);

            DestString.MaximumLength=NICK_NAME_LEN;
            DestString.Buffer=NickName;

            RtlUnicodeStringToAnsiString(&DestString, &SourceString, FALSE);

            NickNameLen=DestString.Length;

        }
        
        ZwClose(KeyHandle);
    }
    
    // Disable paging of code and data if indicated in registery
    
    if (PagingFlags & DISABLE_CODE_PAGING)
    {
        // Any function in the section PAGEIRDA that is locked down
        // will cause the entire section to be locked into memory
        
        MmLockPagableCodeSection(OidToLapQos);
        
        DEBUGMSG(DBG_WARN, (TEXT("IRNDIS: Code paging is disabled\n")));
    }
    
    if (PagingFlags & DISABLE_DATA_PAGING)
    {
        MmLockPagableDataSection(&DisconnectTime);
        
        DEBUGMSG(DBG_WARN, (TEXT("IRNDIS: Data paging is disabled\n")));        
    }
    
    // Register protocol with Ndis
    NdisZeroMemory((PVOID)&pc, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    pc.MajorNdisVersion             = 0x04;
    pc.MinorNdisVersion             = 0x00;
    pc.OpenAdapterCompleteHandler   = IrdaOpenAdapterComplete;
    pc.CloseAdapterCompleteHandler  = IrdaCloseAdapterComplete;
    pc.SendCompleteHandler          = IrdaSendComplete;
    pc.TransferDataCompleteHandler  = IrdaTransferDataComplete;
    pc.ResetCompleteHandler         = IrdaResetComplete;
    pc.RequestCompleteHandler       = IrdaRequestComplete;
    pc.ReceiveHandler               = IrdaReceive;
    pc.ReceiveCompleteHandler       = IrdaReceiveComplete;
    pc.StatusHandler                = IrdaStatus;
    pc.StatusCompleteHandler        = IrdaStatusComplete;
    pc.BindAdapterHandler           = IrdaBindAdapter;
    pc.UnbindAdapterHandler         = IrdaUnbindAdapter;
    pc.UnloadHandler                = NULL;
    pc.Name                         = *ProtocolName;
    pc.ReceivePacketHandler         = IrdaReceivePacket;
    
#if defined(_PNP_POWER_)
    pc.PnPEventHandler              = IrdaPnpEvent;
#endif    
    
    NdisRegisterProtocol(&Status,
                         &NdisIrdaHandle,
                         (PNDIS_PROTOCOL_CHARACTERISTICS)&pc,
                         sizeof(NDIS40_PROTOCOL_CHARACTERISTICS));
 
    IrlmpInitialize();    

    DEBUGMSG(DBG_NDIS, (TEXT("-IrdaInitialize(), rc %x\n"), Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irlmp\irlmp.c ===
/*****************************************************************************
*
*  Copyright (c) 1995 Microsoft Corporation
*
*       @doc
*       @module irlmp.c | Provides IrLMP API
*
*       Author: mbert
*
*       Date: 4/15/95
*
*       @comm
*
*  This module exports the following API's:
*
*       IrlmpOpenLink()
*       IrlmpCloseLink()
*       IrlmpDown()
*       IrlmpUp()
*
*
*                |---------|
*                |   Tdi   |
*                |---------|
*                  /|\  |
*                   |   |
*           TdiUp() |   | IrlmpDown()
*                   |   |
*                   |  \|/
*                |---------|      IrdaTimerStart()     |-------|
*                |         |-------------------------->|       |
*                |  IRLMP  |                           | TIMER |
*                |         |<--------------------------|       |
*                |---------|      ExpFunc()            |-------|
*                  /|\  |
*                   |   |
*         IrlmpUp() |   | IrlapDown()
*                   |   |
*                   |  \|/
*                |---------|
*                |  IRLAP  |
*                |---------|
*
* See irda.h for complete message definitions
*
* Connection context for IRLMP and Tdi are exchanged
* during connection establishment:
*
*   Active connection:
*      +------------+ IRLMP_CONNECT_REQ(TdiContext)           +-------+
*      |            |---------------------------------------->|       |
*      |    Tdi     | IRLMP_CONNECT_CONF(IrlmpContext)        | IRMLP |
*      |            |<----------------------------------------|       |
*      +------------+                                         +-------+
*
*   Passive connection:
*      +------------+ IRLMP_CONNECT_IND(IrlmpContext)         +-------+
*      |            |<----------------------------------------|       |
*      |    Tdi     | IRLMP_CONNECT_RESP(TdiContext)          | IRMLP |
*      |            |---------------------------------------->|       |
*      +------------+                                         +-------+
*
*   
*   Tdi calling IrlmpDown(void *pIrlmpContext, IRDA_MSG *pMsg)
*       pIrlmpContext = NULL for the following:
*       pMsg->Prim = IRLMP_DISCOVERY_REQ,
*                    IRLMP_CONNECT_REQ,
*                    IRLMP_FLOWON_REQ,
*                    IRLMP_GETVALUEBYCLASS_REQ.
*       In all other cases, the pIRLMPContext must be a valid context.
*
*   IRLMP calling TdiUp(void *TdiContext, IRDA_MSG *pMsg)
*       TdiContext = NULL for the following:
*       pMsg->Prim = IRLAP_STATUS_IND,
*                    IRLMP_DISCOVERY_CONF,
*                    IRLMP_CONNECT_IND,
*                    IRLMP_GETVALUEBYCLASS_CONF.
*       In all other cases, the TdiContext will have a valid context.
*/
#include <irda.h>
#include <irioctl.h>
#include <irlap.h>
#include <irlmp.h>
#include <irlmpp.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

// IAS
UCHAR IAS_IrLMPSupport[] = {IAS_IRLMP_VERSION, IAS_SUPPORT_BIT_FIELD, 
                           IAS_LMMUX_SUPPORT_BIT_FIELD};

CHAR IasClassName_Device[]         = "Device";
CHAR IasAttribName_DeviceName[]    = "DeviceName";
CHAR IasAttribName_IrLMPSupport[]  = "IrLMPSupport";
CHAR IasAttribName_TTPLsapSel[]    = "IrDA:TinyTP:LsapSel";
CHAR IasAttribName_IrLMPLsapSel[]  = "IrDA:IrLMP:LsapSel";
CHAR IasAttribName_IrLMPLsapSel2[] = "IrDA:IrLMP:LSAPSel"; // jeez

UCHAR IasClassNameLen_Device        = sizeof(IasClassName_Device)-1;
UCHAR IasAttribNameLen_DeviceName   = sizeof(IasAttribName_DeviceName)-1;
UCHAR IasAttribNameLen_IrLMPSupport = sizeof(IasAttribName_IrLMPSupport)-1;
UCHAR IasAttribNameLen_TTPLsapSel   = sizeof(IasAttribName_TTPLsapSel)-1;
UCHAR IasAttribNameLen_IrLMPLsapSel = sizeof(IasAttribName_IrLMPLsapSel)-1;

UINT NextObjectId;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif


// Globals
LIST_ENTRY      RegisteredLsaps;
LIST_ENTRY      IasObjects;
LIST_ENTRY      gDeviceList;
IRDA_EVENT      EvDiscoveryReq;
IRDA_EVENT      EvConnectReq;
IRDA_EVENT      EvConnectResp;
IRDA_EVENT      EvLmConnectReq;
IRDA_EVENT      EvIrlmpCloseLink;
IRDA_EVENT      EvRetryIasQuery;
BOOLEAN         DscvReqScheduled;
LIST_ENTRY      IrdaLinkCbList;
KSPIN_LOCK      gSpinLock;

// Prototypes
STATIC UINT CreateLsap(PIRLMP_LINK_CB, IRLMP_LSAP_CB **);
STATIC VOID FreeLsap(IRLMP_LSAP_CB *);
STATIC VOID DeleteLsap(IRLMP_LSAP_CB *pLsapCb);
STATIC VOID TearDownConnections(PIRLMP_LINK_CB, IRLMP_DISC_REASON);
STATIC VOID IrlmpMoreCreditReq(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID IrlmpDiscoveryReq(IRDA_MSG *pMsg);
STATIC UINT IrlmpConnectReq(IRDA_MSG *);
STATIC UINT IrlmpConnectResp(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC UINT IrlmpDisconnectReq(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID IrlmpCloseLsapReq(IRLMP_LSAP_CB *);
STATIC UINT IrlmpDataReqExclusive(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC UINT IrlmpDataReqMultiplexed(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID FormatAndSendDataReq(IRLMP_LSAP_CB *, IRDA_MSG *, BOOLEAN, BOOLEAN);
STATIC UINT IrlmpAccessModeReq(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC void SetupTtp(IRLMP_LSAP_CB *);
STATIC VOID SendCntlPdu(IRLMP_LSAP_CB *, int, int, int, int);
STATIC VOID LsapResponseTimerExp(PVOID);
STATIC VOID IrlapDiscoveryConf(PIRLMP_LINK_CB, IRDA_MSG *);
STATIC void UpdateDeviceList(PIRLMP_LINK_CB, LIST_ENTRY *);
STATIC VOID IrlapConnectInd(PIRLMP_LINK_CB, IRDA_MSG *pMsg);
STATIC VOID IrlapConnectConf(PIRLMP_LINK_CB, IRDA_MSG *pMsg);
STATIC VOID IrlapDisconnectInd(PIRLMP_LINK_CB, IRDA_MSG *pMsg);
STATIC IRLMP_LSAP_CB *GetLsapInState(PIRLMP_LINK_CB, int, int, BOOLEAN);
STATIC IRLMP_LINK_CB *GetIrlmpCb(PUCHAR);
STATIC VOID DiscDelayTimerFunc(PVOID);
STATIC VOID IrlapDataConf(IRDA_MSG *pMsg);
STATIC VOID IrlapDataInd(PIRLMP_LINK_CB, IRDA_MSG *pMsg);
STATIC VOID LmPduConnectReq(PIRLMP_LINK_CB, IRDA_MSG *, int, int, UCHAR *);
STATIC VOID LmPduConnectConf(PIRLMP_LINK_CB, IRDA_MSG *, int, int, UCHAR *);
STATIC VOID LmPduDisconnectReq(PIRLMP_LINK_CB, IRDA_MSG *, int, int, UCHAR *);
STATIC VOID SendCreditPdu(IRLMP_LSAP_CB *);
STATIC VOID LmPduData(PIRLMP_LINK_CB, IRDA_MSG *, int, int);
STATIC VOID SetupTtpAndStoreConnData(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID LmPduAccessModeReq(PIRLMP_LINK_CB, int, int, UCHAR *, UCHAR *);
STATIC VOID LmPduAccessModeConf(PIRLMP_LINK_CB, int, int, UCHAR *, UCHAR *);
STATIC IRLMP_LSAP_CB *GetLsap(PIRLMP_LINK_CB, int, int);
STATIC VOID UnroutableSendLMDisc(PIRLMP_LINK_CB, int, int);
STATIC VOID ScheduleConnectReq(PIRLMP_LINK_CB);
STATIC void InitiateCloseLink(PVOID Context);
STATIC void InitiateConnectReq(PVOID Context);
STATIC void InitiateDiscoveryReq(PVOID Context);
STATIC void InitiateConnectResp(PVOID Context);
STATIC void InitiateLMConnectReq(PVOID Context);
STATIC void InitiateRetryIasQuery(PVOID Context);
STATIC UINT IrlmpGetValueByClassReq(IRDA_MSG *);
STATIC IAS_OBJECT *IasGetObject(CHAR *pClassName);
STATIC IasGetValueByClass(CONST CHAR *, int, CONST CHAR *, int, void **,
                           int *, UCHAR *);
STATIC VOID IasConnectReq(PIRLMP_LINK_CB, int);
STATIC VOID IasServerDisconnectReq(IRLMP_LSAP_CB *pLsapCb);
STATIC VOID IasClientDisconnectReq(IRLMP_LSAP_CB *pLsapCb, IRLMP_DISC_REASON);
STATIC VOID IasSendQueryResp(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID IasProcessQueryResp(PIRLMP_LINK_CB, IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID SendGetValueByClassReq(IRLMP_LSAP_CB *);
STATIC VOID SendGetValueByClassResp(IRLMP_LSAP_CB *, IRDA_MSG *);
STATIC VOID RegisterLsapProtocol(int Lsap, BOOLEAN UseTTP);
STATIC UINT IasAddAttribute(IAS_SET *pIASSet, PVOID *pAttribHandle);
STATIC VOID IasDelAttribute(PVOID AttribHandle);
STATIC VOID FlushDiscoveryCache();

#if DBG
TCHAR *LSAPStateStr[] =
{
    TEXT("LSAP_CREATED"),
    TEXT("LSAP_DISCONNECTED"),
    TEXT("LSAP_IRLAP_CONN_PEND"),
    TEXT("LSAP_LMCONN_CONF_PEND"),
    TEXT("LSAP_CONN_RESP_PEND"),
    TEXT("LSAP_CONN_REQ_PEND"),
    TEXT("LSAP_EXCLUSIVEMODE_PEND"),
    TEXT("LSAP_MULTIPLEXEDMODE_PEND"),
    TEXT("LSAP_READY"),
    TEXT("LSAP_NO_TX_CREDIT")
};

TCHAR *LinkStateStr[] =
{
    TEXT("LINK_DOWN"),
    TEXT("LINK_DISCONNECTED"),
    TEXT("LINK_DISCONNECTING"),
    TEXT("LINK_IN_DISCOVERY"),
    TEXT("LINK_CONNECTING"),
    TEXT("LINK_READY")
};
#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, IrlmpInitialize)

#pragma alloc_text(PAGEIRDA, DeleteLsap)
#pragma alloc_text(PAGEIRDA, TearDownConnections)
#pragma alloc_text(PAGEIRDA, IrlmpAccessModeReq)
#pragma alloc_text(PAGEIRDA, SetupTtp)
#pragma alloc_text(PAGEIRDA, LsapResponseTimerExp)
#pragma alloc_text(PAGEIRDA, IrlapConnectInd)
#pragma alloc_text(PAGEIRDA, IrlapConnectConf)
#pragma alloc_text(PAGEIRDA, IrlapDisconnectInd)
#pragma alloc_text(PAGEIRDA, GetLsapInState)
#pragma alloc_text(PAGEIRDA, DiscDelayTimerFunc)
#pragma alloc_text(PAGEIRDA, LmPduConnectReq)
#pragma alloc_text(PAGEIRDA, LmPduConnectConf)
#pragma alloc_text(PAGEIRDA, SetupTtpAndStoreConnData)
#pragma alloc_text(PAGEIRDA, LmPduAccessModeReq)
#pragma alloc_text(PAGEIRDA, LmPduAccessModeConf)
#pragma alloc_text(PAGEIRDA, UnroutableSendLMDisc)
#pragma alloc_text(PAGEIRDA, ScheduleConnectReq)
#pragma alloc_text(PAGEIRDA, InitiateCloseLink)
#pragma alloc_text(PAGEIRDA, InitiateConnectReq)
#pragma alloc_text(PAGEIRDA, InitiateConnectResp)
#pragma alloc_text(PAGEIRDA, InitiateLMConnectReq)
#pragma alloc_text(PAGEIRDA, IrlmpGetValueByClassReq)
#pragma alloc_text(PAGEIRDA, IasGetValueByClass)
#pragma alloc_text(PAGEIRDA, IasConnectReq)
#pragma alloc_text(PAGEIRDA, IasServerDisconnectReq)
#pragma alloc_text(PAGEIRDA, IasClientDisconnectReq)
#pragma alloc_text(PAGEIRDA, IasSendQueryResp)
#pragma alloc_text(PAGEIRDA, IasProcessQueryResp)
#pragma alloc_text(PAGEIRDA, SendGetValueByClassReq)
#pragma alloc_text(PAGEIRDA, SendGetValueByClassResp)
#endif
/*****************************************************************************
*
*/
VOID
IrlmpInitialize()
{
    PAGED_CODE();
    
    InitializeListHead(&RegisteredLsaps);
    InitializeListHead(&IasObjects);
    InitializeListHead(&IrdaLinkCbList);
    InitializeListHead(&gDeviceList);

    KeInitializeSpinLock(&gSpinLock);
        
    DscvReqScheduled = FALSE;
    IrdaEventInitialize(&EvDiscoveryReq, InitiateDiscoveryReq);        
    IrdaEventInitialize(&EvConnectReq, InitiateConnectReq);
    IrdaEventInitialize(&EvConnectResp,InitiateConnectResp);
    IrdaEventInitialize(&EvLmConnectReq, InitiateLMConnectReq);
    IrdaEventInitialize(&EvIrlmpCloseLink, InitiateCloseLink);
    IrdaEventInitialize(&EvRetryIasQuery, InitiateRetryIasQuery);    
}    

/*****************************************************************************
*
*/
VOID
IrdaShutdown()
{
    PIRDA_LINK_CB   pIrdaLinkCb, pIrdaLinkCbNext;
    KIRQL           OldIrql;    
    LARGE_INTEGER   SleepMs;    
    NTSTATUS        Status;
    UINT            Seconds;

    SleepMs.QuadPart = -(10*1000*1000); // 1 second

    KeAcquireSpinLock(&gSpinLock, &OldIrql);
    
    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
         pIrdaLinkCb = pIrdaLinkCbNext)
    {
        pIrdaLinkCbNext = (PIRDA_LINK_CB) pIrdaLinkCb->Linkage.Flink;
        
        KeReleaseSpinLock(&gSpinLock, OldIrql);            
        
        IrlmpCloseLink(pIrdaLinkCb);
        
        KeAcquireSpinLock(&gSpinLock, &OldIrql);        
    }     

    
    KeReleaseSpinLock(&gSpinLock, OldIrql);    
    
    Seconds = 0;
    while (Seconds < 30)
    {
        if (IsListEmpty(&IrdaLinkCbList))
            break;

        KeDelayExecutionThread(KernelMode, FALSE, &SleepMs);
        
        Seconds++;
    }
     
#if DBG
    if (Seconds >= 30)
    {
        DbgPrint("Link left open at shutdown!\n");

        for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
             (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
            pIrdaLinkCb = pIrdaLinkCbNext)
        {
            DbgPrint("pIrdaLinkCb: %X\n", pIrdaLinkCb);
            DbgPrint("   pIrlmpCb: %X\n", pIrdaLinkCb->IrlmpContext);
            DbgPrint("   pIrlapCb: %X\n", pIrdaLinkCb->IrlapContext);
        }
        ASSERT(0);        
    }  
    else
    {
        DbgPrint("Irda shutdown complete\n");
    }       
#endif     
    
    KeDelayExecutionThread(KernelMode, FALSE, &SleepMs);    

    NdisDeregisterProtocol(&Status, NdisIrdaHandle);    
}
/*****************************************************************************
*
*/
VOID
IrlmpOpenLink(OUT PNTSTATUS       Status,
              IN  PIRDA_LINK_CB   pIrdaLinkCb,  
              IN  UCHAR           *pDeviceName,
              IN  int             DeviceNameLen,
              IN  UCHAR           CharSet)
{
    PIRLMP_LINK_CB   pIrlmpCb;
    ULONG           IASBuf[(sizeof(IAS_SET) + 128)/sizeof(ULONG)];
    IAS_SET         *pIASSet;
    
    *Status = STATUS_SUCCESS;

    if (IRDA_ALLOC_MEM(pIrlmpCb, sizeof(IRLMP_LINK_CB), MT_IRLMPCB) == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("Alloc failed\n")));
        *Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    pIrdaLinkCb->IrlmpContext = pIrlmpCb;
    
#if DBG
    pIrlmpCb->DiscDelayTimer.pName = "DiscDelay";
#endif
    IrdaTimerInitialize(&pIrlmpCb->DiscDelayTimer,
                        DiscDelayTimerFunc,
                        IRLMP_DISCONNECT_DELAY_TIMEOUT,
                        pIrlmpCb,
                        pIrdaLinkCb);
    
    InitializeListHead(&pIrlmpCb->LsapCbList);
    InitializeListHead(&pIrlmpCb->DeviceList);

    pIrlmpCb->pIrdaLinkCb       = pIrdaLinkCb;
    pIrlmpCb->ConnReqScheduled  = FALSE;
    pIrlmpCb->LinkState         = LINK_DISCONNECTED;
    pIrlmpCb->pExclLsapCb       = NULL; 
    pIrlmpCb->pIasQuery         = NULL;

    // ConnDevAddrSet is set to true if LINK_IN_DISCOVERY or
    // LINK_DISCONNECTING and an LSAP requests a connection. Subsequent
    // LSAP connection requests check to see if this flag is set. If so
    // the requested device address must match that contained in the
    // IRLMP control block (set by the first connect request)
    pIrlmpCb->ConnDevAddrSet = FALSE;

    // Add device info to IAS        
    pIASSet = (IAS_SET *) IASBuf;
    RtlCopyMemory(pIASSet->irdaClassName, IasClassName_Device, 
                  IasClassNameLen_Device+1);
    RtlCopyMemory(pIASSet->irdaAttribName, IasAttribName_DeviceName,
                  IasAttribNameLen_DeviceName+1);
    pIASSet->irdaAttribType = IAS_ATTRIB_VAL_STRING;
    RtlCopyMemory(pIASSet->irdaAttribute.irdaAttribUsrStr.UsrStr,
                      pDeviceName, 
                      DeviceNameLen + 1);
    pIASSet->irdaAttribute.irdaAttribUsrStr.CharSet = CharSet;
    pIASSet->irdaAttribute.irdaAttribUsrStr.Len = (u_char) DeviceNameLen;        
    IasAddAttribute(pIASSet, &pIrlmpCb->hAttribDeviceName);

    RtlCopyMemory(pIASSet->irdaClassName, IasClassName_Device, 
                  IasClassNameLen_Device+1);
    RtlCopyMemory(pIASSet->irdaAttribName, IasAttribName_IrLMPSupport, 
                  IasAttribNameLen_IrLMPSupport+1);
    pIASSet->irdaAttribType = IAS_ATTRIB_VAL_BINARY;
    RtlCopyMemory(pIASSet->irdaAttribute.irdaAttribOctetSeq.OctetSeq, 
               IAS_IrLMPSupport, sizeof(IAS_IrLMPSupport));
    pIASSet->irdaAttribute.irdaAttribOctetSeq.Len =  
            sizeof(IAS_IrLMPSupport);
            
    IasAddAttribute(pIASSet, &pIrlmpCb->hAttribIrlmpSupport);

    if (*Status != STATUS_SUCCESS)
    {
        IRDA_FREE_MEM(pIrlmpCb);
    }
    else
    {
        ExInterlockedInsertTailList(&IrdaLinkCbList,
                                    &pIrdaLinkCb->Linkage,
                                    &gSpinLock);
    }
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP initialized, status %x\n"), *Status));
    
    return;
}

/*****************************************************************************
*
*
*
*/
VOID
IrlmpDeleteInstance(PVOID Context)
{
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) Context;
    PIRLMP_LINK_CB  pIrlmpCb2;
    PIRDA_LINK_CB   pIrdaLinkCb;    
    KIRQL           OldIrql;
    BOOLEAN         RescheduleDiscovery = FALSE;

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Delete instance %X\n"), Context));
        
    KeAcquireSpinLock(&gSpinLock, &OldIrql);
    
    FlushDiscoveryCache();
        
    // We may have been in the middle of discovery when
    // this link went down. Reschedule the discovery inorder
    // to complete the discovery request.
        
    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
         pIrdaLinkCb = (PIRDA_LINK_CB) pIrdaLinkCb->Linkage.Flink)    
    {
        pIrlmpCb2 = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;

        if (pIrlmpCb2->DiscoveryFlags)
        {
            RescheduleDiscovery = TRUE;
            break;
        }
    }
    
    // remove IrdaLinkCb from List
    
    RemoveEntryList(&pIrlmpCb->pIrdaLinkCb->Linkage);

    if (IsListEmpty(&IrdaLinkCbList))
    {
        RescheduleDiscovery = TRUE;    
    }    
    
    ASSERT(IsListEmpty(&pIrlmpCb->LsapCbList));
        
    KeReleaseSpinLock(&gSpinLock, OldIrql);        

    IasDelAttribute(pIrlmpCb->hAttribDeviceName);
    IasDelAttribute(pIrlmpCb->hAttribIrlmpSupport);    
    
    IRDA_FREE_MEM(pIrlmpCb);
    
    if (RescheduleDiscovery)
    {
        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Reschedule discovery, link gone\n")));    
        IrdaEventSchedule(&EvDiscoveryReq, NULL);        
    }    
    
/*        
    // Cleanup registered LSAP
    while (!IsListEmpty(&RegisteredLsaps))
    {
        pPtr = RemoveHeadList(&RegisteredLsaps);
        IRDA_FREE_MEM(pPtr);
    }
    // And the device list
    while (!IsListEmpty(&DeviceList))
    {
        pPtr = RemoveHeadList(&DeviceList);
        IRDA_FREE_MEM(pPtr);
    }    

    // And IAS entries
    for (pObject = (IAS_OBJECT *) IasObjects.Flink;
         (LIST_ENTRY *) pObject != &IasObjects;
         pObject = pNextObject)    
    {
        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Deleting object %s\n"),
                              pObject->pClassName));
        
        // Get the next cuz this ones being deleted
        pNextObject = (IAS_OBJECT *) pObject->Linkage.Flink;

        IasDeleteObject(pObject->pClassName);
    }
 */   
}

/*****************************************************************************
*
*   @func   UINT | IrlmpCloseLink | Shuts down IRDA stack
*
*   @rdesc  SUCCESS or error
*
*/
VOID
IrlmpCloseLink(PIRDA_LINK_CB pIrdaLinkCb)
{
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
    
    DEBUGMSG(1, (TEXT("IRLMP: CloseLink request\n")));

    if (pIrlmpCb->LinkState == LINK_DOWN)
    {
        DEBUGMSG(1, (TEXT("IRLMP: Link already down, ignoring\n")));    
        return;
    }    
    
    if (pIrlmpCb->LinkState == LINK_IN_DISCOVERY)
    {
        // Discovery was interrupted so schedule the next link
        IrdaEventSchedule(&EvDiscoveryReq, NULL);
    }
    
    pIrlmpCb->LinkState = LINK_DOWN;
    
    IrdaEventSchedule(&EvIrlmpCloseLink, pIrdaLinkCb);

    return;
}
/*****************************************************************************
*
*   @func   UINT | IrlmpRegisterLSAPProtocol | Bag to let IRLMP know if
*                                               a connect ind is using TTP
*   @rdesc  SUCCESS or error
*
*   @parm   int | LSAP | LSAP being registered
*   @parm   BOOLEAN | UseTtp | 
*/
VOID
RegisterLsapProtocol(int Lsap, BOOLEAN UseTtp)
{
    PIRLMP_REGISTERED_LSAP     pRegLsap;
    KIRQL                       OldIrql;        
    
    KeAcquireSpinLock(&gSpinLock, &OldIrql);
        
    for (pRegLsap = (PIRLMP_REGISTERED_LSAP) RegisteredLsaps.Flink;
         (LIST_ENTRY *) pRegLsap != &RegisteredLsaps;
         pRegLsap = (PIRLMP_REGISTERED_LSAP) pRegLsap->Linkage.Flink)
    {
        if (pRegLsap->Lsap == Lsap)
        {

            if (UseTtp) {

                pRegLsap->Flags |= LCBF_USE_TTP;

            } else {

                pRegLsap->Flags &= ~LCBF_USE_TTP;
            }

            goto done;
        }
    }

    if (IRDA_ALLOC_MEM(pRegLsap, sizeof(IRLMP_REGISTERED_LSAP), 
                       MT_IRLMP_REGLSAP) == NULL)
    {
        ASSERT(0);
        goto done;
    }
    pRegLsap->Lsap = Lsap;
    pRegLsap->Flags = UseTtp ? LCBF_USE_TTP : 0;    
    InsertTailList(&RegisteredLsaps, &pRegLsap->Linkage);    

done:    
    KeReleaseSpinLock(&gSpinLock, OldIrql);        

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: LSAP %x registered, %s\n"), Lsap,
                          UseTtp ? TEXT("use TTP") : TEXT("no TTP")));
}

VOID
DeregisterLsapProtocol(int Lsap)
{
    PIRLMP_REGISTERED_LSAP     pRegLsap;
    KIRQL                      OldIrql;        
    
    KeAcquireSpinLock(&gSpinLock, &OldIrql);
    
    for (pRegLsap = (PIRLMP_REGISTERED_LSAP) RegisteredLsaps.Flink;
         (LIST_ENTRY *) pRegLsap != &RegisteredLsaps;
         pRegLsap = (PIRLMP_REGISTERED_LSAP) pRegLsap->Linkage.Flink)
    {
        if (pRegLsap->Lsap == Lsap)
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: LSAP %x deregistered\n"),
                        Lsap));
                        
            RemoveEntryList(&pRegLsap->Linkage);                        
            
            IRDA_FREE_MEM(pRegLsap);
            break;
        }
    }
    
    KeReleaseSpinLock(&gSpinLock, OldIrql);            
}

/*****************************************************************************
*
*   @func   UINT | FreeLsap | Delete an Lsap control context and
*
*   @rdesc  pointer to Lsap context or 0 on error
*
*   @parm   void | pLsapCb | pointer to an Lsap control block
*/
void
FreeLsap(IRLMP_LSAP_CB *pLsapCb)
{
    VALIDLSAP(pLsapCb);
   
    ASSERT(pLsapCb->State == LSAP_DISCONNECTED);
     
    ASSERT(IsListEmpty(&pLsapCb->SegTxMsgList));
    
    ASSERT(IsListEmpty(&pLsapCb->TxMsgList));
    
    LOCK_LINK(pLsapCb->pIrlmpCb->pIrdaLinkCb);
    
#ifdef DBG    
    pLsapCb->Sig = 0xdaeddead;
#endif
    
    RemoveEntryList(&pLsapCb->Linkage);

    UNLOCK_LINK(pLsapCb->pIrlmpCb->pIrdaLinkCb);
    
    IrdaTimerStop(&pLsapCb->ResponseTimer);
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Deleting LsapCb:%X (%d,%d)\n"),
             pLsapCb, pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel));

    REFDEL(&pLsapCb->pIrlmpCb->pIrdaLinkCb->RefCnt, 'PASL');
    
    IRDA_FREE_MEM(pLsapCb);
}

/*****************************************************************************
*
*   @func   UINT | CreateLsap | Create an LSAP control context and
*/
UINT
CreateLsap(PIRLMP_LINK_CB pIrlmpCb, IRLMP_LSAP_CB **ppLsapCb)
{
    KIRQL           OldIrql;
    
    *ppLsapCb = NULL;

    IRDA_ALLOC_MEM(*ppLsapCb, sizeof(IRLMP_LSAP_CB), MT_IRLMP_LSAP_CB);

    if (*ppLsapCb == NULL)
    {
        return IRLMP_ALLOC_FAILED;
    }
    
    CTEMemSet(*ppLsapCb, 0, sizeof(IRLMP_LSAP_CB));

    (*ppLsapCb)->pIrlmpCb = pIrlmpCb;
    (*ppLsapCb)->State = LSAP_CREATED;
    (*ppLsapCb)->UserDataLen = 0;
    (*ppLsapCb)->DiscReason = IRLMP_NO_RESPONSE_LSAP;

    InitializeListHead(&(*ppLsapCb)->TxMsgList);
    InitializeListHead(&(*ppLsapCb)->SegTxMsgList);
    
    ReferenceInit(&(*ppLsapCb)->RefCnt, *ppLsapCb, FreeLsap);
    REFADD(&(*ppLsapCb)->RefCnt, ' TS1');

#if DBG
    (*ppLsapCb)->ResponseTimer.pName = "ResponseTimer";
    
    (*ppLsapCb)->Sig = LSAPSIG;
    
#endif
    IrdaTimerInitialize(&(*ppLsapCb)->ResponseTimer,
                        LsapResponseTimerExp,
                        LSAP_RESPONSE_TIMEOUT,
                        *ppLsapCb,
                        pIrlmpCb->pIrdaLinkCb);

    // Insert into list in the link control block
    KeAcquireSpinLock(&gSpinLock, &OldIrql);    
    
    InsertTailList(&pIrlmpCb->LsapCbList, &((*ppLsapCb)->Linkage));
    
    KeReleaseSpinLock(&gSpinLock, OldIrql);    
    
    REFADD(&pIrlmpCb->pIrdaLinkCb->RefCnt, 'PASL');

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: New LsapCb:%X\n"),
             *ppLsapCb));    

    return SUCCESS;
}

void
DeleteLsap(IRLMP_LSAP_CB *pLsapCb)
{
    IRDA_MSG IMsg, *pMsg, *pNextMsg, *pSegParentMsg;
    
    PAGED_CODE();
    
    VALIDLSAP(pLsapCb);
    
    if (pLsapCb->RemoteLsapSel == IAS_LSAP_SEL)
    {
        pLsapCb->State = LSAP_CREATED;
        return;
    }
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: DeleteLsap:%X\n"), pLsapCb));
    
    if (pLsapCb->State == LSAP_DISCONNECTED)
    {
        ASSERT(0);
        return;
    }    
    
    if (pLsapCb == pLsapCb->pIrlmpCb->pExclLsapCb)
    {
        pLsapCb->pIrlmpCb->pExclLsapCb = NULL;
    }
    
    pLsapCb->State = LSAP_DISCONNECTED;
    
    // Clean up the segmented tx msg list
    while (!IsListEmpty(&pLsapCb->SegTxMsgList))
    {
        pMsg = (IRDA_MSG *) RemoveHeadList(&pLsapCb->SegTxMsgList);
        
        // Decrement the segment counter contained in the parent data request
        pSegParentMsg = pMsg->DataContext;
        pSegParentMsg->IRDA_MSG_SegCount -= 1;
        // IRLMP owns these
        FreeIrdaBuf(IrdaMsgPool, pMsg);
    }

    // return any outstanding data requests (unless there are outstanding segments)
    for (pMsg = (IRDA_MSG *) pLsapCb->TxMsgList.Flink;
         (LIST_ENTRY *) pMsg != &(pLsapCb->TxMsgList);
         pMsg = pNextMsg)
    {
        pNextMsg = (IRDA_MSG *) pMsg->Linkage.Flink;

        if (pMsg->IRDA_MSG_SegCount == 0)
        {
            RemoveEntryList(&pMsg->Linkage);            
            
            if (pLsapCb->TdiContext)
            {
                pMsg->Prim = IRLMP_DATA_CONF;
                pMsg->IRDA_MSG_DataStatus = IRLMP_DATA_REQUEST_FAILED;
                TdiUp(pLsapCb->TdiContext, pMsg);
            }
            else
            {
                CTEAssert(0);
            }        
        }
    }
    
    if (pLsapCb->TdiContext && (pLsapCb->Flags & LCBF_TDI_OPEN))
    {
        IMsg.Prim = IRLMP_DISCONNECT_IND;
        IMsg.IRDA_MSG_DiscReason = pLsapCb->DiscReason;
        IMsg.IRDA_MSG_pDiscData = NULL;
        IMsg.IRDA_MSG_DiscDataLen = 0;

        TdiUp(pLsapCb->TdiContext, &IMsg);
    }    
    
    pLsapCb->LocalLsapSel = -1;
    pLsapCb->RemoteLsapSel = -1;
    
    REFDEL(&pLsapCb->RefCnt, ' TS1');
}

/*****************************************************************************
*
*   @func   void | TearDownConnections | Tears down and cleans up connections
*
*   @parm   IRLMP_DISC_REASONE| DiscReason | The reason connections are being
*                                            torn down. Passed to IRLMP clients
*                                            in IRLMP_DISCONNECT_IND
*/
void
TearDownConnections(PIRLMP_LINK_CB pIrlmpCb, IRLMP_DISC_REASON DiscReason)
{
    IRLMP_LSAP_CB       *pLsapCb, *pLsapCbNext;
    
    PAGED_CODE();
    
    pIrlmpCb->pExclLsapCb = NULL; 
   
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Tearing down connections\r\n")));
    
    // Clean up each LSAP  
    for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
         (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
         pLsapCb = pLsapCbNext)
    {
        pLsapCbNext = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink;
        
        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Teardown LsapCb:%X\n"), pLsapCb));
        
        VALIDLSAP(pLsapCb);

        if (pLsapCb->LocalLsapSel == IAS_LSAP_SEL)
        {
            IasServerDisconnectReq(pLsapCb);
            continue;
        }
        
        if (pLsapCb->LocalLsapSel == IAS_LOCAL_LSAP_SEL && 
            pLsapCb->RemoteLsapSel == IAS_LSAP_SEL)
        {
            IasClientDisconnectReq(pLsapCb, DiscReason);
        }
        else
        {
            IrdaTimerStop(&pLsapCb->ResponseTimer);

            if (pLsapCb->State != LSAP_DISCONNECTED)
            {
                DEBUGMSG(DBG_IRLMP, 
                         (TEXT("IRLMP: Sending IRLMP Disconnect Ind\r\n")));
                         
                pLsapCb->DiscReason = DiscReason;
                                         
                DeleteLsap(pLsapCb);                                         
            }
        }
    }
}

/*****************************************************************************
*
*   @func   UINT | IrlmpDown | Message from Upper layer to LMP
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   void * | void_pLsapCb | void pointer to an LSAP_CB. Can be NULL
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpDown(void *void_pLsapCb, IRDA_MSG *pMsg)
{
    UINT            rc = SUCCESS;
    PIRDA_LINK_CB   pIrdaLinkCb = NULL;

    IRLMP_LSAP_CB *pLsapCb =
            (IRLMP_LSAP_CB *) void_pLsapCb;
    
    if (pLsapCb)
    {
        VALIDLSAP(pLsapCb);

        pIrdaLinkCb = pLsapCb->pIrlmpCb->pIrdaLinkCb;

        // This could be the last lsap closing so
        // add a reference to the IrdaLinkCb so
        // it won't go away before we have a chance
        // to call UNLOCK_LINK
         
        REFADD(&pIrdaLinkCb->RefCnt, 'NWDI');
        
        LOCK_LINK(pIrdaLinkCb);
    }
    
    switch (pMsg->Prim)
    {
      case IRLMP_DISCOVERY_REQ:
        IrlmpDiscoveryReq(pMsg);
        break;

      case IRLMP_CONNECT_REQ:
        rc = IrlmpConnectReq(pMsg);
        break;

      case IRLMP_CONNECT_RESP:
        if (!pLsapCb) 
        {
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }
        rc = IrlmpConnectResp(pLsapCb, pMsg);
        break;

      case IRLMP_DISCONNECT_REQ:
        if (!pLsapCb) 
        {
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }      
        rc = IrlmpDisconnectReq(pLsapCb, pMsg);
        break;
        
      case IRLMP_CLOSELSAP_REQ:
        if (!pLsapCb) 
        {
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }      
        IrlmpCloseLsapReq(pLsapCb);
        break;        

      case IRLMP_DATA_REQ:
        if (!pLsapCb)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: error IRLMP_DATA_REQ on null LsapCb\n")));
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }    
        if (pLsapCb->pIrlmpCb->pExclLsapCb != NULL)
        {
            rc = IrlmpDataReqExclusive(pLsapCb, pMsg);
        }
        else
        {
            rc = IrlmpDataReqMultiplexed(pLsapCb, pMsg);
        }
        break;

      case IRLMP_ACCESSMODE_REQ:
        if (!pLsapCb) 
        {
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }      
        rc = IrlmpAccessModeReq(pLsapCb, pMsg);
        break;
        
      case IRLMP_MORECREDIT_REQ:
        if (!pLsapCb)
        {
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }    
        IrlmpMoreCreditReq(pLsapCb, pMsg);
        break;

      case IRLMP_GETVALUEBYCLASS_REQ:
        rc = IrlmpGetValueByClassReq(pMsg);
        break;

      case IRLMP_REGISTERLSAP_REQ:
        RegisterLsapProtocol(pMsg->IRDA_MSG_LocalLsapSel,
                             pMsg->IRDA_MSG_UseTtp);
        break;

      case IRLMP_DEREGISTERLSAP_REQ:
        DeregisterLsapProtocol(pMsg->IRDA_MSG_LocalLsapSel);
        break;

      case IRLMP_ADDATTRIBUTE_REQ:
        rc = IasAddAttribute(pMsg->IRDA_MSG_pIasSet, pMsg->IRDA_MSG_pAttribHandle);
        break;

      case IRLMP_DELATTRIBUTE_REQ:
        IasDelAttribute(pMsg->IRDA_MSG_AttribHandle);
        break;
        
      case IRLMP_FLUSHDSCV_REQ:
      {
          KIRQL         OldIrql;

          KeAcquireSpinLock(&gSpinLock, &OldIrql);

          FlushDiscoveryCache();
          
          KeReleaseSpinLock(&gSpinLock, OldIrql);

          break;
      }
        
      case IRLAP_STATUS_REQ:
        if (!pLsapCb) 
        {
            rc = IRLMP_INVALID_LSAP_CB;
            break;
        }      
          IrlapDown(pLsapCb->pIrlmpCb->pIrdaLinkCb->IrlapContext, pMsg);
          break;

      default:
        ASSERT(0);
    }

    if (pIrdaLinkCb)
    {
        UNLOCK_LINK(pIrdaLinkCb);
        
        REFDEL(&pIrdaLinkCb->RefCnt, 'NWDI');        
    }
    
    return rc;
}

VOID
IrlmpMoreCreditReq(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    int CurrentAvail = pLsapCb->AvailableCredit;

    pLsapCb->AvailableCredit += pMsg->IRDA_MSG_TtpCredits;
    
    if (pLsapCb->Flags & LCBF_USE_TTP)
    {
        if (CurrentAvail == 0)
        {
            // remote peer completely out of credit, send'm some
            SendCreditPdu(pLsapCb);
        }
    }
    else
    {
        if (pLsapCb == pLsapCb->pIrlmpCb->pExclLsapCb)
        {
            pLsapCb->RemoteTxCredit += pMsg->IRDA_MSG_TtpCredits;
            pMsg->Prim = IRLAP_FLOWON_REQ;
            IrlapDown(pLsapCb->pIrlmpCb->pIrdaLinkCb->IrlapContext, pMsg);
        }
    }
}

/*****************************************************************************
*
*   @func   UINT | IrlmpDiscoveryReq | initiates a discovery request
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
VOID
IrlmpDiscoveryReq(IRDA_MSG *pMsg)
{
    PIRDA_LINK_CB   pIrdaLinkCb;
    PIRLMP_LINK_CB  pIrlmpCb;
    KIRQL           OldIrql;
    
    DEBUGMSG(DBG_DISCOVERY, (TEXT("IRLMP: IRLMP_DISCOVERY_REQ\n")));

    KeAcquireSpinLock(&gSpinLock, &OldIrql);

    if (DscvReqScheduled)
    {
        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Discovery already schedule\n")));
        KeReleaseSpinLock(&gSpinLock, OldIrql);
    }
    else
    {
        // Flag each link for discovery
        for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
             (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
             pIrdaLinkCb = (PIRDA_LINK_CB) pIrdaLinkCb->Linkage.Flink)    
        {
            pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
            pIrlmpCb->DiscoveryFlags = DF_NORMAL_DSCV;

            if (pIrlmpCb->LinkState == LINK_DOWN &&
                !IsListEmpty(&pIrlmpCb->DeviceList))
            {
                FlushDiscoveryCache();

                DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Flush discovery cache, link down\n")));
                
            }
            
            DscvReqScheduled = TRUE;            
        }
        
        KeReleaseSpinLock(&gSpinLock, OldIrql);

        // Schedule the first link
    
        IrdaEventSchedule(&EvDiscoveryReq, NULL);
    }
}
/*****************************************************************************
*
*   @func   UINT | IrlmpConnectReq | Process IRLMP connect request
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpConnectReq(IRDA_MSG *pMsg)
{
    PIRLMP_LSAP_CB  pLsapCb = NULL;
    PIRLMP_LINK_CB  pIrlmpCb = GetIrlmpCb(pMsg->IRDA_MSG_RemoteDevAddr);
    UINT            rc = SUCCESS;

    if (pIrlmpCb == NULL)
        return IRLMP_BAD_DEV_ADDR;
        
    LOCK_LINK(pIrlmpCb->pIrdaLinkCb);        
    
    if (pIrlmpCb->pExclLsapCb != NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: IrlmpConnectReq failed, link in exclusive mode\n")));
        rc = IRLMP_IN_EXCLUSIVE_MODE;
    } 
    else if ((pLsapCb = GetLsap(pIrlmpCb, pMsg->IRDA_MSG_LocalLsapSel, 
                                pMsg->IRDA_MSG_RemoteLsapSel)) != NULL &&
              pLsapCb->RemoteLsapSel != IAS_LSAP_SEL)
    {        
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: IrlmpConnectReq failed, LsapSel in use\n")));
        rc = IRLMP_LSAP_SEL_IN_USE;
    } 
    else if ((UINT)pMsg->IRDA_MSG_ConnDataLen > IRLMP_MAX_USER_DATA_LEN)
    {
        rc = IRLMP_USER_DATA_LEN_EXCEEDED;
    }    
    else if (pLsapCb == NULL && CreateLsap(pIrlmpCb, &pLsapCb) != SUCCESS)
    {
        rc = 1;
    }    
    
    if (rc != SUCCESS)
    {
        goto exit;
    }    


    // Initialize the LSAP endpoint
    pLsapCb->LocalLsapSel          = pMsg->IRDA_MSG_LocalLsapSel;
    pLsapCb->RemoteLsapSel         = pMsg->IRDA_MSG_RemoteLsapSel;
    pLsapCb->TdiContext            = pMsg->IRDA_MSG_pContext;
    pLsapCb->RxMaxSDUSize          = pMsg->IRDA_MSG_MaxSDUSize;
    pLsapCb->AvailableCredit       = pMsg->IRDA_MSG_TtpCredits;
    pLsapCb->UserDataLen           = pMsg->IRDA_MSG_ConnDataLen;  
    pLsapCb->Flags                |= pMsg->IRDA_MSG_UseTtp ? LCBF_USE_TTP : 0;
    
    RtlCopyMemory(pLsapCb->UserData, pMsg->IRDA_MSG_pConnData,
           pMsg->IRDA_MSG_ConnDataLen);
    
    // TDI can abort this connection before the confirm 
    // from peer is received. TDI will call into LMP to 
    // do this so we must return the Lsap context now.
    // This is the only time we actually return something 
    // in an Irda Message.
    pMsg->IRDA_MSG_pContext = pLsapCb;
    
    DEBUGMSG((DBG_IRLMP | DBG_IRLMP_CONN), 
            (TEXT("IRLMP: IRLMP_CONNECT_REQ (l=%d,r=%d), Tdi:%X LinkState=%s\r\n"),
            pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel, pLsapCb->TdiContext,
            pIrlmpCb->LinkState == LINK_DISCONNECTED ? TEXT("DISCONNECTED") :
            pIrlmpCb->LinkState == LINK_IN_DISCOVERY ? TEXT("IN_DISCOVERY") :
            pIrlmpCb->LinkState == LINK_DISCONNECTING? TEXT("DISCONNECTING"):
            pIrlmpCb->LinkState == LINK_READY ? TEXT("READY") : TEXT("oh!")));

    switch (pIrlmpCb->LinkState)
    {
      case LINK_DISCONNECTED:
        RtlCopyMemory(pIrlmpCb->ConnDevAddr, pMsg->IRDA_MSG_RemoteDevAddr,
               IRDA_DEV_ADDR_LEN);

        pLsapCb->State = LSAP_IRLAP_CONN_PEND;
        SetupTtp(pLsapCb);

        pMsg->Prim = IRLAP_CONNECT_REQ;
        rc = IrlapDown(pIrlmpCb->pIrdaLinkCb->IrlapContext, pMsg);
        if (rc == SUCCESS)
        {
            pIrlmpCb->LinkState = LINK_CONNECTING;
        }

        break;

      case LINK_IN_DISCOVERY:
      case LINK_DISCONNECTING:
        if (pIrlmpCb->ConnDevAddrSet == FALSE)
        {
            // Ensure that only the first device to request a connection
            // sets the device address of the remote to be connected to.
            RtlCopyMemory(pIrlmpCb->ConnDevAddr, pMsg->IRDA_MSG_RemoteDevAddr,
                    IRDA_DEV_ADDR_LEN);
            pIrlmpCb->ConnDevAddrSet = TRUE;
        }
        else
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Link in use!\r\n")));
            
            if (CTEMemCmp(pMsg->IRDA_MSG_RemoteDevAddr,
                          pIrlmpCb->ConnDevAddr,
                          IRDA_DEV_ADDR_LEN) != 0)
            {
                // This LSAP is requesting a connection to another device
                DeleteLsap(pLsapCb);
                rc = IRLMP_LINK_IN_USE;
                break;
            }
        }

        pLsapCb->State = LSAP_CONN_REQ_PEND;
        SetupTtp(pLsapCb);

        // This request will complete when discovery/disconnect ends
        break;

      case LINK_CONNECTING:
        if (CTEMemCmp(pMsg->IRDA_MSG_RemoteDevAddr,
                      pIrlmpCb->ConnDevAddr,
                      IRDA_DEV_ADDR_LEN) != 0)
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Link in use!\r\n")));
            // This LSAP is requesting a connection to another device,
            // not the one IRLAP is currently connected to
            DeleteLsap(pLsapCb);
            rc = IRLMP_LINK_IN_USE;
            break;
        }

        // The LSAP will be notified when the IRLAP connection that is
        // underway has completed (see IRLAP_ConnectConf)
        pLsapCb->State = LSAP_IRLAP_CONN_PEND; 

        SetupTtp(pLsapCb);

        break;

      case LINK_READY:
        if (CTEMemCmp(pMsg->IRDA_MSG_RemoteDevAddr,
                      pIrlmpCb->ConnDevAddr,
                      IRDA_DEV_ADDR_LEN) != 0)
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Link in use!\r\n")));
            // This LSAP is requesting a connection to another device
            DeleteLsap(pLsapCb);
            rc = IRLMP_LINK_IN_USE;
            break;
        }
        IrdaTimerRestart(&pLsapCb->ResponseTimer);

        pLsapCb->State = LSAP_LMCONN_CONF_PEND;
        SetupTtp(pLsapCb);

        // Ask remote LSAP for a connection
        SendCntlPdu(pLsapCb, IRLMP_CONNECT_PDU,
                    IRLMP_ABIT_REQUEST, IRLMP_RSVD_PARM, 0);
        break;
    }
    
exit:

    if (pLsapCb)
    {
        if (rc == SUCCESS)
        {
            if (pLsapCb->RemoteLsapSel != IAS_LSAP_SEL)
            {    
                pLsapCb->Flags |= LCBF_TDI_OPEN;
                REFADD(&pLsapCb->RefCnt, 'NEPO');
            }    
        }
        else if (pLsapCb->RemoteLsapSel == IAS_LSAP_SEL)
        {
            DeleteLsap(pLsapCb);
        }
    }    

    UNLOCK_LINK(pIrlmpCb->pIrdaLinkCb);    

    return rc;
}
/*****************************************************************************
*
*   @func   void | SetupTtp | if using TTP, calculate initial credits
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*/
void
SetupTtp(IRLMP_LSAP_CB *pLsapCb)
{
    PAGED_CODE();
    
    VALIDLSAP(pLsapCb);
    
    if (pLsapCb->AvailableCredit > 127)
    {
        pLsapCb->RemoteTxCredit = 127;
        pLsapCb->AvailableCredit -= 127;
    }
    else
    {
        pLsapCb->RemoteTxCredit = pLsapCb->AvailableCredit;
        pLsapCb->AvailableCredit = 0;
    }
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: RemoteTxCredit %d\n"),
                         pLsapCb->RemoteTxCredit));
}
/*****************************************************************************
*
*   @func   UINT | IrlmpConnectResp | Process IRLMP connect response
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpConnectResp(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: IRLMP_CONNECT_RESP l=%d r=%d\n"),
             pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel));
    
    if (pLsapCb->pIrlmpCb->LinkState != LINK_READY)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Bad link state\n")));
        ASSERT(0);
        return IRLMP_LINK_BAD_STATE;
    }

    if (pLsapCb->State != LSAP_CONN_RESP_PEND)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Bad LSAP state\n")));
        ASSERT(0);
        return IRLMP_LSAP_BAD_STATE;
    }

    IrdaTimerStop(&pLsapCb->ResponseTimer);

    if (pMsg->IRDA_MSG_ConnDataLen > IRLMP_MAX_USER_DATA_LEN)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: User data len exceeded\n")));
        return IRLMP_USER_DATA_LEN_EXCEEDED;
    }

    pLsapCb->RxMaxSDUSize       = pMsg->IRDA_MSG_MaxSDUSize;
    pLsapCb->UserDataLen        = pMsg->IRDA_MSG_ConnDataLen;
    pLsapCb->AvailableCredit    = pMsg->IRDA_MSG_TtpCredits;
    RtlCopyMemory(pLsapCb->UserData, pMsg->IRDA_MSG_pConnData,
           pMsg->IRDA_MSG_ConnDataLen);
    
    pLsapCb->TdiContext = pMsg->IRDA_MSG_pContext;
    
    CTEAssert(pLsapCb->TdiContext);    
    
    SetupTtp(pLsapCb);

    pLsapCb->State = LSAP_READY;
    
    pLsapCb->Flags |= LCBF_TDI_OPEN;        
        
    REFADD(&pLsapCb->RefCnt, 'NEPO');

    SendCntlPdu(pLsapCb, IRLMP_CONNECT_PDU, IRLMP_ABIT_CONFIRM,
                IRLMP_RSVD_PARM, 0);

    return SUCCESS;
}



VOID
IrlmpCloseLsapReq(IRLMP_LSAP_CB *pLsapCb)
{
    if (pLsapCb == NULL)
    {
        ASSERT(0);
        return;
    }    
    
    DEBUGMSG((DBG_IRLMP | DBG_IRLMP_CONN), 
            (TEXT("IRLMP: IRLMP_CLOSELSAP_REQ (l=%d,r=%d) Flags:%d State:%s\n"),
             pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel,
             pLsapCb->Flags, LSAPStateStr[pLsapCb->State]));
            
    pLsapCb->Flags &= ~LCBF_TDI_OPEN;             
    
    REFDEL(&pLsapCb->RefCnt, 'NEPO');    
}

/*****************************************************************************
*
*   @func   UINT | IrlmpDisconnectReq | Process IRLMP disconnect request
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpDisconnectReq(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    if (pLsapCb == NULL)
    {
        ASSERT(0);
        return 1;
    }    
    
    DEBUGMSG((DBG_IRLMP | DBG_IRLMP_CONN), 
            (TEXT("IRLMP: IRLMP_DISCONNECT_REQ (l=%d,r=%d) Flags:%d State:%s\n"),
             pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel,
             pLsapCb->Flags, LSAPStateStr[pLsapCb->State]));
            

    if (pLsapCb->State == LSAP_DISCONNECTED)
    {
        return SUCCESS;
    }

    if (pLsapCb->State == LSAP_LMCONN_CONF_PEND ||
        pLsapCb->State == LSAP_CONN_RESP_PEND)
    {
        IrdaTimerStop(&pLsapCb->ResponseTimer);
    }

    if (pLsapCb->State == LSAP_CONN_RESP_PEND || pLsapCb->State >= LSAP_READY)
    {
        // Either the LSAP is connected or the peer is waiting for a
        // response from our client

        if (pMsg->IRDA_MSG_DiscDataLen > IRLMP_MAX_USER_DATA_LEN)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: User data len exceeded\n")));
            return IRLMP_USER_DATA_LEN_EXCEEDED;
        }

        pLsapCb->UserDataLen = pMsg->IRDA_MSG_DiscDataLen;
        RtlCopyMemory(pLsapCb->UserData, pMsg->IRDA_MSG_pDiscData,
               pMsg->IRDA_MSG_DiscDataLen);

        // Notify peer of the disconnect request, reason: user request
        // Send on different thread in case TranportAPI calls this on rx thread
        SendCntlPdu(pLsapCb,IRLMP_DISCONNECT_PDU,IRLMP_ABIT_REQUEST,
                    pLsapCb->State == LSAP_CONN_RESP_PEND ? IRLMP_DISC_LSAP :
                    IRLMP_USER_REQUEST, 0);
    }

    IrdaTimerRestart(&pLsapCb->pIrlmpCb->DiscDelayTimer);
    
    DeleteLsap(pLsapCb);
    
    return SUCCESS;
}
/*****************************************************************************
*
*   @func   UINT | IrlmpDataReqExclusive | Process IRLMP data request
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpDataReqExclusive(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    NDIS_BUFFER         *pNBuf = (NDIS_BUFFER *) pMsg->DataContext;
    NDIS_BUFFER         *pNextNBuf;
    UCHAR                *pData;
    int                 DataLen;

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Exclusive mode data request\n")));

    if (pLsapCb->pIrlmpCb->LinkState != LINK_READY)
    {
        return IRLMP_LINK_BAD_STATE;
    }

    if (pLsapCb != pLsapCb->pIrlmpCb->pExclLsapCb)
    {
        return IRLMP_INVALID_LSAP_CB;
    }
    
    NdisQueryBuffer(pNBuf, &pData, &DataLen);

    NdisGetNextBuffer(pNBuf, &pNextNBuf);       

    ASSERT(pNextNBuf == NULL);

    pMsg->IRDA_MSG_SegCount = 0; // see DATA_CONF on how I'm using this
    pMsg->IRDA_MSG_SegFlags = SEG_FINAL;

    pMsg->IRDA_MSG_pRead = pData;
    pMsg->IRDA_MSG_pWrite = pData + DataLen;

    FormatAndSendDataReq(pLsapCb, pMsg, FALSE, FALSE);
    
    return SUCCESS;
}
/*****************************************************************************
*
*   @func   UINT | IrlmpDataReqMultiplexed | Process IRLMP data request
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpDataReqMultiplexed(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    NDIS_BUFFER         *pNBuf = (NDIS_BUFFER *) pMsg->DataContext;
    NDIS_BUFFER         *pNextNBuf;
    UCHAR                *pData;
    int                 DataLen;
    int                 SegLen;
    IRDA_MSG            *pSegMsg;

    if (pLsapCb->State < LSAP_READY)
    {
        return IRLMP_LSAP_BAD_STATE;
    }
    
    // Place this message on the LSAP's TxMsgList. The message remains
    // here until all segments for it are sent and confirmed
    InsertTailList(&pLsapCb->TxMsgList, &pMsg->Linkage);

    pMsg->IRDA_MSG_SegCount = 0;
    // If it fails, this will be changed
    pMsg->IRDA_MSG_DataStatus = IRLMP_DATA_REQUEST_COMPLETED;

    // Segment the message into PDUs. The segment will either be:
    //  1. Sent immediately to IRLAP if the link is not busy
    //  2. If link is busy, placed on TxMsgList contained in IRLMP_LCB
    //  3. If no credit, placed onto this LSAPS SegTxMsgList

    while (pNBuf != NULL)
    {
        NdisQueryBufferSafe(pNBuf, &pData, &DataLen, NormalPagePriority);
        
        if (pData == NULL)
        {
            break;
        }    
        
         // Get the next one now so I know when to set SegFlag to final
        NdisGetNextBuffer(pNBuf, &pNextNBuf);

        while (DataLen != 0)
        {
            if ((pSegMsg = AllocIrdaBuf(IrdaMsgPool))
                == NULL)
            {
                ASSERT(0);
                return IRLMP_ALLOC_FAILED;
            }
            pSegMsg->IRDA_MSG_pOwner = pLsapCb; // MUX routing
            pSegMsg->DataContext = pMsg; // Parent of segment
            pSegMsg->IRDA_MSG_IrCOMM_9Wire = pMsg->IRDA_MSG_IrCOMM_9Wire;

            // Increment segment count contained in original messages
            pMsg->IRDA_MSG_SegCount++;

            if (DataLen > pLsapCb->pIrlmpCb->MaxPDUSize)
            {
                SegLen = pLsapCb->pIrlmpCb->MaxPDUSize;
            }
            else
            {
                SegLen = DataLen;
            }
            
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Sending SegLen %d\n"),
                                  SegLen));
            
            pSegMsg->IRDA_MSG_pRead = pData;
            pSegMsg->IRDA_MSG_pWrite = pData + SegLen;

            // Indicate this message is part of a segmented message
            pSegMsg->IRDA_MSG_SegCount = pMsg->IRDA_MSG_SegCount;
            
            pData += SegLen;
            DataLen -= SegLen;
            
            if (DataLen == 0 && pNextNBuf == NULL)
            {
                pSegMsg->IRDA_MSG_SegFlags = SEG_FINAL;
            }
            else
            {
                pSegMsg->IRDA_MSG_SegFlags = 0;
            }

            if (pLsapCb->State == LSAP_NO_TX_CREDIT)
            {
                DEBUGMSG(DBG_IRLMP, 
                        (TEXT("IRLMP: Out of credit, placing on SegList\n")));
                InsertTailList(&pLsapCb->SegTxMsgList, &pSegMsg->Linkage);
            }
            else
            {
                FormatAndSendDataReq(pLsapCb, pSegMsg, FALSE, FALSE);
            }
        }
        pNBuf = pNextNBuf;
    }

    return SUCCESS;
}

VOID
FormatAndSendDataReq(IRLMP_LSAP_CB *pLsapCb, 
                     IRDA_MSG *pMsg,
                     BOOLEAN LocallyGenerated,
                     BOOLEAN Expedited)
{
    IRLMP_HEADER        *pLMHeader;
    TTP_DATA_HEADER     *pTTPHeader;
    int                 AdditionalCredit;
    UCHAR                *pLastHdrByte;
    
    VALIDLSAP(pLsapCb);

    // Initialize the header pointers to the end of the header block
    pMsg->IRDA_MSG_pHdrRead  =
    pMsg->IRDA_MSG_pHdrWrite = pMsg->IRDA_MSG_Header + IRDA_HEADER_LEN;

    // Back up the read pointer for the LMP header
    pMsg->IRDA_MSG_pHdrRead -= sizeof(IRLMP_HEADER);

    // Back up header read pointer for TTP
    if (pLsapCb->Flags & LCBF_USE_TTP)
    {
        pMsg->IRDA_MSG_pHdrRead -= (sizeof(TTP_DATA_HEADER));
    }

    // WHACK FOR IRCOMM YUK YUK !!
    if (pMsg->IRDA_MSG_IrCOMM_9Wire == TRUE)
    {
        pMsg->IRDA_MSG_pHdrRead -= 1;
    }

    ASSERT(pMsg->IRDA_MSG_pHdrRead >= pMsg->IRDA_MSG_Header);

    // Build the LMP Header
    pLMHeader = (IRLMP_HEADER *) pMsg->IRDA_MSG_pHdrRead;
    pLMHeader->DstLsapSel = (UCHAR) pLsapCb->RemoteLsapSel;
    pLMHeader->SrcLsapSel = (UCHAR) pLsapCb->LocalLsapSel;
    pLMHeader->CntlBit = IRLMP_DATA_PDU;
    pLMHeader->RsvrdBit = 0;

    pLastHdrByte = (UCHAR *) (pLMHeader + 1);
    
    // Build the TTP Header
    if (pLsapCb->Flags & LCBF_USE_TTP)
    {
        pTTPHeader = (TTP_DATA_HEADER *) (pLMHeader + 1);

        // Credit
        if (pLsapCb->AvailableCredit > 127)
        {
            AdditionalCredit = 127;
            pLsapCb->AvailableCredit -= 127;
        }
        else
        {
            AdditionalCredit = pLsapCb->AvailableCredit;
            pLsapCb->AvailableCredit = 0;
        }

        pTTPHeader->AdditionalCredit = (UCHAR) AdditionalCredit;
        pLsapCb->RemoteTxCredit += AdditionalCredit;

        if (pMsg->IRDA_MSG_pRead != pMsg->IRDA_MSG_pWrite)
        {
            // Only decrement my TxCredit if I'm sending data
            // (may be sending dataless PDU to extend credit to peer)
            pLsapCb->LocalTxCredit -= 1;
        
            if (pLsapCb->LocalTxCredit == 0)
            {
                DEBUGMSG(DBG_IRLMP, 
                         (TEXT("IRLMP: l%d,r%d No credit\n"), pLsapCb->LocalLsapSel,
                          pLsapCb->RemoteLsapSel));
                pLsapCb->State = LSAP_NO_TX_CREDIT;
            }
        }
        
        // SAR
        if (pMsg->IRDA_MSG_SegFlags & SEG_FINAL)
        {
            pTTPHeader->MoreBit = TTP_MBIT_FINAL;
        }
        else
        {
            pTTPHeader->MoreBit = TTP_MBIT_NOT_FINAL;
        }

        pLastHdrByte = (UCHAR *) (pTTPHeader + 1);
    }
    
    // WHACK FOR IRCOMM YUK YUK !!
    if (pMsg->IRDA_MSG_IrCOMM_9Wire == TRUE)
    {
        *pLastHdrByte = 0;
    }

    pMsg->Prim = IRLAP_DATA_REQ;

    pMsg->IRDA_MSG_Expedited = Expedited;

    if (LocallyGenerated)
    {
        pMsg->IRDA_MSG_SegFlags = SEG_LOCAL | SEG_FINAL;
        pMsg->IRDA_MSG_pOwner = 0;
    }
    else
    {
        pMsg->IRDA_MSG_pOwner = pLsapCb;    
        REFADD(&pLsapCb->RefCnt, 'ATAD');
    }    
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Sending Data request pMsg:%X LsapCb:%X\n"),
                        pMsg, pMsg->IRDA_MSG_pOwner));
                        
    if (IrlapDown(pLsapCb->pIrlmpCb->pIrdaLinkCb->IrlapContext, 
                  pMsg) != SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: IRLAP_DATA_REQ failed, faking CONF\n")));
        
        pMsg->IRDA_MSG_DataStatus = IRLAP_DATA_REQUEST_FAILED_LINK_RESET;
        IrlapDataConf(pMsg);
    }        
    
    DEBUGMSG(DBG_IRLMP_CRED,
             (TEXT("IRLMP(l%d,r%d): Tx LocTxCredit %d,RemoteTxCredit %d\n"),
              pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel,
              pLsapCb->LocalTxCredit, pLsapCb->RemoteTxCredit));
}
/*****************************************************************************
*
*   @func   UINT | IrlmpAccessModeReq | Processes the IRLMP_ACCESSMODE_REQ
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
UINT
IrlmpAccessModeReq(IRLMP_LSAP_CB *pRequestingLsapCb, IRDA_MSG *pMsg)
{
    IRLMP_LSAP_CB   *pLsapCb;
    PIRLMP_LINK_CB  pIrlmpCb = pRequestingLsapCb->pIrlmpCb;
    
    PAGED_CODE();
    
    if (pIrlmpCb->LinkState != LINK_READY)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Link bad state %x\n"), 
                              pIrlmpCb->LinkState));        
        return IRLMP_LINK_BAD_STATE;
    }
    if (pRequestingLsapCb->State != LSAP_READY)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: LSAP bad state %x\n"), 
                              pRequestingLsapCb->State));        
        return IRLMP_LSAP_BAD_STATE;
    }
    switch (pMsg->IRDA_MSG_AccessMode)
    {
      case IRLMP_EXCLUSIVE:
        if (pIrlmpCb->pExclLsapCb != NULL)
        {
            // Another LSAP has it already
            return IRLMP_IN_EXCLUSIVE_MODE;
        }
        for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
             (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
             pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
        {
            VALIDLSAP(pLsapCb);
            
            if (pLsapCb->State != LSAP_DISCONNECTED && 
                pLsapCb != pRequestingLsapCb)
            {
                return IRLMP_IN_MULTIPLEXED_MODE;
            }
        }
        
        // OK to request exclusive mode from peer
        pIrlmpCb->pExclLsapCb = pRequestingLsapCb;  
        
        if (pMsg->IRDA_MSG_IrLPTMode == TRUE)
        {
            pMsg->Prim = IRLMP_ACCESSMODE_CONF;
            pMsg->IRDA_MSG_AccessMode = IRLMP_EXCLUSIVE;
            pMsg->IRDA_MSG_ModeStatus = IRLMP_ACCESSMODE_SUCCESS;
            
            TdiUp(pRequestingLsapCb->TdiContext, pMsg);
            return SUCCESS;
        }
        else
        {
            pRequestingLsapCb->State = LSAP_EXCLUSIVEMODE_PEND;

            SendCntlPdu(pRequestingLsapCb, IRLMP_ACCESSMODE_PDU,
                        IRLMP_ABIT_REQUEST, IRLMP_RSVD_PARM,
                        IRLMP_EXCLUSIVE);

            IrdaTimerRestart(&pRequestingLsapCb->ResponseTimer);

        }        
        break;
        
      case IRLMP_MULTIPLEXED:
        if (pIrlmpCb->pExclLsapCb == NULL)
        {
            return IRLMP_IN_MULTIPLEXED_MODE;
        }
        if (pIrlmpCb->pExclLsapCb != pRequestingLsapCb)
        {
            return IRLMP_NOT_LSAP_IN_EXCLUSIVE_MODE;
        }

        if (pMsg->IRDA_MSG_IrLPTMode == TRUE)
        {
            pIrlmpCb->pExclLsapCb = NULL;
            pMsg->Prim = IRLMP_ACCESSMODE_CONF;
            pMsg->IRDA_MSG_AccessMode = IRLMP_MULTIPLEXED;
            pMsg->IRDA_MSG_ModeStatus = IRLMP_ACCESSMODE_SUCCESS;
            return TdiUp(pRequestingLsapCb->TdiContext,
                                   pMsg);
        }
        else
        {
            pRequestingLsapCb->State = LSAP_MULTIPLEXEDMODE_PEND;
        
            SendCntlPdu(pRequestingLsapCb, IRLMP_ACCESSMODE_PDU,
                        IRLMP_ABIT_REQUEST, IRLMP_RSVD_PARM,
                        IRLMP_MULTIPLEXED);     

            IrdaTimerRestart(&pRequestingLsapCb->ResponseTimer);            
        }
        break;
      default:
        return IRLMP_BAD_ACCESSMODE;
    }
    return SUCCESS;
}
/*****************************************************************************
*
*   @func   UINT | SendCntlPdu | Sends connect request to IRLAP
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer LSAP control block
*/
VOID
SendCntlPdu(IRLMP_LSAP_CB *pLsapCb, int OpCode, int ABit,
            int Parm1, int Parm2)
{
    IRDA_MSG            *pMsg = AllocIrdaBuf(IrdaMsgPool);
    IRLMP_HEADER        *pLMHeader;
    IRLMP_CNTL_FORMAT   *pCntlFormat;
    TTP_CONN_HEADER     *pTTPHeader;
    TTP_CONN_PARM       *pTTPParm;
    UINT                rc = SUCCESS;
    
    VALIDLSAP(pLsapCb);
    
    if (pMsg == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Alloc failed\n")));
        ASSERT(0);
        return;// IRLMP_ALLOC_FAILED;
    }

    pMsg->IRDA_MSG_SegFlags = SEG_LOCAL | SEG_FINAL;    

    // Initialize the header pointers to the end of the header block
    pMsg->IRDA_MSG_pHdrRead =
    pMsg->IRDA_MSG_pHdrWrite = pMsg->IRDA_MSG_Header + IRDA_HEADER_LEN;

    // Back up the read pointer for the LMP header
    pMsg->IRDA_MSG_pHdrRead -= (sizeof(IRLMP_HEADER) + \
                             sizeof(IRLMP_CNTL_FORMAT));
    
    // move it forward for non access mode control requests
    // (connect and disconnect don't have a Parm2)
    if (OpCode != IRLMP_ACCESSMODE_PDU)
    {
        pMsg->IRDA_MSG_pHdrRead++;
    }

    // If using Tiny TPP back up the read pointer for its header
    // From LMPs point of view this is where the user data begins.
    // We are sticking it in the header because TTP is now part of IRLMP.

    // TTP connect PDU's are only used for connection establishment
    if ((pLsapCb->Flags & LCBF_USE_TTP) && OpCode == IRLMP_CONNECT_PDU)
    {
        pMsg->IRDA_MSG_pHdrRead -= sizeof(TTP_CONN_HEADER);

        if (pLsapCb->RxMaxSDUSize > 0)
        {
            pMsg->IRDA_MSG_pHdrRead -= sizeof(TTP_CONN_PARM);
        }
    }

    // Build the IRLMP header
    pLMHeader = (IRLMP_HEADER *) pMsg->IRDA_MSG_pHdrRead;
    pLMHeader->DstLsapSel = (UCHAR) pLsapCb->RemoteLsapSel;
    pLMHeader->SrcLsapSel = (UCHAR) pLsapCb->LocalLsapSel;
    pLMHeader->CntlBit = IRLMP_CNTL_PDU;
    pLMHeader->RsvrdBit = 0;
    // Control portion of header
    pCntlFormat = (IRLMP_CNTL_FORMAT *) (pLMHeader + 1);
    pCntlFormat->OpCode = (UCHAR) OpCode; 
    pCntlFormat->ABit = (UCHAR) ABit;
    pCntlFormat->Parm1 = (UCHAR) Parm1;
    if (OpCode == IRLMP_ACCESSMODE_PDU)
    {
        pCntlFormat->Parm2 = (UCHAR) Parm2; // Access mode
    }
    
    // Build the TTP header if needed (we are using TTP and this is a
    // connection request or confirmation not).
    if ((pLsapCb->Flags & LCBF_USE_TTP) && OpCode == IRLMP_CONNECT_PDU)
    {
        // Always using the MaxSDUSize parameter. If the client wishes
        // to disable, MaxSDUSize = 0

        pTTPHeader = (TTP_CONN_HEADER *) (pCntlFormat + 1) - 1;
        // -1, LM-Connect-PDU doesn't use parm2

        /*
           #define TTP_PFLAG_NO_PARMS      0
           #define TTP_PFLAG_PARMS         1
        */

        pTTPHeader->ParmFlag = (pLsapCb->RxMaxSDUSize > 0);
        
        pTTPHeader->InitialCredit = (UCHAR) pLsapCb->RemoteTxCredit;
        
        pTTPParm = (TTP_CONN_PARM *) (pTTPHeader + 1);

        if (pLsapCb->RxMaxSDUSize > 0)
        {
            // HARDCODE-O-RAMA
            pTTPParm->PLen = 6;
            pTTPParm->PI = TTP_MAX_SDU_SIZE_PI;
            pTTPParm->PL = TTP_MAX_SDU_SIZE_PL;
            pTTPParm->PV[3] = (UCHAR) (pLsapCb->RxMaxSDUSize & 0xFF);
            pTTPParm->PV[2] = (UCHAR) ((pLsapCb->RxMaxSDUSize & 0xFF00)
                                      >> 8);
            pTTPParm->PV[1] = (UCHAR) ((pLsapCb->RxMaxSDUSize & 0xFF0000)
                                      >> 16);
            pTTPParm->PV[0] = (UCHAR) ((pLsapCb->RxMaxSDUSize & 0xFF000000)
                                      >> 24);
        }
        
    }

    // Client connection data, Access mode does not include client data
    if (pLsapCb->UserDataLen == 0 || OpCode == IRLMP_ACCESSMODE_PDU) 
    {
        pMsg->IRDA_MSG_pBase =
        pMsg->IRDA_MSG_pRead =
        pMsg->IRDA_MSG_pWrite =
        pMsg->IRDA_MSG_pLimit = NULL;
    }
    else
    {
        pMsg->IRDA_MSG_pBase = pLsapCb->UserData;
        pMsg->IRDA_MSG_pRead = pLsapCb->UserData;
        pMsg->IRDA_MSG_pWrite = pLsapCb->UserData + pLsapCb->UserDataLen;
        pMsg->IRDA_MSG_pLimit = pMsg->IRDA_MSG_pWrite;
    }

    // Message built, send data request to IRLAP
    pMsg->Prim = IRLAP_DATA_REQ;
    
    pMsg->IRDA_MSG_Expedited = TRUE;

    pMsg->IRDA_MSG_pOwner = 0;
    
    DEBUGMSG(DBG_IRLMP,(TEXT("IRLMP: Sending LM_%s_%s for l=%d,r=%d pMsg:%X LsapCb:%X\n"), 
                         (OpCode == IRLMP_CONNECT_PDU ? TEXT("CONNECT") :
                         OpCode == IRLMP_DISCONNECT_PDU ? TEXT("DISCONNECT") :
                         OpCode == IRLMP_ACCESSMODE_PDU ? TEXT("ACCESSMODE") :
                         TEXT("!!oops!!")), 
                         (ABit==IRLMP_ABIT_REQUEST?TEXT("REQ"):TEXT("CONF")),
                         pLsapCb->LocalLsapSel,
                         pLsapCb->RemoteLsapSel,
                         pMsg, pMsg->IRDA_MSG_pOwner));
    
    if (IrlapDown(pLsapCb->pIrlmpCb->pIrdaLinkCb->IrlapContext, 
                  pMsg) != SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: IRLAP_DATA_REQUEST failed\n")));
        ASSERT(0);
    }                  
}
/*****************************************************************************
*
*   @func   UINT | LsapResponseTimerExp | Timer expiration callback
*
*   @rdesc  SUCCESS or an error code
*
*/
VOID
LsapResponseTimerExp(PVOID Context)
{
    IRLMP_LSAP_CB   *pLsapCb = (IRLMP_LSAP_CB *) Context;
    IRDA_MSG        IMsg;
    UINT            rc = SUCCESS;
    PIRLMP_LINK_CB  pIrlmpCb = pLsapCb->pIrlmpCb;
    
    PAGED_CODE();
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: LSAP timer expired\n")));

    VALIDLSAP(pLsapCb);
    
    switch (pLsapCb->State)
    {
      case LSAP_LMCONN_CONF_PEND:
        if (pLsapCb->LocalLsapSel == IAS_LSAP_SEL)
        {
            IasServerDisconnectReq(pLsapCb);
            break;
        }
        
        if (pLsapCb->LocalLsapSel == IAS_LOCAL_LSAP_SEL && 
            pLsapCb->RemoteLsapSel == IAS_LSAP_SEL)
        {
            IasClientDisconnectReq(pLsapCb, IRLMP_NO_RESPONSE_LSAP);
        }
        else
        {

            DeleteLsap(pLsapCb);
            
            IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);
        }
        break;

      case LSAP_CONN_RESP_PEND:
        pLsapCb->UserDataLen = 0; // This will ensure no client data sent in
                                   // Disconnect PDU below

        // Tell remote LSAP that its peer did not respond
        SendCntlPdu(pLsapCb,IRLMP_DISCONNECT_PDU,IRLMP_ABIT_REQUEST,
                    IRLMP_NO_RESPONSE_LSAP, 0);
        IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);

        DeleteLsap(pLsapCb);
        break;

      case LSAP_MULTIPLEXEDMODE_PEND:
        // Spec says peer can't refuse request to return to multiplex mode
        // but if no answer, go into multiplexed anyway?
      case LSAP_EXCLUSIVEMODE_PEND:
        pIrlmpCb->pExclLsapCb = NULL;
        // Peer didn't respond, maybe we are not connected anymore ???

        pLsapCb->State = LSAP_READY;
        
        IMsg.Prim = IRLMP_ACCESSMODE_CONF;
        IMsg.IRDA_MSG_AccessMode = IRLMP_MULTIPLEXED;
        IMsg.IRDA_MSG_ModeStatus = IRLMP_ACCESSMODE_FAILURE;
        TdiUp(pLsapCb->TdiContext, &IMsg);
        break;
         
      default:
        DEBUGMSG(DBG_IRLMP, (TEXT("Ignoring timer expiry in this state, %d\n"),pLsapCb->State));
        ; // ignore
    }
}
/*****************************************************************************
*
*   @func   UINT | IrlmpUp | Bottom of IRLMP, called by IRLAP with
*                             IRLAP messages. This is the MUX
*
*   @rdesc  SUCCESS or an error code
*
*/
UINT
IrlmpUp(PIRDA_LINK_CB pIrdaLinkCb, IRDA_MSG *pMsg)
{
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;

    switch (pMsg->Prim)
    {
      case IRLAP_DISCOVERY_IND:
        UpdateDeviceList(pIrlmpCb, pMsg->IRDA_MSG_pDevList);
        /*
        TDI ignores this
        pMsg->Prim = IRLMP_DISCOVERY_IND;
        pMsg->IRDA_MSG_pDevList = &DeviceList;
        TdiUp(NULL, pMsg);
        */
        return SUCCESS;

      case IRLAP_DISCOVERY_CONF:
        IrlapDiscoveryConf(pIrlmpCb, pMsg);
        return SUCCESS;

      case IRLAP_CONNECT_IND:
        IrlapConnectInd(pIrlmpCb, pMsg);
        return SUCCESS;

      case IRLAP_CONNECT_CONF:
        IrlapConnectConf(pIrlmpCb, pMsg);
        return SUCCESS;

      case IRLAP_DISCONNECT_IND:
        IrlapDisconnectInd(pIrlmpCb, pMsg);
        return SUCCESS;

      case IRLAP_DATA_CONF:
        IrlapDataConf(pMsg);
        return SUCCESS;

      case IRLAP_DATA_IND:
        IrlapDataInd(pIrlmpCb, pMsg);
        if (pIrlmpCb->pExclLsapCb &&
            pIrlmpCb->pExclLsapCb->RemoteTxCredit <=0)
            return IRLMP_LOCAL_BUSY;
        else
            return SUCCESS;

      case IRLAP_UDATA_IND:
        ASSERT(0);
        return SUCCESS;
        
      case IRLAP_STATUS_IND:
        TdiUp(NULL, pMsg);
        return SUCCESS;
    }
    return SUCCESS;
}

/*****************************************************************************
*
*   @func   UINT | IrlapDiscoveryConf | Process the discovery confirm
*/
VOID
IrlapDiscoveryConf(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg)
{
    DEBUGMSG(DBG_DISCOVERY, (TEXT("IRLMP: IRLAP_DISCOVERY_CONF\n")));
    
    if (pIrlmpCb->LinkState != LINK_IN_DISCOVERY)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Link bad state\n")));

        ASSERT(pIrlmpCb->LinkState == LINK_DOWN);
        
        return;// IRLMP_LINK_BAD_STATE;
    }

    pIrlmpCb->LinkState = LINK_DISCONNECTED;

    if (pMsg->IRDA_MSG_DscvStatus == IRLAP_DISCOVERY_COMPLETED)
    {
        UpdateDeviceList(pIrlmpCb, pMsg->IRDA_MSG_pDevList);
    }
    
    // Initiate discovery on next link
    IrdaEventSchedule(&EvDiscoveryReq, NULL);

    // Initiate a connection if one was requested while in discovery
    ScheduleConnectReq(pIrlmpCb);    
}

void
AddDeviceToGlobalList(IRDA_DEVICE *pNewDevice)
{
    IRDA_DEVICE     *pDevice;
    
    for (pDevice = (IRDA_DEVICE *) gDeviceList.Flink;
         (LIST_ENTRY *) pDevice != &gDeviceList;
         pDevice = (IRDA_DEVICE *) pDevice->Linkage.Flink)
    {
        if (pNewDevice->DscvInfoLen == pDevice->DscvInfoLen &&
            CTEMemCmp(pNewDevice->DevAddr, pDevice->DevAddr,
               IRDA_DEV_ADDR_LEN) == 0 &&
            CTEMemCmp(pNewDevice->DscvInfo, pDevice->DscvInfo,
               (ULONG) pNewDevice->DscvInfoLen) == 0)
        {
            // Device is already in the global list
            
            return;
        }
    }     
    
    if (IRDA_ALLOC_MEM(pDevice, sizeof(IRDA_DEVICE), MT_IRLMP_DEVICE) != NULL)
    {
        RtlCopyMemory(pDevice, pNewDevice, sizeof(IRDA_DEVICE));
        InsertHeadList(&gDeviceList, &pDevice->Linkage);
    }    
}

void
DeleteDeviceFromGlobalList(IRDA_DEVICE *pOldDevice)
{
    IRDA_DEVICE     *pDevice;
    
    for (pDevice = (IRDA_DEVICE *) gDeviceList.Flink;
         (LIST_ENTRY *) pDevice != &gDeviceList;
         pDevice = (IRDA_DEVICE *) pDevice->Linkage.Flink)
    {
        if (pOldDevice->DscvInfoLen == pDevice->DscvInfoLen &&
            CTEMemCmp(pOldDevice->DevAddr, pDevice->DevAddr,
               IRDA_DEV_ADDR_LEN) == 0 &&
            CTEMemCmp(pOldDevice->DscvInfo, pDevice->DscvInfo,
               (ULONG) pOldDevice->DscvInfoLen) == 0)
        {
            RemoveEntryList(&pDevice->Linkage);
            IRDA_FREE_MEM(pDevice);
            return;
        }
    }     
}

/*****************************************************************************
*
*   @func   void | UpdateDeviceList | Determines if new devices need to be
*                                  added or old ones removed from the device
*                                  list maintained by IRLMP
*
*   @parm   LIST_ENTRY * | pDevList | pointer to a list of devices
*/
/*void
UpdateDeviceList(PIRLMP_LINK_CB pIrlmpCb, LIST_ENTRY *pNewDevList)
{
    IRDA_DEVICE     *pNewDevice;
    IRDA_DEVICE     *pOldDevice;
    IRDA_DEVICE     *pDevice;
    BOOLEAN         DeviceInList;
    KIRQL           OldIrql;
    
    KeAcquireSpinLock(&gSpinLock, &OldIrql);
    
    // Add new devices, set not seen count to zero if devices is
    // seen again
    for (pNewDevice = (IRDA_DEVICE *) pNewDevList->Flink;
         (LIST_ENTRY *) pNewDevice != pNewDevList;
         pNewDevice = (IRDA_DEVICE *) pNewDevice->Linkage.Flink)
    {
        DeviceInList = FALSE;
        
        AddDeviceToGlobalList(pNewDevice);

        for (pOldDevice = (IRDA_DEVICE *) pIrlmpCb->DeviceList.Flink;
             (LIST_ENTRY *) pOldDevice != &pIrlmpCb->DeviceList;
             pOldDevice = (IRDA_DEVICE *) pOldDevice->Linkage.Flink)
        {
            if (pNewDevice->DscvInfoLen == pOldDevice->DscvInfoLen &&
                RtlCompareMemory(pNewDevice->DevAddr, pOldDevice->DevAddr,
                          IRDA_DEV_ADDR_LEN) == IRDA_DEV_ADDR_LEN &&
                RtlCompareMemory(pNewDevice->DscvInfo, pOldDevice->DscvInfo,
                          pNewDevice->DscvInfoLen) == 
                          (ULONG) pNewDevice->DscvInfoLen)
            {
                DeviceInList = TRUE;
                pOldDevice->NotSeenCnt = -1; // reset not seen count
                                             // will be ++'d to 0 below
                break;
            }
        }
        if (!DeviceInList)
        {
            // Create an new entry in the list maintained by IRLMP
            IRDA_ALLOC_MEM(pDevice, sizeof(IRDA_DEVICE), MT_IRLMP_DEVICE);

            RtlCopyMemory(pDevice, pNewDevice, sizeof(IRDA_DEVICE));
            pDevice->NotSeenCnt = -1; // will be ++'d to 0 below
            InsertHeadList(&pIrlmpCb->DeviceList, &pDevice->Linkage);
        }
    }

    // Run through the list and remove devices that haven't
    // been seen for awhile

    pOldDevice = (IRDA_DEVICE *) pIrlmpCb->DeviceList.Flink;

    while ((LIST_ENTRY *) pOldDevice != &pIrlmpCb->DeviceList)
    {
        pDevice = (IRDA_DEVICE *) pOldDevice->Linkage.Flink;

        if (++(pOldDevice->NotSeenCnt) >= IRLMP_NOT_SEEN_THRESHOLD)
        {
            DeleteDeviceFromGlobalList(pOldDevice);
            
            RemoveEntryList(&pOldDevice->Linkage);
            IRDA_FREE_MEM(pOldDevice);
        }
        pOldDevice = pDevice; // next
    }
    
    KeReleaseSpinLock(&gSpinLock, OldIrql);
}*/
void
UpdateDeviceList(PIRLMP_LINK_CB pIrlmpCb, LIST_ENTRY *pNewDevList)
{
    IRDA_DEVICE     *pNewDevice;
    IRDA_DEVICE     *pOldDevice;
    IRDA_DEVICE     *pDevice;
    BOOLEAN         DeviceInList;
    KIRQL           OldIrql;
    
    KeAcquireSpinLock(&gSpinLock, &OldIrql);
    
    // Add new devices, set not seen count to zero if devices is
    // seen again
    for (pNewDevice = (IRDA_DEVICE *) pNewDevList->Flink;
         (LIST_ENTRY *) pNewDevice != pNewDevList;
         pNewDevice = (IRDA_DEVICE *) pNewDevice->Linkage.Flink)
    {
        DeviceInList = FALSE;
        
        AddDeviceToGlobalList(pNewDevice);

        for (pOldDevice = (IRDA_DEVICE *) pIrlmpCb->DeviceList.Flink;
             (LIST_ENTRY *) pOldDevice != &pIrlmpCb->DeviceList;
             pOldDevice = (IRDA_DEVICE *) pOldDevice->Linkage.Flink)
        {
            if (pNewDevice->DscvInfoLen == pOldDevice->DscvInfoLen &&
                CTEMemCmp(pNewDevice->DevAddr, pOldDevice->DevAddr,
                          IRDA_DEV_ADDR_LEN) == 0 &&
                CTEMemCmp(pNewDevice->DscvInfo, pOldDevice->DscvInfo,
                          (ULONG) pNewDevice->DscvInfoLen) == 0)
            {
                DeviceInList = TRUE;
                pOldDevice->NotSeenCnt = -1; // reset not seen count
                                             // will be ++'d to 0 below
                break;
            }
        }
        if (!DeviceInList)
        {
            // Create an new entry in the list maintained by IRLMP
            IRDA_ALLOC_MEM(pDevice, sizeof(IRDA_DEVICE), MT_IRLMP_DEVICE);

            if (pDevice)
            {
                RtlCopyMemory(pDevice, pNewDevice, sizeof(IRDA_DEVICE));
                pDevice->NotSeenCnt = -1; // will be ++'d to 0 below
                InsertHeadList(&pIrlmpCb->DeviceList, &pDevice->Linkage);
            }    
        }
    }

    // Run through the list and remove devices that haven't
    // been seen for awhile

    pOldDevice = (IRDA_DEVICE *) pIrlmpCb->DeviceList.Flink;

    while ((LIST_ENTRY *) pOldDevice != &pIrlmpCb->DeviceList)
    {
        pDevice = (IRDA_DEVICE *) pOldDevice->Linkage.Flink;

        pOldDevice->NotSeenCnt += 1;
        
        if (pOldDevice->NotSeenCnt == 1 || pOldDevice->NotSeenCnt == 2)
        {
            pIrlmpCb->DiscoveryFlags = DF_NO_SENSE_DSCV;
        }
        else if (pOldDevice->NotSeenCnt > 2)
        {
            DeleteDeviceFromGlobalList(pOldDevice);
            
            RemoveEntryList(&pOldDevice->Linkage);
            IRDA_FREE_MEM(pOldDevice);
        }
        pOldDevice = pDevice; // next
    }
    
    KeReleaseSpinLock(&gSpinLock, OldIrql);
}
/*****************************************************************************
*
*   @func   UINT | IrlapConnectInd | Process the connect indication from LAP
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
VOID
IrlapConnectInd(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg)
{
    PAGED_CODE();
    
    if (pIrlmpCb->LinkState != LINK_DISCONNECTED)
    {
        ASSERT(0);
        return;
    }
    
    pIrlmpCb->LinkState = LINK_CONNECTING;
    
    RtlCopyMemory(pIrlmpCb->ConnDevAddr, pMsg->IRDA_MSG_RemoteDevAddr,
           IRDA_DEV_ADDR_LEN);
    RtlCopyMemory(&pIrlmpCb->NegotiatedQOS, pMsg->IRDA_MSG_pQos,
           sizeof(IRDA_QOS_PARMS));
    pIrlmpCb->MaxPDUSize = IrlapGetQosParmVal(vDataSizeTable,
                               pMsg->IRDA_MSG_pQos->bfDataSize, NULL)
                             - sizeof(IRLMP_HEADER) 
                             - sizeof(TTP_DATA_HEADER)
                             - 2 // size of irlap header
                             - 1; // IrComm

    pIrlmpCb->WindowSize = IrlapGetQosParmVal(vWinSizeTable,
                              pMsg->IRDA_MSG_pQos->bfWindowSize, NULL);

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Connect indication, MaxPDU = %d\n"),
                          pIrlmpCb->MaxPDUSize));
    
    // schedule the response to occur on a differnt thread
    pIrlmpCb->AcceptConnection = TRUE;            
    IrdaEventSchedule(&EvConnectResp, pIrlmpCb->pIrdaLinkCb);
}
/*****************************************************************************
*
*   @func   UINT | IrlapConnectConf | Processes the connect confirm
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
VOID
IrlapConnectConf(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg)
{
    PAGED_CODE();
    
    ASSERT(pIrlmpCb->LinkState == LINK_CONNECTING);

    // Currently, the connect confirm always returns a successful status
    ASSERT(pMsg->IRDA_MSG_ConnStatus == IRLAP_CONNECTION_COMPLETED);

    // Update Link
    pIrlmpCb->LinkState = LINK_READY;
    RtlCopyMemory(&pIrlmpCb->NegotiatedQOS, pMsg->IRDA_MSG_pQos,
            sizeof(IRDA_QOS_PARMS));
    pIrlmpCb->MaxPDUSize =  IrlapGetQosParmVal(vDataSizeTable,
                                      pMsg->IRDA_MSG_pQos->bfDataSize, NULL)
                             - sizeof(IRLMP_HEADER) 
                             - sizeof(TTP_DATA_HEADER)
                             - 2 // size of irlap header
                             - 1; // IrComm

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: IRLAP_CONNECT_CONF, TxMaxPDU = %d\n"),
                          pIrlmpCb->MaxPDUSize));
    
    IrdaEventSchedule(&EvLmConnectReq, pIrlmpCb->pIrdaLinkCb);
}
/*****************************************************************************
*
*   @func   UINT | IrlapDisconnectInd | Processes the disconnect indication
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
VOID
IrlapDisconnectInd(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg)
{
    IRLMP_DISC_REASON   DiscReason = IRLMP_UNEXPECTED_IRLAP_DISC;
    
    PAGED_CODE();

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: IRLAP Disconnect Ind, status = %d\n"),
                          pMsg->IRDA_MSG_DiscStatus));
    
    switch (pIrlmpCb->LinkState)
    {
      case LINK_CONNECTING:
        if (pMsg->IRDA_MSG_DiscStatus == MAC_MEDIA_BUSY)
        {
            DiscReason = IRLMP_MAC_MEDIA_BUSY;
        }
        else
        {
            DiscReason = IRLMP_IRLAP_CONN_FAILED;
        }
        
        // Fall through
      case LINK_READY:
        pIrlmpCb->LinkState = LINK_DISCONNECTED;
        TearDownConnections(pIrlmpCb, DiscReason);
        break;

      case LINK_DISCONNECTING:
        pIrlmpCb->LinkState = LINK_DISCONNECTED;
        // Initiate a connection if one was requested while disconnecting
        ScheduleConnectReq(pIrlmpCb);
        break;

      default:
        DEBUGMSG(1, (TEXT("Link STATE %d\n"), pIrlmpCb->LinkState));
        
        //ASSERT(0);
    }
}
/*****************************************************************************
*
*   @func   IRLMP_LSAP_CB * | GetLsapInState | returns the first occurance of
*                                              an LSAP in the specified state
*                                              as long as the link is in the
*                                              specified state.
*
*   @parm   int | LinkState | get LSAP only as long as link is in this state
*
*   @parm   int | LSAP | Return the LSAP that is in this state if InThisState
*                        is TRUE. Else return LSAP if it is not in this state
*                        if InThisState = FALSE
*
*   @parm   BOOLEAN | InThisState | TRUE return LSAP if in this state
*                                FALSE return LSAP if not in this state
*
*   @rdesc  pointer to an LSAP control block or NULL, if an LSAP is returned
*
*/
IRLMP_LSAP_CB *
GetLsapInState(PIRLMP_LINK_CB pIrlmpCb,
               int LinkState,
               int LSAPState,
               BOOLEAN InThisState)
{
    IRLMP_LSAP_CB *pLsapCb;
    
    PAGED_CODE();    

    // Only want to find an LSAP if the link is in the specified state
    if (pIrlmpCb->LinkState != LinkState)
    {
        return NULL;
    }

    for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
         (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
         pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
    {

        VALIDLSAP(pLsapCb);
        
        if ((pLsapCb->State == LSAPState && InThisState == TRUE) ||
            (pLsapCb->State != LSAPState && InThisState == FALSE))
        {
            return pLsapCb;
        }
    }

    return NULL;
}
/*****************************************************************************
*
*/
IRLMP_LINK_CB *
GetIrlmpCb(PUCHAR RemoteDevAddr)
{
    IRDA_DEVICE         *pDevice;
    PIRLMP_LINK_CB      pIrlmpCb;
    KIRQL               OldIrql;    
    PIRDA_LINK_CB       pIrdaLinkCb;
    
    KeAcquireSpinLock(&gSpinLock, &OldIrql);

    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
         pIrdaLinkCb = (PIRDA_LINK_CB) pIrdaLinkCb->Linkage.Flink)
    {
        pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
    
        for (pDevice = (IRDA_DEVICE *) pIrlmpCb->DeviceList.Flink;
             (LIST_ENTRY *) pDevice != &pIrlmpCb->DeviceList;
             pDevice = (IRDA_DEVICE *) pDevice->Linkage.Flink)
        {
            if (CTEMemCmp(pDevice->DevAddr, RemoteDevAddr,
                          IRDA_DEV_ADDR_LEN) == 0)
            {
                KeReleaseSpinLock(&gSpinLock, OldIrql);
                        
                return pIrlmpCb;
            }
        }    
    }
    
    KeReleaseSpinLock(&gSpinLock, OldIrql);
    
    return NULL;
}
/*****************************************************************************
*
*   @func   UINT | DiscDelayTimerFunc | Timer expiration callback
*
*   @rdesc  SUCCESS or an error code
*
*/
VOID
DiscDelayTimerFunc(PVOID Context)
{
    IRLMP_LSAP_CB               *pLsapCb;
    IRDA_MSG                    IMsg;
    UINT                        rc = SUCCESS;
    PIRLMP_LINK_CB              pIrlmpCb = (PIRLMP_LINK_CB) Context;
    
    PAGED_CODE();

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Link timer expired\n")));

    // The timer that expired is the disconnect delay timer. Bring
    // down link if no LSAP connection exists
    if (pIrlmpCb->LinkState == LINK_DISCONNECTED)
    {
        // already disconnected
        return;
    }
    
    // Search for an LSAP that is connected or coming up
    pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
    while (&pIrlmpCb->LsapCbList != (LIST_ENTRY *) pLsapCb)
    {
        VALIDLSAP(pLsapCb);
        
        if (pLsapCb->State > LSAP_DISCONNECTED)
        {
            // Don't bring down link, an LSAP is connected or connecting
            return;
        }
        pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink;
    }

    DEBUGMSG(DBG_IRLMP, (TEXT(
       "IRLMP: No LSAP connections, disconnecting link\n")));
    // No LSAP connections, bring it down if it is up
    if (pIrlmpCb->LinkState == LINK_READY)
    {
        pIrlmpCb->LinkState = LINK_DISCONNECTING;

        // Request IRLAP to disconnect the link
        IMsg.Prim = IRLAP_DISCONNECT_REQ;
        IrlapDown(pIrlmpCb->pIrdaLinkCb->IrlapContext, &IMsg);
    }

    return;
}
/*****************************************************************************
*
*   @func   UINT | IrlapDataConf | Processes the data confirm
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*/
VOID
IrlapDataConf(IRDA_MSG *pMsg)
{
    IRLMP_LSAP_CB   *pLsapCb = pMsg->IRDA_MSG_pOwner;
    IRDA_MSG        *pSegParentMsg;
    BOOLEAN         RequestFailed = FALSE;
    UINT            rc = SUCCESS;

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Received IRLAP_DATA_CONF pMsg:%X LsapCb:%X\n"),
                pMsg, pMsg->IRDA_MSG_pOwner));

    if (pMsg->IRDA_MSG_DataStatus != IRLAP_DATA_REQUEST_COMPLETED)
    {
        RequestFailed = TRUE;
    }
         
    if (pMsg->IRDA_MSG_SegFlags & SEG_LOCAL)    
    {
        // Locally generated data request
        FreeIrdaBuf(IrdaMsgPool, pMsg);

        if (RequestFailed)
        {
            ; // LOG ERROR
        }
        
        return;
    }
    else
    {
        VALIDLSAP(pLsapCb);    
        
        if (pMsg->IRDA_MSG_SegCount == 0)
        {
            if (!RequestFailed)
            {
                pMsg->IRDA_MSG_DataStatus = IRLMP_DATA_REQUEST_COMPLETED;
            }
        }
        else
        {
            // A segmented message, get its Parent 
            pSegParentMsg = pMsg->DataContext;
            
            // Free the segment
            FreeIrdaBuf(IrdaMsgPool, pMsg);

            if (RequestFailed)
            {
                pSegParentMsg->IRDA_MSG_DataStatus = IRLMP_DATA_REQUEST_FAILED;
            }
            
            if (--(pSegParentMsg->IRDA_MSG_SegCount) != 0)
            {
                // Still outstanding segments
                goto done;
            }
            // No more segments, send DATA_CONF to client
            // First remove it from the LSAPs TxMsgList 
            RemoveEntryList(&pSegParentMsg->Linkage);

            pMsg = pSegParentMsg;
        }

        // If request fails for non-segmented messages, the IRLAP error is
        // returned            
        pMsg->Prim = IRLMP_DATA_CONF;

        TdiUp(pLsapCb->TdiContext, pMsg);
done:
        REFDEL(&pLsapCb->RefCnt, 'ATAD');
    }
}
/*****************************************************************************
*
*   @func   UINT | IrlapDataInd | process the data indication
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | Pointer to an IRDA Message
*
*/
VOID
IrlapDataInd(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg)
{
    IRLMP_HEADER        *pLMHeader;
    IRLMP_CNTL_FORMAT   *pCntlFormat;
    UCHAR                *pCntlParm1;
    UCHAR                *pCntlParm2;

    if ((pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead) < sizeof(IRLMP_HEADER))
    {
        ASSERT(0);
        
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Receive invalid data\n")));
        
        return; // IRLMP_DATA_IND_BAD_FRAME;
    }

    pLMHeader = (IRLMP_HEADER *) pMsg->IRDA_MSG_pRead;

    pMsg->IRDA_MSG_pRead += sizeof(IRLMP_HEADER);

    if (pLMHeader->CntlBit != IRLMP_CNTL_PDU)
    {
        LmPduData(pIrlmpCb, pMsg, (int) pLMHeader->DstLsapSel,
                  (int) pLMHeader->SrcLsapSel);        
    }
    else
    {
        pCntlFormat = (IRLMP_CNTL_FORMAT *) pMsg->IRDA_MSG_pRead;

        // Ensure the control format is included. As per errate, it is
        // valid to exclude the parameter (for LM-connects and only if
        // no user data)        
        if ((UCHAR *) pCntlFormat >= pMsg->IRDA_MSG_pWrite)
        {
            ASSERT(0);
            // Need at least the OpCode portion
            return;// IRLMP_DATA_IND_BAD_FRAME;
        }
        else
        {
            // Initialize control parameters (if exists) and point
            // to beginning of user data
            if (&(pCntlFormat->Parm1) >= pMsg->IRDA_MSG_pWrite)
            {
                pCntlParm1 = NULL;
                pCntlParm2 = NULL;
                pMsg->IRDA_MSG_pRead = &(pCntlFormat->Parm1); // ie none
            }
            else
            {
                pCntlParm1 = &(pCntlFormat->Parm1);
                pCntlParm2 = &(pCntlFormat->Parm2); // Access mode only
                pMsg->IRDA_MSG_pRead = &(pCntlFormat->Parm2); 
            }                
        }        

        switch (pCntlFormat->OpCode)
        {
          case IRLMP_CONNECT_PDU:
            if (pCntlFormat->ABit == IRLMP_ABIT_REQUEST)
            {
                // Connection Request LM-PDU
                LmPduConnectReq(pIrlmpCb, pMsg, 
                                (int) pLMHeader->DstLsapSel,
                                (int) pLMHeader->SrcLsapSel,
                                pCntlParm1);
            }
            else 
            {
                // Connection Confirm LM-PDU
                LmPduConnectConf(pIrlmpCb, pMsg, 
                                 (int) pLMHeader->DstLsapSel,
                                 (int) pLMHeader->SrcLsapSel,
                                 pCntlParm1);
            }
            break;

        case IRLMP_DISCONNECT_PDU:
            if (pCntlFormat->ABit != IRLMP_ABIT_REQUEST)
            {
                ; // LOG ERROR !!!
            }
            else
            {
                LmPduDisconnectReq(pIrlmpCb, pMsg,
                                   (int) pLMHeader->DstLsapSel,
                                   (int) pLMHeader->SrcLsapSel,
                                   pCntlParm1);
            }
            break;
            
          case IRLMP_ACCESSMODE_PDU:
            if (pCntlFormat->ABit == IRLMP_ABIT_REQUEST)
            {
                LmPduAccessModeReq(pIrlmpCb,
                                   (int) pLMHeader->DstLsapSel,
                                   (int) pLMHeader->SrcLsapSel,
                                   pCntlParm1, pCntlParm2);
            }
            else
            {
                LmPduAccessModeConf(pIrlmpCb,
                                    (int) pLMHeader->DstLsapSel,
                                    (int) pLMHeader->SrcLsapSel,
                                    pCntlParm1, pCntlParm2);
            }
            break;
        }
    }
}
/*****************************************************************************
*
*   @func   UINT | LmPduConnectReq | Process the received connect
*                                        request LM-PDU
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | pointer to an IRDA message
*           int | LocalLsapSel | The local LSAP selector, 
*                                 (destination LSAP-SEL in message)
*           int | RemoteLsapSel | The remote LSAP selector,
*                                  (source LSAP-SEL in message)
*           UCHAR * | pRsvdByte | pointer to the reserved parameter
*/
VOID
LmPduConnectReq(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg,
                int LocalLsapSel, int RemoteLsapSel, UCHAR *pRsvdByte)
{
    IRDA_MSG                IMsg;
    IRLMP_LSAP_CB           *pLsapCb = GetLsap(pIrlmpCb,
                                               LocalLsapSel, RemoteLsapSel);
    IRLMP_REGISTERED_LSAP   *pRegLsap;
    BOOLEAN                 LsapRegistered = FALSE;
    
    PAGED_CODE();    
    
    DEBUGMSG((DBG_IRLMP | DBG_IRLMP_CONN), 
             (TEXT("IRLMP: Received LM_CONNECT_REQ for l=%d,r=%d\n"),
              LocalLsapSel, RemoteLsapSel));
    
    if (pRsvdByte != NULL && *pRsvdByte != 0x00)
    {
        // LOG ERROR (bad parm value)
        ASSERT(0);
        return;
    }       

    if (LocalLsapSel == IAS_LSAP_SEL)
    {
        IasConnectReq(pIrlmpCb, RemoteLsapSel);
        return;
    }

    if (pLsapCb == NULL) // Usually NULL, unless receiving 2nd ConnReq
    {
        // No reason to except connection if an LSAP hasn't been registered
        for (pRegLsap = (IRLMP_REGISTERED_LSAP *)
             RegisteredLsaps.Flink;
             (LIST_ENTRY *) pRegLsap != &RegisteredLsaps;
             pRegLsap = (IRLMP_REGISTERED_LSAP *) pRegLsap->Linkage.Flink)
        {
            if (pRegLsap->Lsap == LocalLsapSel)
            {
                LsapRegistered = TRUE;
                break;
            }
        }
        if (!LsapRegistered)
        {
            // No LSAP exists which matches the requested LSAP in the connect
            // packet. IRLMP will decline this connection
            UnroutableSendLMDisc(pIrlmpCb, LocalLsapSel, RemoteLsapSel);
            return;
        }
        else
        {
            // Create a new one
            if (CreateLsap(pIrlmpCb, &pLsapCb) != SUCCESS)
            {
                ASSERT(0);
                return;
            }
            pLsapCb->Flags |= pRegLsap->Flags;
            pLsapCb->TdiContext = NULL;
        }

        // very soon this LSAP will be waiting for a connect response
        // from the upper layer
        pLsapCb->State = LSAP_CONN_RESP_PEND;
    
        pLsapCb->LocalLsapSel = LocalLsapSel;
        pLsapCb->RemoteLsapSel = RemoteLsapSel;
        pLsapCb->UserDataLen = 0;

        SetupTtpAndStoreConnData(pLsapCb, pMsg);

        // Now setup the message to send to the client notifying him
        // of a incoming connection indication
        IMsg.Prim = IRLMP_CONNECT_IND;

        RtlCopyMemory(IMsg.IRDA_MSG_RemoteDevAddr, pIrlmpCb->ConnDevAddr,
               IRDA_DEV_ADDR_LEN);
        IMsg.IRDA_MSG_LocalLsapSel = LocalLsapSel;
        IMsg.IRDA_MSG_RemoteLsapSel = RemoteLsapSel;
        IMsg.IRDA_MSG_pQos = &pIrlmpCb->NegotiatedQOS;
        if (pLsapCb->UserDataLen != 0)
        {
            IMsg.IRDA_MSG_pConnData = pLsapCb->UserData;
            IMsg.IRDA_MSG_ConnDataLen = pLsapCb->UserDataLen;
        }
        else
        {
            IMsg.IRDA_MSG_pConnData = NULL;
            IMsg.IRDA_MSG_ConnDataLen = 0;
        }
    
        IMsg.IRDA_MSG_pContext = pLsapCb;
        IMsg.IRDA_MSG_MaxSDUSize = pLsapCb->TxMaxSDUSize;
        IMsg.IRDA_MSG_MaxPDUSize = pIrlmpCb->MaxPDUSize;

        // The LSAP response timer is the time that we give the Client
        // to respond to this connect indication. If it expires before
        // the client responds, then IRLMP will decline the connect
        IrdaTimerRestart(&pLsapCb->ResponseTimer);
                
        TdiUp(pLsapCb->TdiContext, &IMsg);
        return;
    }
    else
    {
        ASSERT(0);
    }    
    // Ignoring if LSAP already exists
}
/*****************************************************************************
*
*   @func   UINT | LmPduConnectConf | Process the received connect
*                                         confirm LM-PDU
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | pointer to an IRDA message
*           int | LocalLsapSel | The local LSAP selector, 
*                                 (destination LSAP-SEL in message)
*           int | RemoteLsapSel | The remote LSAP selector,
*                                  (source LSAP-SEL in message)
*           BYTE * | pRsvdByte | pointer to the reserved byte parameter
*/
VOID
LmPduConnectConf(PIRLMP_LINK_CB pIrlmpCb,
                 IRDA_MSG *pMsg, int LocalLsapSel, int RemoteLsapSel,
                 UCHAR *pRsvdByte)
{
    IRLMP_LSAP_CB   *pLsapCb = GetLsap(pIrlmpCb,
                                       LocalLsapSel, RemoteLsapSel);

    PAGED_CODE();

    DEBUGMSG((DBG_IRLMP | DBG_IRLMP_CONN), 
             (TEXT("IRLMP: Received LM_CONNECT_CONF for l=%d,r=%d\n"),
              LocalLsapSel, RemoteLsapSel));

    if (pRsvdByte != NULL && *pRsvdByte != 0x00)
    {
        // LOG ERROR, indicate bad parm
        return;
    }

    if (pLsapCb == NULL)
    {
        // This is a connect confirm to a non-existant LSAP
        // LOG SOMETHING HERE !!!
        return; 
    }

    if (pLsapCb->State != LSAP_LMCONN_CONF_PEND)
    {
        // received unsolicited confirm
        // probably timed out
        return;
    }

    IrdaTimerStop(&pLsapCb->ResponseTimer);
    
    pLsapCb->State = LSAP_READY;
    
    if (LocalLsapSel == IAS_LOCAL_LSAP_SEL && RemoteLsapSel == IAS_LSAP_SEL)
    {
        SendGetValueByClassReq(pLsapCb);
        return;
    }
    else
    {
        SetupTtpAndStoreConnData(pLsapCb, pMsg);
    
        pMsg->Prim = IRLMP_CONNECT_CONF;
            
        pMsg->IRDA_MSG_pQos = &pIrlmpCb->NegotiatedQOS;
        if (pLsapCb->UserDataLen != 0)
        {
            pMsg->IRDA_MSG_pConnData = pLsapCb->UserData;
            pMsg->IRDA_MSG_ConnDataLen = pLsapCb->UserDataLen;
        }
        else
        {
            pMsg->IRDA_MSG_pConnData = NULL;
            pMsg->IRDA_MSG_ConnDataLen = 0;
        }
        
        pMsg->IRDA_MSG_pContext = pLsapCb;
        pMsg->IRDA_MSG_MaxSDUSize = pLsapCb->TxMaxSDUSize;
        pMsg->IRDA_MSG_MaxPDUSize = pIrlmpCb->MaxPDUSize;

        TdiUp(pLsapCb->TdiContext, pMsg);
    }
}
/*****************************************************************************
*/
VOID
SetupTtpAndStoreConnData(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    TTP_CONN_HEADER *pTTPHeader;
    UCHAR            PLen, *pEndParms, PI, PL;

    PAGED_CODE();
    
    VALIDLSAP(pLsapCb);
    
    // Upon entering this function, the pRead pointer points to the
    // TTP header or the beginning of client data

    if (!(pLsapCb->Flags & LCBF_USE_TTP))
    {
        pLsapCb->TxMaxSDUSize = pLsapCb->pIrlmpCb->MaxPDUSize;
    }
    else
    {
        if (pMsg->IRDA_MSG_pRead >= pMsg->IRDA_MSG_pWrite)
        {
            // THIS IS AN ERROR, WE ARE USING TTP. There is no more
            // data in the frame, but we need the TTP header
            // SOME KIND OF WARNING SHOULD BE LOGGED
            return;
        }
        pTTPHeader = (TTP_CONN_HEADER *) pMsg->IRDA_MSG_pRead;
        pLsapCb->LocalTxCredit = (int) pTTPHeader->InitialCredit;

        DEBUGMSG(DBG_IRLMP | DBG_IRLMP_CRED, (TEXT("IRLMP: Initial LocalTxCredit %d\n"),
                              pLsapCb->LocalTxCredit));
                              
        // advance the pointer to the first byte of data
        pMsg->IRDA_MSG_pRead += sizeof(TTP_CONN_HEADER);
        
        pLsapCb->TxMaxSDUSize = 0;
        if (pTTPHeader->ParmFlag == TTP_PFLAG_PARMS)
        {
            // Parameter carrying Connect TTP-PDU
            PLen = *pMsg->IRDA_MSG_pRead++;
            pEndParms = pMsg->IRDA_MSG_pRead + PLen;
        
            // NOTE: This breaks if PI other than MaxSDUSize!!!

            if (PLen < 3 || pEndParms > pMsg->IRDA_MSG_pWrite)
            {
                // LOG ERROR !!!
                return;
            }
            
            PI = *pMsg->IRDA_MSG_pRead++;
            PL = *pMsg->IRDA_MSG_pRead++;
            
            if (PI != TTP_MAX_SDU_SIZE_PI)
            {
                // LOG ERROR !!!
                return;
            }

            for ( ; PL != 0 ; PL--)
            {
                pLsapCb->TxMaxSDUSize <<= 8;
                pLsapCb->TxMaxSDUSize += (int) (*pMsg->IRDA_MSG_pRead);
                pMsg->IRDA_MSG_pRead++;
            }
        }
    }
    
    // if there is any user data with this connection request/conf, place
    // it in the control block. This is just a place to store this
    // information while upper layer is looking at it. It may be over-
    // written by connection data in the response from the client.
    pLsapCb->UserDataLen = 0;
    /*
    
    NOTE: IF USER CONNECTION DATA IS EVER SUPPORTED, VERIFY DATA
          WON'T OVERFLOW UserData BUFFER
          
    if (pMsg->IRDA_MSG_pRead < pMsg->IRDA_MSG_pWrite)
    {
        pLsapCb->UserDataLen = (UINT) (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead);
        RtlCopyMemory(pLsapCb->UserData, pMsg->IRDA_MSG_pRead,
               pLsapCb->UserDataLen);
    }
    */

    return;
}
/*****************************************************************************
*
*   @func   UINT | LmPduDisconnectReq | Process the received discconnect
*                                           request LM-PDU
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | pointer to an IRDA message
*           int | LocalLsapSel | The local LSAP selector, 
*                                 (destination LSAP-SEL in message)
*           int | RemoteLsapSel | The remote LSAP selector,
*                                  (source LSAP-SEL in message)
*           BYTE * | pReason | pointer to the reason parameter
*/
VOID
LmPduDisconnectReq(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg,
                   int LocalLsapSel, int RemoteLsapSel, UCHAR *pReason)
{
    IRLMP_LSAP_CB       *pLsapCb;
    UINT                rc = SUCCESS;

    
    if (pReason == NULL)
    {
        ASSERT(0);
        return; // LOG ERROR !!! need reason code
    }

    pLsapCb = GetLsap(pIrlmpCb, LocalLsapSel, RemoteLsapSel);

    DEBUGMSG((DBG_IRLMP | DBG_IRLMP_CONN), 
             (TEXT("IRLMP: Received LM_DISCONNECT_REQ LsapCb:%x for l=%d,r=%d\n"),
              pLsapCb, LocalLsapSel, RemoteLsapSel));
    
    if (pLsapCb == NULL)
    {
        return;
    }

    if (pLsapCb->State == LSAP_LMCONN_CONF_PEND)
    {
        IrdaTimerStop(&pLsapCb->ResponseTimer);
    }

    IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);

    if (LocalLsapSel == IAS_LSAP_SEL)
    {
        IasServerDisconnectReq(pLsapCb);
        return;
    }
    if (LocalLsapSel == IAS_LOCAL_LSAP_SEL && RemoteLsapSel == IAS_LSAP_SEL)
    {
        IasClientDisconnectReq(pLsapCb, *pReason);
        return;
    }

    if (pLsapCb->State != LSAP_DISCONNECTED)
    {
        pLsapCb->UserDataLen = 0;

        /*
        
        NOTE: IF USER CONNECTION DATA IS EVER SUPPORTED, VERIFY DATA
              WON'T OVERFLOW UserData BUFFER
          
        if (pMsg->IRDA_MSG_pRead < pMsg->IRDA_MSG_pWrite)
        {
            // Disconnect User data
            pLsapCb->UserDataLen = (UINT) (pMsg->IRDA_MSG_pWrite - pMsg->IRDA_MSG_pRead);
            RtlCopyMemory(pLsapCb->UserData, pMsg->IRDA_MSG_pRead,
               pLsapCb->UserDataLen);
        }   
        */

        pLsapCb->DiscReason = *pReason;
        
        DeleteLsap(pLsapCb);
    }
}
/*****************************************************************************
*
*   @func   IRLMP_LSAP_CB *| GetLsap | For the LSAP selector pair, return the
*                                      LSAP control block they map to. NULL
*                                      if one does not exist
*
*   @rdesc  pointer to an LSAP control block or NULL
*
*   @parm   int | LocalLsapSel | local LSAP selector
*   @parm   int | RemoteLsapSel | Remote LSAP selector
*
*   if an LSAP is found, its critical section is acquired
*/
IRLMP_LSAP_CB *
GetLsap(PIRLMP_LINK_CB pIrlmpCb, int LocalLsapSel, int RemoteLsapSel)
{
    IRLMP_LSAP_CB *pLsapCb;

    for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
         (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
         pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
    {
        VALIDLSAP(pLsapCb);

        if (pLsapCb->LocalLsapSel == LocalLsapSel &&
            pLsapCb->RemoteLsapSel == RemoteLsapSel)
        {
            return pLsapCb;
        }
    }

    return NULL;
}
/*****************************************************************************
*
*   @func   UINT | SendCreditPdu | Send a dataless PDU to extend credit
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRLMP_LSAP_CB * | pLsapCb | pointer to an LSAP control block
*/
VOID
SendCreditPdu(IRLMP_LSAP_CB *pLsapCb)
{
    IRDA_MSG    *pMsg;
    
    VALIDLSAP(pLsapCb);
    
    if (pLsapCb->AvailableCredit == 0)
    {
        // No credit to give
        return;
    }
    
    if ((pMsg = AllocIrdaBuf(IrdaMsgPool)) == NULL)
    {
        ASSERT(0);
        return;
    }

    // No Data
    pMsg->IRDA_MSG_pBase =
    pMsg->IRDA_MSG_pLimit =
    pMsg->IRDA_MSG_pRead = 
    pMsg->IRDA_MSG_pWrite = pMsg->IRDA_MSG_Header + IRDA_HEADER_LEN;

    pMsg->IRDA_MSG_IrCOMM_9Wire = FALSE;
    
    pMsg->IRDA_MSG_SegFlags = SEG_FINAL;
    
    FormatAndSendDataReq(pLsapCb, pMsg, TRUE, FALSE);
}
/*****************************************************************************
*
*   @func   VOID | LmPduData | Process the received data (indication)
*                                  LM-PDU
*
*   @rdesc  SUCCESS or an error code
*
*   @parm   IRDA_MSG * | pMsg | pointer to an IRDA message
*           int | LocalLsapSel | The local LSAP selector, 
*                                 (destination LSAP-SEL in message)
*           int | RemoteLsapSel | The remote LSAP selector,
*                                  (source LSAP-SEL in message)
*/
VOID
LmPduData(PIRLMP_LINK_CB pIrlmpCb, IRDA_MSG *pMsg,
          int LocalLsapSel, int RemoteLsapSel)
{
    IRLMP_LSAP_CB       *pLsapCb = GetLsap(pIrlmpCb,
                                           LocalLsapSel, RemoteLsapSel);
    TTP_DATA_HEADER     *pTTPHeader;
    BOOLEAN             DataPDUSent = FALSE;
    BOOLEAN             FinalSeg = TRUE;
   
    if (pLsapCb == NULL)
    {
        // Unroutable, send disconnect
        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Data sent to bad Lsap (%d,%d)\n"),
                    LocalLsapSel, RemoteLsapSel));
                    
        //UnroutableSendLMDisc(pIrlmpCb, LocalLsapSel, RemoteLsapSel);
        return;
    }

    if (LocalLsapSel == IAS_LSAP_SEL)
    {
        IasSendQueryResp(pLsapCb, pMsg);
        return;
    }
    if (LocalLsapSel == IAS_LOCAL_LSAP_SEL && RemoteLsapSel == IAS_LSAP_SEL)
    {
        IasProcessQueryResp(pIrlmpCb, pLsapCb, pMsg);
        return;
    }
    
    if (pLsapCb->Flags & LCBF_USE_TTP)
    {
        if (pMsg->IRDA_MSG_pRead >= pMsg->IRDA_MSG_pWrite)
        {
            DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Missing TTP Header!\n")));
            
            // NEED TTP HEADER, LOG ERROR !!!
            return;
        }
            
        pTTPHeader = (TTP_DATA_HEADER *) pMsg->IRDA_MSG_pRead;
        pMsg->IRDA_MSG_pRead += sizeof(TTP_DATA_HEADER);

        pLsapCb->LocalTxCredit += (int) pTTPHeader->AdditionalCredit;

        DEBUGMSG(DBG_IRLMP_CRED, 
                    (TEXT("IRLMP(l%d,r%d): Rx LocalTxCredit:+%d=%d\n"),
                    pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel,                    
                    pTTPHeader->AdditionalCredit, pLsapCb->LocalTxCredit));

        if (pTTPHeader->MoreBit == TTP_MBIT_NOT_FINAL)
        {
            FinalSeg = FALSE;
        }
    }
    
    REFADD(&pLsapCb->RefCnt, ' DNI'); 

    if (pMsg->IRDA_MSG_pRead < pMsg->IRDA_MSG_pWrite)
    {
        // PDU containing data. Decrement remotes Tx Credit
        pLsapCb->RemoteTxCredit--;
        
        if (pLsapCb->State >= LSAP_READY)
        {
            pMsg->Prim = IRLMP_DATA_IND;
            pMsg->IRDA_MSG_SegFlags = FinalSeg ? SEG_FINAL : 0;
        
            TdiUp(pLsapCb->TdiContext, pMsg);
        }    
    }
    // else no user data, this was a dataless TTP-PDU to extend credit.
      
    if (pLsapCb->State != LSAP_DISCONNECTED)
    {      
        // Did we get some credit?
        if ((pLsapCb->Flags & LCBF_USE_TTP) && 
            pLsapCb->LocalTxCredit > 0 && 
            pLsapCb->State == LSAP_NO_TX_CREDIT)
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: l%d,r%d flow on\n"),
                              pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel));
        
            pLsapCb->State = LSAP_READY;
        }
        DEBUGMSG(DBG_IRLMP,
             (TEXT("IRLMP(l%d,r%d): Rx LocTxCredit %d,RemoteTxCredit %d\n"),
              pLsapCb->LocalLsapSel, pLsapCb->RemoteLsapSel,             
              pLsapCb->LocalTxCredit, pLsapCb->RemoteTxCredit));

        while (!IsListEmpty(&pLsapCb->SegTxMsgList) && 
               pLsapCb->State == LSAP_READY)
        {
            pMsg = (IRDA_MSG *) RemoveHeadList(&pLsapCb->SegTxMsgList);
        
            FormatAndSendDataReq(pLsapCb, pMsg, FALSE, FALSE);

            DataPDUSent = TRUE;
        }   
    
        // Do I need to extend credit to peer in a dataless PDU?
        if ((pLsapCb->Flags & LCBF_USE_TTP) && 
            !DataPDUSent && 
            pLsapCb->RemoteTxCredit <= pIrlmpCb->WindowSize + 1)
        {   
            SendCreditPdu(pLsapCb);
        }
    }  
    REFDEL(&pLsapCb->RefCnt, ' DNI');       
}
/*****************************************************************************
*
*   @func   UINT | LmPduAccessModeReq | process access mode request 
*                                           from peer
*
*   @rdesc  SUCCESS
*
*   @parm   int | LocalLsapSel | Local LSAP selector
*   @parm   int | LocalLsapSel | Local LSAP selector
*   @parm   BYTE * | pRsvdByte | Reserved byte in the Access mode PDU
*   @parm   BYTE * | pMode | Mode byte in Access mode PDU
*/
VOID
LmPduAccessModeReq(PIRLMP_LINK_CB pIrlmpCb,
                   int LocalLsapSel, int RemoteLsapSel, 
                   UCHAR *pRsvdByte, UCHAR *pMode)
{
    IRLMP_LSAP_CB   *pRequestedLsapCb = GetLsap(pIrlmpCb,
                                                 LocalLsapSel,RemoteLsapSel);
    IRLMP_LSAP_CB   *pLsapCb;
    IRDA_MSG        IMsg;
    
    if (pRequestedLsapCb==NULL || pRequestedLsapCb->State != LSAP_READY)
    {
        UnroutableSendLMDisc(pIrlmpCb, LocalLsapSel, RemoteLsapSel);
        return;
    }
    
    if (pRsvdByte == NULL || *pRsvdByte != 0x00 || pMode == NULL)
    {
        // LOG ERROR, indicate bad parm
        return;
    }
    
    switch (*pMode)
    {
      case IRLMP_EXCLUSIVE:
        if (pIrlmpCb->pExclLsapCb != NULL)
        {
            if (pIrlmpCb->pExclLsapCb == pRequestedLsapCb)
            {
                // Already has exclusive mode, confirm it again I guess
                // but I'm not telling my client again
                SendCntlPdu(pRequestedLsapCb, IRLMP_ACCESSMODE_PDU,
                            IRLMP_ABIT_CONFIRM, IRLMP_STATUS_SUCCESS,
                            IRLMP_EXCLUSIVE);
                return;
            }
            else
            {
                // This is what spec says...
                SendCntlPdu(pRequestedLsapCb, IRLMP_ACCESSMODE_PDU,
                            IRLMP_ABIT_CONFIRM, IRLMP_STATUS_FAILURE,
                            IRLMP_MULTIPLEXED);
                return;
            }
        }

        // Are there any other LSAPs connections? If so, NACK peer
        for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
             (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
             pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
        {
            if (pLsapCb->State != LSAP_DISCONNECTED && 
                pLsapCb != pRequestedLsapCb)
            {
                SendCntlPdu(pRequestedLsapCb, IRLMP_ACCESSMODE_PDU,
                            IRLMP_ABIT_CONFIRM, IRLMP_STATUS_FAILURE,
                            IRLMP_MULTIPLEXED);
                return;
            }
        }      
        // OK to go into exclusive mode
        pIrlmpCb->pExclLsapCb = pRequestedLsapCb;
        // Send confirmation to peer
        SendCntlPdu(pRequestedLsapCb, IRLMP_ACCESSMODE_PDU,
                    IRLMP_ABIT_CONFIRM, IRLMP_STATUS_SUCCESS,
                    IRLMP_EXCLUSIVE);
        // Notify client
        IMsg.Prim = IRLMP_ACCESSMODE_IND;
        IMsg.IRDA_MSG_AccessMode = IRLMP_EXCLUSIVE;
        TdiUp(pRequestedLsapCb->TdiContext, &IMsg);
        return;
        
      case IRLMP_MULTIPLEXED:
        if (pRequestedLsapCb != pIrlmpCb->pExclLsapCb)
        {
            // Log Error here
            return;
        }
        pIrlmpCb->pExclLsapCb = NULL;
        // Send confirmation to peer
        SendCntlPdu(pRequestedLsapCb, IRLMP_ACCESSMODE_PDU,
                    IRLMP_ABIT_CONFIRM, IRLMP_STATUS_SUCCESS,
                    IRLMP_MULTIPLEXED);
        // Notify client
        IMsg.Prim = IRLMP_ACCESSMODE_IND;
        IMsg.IRDA_MSG_AccessMode = IRLMP_MULTIPLEXED;
        TdiUp(pRequestedLsapCb->TdiContext, &IMsg);
        return;
        
      default:
        ASSERT(0);
    }
}
/*****************************************************************************
*
*   @func   UINT | LmPduAccessModeReq | process access mode request 
*                                           from peer
*
*   @rdesc  SUCCESS
*
*   @parm   int | LocalLsapSel | Local LSAP selector
*   @parm   int | LocalLsapSel | Local LSAP selector
*   @parm   BYTE * | pStatus | Status byte in the Access mode PDU
*   @parm   BYTE * | pMode | Mode byte in Access mode PDU
*/
VOID
LmPduAccessModeConf(PIRLMP_LINK_CB pIrlmpCb,
                    int LocalLsapSel, int RemoteLsapSel, 
                    UCHAR *pStatus, UCHAR *pMode)
{
    IRLMP_LSAP_CB   *pRequestedLsapCb = GetLsap(pIrlmpCb,
                                                 LocalLsapSel,RemoteLsapSel);
    IRDA_MSG        IMsg;

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: ACCESSMODE_CONF\r\n")));
    
    if (pRequestedLsapCb==NULL)
    {
        UnroutableSendLMDisc(pIrlmpCb, LocalLsapSel, RemoteLsapSel);
        return;
    }
    if (pStatus == NULL || pMode == NULL)
    {
        // LOG ERROR
        return;
    }
    
    switch (*pMode)
    {
      case IRLMP_EXCLUSIVE:
        if (pRequestedLsapCb != pIrlmpCb->pExclLsapCb || 
            pRequestedLsapCb->State != LSAP_EXCLUSIVEMODE_PEND)
        {
            // LOG ERROR
            return;
        }
        if (*pStatus != IRLMP_STATUS_SUCCESS)
        {
            pIrlmpCb->pExclLsapCb = NULL;
            return; // protocol error, 
                    // wouldn't have Exclusive mode != SUCCESS
        }
        else
        {
            pRequestedLsapCb->State = LSAP_READY;

            IMsg.Prim = IRLMP_ACCESSMODE_CONF;
            IMsg.IRDA_MSG_AccessMode = IRLMP_EXCLUSIVE;
            IMsg.IRDA_MSG_ModeStatus = IRLMP_ACCESSMODE_SUCCESS;

            TdiUp(pRequestedLsapCb->TdiContext, &IMsg);
            return;
        }
        
      case IRLMP_MULTIPLEXED:
        if (pRequestedLsapCb != pIrlmpCb->pExclLsapCb || 
            (pRequestedLsapCb->State != LSAP_EXCLUSIVEMODE_PEND &&
             pRequestedLsapCb->State != LSAP_MULTIPLEXEDMODE_PEND))
        {
            return;
        }

        pIrlmpCb->pExclLsapCb = NULL;
        pRequestedLsapCb->State = LSAP_READY;
            
        IMsg.Prim = IRLMP_ACCESSMODE_CONF;
        IMsg.IRDA_MSG_AccessMode = *pMode;
        if (*pStatus == IRLMP_STATUS_SUCCESS)
        {
            IMsg.IRDA_MSG_ModeStatus = IRLMP_ACCESSMODE_SUCCESS;
        }
        else
        {
            IMsg.IRDA_MSG_ModeStatus = IRLMP_ACCESSMODE_FAILURE;
        }            
        TdiUp(pRequestedLsapCb->TdiContext, &IMsg);
        return;
        
      default:
        ASSERT(0);
    }
}
/*****************************************************************************
*
*   @func   UINT | UnroutableSendLMDisc | Sends an LM-Disconnect to peer with
*                                         reason = "received LM packet on 
*                                         disconnected LSAP"
*   @parm   int | LocalLsapSel | the local LSAP selector in LM-PDU
*   @parm   int | RemoteLsapSel | the remote LSAP selector in LM-PDU
*/
VOID
UnroutableSendLMDisc(PIRLMP_LINK_CB pIrlmpCb, int LocalLsapSel, int RemoteLsapSel)
{
    IRLMP_LSAP_CB   FakeLsapCb;
    
    DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: received unroutabled Pdu LocalLsap:%d RemoteLsap:%d\n"),
                        LocalLsapSel, RemoteLsapSel));
    FakeLsapCb.Flags            = 0;
    FakeLsapCb.LocalLsapSel     = LocalLsapSel;
    FakeLsapCb.RemoteLsapSel    = RemoteLsapSel;
    FakeLsapCb.UserDataLen      = 0;
    FakeLsapCb.pIrlmpCb         = pIrlmpCb;
#ifdef DBG    
    FakeLsapCb.Sig              = LSAPSIG;
#endif    
        
    SendCntlPdu(&FakeLsapCb,IRLMP_DISCONNECT_PDU,
                IRLMP_ABIT_REQUEST, IRLMP_DISC_LSAP, 0);
    return;
}

/*****************************************************************************
*
*   @func   UINT | InitiateDiscovoryReq | A deferred processing routine that sends
*                                    an IRLAP discovery request
*/
void
InitiateDiscoveryReq(PVOID Context)
{
    IRDA_MSG        IMsg;
    UINT            rc;
    PIRLMP_LINK_CB  pIrlmpCb = NULL;
    PIRLMP_LINK_CB  pIrlmpCb2 = NULL;
    PIRDA_LINK_CB   pIrdaLinkCb;
    KIRQL           OldIrql;
    BOOLEAN         ScheduleNextLink = TRUE;
    BOOLEAN         MediaSense = TRUE;

    KeAcquireSpinLock(&gSpinLock, &OldIrql);

    DEBUGMSG(DBG_DISCOVERY, (TEXT("IRLMP: InitDscvReq event\n")));
    
    // Find the next link to start discovery on
    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
        (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
         pIrdaLinkCb = (PIRDA_LINK_CB) pIrdaLinkCb->Linkage.Flink)    
    {
        pIrlmpCb2 = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;

        if (pIrlmpCb2->DiscoveryFlags)
        {
            if (pIrlmpCb2->DiscoveryFlags == DF_NO_SENSE_DSCV)
            {
                MediaSense = FALSE;
            }
            pIrlmpCb2->DiscoveryFlags = 0;
            pIrlmpCb = pIrlmpCb2;
            break;
        }
    }

    // No more links on which to discover, send confirm up
    if (pIrlmpCb == NULL)
    {        
        if (pIrlmpCb2 == NULL)
        {
            IMsg.IRDA_MSG_DscvStatus = IRLMP_NO_RESPONSE;        
        }
        else
        {
            IMsg.IRDA_MSG_DscvStatus = IRLAP_DISCOVERY_COMPLETED;        
        }
            
        DscvReqScheduled = FALSE;
        
        IMsg.Prim = IRLMP_DISCOVERY_CONF;
        IMsg.IRDA_MSG_pDevList = &gDeviceList;

        // Hold the spin lock to protect list while TDI is copying it.
        
        TdiUp(NULL, &IMsg);
        
        KeReleaseSpinLock(&gSpinLock, OldIrql);
                
        return;
    }
    
    // Add a reference so link won't be removed from underneath us here
    // (was happening coming out of hibernation)
    
    REFADD(&pIrlmpCb->pIrdaLinkCb->RefCnt, 'VCSD');

    KeReleaseSpinLock(&gSpinLock, OldIrql);    

    LOCK_LINK(pIrlmpCb->pIrdaLinkCb);    

    if (pIrlmpCb->LinkState == LINK_DISCONNECTED &&
        !pIrlmpCb->ConnReqScheduled)
    {
        IMsg.Prim = IRLAP_DISCOVERY_REQ;
        IMsg.IRDA_MSG_SenseMedia = MediaSense;

        DEBUGMSG(DBG_DISCOVERY,
                 (TEXT
                  ("IRLMP: Sent IRLAP_DISCOVERY_REQ, New LinkState=LINK_IN_DISCOVERY\n")));
        
        if ((rc = IrlapDown(pIrlmpCb->pIrdaLinkCb->IrlapContext, &IMsg)) != SUCCESS)
        {
            if (rc != IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR &&
                rc != IRLAP_REMOTE_CONNECTION_IN_PROGRESS_ERR)
            {
                ASSERT(0);
            }
            else
            {                
                DEBUGMSG(DBG_DISCOVERY, (TEXT("IRLAP_DISCOVERY_REQ failed, link busy\n")));
            }
        }
        else
        {
            pIrlmpCb->LinkState = LINK_IN_DISCOVERY;
            // The next link will be schedule to run discovery when
            // the DISCOVERY_CONF for this link is received
            ScheduleNextLink = FALSE;
        }
    }
    
    UNLOCK_LINK(pIrlmpCb->pIrdaLinkCb);

    REFDEL(&pIrlmpCb->pIrdaLinkCb->RefCnt, 'VCSD');

    // Discovery failed on this link or it was not in the disconnected
    // state, schedule the next one

    if (ScheduleNextLink)
    {
        IrdaEventSchedule(&EvDiscoveryReq, NULL);
    }
}

VOID
ScheduleConnectReq(PIRLMP_LINK_CB pIrlmpCb)
{
    IRLMP_LSAP_CB   *pLsapCb;
    
    // Schedule the ConnectReq event if not already scheduled and if an LSAP
    // has a connect pending
    if (pIrlmpCb->ConnReqScheduled == FALSE)
    {       
        for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
             (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
             pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
        {
            VALIDLSAP(pLsapCb);
            
            if (pLsapCb->State == LSAP_CONN_REQ_PEND)
            {
                IrdaEventSchedule(&EvConnectReq, pIrlmpCb->pIrdaLinkCb);

                pIrlmpCb->ConnReqScheduled = TRUE;
                return;
            }
        }
    }
}

/*****************************************************************************
*
*   @func   UINT | InitiateConnectReq | A deferred processing routine that sends
*                                   IRLAP a connect request
*   This is scheduled after an IRLMP discovery confirm or a disconnect 
*   indication has been received via IRLMP_Up(). This allows the possible
*   IRLAP connect request to be made in a different context.
*/
void
InitiateConnectReq(PVOID Context)
{
    IRLMP_LSAP_CB   *pLsapCb;
    BOOLEAN         ConnectIrlap = FALSE;
    IRDA_MSG        IMsg;
    UINT            rc;
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;

    PAGED_CODE();
    
    LOCK_LINK(pIrdaLinkCb);
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: InitiateConnectReq()!\n")));

    pIrlmpCb->ConnReqScheduled = FALSE;

    if (pIrlmpCb->LinkState != LINK_DISCONNECTED &&
        pIrlmpCb->LinkState != LINK_CONNECTING)
    {
        UNLOCK_LINK(pIrdaLinkCb);           
        ASSERT(0);
        return;
    }

    // Check for LSAP in the connect request pending state.
    // If one or more exists, place them in IRLAP connect pending state
    // and initiate an IRLAP connection
    for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
        (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
        pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
    {
        VALIDLSAP(pLsapCb);
        
        if (pLsapCb->State == LSAP_CONN_REQ_PEND)
        {
            pLsapCb->State = LSAP_IRLAP_CONN_PEND;
            ConnectIrlap = TRUE;
        }
    }

    if (ConnectIrlap && pIrlmpCb->LinkState == LINK_DISCONNECTED)
    {
        DEBUGMSG(DBG_IRLMP, 
           (TEXT("IRLMP: IRLAP_CONNECT_REQ, State=LINK CONNECTING\r\n")));
        
        pIrlmpCb->LinkState = LINK_CONNECTING;

        pIrlmpCb->ConnDevAddrSet = FALSE; // This was previously set by
                                          // the LSAP which set the remote
                                          // device address. This is the
                                          // first opportunity to clear
                                          // the flag

        // Get the connection address out of the IRLMP control block
        RtlCopyMemory(IMsg.IRDA_MSG_RemoteDevAddr, pIrlmpCb->ConnDevAddr,
               IRDA_DEV_ADDR_LEN);
        IMsg.Prim = IRLAP_CONNECT_REQ;
        if ((rc = IrlapDown(pIrlmpCb->pIrdaLinkCb->IrlapContext, &IMsg))
            != SUCCESS)
        {
            DEBUGMSG(DBG_IRLMP, 
             (TEXT("IRLMP: IRLAP_CONNECT_REQ failed, State=LINK_DISCONNECTED\r\n")));

            pIrlmpCb->LinkState = LINK_DISCONNECTED;

            ASSERT(rc == IRLAP_REMOTE_DISCOVERY_IN_PROGRESS_ERR);

            TearDownConnections(pIrlmpCb, IRLMP_IRLAP_REMOTE_DISCOVERY_IN_PROGRESS);
        }
    }

    UNLOCK_LINK(pIrdaLinkCb);
    
    return;
}

void
InitiateConnectResp(PVOID Context)
{
    IRDA_MSG    IMsg;
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
    
    PAGED_CODE();    
    
    LOCK_LINK(pIrdaLinkCb);
    
    ASSERT(pIrlmpCb->LinkState == LINK_CONNECTING);
    
    if (pIrlmpCb->AcceptConnection)
    {
        IMsg.Prim = IRLAP_CONNECT_RESP;

        IrlapDown(pIrdaLinkCb->IrlapContext, &IMsg);

        pIrlmpCb->LinkState = LINK_READY;
        
        // Disconnect the link if no LSAP connection after a bit
        IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);                
        
        IrdaEventSchedule(&EvLmConnectReq, pIrlmpCb->pIrdaLinkCb);
        
    }
    else
    {
        pIrlmpCb->LinkState = LINK_DISCONNECTED;
        IMsg.Prim = IRLAP_DISCONNECT_REQ;
        IrlapDown(pIrdaLinkCb->IrlapContext, &IMsg);        
    }
    
    UNLOCK_LINK(pIrdaLinkCb);    

    return;
}

void
InitiateLMConnectReq(PVOID Context)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
    IRLMP_LSAP_CB   *pLsapCb;
    
    LOCK_LINK(pIrdaLinkCb);

    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: InitiateLMConnectReq()!\n")));    

    // Send the connect request PDU to peer LSAPs
    while ((pLsapCb = GetLsapInState(pIrlmpCb, LINK_READY,
                                      LSAP_IRLAP_CONN_PEND, TRUE)) != NULL)
    {
        pLsapCb->State = LSAP_LMCONN_CONF_PEND;

        // Ask remote LSAP for a connection
        SendCntlPdu(pLsapCb, IRLMP_CONNECT_PDU, IRLMP_ABIT_REQUEST,
                    IRLMP_RSVD_PARM, 0);
        
        IrdaTimerRestart(&pLsapCb->ResponseTimer);
    }
    
    UNLOCK_LINK(pIrdaLinkCb);
}

void
InitiateCloseLink(PVOID Context)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
    IRDA_MSG        IMsg;
    LARGE_INTEGER   SleepMs;    
    PIRLMP_LSAP_CB  pLsapCb;
    
    PAGED_CODE();
        
//    //Sleep(500); // This sleep allows time for LAP to send any 
                // LM_DISCONNECT_REQ's that may be sitting on its TxQue.                
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: InitiateCloseLink()!\n")));    
    
    LOCK_LINK(pIrdaLinkCb);    

    // Stop link timer
    IrdaTimerStop(&pIrlmpCb->DiscDelayTimer);

    // Bring down the link...
    IMsg.Prim = IRLAP_DISCONNECT_REQ;
    IrlapDown(pIrdaLinkCb->IrlapContext, &IMsg);

    UNLOCK_LINK(pIrdaLinkCb);    
    
    // Allow LAP time to disconnect link
    SleepMs.QuadPart = -(10*1000*1000);

    KeDelayExecutionThread(KernelMode, FALSE, &SleepMs);

    LOCK_LINK(pIrlmpCb->pIrdaLinkCb);    
    
    IrlapCloseLink(pIrdaLinkCb);
   
    TearDownConnections(pIrlmpCb, IRLMP_UNSPECIFIED_DISC);
    
    // Delete the ias entry if it exists
    for (pLsapCb = (IRLMP_LSAP_CB *) pIrlmpCb->LsapCbList.Flink;
         (LIST_ENTRY *) pLsapCb != &pIrlmpCb->LsapCbList;
         pLsapCb = (IRLMP_LSAP_CB *) pLsapCb->Linkage.Flink)
    {
        if (pLsapCb->RemoteLsapSel == IAS_LSAP_SEL)
        {
            pLsapCb->RemoteLsapSel = 1; // DeleteLsap ignore IAS_LSAP_SEL
            
            DeleteLsap(pLsapCb);
            
            break;
        }
    }
        
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP Shutdown\n")));

    UNLOCK_LINK(pIrdaLinkCb);
    
    return;
}

// IAS

// Oh my God! I'm out of time, no more function hdrs

int StringLen(char *p)
{
    int i = 0;
    
    while (*p++ != 0)
    {
        i++;
    }
    
    return i;
}

int StringCmp(char *p1, char *p2)
{
    while (1)
    {
        if (*p1 != *p2)
            break;
        
        if (*p1 == 0)
            return 0;
        p1++, p2++;
    }
    return 1;
}   


UINT
IrlmpGetValueByClassReq(IRDA_MSG *pReqMsg)
{
    UINT            rc = SUCCESS;
    PIRLMP_LINK_CB  pIrlmpCb = GetIrlmpCb(pReqMsg->IRDA_MSG_pIasQuery->irdaDeviceID);
    IRDA_MSG        IMsg;
    
    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: IRLMP_GETVALUEBYCLASS_REQ\n")));
    
    PAGED_CODE();    

    if (pIrlmpCb == NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Null IrlmpCb\n")));
        return IRLMP_BAD_DEV_ADDR;;
    }

    LOCK_LINK(pIrlmpCb->pIrdaLinkCb);
    
    if (pIrlmpCb->pIasQuery != NULL)
    {
        DEBUGMSG(DBG_ERROR, 
                 (TEXT("IRLMP: ERROR query already in progress\n")));
        rc = IRLMP_IAS_QUERY_IN_PROGRESS;
        
        UNLOCK_LINK(pIrlmpCb->pIrdaLinkCb);            
    }
    else
    {
        // Save the pointer to the query in the control block
        // and then request a connection to the remote IAS LSAP

        // Save it
        pIrlmpCb->pIasQuery             = pReqMsg->IRDA_MSG_pIasQuery;
        pIrlmpCb->AttribLen             = pReqMsg->IRDA_MSG_AttribLen;
        pIrlmpCb->AttribLenWritten      = 0;
        pIrlmpCb->FirstIasRespReceived  = FALSE;
        pIrlmpCb->IasRetryCnt           = 0;
        
        UNLOCK_LINK(pIrlmpCb->pIrdaLinkCb);

        // request connection
        IMsg.Prim                      = IRLMP_CONNECT_REQ;
        IMsg.IRDA_MSG_RemoteLsapSel    = IAS_LSAP_SEL;
        IMsg.IRDA_MSG_LocalLsapSel     = IAS_LOCAL_LSAP_SEL;
        IMsg.IRDA_MSG_pQos             = NULL;
        IMsg.IRDA_MSG_pConnData        = NULL;
        IMsg.IRDA_MSG_ConnDataLen      = 0;
        IMsg.IRDA_MSG_UseTtp           = FALSE;
        IMsg.IRDA_MSG_pContext         = NULL;

        RtlCopyMemory(pIrlmpCb->IasQueryDevAddr, 
                      pReqMsg->IRDA_MSG_pIasQuery->irdaDeviceID,
                      IRDA_DEV_ADDR_LEN);
        
        RtlCopyMemory(IMsg.IRDA_MSG_RemoteDevAddr,
                      pReqMsg->IRDA_MSG_pIasQuery->irdaDeviceID,
                      IRDA_DEV_ADDR_LEN);
    
        if ((rc = IrlmpConnectReq(&IMsg)) != SUCCESS)
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Retry IasQuery at start\n")));
            
            IrdaEventSchedule(&EvRetryIasQuery, 
                              pIrlmpCb->pIrdaLinkCb);
            rc = SUCCESS;
        }
    }

    return rc;
}

VOID
SendGetValueByClassReq(IRLMP_LSAP_CB *pLsapCb)
{
    IRDA_MSG            *pMsg;
    IAS_CONTROL_FIELD   *pControl;
    int                 ClassNameLen;
    int                 AttribNameLen;
    PIRLMP_LINK_CB      pIrlmpCb = (PIRLMP_LINK_CB) pLsapCb->pIrlmpCb;
    
    PAGED_CODE();    

    if (pIrlmpCb->pIasQuery == NULL)
    {
        return;
    }

    ClassNameLen = StringLen(pIrlmpCb->pIasQuery->irdaClassName);
    AttribNameLen = StringLen(pIrlmpCb->pIasQuery->irdaAttribName);
    
    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: Send GetValueByClassReq(%hs,%hs)\n"),
            pIrlmpCb->pIasQuery->irdaClassName, pIrlmpCb->pIasQuery->irdaAttribName));

    // Alloc a message for data request that will contain the query
    if ((pMsg = AllocIrdaBuf(IrdaMsgPool)) == NULL)
    {
        ASSERT(0);
        return;
    }

    pMsg->IRDA_MSG_pHdrRead = 
    pMsg->IRDA_MSG_pHdrWrite = pMsg->IRDA_MSG_Header + IRDA_HEADER_LEN;
    
    pMsg->IRDA_MSG_pRead  = \
    pMsg->IRDA_MSG_pWrite = \
    pMsg->IRDA_MSG_pBase  = pMsg->IRDA_MSG_pHdrWrite;
    pMsg->IRDA_MSG_pLimit = pMsg->IRDA_MSG_pBase +
        IRDA_MSG_DATA_SIZE_INTERNAL - sizeof(IRDA_MSG) - 1;    

    // Build the query and then send it in a LAP data req

    pControl = (IAS_CONTROL_FIELD *) pMsg->IRDA_MSG_pRead;

    pControl->Last   = TRUE;
    pControl->Ack    = FALSE;
    pControl->OpCode = IAS_OPCODE_GET_VALUE_BY_CLASS;
    
    *(pMsg->IRDA_MSG_pRead + 1) = (UCHAR) ClassNameLen;
    RtlCopyMemory(pMsg->IRDA_MSG_pRead + 2,
           pIrlmpCb->pIasQuery->irdaClassName, 
           ClassNameLen);
    *(pMsg->IRDA_MSG_pRead + ClassNameLen + 2) = (UCHAR) AttribNameLen;
    RtlCopyMemory(pMsg->IRDA_MSG_pRead + ClassNameLen + 3,
           pIrlmpCb->pIasQuery->irdaAttribName,
           AttribNameLen);

    pMsg->IRDA_MSG_pWrite = pMsg->IRDA_MSG_pRead + ClassNameLen + AttribNameLen + 3;

    pMsg->IRDA_MSG_IrCOMM_9Wire = FALSE;
    
    FormatAndSendDataReq(pLsapCb, pMsg, TRUE, TRUE);
}

VOID
IasConnectReq(PIRLMP_LINK_CB pIrlmpCb, int RemoteLsapSel)
{
    IRLMP_LSAP_CB           *pLsapCb = GetLsap(pIrlmpCb,
                                               IAS_LSAP_SEL, RemoteLsapSel);

    PAGED_CODE();
    
    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: Received IAS connect request\n")));
    
    if (pLsapCb == NULL)
    {
        if (CreateLsap(pIrlmpCb, &pLsapCb) != SUCCESS)
            return;
        
        pLsapCb->State          = LSAP_READY;
        pLsapCb->LocalLsapSel   = IAS_LSAP_SEL;
        pLsapCb->RemoteLsapSel  = RemoteLsapSel;
    }
    
    SendCntlPdu(pLsapCb, IRLMP_CONNECT_PDU, IRLMP_ABIT_CONFIRM,
                IRLMP_RSVD_PARM, 0);
}

VOID
IasServerDisconnectReq(IRLMP_LSAP_CB *pLsapCb)
{
    PAGED_CODE();
    
    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: Received disconnect request IAS\n")));
    
    DeleteLsap(pLsapCb);
    
    return;
}

VOID
IasClientDisconnectReq(IRLMP_LSAP_CB *pLsapCb, IRLMP_DISC_REASON DiscReason)
{
    IRDA_MSG        IMsg;
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pLsapCb->pIrlmpCb;
    
    PAGED_CODE();    

    DeleteLsap(pLsapCb);    
    
    if (pIrlmpCb->pIasQuery != NULL)
    {
        if (DiscReason != IRLMP_UNSPECIFIED_DISC)
        {
            DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Retry IasQuery as timeout\n")));
            
            IrdaEventSchedule(&EvRetryIasQuery, 
                              pIrlmpCb->pIrdaLinkCb);
        }
        else
        {
            pIrlmpCb->pIasQuery = NULL; 

            // Disconnect link
            IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);
        
            IMsg.Prim = IRLMP_GETVALUEBYCLASS_CONF;
            IMsg.IRDA_MSG_IASStatus = DiscReason;
    
            TdiUp(NULL, &IMsg);
        }    
    }
}

VOID
IasSendQueryResp(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    IAS_CONTROL_FIELD   *pCntl = (IAS_CONTROL_FIELD *) pMsg->IRDA_MSG_pRead++;
    
    PAGED_CODE();    

    if (pCntl->OpCode != IAS_OPCODE_GET_VALUE_BY_CLASS)
    {
        return;// IRLMP_UNSUPPORTED_IAS_OPERATION;
    }

    SendGetValueByClassResp(pLsapCb, pMsg);
}

VOID
IasProcessQueryResp(PIRLMP_LINK_CB pIrlmpCb,
                    IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pMsg)
{
    IAS_CONTROL_FIELD   *pCntl      = (IAS_CONTROL_FIELD *) pMsg->IRDA_MSG_pRead++;
    UCHAR                ReturnCode;
    int                 ObjID;
    
    PAGED_CODE();    

    if (pIrlmpCb->pIasQuery == NULL)
    {
        return;
        // return IRLMP_UNSOLICITED_IAS_RESPONSE;
    }

    if (pIrlmpCb->FirstIasRespReceived == FALSE)
    {
        pIrlmpCb->FirstIasRespReceived = TRUE;

        ReturnCode = *pMsg->IRDA_MSG_pRead++;

        if (ReturnCode != IAS_SUCCESS)
        {
            if (ReturnCode == IAS_NO_SUCH_OBJECT)
            {
                pMsg->IRDA_MSG_IASStatus = IRLMP_IAS_NO_SUCH_OBJECT;
            }
            else
            {
                pMsg->IRDA_MSG_IASStatus = IRLMP_IAS_NO_SUCH_ATTRIB;
            }

            // Disconnect LSAP
            SendCntlPdu(pLsapCb,IRLMP_DISCONNECT_PDU,IRLMP_ABIT_REQUEST,
                        IRLMP_USER_REQUEST, 0);

            DeleteLsap(pLsapCb);

            // Disconnect link
            IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);
            
            pMsg->Prim = IRLMP_GETVALUEBYCLASS_CONF;
            pMsg->IRDA_MSG_pIasQuery = pIrlmpCb->pIasQuery;
            pIrlmpCb->pIasQuery = NULL;

            TdiUp(NULL, pMsg);
            return;
        }

        pIrlmpCb->QueryListLen =  ((int)(*pMsg->IRDA_MSG_pRead++)) << 8;
        pIrlmpCb->QueryListLen += (int) *pMsg->IRDA_MSG_pRead++;        

        // What I am going to do with this?
        ObjID = ((int)(*pMsg->IRDA_MSG_pRead++)) << 8;
        ObjID += (int) *pMsg->IRDA_MSG_pRead++;

        pIrlmpCb->pIasQuery->irdaAttribType = (int) *pMsg->IRDA_MSG_pRead++;
    
        switch (pIrlmpCb->pIasQuery->irdaAttribType)
        {
          case IAS_ATTRIB_VAL_MISSING:
            break;
            
          case IAS_ATTRIB_VAL_INTEGER:
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribInt = 0;
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribInt += 
                ((int) (*pMsg->IRDA_MSG_pRead++) << 24) & 0xFF000000;
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribInt += 
                ((int) (*pMsg->IRDA_MSG_pRead++) << 16) & 0xFF0000;
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribInt += 
                ((int) (*pMsg->IRDA_MSG_pRead++) << 8) & 0xFF00;
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribInt += 
                (int) (*pMsg->IRDA_MSG_pRead++) & 0xFF;
            break;
        
          case IAS_ATTRIB_VAL_BINARY:
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribOctetSeq.Len = 0;
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribOctetSeq.Len += 
                         ((int )(*pMsg->IRDA_MSG_pRead++) << 8) & 0xFF00;
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribOctetSeq.Len += 
                         ((int) *pMsg->IRDA_MSG_pRead++) & 0xFF;        
            break;
            

          case IAS_ATTRIB_VAL_STRING:
            // char set
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribUsrStr.CharSet =
                *pMsg->IRDA_MSG_pRead++;                   
            
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribUsrStr.Len =
                (int) *pMsg->IRDA_MSG_pRead++;
            break;
            
        }

    }
    
    switch (pIrlmpCb->pIasQuery->irdaAttribType)
    {
      case IAS_ATTRIB_VAL_BINARY:    
        while (pMsg->IRDA_MSG_pRead < pMsg->IRDA_MSG_pWrite &&
               pIrlmpCb->AttribLenWritten < pIrlmpCb->AttribLen &&
               pIrlmpCb->AttribLenWritten < pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribOctetSeq.Len)
        {   
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribOctetSeq.OctetSeq[pIrlmpCb->AttribLenWritten++] = *pMsg->IRDA_MSG_pRead++;
        }
        
        break;
        
      case IAS_ATTRIB_VAL_STRING:
        while (pMsg->IRDA_MSG_pRead < pMsg->IRDA_MSG_pWrite &&
               pIrlmpCb->AttribLenWritten < pIrlmpCb->AttribLen &&
               pIrlmpCb->AttribLenWritten < pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribUsrStr.Len)
        {
            pIrlmpCb->pIasQuery->irdaAttribute.irdaAttribUsrStr.UsrStr[pIrlmpCb->AttribLenWritten++] = *pMsg->IRDA_MSG_pRead++;
        }
    }
    
    if (pCntl->Last == TRUE)
    {
        pMsg->IRDA_MSG_pIasQuery = pIrlmpCb->pIasQuery;
        
        // Done with query
        pIrlmpCb->pIasQuery = NULL;

        // Disconnect LSAP
        SendCntlPdu(pLsapCb,IRLMP_DISCONNECT_PDU,IRLMP_ABIT_REQUEST,
                    IRLMP_USER_REQUEST, 0);

        DeleteLsap(pLsapCb);

        // Disconnect link
        IrdaTimerRestart(&pIrlmpCb->DiscDelayTimer);        

        pMsg->Prim = IRLMP_GETVALUEBYCLASS_CONF;

        if (pIrlmpCb->QueryListLen > 1)
        {
            pMsg->IRDA_MSG_IASStatus = IRLMP_IAS_SUCCESS_LISTLEN_GREATER_THAN_ONE;
        }
        else
        {
            pMsg->IRDA_MSG_IASStatus = IRLMP_IAS_SUCCESS;
        }
    
        TdiUp(NULL, pMsg);
        return;
    }
}

UINT
NewQueryMsg(PIRLMP_LINK_CB pIrlmpCb, LIST_ENTRY *pList, IRDA_MSG **ppMsg)
{
    IRDA_MSG *pMsg;
    
    if ((*ppMsg = AllocIrdaBuf(IrdaMsgPool)) == NULL)
    {
        pMsg = (IRDA_MSG *) RemoveHeadList(pList);
        
        while (pMsg != (IRDA_MSG *) pList)
        {
            FreeIrdaBuf(IrdaMsgPool, pMsg);
            pMsg = (IRDA_MSG *) RemoveHeadList(pList);            
        }
        return IRLMP_ALLOC_FAILED;
    }
    (*ppMsg)->IRDA_MSG_pHdrRead  = \
    (*ppMsg)->IRDA_MSG_pHdrWrite = (*ppMsg)->IRDA_MSG_Header+IRDA_HEADER_LEN;
        
    (*ppMsg)->IRDA_MSG_pRead  = \
    (*ppMsg)->IRDA_MSG_pWrite = \
    (*ppMsg)->IRDA_MSG_pBase  = (*ppMsg)->IRDA_MSG_pHdrWrite;
    (*ppMsg)->IRDA_MSG_pLimit = (*ppMsg)->IRDA_MSG_pBase +
        IRDA_MSG_DATA_SIZE_INTERNAL - sizeof(IRDA_MSG) - 1;
    
    InsertTailList(pList, &( (*ppMsg)->Linkage) );    

    // reserve space for the IAS control field.
    (*ppMsg)->IRDA_MSG_pWrite += sizeof(IAS_CONTROL_FIELD);   

    return SUCCESS;
}

VOID
SendGetValueByClassResp(IRLMP_LSAP_CB *pLsapCb, IRDA_MSG *pReqMsg)
{  
    int                 ClassNameLen, AttribNameLen;
    CHAR                *pClassName, *pAttribName;
    IRDA_MSG            *pQMsg, *pNextMsg;
    IAS_OBJECT          *pObject;
    IAS_ATTRIBUTE       *pAttrib;
    LIST_ENTRY          QueryList;
    IAS_CONTROL_FIELD   *pControl;
    UCHAR               *pReturnCode;
    UCHAR               *pListLen;
    UCHAR               *pBPtr;
    int                 ListLen = 0;
    BOOLEAN             ObjectFound = FALSE;
    BOOLEAN             AttribFound = FALSE;
    int                 i;
#if DBG
    char                ClassStr[128];
    char                AttribStr[128];
#endif        
    
    PAGED_CODE();
        
    DEBUGMSG(DBG_IRLMP, 
             (TEXT("IRLMP: Remote GetValueByClass query received\n")));

    ClassNameLen = (int) *pReqMsg->IRDA_MSG_pRead;
    pClassName = (CHAR *) (pReqMsg->IRDA_MSG_pRead + 1);

    AttribNameLen =  (int) *(pClassName + ClassNameLen);
    pAttribName = pClassName + ClassNameLen + 1;
    
#if DBG
    RtlCopyMemory(ClassStr, pClassName, ClassNameLen);
    ClassStr[ClassNameLen] = 0;
    RtlCopyMemory(AttribStr, pAttribName, AttribNameLen);
    AttribStr[AttribNameLen] = 0;
#endif    

    if (pReqMsg->IRDA_MSG_pWrite != (UCHAR *) (pAttribName + AttribNameLen))
    {
        // The end of the message didn't point to where the end of
        // the parameters.
        
        // LOG ERROR.
        //return IRLMP_BAD_IAS_QUERY_FROM_REMOTE;
        return;
    }

    // The query may require multiple frames to transmit, build a list
    InitializeListHead(&QueryList);

    // Create the first message
    if (NewQueryMsg(pLsapCb->pIrlmpCb, &QueryList, &pQMsg) != SUCCESS)
    {
        ASSERT(0);
        return;
    }

    pReturnCode = pQMsg->IRDA_MSG_pWrite++;
    pListLen = pQMsg->IRDA_MSG_pWrite++;
    pQMsg->IRDA_MSG_pWrite++; // list len get 2 bytes
    
    for (pObject = (IAS_OBJECT *) IasObjects.Flink;
         (LIST_ENTRY *) pObject != &IasObjects;
         pObject = (IAS_OBJECT *) pObject->Linkage.Flink)    
    {
        DEBUGMSG(DBG_IRLMP_IAS, (TEXT("  compare object %hs with %hs\n"),
                        ClassStr, pObject->pClassName));
                        
        if (ClassNameLen == StringLen(pObject->pClassName) &&
            CTEMemCmp(pClassName, pObject->pClassName, (ULONG) ClassNameLen) == 0)
        {
            DEBUGMSG(DBG_IRLMP_IAS, (TEXT("  Object found\n")));
        
            ObjectFound = TRUE;

            pAttrib = pObject->pAttributes;
            while (pAttrib != NULL)
            {
                DEBUGMSG(DBG_IRLMP_IAS, (TEXT("  compare attrib %hs with %hs\n"),
                        pAttrib->pAttribName, AttribStr));
                        
                if (AttribNameLen == StringLen(pAttrib->pAttribName) &&
                    CTEMemCmp(pAttrib->pAttribName, pAttribName, (ULONG) AttribNameLen) == 0)
                {
                    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("  Attrib found\n")));
                
                    AttribFound = TRUE;

                    ListLen++;
                    
                    if (pQMsg->IRDA_MSG_pWrite + 1 > pQMsg->IRDA_MSG_pLimit)
                    {
                        // I need 2 bytes for object ID, don't want to
                        // split 16 bit field up 
                        if (NewQueryMsg(pLsapCb->pIrlmpCb, &QueryList,
                                        &pQMsg) != SUCCESS)
                        {
                            ASSERT(0);
                            return;
                        }
                    }
                    
                    *pQMsg->IRDA_MSG_pWrite++ = 
                        (UCHAR) (((pObject->ObjectId) & 0xFF00) >> 8);
                    *pQMsg->IRDA_MSG_pWrite++ = 
                        (UCHAR) ((pObject->ObjectId) & 0xFF);
                    
                    if (pQMsg->IRDA_MSG_pWrite > pQMsg->IRDA_MSG_pLimit)
                    {
                        if (NewQueryMsg(pLsapCb->pIrlmpCb, &QueryList,
                                        &pQMsg) != SUCCESS)
                        {
                            ASSERT(0);
                            return;
                        }                        
                    }
                    
                    switch (pAttrib->AttribValType)
                    {
                      case IAS_ATTRIB_VAL_INTEGER:
                        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: integer query %d\n"),
                                              *((int *) pAttrib->pAttribVal)));
                        
                        if (pQMsg->IRDA_MSG_pWrite + 4 > pQMsg->IRDA_MSG_pLimit)
                        {
                            if (NewQueryMsg(pLsapCb->pIrlmpCb,
                                            &QueryList, &pQMsg) != SUCCESS)
                            {
                                ASSERT(0);
                                return;
                            }
                        }
                        *pQMsg->IRDA_MSG_pWrite++ = IAS_ATTRIB_VAL_INTEGER;
                        *pQMsg->IRDA_MSG_pWrite++ = (UCHAR)
                            ((*((int *) pAttrib->pAttribVal) & 0xFF000000) >> 24);
                        *pQMsg->IRDA_MSG_pWrite++ = (UCHAR)
                            ((*((int *) pAttrib->pAttribVal) & 0xFF0000) >> 16);
                        *pQMsg->IRDA_MSG_pWrite++ = (UCHAR)
                            ((*((int *) pAttrib->pAttribVal) & 0xFF00) >> 8);
                        *pQMsg->IRDA_MSG_pWrite++ = (UCHAR)
                            (*((int *) pAttrib->pAttribVal) & 0xFF); 
                        break;

                      case IAS_ATTRIB_VAL_BINARY:
                      case IAS_ATTRIB_VAL_STRING:
                        if (pQMsg->IRDA_MSG_pWrite + 2 > pQMsg->IRDA_MSG_pLimit)
                        {
                            if (NewQueryMsg(pLsapCb->pIrlmpCb,
                                            &QueryList, &pQMsg) != SUCCESS)
                            {
                                ASSERT(0);
                                return;
                            }
                        }
                        
                        *pQMsg->IRDA_MSG_pWrite++ = (UCHAR) pAttrib->AttribValType;

                        if (pAttrib->AttribValType == IAS_ATTRIB_VAL_BINARY)
                        {
                            *pQMsg->IRDA_MSG_pWrite++ = 
                                  (UCHAR) ((pAttrib->AttribValLen & 0xFF00) >> 8);
                            *pQMsg->IRDA_MSG_pWrite++ = 
                                  (UCHAR) (pAttrib->AttribValLen & 0xFF);;
                        }
                        else
                        {
                            *pQMsg->IRDA_MSG_pWrite++ = 
                                   (UCHAR) pAttrib->CharSet;
                            *pQMsg->IRDA_MSG_pWrite++ = 
                                  (UCHAR) pAttrib->AttribValLen;
                        }

                        pBPtr = (UCHAR *) pAttrib->pAttribVal;
                        
                        for (i=0; i < pAttrib->AttribValLen; i++)
                        {
                            if (pQMsg->IRDA_MSG_pWrite > pQMsg->IRDA_MSG_pLimit)
                            {
                                if (NewQueryMsg(pLsapCb->pIrlmpCb,
                                                &QueryList, &pQMsg) != SUCCESS)
                                {
                                    ASSERT(0);
                                    return;
                                }
                            }
                            *pQMsg->IRDA_MSG_pWrite++ = *pBPtr++;
                        }
                        break;
                    }

                    break; // Break out of loop, only look for single 
                           // attrib per object (??)
                }
                pAttrib = pAttrib->pNext;
            }             
        }                                                   
    }

    // Send the query
    if (!ObjectFound)
    {
        *pReturnCode = IAS_NO_SUCH_OBJECT;
    }
    else
    {
        if (!AttribFound)
        {
            *pReturnCode = IAS_NO_SUCH_ATTRIB;
        }
        else
        {
            *pReturnCode = IAS_SUCCESS;
            *pListLen++ =  (UCHAR) ((ListLen & 0xFF00) >> 8);
            *pListLen = (UCHAR) (ListLen & 0xFF);
        }
    }

    if (!IsListEmpty(&QueryList))
    {
        pQMsg = (IRDA_MSG *) RemoveHeadList(&QueryList);
    }
    else
    {
        pQMsg = NULL;
    }
    
    while (pQMsg)
    {
        if (!IsListEmpty(&QueryList))
        {
            pNextMsg = (IRDA_MSG *) RemoveHeadList(&QueryList);
        }
        else
        {
            pNextMsg = NULL;
        }

        // Build the control field
        pControl = (IAS_CONTROL_FIELD *) pQMsg->IRDA_MSG_pRead;
        pControl->OpCode = IAS_OPCODE_GET_VALUE_BY_CLASS;
        pControl->Ack = FALSE;
        if (pNextMsg == NULL)
        {
            pControl->Last = TRUE;
        }
        else
        {
            pControl->Last = FALSE;
        }

        pQMsg->IRDA_MSG_IrCOMM_9Wire = FALSE;               

        FormatAndSendDataReq(pLsapCb, pQMsg, TRUE, TRUE);

        pQMsg = pNextMsg;
    }
}

IAS_OBJECT *
IasGetObject(CHAR *pClassName)
{
    IAS_OBJECT  *pObject;
    
    for (pObject = (IAS_OBJECT *) IasObjects.Flink;
         (LIST_ENTRY *) pObject != &IasObjects;
         pObject = (IAS_OBJECT *) pObject->Linkage.Flink)    
    {
        if (StringCmp(pObject->pClassName, pClassName) == 0)
        {
            return pObject;
        }
    }
    return NULL;
}

UINT
IasAddAttribute(IAS_SET *pIASSet, PVOID *pAttribHandle)
{
    IAS_OBJECT      *pObject = NULL;
    IAS_ATTRIBUTE   *pAttrib = NULL;
    CHAR            *pClassName = NULL;
    CHAR            ClassNameLen;
    CHAR            *pAttribName = NULL;
    CHAR            AttribNameLen;
    int             AttribValLen;
    void            *pAttribVal = NULL;
    UINT            cAttribs = 0;    
    KIRQL           OldIrql;
    BOOLEAN         NewObject = FALSE;
    BOOLEAN         NewObjectOnList = FALSE;
    UINT            rc = SUCCESS;
    
    *pAttribHandle = NULL;
    
    KeAcquireSpinLock(&gSpinLock, &OldIrql);    

    if ((pObject = IasGetObject(pIASSet->irdaClassName)) == NULL)
    {
        if (IRDA_ALLOC_MEM(pObject, sizeof(IAS_OBJECT), MT_IRLMP_IAS_OBJECT)
            == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }
        
        NewObject = TRUE;

        ClassNameLen = StringLen(pIASSet->irdaClassName) + 1;
        
        if (IRDA_ALLOC_MEM(pClassName, ClassNameLen, MT_IRLMP_IAS_CLASSNAME)
            == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }

        RtlCopyMemory(pClassName, pIASSet->irdaClassName, ClassNameLen);
        
        pObject->pClassName     = pClassName;
        pObject->pAttributes    = NULL;    
        
        NewObjectOnList = TRUE;

        InsertTailList(&IasObjects, &pObject->Linkage);    
        
        pObject->ObjectId = NextObjectId++;
    }

    // Does the attribute already exist?
    for (pAttrib = pObject->pAttributes; pAttrib != NULL; 
         pAttrib = pAttrib->pNext)
    {
        if (StringCmp(pAttrib->pAttribName, pIASSet->irdaAttribName) == 0)
        {
            break;
        }
        cAttribs++;
    }
    
    if (pAttrib != NULL)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Attribute alreay exists\r\n")));
        pAttrib = NULL;        
        rc = IRLMP_IAS_ATTRIB_ALREADY_EXISTS;
        goto done;
    }
    else
    {       
        // Only allowed to add 256 attributes to an object.
        if (cAttribs >= 256)
        {
            rc = IRLMP_IAS_MAX_ATTRIBS_REACHED;
            goto done;
        }

        if (IRDA_ALLOC_MEM(pAttrib, sizeof(IAS_ATTRIBUTE), MT_IRLMP_IAS_ATTRIB)
             == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }

        AttribNameLen = StringLen(pIASSet->irdaAttribName) + 1;
        
        if (IRDA_ALLOC_MEM(pAttribName, AttribNameLen, MT_IRLMP_IAS_ATTRIBNAME)
            == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }

        RtlCopyMemory(pAttribName, pIASSet->irdaAttribName, AttribNameLen);
        
    }

    switch (pIASSet->irdaAttribType)
    {
      case IAS_ATTRIB_VAL_INTEGER:
        AttribValLen = sizeof(int);
        if (IRDA_ALLOC_MEM(pAttribVal, AttribValLen, MT_IRLMP_IAS_ATTRIBVAL)
            == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }

        *((int *) pAttribVal) = pIASSet->irdaAttribute.irdaAttribInt;
        break;
        
      case IAS_ATTRIB_VAL_BINARY:
        AttribValLen = pIASSet->irdaAttribute.irdaAttribOctetSeq.Len;
        if (IRDA_ALLOC_MEM(pAttribVal, AttribValLen, MT_IRLMP_IAS_ATTRIBVAL)
            == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }

        RtlCopyMemory(pAttribVal, pIASSet->irdaAttribute.irdaAttribOctetSeq.OctetSeq,
               AttribValLen);
        break;
        
      case IAS_ATTRIB_VAL_STRING:
        AttribValLen = pIASSet->irdaAttribute.irdaAttribUsrStr.Len;
        if (IRDA_ALLOC_MEM(pAttribVal, AttribValLen, MT_IRLMP_IAS_ATTRIBVAL)
            == NULL)
        {
            rc = IRLMP_ALLOC_FAILED;
            goto done;
        }

        RtlCopyMemory(pAttribVal, pIASSet->irdaAttribute.irdaAttribUsrStr.UsrStr, 
               AttribValLen);
        break;
        
      default:
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: IasAddAttribute, invalid type\n %d\n"),
                 pIASSet->irdaAttribType));
        rc = IRLMP_NO_SUCH_IAS_ATTRIBUTE;
        goto done;               
    }
    
    pAttrib->pAttribName        = pAttribName;
    pAttrib->pAttribVal         = pAttribVal;
    pAttrib->AttribValLen       = AttribValLen;
    pAttrib->AttribValType      = (UCHAR) pIASSet->irdaAttribType;
    pAttrib->CharSet            = pIASSet->irdaAttribute.irdaAttribUsrStr.CharSet;
    pAttrib->pNext              = pObject->pAttributes;
    
    pObject->pAttributes = pAttrib;

    *pAttribHandle = pAttrib;
    
done:    
    
    if (rc == SUCCESS)
    {
        DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: Added attrib(%x) %s to class %s\n"),
                pAttrib, pAttrib->pAttribName, pObject->pClassName));
        ;        
    }    
    else
    {
        DEBUGMSG(DBG_ERROR, (TEXT("IRLMP: Failed to add Ias attribute\n")));
        
        if (pObject && NewObjectOnList) RemoveEntryList(&pObject->Linkage);    
        if (pObject && NewObject) IRDA_FREE_MEM(pObject);
        if (pClassName) IRDA_FREE_MEM(pClassName);
        if (pAttrib) IRDA_FREE_MEM(pAttrib);
        if (pAttribName) IRDA_FREE_MEM(pAttribName);
        if (pAttribVal) IRDA_FREE_MEM(pAttribVal);
    }        

    KeReleaseSpinLock(&gSpinLock, OldIrql);
        
    return rc;
}

VOID
IasDelAttribute(PVOID AttribHandle)
{
    KIRQL           OldIrql;
    IAS_OBJECT      *pObject;
    IAS_ATTRIBUTE   *pAttrib, *pPrevAttrib;

    KeAcquireSpinLock(&gSpinLock, &OldIrql);

    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: Delete attribHandle %x\n"),
             AttribHandle));   
    
    for (pObject = (IAS_OBJECT *) IasObjects.Flink;
         (LIST_ENTRY *) pObject != &IasObjects;
         pObject = (IAS_OBJECT *) pObject->Linkage.Flink)    
    {
        pPrevAttrib = NULL;
        
        for (pAttrib = pObject->pAttributes;
             pAttrib != NULL;
             pAttrib = pAttrib->pNext)    
        {
            if (pAttrib == AttribHandle)
            {
                DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: attrib %hs deleted\n"),
                         pAttrib->pAttribName));
                                       
                if (pAttrib == pObject->pAttributes)
                {
                    pObject->pAttributes = pAttrib->pNext;
                }
                else
                {
                    ASSERT(pPrevAttrib);
                    pPrevAttrib->pNext = pAttrib->pNext;                    
                }
                
                IRDA_FREE_MEM(pAttrib->pAttribName);
                IRDA_FREE_MEM(pAttrib->pAttribVal);                
                IRDA_FREE_MEM(pAttrib);
                
                if (pObject->pAttributes == NULL)
                {
                    DEBUGMSG(DBG_IRLMP_IAS, (TEXT("IRLMP: No attributes associated with class %hs, deleting\n"),
                            pObject->pClassName));
                            
                    RemoveEntryList(&pObject->Linkage);    
                    IRDA_FREE_MEM(pObject->pClassName);
                    IRDA_FREE_MEM(pObject);
                }
                
                goto done;
            }
            
            pPrevAttrib = pAttrib;
        }
    }
    
done:
    
    KeReleaseSpinLock(&gSpinLock, OldIrql);
}

void
InitiateRetryIasQuery(PVOID Context)
{
    PIRDA_LINK_CB   pIrdaLinkCb = (PIRDA_LINK_CB) Context;
    PIRLMP_LINK_CB  pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
    IRDA_MSG        IMsg;
    LARGE_INTEGER   SleepMs;    


    IMsg.Prim                      = IRLMP_CONNECT_REQ;
    IMsg.IRDA_MSG_RemoteLsapSel    = IAS_LSAP_SEL;
    IMsg.IRDA_MSG_LocalLsapSel     = IAS_LOCAL_LSAP_SEL;
    IMsg.IRDA_MSG_pQos             = NULL;
    IMsg.IRDA_MSG_pConnData        = NULL;
    IMsg.IRDA_MSG_ConnDataLen      = 0;
    IMsg.IRDA_MSG_UseTtp           = FALSE;
    IMsg.IRDA_MSG_pContext         = NULL;

    RtlCopyMemory(IMsg.IRDA_MSG_RemoteDevAddr,
                  pIrlmpCb->IasQueryDevAddr,
                  IRDA_DEV_ADDR_LEN);

    while (pIrlmpCb->IasRetryCnt < 4)
    {
        pIrlmpCb->IasRetryCnt++;        
            
        DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Retry count is %d\n"), pIrlmpCb->IasRetryCnt));
    
        SleepMs.QuadPart = -(5*1000*1000); // .5 second    
        KeDelayExecutionThread(KernelMode, FALSE, &SleepMs);
                
        if (IrlmpConnectReq(&IMsg) == SUCCESS)
        {
            return;
        }
        
    }
    
    // retrying failed
    
    DEBUGMSG(DBG_IRLMP, (TEXT("IRLMP: Retry ias failed\n")));
    
    pIrlmpCb->pIasQuery = NULL;
      
    IMsg.Prim = IRLMP_GETVALUEBYCLASS_CONF;
    IMsg.IRDA_MSG_IASStatus = IRLMP_MAC_MEDIA_BUSY;
    
    TdiUp(NULL, &IMsg);    
}

VOID
DeleteDeviceList(LIST_ENTRY *pDeviceList)
{
    IRDA_DEVICE         *pDevice, *pDeviceNext;

    for (pDevice = (IRDA_DEVICE *) pDeviceList->Flink;
         (LIST_ENTRY *) pDevice != pDeviceList;
         pDevice = pDeviceNext)
    {
        pDeviceNext = (IRDA_DEVICE *) pDevice->Linkage.Flink;
         
        IRDA_FREE_MEM(pDevice);            
    }    
        
    InitializeListHead(pDeviceList);
}

VOID
FlushDiscoveryCache()
{
    PIRDA_LINK_CB       pIrdaLinkCb;
    PIRLMP_LINK_CB      pIrlmpCb;
   
    // Assumes global spinlock held

    // Flush the per link cache
    
    for (pIrdaLinkCb = (PIRDA_LINK_CB) IrdaLinkCbList.Flink;
         (LIST_ENTRY *) pIrdaLinkCb != &IrdaLinkCbList;
         pIrdaLinkCb = (PIRDA_LINK_CB) pIrdaLinkCb->Linkage.Flink)
    {                  
        pIrlmpCb = (PIRLMP_LINK_CB) pIrdaLinkCb->IrlmpContext;
        
        DEBUGMSG(DBG_DISCOVERY, (TEXT("IRLMP: Deleting IrlmpCb:%X discovery cache\n"),
                 pIrlmpCb));        
    
        DeleteDeviceList(&pIrlmpCb->DeviceList);
    }
    
    // And the global cache

    DEBUGMSG(DBG_DISCOVERY, (TEXT("IRLMP: Deleting global discovery cache\n")));
    
    DeleteDeviceList(&gDeviceList);    
}

VOID
IrlmpGetPnpContext(
    PVOID   IrlmpContext,
    PVOID   *pPnpContext)
{
    IRLMP_LSAP_CB *pLsapCb = (IRLMP_LSAP_CB *) IrlmpContext;
    PIRDA_LINK_CB pIrdaLinkCb = NULL;

    *pPnpContext = NULL;
    
    if (pLsapCb == NULL)
    {
        return;
    }

    VALIDLSAP(pLsapCb);
    
    pIrdaLinkCb = pLsapCb->pIrlmpCb->pIrdaLinkCb;
    
    if (pIrdaLinkCb) 
    {
        *pPnpContext = pIrdaLinkCb->PnpContext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\irdisc.c ===
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>

#include <winsock2.h>
#include <af_irda.h>
#include <irioctl.h>

#include <irtypes.h>

#include <resrc1.h>
#include "internal.h"

#define MAX_ATTRIB_LEN          64
#define DEVICE_LIST_LEN         5
#define IRDA_DEVICE_NAME        TEXT("\\Device\\IrDA")

#define DISCOVERY_BUFFER_SIZE    (sizeof(DEVICELIST) -                           \
                                   sizeof(IRDA_DEVICE_INFO) +                    \
                                   (sizeof(IRDA_DEVICE_INFO) * DEVICE_LIST_LEN))

typedef struct _IR_DISCOVERY_OBJECT {

    BOOL       Closing;
    LONG       ReferenceCount;

    HANDLE     DeviceHandle;
    SOCKET     Socket;

    HWND       WindowHandle;
    UINT       DiscoveryWindowMessage;
    UINT       LinkWindowMessage;
    HANDLE     TimerHandle;

    IO_STATUS_BLOCK   DiscoveryStatusBlock;
    IO_STATUS_BLOCK   LinkStateStatusBlock;

    BYTE       IoDeviceListBuffer[DISCOVERY_BUFFER_SIZE];

    BYTE       CurrentDeviceListBuffer[DISCOVERY_BUFFER_SIZE];

    IRLINK_STATUS               IoLinkStatus;

    IRLINK_STATUS               CurrentLinkStatus;

} IR_DISCOVERY_OBJECT, *PIR_DISCOVERY_OBJECT;


VOID WINAPI
TimerApcRoutine(
    PIR_DISCOVERY_OBJECT    DiscoveryObject,
    DWORD              LowTime,
    DWORD              HighTime
    );

VOID
WINAPI
DiscoverComplete(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );

VOID
WINAPI
LinkStatusComplete(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    );


int
QueryIASForInteger(SOCKET   QuerySock,
                   u_char  *pirdaDeviceID,
                   char    *pClassName,
                   int      ClassNameLen,       // including trailing NULL
                   char    *pAttribute,
                   int      AttributeLen,       // including trailing NULL
                   int    *pValue)
{
    BYTE        IASQueryBuff[sizeof(IAS_QUERY) - 3 + MAX_ATTRIB_LEN];
    int         IASQueryLen = sizeof(IASQueryBuff);
    PIAS_QUERY  pIASQuery   = (PIAS_QUERY) &IASQueryBuff;

#if DBG
    if (!((ClassNameLen > 0 && ClassNameLen <= IAS_MAX_CLASSNAME)   &&
          (AttributeLen > 0 && AttributeLen <= IAS_MAX_ATTRIBNAME)))
    {
        DEBUGMSG(("IRMON: QueryIASForInteger, bad parms\n"));
        return(SOCKET_ERROR);
    }
#endif

    RtlCopyMemory(&pIASQuery->irdaDeviceID[0], pirdaDeviceID, 4);

    RtlCopyMemory(&pIASQuery->irdaClassName[0],  pClassName, ClassNameLen);
    RtlCopyMemory(&pIASQuery->irdaAttribName[0], pAttribute, AttributeLen);

    if (getsockopt(QuerySock, SOL_IRLMP, IRLMP_IAS_QUERY,
                   (char *) pIASQuery, &IASQueryLen) == SOCKET_ERROR)
    {
#if 0
        DEBUGMSG(("IRMON: IAS Query [\"%s\",\"%s\"] failed %ws\n",
                 pIASQuery->irdaClassName,
                 pIASQuery->irdaAttribName,
                 GetLastErrorText()));
#endif
        return SOCKET_ERROR;
    }

    if (pIASQuery->irdaAttribType != IAS_ATTRIB_INT)
    {
        DEBUGMSG(("IRMON: IAS Query [\"%s\",\"%s\"] irdaAttribType not int (%d)\n",
                 pIASQuery->irdaClassName,
                 pIASQuery->irdaAttribName,
                 pIASQuery->irdaAttribType));
        return SOCKET_ERROR;
    }

    *pValue = pIASQuery->irdaAttribute.irdaAttribInt;

    return(0);
}


HANDLE
CreateIrDiscoveryObject(
    HWND    WindowHandle,
    UINT    DiscoveryWindowMessage,
    UINT    LinkWindowMessage
    )

{

    PIR_DISCOVERY_OBJECT    DiscoveryObject;
    LONGLONG                DueTime=Int32x32To64(2000,-10000);

    DiscoveryObject=HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*DiscoveryObject));

    if (DiscoveryObject == NULL) {

        return NULL;
    }

    DiscoveryObject->WindowHandle=WindowHandle;
    DiscoveryObject->DiscoveryWindowMessage=DiscoveryWindowMessage;
    DiscoveryObject->LinkWindowMessage=LinkWindowMessage;
    DiscoveryObject->DeviceHandle=INVALID_HANDLE_VALUE;
    DiscoveryObject->Socket=INVALID_SOCKET;

    DiscoveryObject->TimerHandle=CreateWaitableTimer(NULL,FALSE,NULL);

    if (DiscoveryObject->TimerHandle == NULL) {

        HeapFree(GetProcessHeap(),0,DiscoveryObject);
        return NULL;
    }

    DiscoveryObject->ReferenceCount=1;

    SetWaitableTimer(
        DiscoveryObject->TimerHandle,
        (LARGE_INTEGER*)&DueTime,
        0,
        TimerApcRoutine,
        DiscoveryObject,
        FALSE
        );


    return (HANDLE)DiscoveryObject;

}

VOID
RemoveRefCount(
    PIR_DISCOVERY_OBJECT    DiscoveryObject
    )

{
    LONG    Count=InterlockedDecrement(&DiscoveryObject->ReferenceCount);

    if (Count == 0) {

        CancelWaitableTimer(DiscoveryObject->TimerHandle);

        CloseHandle(DiscoveryObject->TimerHandle);

        if (DiscoveryObject->DeviceHandle != INVALID_HANDLE_VALUE) {

            CancelIo(DiscoveryObject->DeviceHandle);

            CloseHandle(DiscoveryObject->DeviceHandle);
        }

        if (DiscoveryObject->Socket != INVALID_SOCKET) {

            closesocket(DiscoveryObject->Socket);
        }

        DbgPrint("irmon: discovery object closed\n");

        HeapFree(GetProcessHeap(),0,DiscoveryObject);
    }

    return;
}

VOID
CloseIrDiscoveryObject(
    HANDLE    Object
    )

{
    PIR_DISCOVERY_OBJECT    DiscoveryObject=Object;

    DiscoveryObject->Closing=TRUE;

    if (DiscoveryObject->DeviceHandle != INVALID_HANDLE_VALUE) {

        CancelIo(DiscoveryObject->DeviceHandle);
    }

    return;

}

VOID WINAPI
TimerApcRoutine(
    PIR_DISCOVERY_OBJECT    DiscoveryObject,
    DWORD              LowTime,
    DWORD              HighTime
    )

{

    IO_STATUS_BLOCK    IoStatusBlock;
    UNICODE_STRING     DeviceName;
    OBJECT_ATTRIBUTES   ObjAttr;
    NTSTATUS           Status;
    LONGLONG           DueTime=Int32x32To64(10000,-10000);

    if (DiscoveryObject->Closing) {

        RemoveRefCount(DiscoveryObject);
        return;
    }

    if (DiscoveryObject->DeviceHandle == INVALID_HANDLE_VALUE) {

        // Open the stack and issue lazy discovery and status ioctls

        RtlInitUnicodeString(&DeviceName, IRDA_DEVICE_NAME);

        InitializeObjectAttributes(
                            &ObjAttr,
                            &DeviceName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL
                            );

        Status = NtCreateFile(
                    &DiscoveryObject->DeviceHandle,      // PHANDLE FileHandle
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,  // ACCESS_MASK DesiredAccess
                    &ObjAttr,           // POBJECT_ATTRIBUTES ObjAttr
                    &IoStatusBlock,     // PIO_STATUS_BLOCK IoStatusBlock
                    NULL,               // PLARGE_INTEGER AllocationSize
                    FILE_ATTRIBUTE_NORMAL,  // ULONG FileAttributes
                    FILE_SHARE_READ |
                    FILE_SHARE_WRITE,   // ULONG ShareAccess
                    FILE_OPEN_IF,       // ULONG CreateDisposition
                    0,                  // ULONG CreateOptions
                    NULL,               // PVOID EaBuffer
                    0);                 // ULONG EaLength

        if (!NT_SUCCESS(Status)) {

            DEBUGMSG(("IRMON: NtCreateFile irda.sys failed\n"));

            DiscoveryObject->DeviceHandle=INVALID_HANDLE_VALUE;

            SetWaitableTimer(
                DiscoveryObject->TimerHandle,
                (LARGE_INTEGER*)&DueTime,
                0,
                TimerApcRoutine,
                DiscoveryObject,
                FALSE
                );

            return;
        }

        // Flush IrDA's discovery cache because the user may log out
        // and devices will remain in the cache. When they log back in
        // the device would then appear briefly.

        NtDeviceIoControlFile(
                        DiscoveryObject->DeviceHandle,           // HANDLE FileHandle
                        NULL,                   // HANDLE Event OPTIONAL
                        NULL,                   // PIO_APC_ROUTINE ApcRoutine
                        NULL,                   // PVOID ApcContext
                        &IoStatusBlock,         // PIO_STATUS_BLOCK IoStatusBlock
                        IOCTL_IRDA_FLUSH_DISCOVERY_CACHE,// ULONG IoControlCode
                        NULL,                   // PVOID InputBuffer
                        0,                      // ULONG InputBufferLength
                        NULL,                   // PVOID OutputBuffer
                        0);                     // ULONG OutputBufferLength


        DiscoveryObject->Socket = socket(AF_IRDA, SOCK_STREAM, 0);

        if (DiscoveryObject->Socket == INVALID_SOCKET) {

//            DEBUGMSG(("IRMON: socket() error: %ws\n", GetLastErrorText()));

            CloseHandle(DiscoveryObject->DeviceHandle);
            DiscoveryObject->DeviceHandle=INVALID_HANDLE_VALUE;

            SetWaitableTimer(
                DiscoveryObject->TimerHandle,
                (LARGE_INTEGER*)&DueTime,
                0,
                TimerApcRoutine,
                DiscoveryObject,
                FALSE
                );


            return;

        } else {

            DEBUGMSG(("IRMON: socket created (%d).\n", DiscoveryObject->Socket));
        }
    }


    Status = NtDeviceIoControlFile(
                    DiscoveryObject->DeviceHandle,           // HANDLE FileHandle
                    NULL,                   // HANDLE Event OPTIONAL
                    DiscoverComplete,// PIO_APC_ROUTINE ApcRoutine
                    DiscoveryObject,                   // PVOID ApcContext
                    &DiscoveryObject->DiscoveryStatusBlock,         // PIO_STATUS_BLOCK IoStatusBlock
                    IOCTL_IRDA_LAZY_DISCOVERY,
                    NULL,                   // PVOID InputBuffer
                    0,                      // ULONG InputBufferLength
                    &DiscoveryObject->IoDeviceListBuffer[0],         // PVOID OutputBuffer
                    sizeof(DiscoveryObject->IoDeviceListBuffer)   // ULONG OutputBufferLength
                    );

    if (!NT_SUCCESS(Status)) {

        SetWaitableTimer(
            DiscoveryObject->TimerHandle,
            (LARGE_INTEGER*)&DueTime,
            0,
            TimerApcRoutine,
            DiscoveryObject,
            FALSE
            );

    }

    InterlockedIncrement(&DiscoveryObject->ReferenceCount);

    Status = NtDeviceIoControlFile(
                DiscoveryObject->DeviceHandle,   // HANDLE FileHandle
                NULL,                   // HANDLE Event OPTIONAL
                LinkStatusComplete,// PIO_APC_ROUTINE ApcRoutine
                DiscoveryObject,        // PVOID ApcContext
                &DiscoveryObject->LinkStateStatusBlock,         // PIO_STATUS_BLOCK IoStatusBlock
                IOCTL_IRDA_LINK_STATUS, // ULONG IoControlCode
                NULL,                   // PVOID InputBuffer
                0,                      // ULONG InputBufferLength
                &DiscoveryObject->IoLinkStatus,            // PVOID OutputBuffer
                sizeof(DiscoveryObject->IoLinkStatus) // ULONG OutputBufferLength
                );

    if (!NT_SUCCESS(Status)) {

        RemoveRefCount(DiscoveryObject);
    }


    return;

}

VOID
WINAPI
DiscoverComplete(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )

{
    NTSTATUS           Status;
    LONGLONG           DueTime=Int32x32To64(10000,-10000);
    PIR_DISCOVERY_OBJECT    DiscoveryObject=ApcContext;

    PDEVICELIST devices=(PDEVICELIST)&DiscoveryObject->CurrentDeviceListBuffer[0];

    CopyMemory(
        &DiscoveryObject->CurrentDeviceListBuffer[0],
        &DiscoveryObject->IoDeviceListBuffer[0],
        sizeof(DiscoveryObject->IoDeviceListBuffer)
        );

    if (DiscoveryObject->Closing) {

        RemoveRefCount(DiscoveryObject);
        return;
    }


    if (NT_SUCCESS(IoStatusBlock->Status) && (IoStatusBlock->Information >= sizeof(ULONG))) {

        PostMessage(
            DiscoveryObject->WindowHandle,
            DiscoveryObject->DiscoveryWindowMessage,
            0,
            0
            );

    } else {

        devices->numDevice=0;
    }

    Status = NtDeviceIoControlFile(
                    DiscoveryObject->DeviceHandle,           // HANDLE FileHandle
                    NULL,                   // HANDLE Event OPTIONAL
                    DiscoverComplete,// PIO_APC_ROUTINE ApcRoutine
                    DiscoveryObject,                   // PVOID ApcContext
                    &DiscoveryObject->DiscoveryStatusBlock,         // PIO_STATUS_BLOCK IoStatusBlock
                    IOCTL_IRDA_LAZY_DISCOVERY,
                    NULL,                   // PVOID InputBuffer
                    0,                      // ULONG InputBufferLength
                    &DiscoveryObject->IoDeviceListBuffer[0],         // PVOID OutputBuffer
                    sizeof(DiscoveryObject->IoDeviceListBuffer)   // ULONG OutputBufferLength
                    );

    if (!NT_SUCCESS(Status)) {

        SetWaitableTimer(
            DiscoveryObject->TimerHandle,
            (LARGE_INTEGER*)&DueTime,
            0,
            TimerApcRoutine,
            DiscoveryObject,
            FALSE
            );

    }

    return;
}

VOID
WINAPI
LinkStatusComplete(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )

{
    NTSTATUS           Status;
    PIR_DISCOVERY_OBJECT    DiscoveryObject=ApcContext;

    CopyMemory(
        &DiscoveryObject->CurrentLinkStatus,
        &DiscoveryObject->IoLinkStatus,
        sizeof(DiscoveryObject->IoLinkStatus)
        );

    PostMessage(
        DiscoveryObject->WindowHandle,
        DiscoveryObject->LinkWindowMessage,
        0,
        0
        );


    Status = NtDeviceIoControlFile(
                DiscoveryObject->DeviceHandle,   // HANDLE FileHandle
                NULL,                   // HANDLE Event OPTIONAL
                LinkStatusComplete,// PIO_APC_ROUTINE ApcRoutine
                DiscoveryObject,        // PVOID ApcContext
                &DiscoveryObject->LinkStateStatusBlock,         // PIO_STATUS_BLOCK IoStatusBlock
                IOCTL_IRDA_LINK_STATUS, // ULONG IoControlCode
                NULL,                   // PVOID InputBuffer
                0,                      // ULONG InputBufferLength
                &DiscoveryObject->IoLinkStatus,            // PVOID OutputBuffer
                sizeof(DiscoveryObject->IoLinkStatus) // ULONG OutputBufferLength
                );

    if (!NT_SUCCESS(Status)) {

        RemoveRefCount(DiscoveryObject);
    }

}


LONG
GetDeviceList(
    HANDLE    Object,
    OBEX_DEVICE_LIST *   List,
    ULONG    *ListBufferSize
    )

{

    PIR_DISCOVERY_OBJECT    DiscoveryObject=Object;
    ULONG                   BufferSizeNeeded;
    ULONG                   i;

    PDEVICELIST devices=(PDEVICELIST)&DiscoveryObject->CurrentDeviceListBuffer[0];

    BufferSizeNeeded=(devices->numDevice * sizeof(OBEX_DEVICE)) + FIELD_OFFSET(OBEX_DEVICE_LIST,DeviceList);

    if (*ListBufferSize < BufferSizeNeeded) {

        *ListBufferSize= BufferSizeNeeded;

        return ERROR_INSUFFICIENT_BUFFER;
    }

    ZeroMemory(List,*ListBufferSize);

    for (i=0; i<devices->numDevice; i++) {

        //
        //  the irda device name buffer is 23 bytes in size and may ahve either ascii or
        //  unicode chars. Add enough bytes to round up the an even number of unicode chars
        //  plus a null terminator.
        //
        UCHAR  TempBuffer[sizeof(devices->Device[i].irdaDeviceName)+3];

        unsigned MaxCharCount;

        CopyMemory(
            &List->DeviceList[i].DeviceSpecific.s.Irda.DeviceId,
            &devices->Device[i].irdaDeviceID,
            sizeof(ULONG)
            );

//        List->DeviceList[i].DeviceSpecific.s.Irda.DeviceId= *(unsigned long *) devices->Device[i].irdaDeviceID;

        List->DeviceList[i].DeviceType=TYPE_IRDA;

        //
        //  zero out the whole buffer and then copy the string from the device to make sure it
        //  is null terminated
        //
        ZeroMemory(&TempBuffer[0],sizeof(TempBuffer));

        CopyMemory(&TempBuffer[0],devices->Device[i].irdaDeviceName,sizeof(devices->Device[i].irdaDeviceName));

        //
        //  get the character count of unicode destination buffer
        //
        MaxCharCount = sizeof(List->DeviceList[i].DeviceName)/sizeof(wchar_t);

        if (devices->Device[i].irdaCharSet != LmCharSetUNICODE) {

            MultiByteToWideChar(CP_ACP, 0,
                                &TempBuffer[0],
                                -1,  // NULL terminated string
                                List->DeviceList[i].DeviceName,
                                MaxCharCount
                                );
        } else {
            //
            //  the name is in unicode
            //
            wcsncpy( List->DeviceList[i].DeviceName,
                     (wchar_t *)&TempBuffer[0],
                     MaxCharCount
                     );

            //
            // Assure that it is NULL-terminated.
            //
            List->DeviceList[i].DeviceName[ MaxCharCount-1 ] = 0;

        }

//        lstrcat(List->DeviceList[i].DeviceName,TEXT("(IR)"));

        {
            int   LSapSel;
            int Attempt;
            LONG  status;

            for (Attempt=1; Attempt < 5; ++Attempt) {

                status = QueryIASForInteger(DiscoveryObject->Socket,
                                            devices->Device[i].irdaDeviceID,
                                            "OBEX:IrXfer",     12,
                                            "IrDA:TinyTP:LsapSel",  20,
                                            &LSapSel);

                if (status != ERROR_SUCCESS)
                    {
                    status = QueryIASForInteger(DiscoveryObject->Socket,
                                                devices->Device[i].irdaDeviceID,
                                                "OBEX",            5,
                                                "IrDA:TinyTP:LsapSel",  20,
                                                &LSapSel);
                    }

                if (status == WSAETIMEDOUT || status == WSAECONNRESET)
                    {
                    Sleep(250);
                    continue;
                    }

                break;
            }

            if (!status) {

                List->DeviceList[i].DeviceSpecific.s.Irda.ObexSupport=TRUE;
            }
        }

        List->DeviceCount++;

    }

    return ERROR_SUCCESS;
}




VOID
GetLinkStatus(
    HANDLE    Object,
    IRLINK_STATUS  *LinkStatus
    )

{

    PIR_DISCOVERY_OBJECT    DiscoveryObject=Object;

    *LinkStatus=DiscoveryObject->CurrentLinkStatus;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\irmon.c ===
/*****************************************************************************
*
*  Copyright (C) Microsoft Corporation, 1995 - 1999
*
*  File:   irmon.c
*
*  Description: Infrared monitor
*
*  Author: mbert/mikezin
*
*  Date:   3/1/98
*
*/
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock2.h>
#include <af_irda.h>
#include <shellapi.h>
#include <resource.h>
#include <resrc1.h>
#include <irioctl.h>
// allocate storage! and initialize the GUIDS
#include <initguid.h>
#include <devguid.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <mmsystem.h>

#include "internal.h"

#include <devlist.h>
#include <irtypes.h>
#include <ssdp.h>
#include <irmon.h>

#include "irdisc.h"

#define BUILD_SERVICE_EXE       1

#define WM_IP_DEVICE_CHANGE     (WM_USER+500)
#define WM_IR_DEVICE_CHANGE     (WM_USER+501)
#define WM_IR_LINK_CHANGE       (WM_USER+502)

#define IRXFER_DLL              TEXT("irxfer.dll")
#define IAS_LSAP_SEL            "IrDA:TinyTP:LsapSel"
#define IRXFER_CLASSNAME        "OBEX:IrXfer"
#define IRXFER_CLASSNAME2       "OBEX"
#define IRMON_SERVICE_NAME      TEXT("irmon")
#define IRMON_CONFIG_KEY        TEXT("System\\CurrentControlSet\\Services\\Irmon")
#define IRMON_SHOW_ICON_KEY     TEXT("ShowTrayIcon")
#define IRMON_NO_SOUND_KEY      TEXT("NoSound")
#define TRANSFER_EXE            TEXT("irxfer")
#define PROPERTIES_EXE          TEXT("irxfer /s")
#define TASK_BAR_CREATED        TEXT("TaskbarCreated")
#define IRDA_DEVICE_NAME        TEXT("\\Device\\IrDA")
#define DEVICE_LIST_LEN         5
#define TOOL_TIP_STR_SIZE       64
#define EMPTY_STR               TEXT("")
#define SYSTRAYEVENTID          WM_USER + 1
#define EV_STOP_EVENT           0
#define EV_LOGON_EVENT          1
#define EV_LOGOFF_EVENT         2
#define EV_REG_CHANGE_EVENT     3
#define EV_TRAY_STATUS_EVENT    4
#define MAX_ATTRIB_LEN          64
#define MAKE_LT_UPDATE(a,b)     (a << 16) + b
#define RETRY_DSCV_TIMER        1
#define RETRY_DSCV_INTERVAL     10000 // 10 seconds
#define CONN_ANIMATION_TIMER    2
#define CONN_ANIMATION_INTERVAL 250
#define RETRY_TRAY_UPDATE_TIMER 3
#define RETRY_TRAY_UPDATE_INTERVAL 4000 // 4 seconds
#define WAIT_EVENT_CNT          5


typedef enum
{
    ICON_ST_NOICON,
    ICON_ST_CONN1 = 1,
    ICON_ST_CONN2,
    ICON_ST_CONN3,
    ICON_ST_CONN4,
    ICON_ST_IN_RANGE,
    ICON_ST_IP_IN_RANGE,

/*
    ICON_ST_IDLE,
    ICON_ST_RX,
    ICON_ST_TX,
    ICON_ST_RXTX,
*/
    ICON_ST_INTR
} ICON_STATE;


typedef struct _IRMON_CONTROL {

    CRITICAL_SECTION    Lock;

    PVOID               IrxferContext;
#ifdef IP_OBEX
    HANDLE              SsdpContext;
#endif

    HWND                hWnd;

    WSAOVERLAPPED       Overlapped;

    HANDLE              DiscoveryObject;

    BOOL                SoundOn;

}  IRMON_CONTROL, *PIRMON_CONTROL;

IRMON_CONTROL    GlobalIrmonControl;


extern WAVE_NUM_DEV_FN             WaveNumDev;



SERVICE_STATUS_HANDLE       IrmonStatusHandle;
SERVICE_STATUS              IrmonServiceStatus;
HANDLE                      hIrmonEvents[WAIT_EVENT_CNT];


BYTE                        FoundDevListBuf[ sizeof(OBEX_DEVICE_LIST) + sizeof(OBEX_DEVICE)*MAX_OBEX_DEVICES];
OBEX_DEVICE_LIST * const    pDeviceList=(POBEX_DEVICE_LIST)FoundDevListBuf;

BYTE                        FoundIpListBuffer[sizeof(OBEX_DEVICE_LIST) + sizeof(OBEX_DEVICE)*MAX_OBEX_DEVICES];
OBEX_DEVICE_LIST * const    IpDeviceList=(POBEX_DEVICE_LIST)FoundIpListBuffer;

LONG    UpdatingIpAddressList=0;




TCHAR                       IrmonClassName[] = TEXT("IrmonClass");
BOOLEAN                     IconInTray;
BOOLEAN                     IrmonStopped;

HICON                       hInRange;
HICON                       hIpInRange;
HICON                       hInterrupt;
HICON                       hConn1;
HICON                       hConn2;
HICON                       hConn3;
HICON                       hConn4;
/*
HICON                       hIdle;
HICON                       hTx;
HICON                       hRxTx;
HICON                       hRx;
*/
IRLINK_STATUS               LinkStatus;
HINSTANCE                   ghInstance;

BOOLEAN                     UserLoggedIn;
BOOLEAN                     TrayEnabled;

BOOLEAN                     DeviceListUpdated;
//UINT                        gTaskbarCreated;
UINT                        LastTrayUpdate; // debug purposes
UINT_PTR                    RetryTrayUpdateTimerId;
BOOLEAN                     RetryTrayUpdateTimerRunning;
int                         TrayUpdateFailures;
extern HANDLE               g_UserToken;
UINT_PTR                    ConnAnimationTimerId;
TCHAR                       ConnDevName[64];
UINT                        ConnIcon;
int                         ConnAddition;
BOOLEAN                     InterruptedSoundPlaying;

HKEY                        ghCurrentUserKey = 0;
BOOLEAN                     ShowBalloonTip;
BOOLEAN                     IrxferDeviceInRange;
HMODULE                     hIrxfer;

HWINSTA                     hWinStaUser = 0;
HWINSTA                     hSaveWinSta = 0;
HDESK                       hDeskUser = 0;
HDESK                       hSaveDesk = 0;

extern BOOL ShowSendWindow();
extern BOOL ShowPropertiesPage();

extern
void
UpdateDiscoveredDevices(
    const OBEX_DEVICE_LIST *IrDevices,
    const OBEX_DEVICE_LIST *IpDevices
    );



VOID
InitiateLazyDscv(
    PIRMON_CONTROL    IrmonControl
    );



VOID
InitiateLinkStatusQuery(
    PIRMON_CONTROL    IrmonControl
    );


VOID
SetLogonStatus(BOOL LoggedOn);

VOID
MySetLogonStatus(BOOL LoggedOn);

#if DBG
TCHAR *
GetLastErrorText()
{
    switch (WSAGetLastError())
    {
      case WSAEINTR:
        return (TEXT("WSAEINTR"));
        break;

      case WSAEBADF:
        return(TEXT("WSAEBADF"));
        break;

      case WSAEACCES:
        return(TEXT("WSAEACCES"));
        break;

      case WSAEFAULT:
        return(TEXT("WSAEFAULT"));
        break;

      case WSAEINVAL:
        return(TEXT("WSAEINVAL"));
        break;

      case WSAEMFILE:
        return(TEXT("WSAEMFILE"));
        break;

      case WSAEWOULDBLOCK:
        return(TEXT("WSAEWOULDBLOCK"));
        break;

      case WSAEINPROGRESS:
        return(TEXT("WSAEINPROGRESS"));
        break;

      case WSAEALREADY:
        return(TEXT("WSAEALREADY"));
        break;

      case WSAENOTSOCK:
        return(TEXT("WSAENOTSOCK"));
        break;

      case WSAEDESTADDRREQ:
        return(TEXT("WSAEDESTADDRREQ"));
        break;

      case WSAEMSGSIZE:
        return(TEXT("WSAEMSGSIZE"));
        break;

      case WSAEPROTOTYPE:
        return(TEXT("WSAEPROTOTYPE"));
        break;

      case WSAENOPROTOOPT:
        return(TEXT("WSAENOPROTOOPT"));
        break;

      case WSAEPROTONOSUPPORT:
        return(TEXT("WSAEPROTONOSUPPORT"));
        break;

      case WSAESOCKTNOSUPPORT:
        return(TEXT("WSAESOCKTNOSUPPORT"));
        break;

      case WSAEOPNOTSUPP:
        return(TEXT("WSAEOPNOTSUPP"));
        break;

      case WSAEPFNOSUPPORT:
        return(TEXT("WSAEPFNOSUPPORT"));
        break;

      case WSAEAFNOSUPPORT:
        return(TEXT("WSAEAFNOSUPPORT"));
        break;

      case WSAEADDRINUSE:
        return(TEXT("WSAEADDRINUSE"));
        break;

      case WSAEADDRNOTAVAIL:
        return(TEXT("WSAEADDRNOTAVAIL"));
        break;

      case WSAENETDOWN:
        return(TEXT("WSAENETDOWN"));
        break;

      case WSAENETUNREACH:
        return(TEXT("WSAENETUNREACH"));
        break;

      case WSAENETRESET:
        return(TEXT("WSAENETRESET"));
        break;

      case WSAECONNABORTED:
        return(TEXT("WSAECONNABORTED"));
        break;

      case WSAECONNRESET:
        return(TEXT("WSAECONNRESET"));
        break;

      case WSAENOBUFS:
        return(TEXT("WSAENOBUFS"));
        break;

      case WSAEISCONN:
        return(TEXT("WSAEISCONN"));
        break;

      case WSAENOTCONN:
        return(TEXT("WSAENOTCONN"));
        break;

      case WSAESHUTDOWN:
        return(TEXT("WSAESHUTDOWN"));
        break;

      case WSAETOOMANYREFS:
        return(TEXT("WSAETOOMANYREFS"));
        break;

      case WSAETIMEDOUT:
        return(TEXT("WSAETIMEDOUT"));
        break;

      case WSAECONNREFUSED:
        return(TEXT("WSAECONNREFUSED"));
        break;

      case WSAELOOP:
        return(TEXT("WSAELOOP"));
        break;

      case WSAENAMETOOLONG:
        return(TEXT("WSAENAMETOOLONG"));
        break;

      case WSAEHOSTDOWN:
        return(TEXT("WSAEHOSTDOWN"));
        break;

      case WSAEHOSTUNREACH:
        return(TEXT("WSAEHOSTUNREACH"));
        break;

      case WSAENOTEMPTY:
        return(TEXT("WSAENOTEMPTY"));
        break;

      case WSAEPROCLIM:
        return(TEXT("WSAEPROCLIM"));
        break;

      case WSAEUSERS:
        return(TEXT("WSAEUSERS"));
        break;

      case WSAEDQUOT:
        return(TEXT("WSAEDQUOT"));
        break;

      case WSAESTALE:
        return(TEXT("WSAESTALE"));
        break;

      case WSAEREMOTE:
        return(TEXT("WSAEREMOTE"));
        break;

      case WSAEDISCON:
        return(TEXT("WSAEDISCON"));
        break;

      case WSASYSNOTREADY:
        return(TEXT("WSASYSNOTREADY"));
        break;

      case WSAVERNOTSUPPORTED:
        return(TEXT("WSAVERNOTSUPPORTED"));
        break;

      case WSANOTINITIALISED:
        return(TEXT("WSANOTINITIALISED"));
        break;

        /*
      case WSAHOST:
        return(TEXT("WSAHOST"));
        break;

      case WSATRY:
        return(TEXT("WSATRY"));
        break;

      case WSANO:
        return(TEXT("WSANO"));
        break;
        */

      default:
        return(TEXT("Unknown Error"));
    }
}
#endif

HKEY
OpenCurrentUserKey()
{
    HKEY            hUserKey;
    DWORD           SizeNeeded;
    TOKEN_USER      *TokenData;
    WCHAR           UnicodeBuffer[256];
    UNICODE_STRING  UnicodeString;
    NTSTATUS        NtStatus;

    // Get current user token so we can access the sound data in the
    // user's hive

    if (!GetTokenInformation(g_UserToken, TokenUser, 0, 0, &SizeNeeded))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            TokenData = (TOKEN_USER *) _alloca( SizeNeeded );
        }
        else
        {
            DEBUGMSG(("IRMON: GetTokenInformation failed %d\n", GetLastError()));
            return 0;
        }
    }
    else
    {
        DEBUGMSG(("IRMON: GetTokenInformation should have failed\n"));
        return 0;
    }

    if (!TokenData)
    {
        DEBUGMSG(("IRMON: alloc failed\n"));
        return 0;
    }

    if (!GetTokenInformation(g_UserToken, TokenUser, TokenData,
                             SizeNeeded, &SizeNeeded))
    {
        DEBUGMSG(("IRMON: GetTokenInformation failed %d\n", GetLastError()));
        return 0;
    }

    UnicodeString.Buffer        = UnicodeBuffer;
    UnicodeString.Length        = 0;
    UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            TokenData->User.Sid,
                                            FALSE);

    if (!NT_SUCCESS(NtStatus))
    {
        DEBUGMSG(("IRMON: RtlConvertSidToUnicodeString failed %\n", GetLastError()));
        return 0;
    }

    UnicodeString.Buffer[UnicodeString.Length] = 0;

    //
    // Open all our keys.  If we can't open the user's key
    // or the key to watch for changes, we bail.
    //
    if (RegOpenKeyEx(HKEY_USERS, UnicodeString.Buffer, 0, KEY_READ, &hUserKey))
    {
        DEBUGMSG(("IRMON: RegOpenKey1 failed %d\n", GetLastError()));
        return 0;
    }

    return hUserKey;
}


VOID
LoadTrayIconImages()
{
    hInRange  = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_IN_RANGE),
                          IMAGE_ICON, 16,16,0);
    hInterrupt= LoadImage(ghInstance, MAKEINTRESOURCE(IDI_INTR),
                          IMAGE_ICON, 16,16,0);
    hConn1    = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CONN1),
                          IMAGE_ICON, 16,16,0);
    hConn2    = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CONN2),
                          IMAGE_ICON, 16,16,0);
    hConn3    = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CONN3),
                          IMAGE_ICON, 16,16,0);
    hConn4    = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CONN4),
                          IMAGE_ICON, 16,16,0);

    hIpInRange= LoadImage(ghInstance, MAKEINTRESOURCE(IDI_IP),
                          IMAGE_ICON, 16,16,0);
}

VOID
UpdateTray(
    PIRMON_CONTROL    IrmonControl,
    ICON_STATE        IconState,
    DWORD             MsgId,
    LPTSTR            DeviceName,
    UINT              Baud
    )
{
    NOTIFYICONDATA      NotifyIconData;
    DWORD               Cnt;
    TCHAR               FormatStr[256];
    BOOL                Result = TRUE;
    BOOLEAN             TrayUpdateFailed = FALSE;

    if (!TrayEnabled && IconState != ICON_ST_NOICON)
    {
        return;
    }

    if (!hInRange)
    {
        LoadTrayIconImages();
    }

    NotifyIconData.cbSize           = sizeof(NOTIFYICONDATA);
    NotifyIconData.uID              = 0;
    NotifyIconData.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_TIP | NIF_INFO;
    NotifyIconData.uCallbackMessage = SYSTRAYEVENTID;
    NotifyIconData.hWnd             = IrmonControl->hWnd;
    NotifyIconData.hIcon            = 0;
    NotifyIconData.szInfo[0]        = 0;
    NotifyIconData.szInfoTitle[0]   = 0;

    if (MsgId == 0)
    {
        lstrcpy(NotifyIconData.szTip, EMPTY_STR);
    }
    else
    {
        if (LoadString(ghInstance, MsgId, FormatStr, sizeof(FormatStr)/sizeof(TCHAR)))
        {
            wsprintf(NotifyIconData.szTip, FormatStr, DeviceName, Baud);
        }
    }

    if (IrmonStopped && IconState != ICON_ST_NOICON)
        return;

    switch (IconState)
    {
        case ICON_ST_NOICON:

            ShowBalloonTip = TRUE;

            if (IconInTray)
            {

                NotifyIconData.uFlags = 0;
                IconInTray = FALSE;
                if (Shell_NotifyIcon(NIM_DELETE, &NotifyIconData)) {

                    LastTrayUpdate = MAKE_LT_UPDATE(NIM_DELETE,ICON_ST_NOICON);

                    if (IrmonControl->SoundOn) {

                        PlayIrSound(OUTOFRANGE_SOUND);
                    }
                } else {

                    DEBUGMSG(("IRMON: Shell_NotifyIcon(Delete) failed %d, %d\n", TrayUpdateFailures, GetLastError()));
                }
            }
            return;

        case ICON_ST_IN_RANGE:
        case ICON_ST_IP_IN_RANGE:

            if (IconState == ICON_ST_IP_IN_RANGE) {

                NotifyIconData.hIcon = hIpInRange;

            } else {

                NotifyIconData.hIcon = hInRange;
            }

            if (ShowBalloonTip)
            {
                ShowBalloonTip = FALSE;

                if (IrxferDeviceInRange &&
                    LoadString(ghInstance, IDS_BALLOON_TITLE,
                               NotifyIconData.szInfoTitle,
                               sizeof(NotifyIconData.szInfoTitle)/sizeof(TCHAR)))
                {
                    NotifyIconData.uFlags |= NIF_INFO;
                    NotifyIconData.uTimeout = 10000; // in milliseconds
//                    NotifyIconData.dwInfoFlags = NIIF_INFO;

                    if (DeviceName)
                    {
                        LoadString(ghInstance, IDS_BALLOON_TXT,
                                   FormatStr,
                                   sizeof(FormatStr)/sizeof(TCHAR));
                        wsprintf(NotifyIconData.szInfo, FormatStr, DeviceName);
                    }
                    else
                    {
                        LoadString(ghInstance, IDS_BALLOON_TXT2,
                                   NotifyIconData.szInfo,
                                   sizeof(NotifyIconData.szInfo)/sizeof(TCHAR));
                    }
                }
            }

            break;

        case ICON_ST_CONN1:
            NotifyIconData.hIcon = hConn1;
            break;

        case ICON_ST_CONN2:
            NotifyIconData.hIcon = hConn2;
            break;

        case ICON_ST_CONN3:
            NotifyIconData.hIcon = hConn3;
            break;

        case ICON_ST_CONN4:
            NotifyIconData.hIcon = hConn4;
            break;

/*
        case ICON_ST_IDLE:
            NotifyIconData.hIcon = hIdle;
            break;

        case ICON_ST_RX:
            NotifyIconData.hIcon = hRx;
            break;

        case ICON_ST_TX:
            NotifyIconData.hIcon = hTx;
            break;

        case ICON_ST_RXTX:
            NotifyIconData.hIcon = hRxTx;
            break;

*/
        case ICON_ST_INTR:
            NotifyIconData.hIcon = hInterrupt;

            if (LoadString(ghInstance, IDS_BLOCKED_TITLE,
                               NotifyIconData.szInfoTitle,
                               sizeof(NotifyIconData.szInfoTitle)/sizeof(TCHAR)) &&
                LoadString(ghInstance, IDS_BLOCKED_TXT,
                               NotifyIconData.szInfo,
                               sizeof(NotifyIconData.szInfo)/sizeof(TCHAR)))
            {
                NotifyIconData.uFlags |= NIF_INFO;
                NotifyIconData.uTimeout = 10000; // in milliseconds
                NotifyIconData.dwInfoFlags = NIIF_WARNING;
            }
            break;
    }

    if (IconState == ICON_ST_INTR) {

        if (IrmonControl->SoundOn) {

            PlayIrSound(INTERRUPTED_SOUND);
            InterruptedSoundPlaying = TRUE;
        }

    } else {

        if (InterruptedSoundPlaying) {

            InterruptedSoundPlaying = FALSE;
            PlayIrSound(END_INTERRUPTED_SOUND);
        }
    }

    if (!IconInTray)
    {
        if (Shell_NotifyIcon(NIM_ADD, &NotifyIconData))
        {
            LastTrayUpdate = MAKE_LT_UPDATE(NIM_ADD, IconState);
            if (IrmonControl->SoundOn) {

                PlayIrSound(INRANGE_SOUND);
            }
            IconInTray = TRUE;
        }
        else
        {
            TrayUpdateFailures++;
            DEBUGMSG(("IRMON: Shell_NotifyIcon(ADD) failed %d, %d\n", TrayUpdateFailures, GetLastError()));
            NotifyIconData.uFlags = 0;
            NotifyIconData.cbSize           = sizeof(NOTIFYICONDATA);
            NotifyIconData.uID              = 0;
            NotifyIconData.uCallbackMessage = SYSTRAYEVENTID;
            NotifyIconData.hWnd             = IrmonControl->hWnd;
            NotifyIconData.hIcon            = 0;
            NotifyIconData.szInfo[0]        = 0;
            NotifyIconData.szInfoTitle[0]   = 0;

            Shell_NotifyIcon(NIM_DELETE, &NotifyIconData);
            TrayUpdateFailed = TRUE;
            ShowBalloonTip = TRUE;
        }
    }
    else
    {
        if (!Shell_NotifyIcon(NIM_MODIFY, &NotifyIconData))
        {
            TrayUpdateFailures++;
            DEBUGMSG(("IRMON: Shell_NotifyIcon(Modify) failed %d, %d\n", TrayUpdateFailures, GetLastError()));
            TrayUpdateFailed = TRUE;
        }
        else
        {
            LastTrayUpdate = MAKE_LT_UPDATE(NIM_MODIFY, IconState);
        }
    }

    if (TrayUpdateFailed && !RetryTrayUpdateTimerRunning)
    {
        RetryTrayUpdateTimerId = SetTimer(IrmonControl->hWnd, RETRY_TRAY_UPDATE_TIMER,
                                          RETRY_TRAY_UPDATE_INTERVAL, NULL);

        RetryTrayUpdateTimerRunning = TRUE;
    }
}

VOID
ConnAnimationTimerExp(
    PIRMON_CONTROL    IrmonControl
    )
{
/*    if (ConnDevName[0] == 0)
    {
        UpdateTray(ICON_ST_CONN1, 0, NULL, 0);
    }
    else
    {
*/
        UpdateTray(IrmonControl,ConnIcon,  IDS_CONNECTED_TO, ConnDevName,
                   LinkStatus.ConnectSpeed);
//    }

    ConnIcon += ConnAddition;

    if (ConnIcon == 4)
    {
        ConnAddition = -1;
    }
    else if (ConnIcon == 1)
    {
        ConnAddition = 1;
    }
}

VOID
IsIrxferDeviceInRange()
{
    int     i, LsapSel, Attempt, Status;

    IrxferDeviceInRange = FALSE;

    if (IpDeviceList->DeviceCount > 0) {

        IrxferDeviceInRange = TRUE;
        return;
    }

    for (i = 0; i < (int)pDeviceList->DeviceCount; i++) {


        if (pDeviceList->DeviceList[i].DeviceSpecific.s.Irda.ObexSupport) {

            IrxferDeviceInRange = TRUE;
            break;
        }
    }
    return;

}

VOID
DevListChangeOrUpdatedLinkStatus(
    PIRMON_CONTROL    IrmonControl
    )
{
    if (!UserLoggedIn)
    {
        DEBUGMSG(("IRMON: User not logged in, ignoring device change\n"));
        return;
    }

    if (DeviceListUpdated)
    {
        IsIrxferDeviceInRange();
    }

    if (LinkStatus.Flags & LF_INTERRUPTED)
    {
        KillTimer(IrmonControl->hWnd, ConnAnimationTimerId);

        UpdateTray(IrmonControl,ICON_ST_INTR, IDS_INTERRUPTED, NULL, 0);

    }
    else if (LinkStatus.Flags & LF_CONNECTED)
    {
//        ICON_STATE  IconState = ICON_ST_IDLE;
        ULONG       i;

        ConnDevName[0] = 0;

        ConnIcon = 1;
        ConnAddition = 1;

        for (i = 0; i < pDeviceList->DeviceCount; i++)
        {
            if (memcmp(&pDeviceList->DeviceList[i].DeviceSpecific.s.Irda.DeviceId,
                LinkStatus.ConnectedDeviceId, 4) == 0)
            {

                //
                //  the name is in unicode
                //
                ZeroMemory(ConnDevName,sizeof(ConnDevName));

                lstrcpy(
                    ConnDevName,
                    pDeviceList->DeviceList[i].DeviceName
                    );


                break;
            }
        }
        ConnAnimationTimerExp(IrmonControl);

        ConnAnimationTimerId = SetTimer(IrmonControl->hWnd, CONN_ANIMATION_TIMER,
                                        CONN_ANIMATION_INTERVAL, NULL);

    }
    else
    {
        KillTimer(IrmonControl->hWnd, ConnAnimationTimerId);

        if ((pDeviceList->DeviceCount == 0) && (IpDeviceList->DeviceCount == 0)) {
            //
            //  no devices in range
            //
            UpdateTray(IrmonControl,ICON_ST_NOICON, 0, NULL, 0);

        } else {
            //
            //  atleast on device in range
            //
            if ((pDeviceList->DeviceCount == 1) && (IpDeviceList->DeviceCount == 0)) {
                //
                //  one ir device in range
                //
                lstrcpy(
                    ConnDevName,
                    pDeviceList->DeviceList[0].DeviceName
                    );

                UpdateTray(IrmonControl,ICON_ST_IN_RANGE, IDS_IN_RANGE, ConnDevName, 0);

            } else {

                if ((pDeviceList->DeviceCount == 0) && (IpDeviceList->DeviceCount == 1)) {
                    //
                    //  one ip device in range
                    //
                    lstrcpy(
                        ConnDevName,
                        IpDeviceList->DeviceList[0].DeviceName
                        );

                    lstrcat(ConnDevName,TEXT("(IP)"));

                    UpdateTray(IrmonControl,ICON_ST_IP_IN_RANGE, IDS_IN_RANGE, ConnDevName, 0);

                } else {
                    //
                    //  more than one device total
                    //
                    if (pDeviceList->DeviceCount > IpDeviceList->DeviceCount) {

                        UpdateTray(IrmonControl,ICON_ST_IN_RANGE, IDS_DEVS_IN_RANGE, NULL, 0);

                    } else {

                        UpdateTray(IrmonControl,ICON_ST_IP_IN_RANGE, IDS_DEVS_IN_RANGE, NULL, 0);
                    }

                }
            }
        }
    }

    if (!UserLoggedIn)
    {
        // Check again because UpdateTray() may have changed logon status
        // because of premature notification from irxfer

        DEBUGMSG(("IRMON: User not logged in because UpdateTray must have logged us off\n"));

        return;
    }

    if (DeviceListUpdated)
    {
        HANDLE  hThread;
        DWORD   ThreadId;

        DeviceListUpdated = FALSE;

        // PnP Printers, Notify transfer app

        UpdateDiscoveredDevices(pDeviceList,IpDeviceList);
    }
}

VOID
UserLogonEvent(
    PIRMON_CONTROL    IrmonControl
    )
{
    UINT                DevListLen;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;


    //
    // save current desktop and window station
    // so that it can be restored when the user logs off.
    //

    hSaveWinSta = GetProcessWindowStation();

    hSaveDesk = GetThreadDesktop(GetCurrentThreadId());

    //
    // Open the current user's window station and desktop so
    // we can add an icon to the taskbar
    //

    hWinStaUser = OpenWindowStation(L"WinSta0", FALSE, MAXIMUM_ALLOWED);

    if (hWinStaUser == NULL)
    {
        DEBUGMSG(("IRMON: OpenWindowStation FAILED %d\n", GetLastError()));
    }
    else
    {
        if (!SetProcessWindowStation(hWinStaUser))
        {
            DEBUGMSG(("IRMON: SetProcessWindowStation failed %d\n", GetLastError()));
        }
        else
        {
            DEBUGMSG(("IRMON: SetProcessWindowStation succeeded\n"));
        }
    }

    hDeskUser = OpenDesktop(L"Default", 0 , FALSE, MAXIMUM_ALLOWED);

    if (hDeskUser == NULL)
    {
        DEBUGMSG(("IRMON: OpenDesktop failed %d\n", GetLastError()));
    }
    else
    {
        if (!SetThreadDesktop(hDeskUser))
        {
            DEBUGMSG(("IRMON: SetThreadDesktop failed %d\n", GetLastError()));
        }
        else
        {
            DEBUGMSG(("IRMON: SetThreadDesktop succeeded %d\n"));
        }
    }

    //
    // Create the window that will receive the taskbar menu messages.
    // The window has to be created after opening the user's desktop
    // or the call to SetThreadDesktop() will if the thread has
    // any windows
    //

    IrmonControl->hWnd = CreateWindow(
          IrmonClassName,
          NULL,
          WS_OVERLAPPEDWINDOW,
          CW_USEDEFAULT,
          CW_USEDEFAULT,
          CW_USEDEFAULT,
          CW_USEDEFAULT,
          NULL,
          NULL,
          ghInstance,
          &GlobalIrmonControl
          );

    ShowWindow(IrmonControl->hWnd, SW_HIDE);

    UpdateWindow(IrmonControl->hWnd);



    ghCurrentUserKey = OpenCurrentUserKey();

    InitializeSound(
        ghCurrentUserKey,
        hIrmonEvents[EV_REG_CHANGE_EVENT]
        );


    ShowBalloonTip = TRUE;

    IrmonControl->DiscoveryObject=CreateIrDiscoveryObject(
        IrmonControl->hWnd,
        WM_IR_DEVICE_CHANGE,
        WM_IR_LINK_CHANGE
        );

    if (IrmonControl->DiscoveryObject == NULL) {

        DbgPrint("irmon: could not create ir discovery object\n");
        return;

    }

}

VOID
UserLogoffEvent(
    PIRMON_CONTROL    IrmonControl
    )
{
    DEBUGMSG(("IRMON: User logoff event\n"));
    UserLoggedIn = FALSE;
    IconInTray = FALSE;

    KillTimer(IrmonControl->hWnd, ConnAnimationTimerId);

    if (IrmonControl->DiscoveryObject != NULL) {

        CloseIrDiscoveryObject(IrmonControl->DiscoveryObject);

        IrmonControl->DiscoveryObject = NULL;
    }


    UninitializeSound();

    if (ghCurrentUserKey)
    {
        RegCloseKey(ghCurrentUserKey);
        ghCurrentUserKey = 0;
    }

    if (hSaveDesk)
    {
        SetThreadDesktop(hSaveDesk);

        if (hSaveWinSta)
            {
            SetProcessWindowStation(hSaveWinSta);
            }

        CloseDesktop(hSaveDesk);
        hSaveDesk = 0;

        if (hSaveWinSta)
            {
            CloseWindowStation(hSaveWinSta);
            hSaveWinSta = 0;
            }
    }

    if (hDeskUser)
    {
        CloseDesktop(hDeskUser);
        hDeskUser = 0;
    }

    if (hWinStaUser)
    {
        CloseWindowStation(hWinStaUser);
        hWinStaUser = 0;
    }

    if (IrmonControl->hWnd) {

        if (IconInTray) {

            UpdateTray(&GlobalIrmonControl,ICON_ST_NOICON, 0, NULL, 0);
        }

        DestroyWindow(IrmonControl->hWnd);
        IrmonControl->hWnd = 0;
    }
}

VOID
SetLogonStatus(BOOL LoggedOn)
{
    MySetLogonStatus(LoggedOn);
}

VOID
MySetLogonStatus(BOOL LoggedOn)
{
    if (LoggedOn)
    {
        if (UserLoggedIn)
        {
            DEBUGMSG(("IRMON: SetLogonStatus(TRUE) && UserLoggedIn==TRUE (OK)\n"));
            return;
        }
        else
        {
            DEBUGMSG(("IRMON: User logged in\n"));

            UserLoggedIn = TRUE;

            SetEvent(hIrmonEvents[EV_LOGON_EVENT]);
        }
    }
    else
    {
        SetEvent(hIrmonEvents[EV_LOGOFF_EVENT]);
    }
}


VOID
SetSoundStatus(
    PVOID    Context,
    BOOL     SoundOn
    )

{
    PIRMON_CONTROL    IrmonControl=(PIRMON_CONTROL)Context;

//    DbgPrint("Irmon: sound %d\n",SoundOn);

    IrmonControl->SoundOn=SoundOn;

    return;

}

VOID
SetTrayStatus(
    PVOID    Context,
    BOOL     lTrayEnabled
    )
{
    PIRMON_CONTROL    IrmonControl=(PIRMON_CONTROL)Context;

    if (lTrayEnabled)
    {
        DEBUGMSG(("IRMON: Tray enabled\n"));
        TrayEnabled = TRUE;
    }
    else
    {
        DEBUGMSG(("IRMON: Tray disabled\n"));
        TrayEnabled = FALSE;
    }

    SetEvent(hIrmonEvents[EV_TRAY_STATUS_EVENT]);
}

LONG_PTR FAR PASCAL
WndProc(
    HWND hWnd,
    unsigned message,
    WPARAM wParam,
    LPARAM lParam)
{

    PIRMON_CONTROL    IrmonControl=(PIRMON_CONTROL)GetWindowLongPtr(hWnd,GWLP_USERDATA);

    switch (message)
    {
        case WM_CREATE: {

            LPCREATESTRUCT   CreateStruct=(LPCREATESTRUCT)lParam;

            SetWindowLongPtr(hWnd,GWLP_USERDATA,(LONG_PTR)CreateStruct->lpCreateParams);

            return 0;
        }
        break;


        case WM_COMMAND:
        {
            switch (wParam)
            {
                case IDC_TX_FILES:
                    ShowSendWindow();
                    break;

                case IDC_PROPERTIES:
                    DEBUGMSG(("IRMON: Launch Properties page\n"));
                    ShowPropertiesPage();
                    break;

                default:
                    ;
                    //DEBUGMSG(("Other WM_COMMAND %X\n", wParam));
            }
            break;
        }

        case SYSTRAYEVENTID:
        {
            POINT     pt;
            HMENU     hMenu, hMenuPopup;

            switch (lParam)
            {
                case WM_LBUTTONDOWN:
                    ShowSendWindow();
                    break;

                case WM_RBUTTONDOWN:

                    SetForegroundWindow(hWnd);

                    GetCursorPos(&pt);

                    hMenu = LoadMenu(ghInstance, MAKEINTRESOURCE(IDR_TRAY_MENU));

                    if (!hMenu)
                    {
                        DEBUGMSG(("IRMON: failed to load menu\n"));
                        break;
                    }

                    hMenuPopup = GetSubMenu(hMenu, 0);
                    SetMenuDefaultItem(hMenuPopup, 0, TRUE);

                    TrackPopupMenuEx(hMenuPopup,
                                     TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                                     pt.x, pt.y, hWnd, NULL);

                    DestroyMenu(hMenu);
                    break;
                //default:DEBUGMSG(("IRMON: Systray other %d\n", lParam));
            }

            break;
        }

        case WM_TIMER:

            if (wParam == ConnAnimationTimerId)
            {
                ConnAnimationTimerExp(IrmonControl);
            }
            else if (wParam == RetryTrayUpdateTimerId)
            {
                DEBUGMSG(("IRMON: RetryTrayUpdateTimer expired\n"));
                KillTimer(IrmonControl->hWnd, RetryTrayUpdateTimerId);
                RetryTrayUpdateTimerRunning = FALSE;
                DevListChangeOrUpdatedLinkStatus(IrmonControl);
            }
            break;

        case WM_QUERYENDSESSION:
            {
            extern BOOL IrxferHandlePowerMessage( HWND hWnd, unsigned message, WPARAM wParam, LPARAM lParam );

            return IrxferHandlePowerMessage( hWnd, message, wParam, lParam );
            break;
            }

        case WM_ENDSESSION:
            break;

        case WM_POWERBROADCAST:
            {
            extern BOOL IrxferHandlePowerMessage( HWND hWnd, unsigned message, WPARAM wParam, LPARAM lParam );

            return IrxferHandlePowerMessage( hWnd, message, wParam, lParam );
            break;
            }

        case WM_IP_DEVICE_CHANGE: {


            ULONG    BufferSize=sizeof(FoundIpListBuffer);
            ULONG    i;
            LONG     lResult;
            LONG     Count;

            EnterCriticalSection(&IrmonControl->Lock);
            Count=InterlockedIncrement(&UpdatingIpAddressList);

            if (Count > 1) {
                //
                //  re-eneter, just skip
                //
                DbgPrint("irmon: re-entered device notify message %d\n",Count);

            } else {
                //
                //  first one in, up date the list
                //
#ifdef IP_OBEX
                if (IrmonControl->SsdpContext != NULL) {

                    lResult=GetSsdpDevices(
                        IrmonControl->SsdpContext,
                        IpDeviceList,
                        &BufferSize
                        );

                    if (lResult == ERROR_SUCCESS) {

                        for (i=0; i<IpDeviceList->DeviceCount; i++) {

                            DbgPrint(
                                "IRMON: ip device %ws, addr=%08lx, port=%d\n",\
                                IpDeviceList->DeviceList[i].DeviceName,
                                IpDeviceList->DeviceList[i].DeviceSpecific.s.Ip.IpAddress,
                                IpDeviceList->DeviceList[i].DeviceSpecific.s.Ip.Port
                                );

                        }

                        DeviceListUpdated = TRUE;

                        DevListChangeOrUpdatedLinkStatus(IrmonControl);

                    } else {

                        DbgPrint("IRMON: GetSsdpDevices() failed\n");
                    }

                } else {

                    DbgPrint("irmon: ssdp context == null\n");
                }
#endif //IP_OBEX
            }

            InterlockedDecrement(&UpdatingIpAddressList);
            LeaveCriticalSection(&IrmonControl->Lock);

            break;
        }

        case WM_IR_DEVICE_CHANGE: {

            ULONG    BufferSize=sizeof(FoundDevListBuf);



            GetDeviceList(
                IrmonControl->DiscoveryObject,
                pDeviceList,
                &BufferSize
                );


            DeviceListUpdated = TRUE;

            DEBUGMSG(("IRMON: %d IR device(s) found:\n", pDeviceList->DeviceCount));

            DevListChangeOrUpdatedLinkStatus(IrmonControl);


        }
        break;

        case WM_IR_LINK_CHANGE: {

            GetLinkStatus(
                IrmonControl->DiscoveryObject,
                &LinkStatus
                );

            DEBUGMSG(("IRMON: link state change\n"));

            DevListChangeOrUpdatedLinkStatus(IrmonControl);

        }
        break;

        default:
#if 0
            if (message == gTaskbarCreated)
            {
                DevListChangeOrUpdatedLinkStatus(IrmonControl);
            }
#endif
            //DEBUGMSG(("Msg %X, wParam %d, lParam %d\n", message, wParam, lParam));
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return 0;
}

DWORD
IrmonReportServiceStatus()
{
#ifdef BUILD_SERVICE_EXE
    if (!SetServiceStatus(IrmonStatusHandle, &IrmonServiceStatus))
    {
        DEBUGMSG(("IRMON: SetServiceStatus failed %d\n", GetLastError()));
        return GetLastError();
    }
#endif
    return NO_ERROR;
}

DWORD
IrmonUpdateServiceStatus(
    DWORD State,
    DWORD Win32ExitCode,
    DWORD CheckPoint,
    DWORD WaitHint
    )
{
    DWORD Error = NO_ERROR;

#ifdef BUILD_SERVICE_EXE
    IrmonServiceStatus.dwCurrentState  = State;
    IrmonServiceStatus.dwWin32ExitCode = Win32ExitCode;
    IrmonServiceStatus.dwCheckPoint    = CheckPoint;
    IrmonServiceStatus.dwWaitHint      = WaitHint;

    Error = IrmonReportServiceStatus();

    if (Error != NO_ERROR)
    {
        DEBUGMSG(("IRMON: IrmonUpdateServiceStatus failed %d\n", GetLastError()));
    }
#endif

    return Error;
}

VOID
AdhocNotworkNotification(
    PVOID    Context,
    BOOL     Availible
    )

{
    PIRMON_CONTROL    IrmonControl=(PIRMON_CONTROL)Context;
#ifdef IP_OBEX
    if (Availible) {
        //
        //  there is an adhok network availible
        //
        EnterCriticalSection(&IrmonControl->Lock);

        DbgPrint("irmon: new adhoc networks\n");

        IrmonControl->SsdpContext=CreateSsdpDiscoveryObject(
            "OBEX",
            IrmonControl->hWnd,
            WM_IP_DEVICE_CHANGE
            );

        LeaveCriticalSection(&IrmonControl->Lock);


    } else {

        DbgPrint("irmon: no adhoc networks\n");

        EnterCriticalSection(&IrmonControl->Lock);

        if (IrmonControl->SsdpContext != NULL) {

            CloseSsdpDiscoveryObject(IrmonControl->SsdpContext);
            IrmonControl->SsdpContext=NULL;
        }

        IpDeviceList->DeviceCount=0;
        DeviceListUpdated = TRUE;

        LeaveCriticalSection(&IrmonControl->Lock);

        DevListChangeOrUpdatedLinkStatus(IrmonControl);
    }
#endif
    return;
}


#ifdef BUILD_SERVICE_EXE
VOID
ServiceHandler(
    DWORD OpCode)
{

    switch( OpCode )
    {
    case SERVICE_CONTROL_STOP :

        DEBUGMSG(("IRMON: SERVICE_CONTROL_STOP received\n"));
        IrmonServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        IrmonReportServiceStatus();
        SetEvent(hIrmonEvents[EV_STOP_EVENT]);
        return;

    case SERVICE_CONTROL_PAUSE :

        DEBUGMSG(("IRMON: SERVICE_CONTROL_PAUSE received\n"));
        IrmonServiceStatus.dwCurrentState = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_CONTINUE :

        DEBUGMSG(("IRMON: SERVICE_CONTROL_CONTINUE received\n"));
        IrmonServiceStatus.dwCurrentState = SERVICE_RUNNING;
        break;

    default :
        break;
    }

    IrmonReportServiceStatus();
}
#endif

VOID
ServiceMain(
    DWORD       cArgs,
    LPWSTR      *pArgs)
{
    DWORD       Error = NO_ERROR;
    DWORD       Status;
    WNDCLASS    Wc;
    MSG         Msg;
    HKEY        hKey;
    LONG        rc;
    WSADATA     WSAData;
    WORD        WSAVerReq = MAKEWORD(2,0);
    char        c;
    BOOL        bResult;

    hIrmonEvents[EV_STOP_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    hIrmonEvents[EV_LOGON_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    hIrmonEvents[EV_LOGOFF_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    hIrmonEvents[EV_REG_CHANGE_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    hIrmonEvents[EV_TRAY_STATUS_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Initialize all necessary globals to 0, FALSE, or NULL because
    // we might be restarting within the same services process
    pDeviceList->DeviceCount = 0;
    IconInTray = FALSE;
    IrmonStopped = FALSE;
    UserLoggedIn = FALSE;
    TrayEnabled = FALSE;

    DeviceListUpdated = FALSE;
    LastTrayUpdate = 0;
//    RetryLazyDscvTimerRunning = FALSE;
    RetryTrayUpdateTimerRunning = FALSE;
    hInRange = 0;
    WaveNumDev = NULL;
    RtlZeroMemory(&LinkStatus, sizeof(LinkStatus));

    ZeroMemory(&GlobalIrmonControl,sizeof(GlobalIrmonControl));

    InitializeCriticalSection(&GlobalIrmonControl.Lock);

#ifdef BUILD_SERVICE_EXE
    IrmonServiceStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    IrmonServiceStatus.dwCurrentState            = SERVICE_STOPPED;
    IrmonServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                                 | SERVICE_ACCEPT_PAUSE_CONTINUE;
    IrmonServiceStatus.dwWin32ExitCode           = NO_ERROR;
    IrmonServiceStatus.dwServiceSpecificExitCode = NO_ERROR;
    IrmonServiceStatus.dwCheckPoint              = 0;
    IrmonServiceStatus.dwWaitHint                = 0;


    IrmonStatusHandle = RegisterServiceCtrlHandler(IRMON_SERVICE_NAME,
                                                   ServiceHandler);

    if (!IrmonStatusHandle)
    {
        DEBUGMSG(("IRMON: RegisterServiceCtrlHandler failed %d\n",
                 GetLastError()));
        goto done;
    }

    DEBUGMSG(("IRMON: Start pending\n"));

    Error = IrmonUpdateServiceStatus(SERVICE_START_PENDING,
                                     NO_ERROR, 1, 25000);

    if (Error != NO_ERROR)
    {
        goto done;
    }

#endif

    LoadSoundApis();

    if (WSAStartup(WSAVerReq, &WSAData) != 0)
    {
        DEBUGMSG(("IRMON: WSAStartup failed\n"));
        Error = 1;
        goto done;
    }

    // Initialize OBEX and IrTran-P:
    bResult=InitializeIrxfer(
        &GlobalIrmonControl,
        AdhocNotworkNotification,
        SetLogonStatus,
        SetTrayStatus,
        SetSoundStatus,
        &GlobalIrmonControl.IrxferContext
        );


    if (bResult) {

        DEBUGMSG(("IRMON: Irxfer initialized\n"));

    } else {

        DEBUGMSG(("IRMON: Irxfer initializtion failed\n"));
        goto done;
    }

//    gTaskbarCreated = RegisterWindowMessage(TASK_BAR_CREATED);

    Wc.style            = CS_NOCLOSE;
    Wc.cbClsExtra       = 0;
    Wc.cbWndExtra       = 0;
    Wc.hInstance        = ghInstance;
    Wc.hIcon            = NULL;
    Wc.hCursor          = NULL;
    Wc.hbrBackground    = NULL;
    Wc.lpszMenuName     = NULL;
    Wc.lpfnWndProc      = WndProc;
    Wc.lpszClassName    = IrmonClassName;

    if (!RegisterClass(&Wc))
    {
        DEBUGMSG(("IRMON: failed to register class\n"));
    }

    IrmonStopped = FALSE;

    Error = IrmonUpdateServiceStatus(SERVICE_RUNNING,
                                     NO_ERROR, 0, 0);

    DEBUGMSG(("IRMON: Service running\n"));

    while (!IrmonStopped)
    {
        Status = MsgWaitForMultipleObjectsEx(WAIT_EVENT_CNT, hIrmonEvents, INFINITE,
                           QS_ALLINPUT | QS_ALLEVENTS | QS_ALLPOSTMESSAGE,
                           MWMO_ALERTABLE);

        switch (Status)
        {
            case WAIT_OBJECT_0 + EV_STOP_EVENT:
                IrmonStopped = TRUE;
                break;

            case WAIT_OBJECT_0 + EV_LOGON_EVENT:
                UserLogonEvent(&GlobalIrmonControl);
                break;

            case WAIT_OBJECT_0 + EV_LOGOFF_EVENT:
                UserLogoffEvent(&GlobalIrmonControl);
                break;

            case WAIT_OBJECT_0 + EV_REG_CHANGE_EVENT:
                if (UserLoggedIn)
                {
                    GetRegSoundData(hIrmonEvents[EV_REG_CHANGE_EVENT]);
                }
                break;

            case WAIT_OBJECT_0 + EV_TRAY_STATUS_EVENT:
                if (TrayEnabled)
                {
                    DevListChangeOrUpdatedLinkStatus(&GlobalIrmonControl);
                }
                else if (IconInTray)
                {
                    UpdateTray(&GlobalIrmonControl,ICON_ST_NOICON, 0, NULL, 0);
                }
                break;

            case WAIT_IO_COMPLETION:
                break;

            default:
                while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (Msg.message == WM_QUIT)
                    {
                        IrmonStopped = TRUE;
                        break;
                    }

                    if (!IsDialogMessage(GlobalIrmonControl.hWnd, &Msg))
                    {
                        TranslateMessage(&Msg);
                        DispatchMessage(&Msg);
                    }
                }
        }

    }

    if (UserLoggedIn) {

        UserLogoffEvent(&GlobalIrmonControl);
    }



    if (!UninitializeIrxfer(GlobalIrmonControl.IrxferContext)) {

        DEBUGMSG(("IRMON: Failed to unitialize irxfer!!\n"));
        IrmonStopped = FALSE;

    } else {

        DEBUGMSG(("IRMON: irxfer unitialized\n"));
    }


    UpdateTray(&GlobalIrmonControl,ICON_ST_NOICON, 0, NULL, 0);


done:

    DeleteCriticalSection(&GlobalIrmonControl.Lock);

    if (IrmonStatusHandle)
    {
        DEBUGMSG(("IRMON: Service stopped\n"));
        IrmonUpdateServiceStatus(SERVICE_STOPPED, Error, 0, 0);
    }
}

BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        ghInstance = hinst;
        DisableThreadLibraryCalls (hinst);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\controls.h ===
#ifndef __BUTTON_H
#define __BUTTON_H

#include <assert.h>

class Wnd {
public:
    Wnd(UINT ResID) : hDlg(NULL) { iResource = ResID; }
    ~Wnd() {}
    void SetWindowText(LPCTSTR lpszString) { 
        if (hDlg != NULL) { 
            assert(::IsWindow(hDlg)); ::SetWindowText(hDlg, lpszString); 
        } else { 
            assert(FALSE); } }
    HWND SetParent(HWND parent) { hDlg = GetDlgItem(parent, iResource); return hDlg;}

protected:
    HWND hDlg;
    UINT iResource;
};

class Button : public Wnd {

public:
    Button(UINT ResID) : Wnd(ResID) {}
    ~Button() {}

    int GetCheck() const
        { if (hDlg != NULL) { assert(::IsWindow(hDlg)); return (int)::SendMessage(hDlg, BM_GETCHECK, 0, 0); } return 0;}
    void SetCheck(int nCheck)
        { if (hDlg != NULL) { assert(::IsWindow(hDlg)); ::SendMessage(hDlg, BM_SETCHECK, nCheck, 0); } }

};

class Edit : public Wnd {
public:
    Edit(UINT ResID) : Wnd(ResID) {}
    ~Edit() {}

};


#endif // __BUTTON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by irsock.rc
//
#define IDD_DIALOG1                     101
#define IDC_LISTEN                      1000
#define IDC_DISCOVER                    1001
#define IDC_CONNECT                     1002
#define IDC_COMBO1                      1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\debug.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       DEBUG.CPP
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#include "precomp.hxx"
#include "debug.h"

#if DBG
ULONG IRDA_Debug_Trace_Level = LWARN;
#endif // DBG

void TRACE(LPCTSTR Format, ...) 
{
    va_list arglist;
    va_start(arglist, Format);

    TCHAR buf[200];

    wvsprintf(buf, Format, arglist);
    OutputDebugString(buf);

    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\resrc1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resrc1.h
//
//--------------------------------------------------------------------------


#ifndef APSTUDIO_INVOKED
#include <windows.h>
#include <ntverp.h>
#define VER_FILETYPE    VFT_DLL
#define VER_FILESUBTYPE VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Infrared Monitor"
#define VER_INTERNALNAME_STR        "irmon.dll"
#define VER_ORIGINALFILENAME_STR    "irmon.dll"
#include "common.ver"
#endif

#include "..\irxfer\resource.h"

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by irmon.rc
//
#define IDS_IN_RANGE                    1
#define IDS_DEVS_IN_RANGE               2
#define IDS_CONNECTED_TO                3
#define IDS_INTERRUPTED                 4
#define IDS_INRANGE_LABEL               5
#define IDS_OUTOFRANGE_LABEL            6
#define IDS_INTERRUPT_LABEL             7
#define IDS_WIRELESSLINK                8
#define IDS_BALLOON_TITLE               9
#define IDS_BALLOON_TXT                 10
#define IDS_BLOCKED_TITLE               11
#define IDS_BLOCKED_TXT                 12
#define IDS_BALLOON_TXT2                13
#define IDD_IRMON                       101
#define IDI_IN_RANGE                    107
#define IDI_RXTX                        147
#define IDI_TX                          151
#define IDI_RX                          152
#define IDI_INTR                        162
#define IDR_TRAY_MENU                   165
#define IDI_CONN1                       166
#define IDI_CONN2                       167
#define IDI_CONN3                       168
#define IDI_CONN4                       169
#define IDI_IP                          170
#define IDI_IDLE                        246
#define IDI_CON1                        251
#define IDC_DEVICES                     1008
#define IDC_ENUMDEVICES                 1009
#define IDC_STATUS                      1010
#define IDC_CONNECTTO                   1011
#define IDC_LISTENON                    1012
#define IDC_EDIT1                       1013
#define IDC_RX                          1013
#define IDC_FILE                        1013
#define IDC_SEND                        1014
#define IDC_CLOSE                       1015
#define IDC_EDIT2                       1016
#define IDC_CLASSNAME                   1016
#define IDC_IRLPT                       1017
#define IDC_PRINT                       1018
#define IDC_ATTRIBNAME                  1019
#define IDC_GVC                         1022
#define IDC_RXCNT                       1023
#define IDC_STOPRX                      1024
#define IDC_STARTRX                     1025
#define IDC_SENDSIZE                    1026
#define IDC_SENDCNT                     1027
#define IDC_BYTESEC                     1029
#define IDC_BUTTON1                     1030
#define IDC_PROGRESS1                   1031
#define IDC_TX_FILES                    40001
#define IDC_PROPERTIES                  40003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        170
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1033
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irmon\sound.c ===
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>

#include <resrc1.h>
#include "internal.h"

#define WINMM_DLL               TEXT("winmm.dll")
#define WAVE_GET_NUM_DEV_FN_NAME "waveOutGetNumDevs"
#define PLAY_SOUND_FN_NAME      "PlaySoundW"


typedef UINT (* WAVE_NUM_DEV_FN)(VOID);
typedef BOOL (* PLAY_SOUND_FN)( IN LPCWSTR pszSound, IN HMODULE hmod, IN DWORD fdwSound);


const WCHAR *InRangeLabelKey    = TEXT("AppEvents\\EventLabels\\InfraredInRange");
const WCHAR *OutOfRangeLabelKey = TEXT("AppEvents\\EventLabels\\InfraredOutOfRange");
const WCHAR *InterruptLabelKey  = TEXT("AppEvents\\EventLabels\\InfraredInterrupt");
const WCHAR *WirelessLinkKey    = TEXT("AppEvents\\Schemes\\Apps\\WirelessLink");
const WCHAR *InRangeSoundKey    = TEXT("AppEvents\\Schemes\\Apps\\WirelessLink\\InfraredInRange");
const WCHAR *OutOfRangeSoundKey = TEXT("AppEvents\\Schemes\\Apps\\WirelessLink\\InfraredOutOfRange");
const WCHAR *InterruptSoundKey  = TEXT("AppEvents\\Schemes\\Apps\\WirelessLink\\InfraredInterrupt");
const WCHAR *CurrentSoundKey    = TEXT(".Current");
const WCHAR *DefaultSoundKey    = TEXT(".Default");
const WCHAR *InRangeWav         = TEXT("ir_begin.wav");
const WCHAR *OutOfRangeWav      = TEXT("ir_end.wav");
const WCHAR *InterruptWav       = TEXT("ir_inter.wav");
const WCHAR *SystemInfoKey      = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
const WCHAR *SystemRootVal      = TEXT("SystemRoot");
const WCHAR *MediaPath          = TEXT("\\Media\\");


TCHAR                       gSystemRoot[64];
TCHAR                       InRangeWavPath[128];
TCHAR                       OutOfRangeWavPath[128];
TCHAR                       InterruptWavPath[128];

HKEY                        ghInRangeKey = 0;
HKEY                        ghOutOfRangeKey = 0;
HKEY                        ghInterruptKey = 0;


WAVE_NUM_DEV_FN             WaveNumDev;
PLAY_SOUND_FN               PlaySoundF;


BOOL
InitializeSound(
    HKEY   CurrentUserKey,
    HANDLE Event
    )

{

    if (CurrentUserKey)
    {

        CreateRegSoundData();

        // Open the wave file keys so we can monitor them for changes

        RegOpenKeyEx(CurrentUserKey, InRangeSoundKey, 0, KEY_READ, &ghInRangeKey);
        RegOpenKeyEx(CurrentUserKey, OutOfRangeSoundKey, 0, KEY_READ, &ghOutOfRangeKey);
        RegOpenKeyEx(CurrentUserKey, InterruptSoundKey, 0, KEY_READ, &ghInterruptKey);

        GetRegSoundData(Event);

    }


    return TRUE;
}

VOID
UninitializeSound(
    VOID
    )

{
    if (ghInRangeKey)
    {
        RegCloseKey(ghInRangeKey);
        ghInRangeKey = 0;
    }

    if (ghInterruptKey)
    {
        RegCloseKey(ghInterruptKey);
        ghInterruptKey = 0;
    }

    if (ghOutOfRangeKey)
    {
        RegCloseKey(ghOutOfRangeKey);
        ghOutOfRangeKey = 0;
    }


    return;
}


VOID
LoadSoundApis()
{
    HMODULE     hWinMm;

    // Load multimedia module and get wave player entry points

    if ((hWinMm = LoadLibrary(WINMM_DLL)) == NULL)
    {
        DEBUGMSG(("IRMON: failed to load winmm.dll\n")) ;
    }
    else
    {
        if (!(WaveNumDev = (WAVE_NUM_DEV_FN) GetProcAddress(hWinMm,
                                            WAVE_GET_NUM_DEV_FN_NAME)))
        {
            DEBUGMSG(("IRMON: GetProcAddress failed on WaveGetNumDevs\n"));
        }

        if (!(PlaySoundF = (PLAY_SOUND_FN) GetProcAddress(hWinMm,
                                            PLAY_SOUND_FN_NAME)))
        {
            DEBUGMSG(("IRMON: GetProcAddress failed on PlaySound\n"));
        }

    }
}

VOID
CreateRegSoundEventLabel(
    const WCHAR     *LabelKey,
    DWORD           LabelId)
{
    TCHAR           LabelStr[64];

    // Load the localizable string label for the sound event

    if (!LoadString(ghInstance, LabelId, LabelStr, sizeof(LabelStr)/sizeof(TCHAR)))
    {
        DEBUGMSG(("IRMON: LoadString failed %d\n", GetLastError()));
        return;
    }

    if (RegSetValue(ghCurrentUserKey, LabelKey, REG_SZ, LabelStr,
                   lstrlen(LabelStr)))
    {
        DEBUGMSG(("IRMON: RegSetValue failed %d\n", GetLastError()));
    }
}

VOID
CreateRegSoundScheme(
    TCHAR       *SystemRoot,
    const WCHAR *SoundKey,
    const WCHAR *WavFile)
{
    HKEY    hSoundKey;
    DWORD   Disposition;
    TCHAR   WavPath[128];


    if (RegCreateKeyEx(ghCurrentUserKey,
                       SoundKey,
                       0,                      // reserved MBZ
                       0,                      // class name
                       REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS,
                       0,                      // security attributes
                       &hSoundKey,
                       &Disposition))
    {
        DEBUGMSG(("IRMON: RegCreateKey failed %d\n", GetLastError()));
        return;
    }

    if (Disposition == REG_CREATED_NEW_KEY)
    {

        if (RegSetValue(hSoundKey, CurrentSoundKey, REG_SZ, WavFile,
                        lstrlen(WavFile)))
        {
            DEBUGMSG(("IRMON: RegSetValue failed %d\n", GetLastError()));
        }

        lstrcpy(WavPath, SystemRoot);
        lstrcat(WavPath, MediaPath);
        lstrcat(WavPath, WavFile);

        if (RegSetValue(hSoundKey, DefaultSoundKey, REG_SZ, WavPath,
                        lstrlen(WavPath)))
        {
            DEBUGMSG(("IRMON: RegSetValue failed %d\n", GetLastError()));
        }
    }

    RegCloseKey(hSoundKey);
}

VOID
CreateRegSoundData()
{
    DWORD           ValType;
    HKEY            hKey, hUserKey;
    LONG            Len;
    TCHAR           WirelessLinkStr[64];

    // Get the system root so we can add default registry values
    // i.e. Schemes\WirelessLink\InfraredInRange\.Default = "C:\winnt\media\irin.wav"
    //                                                       ^^^^^^^^

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SystemInfoKey, 0, KEY_READ, &hKey))
    {
        DEBUGMSG(("IRMON: RegOpenKey2 failed %d\n", GetLastError()));
        return;
    }

    Len = sizeof(gSystemRoot);

    if (RegQueryValueEx(hKey, SystemRootVal, 0, &ValType,
                        (LPBYTE) gSystemRoot, &Len))
    {
        DEBUGMSG(("IRMON: RegQueryValue failed %d\n", GetLastError()));
        return;
    }

    RegCloseKey(hKey);

    // Create the sound EventLabels and schemes if they don't exist

    CreateRegSoundEventLabel(InRangeLabelKey, IDS_INRANGE_LABEL);
    CreateRegSoundEventLabel(OutOfRangeLabelKey, IDS_OUTOFRANGE_LABEL);
    CreateRegSoundEventLabel(InterruptLabelKey, IDS_INTERRUPT_LABEL);

    if (!LoadString(ghInstance, IDS_WIRELESSLINK, WirelessLinkStr, sizeof(WirelessLinkStr)/sizeof(TCHAR)))
    {
        DEBUGMSG(("IRMON: LoadString failed %d\n", GetLastError()));
        return;
    }

    if (RegSetValue(ghCurrentUserKey, WirelessLinkKey, REG_SZ, WirelessLinkStr,
                   lstrlen(WirelessLinkStr)))
    {
        DEBUGMSG(("IRMON: RegSetValue failed %d\n", GetLastError()));
    }

    CreateRegSoundScheme(gSystemRoot, InRangeSoundKey, InRangeWav);
    CreateRegSoundScheme(gSystemRoot, OutOfRangeSoundKey, OutOfRangeWav);
    CreateRegSoundScheme(gSystemRoot, InterruptSoundKey, InterruptWav);

}

VOID
GetRegSoundWavPath(
    const WCHAR     *SoundKey,
    TCHAR           *SoundWavPath,
    LONG            PathLen)
{
    TCHAR   CurrRegPath[128];
    DWORD   ValType;
    HKEY    hSoundKey;
    int     i;
    BOOLEAN FullPath = FALSE;

    lstrcpy(CurrRegPath, SoundKey);
    lstrcat(CurrRegPath, TEXT("\\"));
    lstrcat(CurrRegPath, CurrentSoundKey);

    if (RegOpenKeyEx(ghCurrentUserKey, CurrRegPath, 0, KEY_READ, &hSoundKey))
    {
        DEBUGMSG(("IRMON: RegOpenKey3 failed %d\n", GetLastError()));
        return;
    }

    if (RegQueryValueEx(hSoundKey, NULL, 0, &ValType,
                        (LPBYTE) SoundWavPath, &PathLen))
    {
        DEBUGMSG(("IRMON: RegQueryValue failed %d\n", GetLastError()));
        RegCloseKey(hSoundKey);
        return;
    }


    // the PlaySound API does not look in \winnt\media for
    // wav files when a filename is specified, so if this is not a full
    // pathname then we'll need to add "c:\winnt\media" to the WavPath.
    // I'm counting on a path without '\' as an indication that it is relative.

    for (i = 0; i < lstrlen(SoundWavPath); i++)
    {
        if (SoundWavPath[i] == TEXT('\\'))
        {
            FullPath = TRUE;
            break;
        }
    }

    if (!FullPath && lstrlen(SoundWavPath) != 0)
    {
         TCHAR  TempStr[64];

         lstrcpy(TempStr, SoundWavPath);
         lstrcpy(SoundWavPath, gSystemRoot);
         lstrcat(SoundWavPath, MediaPath);
         lstrcat(SoundWavPath, TempStr);
    }

    RegCloseKey(hSoundKey);
}

VOID
GetRegSoundData(
    HANDLE    Event
    )
{
    GetRegSoundWavPath(InRangeSoundKey, InRangeWavPath, sizeof(InRangeWavPath));

//    DEBUGMSG(("IRMON: In range wav: %ws\n", InRangeWavPath));

    GetRegSoundWavPath(OutOfRangeSoundKey, OutOfRangeWavPath, sizeof(OutOfRangeWavPath));

//    DEBUGMSG(("IRMON: Out of range wav: %ws\n", OutOfRangeWavPath));

    GetRegSoundWavPath(InterruptSoundKey, InterruptWavPath, sizeof(InterruptWavPath));

//    DEBUGMSG(("IRMON: Interrupt wav: %ws\n", InterruptWavPath));

    RegNotifyChangeKeyValue(ghInRangeKey,
                            TRUE,              // watch child keys
                            REG_NOTIFY_CHANGE_LAST_SET,
                            Event,
                            TRUE);               // async

    RegNotifyChangeKeyValue(ghOutOfRangeKey,
                            TRUE,              // watch child keys
                            REG_NOTIFY_CHANGE_LAST_SET,
                            Event,
                            TRUE);               // async

    RegNotifyChangeKeyValue(ghInterruptKey,
                            TRUE,              // watch child keys
                            REG_NOTIFY_CHANGE_LAST_SET,
                            Event,
                            TRUE);               // async

}

VOID
PlayIrSound(IRSOUND_EVENT SoundEvent)
{
    int     Beep1, Beep2, Beep3;
    BOOL    SoundPlayed = FALSE;
    LPWSTR  WaveSound;
    DWORD   Flags = 0;


    if (!WaveNumDev)
    {
        LoadSoundApis();
    }

    switch (SoundEvent)
    {
        case INRANGE_SOUND:
            WaveSound = InRangeWavPath;

            Beep1 = 200;
            Beep2 = 250;
            Beep3 = 300;
            break;

        case OUTOFRANGE_SOUND:
            WaveSound = OutOfRangeWavPath;
            Beep1 = 300;
            Beep2 = 250;
            Beep3 = 200;
            break;

        case INTERRUPTED_SOUND:
            WaveSound = InterruptWavPath;
            Flags = SND_LOOP;
            Beep1 = 500;
            Beep2 = 350;
            Beep3 = 500;
            break;

        case END_INTERRUPTED_SOUND:
            WaveSound = NULL;
            SoundPlayed = TRUE;
            break;
    }

    if (SoundEvent != END_INTERRUPTED_SOUND && lstrlen(WaveSound) == 0) {
        //
        //  the path of sound file is a null string, can't play anything
        //
        SoundPlayed = TRUE;

    } else if (WaveNumDev && PlaySoundF && WaveNumDev() > 0) {
        //
        //  the functions are availible and there is at least on wave device
        //
        SoundPlayed = PlaySoundF(
                          WaveSound,
                          (HMODULE) NULL,
                          SND_FILENAME | SND_ASYNC | Flags
                          );

        if (WaveSound == NULL) {
            //
            //  we just wanted to stop the wave, set this to true so it will not try to beep
            //
            SoundPlayed=TRUE;
        }

    }

    if (!SoundPlayed) {
        //
        //  could not play a wave, just uses beeps
        //
        DEBUGMSG(("Not Wave enabled\n"));

        Beep(Beep1, 100);
        Beep(Beep2, 100);
        Beep(Beep3, 100);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\debug.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*  TITLE:       DEBUG.H
*  VERSION:     1.0
*  AUTHOR:      jsenior
*  DATE:        10/28/1998
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE       REV     DESCRIPTION
*  ---------- ------- ----------------------------------------------------------
*  10/28/1998 jsenior Original implementation.
*
*******************************************************************************/
#ifndef __IRDADEBUG_H__
#define __IRDADEBUG_H__

void TRACE(LPCTSTR Format, ...);

#if DBG

#define LERROR 1
#define LWARN 2
#define LTRACE 3
#define LINFO 4

extern ULONG IRDA_Debug_Trace_Level;
#define IRDA_Print(l, _x_) if ((l) <= IRDA_Debug_Trace_Level) \
    {   TRACE (_T("IRCPL: ")); \
        TRACE _x_; \
        TRACE (_T("\n")); }
#define IRWARN(_x_) IRDA_Print(LWARN, _x_)
#define IRERROR(_x_) IRDA_Print(LERROR, _x_)
#define IRTRACE(_x_) IRDA_Print(LTRACE, _x_)
#define IRINFO(_x_) IRDA_Print(LINFO, _x_)

#else // DBG

#define IRDA_Print(l, _x_)

#define IRWARN(_x_)
#define IRERROR(_x_)
#define IRTRACE(_x_)
#define IRINFO(_x_)

#endif // DBG

#endif //  __IRDADEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\dialog.cpp ===
#include "precomp.hxx"
#include "dialog.h"

INT_PTR Dialog::DialogStaticDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    Dialog *pThis;

    pThis = (Dialog*) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG) {
        pThis = (Dialog *) lParam;
        pThis->hDlg = hDlg;
        SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR) pThis);

        return pThis->OnInitDialog(hDlg);
    }

    if (pThis) {
        return pThis->MainDlgProc(msg, wParam, lParam);
    }

    return FALSE;
}

INT_PTR Dialog::MainDlgProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_COMMAND:
        HandleCommand((UINT) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        return FALSE;

    case WM_HELP:
        return OnHelp((LPHELPINFO) lParam);
    
    case WM_CONTEXTMENU:
        return OnContextMenu(wParam, lParam);
    
    case WM_NOTIFY:
        return OnNotify((NMHDR *)lParam);
    }

    return DlgProc(msg, wParam, lParam);
}

void Dialog::HandleCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify)
{
    switch (ctrlId) {
    case IDOK:
        OnOK();
        break; 

    case IDCANCEL:
        OnCancel();
        break; 

    default:
        OnCommand(ctrlId, hwndCtrl, cNotify);
        break;
   }
}

UINT Dialog::ShowModal(HWND hwndParent)
{
    DialogBoxParam(hInstance,
                   MAKEINTRESOURCE(resID),
                   hwndParent,
                   DialogStaticDlgProc,
                   (DWORD_PTR) this);

    return result;
}

HICON Dialog::SetIcon(UINT iconID, BOOL bLarge)
{
    HICON hIcon;
    int size;

    size = bLarge ? 32 : 16;

    hIcon = (HICON) LoadImage(hInstance,
                              MAKEINTRESOURCE(iconID),
                              IMAGE_ICON,
                              size,
                              size,
                              0);
                               
    return (HICON)
        ::SendMessage(hDlg,
                      WM_SETICON,
                      bLarge ? ICON_BIG : ICON_SMALL,
                      (LPARAM) hIcon);
}

void Dialog::CenterWindow(HWND hwnd)
{
    RECT me;
    RECT parent;

    if (hwnd == NULL) {
        hwnd = GetDesktopWindow();
    }

    GetWindowRect(hDlg, &me);
    GetWindowRect(hwnd, &parent);

    int meWidth = me.right - me.left,
        meHeight = me.bottom - me.top;

    int parentWidth = parent.right - parent.left,
        parentHeight = parent.bottom - parent.top;

    int widthOffset = (parentWidth - meWidth)/2,
        heightOffset = (parentHeight - meHeight)/2;

    me.left = parent.left + widthOffset;
    me.top = parent.top + heightOffset;

    SetWindowPos(hDlg, 
                 NULL,
                 me.left,
                 me.top,
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\dialog.h ===
#ifndef __DIALOG_H
#define __DIALOG_H

class Dialog {

public:
    Dialog(UINT ResID, HINSTANCE hInst) : resID(ResID), hDlg(NULL), hInstance(hInst) {}
    virtual ~Dialog() {}

    virtual UINT ShowModal(HWND hwndParent = NULL);

    virtual INT_PTR OnInitDialog(HWND hwndDlg) { hDlg = hwndDlg; return TRUE; }
    INT_PTR MainDlgProc(UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    static INT_PTR DialogStaticDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    virtual INT_PTR DlgProc(UINT msg, WPARAM wParam, LPARAM lParam) { return FALSE; }

    virtual void OnOK() { result = IDOK; EndDialog(hDlg, IDOK);}
    virtual void OnCancel() { result = IDCANCEL; EndDialog(hDlg, IDCANCEL);}

    virtual BOOL OnHelp(LPHELPINFO pHelpInfo) { return FALSE; }
    virtual BOOL OnContextMenu (WPARAM wParam, LPARAM lParam) { return FALSE; }
    void HandleCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify);
    virtual void OnCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify) {}
    virtual INT_PTR OnNotify(NMHDR * nmhdr) {return FALSE;}

    HICON SetIcon(UINT iconID, BOOL bLarge = TRUE);
    void CenterWindow(HWND hwnd = NULL);

    HINSTANCE hInstance;
    HWND hDlg;
    UINT resID;
    UINT result;
};


#endif // __DIALOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\filetransferpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       filetransferpage.cpp
//
//--------------------------------------------------------------------------

// FileTransferPage.cpp : implementation file
//

#include "precomp.hxx"
#include "filetransferpage.h"
#include "debug.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const DWORD g_FileTransferHelp[] = {
    IDC_DISPLAYTRAY,            IDH_DISPLAYTRAY,
    IDC_SENDFILESGROUP,         IDH_DISABLEHELP,
    IDC_ALLOWSEND,              IDH_ALLOWSEND,
    IDC_DISPLAYRECV,            IDH_DISPLAYRECV,
    IDC_LOCATIONTITLE,          IDH_LOCATIONTITLE,
    IDC_RECEIVEDFILESLOCATION,  IDH_RECEIVEDFILESLOCATION,
    IDC_CHOOSEFILELOCATION,     IDH_CHOOSEFILELOCATION,
    IDC_SOUND,                  IDH_PLAYSOUND,
    0,  0
};

/////////////////////////////////////////////////////////////////////////////
// FileTransferPage property page

void FileTransferPage::OnCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify)
{
    IRINFO((_T("FileTransferPage::OnCommand")));
    switch (ctrlId) {
    case IDC_ALLOWSEND:
        OnAllowsend();
        break;
    case IDC_DISPLAYRECV:
        OnDisplayrecv();
        break;
    case IDC_DISPLAYTRAY:
        OnDisplaytray();
        break;
    case IDC_CHOOSEFILELOCATION:
        OnChoosefilelocation();
        break;
    case IDC_SOUND:
        OnPlaySound();
        break;
    }
}

INT_PTR FileTransferPage::OnNotify(NMHDR * nmhdr)
{
    switch (nmhdr->code)
    {
        case NM_CLICK:
            switch (nmhdr->idFrom)
            {
                case IDC_NETWORKCONNECTIONS_LINK:
                    return OnNetworkConnectionsLink();
            }
        break;
    }

    return PropertyPage::OnNotify(nmhdr);
}
/////////////////////////////////////////////////////////////////////////////
// Opens the Network Connections Folder
BOOL FileTransferPage::OnNetworkConnectionsLink()
{
    // This is: ::{CLSID_MyComputer}\::{CLSID_ControlPanel}\::{CLSID_NetworkConnections}
    if (ShellExecute(NULL, NULL, L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{7007ACC7-3202-11D1-AAD2-00805FC1270E}", L"", NULL, SW_SHOWNORMAL) > reinterpret_cast<HINSTANCE>(32))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// FileTransferPage message handlers

void FileTransferPage::OnAllowsend()
{
    int AllowSend = m_cbAllowSend.GetCheck();
    if (AllowSend != m_fAllowSend)
        m_ChangeMask |= CHANGE_ALLOW_FILE_XFER;
    else
        m_ChangeMask &= ~(CHANGE_ALLOW_FILE_XFER);
    SetModified(m_ChangeMask);
}

void FileTransferPage::OnDisplayrecv()
{
    int DisplayRecv = m_cbDisplayRecv.GetCheck();
    if (DisplayRecv != m_fDisplayRecv)
        m_ChangeMask |= CHANGE_NOTIFY_ON_FILE_XFER;
    else
        m_ChangeMask &= ~(CHANGE_NOTIFY_ON_FILE_XFER);
    SetModified(m_ChangeMask);
}

void FileTransferPage::OnDisplaytray()
{
    int DisplayIcon = m_cbDisplayTray.GetCheck();
    if (DisplayIcon != m_fDisplayTray)
        m_ChangeMask |= CHANGE_DISPLAY_ICON;
    else
        m_ChangeMask &= ~(CHANGE_DISPLAY_ICON);
    SetModified(m_ChangeMask);
}


void FileTransferPage::OnPlaySound()
{
    int NewState = m_cbPlaySound.GetCheck();
    if (NewState != m_fPlaySound)
        m_ChangeMask |= CHANGE_PLAY_SOUND;
    else
        m_ChangeMask &= ~(CHANGE_PLAY_SOUND);
    SetModified(m_ChangeMask);
}


INT_PTR FileTransferPage::OnInitDialog(HWND hwndDlg)
{
    PropertyPage::OnInitDialog(hwndDlg);

    m_recvdFilesLocation.SetParent(hwndDlg);
    m_cbDisplayTray.SetParent(hwndDlg);
    m_cbDisplayRecv.SetParent(hwndDlg);
    m_cbAllowSend.SetParent(hwndDlg);
    m_cbPlaySound.SetParent(hwndDlg);
    
    IRINFO((_T("FileTransferPage::OnInitDialog")));
    
    LoadRegistrySettings();
    m_cbAllowSend.SetCheck(m_fAllowSend);
    m_cbDisplayRecv.SetCheck(m_fDisplayRecv);
    m_cbDisplayTray.SetCheck(m_fDisplayTray);
    m_recvdFilesLocation.SetWindowText(m_FinalDestLocation);
    m_cbPlaySound.SetCheck(m_fPlaySound);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void FileTransferPage::LoadRegistrySettings(void)
{
    HKEY hIrKey = NULL;
    HKEY hftKey = NULL;
    DWORD iSize = sizeof(DWORD);
    DWORD data = 0;
    TCHAR lpszReceivedFilesLocation[MAX_PATH];

    IRINFO((_T("FileTransferPage::LoadRegistrySettings")));
    RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Control Panel\\Infrared\\File Transfer"),
                    0, KEY_READ, &hftKey);
    RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Control Panel\\Infrared\\Global"),
                    0, KEY_READ, &hIrKey);

    if (!hIrKey && !hftKey)
        return;


    if (hIrKey) {

        if (ERROR_SUCCESS ==
                    RegQueryValueEx (hIrKey, TEXT("ShowTrayIcon"), NULL, NULL,
                                        (LPBYTE)&data, &iSize))
             m_fDisplayTray = data?TRUE:FALSE;

        iSize=sizeof(data);

        if (ERROR_SUCCESS ==
                RegQueryValueEx (hIrKey, TEXT("PlaySound"), NULL, NULL,
                                    (LPBYTE)&data, &iSize))
            m_fPlaySound = data?TRUE:FALSE;

    }

    iSize=sizeof(data);

    if (hftKey && ERROR_SUCCESS ==
                RegQueryValueEx (hftKey, TEXT("AllowSend"), NULL, NULL,
                                    (LPBYTE)&data, &iSize))
            m_fAllowSend = data?TRUE:FALSE;

    iSize=sizeof(data);

    if (hftKey && ERROR_SUCCESS ==
                RegQueryValueEx (hftKey, TEXT("ShowRecvStatus"), NULL, NULL,
                                    (LPBYTE)&data, &iSize))
            m_fDisplayRecv = data?TRUE:FALSE;



    // If the destionation location is not specified,
    // use the default(Desktop subfolder).
    // Create it if necessary.
    SHGetSpecialFolderPath (hDlg, m_FinalDestLocation,
                            CSIDL_DESKTOPDIRECTORY, 0);
    
    iSize = MAX_PATH * sizeof (TCHAR);
    if (hftKey && ERROR_SUCCESS ==
                RegQueryValueEx (hftKey, TEXT("RecvdFilesLocation"), NULL,
                                    NULL, (LPBYTE)lpszReceivedFilesLocation, &iSize))
            lstrcpy(m_FinalDestLocation, lpszReceivedFilesLocation);

    //
    // m_TempDestLocation will be used as the intial
    // folder of choice for SHBrowseForFolder call.
    //
    lstrcpy(m_TempDestLocation, m_FinalDestLocation);
    
    if (hIrKey)
        RegCloseKey(hIrKey);
    if (hftKey)
        RegCloseKey(hftKey);

}

void FileTransferPage::SaveSettingsToRegistry(void)
{
    HKEY hIrKey = NULL;
    HKEY hftKey = NULL;
    DWORD dwDisposition;

    IRINFO((_T("FileTransferPage::SaveSettingsToRegistry")));
    RegCreateKeyEx (HKEY_CURRENT_USER, TEXT("Control Panel\\Infrared\\File Transfer"),
                        0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                        NULL, &hftKey, &dwDisposition);

    RegCreateKeyEx (HKEY_CURRENT_USER, TEXT("Control Panel\\Infrared\\Global"),
                        0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                        NULL, &hIrKey, &dwDisposition);

    if (hIrKey)
    {
        RegSetValueEx(hIrKey, TEXT("ShowTrayIcon"), 0, REG_BINARY,
                        (CONST BYTE*)&m_fDisplayTray, 1);

        RegSetValueEx(hIrKey, TEXT("PlaySound"), 0, REG_BINARY,
                        (CONST BYTE*)&m_fPlaySound, 1);

        RegCloseKey(hIrKey);
    }

    if (hftKey)
    {
        RegSetValueEx(hftKey, TEXT("AllowSend"), 0, REG_BINARY,
                        (CONST BYTE*)&m_fAllowSend, 1);
        RegSetValueEx(hftKey, TEXT("ShowRecvStatus"), 0, REG_BINARY,
                        (CONST BYTE*)&m_fDisplayRecv, 1);


        RegSetValueEx(hftKey, TEXT("RecvdFilesLocation"), 0, REG_SZ,
                        (CONST BYTE*)&m_FinalDestLocation, sizeof(TCHAR)*lstrlen(m_FinalDestLocation));
        RegCloseKey(hftKey);
    }
}

int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    WPARAM sendWParam;
    LPARAM sendLParam;
    LPCTSTR lpszFilesLocation;
    TCHAR szErrorMsg[MAX_PATH];
    TCHAR szErrorTitle[MAX_PATH];
    HINSTANCE hInstanceRes;

    IRINFO((_T("FileTransferPage::BrowseCallbackProc")));
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        lpszFilesLocation = (LPCTSTR)lpData;
        sendWParam = TRUE;
        sendLParam = (LPARAM)lpszFilesLocation;
        SendMessage(hwnd, BFFM_SETSELECTION, sendWParam, sendLParam);
        break;
    case BFFM_VALIDATEFAILED:
        hInstanceRes = gHInst;
        ::LoadString (hInstanceRes, IDS_INVALID_MSG, szErrorMsg, MAX_PATH);
        ::LoadString (hInstanceRes, IDS_INVALID_TITLE, szErrorTitle, MAX_PATH);
        ::MessageBox (hwnd, szErrorMsg, szErrorTitle, MB_OK | MB_ICONSTOP);
        return 1;
    default:
        break;
    }

    return 0;
}

void FileTransferPage::OnChoosefilelocation()
{
    BROWSEINFO browseInfo;
    TCHAR pszSelectedFolder[MAX_PATH];
    LPITEMIDLIST lpItemIDList;
    LPMALLOC pMalloc;
    TCHAR szBrowseTitle [MAX_PATH];

    IRINFO((_T("FileTransferPage::OnChoosefileLocation")));
    //load the title
    ::LoadString (hInstance, IDS_FILEFOLDER_PROMPT,
                  szBrowseTitle, MAX_PATH);
    browseInfo.hwndOwner = hDlg;
    browseInfo.pidlRoot = NULL; //this will get the desktop folder
    browseInfo.pszDisplayName = pszSelectedFolder;
    browseInfo.lpszTitle = szBrowseTitle;
    browseInfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS |
                            BIF_VALIDATE | BIF_EDITBOX;
    browseInfo.lpfn = BrowseCallback;
    browseInfo.lParam = (LPARAM)m_TempDestLocation;

    if (NULL != (lpItemIDList = SHBrowseForFolder (&browseInfo)))
    {
        //the user chose the OK button in the browse dialog box
        SHGetPathFromIDList(lpItemIDList, pszSelectedFolder);
        lstrcpy (m_TempDestLocation, pszSelectedFolder);
        m_recvdFilesLocation.SetWindowText(m_TempDestLocation);
        if (lstrcmpi(m_TempDestLocation, m_FinalDestLocation))
            m_ChangeMask |= CHANGE_FILE_LOCATION;
        else
            m_ChangeMask &= ~(CHANGE_FILE_LOCATION);
        
        SetModified(m_ChangeMask);
        SHGetMalloc(&pMalloc);
        pMalloc->Free (lpItemIDList);   //free the item id list as we do not need it any more
        pMalloc->Release();
    }
}

void FileTransferPage::OnApply(LPPSHNOTIFY lppsn)
{
    IRINFO((_T("FileTransferPage::OnApply")));
    if (m_ChangeMask)
    {
        if (m_ChangeMask & CHANGE_FILE_LOCATION)
            lstrcpy(m_FinalDestLocation, m_TempDestLocation);

        if (m_ChangeMask & CHANGE_ALLOW_FILE_XFER)
            m_fAllowSend = m_cbAllowSend.GetCheck();

        if (m_ChangeMask & CHANGE_NOTIFY_ON_FILE_XFER)
            m_fDisplayRecv = m_cbDisplayRecv.GetCheck();

        if (m_ChangeMask & CHANGE_DISPLAY_ICON)
            m_fDisplayTray = m_cbDisplayTray.GetCheck();

        if (m_ChangeMask & CHANGE_PLAY_SOUND)
            m_fPlaySound = m_cbPlaySound.GetCheck();


        SaveSettingsToRegistry();
        m_ChangeMask = 0;
    }
    PropertyPage::OnApply(lppsn);
}

BOOL FileTransferPage::OnHelp (LPHELPINFO pHelpInfo)
{
    TCHAR szHelpFile[MAX_PATH];

    IRINFO((_T("FileTransferPage::OnHelp")));
    
    ::LoadString(hInstance, IDS_HELP_FILE, szHelpFile, MAX_PATH);

    ::WinHelp((HWND)(pHelpInfo->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_FileTransferHelp);

    return FALSE;
}

BOOL FileTransferPage::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    TCHAR szHelpFile[MAX_PATH];

    IRINFO((_T("FileTransferPage::OnContextMenu")));
    ::LoadString(hInstance, IDS_HELP_FILE, szHelpFile, MAX_PATH);

    ::WinHelp((HWND) wParam,
            (LPCTSTR) szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID)g_FileTransferHelp);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\filetransferpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       filetransferpage.h
//
//--------------------------------------------------------------------------

#ifndef __FILETRANSFERPAGE_H__
#define __FILETRANSFERPAGE_H__

// FileTransferPage.h : header file
//

#include "PropertyPage.h"
#include "Controls.h"

#define CHANGE_DISPLAY_ICON             0x10
#define CHANGE_ALLOW_FILE_XFER          0x20
#define CHANGE_NOTIFY_ON_FILE_XFER      0x40
#define CHANGE_FILE_LOCATION            0x80
#define CHANGE_PLAY_SOUND               0x08

/////////////////////////////////////////////////////////////////////////////
// CFileTransferPage dialog

class FileTransferPage : public PropertyPage
{
// Construction
public:
    FileTransferPage(HINSTANCE hInst, HWND parent) : 
        PropertyPage(IDD_FILETRANSFER, hInst), 
        m_recvdFilesLocation(IDC_RECEIVEDFILESLOCATION),
        m_cbDisplayTray(IDC_DISPLAYTRAY),
        m_cbDisplayRecv(IDC_DISPLAYRECV),
        m_cbPlaySound(IDC_SOUND),
        m_cbAllowSend(IDC_ALLOWSEND) {
        m_fAllowSend = m_fDisplayRecv = m_fDisplayTray = m_fPlaySound = TRUE;
        m_FinalDestLocation[0] = _T('\0'); 
        m_TempDestLocation[0] = _T('\0'); 
        m_ChangeMask = 0;}
    ~FileTransferPage() { ; }
    friend LONG CALLBACK CPlApplet(HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2);


// Dialog Data
    Edit   m_recvdFilesLocation;
    Button m_cbDisplayTray;
    Button m_cbDisplayRecv;
    Button m_cbAllowSend;
    Button m_cbPlaySound;


// Overrides
public:
    void OnApply(LPPSHNOTIFY lppsn);
protected:

// Implementation
protected:
    void OnAllowsend();
    void OnPlaySound();
    void OnDisplayrecv();
    void OnDisplaytray();
    INT_PTR OnInitDialog(HWND hwndDlg);
    void OnChoosefilelocation();
    BOOL OnHelp (LPHELPINFO pHelpInfo);
    BOOL OnContextMenu (WPARAM wParam, LPARAM lParam);
    void OnCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify);
    BOOL OnNetworkConnectionsLink();
    INT_PTR OnNotify(NMHDR * nmhdr);

private:
    TCHAR m_FinalDestLocation[MAX_PATH];
    TCHAR m_TempDestLocation[MAX_PATH];
    void SaveSettingsToRegistry (void);
    void LoadRegistrySettings(void);
    BOOL m_fDisplayTray;
    BOOL m_fDisplayRecv;
    BOOL m_fAllowSend;
    BOOL m_fPlaySound;
    DWORD m_ChangeMask;
};

extern HINSTANCE gHInst;

#endif // __FILETRANSFERPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\hardwarepage.h ===
#ifndef __HARDWAREPAGE_H__
#define __HARDWAREPAGE_H__

#include "PropertyPage.h"

/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    HardwarePage.h

Abstract:



Author:

    Rahul Thombre (RahulTh) 11/4/1998

Revision History:

    11/4/1998   RahulTh         Created this module.

--*/

/////////////////////////////////////////////////////////////////////////////
// CHardwarePage dialog

class HardwarePage : public PropertyPage
{
// Construction
public:
    HardwarePage(HINSTANCE hInst, HWND parent) : PropertyPage(IDD_HARDWARE, hInst) { }
    ~HardwarePage() { }
    friend LONG CALLBACK CPlApplet(HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2);

// Overrides
protected:

// Implementation
protected:
    INT_PTR OnInitDialog(HWND hwndDlg);
};

#endif // !defined(__HARDWAREPAGE_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\hardwarepage.cpp ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    HardwarePage.cpp

Abstract:
    the hardware tab for the wireless link control panel applet.
    the functionality is actually completely obtained from devmgr.dll
    which is responsible for putting everything on the property page
    the key function for this is DeviceCreateHardwarePage



Author:

    Rahul Thombre (RahulTh) 11/4/1998

Revision History:

    11/4/1998   RahulTh         Created this module.

--*/

#include "precomp.hxx"
#include <initguid.h>
#include <devguid.h>    //for the GUID for the infrared device class.
#include "hardwarepage.h"

//the function used to create the hardware page.
//there is no devmgr.h, so we have to declare it ourselves.
EXTERN_C DECLSPEC_IMPORT HWND STDAPICALLTYPE
DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode);

// stolen from \nt\shell\inc\hwtab.h
#define HWTAB_SMALLLIST 3

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define NUM_WIRELESS_GUIDS 2

/////////////////////////////////////////////////////////////////////////////
// HardwarePage property page

INT_PTR HardwarePage::OnInitDialog(HWND hwndDlg)
{
    PropertyPage::OnInitDialog(hwndDlg);

    GUID guids[NUM_WIRELESS_GUIDS];

    guids[0] = GUID_DEVCLASS_INFRARED;
    guids[1] = GUID_DEVCLASS_BLUETOOTH;

    HWND hWndHW =
        DeviceCreateHardwarePageEx(hwndDlg, guids, NUM_WIRELESS_GUIDS, HWTAB_SMALLLIST);

    if (hWndHW)
    {
        ::SetWindowText(hWndHW,
                        TEXT("hh.exe mk:@MSITStore:tshoot.chm::/tshardw_result.htm"));

        return FALSE;
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\helparr.h ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1999

Module Name:

    HelpArr.h

Abstract:

    contains the context help identifiers for all the UI elements


Author:

    Rahul Thombre (RahulTh) 11/4/1998

Revision History:

    11/4/1998   RahulTh         Created this module.

--*/

#ifndef __HELPARR_H__
#define __HELPARR_H__

#define IDH_DISABLEHELP         ((DWORD) -1)

//help ids for various controls
//the names of the ids were created by replacing the third character of the
//names of their corresponding controls with an H

//controls on the file transfer page
#define IDH_DISPLAYTRAY             1001
#define IDH_ALLOWSEND               1003
#define IDH_DISPLAYRECV             1004
#define IDH_LOCATIONTITLE           1005  // won't use in help, reference IDC to next one
#define IDH_RECEIVEDFILESLOCATION   1005
#define IDH_CHOOSEFILELOCATION      1006
#define IDH_PLAYSOUND               1007

//controls on the image transfer page
#define IDH_IMAGEXFER_ENABLE_IRCOMM         1101
#define IDH_IMAGEXFER_DESTDESC              1103 // won't use in help, reference IDC to next one
#define IDH_IMAGEXFER_DEST                  1103
#define IDH_IMAGEXFER_BROWSE                1104
#define IDH_IMAGEXFER_EXPLOREONCOMPLETION   1105

#endif  //!defined (__HELPARR_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\imagetransferpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       imagetransferpage.cpp
//
//--------------------------------------------------------------------------

// ImageTransferPage.cpp : implementation file
//

#include "precomp.hxx"
#include "imagetransferpage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//context ids for context help
const DWORD g_ImageTransferHelp [] = {
    IDC_IMAGEXFER_ENABLE_IRCOMM,        IDH_IMAGEXFER_ENABLE_IRCOMM,
    IDC_IMAGEXFER_DESTGROUP,            IDH_DISABLEHELP,
    IDC_IMAGEXFER_DESTDESC,             IDH_IMAGEXFER_DESTDESC,
    IDC_IMAGEXFER_DEST,                 IDH_IMAGEXFER_DEST,
    IDC_IMAGEXFER_BROWSE,               IDH_IMAGEXFER_BROWSE,
    IDC_IMAGEXFER_EXPLOREONCOMPLETION,  IDH_IMAGEXFER_EXPLOREONCOMPLETION,
    0, 0
};

//
// Registry entries that control IrTranP image transfer behavior.
// Everything is under HKEY_CURRENT_USER\\Control Panel\\Infrared\IrTranP
// subkey. Whenever there are changes, they are recorded in the registry
// and the service(IrMon) would pick up the changes by RegNotifyChangeKeyValue
// API.
//
//
//
TCHAR const REG_PATH_IRTRANP_CPL[] = TEXT("Control Panel\\Infrared\\IrTranP");


//
// Entry that controls if IrTranPV1 service should be disabled.
// The type is REG_DWORD. Default is enabled(either the entry
// does not exist or the value is zero).
//
TCHAR const REG_STR_DISABLE_IRTRANPV1[] = TEXT("DisableIrTranPv1");

//
// Entry that controls if IrCOMM should be disabled.
// The type is REG_DWORD. Default is enabled(either the entry
// does not exist or the value is zero).
//
TCHAR const REG_STR_DISABLE_IRCOMM[] = TEXT("DisableIrCOMM");


// Entry that specifies the image file destionation subfolder.
// The type is REG_SZ. The default is Shell special folder CSIDL_MYPICTURES
// (if the entry does not exist).
//
TCHAR const REG_STR_DESTLOCATION[] = TEXT("RecvdFilesLocation");

//
// Entry that controls if IrMon should explore the picture subfolder
// when image transfer(s) are done. The type is REG_DWORD.
// Default is enabled(the entry does not exist of its value is
// non-zero.
//
TCHAR const REG_STR_EXPLORE_ON_COMPLETION[] = TEXT("ExploreOnCompletion");



/////////////////////////////////////////////////////////////////////////////
// ImageTransferPage property page

void ImageTransferPage::OnCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify)
{
    switch (ctrlId) {
    case IDC_IMAGEXFER_EXPLOREONCOMPLETION:
        OnEnableExploring();
        break;
    case IDC_IMAGEXFER_BROWSE:
        OnBrowse();
        break;
    case IDC_IMAGEXFER_ENABLE_IRCOMM:
        OnEnableIrCOMM();
        break;
    }
}

/////////////////////////////////////////////////////////////////////////////
// ImageTransferPage message handlers

void ImageTransferPage::OnBrowse()
{
    BROWSEINFO browseInfo;
    TCHAR pszSelectedFolder[MAX_PATH];
    TCHAR pszTitle[MAX_PATH];
    LPITEMIDLIST lpItemIDList;
    LPMALLOC pMalloc;

    // load the title string
    ::LoadString(hInstance, IDS_IMAGEFOLDER_PROMPT, pszTitle,
             sizeof(pszTitle) / sizeof(TCHAR));
    browseInfo.hwndOwner = hDlg;
    browseInfo.pidlRoot = NULL; //this will get the desktop folder
    browseInfo.pszDisplayName = pszSelectedFolder;
    browseInfo.lpszTitle = pszTitle;
    browseInfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS |
                            BIF_VALIDATE | BIF_EDITBOX;
    browseInfo.lpfn = BrowseCallback;
    // this will the the initial selection which is from
    // either the registry or the default or the last value
    // selected.
    browseInfo.lParam = (LPARAM)m_TempDestLocation;

    if (NULL != (lpItemIDList = SHBrowseForFolder (&browseInfo)))
    {
        //the user chose the OK button in the browse dialog box
        SHGetPathFromIDList(lpItemIDList, pszSelectedFolder);
        lstrcpy(m_TempDestLocation, pszSelectedFolder);
        m_ctrlDestLocation.SetWindowText(m_TempDestLocation);
        if (lstrcmpi(m_TempDestLocation, m_FinalDestLocation))
            m_ChangeMask |= CHANGE_IMAGE_LOCATION;
        else
            m_ChangeMask &= ~(CHANGE_IMAGE_LOCATION);

        SetModified(m_ChangeMask);
        SHGetMalloc(&pMalloc);
        pMalloc->Free (lpItemIDList);   //free the item id list as we do not need it any more
        pMalloc->Release();
    }

}


void ImageTransferPage::OnEnableExploring()
{
    int Enabled = m_ctrlEnableExploring.GetCheck();
    // Only accepted value is 0 or 1.
    assert(Enabled >= 0 && Enabled <= 1);

    // if new state is different than our old one
    // enable/disable Apply Now accordingly
    if (Enabled != m_ExploringEnabled)
        m_ChangeMask |= CHANGE_EXPLORE_ON_COMPLETION;
    else
        m_ChangeMask &= ~(CHANGE_EXPLORE_ON_COMPLETION);
    SetModified(m_ChangeMask);
}

void ImageTransferPage::OnEnableIrCOMM()
{
    int Enabled = m_ctrlEnableIrCOMM.GetCheck();
    // Only accepted value is 0 or 1.
    assert(Enabled >= 0 && Enabled <= 1);

    // enable/disable Apply Now accordingly.
    if (Enabled != m_IrCOMMEnabled)
        m_ChangeMask |= CHANGE_DISABLE_IRCOMM;
    else
        m_ChangeMask &= ~(CHANGE_DISABLE_IRCOMM);
    SetModified(m_ChangeMask);
}

void ImageTransferPage::LoadRegistrySettings()
{
    HKEY hKeyIrTranP;
    DWORD  dwType, dwValue, dwSize;
    LONG Error;

    //
    // the ctor should have initialized
    //  m_ExploringEnabled,
    //  m_IrCOMMEnabled and
    //  m_FinalDestLocation
    //

    // It is okay if we can not open the registry key.
    // We simply use the defaults.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_PATH_IRTRANP_CPL, 0,
                     KEY_READ, &hKeyIrTranP))

    {
        // read the value "ExploreOnCompletion" and "RecvdFilesLocation"
        dwSize = sizeof(m_ExploringEnabled);
        Error = RegQueryValueEx(hKeyIrTranP,
                      REG_STR_EXPLORE_ON_COMPLETION,
                      0,
                      &dwType,
                      (LPBYTE)&dwValue,
                      &dwSize
                      );
        if (ERROR_SUCCESS == Error && REG_DWORD == dwType)
        {
            m_ExploringEnabled = (dwValue) ? 1 : 0;
        }
        dwSize = sizeof(m_FinalDestLocation);
        Error = RegQueryValueEx(hKeyIrTranP,
                      REG_STR_DESTLOCATION,
                      0,
                      &dwType,
                      (LPBYTE)m_FinalDestLocation,
                      &dwSize);
        if (ERROR_SUCCESS != Error || REG_SZ != dwType) {
            // If the destionation location is not specified,
            // use the default(My Picture subfolder).
            // Create it if necessary.
            SHGetSpecialFolderPath(hDlg, m_FinalDestLocation, CSIDL_MYPICTURES, TRUE);
        } else {
            // make sure the folder does exist
            dwType = GetFileAttributes(m_FinalDestLocation);
            if (0xFFFFFFFF == dwType || !(dwType & FILE_ATTRIBUTE_DIRECTORY))
            {
                // the destination does not exist or it is not a
                // directory, delete it
                Error = RegDeleteValue(hKeyIrTranP, REG_STR_DESTLOCATION);
                if (ERROR_SUCCESS == Error) {
                    // If the destionation location is not specified,
                    // use the default(My Picture subfolder).
                    // Create it if necessary.
                    SHGetSpecialFolderPath(hDlg, m_FinalDestLocation, CSIDL_MYPICTURES, TRUE);
                }
            }
        }
    
        //
        // m_TempDestLocation will be used as the intial
        // folder of choice for SHBrowseForFolder call.
        //
        lstrcpy(m_TempDestLocation, m_FinalDestLocation);
    
        dwSize = sizeof(dwValue);
        Error = RegQueryValueEx(hKeyIrTranP,
                      REG_STR_DISABLE_IRCOMM,
                      0,
                      &dwType,
                      (LPBYTE)&dwValue,
                      &dwSize
                      );
        if (ERROR_SUCCESS == Error && REG_DWORD == dwType)
        {
            // when the value is non-zero, IrCOMM is disabled.
            // Do not assume it is either 1 or 0!
            m_IrCOMMEnabled = (dwValue) ? 0 : 1;
        } else {
            // default
            m_IrCOMMEnabled = 0;
        }
        RegCloseKey(hKeyIrTranP);
    }
}

void ImageTransferPage::SaveRegistrySettings()
{
    LONG Error;
    HKEY hKeyIrTranP;
    if (m_ChangeMask)
    {
        Error = RegCreateKeyEx(HKEY_CURRENT_USER,
                     REG_PATH_IRTRANP_CPL,
                     0,     // reserved
                     NULL,      // class
                     REG_OPTION_NON_VOLATILE, // options
                     KEY_ALL_ACCESS,// REGSAM
                     NULL,      // Security
                     &hKeyIrTranP,  //
                     NULL       // disposition
                     );
    
        if (ERROR_SUCCESS == Error)
        {
            if (m_ChangeMask & CHANGE_EXPLORE_ON_COMPLETION)
            {
            Error = RegSetValueEx(hKeyIrTranP,
                        REG_STR_EXPLORE_ON_COMPLETION,
                        0,
                        REG_DWORD,
                        (LPBYTE)&m_ExploringEnabled,
                        sizeof(m_ExploringEnabled)
                        );
            if (ERROR_SUCCESS != Error)
            {
                IdMessageBox(hDlg, IDS_ERROR_REGVALUE_WRITE);
            }
            }
            if (m_ChangeMask & CHANGE_IMAGE_LOCATION)
            {
            Error = RegSetValueEx(hKeyIrTranP,
                        REG_STR_DESTLOCATION,
                        0,
                        REG_SZ,
                        (LPBYTE)m_FinalDestLocation,
                        lstrlen(m_FinalDestLocation) * sizeof(TCHAR)
                        );
            if (ERROR_SUCCESS != Error)
                IdMessageBox(hDlg, IDS_ERROR_REGVALUE_WRITE);
            }
            if (m_ChangeMask & CHANGE_DISABLE_IRCOMM)
            {
                int IrCOMMDisabled = m_IrCOMMEnabled ^ 1;
                Error = RegSetValueEx(hKeyIrTranP,
                                      REG_STR_DISABLE_IRCOMM,
                                      0,
                                      REG_DWORD,
                                      (LPBYTE)&IrCOMMDisabled,
                                      sizeof(IrCOMMDisabled)
                                      );
            if (ERROR_SUCCESS != Error)
                IdMessageBox(hDlg, IDS_ERROR_REGVALUE_WRITE);
            }
            RegCloseKey(hKeyIrTranP);
        }
        else
        {
            IdMessageBox(hDlg, IDS_ERROR_REGKEY_CREATE);
        }
    }
}

INT_PTR ImageTransferPage::OnInitDialog(HWND hDialog)
{
    PropertyPage::OnInitDialog(hDialog);
    
    m_ctrlEnableExploring.SetParent(hDialog);
    m_ctrlDestLocation.SetParent(hDialog);
    m_ctrlEnableIrCOMM.SetParent(hDialog);
    
    //
    // Load initial settings from the system registry
    //
    LoadRegistrySettings();
    
    m_ctrlEnableExploring.SetCheck(m_ExploringEnabled);
    m_ctrlEnableIrCOMM.SetCheck(m_IrCOMMEnabled);
    m_ctrlDestLocation.SetWindowText(m_FinalDestLocation);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void ImageTransferPage::OnApply(LPPSHNOTIFY lppsn)
{
    if (m_ChangeMask)
    {
        if (m_ChangeMask & CHANGE_IMAGE_LOCATION)
            lstrcpy(m_FinalDestLocation, m_TempDestLocation);
        if (m_ChangeMask & CHANGE_EXPLORE_ON_COMPLETION)
            m_ExploringEnabled = m_ctrlEnableExploring.GetCheck();
        if (m_ChangeMask & CHANGE_DISABLE_IRCOMM)
            m_IrCOMMEnabled = m_ctrlEnableIrCOMM.GetCheck();
        
        SaveRegistrySettings();
        m_ChangeMask = 0;
    }
    PropertyPage::OnApply(lppsn);
}


BOOL ImageTransferPage::OnHelp (LPHELPINFO pHelpInfo)
{
    TCHAR szHelpFile[MAX_PATH];

    ::LoadString(hInstance, IDS_HELP_FILE, szHelpFile, MAX_PATH);

    ::WinHelp((HWND)(pHelpInfo->hItemHandle),
              (LPCTSTR) szHelpFile,
              HELP_WM_HELP,
              (ULONG_PTR)(LPTSTR)g_ImageTransferHelp);

    return FALSE;
}

BOOL ImageTransferPage::OnContextMenu (WPARAM wParam, LPARAM lParam)
{
    TCHAR szHelpFile[MAX_PATH];

    ::LoadString(hInstance, IDS_HELP_FILE, szHelpFile, MAX_PATH);

    ::WinHelp((HWND) wParam,
            (LPCTSTR) szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID)g_ImageTransferHelp);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\irpropsheet.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       irpropsheet.cpp
//
//--------------------------------------------------------------------------

// IrPropSheet.cpp : implementation file
//

#include "precomp.hxx"
#include "irpropsheet.h"
#include "debug.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const UINT IRPROPSHEET_MAX_PAGES = 3;

BOOL CALLBACK IrPropSheet::AddPropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    IrPropSheet *irprop = (IrPropSheet*) lParam;
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)&(irprop->psh);

    IRINFO((_T("IrPropSheet::AddPropSheetPage")));
    if (hpage && (ppsh->nPages < MAX_PAGES))
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}

void IrPropSheet::PropertySheet(LPCTSTR pszCaption, HWND hParent, UINT iSelectPage)
{
    HPSXA hpsxa;
    UINT added;
    BOOL isIrdaSupported = IsIrDASupported();
    INITCOMMONCONTROLSEX icc = { 0 };

    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&icc);

    LinkWindow_RegisterClass();

    IRINFO((_T("IrPropSheet::PropertySheet")));
    //
    // Property page init
    //
    ZeroMemory(&psh, sizeof(psh));
    psh.hwndParent = hParent;
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_USECALLBACK;
    psh.hInstance = hInstance;
    psh.pszCaption = pszCaption;
    psh.nPages = 0;
    psh.phpage = hp;
    psh.nStartPage = iSelectPage;

    //
    //  Check for any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegWireless, 8);

    // 
    // Add the file transfer page, giving the extensions a chance to replace it.
    //
    if ((!hpsxa ||
         !SHReplaceFromPropSheetExtArray(hpsxa, 
                                         CPLPAGE_FILE_XFER,
                                         AddPropSheetPage,
                                         (LPARAM)this)) &&
        isIrdaSupported) {
        IRINFO((_T("Adding infrared page...")));
        AddPropSheetPage(m_FileTransferPage, (LPARAM)this);
    }
        
    // 
    // Add the image transfer page, giving the extensions a chance to replace it.
    //
    if ((!hpsxa ||
         !SHReplaceFromPropSheetExtArray(hpsxa, 
                                         CPLPAGE_IMAGE_XFER,
                                         AddPropSheetPage,
                                         (LPARAM)this)) &&
        isIrdaSupported) {
        IRINFO((_T("Adding image page...")));
        AddPropSheetPage(m_ImageTransferPage, (LPARAM)this);
    }

    //
    // Extensions are not allowed to extend the hardware page
    //
#if 0
    // 
    // Add the hardware page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray(hpsxa, 
                                        CPLPAGE_HARDWARE,
                                        AddPropSheetPage,
                                        (LPARAM)this)) {
        IRINFO((_T("Adding hardware page...")));
        AddPropSheetPage(m_HardwarePage, (LPARAM)this);
    }
#else
    AddPropSheetPage(m_HardwarePage, (LPARAM)this);
#endif

    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa) {
        IRINFO((_T("Adding prop sheet extensions...")));
        added = SHAddFromPropSheetExtArray(hpsxa,
                                            AddPropSheetPage,
                                            (LPARAM)this );
        IRINFO((_T("Added %x prop sheet pages."), added));
    }

    //sanity check so that we won't be in infinite loop.
    if (iSelectPage >= psh.nPages) {
        // start page is out of range.
        psh.nStartPage = -1;
    }
    
    ::PropertySheet(&psh);

    if (hpsxa) {
        //
        // Unload any of our extensions
        //
        SHDestroyPropSheetExtArray(hpsxa);
    }

    LinkWindow_UnregisterClass(hInstance);
}


/////////////////////////////////////////////////////////////////////////////
// IrPropSheet

IrPropSheet::IrPropSheet(HINSTANCE hInst, UINT nIDCaption, HWND hParent, UINT iSelectPage) :
    hInstance(hInst), 
    m_FileTransferPage(hInst, hParent), 
    m_ImageTransferPage(hInst, hParent), 
    m_HardwarePage(hInst, hParent)
{
    TCHAR buf[MAX_PATH];
    IRINFO((_T("IrPropSheet::IrPropSheet")));
    ::LoadString(hInstance, nIDCaption, buf, MAX_PATH);
    PropertySheet(buf, hParent, iSelectPage);
}

IrPropSheet::IrPropSheet(HINSTANCE hInst, LPCTSTR pszCaption, HWND hParent, UINT iSelectPage) :
    hInstance(hInst), m_FileTransferPage(hInst, hParent), 
    m_ImageTransferPage(hInst, hParent), m_HardwarePage(hInst, hParent)
{
    IRINFO((_T("IrPropSheet::IrPropSheet")));
    PropertySheet(pszCaption, hParent, iSelectPage);
}


IrPropSheet::~IrPropSheet()
{
}

////////////////////////////////////////////////////////////////////////
//  Function that checks if the IrDA protocol is supported on the
//  machine or not. If not, then CPlApplet returns FALSE when it gets
//  the CPL_INIT message, thus preventing the control panel from
//  displaying the applet.
////////////////////////////////////////////////////////////////////////

BOOL IrPropSheet::IsIrDASupported (void)
{
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;
    BOOL retVal = FALSE;
    SOCKET sock;

    IRINFO((_T("IrPropSheet::IsIrDASupported")));
    
    wVersionRequested = MAKEWORD( 1, 1 );
    err = WSAStartup( wVersionRequested, &wsaData );

    if ( err != 0 )
        return FALSE;   //a usable WinSock DLL could not be found

    if ( LOBYTE( wsaData.wVersion ) != 1 ||
            HIBYTE( wsaData.wVersion ) != 1 ) {
        WSACleanup();   //the WinSock DLL is not acceptable.
        IRINFO((_T("Winsock DLL not acceptable")));
        return FALSE;
    }

    //The WinSock DLL is acceptable. Proceed.
    sock = socket (AF_IRDA, SOCK_STREAM, 0);

    if (INVALID_SOCKET != sock) //BUGBUG: need to explicitly check for WSAEAFNOSUPPORT
    {
        closesocket(sock);
        retVal = TRUE;
    }

    IRINFO((_T("Irda supported = %x"), retVal));
    //cleanup before leaving
    WSACleanup();
    return retVal;
}

/*
INT_PTR IrPropSheet::DlgProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == g_uIPMsg) {
        return OnInterProcessMsg (wParam, lParam);
    } else if (msg == WM_INITDIALOG) {
        return OnInitDialog(hDlg);
    }
    return FALSE;
}

*/
/*
int CALLBACK IrPropSheet::OnInitDialog()
{
    g_hwndPropSheet = hDlg;
    
    DWORD dwStyle = ::GetWindowLongPtr(hDlg, GWL_EXSTYLE);
    DWORD dwNewStyle = dwStyle | WS_EX_CONTEXTHELP;
    ::SetWindowLongPtr(hDlg, GWL_EXSTYLE, dwNewStyle);
    
    return bResult;
}

//
// Function to handle inter-process communication(the g_uIPMsg)
// Input:
//  wParam  -- contain IPMSG_ command
//  lParam  -- contain command's extra parameters.
// Output:
//  depends on command. -1 if the command failed.
//
LRESULT IrPropSheet::OnInterProcessMsg (WPARAM wParam, LPARAM lParam)
{
    if (IPMSG_REQUESTSIGNATURE == lParam)
    {
        if (IPMSG_SIGNATURECHECK == wParam)
            return (LRESULT)IPMSG_REPLYSIGNATURE;
    }
    return (LRESULT)-1;
} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\imagetransferpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       imagetransferpage.h
//
//--------------------------------------------------------------------------

#ifndef __IMAGETRANSFERPAGE_H__
#define __IMAGETRANSFERPAGE_H__

// ImageTransferPage.h : header file
//

#include "PropertyPage.h"
#include "Controls.h"

#define CHANGE_EXPLORE_ON_COMPLETION    0x01
#define CHANGE_DISABLE_IRCOMM           0x02
#define CHANGE_IMAGE_LOCATION           0x04


/////////////////////////////////////////////////////////////////////////////
// ImageTransferPage dialog

class ImageTransferPage : public PropertyPage
{
// Construction
public:
    ImageTransferPage(HINSTANCE hInst, HWND parent) : 
        PropertyPage(IDD_IMAGETRANSFER, hInst),
        m_ctrlEnableIrCOMM(IDC_IMAGEXFER_ENABLE_IRCOMM),
        m_ctrlEnableExploring(IDC_IMAGEXFER_EXPLOREONCOMPLETION),
        m_ctrlDestLocation(IDC_IMAGEXFER_DEST) {
        m_ExploringEnabled = 1;
        m_IrCOMMEnabled = 0;
        m_TempDestLocation[0] = _T('\0');
        m_FinalDestLocation[0] = _T('\0');
        m_ChangeMask = 0; }
    ~ImageTransferPage() { ; }

// Dialog Data
    Button m_ctrlEnableIrCOMM;
    Button m_ctrlEnableExploring;
    Edit   m_ctrlDestLocation;


// Overrides
private:
    void OnApply(LPPSHNOTIFY lppsn);
    BOOL OnHelp (LPHELPINFO pHelpInfo);
    BOOL OnContextMenu (WPARAM wParam, LPARAM lParam);
    void OnCommand(UINT ctrlId, HWND hwndCtrl, UINT cNotify);
    INT_PTR OnInitDialog(HWND hDialog);

// Implementation
protected:
    void OnEnableExploring();
    void OnEnableIrCOMM();
    void OnBrowse();
    
private:
    void LoadRegistrySettings();
    void SaveRegistrySettings();
    int m_ExploringEnabled;
    int m_IrCOMMEnabled;
    TCHAR   m_FinalDestLocation[MAX_PATH + 1];
    DWORD   m_ChangeMask;
    TCHAR   m_TempDestLocation[MAX_PATH + 1];
};

extern HINSTANCE gHInst;

#endif // __IMAGETRANSFERPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\irprops.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       irprops.h
//
//--------------------------------------------------------------------------

// irprops.h : main header file for the IRPROPS DLL
//

#ifndef __IRPROPS_H__
#define __IRPROPS_H__

#include "resource.h"       // main symbols

#define SINGLE_INST_MUTEX   L"IRProps_75F2364F_4CE2_41BE_876C_9F685B55B775"

#define WIRELESSLINK_INTERPROCESSMSG L"WirelessLinkInterprocessMsg"

#define IPMSG_SIGNATURECHECK    0x02

#define IPMSG_REQUESTSIGNATURE  0xFA5115AF
#define IPMSG_REPLYSIGNATURE    ~IPMSG_REQUESTSIGNATURE

BOOL EnumWinProc(HWND hWnd, LPARAM lParam);
extern HWND g_hwndPropSheet;
extern UINT g_uIPMsg;
#define NUM_APPLETS 1

///////////////////////////////////////////////////////////////////////////
//  Dll's exported functions
LONG CALLBACK CPlApplet(HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2);

int MsgBoxWinError(HWND hWndParent, DWORD Options = MB_OK | MB_ICONSTOP, DWORD Error = 0, int CaptionId = 0);

////////////////////////////////////////////////////////////////
//
typedef struct tagApplets {
    int icon;         // icon resource identifier
    int namestring;   // name-string resource identifier
    int descstring;   // description-string resource identifier
} APPLETS;

/////////////////////////////////////////////////////////////////////////////

#endif // __IRPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\propertypage.cpp ===
#include "precomp.hxx"
#include "PropertyPage.h"

void PropertyPage::FillPropSheetPage()
{
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize = sizeof(psp);
    psp.dwFlags =  PSP_USECALLBACK;
    psp.pszTemplate = MAKEINTRESOURCE(resID);
    psp.hInstance = hInstance;
    psp.lParam = (LPARAM) this;
    psp.pfnDlgProc = PropertyPageStaticDlgProc;
    psp.pfnCallback = PropertyPageStaticCallback;
}

HPROPSHEETPAGE PropertyPage::CreatePropertyPage()
{
    HPROPSHEETPAGE hp;
    FillPropSheetPage();
    return ::CreatePropertySheetPage(&psp);
}

UINT CALLBACK PropertyPage::PropertyPageStaticCallback(HWND hwnd, UINT msg, LPPROPSHEETPAGE ppsp)
{
    PropertyPage * pThis = (PropertyPage*) ppsp->lParam;

    switch (msg) {
    case PSPCB_CREATE:
        return pThis->CallbackCreate();

    case PSPCB_RELEASE:
        pThis->CallbackRelease();
        return FALSE;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

INT_PTR PropertyPage::PropertyPageStaticDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    Dialog *pThis;

    pThis = (PropertyPage*) GetWindowLongPtr(hDlg, DWLP_USER);

    if (msg == WM_INITDIALOG) {
        pThis = (PropertyPage *) ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR) pThis);

        return pThis->OnInitDialog(hDlg);
    }

    if (pThis) {
        return pThis->MainDlgProc(msg, wParam, lParam);
    }

    return FALSE;
}

INT_PTR PropertyPage::OnNotify(NMHDR * nmhdr)
{
    INT_PTR res = Dialog::OnNotify(nmhdr);
    LPPSHNOTIFY lppsn = (LPPSHNOTIFY) nmhdr;

    switch (nmhdr->code) {
    case PSN_APPLY:
        OnApply(lppsn);
        return TRUE;

    case PSN_KILLACTIVE:
        OnKillActive(lppsn);
        return TRUE;

    case PSN_SETACTIVE:
        OnSetActive(lppsn);
        return TRUE;
        
    case PSN_HELP:
        OnHelp(lppsn);
        return TRUE;

    case PSN_RESET:
        OnReset(lppsn);
        return FALSE;

    case PSN_QUERYCANCEL:
        OnQueryCancel(lppsn);
        return TRUE;

    default:
        return FALSE;
    }
}

void PropertyPage::OnApply(LPPSHNOTIFY lppsn) 
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
}

void PropertyPage::OnSetActive(LPPSHNOTIFY lppsn)
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
}

void PropertyPage::OnKillActive(LPPSHNOTIFY lppsn)
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
}

void PropertyPage::OnQueryCancel(LPPSHNOTIFY lppsn) 
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
}

void PropertyPage::SetModified(BOOL bChanged) {
    assert(::IsWindow(hDlg));
    assert(GetParent(hDlg) != NULL);
    UINT uMsg = bChanged ? PSM_CHANGED : PSM_UNCHANGED;
    ::SendMessage(GetParent(hDlg), uMsg, (WPARAM)hDlg, 0L);
}

//
// SHBrowseForFolder callback
//
int
CALLBACK
BrowseCallback(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        // set the initial seclection to our default folder
        // (from the registry or SIDL_MYPICTURES).
        // the lpData points to the folder path.
        // It must contain a path.
        assert(lpData && _T('\0') != *((LPTSTR)lpData));

        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
        break;
    case BFFM_VALIDATEFAILED:
        IdMessageBox(hwnd, IDS_ERROR_INVALID_FOLDER);
        return 1;
    default:
        break;
    }

    return 0;
}

extern HINSTANCE gHInst;

int
IdMessageBox(
    HWND hwnd,
    int  MsgId,
    DWORD Options,
    int  CaptionId
    )
{
    TCHAR MsgText[MAX_PATH];
    TCHAR Caption[MAX_PATH];
    assert(MsgId);
    if (MsgId)
        LoadString(gHInst, MsgId, MsgText, sizeof(MsgText) / sizeof(TCHAR));
    else
        LoadString(gHInst, IDS_ERROR_UNKNOWN, MsgText, sizeof(MsgText) / sizeof(TCHAR));
    if (CaptionId)
        LoadString(gHInst, CaptionId, Caption, sizeof(Caption) / sizeof(TCHAR));
    else
        LoadString(gHInst, IDS_APPLETNAME, Caption, sizeof(Caption) / sizeof(TCHAR));
    return MessageBox(hwnd, MsgText, Caption, Options);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\irprops.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       irprops.cpp
//
//--------------------------------------------------------------------------

// irprops.cpp : Defines the initialization routines for the DLL.
//

#include "precomp.hxx"
#include "irprops.h"
#include "irpropsheet.h"
#include "debug.h"


BOOL InitInstance();
INT ExitInstance();
BOOL IsFirstInstance();
INT_PTR WINAPI DoPropertiesA(HWND hwnd, LPCSTR CmdLine);
INT_PTR WINAPI DoPropertiesW(HWND hwnd, LPCWSTR CmdLine);


HINSTANCE gHInst;

//
// This records the current active property sheet window handle created
// by this instance. It is set/reset by CIrPropSheet object.
//
HWND        g_hwndPropSheet = NULL;
HANDLE      g_hMutex = NULL;
BOOL        g_bFirstInstance = TRUE;

//
// This records our registered message for inter-instances communications
// The message is registered in CIrpropsApp::InitInstance.
//
UINT        g_uIPMsg;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern "C" {

BOOL APIENTRY
DllMain(HANDLE hDll,
        DWORD dwReason,
        LPVOID lpReserved)
{
    IRINFO((_T("DllMain reason %x"), dwReason));
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        gHInst = (HINSTANCE) hDll;
        return InitInstance(); 
        break;

    case DLL_PROCESS_DETACH:
        return ExitInstance();
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    default:
        break;
    }

    return TRUE;
}

}

////////////////////////////////////////////////////////////////////////
//some globals

APPLETS IRApplet[NUM_APPLETS] = {
    {IDI_IRPROPS, IDS_APPLETNAME, IDS_APPLETDESC}
};


/////////////////////////////////////////////////////////////////////////
//  CPlApplet function for the control panel
//
LONG CALLBACK CPlApplet(
                        HWND hwndCPL,
                        UINT uMsg,
                        LPARAM lParam1,
                        LPARAM lParam2)
{
    int i;
    LPCPLINFO lpCPlInfo;

    i = (int) lParam1;

    IRINFO((_T("CplApplet message %x"), uMsg));
    switch (uMsg)
    {
    case CPL_INIT:      // first message, sent once
        if (!IrPropSheet::IsIrDASupported()) {
            HPSXA hpsxa;
            //
            //  Check for any installed extensions.
            //
            hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegWireless, 8);
            if (hpsxa) {
                //
                // We have extensions installed so we have to show the CPL, 
                // whether IRDA exists or not.
                //
                SHDestroyPropSheetExtArray(hpsxa);
                return TRUE;
            }
            return FALSE;
        }
        return TRUE;
    case CPL_GETCOUNT:  // second message, sent once
        return NUM_APPLETS;
        break;
    case CPL_INQUIRE: // third message, sent once per application
        lpCPlInfo = (LPCPLINFO) lParam2;
        lpCPlInfo->lData = 0;
        lpCPlInfo->idIcon = IRApplet[i].icon;
        lpCPlInfo->idName = IRApplet[i].namestring;
        lpCPlInfo->idInfo = IRApplet[i].descstring;
        break;

    case CPL_STARTWPARMSA:
        if (-1 == DoPropertiesA(hwndCPL, (LPCSTR)lParam2))
            MsgBoxWinError(hwndCPL);
        // return true so that we won't get CPL_DBLCLK.
        return 1;
        break;
    case CPL_STARTWPARMSW:
        if (-1 == DoPropertiesW(hwndCPL, (LPCWSTR)lParam2))
            MsgBoxWinError(hwndCPL);
        // return true so that we won't get CPL_DBLCLK.
        return 1;
        break;
    case CPL_DBLCLK:    // application icon double-clicked
        if (-1 == DoPropertiesA(hwndCPL, (LPCSTR)lParam2))
            MsgBoxWinError(hwndCPL);
    return 1;
        break;
    case CPL_STOP:      // sent once per application before CPL_EXIT
        break;
    case CPL_EXIT:    // sent once before FreeLibrary is called
        break;
    default:
        break;
    }

    return 0;
}

//
// This function presents the Wireless link property sheet.
// INPUT:
//  hwndParent  -- window handle to be used as parent window of
//          the property sheet
//  lpCmdLine -- optional command line
//           'n" (n in decimal) is start page number(zero-based).
// OUTPUT:
//  Return value of PropertySheet API
INT_PTR
DoPropertiesW(
    HWND    hwndParent,
    LPCWSTR lpCmdLine
    )
{
    INT_PTR Result;
    INT   StartPage;
    
    IRINFO((_T("DoPropertiesW")));
    //
    // Assuming no start page was specified.
    //
    StartPage = -1;
    //
    // Command line specifies start page number
    //
    if (lpCmdLine)
    {
        // skip white chars
        while (_T('\0') != *lpCmdLine &&
               (_T(' ') == *lpCmdLine || _T('\t') == *lpCmdLine))
        {
            lpCmdLine++;
        }
        if (_T('0') <= *lpCmdLine && _T('9') >= *lpCmdLine)
        {
            StartPage = 0;
            do
            {
                StartPage = StartPage * 10 + *lpCmdLine - _T('0');
                lpCmdLine++;
            } while (_T('0') <= *lpCmdLine && _T('9') >= *lpCmdLine);
        }
    }
    if (!IsFirstInstance() || NULL != g_hwndPropSheet)
    {
        IRINFO((_T("Not the first instance")));
        HWND hwndPropSheet = HWND_DESKTOP;
        if (NULL == g_hwndPropSheet)
        {
            IRINFO((_T("No window created")));
            //
            // We are not the first instance. Look for the property sheet
            // window created by the first instance.
            //
            EnumWindows(EnumWinProc, (LPARAM)&hwndPropSheet);
        }
        else
        {
            IRINFO((_T("Window active")));
            //
            // This is not the first call and we have a
            // property sheet active(same process, multiple calls)
            //
            hwndPropSheet = g_hwndPropSheet;
        }
        if (HWND_DESKTOP != hwndPropSheet)
        {
            IRINFO((_T("Found the active property sheet.")));
            //
            // We found the active property sheet
            //
            // Select the new active page if necessary
            //
            if (-1 != StartPage)
            PropSheet_SetCurSel(hwndPropSheet, NULL, StartPage);
    
            //
            // bring the property sheet to the foreground.
            //
            ::SetForegroundWindow(hwndPropSheet);
        }
        Result = IDCANCEL;
    }
    else
    {
        IRINFO((_T("First instance, creating propertysheet")));
        IrPropSheet PropSheet(gHInst, IDS_APPLETNAME, hwndParent, StartPage);
    }
    return Result;
}

//
// This is our callback function for EnumWindows API.
// It probes for each window handle to see if it is the property sheet
// window created by the previous instance. If it is, it returns
// the window handle in the provided buffer, lParam)
// Input:
//  hWnd -- the window handle
//  lParam -- (HWND *)
// Output:
//  TRUE -- Let Windows continue to call us
//  FALSE -- Stop Windows from calling us again
//
BOOL
CALLBACK
EnumWinProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    //
    // Verify with this window to see if it is the one we are looking for.
    //
    LRESULT lr;
    lr = ::SendMessage(hWnd, g_uIPMsg, (WPARAM)IPMSG_SIGNATURECHECK,
               (LPARAM)IPMSG_REQUESTSIGNATURE);
    if (IPMSG_REPLYSIGNATURE == lr)
    {
    if (lParam)
    {
        // this is the one
        *((HWND *)(lParam)) = hWnd;
    }
    //
    // We are done with enumeration.
    //
    return FALSE;
    }
    return TRUE;
}

INT_PTR
DoPropertiesA(
    HWND hwndParent,
    LPCSTR lpCmdLine
    )
{
    WCHAR CmdLineW[MAX_PATH];
    UINT Size;
    if (!lpCmdLine)
        return DoPropertiesW(hwndParent, NULL);
    MultiByteToWideChar(CP_ACP, 0, lpCmdLine, -1, CmdLineW, sizeof(CmdLineW) / sizeof(WCHAR));
    return DoPropertiesW(hwndParent, CmdLineW);
}


// This function creates and displays a message box for the given
// win32 error(or last error)
// INPUT:
//  hwndParent -- the parent window for the will-be-created message box
//  Type       -- message styles(MB_xxxx)
//  Error      -- Error code. If the value is 0
//            GetLastError() will be called to retreive the
//            real error code.
//  CaptionId  -- optional string id for caption
// OUTPUT:
//  the value return from MessageBox
//
int
MsgBoxWinError(
    HWND hwndParent,
    DWORD Options,
    DWORD Error,
    int  CaptionId
    )
{
    if (ERROR_SUCCESS == Error)
    Error = GetLastError();

    // nonsense to report success!
    if (ERROR_SUCCESS == Error)
    return IDOK;

    TCHAR szMsg[MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    if (!CaptionId)
    CaptionId = IDS_APPLETNAME;
    ::LoadString(gHInst, CaptionId, szCaption, sizeof(szCaption) / sizeof(TCHAR));
    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
          NULL, Error, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
          szMsg, sizeof(szMsg) / sizeof(TCHAR), NULL);
    return MessageBox(hwndParent, szMsg, szCaption, Options);
}

BOOL InitInstance()
{
    //
    // Try to create a named mutex. This give us a clue
    // if we are the first instance. We will not close
    // the mutex until exit.
    //
    g_hMutex = CreateMutex(NULL, TRUE, SINGLE_INST_MUTEX);
    if (g_hMutex)
    {
        g_bFirstInstance = ERROR_ALREADY_EXISTS != GetLastError();
        //
        // register a message for inter-instances communication
        //
        g_uIPMsg = RegisterWindowMessage(WIRELESSLINK_INTERPROCESSMSG);
        SHFusionInitializeFromModuleID(gHInst, 124);
        return TRUE;
    }
    return FALSE;
}

BOOL ExitInstance()
{
    if (g_hMutex)
    {
        CloseHandle(g_hMutex);
        g_hMutex = NULL;
    }
    SHFusionUninitialize();
    return TRUE;
}

BOOL IsFirstInstance()
{
    return g_bFirstInstance;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\irpropsheet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       irpropsheet.h
//
//--------------------------------------------------------------------------

#ifndef __IRPROPSHEET_H__
#define __IRPROPSHEET_H__

#include "FileTransferPage.h"
#include "ImageTransferPage.h"
#include "HardwarePage.h"
#include "Resource.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// IrPropSheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIrPropSheet
#define MAX_PAGES 8
#define CPLPAGE_FILE_XFER       1
#define CPLPAGE_IMAGE_XFER      2
#define CPLPAGE_HARDWARE        3

class IrPropSheet
{

// Construction
public:
    IrPropSheet(HINSTANCE hInst, UINT nIDCaption = IDS_APPLETNAME, HWND hParent = NULL, UINT iSelectPage = 0);
    IrPropSheet(HINSTANCE hInst, LPCTSTR pszCaption, HWND hParent = NULL, UINT iSelectPage = 0);
    friend LONG CALLBACK CPlApplet(HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2);

    static BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);
    static BOOL IsIrDASupported (void);

// Attributes
public:

// Operations
public:

// Overrides
public:
//    virtual BOOL OnInitDialog();

// Implementation
public:
    virtual ~IrPropSheet();

/*    void AddFileTransferPage();
    void AddImageTransferPage();
    void AddHardwarePage();*/
    // Generated message map functions
protected:
/*    void OnActivateApp(BOOL bActive, HTASK hTask);
    void OnClose();
    BOOL OnHelp (LPHELPINFO pHelpInfo);
    BOOL OnContextMenu (WPARAM wParam, LPARAM lParam);
    LRESULT OnInterProcessMsg(WPARAM wParam, LPARAM lParam);
    INT_PTR DlgProc(UINT msg, WPARAM wParam, LPARAM lParam);*/
private:
    void PropertySheet(LPCTSTR pszCaption, HWND pParentWnd, UINT iSelectPage);
    FileTransferPage    m_FileTransferPage;
    ImageTransferPage   m_ImageTransferPage;
    HardwarePage        m_HardwarePage;
    HINSTANCE           hInstance;
    PROPSHEETHEADER     psh;
    HPROPSHEETPAGE      hp[MAX_PAGES];
    UINT                nPages;
};
/////////////////////////////////////////////////////////////////////////////

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegWireless[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Wireless");

#endif // __IRPROPSHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by irprops.rc
//
#define IDS_APPLETNAME                  1
#define IDS_APPLETDESC                  2
#define IDS_ERROR_UNKNOWN               3
#define IDS_ERROR_INVALID_FOLDER        4
#define IDS_ERROR_REGKEY_CREATE         5
#define IDS_ERROR_REGVALUE_WRITE        6
#define IDS_IMAGEFOLDER_PROMPT          7
#define IDS_FILEFOLDER_PROMPT           8
#define IDS_INVALID_MSG                 9
#define IDS_INVALID_TITLE               10
#define IDD_HARDWARE                    106
#define IDI_IRPROPS                     129
#define IDD_FILETRANSFER                130
#define IDD_IMAGETRANSFER               131
#define IDC_JUNK                        1000
#define IDC_DISPLAYTRAY                 1002
#define IDC_SENDFILESGROUP              1004
#define IDC_ALLOWSEND                   1006
#define IDC_DISPLAYRECV                 1007
#define IDC_LOCATIONTITLE               1008
#define IDC_RECEIVEDFILESLOCATION       1009
#define IDC_CHOOSEFILELOCATION          1010
#define IDC_IMAGEXFER_ENABLE_IRCOMM     1011
#define IDC_IMAGEXFER_EXPLOREONCOMPLETION 1012
#define IDC_IMAGEXFER_DESTGROUP         1013
#define IDC_IMAGEXFER_DESTDESC          1014
#define IDC_IMAGEXFER_DEST              1015
#define IDC_IMAGEXFER_BROWSE            1016
#define IDS_HELP_FILE                   1017
#define IDC_NETWORKCONNECTIONS_LINK     1018
#define IDC_HW_FAIL                     1022
#define IDC_SOUND                       1023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1024
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\propertypage.h ===
#ifndef __PROPERTYPAGE_H
#define __PROPERTYPAGE_H

#include "dialog.h"

class PropertyPage : public Dialog {
public:
    PropertyPage(UINT resID, HINSTANCE hInst) : Dialog(resID, hInst) {}
    
    HPROPSHEETPAGE CreatePropertyPage();
    operator HPROPSHEETPAGE() { return CreatePropertyPage(); }

protected:
    static INT_PTR PropertyPageStaticDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK PropertyPageStaticCallback(HWND hwnd, UINT msg, LPPROPSHEETPAGE ppsp);

    virtual UINT CallbackCreate() { return TRUE; }
    virtual void CallbackRelease() {}

    virtual UINT ShowModal(HWND hwndParent = NULL) { return (UINT) -1;}

    virtual INT_PTR OnNotify(NMHDR * nmhdr);
    virtual void OnApply(LPPSHNOTIFY lppsn);
    virtual void OnSetActive(LPPSHNOTIFY lppsn);
    virtual void OnKillActive(LPPSHNOTIFY lppsn);
    virtual void OnReset(LPPSHNOTIFY lppsn) {}
    virtual void OnHelp(LPPSHNOTIFY lppsn) {}
    virtual void OnQueryCancel(LPPSHNOTIFY lppsn);
    virtual void SetModified(BOOL bChanged = TRUE);

    virtual void FillPropSheetPage();

    PROPSHEETPAGE psp;
};

int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

int IdMessageBox(HWND hwnd, int MsgId, DWORD Options = MB_OK | MB_ICONSTOP, int CaptionId = 0);

#endif // __PROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\actisys.h ===
/*****************************************************************************
*
*  Copyright (c) 1997-1999 Microsoft Corporation
*
*       @doc
*       @module   ACTISYS.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     10/30/1997 (created)
*
*       Contents: ACTISYS dongle specific prototypes.
*
*****************************************************************************/


#ifndef ACTISYS_H
#define ACTISYS_H

#include "dongle.h"

NDIS_STATUS
ACT200L_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        );

NDIS_STATUS ACT200L_Init(
                PDEVICE_OBJECT       pSerialDevObj
                );

void ACT200L_Deinit(
                PDEVICE_OBJECT       pSerialDevObj
                );

NDIS_STATUS ACT200L_SetSpeed(
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

NDIS_STATUS
ACT220L_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        );

NDIS_STATUS
ACT220LPlus_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        );

NDIS_STATUS ACT220L_Init(
                PDEVICE_OBJECT       pSerialDevObj
                );

void ACT220L_Deinit(
                PDEVICE_OBJECT       pSerialDevObj
                );

NDIS_STATUS ACT220L_SetSpeed(
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

#endif // ACTISYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\convert.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   convert.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/4/1996 (created)
*
*       Contents: Conversion routine from an ndis packet to an ir packet.
*
*
*****************************************************************************/

#include "irsir.h"

extern const USHORT fcsTable[];

ULONG __inline EscapeSlowIrData(PUCHAR Dest, UCHAR SourceByte)
{
    switch (SourceByte){
        case SLOW_IR_BOF:
        case SLOW_IR_EOF:
        case SLOW_IR_ESC:
            Dest[0] = SLOW_IR_ESC;
            Dest[1] = SourceByte ^ SLOW_IR_ESC_COMP;
            return 2;

        default:
            Dest[0] = SourceByte;
            return 1;
    }
}

/*****************************************************************************
*
*  Function:   NdisToIrPacket
*
*  Synopsis:   convert an NDIS packet to an IR packet
*
*              Write the IR packet into the provided buffer and report
*              its actual size.
*
*  Arguments:  pThisDev
*              pPacket
*              irPacketBuf
*              irPacketBufLen
*              irPacketLen
*
*  Returns:    TRUE  - on success
*              FALSE - on failure
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/4/1996    sholden   author
*
*  Notes:
*
*  If failing, *irPacketLen will contain the buffer size that
*  the caller should retry with (or 0 if a corruption was detected).
*
*****************************************************************************/

BOOLEAN
NdisToIrPacket(
            PIR_DEVICE   pThisDev,
            PNDIS_PACKET pPacket,
            UCHAR        *irPacketBuf,
            UINT         irPacketBufLen,
            UINT         *irPacketLen
            )
{
    UINT i;
    UINT ndisPacketBytes;
    UINT I_fieldBytes;
    UINT totalBytes;
    UINT ndisPacketLen;
    UINT numExtraBOFs;
    UINT bufLen;

    SLOW_IR_FCS_TYPE fcs;
    SLOW_IR_FCS_TYPE tmpfcs;

    UCHAR *bufData;
    UCHAR nextChar;

    PNDIS_BUFFER ndisBuf;
    PNDIS_IRDA_PACKET_INFO packetInfo;

    DEBUGMSG(DBG_FUNC, ("+NdisToIrPacket\n"));

    //
    // Initialize locals.
    //

    ndisPacketBytes = 0;
    I_fieldBytes    = 0;
    totalBytes      = 0;

    packetInfo = GetPacketInfo(pPacket);

    //
    // Get the packet's entire length and its first NDIS buffer.
    //

    NdisQueryPacket(pPacket, NULL, NULL, &ndisBuf, &ndisPacketLen);

    //
    // Make sure that the packet is big enough to be legal.
    // It consists of an A, C, and variable-length I field.
    //

    if (ndisPacketLen < SLOW_IR_ADDR_SIZE + SLOW_IR_CONTROL_SIZE)
    {
        DEBUGMSG(DBG_ERR, ("    Packet too short in NdisToIrPacket (%d bytes)\n",
                ndisPacketLen));

        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - SLOW_IR_ADDR_SIZE - SLOW_IR_CONTROL_SIZE;
    }

    //
    // Make sure that we won't overwrite our contiguous buffer.
    // Make sure that the passed-in buffer can accomodate this packet's
    // data no matter how much it grows through adding ESC-sequences, etc.
    //

    if ((ndisPacketLen > MAX_IRDA_DATA_SIZE) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > irPacketBufLen))
    {
        //
        // The packet is too large
        // Tell the caller to retry with a packet size large
        // enough to get past this stage next time.
        //

        DEBUGMSG(DBG_ERR, ("Packet too large in NdisToIrPacket (%d=%xh bytes), \n"
                "MAX_IRDA_DATA_SIZE=%d, irPacketBufLen=%d.",
                 ndisPacketLen, ndisPacketLen, MAX_IRDA_DATA_SIZE, irPacketBufLen));

        *irPacketLen = ndisPacketLen;
        return FALSE;
    }

    if (!ndisBuf)
    {
        DEBUGMSG(DBG_ERR, ("No NDIS_BUFFER in NdisToIrPacket"));
		*irPacketLen = 0;
        return FALSE;
    }
	
    NdisQueryBuffer(ndisBuf, (PVOID *)&bufData, &bufLen);

    if (!bufData)
    {
        DEBUGMSG(DBG_ERR, ("No data in NDIS_BUFFER in NdisToIrPacket"));
		*irPacketLen = 0;
        return FALSE;
    }
	
    fcs = 0xffff;

    // Calculate FCS and write the new buffer in ONE PASS.

	//
	// Now begin building the IR frame.
	//
	// This is the final format:
	//
	// 	BOF	(1)
	//     extra BOFs ...
	// 	NdisMediumIrda packet (what we get from NDIS):
	// 		Address (1)
	// 		Control (1)
	// 	FCS	(2)
	//     EOF (1)
	

    //
    // Prepend BOFs (extra BOFs + 1 actual BOF)
    //

    numExtraBOFs = packetInfo->ExtraBOFs;

    if (numExtraBOFs > MAX_NUM_EXTRA_BOFS)
    {
        numExtraBOFs = MAX_NUM_EXTRA_BOFS;
    }

    if (pThisDev->fRequireMinTurnAround &&
        packetInfo->MinTurnAroundTime>0)
    {
        //
        // A MinTurnAroundTime delay is required, to be implemented
        // by inserting extra BOF characters.
        //
        // TurnaroundBOFS = (BitsPerSec/BitsPerChar) * (uSecDelay/uSecPerSecond)
        //                                  10                     1000000
        //

        ASSERT(pThisDev->currentSpeed<=MAX_SPEED_SUPPORTED);
        ASSERT(packetInfo->MinTurnAroundTime<=MAX_TURNAROUND_usec);

        //
        // The following operation won't overflow 32 bit operators so long
        // as currentSpeed<=115200 and MinTurnAroundTime<=10000
        //

        numExtraBOFs += (pThisDev->currentSpeed * packetInfo->MinTurnAroundTime)
                        / (BITS_PER_CHAR*usec_PER_SEC);

        //
        // Don't need minimum turn around time until our next receive.
        //

        pThisDev->fRequireMinTurnAround = FALSE;
    }

    RtlFillMemory(irPacketBuf, numExtraBOFs+1, SLOW_IR_BOF);
    totalBytes = numExtraBOFs + 1;


    for (i=0; i<ndisPacketLen; i++)
    {
        ASSERT(bufData);
        nextChar = *bufData++;
        fcs = (fcs >> 8) ^ fcsTable[(fcs ^ nextChar) & 0xff];

        totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], nextChar);

        if (--bufLen==0)
        {
            NdisGetNextBuffer(ndisBuf, &ndisBuf);
            if (ndisBuf)
            {
                NdisQueryBuffer(ndisBuf, (PVOID *)&bufData, &bufLen);
            }
            else
            {
                bufData = NULL;
            }
        }

    }

    if (bufData!=NULL)
    {
		/*
		 *  Packet was corrupt -- it misreported its size.
		 */
		DEBUGMSG(DBG_ERR, ("Packet corrupt in NdisToIrPacket (buffer lengths don't add up to packet length)."));
		*irPacketLen = 0;
		return FALSE;
    }

    fcs = ~fcs;

    // Now we escape the fcs onto the end.

    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs&0xff));
    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs>>8));

    // EOF

	irPacketBuf[totalBytes++] = SLOW_IR_EOF;


    *irPacketLen = totalBytes;

    DEBUGMSG(DBG_FUNC, ("-NdisToIrPacket converted %d-byte ndis pkt to %d-byte irda pkt:\n", ndisPacketLen, *irPacketLen));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irprops\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__AC9A01D7_B0A9_11D1_8224_000000000000__INCLUDED_)
#define AFX_STDAFX_H__AC9A01D7_B0A9_11D1_8224_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

//other includes
#include <winsock.h>
#include <af_irda.h>
#include <cpl.h>
#include <winreg.h>
#include <shlobj.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AC9A01D7_B0A9_11D1_8224_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\comm.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module comm.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/1/1996 (created)
*
*       Contents:
*
*****************************************************************************/

#include "irsir.h"

/*****************************************************************************
*
*  Function:   SetSpeed
*
*  Synopsis:   Set the baud rate of the uart and the dongle.
*
*  Arguments:  pThisDev - pointer to ir device to set the link speed
*
*  Returns:    STATUS_SUCCESS
*              STATUS_UNSUCCESSFUL
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*              This function will only be called once we know that all
*              outstanding receives and sends to the serial port have
*              been completed.
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SetSpeed(
        PIR_DEVICE pThisDev
        )
{
    ULONG       bitsPerSec, dwNotUsed;
    NTSTATUS    status;
    UCHAR       c[2];

    DEBUGMSG(DBG_FUNC, ("+SetSpeed\n"));

    if (pThisDev->linkSpeedInfo)
    {
        bitsPerSec = (ULONG)pThisDev->linkSpeedInfo->bitsPerSec;
    }
    else
    {
        bitsPerSec = 9600;
        DEBUGMSG(DBG_ERROR, ("IRSIR:  pThisDev->linkSpeedInfo not set\n"));
    }

    DEBUGMSG(DBG_STAT, ("    Requested speed = %d\n", bitsPerSec));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    // We need to be certain any data sent previously was flushed.
    // Since there are so many serial devices out there, and they
    // seem to handle flushing differently, send a little extra
    // data out to act as a plunger.

    c[0] = c[1] = SLOW_IR_EXTRA_BOF;
    (void)SerialSynchronousWrite(pThisDev->pSerialDevObj,
                                 c, sizeof(c), &dwNotUsed);

    // And just for good measure.
    NdisMSleep(50000);

    //
    // The dongle is responsible for performing the SerialSetBaudRate
    // to set the UART to the correct speed it requires for
    // performing commands and changing the rate of the dongle.
    //

    //
    // Set the speed of the dongle to the requested speed.
    //

    status = pThisDev->dongle.SetSpeed(
                                pThisDev->pSerialDevObj,
                                bitsPerSec,
                                pThisDev->currentSpeed
                                );

    if (status != STATUS_SUCCESS)
    {
        goto done;
    }

    //
    // Set the speed of the UART to the requested speed.
    //

    status = SerialSetBaudRate(
                        pThisDev->pSerialDevObj,
                        &bitsPerSec
                        );

    if (status != STATUS_SUCCESS)
    {
        goto done;
    }

    //
    // Update our current speed.
    //

    pThisDev->currentSpeed = bitsPerSec;

    done:
        DEBUGMSG(DBG_FUNC, ("-SetSpeed\n"));

        return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\crystal.c ===
/*****************************************************************************
*
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*       @doc
*       @module   crystal.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     10/30/1997 (created)
*
*       Contents: Crystal (AMP dongle specific code for initialization,
*                 deinit, and setting the baud rate of the device.
*
*****************************************************************************/

#include "irsir.h"
#include "dongle.h"

ULONG CRYSTAL_IRDA_SPEEDS = (
                                    NDIS_IRDA_SPEED_2400        |
                                    NDIS_IRDA_SPEED_9600        |
                                    NDIS_IRDA_SPEED_19200       |
                                    NDIS_IRDA_SPEED_38400       |
                                    NDIS_IRDA_SPEED_57600       |
                                    NDIS_IRDA_SPEED_115200
                                );

#define MS(d)  ((d)*1000)

/*
**  Command sequences for configuring CRYSTAL chip.
*/
UCHAR CrystalSetPrimaryRegisterSet[]    = { 0xD0 };
UCHAR CrystalSetSecondaryRegisterSet[]  = { 0xD1 };
UCHAR CrystalSetSpeed2400[]             = { 0x10, 0x8F, 0x95, 0x11 };
UCHAR CrystalSetSpeed9600[]             = { 0x10, 0x87, 0x91, 0x11 };
UCHAR CrystalSetSpeed19200[]            = { 0x10, 0x8B, 0x90, 0x11 };
UCHAR CrystalSetSpeed38400[]            = { 0x10, 0x85, 0x90, 0x11 };
UCHAR CrystalSetSpeed57600[]            = { 0x10, 0x83, 0x90, 0x11 };
UCHAR CrystalSetSpeed115200[]           = { 0x10, 0x81, 0x90, 0x11 };
UCHAR CrystalSetIrdaMode[]              = { 0x0B, 0x53, 0x47, 0x63, 0x74, 0xD1, 0x56, 0xD0 };
UCHAR CrystalSetASKMode[]               = { 0x0b, 0x43, 0x62, 0x54 };
UCHAR CrystalSetLowPower[]              = { 0x09, 0x00 };

#if 1
static BOOLEAN
CrystalWriteCommand(IN PDEVICE_OBJECT pSerialDevObj,
                    IN PUCHAR pCommand, UINT Length)
{
    SerialSetTimeouts(pSerialDevObj, &SerialTimeoutsInit);
    while (Length--)
    {
        UCHAR Response;
        ULONG BytesRead;
        ULONG BytesWritten = 0;
        NTSTATUS Status;

        (void)SerialSynchronousWrite(pSerialDevObj,
                                     pCommand,
                                     1,
                                     &BytesWritten);

        if (BytesWritten!=1)
        {
            return FALSE;
        }

        Status = SerialSynchronousRead(pSerialDevObj,
                                       &Response,
                                       1,
                                       &BytesRead);
        if (Status!=STATUS_SUCCESS || Response!=*pCommand)
        {
            if (BytesRead)
            {
                DEBUGMSG(DBG_ERROR, ("Expected: %02X Got: %02X\n", *pCommand, Response));
            }
            return FALSE;
        }
        pCommand++;
    }
    return TRUE;
}
#else
BOOLEAN CrystalWriteCmd(IN PDEVICE_OBJECT pSerialDevObj, IN PUCHAR pCmd, IN ULONG Len)
{
    NTSTATUS Status;
    ULONG BytesWritten, BytesRead, i, j;
    UCHAR c;

    SerialSetTimeouts(pSerialDevObj, &SerialTimeoutsInit);

    for (i=0;
         i<20000;
         i++)
    {
        if (SerialSynchronousRead(pSerialDevObj, &c, 1, &BytesRead)!=STATUS_SUCCESS)
        {
            break;
        }
    }

    for (i=0; i<Len; i++)
    {
        Status = SerialSynchronousWrite(pSerialDevObj, &pCmd[i], 1, &BytesWritten);

        if (Status!=STATUS_SUCCESS || BytesWritten!=1)
            return FALSE;

        // The dongle is not particularly responsive, so we need to give it some time.
        j = 0;
        do
        {
            Status = SerialSynchronousRead(pSerialDevObj, &c, 1, &BytesRead);
            if (BytesRead==0)
            {
                NdisMSleep(MS(10));
            }
        } while ( BytesRead==0 && j++<3);

        if (Status!=STATUS_SUCCESS || c!=pCmd[i])
            return FALSE;
    }

    return TRUE;
}
#endif

BOOLEAN CrystalReadRev(IN PDEVICE_OBJECT pSerialDevObj, OUT PUCHAR pRev)
{
    UCHAR readval, writeval = 0xC0;
    ULONG BytesWritten, BytesRead;
    NTSTATUS Status = STATUS_SUCCESS;

    /*
    **  Set secondary register set
    */

    if (!CrystalWriteCommand(pSerialDevObj,
                             CrystalSetSecondaryRegisterSet,
                             sizeof(CrystalSetSecondaryRegisterSet)))
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    if (Status==STATUS_SUCCESS)
    {
        Status = SerialSynchronousWrite(pSerialDevObj, &writeval, 1, &BytesWritten);
    }

    if (Status==STATUS_SUCCESS && BytesWritten==1)
    {
        NdisMSleep(MS(10));
        Status = SerialSynchronousRead(pSerialDevObj, &readval, 1, &BytesRead);
    }

    if (Status==STATUS_SUCCESS && BytesRead==1)
    {
        if ((readval & 0xF0) != writeval){
            return FALSE;
        }

        *pRev = (readval & 0x0F);

        /*
        **  Switch back to primary register set
        */
        CrystalWriteCommand(pSerialDevObj,
                            CrystalSetPrimaryRegisterSet,
                            sizeof(CrystalSetPrimaryRegisterSet));
    }

#if DBG
    if (Status!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERR, ("CrystalReadRev failed 0x%08X\n", Status));
    }
#endif

    return ((Status==STATUS_SUCCESS) ? TRUE : FALSE);
}

static BOOLEAN CrystalSetIrDAMode(IN PDEVICE_OBJECT pSerialDevObj, OUT PUCHAR pRev)
{
    UINT        i;
    ULONG       BytesWritten;
    NTSTATUS    Status;
    ULONG       Speed9600 = 9600;

    //(void)SerialSetBaudRate(pSerialDevObj, &Speed9600);
    (void)SerialPurge(pSerialDevObj);

    for (i=0; i<5; i++)
    {
        (void)SerialSetDTR(pSerialDevObj);
        (void)SerialSetRTS(pSerialDevObj);
        NdisMSleep(MS(50));
        (void)SerialClrRTS(pSerialDevObj);
        NdisMSleep(MS(50));

        if (!CrystalWriteCommand(pSerialDevObj,
                                 CrystalSetIrdaMode,
                                 sizeof(CrystalSetIrdaMode)))
        {
            continue;
        }

        if (CrystalReadRev(pSerialDevObj, pRev))
        {
            return TRUE;
        }
    }
    DEBUGMSG(DBG_ERR, ("IRSIR: Failed to set CrystalIrDAMode\n"));
    return FALSE;
}

NDIS_STATUS
Crystal_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    pDongleCaps->supportedSpeedsMask    = CRYSTAL_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    return NDIS_STATUS_SUCCESS;
}

/*****************************************************************************
*
*  Function:   Crystal_Init
*
*  Synopsis:   Initialize the Crystal dongle.
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS
*              DONGLE_CAPABILITIES
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              03-04-1998   stana     author
*
*  Notes:
*
*****************************************************************************/

NDIS_STATUS
Crystal_Init(
        IN  PDEVICE_OBJECT       pSerialDevObj
        )
{
    ULONG BytesRead, BytesWritten;
    UCHAR Response, Revision;
    BOOLEAN Reset = FALSE;
    UINT i;

    DEBUGMSG(DBG_FUNC, ("+Crystal_Init\n"));

    if (!CrystalSetIrDAMode(pSerialDevObj, &Revision))
    {
        return NDIS_STATUS_FAILURE;
    }

    //
    // Clear command mode
    //
    (void)SerialClrDTR(pSerialDevObj);
    NdisMSleep(MS(50));

    if (Revision==0x1)
    {
        // This is Rev C, which doesn't support 115200

        CRYSTAL_IRDA_SPEEDS &= ~NDIS_IRDA_SPEED_115200;
    }
    else
    {
        CRYSTAL_IRDA_SPEEDS |= NDIS_IRDA_SPEED_115200;
    }


    DEBUGMSG(DBG_FUNC, ("-Crystal_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   Crystal_Deinit
*
*  Synopsis:   The Crystal dongle doesn't require any special deinit, but for
*              purposes of being symmetrical with other dongles...
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              03-04-1998   stana     author
*
*  Notes:
*
*
*****************************************************************************/

VOID
Crystal_Deinit(
        IN PDEVICE_OBJECT pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+Crystal_Deinit\n"));

    (void)SerialClrDTR(pSerialDevObj);
    (void)SerialClrRTS(pSerialDevObj);

    DEBUGMSG(DBG_FUNC, ("-Crystal_Deinit\n"));
    return;
}

/*****************************************************************************
*
*  Function:   Crystal_SetSpeed
*
*  Synopsis:   set the baud rate of the Crystal dongle
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS if bitsPerSec = 9600 || 19200 || 115200
*              NDIS_STATUS_FAILURE otherwise
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    stana   author
*
*  Notes:
*              The caller of this function should set the baud rate of the
*              serial driver (UART) to 9600 first to ensure that dongle
*              receives the commands.
*
*
*****************************************************************************/

NDIS_STATUS
Crystal_SetSpeed(
        IN PDEVICE_OBJECT pSerialDevObj,
        IN UINT bitsPerSec,
        IN UINT currentSpeed
        )
{
    ULONG       WaitMask = SERIAL_EV_TXEMPTY;
    UCHAR       *SetSpeedString, Revision;
    ULONG       SetSpeedStringLength, BytesWritten;
    ULONG       Speed9600 = 9600;
    BOOLEAN     Result;


    DEBUGMSG(DBG_FUNC, ("+Crystal_SetSpeed\n"));

    switch (bitsPerSec)
    {
        #define MAKECASE(speed) \
            case speed: SetSpeedString = CrystalSetSpeed##speed; SetSpeedStringLength = sizeof(CrystalSetSpeed##speed); break;

        MAKECASE(2400)
        MAKECASE(9600)
        MAKECASE(19200)
        MAKECASE(38400)
        MAKECASE(57600)
        MAKECASE(115200)
        default:
            return NDIS_STATUS_FAILURE;
    }

    (void)SerialSetBaudRate(pSerialDevObj, &Speed9600);
    (void)SerialPurge(pSerialDevObj);

    NdisMSleep(MS(20));
    (void)SerialSetDTR(pSerialDevObj);
    NdisMSleep(MS(50));

    if (!CrystalWriteCommand(pSerialDevObj,
                             SetSpeedString,
                             SetSpeedStringLength))
    {
        if (!CrystalSetIrDAMode(pSerialDevObj, &Revision) ||
            !CrystalWriteCommand(pSerialDevObj, SetSpeedString, SetSpeedStringLength))
        {
            // Always clear DTR to get out of command mode.
            (void)SerialClrDTR(pSerialDevObj);

            return NDIS_STATUS_FAILURE;
        }


    }

    (void)SerialClrDTR(pSerialDevObj);
    NdisMSleep(MS(50));

    DEBUGMSG(DBG_FUNC, ("-Crystal_SetSpeed\n"));

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\actisys.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   actisys.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     10/30/1997 (created)
*
*       Contents: ACTiSYS dongle specific code for initialization,
*                 deinit, and setting the baud rate of the device.
*
*****************************************************************************/

#include "irsir.h"
#include "dongle.h"

#define ACT200L_IRDA_SPEEDS         ( \
                                    NDIS_IRDA_SPEED_2400        |       \
                                    NDIS_IRDA_SPEED_9600        |       \
                                    NDIS_IRDA_SPEED_19200       |       \
                                    NDIS_IRDA_SPEED_38400       |       \
                                    NDIS_IRDA_SPEED_57600       |       \
                                    NDIS_IRDA_SPEED_115200              \
                                )

#define MS(d)  ((d)*1000)

#if 0
static UCHAR Act200LReset[]            = { 0xf0 };
static UCHAR Act200LSetIrDAMode[]      = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0 };
static UCHAR Act200LSetSpeed2400[]     = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0, 0x8F, 0x95, 0x11 };
static UCHAR Act200LSetSpeed9600[]     = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0, 0x87, 0x91, 0x11 };
static UCHAR Act200LSetSpeed19200[]    = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0, 0x8B, 0x90, 0x11 };
static UCHAR Act200LSetSpeed38400[]    = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0, 0x85, 0x90, 0x11 };
static UCHAR Act200LSetSpeed57600[]    = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0, 0x83, 0x90, 0x11 };
static UCHAR Act200LSetSpeed115200[]   = { 0x03, 0x47, 0x53, 0x64, 0x76, 0xD1, 0x56, 0xD0, 0x81, 0x90, 0x11 };
#else
static UCHAR Act200LReset[]            = { 0xf0 };
static UCHAR Act200LSetIrDAMode[]      = { 0x0B, 0x53, 0x47, 0x63, 0x74, 0xD1, 0x56, 0xD0 };
static UCHAR Act200LSetSpeed2400[]     = { 0x8F, 0x95, 0x11 };
static UCHAR Act200LSetSpeed9600[]     = { 0x87, 0x91, 0x11 };
static UCHAR Act200LSetSpeed19200[]    = { 0x8B, 0x90, 0x11 };
static UCHAR Act200LSetSpeed38400[]    = { 0x85, 0x90, 0x11 };
static UCHAR Act200LSetSpeed57600[]    = { 0x83, 0x90, 0x11 };
static UCHAR Act200LSetSpeed115200[]   = { 0x81, 0x90, 0x11 };
#endif


static BOOLEAN ACT200L_Reset(IN PDEVICE_OBJECT pSerialDevObj)
{
    ULONG BytesRead, BytesWritten;
    UCHAR Response;
    BOOLEAN Reset = FALSE;
    UINT i;

    DEBUGMSG(DBG_FUNC, ("+ACT200L_Reset\n"));


    (void)SerialPurge(pSerialDevObj);
    SerialSetTimeouts(pSerialDevObj, &SerialTimeoutsInit);

    for (i=0; i<5 && !Reset; i++)
    {
        (void)SerialSetDTR(pSerialDevObj);
        (void)SerialSetRTS(pSerialDevObj);
        NdisMSleep(MS(100));

        (void)SerialClrRTS(pSerialDevObj);
        (void)SerialSetBreakOn(pSerialDevObj);
        NdisMSleep(MS(60));

        (void)SerialSetBreakOff(pSerialDevObj);
        (void)SerialSetRTS(pSerialDevObj);
        NdisMSleep(MS(60));

        (void)SerialClrDTR(pSerialDevObj);
        NdisMSleep(MS(20));

        (void)SerialSynchronousWrite(pSerialDevObj,
                                     Act200LReset,
                                     sizeof(Act200LReset),
                                     &BytesWritten);

        (void)SerialSynchronousRead(pSerialDevObj,
                                    &Response,
                                    1,
                                    &BytesRead);
        if (BytesRead==1 && (Response==0xF4 || Response==0xF5))
        {
            Reset = TRUE;
        }
        else
        {
            DEBUGMSG(DBG_ERROR, ("ACT200L failed to reset %d %d %x!\n", i, BytesRead, Response));
        }
    }
    DEBUGMSG(DBG_FUNC, ("-ACT200L_Reset\n"));
    return Reset;
}

static BOOLEAN
ACT200L_WriteCommand(IN PDEVICE_OBJECT pSerialDevObj,
                     IN PUCHAR pCommand, UINT Length)
{
    SerialSetTimeouts(pSerialDevObj, &SerialTimeoutsInit);
    while (Length--)
    {
        UCHAR Response;
        ULONG BytesRead;
        ULONG BytesWritten = 0;
        NTSTATUS Status;

        (void)SerialSynchronousWrite(pSerialDevObj,
                                     pCommand,
                                     1,
                                     &BytesWritten);

        if (BytesWritten!=1)
        {
            return FALSE;
        }

        Status = SerialSynchronousRead(pSerialDevObj,
                                       &Response,
                                       1,
                                       &BytesRead);
        if (Status!=STATUS_SUCCESS || Response!=*pCommand)
        {
            if (BytesRead)
            {
                DEBUGMSG(DBG_ERROR, ("Expected: %02X Got: %02X\n", *pCommand, Response));
            }
            return FALSE;
        }
        pCommand++;
    }
    return TRUE;
}

NDIS_STATUS
ACT200L_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    pDongleCaps->supportedSpeedsMask    = ACT200L_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    return NDIS_STATUS_SUCCESS;
}

static BOOLEAN ACT200L_SetIrDAMode(IN PDEVICE_OBJECT       pSerialDevObj)
{
    UINT Attempts;
    BOOLEAN Result = FALSE;

    for (Attempts=0; !Result && Attempts<5; Attempts++)
    {
        if (ACT200L_Reset(pSerialDevObj) &&
            ACT200L_WriteCommand(pSerialDevObj, Act200LSetIrDAMode, sizeof(Act200LSetIrDAMode)) &&
            ACT200L_WriteCommand(pSerialDevObj, Act200LSetSpeed9600, sizeof(Act200LSetSpeed9600)))
        {
            Result = TRUE;
        }
    }
    // Return with chip in command mode.
    return Result;
}

/*****************************************************************************
*
*  Function:   ACT200L_Init
*
*  Synopsis:   Initialize the ACTiSYS 200L dongle.
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS
*              DONGLE_CAPABILITIES
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    stana   author
*
*  Notes:
*
*****************************************************************************/

NDIS_STATUS
ACT200L_Init(
        IN  PDEVICE_OBJECT       pSerialDevObj
        )
{
    ULONG BytesRead, BytesWritten;
    UCHAR Response;
    BOOLEAN Reset = FALSE;
    UINT i;

    DEBUGMSG(DBG_FUNC, ("+ACT200L_Init\n"));

    if (!ACT200L_SetIrDAMode(pSerialDevObj))
    {
        DEBUGMSG(DBG_ERROR, ("ACT200L wouldn't SetIrDAMode! Giving up.\n"));
        return NDIS_STATUS_FAILURE;
    }

    // Clear command mode.
    (void)SerialSetDTR(pSerialDevObj);
    NdisMSleep(MS(50));

    DEBUGMSG(DBG_FUNC, ("-ACT200L_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   ACT200L_Deinit
*
*  Synopsis:   The ACT200L dongle doesn't require any special deinit, but for
*              purposes of being symmetrical with other dongles...
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    stana   author
*
*  Notes:
*
*
*****************************************************************************/

VOID
ACT200L_Deinit(
        IN PDEVICE_OBJECT pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+ACT200L_Deinit\n"));

    (void)SerialSetDTR(pSerialDevObj);
    (void)SerialClrRTS(pSerialDevObj);
    NdisMSleep(MS(50));

    DEBUGMSG(DBG_FUNC, ("-ACT200L_Deinit\n"));
    return;
}

/*****************************************************************************
*
*  Function:   ACT200L_SetSpeed
*
*  Synopsis:   set the baud rate of the ACT200L dongle
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS if bitsPerSec = 9600 || 19200 || 115200
*              NDIS_STATUS_FAILURE otherwise
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    stana   author
*
*  Notes:
*              The caller of this function should set the baud rate of the
*              serial driver (UART) to 9600 first to ensure that dongle
*              receives the commands.
*
*
*****************************************************************************/

NDIS_STATUS
ACT200L_SetSpeed(
        IN PDEVICE_OBJECT pSerialDevObj,
        IN UINT bitsPerSec,
        IN UINT currentSpeed
        )
{
    ULONG       WaitMask = SERIAL_EV_TXEMPTY;
    UCHAR       *SetSpeedString;
    ULONG       SetSpeedStringLength, BytesWritten;
    ULONG       Speed9600 = 9600;
    BOOLEAN     Result;


    DEBUGMSG(DBG_FUNC, ("+ACT200L_SetSpeed\n"));


    switch (bitsPerSec)
    {
        #define MAKECASE(speed) \
            case speed: SetSpeedString = Act200LSetSpeed##speed; SetSpeedStringLength = sizeof(Act200LSetSpeed##speed); break;

        MAKECASE(2400)
        MAKECASE(9600)
        MAKECASE(19200)
        MAKECASE(38400)
        MAKECASE(57600)
        MAKECASE(115200)
        default:
            return NDIS_STATUS_FAILURE;
    }

    (void)SerialPurge(pSerialDevObj);

    (void)SerialClrDTR(pSerialDevObj);

    NdisMSleep(MS(50));

    if (!ACT200L_WriteCommand(pSerialDevObj, SetSpeedString, SetSpeedStringLength))
    {
        DEBUGMSG(DBG_ERROR, ("SetSpeed failed first try.\n"));
        if (!ACT200L_SetIrDAMode(pSerialDevObj) ||
            !ACT200L_WriteCommand(pSerialDevObj, SetSpeedString, SetSpeedStringLength))
        {
            return NDIS_STATUS_FAILURE;
        }
    }

    NdisMSleep(MS(50));

    (void)SerialSetDTR(pSerialDevObj);

    DEBUGMSG(DBG_FUNC, ("-ACT200L_SetSpeed\n"));

    return NDIS_STATUS_SUCCESS;
}

#define ACT220L_IRDA_SPEEDS (NDIS_IRDA_SPEED_9600    |       \
                             NDIS_IRDA_SPEED_19200   |       \
                             NDIS_IRDA_SPEED_57600   |       \
                             NDIS_IRDA_SPEED_115200)

NDIS_STATUS
ACT220L_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    DEBUGMSG(DBG_FUNC, ("+ACT220L_QueryCaps\n"));

    pDongleCaps->supportedSpeedsMask    = ACT220L_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    DEBUGMSG(DBG_FUNC, ("-ACT220L_QueryCaps\n"));
    return NDIS_STATUS_SUCCESS;
}

#define ACT220LPLUS_IRDA_SPEEDS (ACT220L_IRDA_SPEEDS | NDIS_IRDA_SPEED_38400)

NDIS_STATUS
ACT220LPlus_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    DEBUGMSG(DBG_FUNC, ("+ACT220LPlus_QueryCaps\n"));

    pDongleCaps->supportedSpeedsMask    = ACT220LPLUS_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    DEBUGMSG(DBG_FUNC, ("-ACT220LPlus_QueryCaps\n"));
    return NDIS_STATUS_SUCCESS;
}

/*****************************************************************************
*
*  Function:   ACT220L_Init
*
*  Synopsis:   Initialize the ACTiSYS 200L dongle.
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS
*              DONGLE_CAPABILITIES
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/31/1997    stana   author
*
*  Notes:
*
*****************************************************************************/

NDIS_STATUS
ACT220L_Init(IN  PDEVICE_OBJECT       pSerialDevObj)
{
    ULONG BytesRead, BytesWritten;
    UCHAR Response;
    BOOLEAN Reset = FALSE;
    UINT i;

    DEBUGMSG(DBG_FUNC, ("+ACT220L_Init\n"));

    (void)SerialSetDTR(pSerialDevObj);
    (void)SerialSetRTS(pSerialDevObj);
    NdisMSleep(MS(50));
    (void)SerialClrDTR(pSerialDevObj);
    (void)SerialSetDTR(pSerialDevObj);

    DEBUGMSG(DBG_FUNC, ("-ACT220L_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   ACT220L_Deinit
*
*  Synopsis:   The ACT220L dongle doesn't require any special deinit, but for
*              purposes of being symmetrical with other dongles...
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    stana   author
*
*  Notes:
*
*
*****************************************************************************/

VOID
ACT220L_Deinit(
        IN PDEVICE_OBJECT pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+ACT220L_Deinit\n"));

    (void)SerialClrDTR(pSerialDevObj);
    (void)SerialClrRTS(pSerialDevObj);

    DEBUGMSG(DBG_FUNC, ("-ACT220L_Deinit\n"));
    return;
}

/*****************************************************************************
*
*  Function:   ACT220L_SetSpeed
*
*  Synopsis:   set the baud rate of the ACT220L dongle
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS if bitsPerSec = 9600 || 19200 || 115200
*              NDIS_STATUS_FAILURE otherwise
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    stana   author
*
*  Notes:
*              The caller of this function should set the baud rate of the
*              serial driver (UART) to 9600 first to ensure that dongle
*              receives the commands.
*
*
*****************************************************************************/

NDIS_STATUS
ACT220L_SetSpeed(
        IN PDEVICE_OBJECT pSerialDevObj,
        IN UINT bitsPerSec,
        IN UINT currentSpeed
        )
{
    ULONG       NumToggles;

    DEBUGMSG(DBG_FUNC, ("+ACT220L_SetSpeed\n"));


    if (bitsPerSec==currentSpeed)
    {
        return NDIS_STATUS_SUCCESS;
    }

    //
    // We will need to 'count up' from 9600 Kbaud.
    //

    switch (bitsPerSec){
        case 9600:              NumToggles = 0;         break;
        case 19200:             NumToggles = 1;         break;
        case 57600:             NumToggles = 2;         break;
        case 115200:            NumToggles = 3;         break;
        case 38400:             NumToggles = 4;         break;
        default:
            /*
             *  Illegal speed
             */
            return NDIS_STATUS_FAILURE;
    }

    //
    // Set speed to 9600
    //

    NdisStallExecution(1);
    (void)SerialClrDTR(pSerialDevObj);
    NdisStallExecution(1);
    (void)SerialSetDTR(pSerialDevObj);

    while (NumToggles--)
    {
        NdisStallExecution(1);
        (void)SerialClrRTS(pSerialDevObj);
        NdisStallExecution(1);
        (void)SerialSetRTS(pSerialDevObj);
    }

    DEBUGMSG(DBG_FUNC, ("-ACT220L_SetSpeed\n"));

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\crystal.h ===
/*****************************************************************************
*
*  Copyright (c) 1998-1999 Microsoft Corporation
*
*       @doc
*       @module   Crystal.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     3/4/1998 (created)
*
*       Contents: Crystal (AMP) dongle specific prototypes.
*
*****************************************************************************/


#ifndef Crystal_H
#define Crystal_H

#include "dongle.h"

NDIS_STATUS Crystal_QueryCaps(
                PDONGLE_CAPABILITIES pDongleCaps
                );

NDIS_STATUS Crystal_Init(
                PDEVICE_OBJECT       pSerialDevObj
                );

void Crystal_Deinit(
                PDEVICE_OBJECT       pSerialDevObj
                );

NDIS_STATUS Crystal_SetSpeed(
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

#endif //Crystal_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\debug.h ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   debug.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/4/1996 (created)
*
*       Contents: debug output
*
*****************************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG
    #define DEBUG
    #define DEBUG_IRSIR
#endif

#ifdef DEBUG

extern int DbgSettings;

#define DEBUGMSG(dbgs,format) (((dbgs) & DbgSettings)? DbgPrint format:0)

    #define DBG_PNP      (1 << 24)
    #define DBG_TIME     (1 << 25)
    #define DBG_DBG      (1 << 26)
    #define DBG_OUT      (1 << 27)
    #define DBG_STAT     (1 << 28)
    #define DBG_FUNCTION (1 << 29)
    #define DBG_FUNC     (1 << 29)
    #define DBG_WARN     (1 << 30)
    #define DBG_ERROR    (1 << 31)
    #define DBG_ERR      (1 << 31)

    #define DBGDBG(_dbgPrint)                       \
            DbgPrint(_dbgPrint)

    #ifdef DEBUG_IRSIR

        #define DBG_D(dbgs, i) (((dbgs) & DbgSettings)? DbgPrint("IRSIR:"#i"==%d\n", (i)):0)
        #define DBG_X(dbgs, x) (((dbgs) & DbgSettings)? DbgPrint("IRSIR:"#x"==0x%0*X\n", sizeof(x)*2, ((ULONG_PTR)(x))&((1<<(sizeof(x)*8))-1) ):0)
        #define DBG_UNISTR(dbgs, s) (((dbgs) & DbgSettings)? DbgPrint("IRSIR:"#s"==%wZ\n", (s) ):0))

        #define DBGTIME(_str)                               \
            {                                               \
                LARGE_INTEGER Time;                         \
                                                            \
                KeQuerySystemTime(&Time);                   \
                DEBUGMSG(DBG_TIME, (_str " %d:%d\n",        \
                                    Time.HighPart,          \
                                    Time.LowPart/10000));   \
            }
    #else // DEBUG_IRSIR

        #define DBGTIME(_str)
        #define DBGFUNC(_dbgPrint)
        #define DBGOUT(_dbgPrint)
        #define DBGERR(_dbgPrint)
        #define DBGWARN(_dbgPrint)
        #define DBGSTAT(_dbgPrint)
        #define DBGTIME(_dbgPrint)
        #define DEBUGMSG(dbgs,format)

    #endif // DEBUG_IRSIR

#else // DEBUG

    #define DBGTIME(_str)
    #define DBGFUNC(_dbgPrint)
    #define DBGDBG(_dbgPrint)
    #define DBGOUT(_dbgPrint)
    #define DBGERR(_dbgPrint)
    #define DBGWARN(_dbgPrint)
    #define DBGSTAT(_dbgPrint)
    #define DEBUGMSG(dbgs,format)
    #define DBG_D(dbgs, ivar)
    #define DBG_X(dbgs, xvar)
    #define DBG_UNISTR(dbgs, svar)

#endif // DEBUG

#ifndef LIST_CHECKING
#define LIST_CHECKING 0
#endif

#ifndef MEM_CHECKING
#define MEM_CHECKING 0
#endif

#ifndef LOGGING
#define LOGGING 0
#endif

#if LOGGING
typedef struct {
    UHALF_PTR Tag;
    UHALF_PTR Line;
    ULONG_PTR  Data[3];
} LOG;

#define NUM_LOG 1024

extern ULONG LogIndex;
extern LOG   Log[NUM_LOG];

#define NextLog()  ((NdisInterlockedIncrement(&LogIndex)-1)&(NUM_LOG-1))
#define LOG_ENTRY(tag, d1, d2, d3)              \
{                                               \
    ULONG ThisLog = NextLog();                  \
    Log[ThisLog].Tag = (tag);                   \
    Log[ThisLog].Line = __LINE__;               \
    Log[ThisLog].Data[0] = (ULONG_PTR)(d1);      \
    Log[ThisLog].Data[1] = (ULONG_PTR)(d2);      \
    Log[ThisLog].Data[2] = (ULONG_PTR)(d3);      \
}
#else
#define LOG_ENTRY(tag, d1, d2, d3)
#endif

#if LIST_CHECKING
PLIST_ENTRY FASTCALL MyInterlockedInsertHeadList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock);
PLIST_ENTRY FASTCALL MyInterlockedInsertTailList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock);
PLIST_ENTRY FASTCALL MyInterlockedRemoveHeadList(PLIST_ENTRY Head, PNDIS_SPIN_LOCK SpinLock);
VOID FASTCALL CheckList(PLIST_ENTRY ListHead);
#define CheckedRemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_Entry;\
    CheckList(Entry);\
    _EX_Entry = (Entry);\
    _EX_Flink = _EX_Entry->Flink;\
    _EX_Blink = _EX_Entry->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_Entry->Flink = _EX_Entry->Blink = NULL; \
    }
#ifdef RemoveEntryList
#undef RemoveEntryList
#endif
#define RemoveEntryList CheckedRemoveEntryList

#define CheckedInsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    CheckList(ListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    CheckList(ListHead);\
    }
#ifdef InsertHeadList
#undef InsertHeadList
#endif
#define InsertHeadList CheckedInsertHeadList

#define CheckedInsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    CheckList(ListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    CheckList(ListHead);\
    }
#ifdef InsertTailList
#undef InsertTailList
#endif
#define InsertTailList CheckedInsertTailList

#define CheckedRemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    if(!IsListEmpty(ListHead)){ \
        RemoveEntryList((ListHead)->Flink);\
        CheckList(ListHead);\
    }
#ifdef RemoveHeadList
#undef RemoveHeadList
#endif
#define RemoveHeadList CheckedRemoveHeadList

#define CheckedRemoveTailList(ListHead) \
    (ListHead)->Blink;\
    if(!IsListEmpty(ListHead)){ \
        RemoveEntryList((ListHead)->Blink);\
        CheckList(ListHead);\
    }
#ifdef RemoveTailList
#undef RemoveTailList
#endif
#define RemoveTailList CheckedRemoveTailList

#else // ! LIST_CHECKING
#define CheckList(h)
#define MyInterlockedInsertHeadList NdisInterlockedInsertHeadList
#define MyInterlockedInsertTailList NdisInterlockedInsertTailList
#define MyInterlockedRemoveHeadList NdisInterlockedRemoveHeadList
#endif

#if MEM_CHECKING
#define MyMemAlloc(size)  _MyMemAlloc((size),__FILE__,__LINE__)
PVOID _MyMemAlloc(UINT, PUCHAR, UINT);
VOID InitMemory();
VOID DeinitMemory();
#else
PVOID MyMemAlloc(UINT);
#endif

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\esi.h ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   esi.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     9/30/1996 (created)
*
*       Contents: ESI 9680 JetEye dongle specific prototypes.
*
*****************************************************************************/

#include "dongle.h"

#ifndef ESI_H
#define ESI_H

NDIS_STATUS ESI_QueryCaps(
                PDONGLE_CAPABILITIES pDongleCaps
                );

NDIS_STATUS ESI_Init(
                PDEVICE_OBJECT       pSerialDevObj
                );

void ESI_Deinit(
                PDEVICE_OBJECT       pSerialDevObj
                );

NDIS_STATUS ESI_SetSpeed(
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

#endif ESI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\dongle.h ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   dongle.h | IrSIR NDIS Minport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     9/30/1996 (created)
*
*       Contents:
*                 dongle settings
*
*****************************************************************************/

#ifndef DONGLE_H
#define DONGLE_H

//
// Some UART transceiver have minor differences which require special
// treatment. We will retrieve the type out of the registry.
// Any changes to this MUST also be reflected in the oemsetup.inf
// which allows the user to modify transceiver type.
//

typedef enum _IR_TRANSCEIVER_TYPE {
                    STANDARD_UART   = 0,
                    ACTISYS_200L,
                    ACTISYS_220L,
                    ACTISYS_220LPLUS,
                    AMP_PHASIR,
                    ESI_9680,
                    PARALLAX,
                    TEKRAM_IRMATE_210,
                    TEMIC_TOIM3232,
                    GIRBIL,
//                    CRYSTAL,
//                    NSC_DEMO_BD,    // NSC PC87108 demo board

                    NUM_TRANSCEIVER_TYPES
} IR_TRANSCEIVER_TYPE;

//
// ir speed masks
//

#define NDIS_IRDA_SPEED_2400       (UINT)(1 << 0)    // SLOW IR ...
#define NDIS_IRDA_SPEED_9600       (UINT)(1 << 1)
#define NDIS_IRDA_SPEED_19200      (UINT)(1 << 2)
#define NDIS_IRDA_SPEED_38400      (UINT)(1 << 3)
#define NDIS_IRDA_SPEED_57600      (UINT)(1 << 4)
#define NDIS_IRDA_SPEED_115200     (UINT)(1 << 5)
#define NDIS_IRDA_SPEED_576K       (UINT)(1 << 6)   // MEDIUM IR ...
#define NDIS_IRDA_SPEED_1152K      (UINT)(1 << 7)
#define NDIS_IRDA_SPEED_4M         (UINT)(1 << 8)   // FAST IR


typedef struct _DONGLE_CAPABILITIES
{
    //
    // Mask of NDIS_IRDA_SPEED_xxx bit values.
    //

    UINT supportedSpeedsMask;

    //
    // Time (in microseconds) that must transpire between
    // a transmit and the next receive.
    //

    UINT turnAroundTime_usec;

    //
    // Extra BOF (Beginning Of Frame) characters required
    // at the start of each received frame.
    //

    UINT extraBOFsRequired;

} DONGLE_CAPABILITIES, *PDONGLE_CAPABILITIES;

//
// Dongle init, set speed and deinit functions...all
// incorporated into a dongle interface.
//

typedef
NDIS_STATUS (_stdcall *IRSIR_QUERY_CAPS_HANDLER) (
                PDONGLE_CAPABILITIES pDongleCaps
                );

typedef
NDIS_STATUS (_stdcall *IRSIR_INIT_HANDLER) (
                PDEVICE_OBJECT       pSerialDevObj
                );

typedef
void (_stdcall *IRSIR_DEINIT_HANDLER) (
                PDEVICE_OBJECT       pSerialDevObj
                );

typedef
NDIS_STATUS (_stdcall *IRSIR_SETSPEED_HANDLER) (
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

typedef struct _DONGLE_INTERFACE
{
    IRSIR_QUERY_CAPS_HANDLER    QueryCaps;
    IRSIR_INIT_HANDLER          Initialize;
    IRSIR_SETSPEED_HANDLER      SetSpeed;
    IRSIR_DEINIT_HANDLER        Deinitialize;
} DONGLE_INTERFACE, *PDONGLE_INTERFACE;


#endif // DONGLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\esi.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   esi.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     9/30/1996 (created)
*
*       Contents: ESI 9680 JetEye dongle specific code for initialization,
*                 deinit, and setting the baud rate of the device.
*
*****************************************************************************/

#include "irsir.h"
#include "dongle.h"

#define ESI_9680_IRDA_SPEEDS    (   NDIS_IRDA_SPEED_9600     |    \
                                    NDIS_IRDA_SPEED_19200    |    \
                                    NDIS_IRDA_SPEED_115200        \
                                )

NDIS_STATUS
ESI_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    DEBUGMSG(DBG_FUNC, ("+ESI_QueryCaps\n"));

    ASSERT(pDongleCaps   != NULL);

    pDongleCaps->supportedSpeedsMask    = ESI_9680_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    DEBUGMSG(DBG_FUNC, ("-ESI_QueryCaps\n"));

    return NDIS_STATUS_SUCCESS;
}

/*****************************************************************************
*
*  Function:   ESI_Init
*
*  Synopsis:   Initialize the ESI dongle.
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS
*              DONGLE_CAPABILITIES
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*****************************************************************************/

NDIS_STATUS
ESI_Init(
        IN  PDEVICE_OBJECT       pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+ESI_Init\n"));
    DEBUGMSG(DBG_FUNC, ("-ESI_Init\n"));

    return NDIS_STATUS_SUCCESS;
}

/*****************************************************************************
*
*  Function:   ESI_Deinit
*
*  Synopsis:   The ESI dongle doesn't require any special deinit, but for
*              purposes of being symmetrical with other dongles...
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

VOID
ESI_Deinit(
        IN PDEVICE_OBJECT pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+ESI_Deinit\n"));

    DEBUGMSG(DBG_FUNC, ("-ESI_Deinit\n"));
    return;
}

/*****************************************************************************
*
*  Function:   ESI_SetSpeed
*
*  Synopsis:   set the baud rate of the ESI JetEye dongle
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS if bitsPerSec = 9600 || 19200 || 115200
*              NDIS_STATUS_FAILURE otherwise
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*              The caller of this function should set the baud rate of the
*              serial driver (UART) to 9600 first to ensure that dongle
*              receives the commands.
*
*
*****************************************************************************/

NDIS_STATUS
ESI_SetSpeed(
        IN PDEVICE_OBJECT pSerialDevObj,
        IN UINT bitsPerSec,
        IN UINT currentSpeed
        )
{
    ULONG       BaudRate;
    NDIS_STATUS status;

    DEBUGMSG(DBG_FUNC, ("+ESI_SetSpeed\n"));

    status = NDIS_STATUS_SUCCESS;

    switch (bitsPerSec)
    {
        case 9600:
        case 19200:
        case 115200:

            //
            // Set the UART baud rate so we can communicate with the
            // dongle. The baud rate needs to be 9600 to communicate
            // with the dongle.
            //

            if (currentSpeed != 9600)
            {
                BaudRate = 9600;

                status = (NDIS_STATUS) SerialSetBaudRate(
                                            pSerialDevObj,
                                            &BaudRate
                                            );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    goto done;
                }
            }

            break;

        default:

            //
            // Illegal speed setting.
            //

            DEBUGMSG(DBG_ERR, ("    Illegal speed = %d\n", bitsPerSec));

            status = NDIS_STATUS_FAILURE;

            goto done;
    }

    switch (bitsPerSec)
    {
        case 9600:

            //
            // set request-to-send
            // clear data-terminal-ready
            //

            status = (NDIS_STATUS) SerialSetRTS(pSerialDevObj);

            if (status != NDIS_STATUS_SUCCESS)
            {
                goto done;
            }

            status = (NDIS_STATUS) SerialClrDTR(pSerialDevObj);

            if (status != NDIS_STATUS_SUCCESS)
            {
                goto done;
            }

            break;

        case 19200:

            //
            // clear request-to-send
            // set data-terminal-ready
            //

            status = (NDIS_STATUS) SerialClrRTS(pSerialDevObj);

            if (status != NDIS_STATUS_SUCCESS)
            {
                goto done;
            }

            status = (NDIS_STATUS) SerialSetDTR(pSerialDevObj);

            if (status != NDIS_STATUS_SUCCESS)
            {
                goto done;
            }

            break;

        case 115200:

            //
            // set request-to-send
            // set data-terminal-ready
            //

            status = (NDIS_STATUS) SerialSetRTS(pSerialDevObj);

            if (status != NDIS_STATUS_SUCCESS)
            {
                goto done;
            }

            status = (NDIS_STATUS) SerialSetDTR(pSerialDevObj);

            if (status != NDIS_STATUS_SUCCESS)
            {
                goto done;
            }

            break;

        default:
            break;
    }

    done:
        DEBUGMSG(DBG_FUNC, ("-ESI_SetSpeed\n"));

        return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\externs.h ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   externs.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/9/1996 (created)
*
*       Contents:
*
*****************************************************************************/

#ifndef EXTERNS_H
#define EXTERNS_H


//
// Include externs for dongle modules
//

#include "esi.h"
#include "parallax.h"
#include "actisys.h"
#include "tekram.h"
#include "crystal.h"
#include "temic.h"
#include "girbil.h"
//        #include "adaptec.h"
//        #include "nscdemo.h"


//
// Externs for required miniport export functions
//

VOID IrsirHalt(
            IN NDIS_HANDLE MiniportAdapterContext
            );

NDIS_STATUS IrsirInitialize(
            OUT PNDIS_STATUS    OpenErrorStatus,
            OUT PUINT           SelectedMediumIndex,
            IN  PNDIS_MEDIUM    MediumArray,
            IN  UINT            MediumArraySize,
            IN  NDIS_HANDLE     MiniportAdapterHandle,
            IN  NDIS_HANDLE     WrapperConfigurationContext
            );

NDIS_STATUS IrsirQueryInformation(
            IN  NDIS_HANDLE MiniportAdapterContext,
            IN  NDIS_OID    Oid,
            IN  PVOID       InformationBuffer,
            IN  ULONG       InformationBufferLength,
            OUT PULONG      BytesWritten,
            OUT PULONG      BytesNeeded
            );

NDIS_STATUS IrsirSend(
            IN NDIS_HANDLE  MiniportAdapterContext,
            IN PNDIS_PACKET Packet,
            IN UINT         Flags
            );

NDIS_STATUS IrsirReset(
            OUT PBOOLEAN    AddressingReset,
            IN  NDIS_HANDLE MiniportAdapterContext
            );

NDIS_STATUS ResetIrDevice(
            IN OUT PIR_DEVICE pThisDev
            );

NDIS_STATUS IrsirSetInformation(
            IN  NDIS_HANDLE MiniportAdapterContext,
            IN  NDIS_OID    Oid,
            IN  PVOID       InformationBuffer,
            IN  ULONG       InformationBufferLength,
            OUT PULONG      BytesRead,
            OUT PULONG      BytesNeeded
            );

VOID IrsirReturnPacket(
            IN NDIS_HANDLE  MiniportAdapterContext,
            IN PNDIS_PACKET Packet
            );

VOID PassiveLevelThread(
            IN PVOID Context
            );

NTSTATUS SetIrFunctions(PIR_DEVICE pThisDev);
extern PDRIVER_OBJECT DriverObject;
//
// exported from openclos.c
//

NDIS_STATUS InitializeDevice(
            IN OUT PIR_DEVICE dev
            );

NDIS_STATUS DeinitializeDevice(
            IN OUT PIR_DEVICE dev
            );

NDIS_STATUS GetDeviceConfiguration(
            IN OUT PIR_DEVICE  dev,
            IN     NDIS_HANDLE WrapperConfigurationContext
            );

NDIS_STATUS SerialOpen(
            IN PIR_DEVICE pThisDev
            );

NDIS_STATUS SerialClose(
            IN PIR_DEVICE pThisDev
            );

NTSTATUS GetComPortNtDeviceName(IN     PUNICODE_STRING SerialDosName,
                                IN OUT PUNICODE_STRING NtDevName);

//
// exported from receive.c
//


NDIS_STATUS InitializeReceive(
            IN OUT PIR_DEVICE pThisDev
            );

//
// exported from resources.c
//

#if 0 // Defined in debug.h
PVOID MyMemAlloc(
            IN UINT size
            );
#endif

VOID MyMemFree(
            IN PVOID memptr,
            IN UINT size
            );

PIR_DEVICE NewDevice();

VOID FreeDevice(
            IN PIR_DEVICE dev
            );

PIRP SerialBuildReadWriteIrp(
            IN     PDEVICE_OBJECT   pSerialDevObj,
            IN     ULONG            MajorFunction,
            IN OUT PVOID            pBuffer,
            IN     ULONG            BufferLength,
            IN     PIO_STATUS_BLOCK pIosb
            );

NTSTATUS
SerialSynchronousWrite(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PVOID          pBuffer,
            IN ULONG          dwLength,
            OUT PULONG        pdwBytesWritten);

NTSTATUS
SerialSynchronousRead(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT PVOID         pBuffer,
            IN ULONG          dwLength,
            OUT PULONG        pdwBytesRead);

NDIS_STATUS
ScheduleWorkItem(PASSIVE_PRIMITIVE Prim,
            PIR_DEVICE        pDevice,
            WORK_PROC         Callback,
            PVOID             InfoBuf,
            ULONG             InfoBufLen);

VOID FreeWorkItem(
            IN PIR_WORK_ITEM pItem
            );

//
// exported from fcs.c
//

USHORT ComputeFCS(
            IN UCHAR *data,
            IN UINT dataLen
            );

//
// exported from convert.c
//

BOOLEAN NdisToIrPacket(
            IN  PIR_DEVICE      thisDev,
            IN  PNDIS_PACKET    Packet,
            OUT UCHAR           *irPacketBuf,
            IN  UINT            irPacketBufLen,
            OUT UINT            *irPacketLen
            );

//
// Externs for global data objects
//

extern PIR_DEVICE firstIrDevice;

//
// exported from comm.c
//

NTSTATUS SetSpeed(
            IN OUT PIR_DEVICE thisDev
            );

VOID
SetSpeedCallback(PIR_WORK_ITEM pWorkItem);
//
// exported from settings.c
//

extern baudRateInfo supportedBaudRateTable[NUM_BAUDRATES];


#endif EXTERNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\fcs.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   fcs.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/2/1996 (copied from IrMini driver)
*
*       Contents:
*
*****************************************************************************/

#include "irsir.h"

const USHORT fcsTable[256] =
{
        0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
        0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
        0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
        0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
        0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
        0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
        0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
        0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
        0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
        0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
        0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
        0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
        0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
        0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
        0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
        0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
        0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
        0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
        0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
        0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
        0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
        0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
        0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
        0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
        0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
        0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
        0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
        0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
        0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
        0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
        0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
        0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/*****************************************************************************
*
*  Function:   ComputeFCS
*
*  Synopsis:   Compute the FCS.
*
*  Arguments:  data    - a pointer to the data buffer to compute the fcs of
*              dataLen - length of the data buffer
*
*  Returns:    USHORT - the computed FCS
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

USHORT
ComputeFCS(
            UCHAR *data,
            UINT  dataLen
            )
{
    USHORT fcs = 0xffff;
    UINT i;

    DEBUGMSG(DBG_FUNC, ("+ComputeFCS. %d-byte buffer.\n", dataLen));

    for(i = 0; i < dataLen; i++)
    {
        fcs = (fcs >> 8) ^ fcsTable[(fcs ^ *data++) & 0xff];
    }

    fcs = ~fcs;

    DEBUGMSG(DBG_FUNC, ("-ComputeFCS. Returning %d=0x%x.\n", (UINT)fcs, (UINT)fcs));

    return fcs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\girbil.c ===
/*****************************************************************************
*
*  Copyright (c) 1999 Microsoft Corporation
*
*       @doc
*       @module   girbil.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     6/9/1999 (created)
*
*       Contents: GIrBIL dongle specific code for initialization,
*                 deinit, and setting the baud rate of the device.
*
*****************************************************************************/

#include "irsir.h"
#include "dongle.h"

#define GIRBIL_IRDA_SPEEDS	( \
                                    NDIS_IRDA_SPEED_2400	|	\
                                    NDIS_IRDA_SPEED_9600	|	\
                                    NDIS_IRDA_SPEED_19200	|	\
                                    NDIS_IRDA_SPEED_38400	|	\
                                    NDIS_IRDA_SPEED_57600	|	\
                                    NDIS_IRDA_SPEED_115200		\
                                )

NDIS_STATUS
GIRBIL_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    DEBUGMSG(DBG_FUNC, ("+GIRBIL_Init\n"));

    ASSERT(pDongleCaps   != NULL);

    pDongleCaps->supportedSpeedsMask    = GIRBIL_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    DEBUGMSG(DBG_FUNC, ("-GIRBIL_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   GIRBIL_Init
*
*  Synopsis:   Initialize the GIRBIL dongle.
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS
*              DONGLE_CAPABILITIES
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*****************************************************************************/

NDIS_STATUS
GIRBIL_Init(
        IN  PDEVICE_OBJECT       pSerialDevObj
        )
{
    UCHAR Data[] = { 0x07 };
    ULONG BytesWritten;
    DEBUGMSG(DBG_FUNC, ("+GIRBIL_Init\n"));

    (void)SerialSetRTS(pSerialDevObj);
    NdisMSleep(1000);
    (void)SerialClrRTS(pSerialDevObj);
    NdisMSleep(8000);
    (void)SerialSetRTS(pSerialDevObj);
    NdisMSleep(8000);
    (void)SerialSetDTR(pSerialDevObj);
    NdisMSleep(8000);
    (void)SerialClrDTR(pSerialDevObj);
    NdisMSleep(8000);

    (void)SerialSynchronousWrite(pSerialDevObj, Data, sizeof(Data), &BytesWritten);
    NdisMSleep(5000);

    (void)SerialSetDTR(pSerialDevObj);
    NdisMSleep(8000);

    DEBUGMSG(DBG_FUNC, ("-GIRBIL_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   GIRBIL_Deinit
*
*  Synopsis:   The GIRBIL dongle doesn't require any special deinit, but for
*              purposes of being symmetrical with other dongles...
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

VOID
GIRBIL_Deinit(
        IN PDEVICE_OBJECT pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+GIRBIL_Deinit\n"));


    DEBUGMSG(DBG_FUNC, ("-GIRBIL_Deinit\n"));
    return;
}

/*****************************************************************************
*
*  Function:   GIRBIL_SetSpeed
*
*  Synopsis:   set the baud rate of the GIRBIL dongle
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS if bitsPerSec = 9600 || 19200 || 115200
*              NDIS_STATUS_FAILURE otherwise
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*              The caller of this function should set the baud rate of the
*              serial driver (UART) to 9600 first to ensure that dongle
*              receives the commands.
*
*
*****************************************************************************/

NDIS_STATUS
GIRBIL_SetSpeed(
        IN PDEVICE_OBJECT pSerialDevObj,
        IN UINT bitsPerSec,
        IN UINT currentSpeed
        )
{
    ULONG       Speed = 9600;
    ULONG       BytesWritten;
    UCHAR       Data[] = { 0x00, 0x51 };

    DEBUGMSG(DBG_FUNC, ("+GIRBIL_SetSpeed\n"));


    if (bitsPerSec==currentSpeed)
    {
        return NDIS_STATUS_SUCCESS;
    }

    switch (bitsPerSec){
        case 2400:      Data[0] = 0x30;    break;
        case 9600:		Data[0] = 0x32;    break;
        case 19200:		Data[0] = 0x33;    break;
        case 38400:		Data[0] = 0x34;    break;
        case 57600:		Data[0] = 0x35;    break;
        case 115200:	Data[0] = 0x36;    break;
            break;
        default:
            /*
             *  Illegal speed
             */
            return NDIS_STATUS_FAILURE;
    }

    (void)SerialSetBaudRate(pSerialDevObj, &Speed);

    GIRBIL_Init(pSerialDevObj);

    (void)SerialClrDTR(pSerialDevObj);
    NdisMSleep(8000);

    (void)SerialSynchronousWrite(pSerialDevObj, Data, sizeof(Data), &BytesWritten);
    NdisMSleep(5000);

    (void)SerialSetDTR(pSerialDevObj);
    NdisMSleep(8000);

    DEBUGMSG(DBG_FUNC, ("-GIRBIL_SetSpeed\n"));

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\girbil.h ===
/*****************************************************************************
*
*  Copyright (c) 1999 Microsoft Corporation
*
*       @doc
*       @module   GIRBIL.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     10/15/1997 (created)
*
*       Contents: GIRBIL PRA9500A dongle specific prototypes.
*
*****************************************************************************/


#ifndef GIRBIL_H
#define GIRBIL_H

#include "dongle.h"

NDIS_STATUS GIRBIL_QueryCaps(
                PDONGLE_CAPABILITIES pDongleCaps
                );

NDIS_STATUS GIRBIL_Init(
                PDEVICE_OBJECT       pSerialDevObj
                );

void GIRBIL_Deinit(
                PDEVICE_OBJECT       pSerialDevObj
                );

NDIS_STATUS GIRBIL_SetSpeed(
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

#endif // GIRBIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\ioctl.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module ioctl.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     9/30/1996 (created)
*
*       Contents:
*                 Wrappers to the io control functions of the serial port.
*
*****************************************************************************/


#include "irsir.h"

NTSTATUS
SerialFlush(IN PDEVICE_OBJECT pSerialDevObj);


VOID
SendIoctlToSerial(
    PDEVICE_OBJECT    DeviceObject,
    PIO_STATUS_BLOCK  StatusBlock,
    ULONG             IoCtl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    );

#pragma alloc_text(PAGE, SendIoctlToSerial)
#pragma alloc_text(PAGE, SerialGetStats)
#pragma alloc_text(PAGE, SerialClearStats)
#pragma alloc_text(PAGE, SerialGetProperties)
#pragma alloc_text(PAGE, SerialGetModemStatus)
#pragma alloc_text(PAGE, SerialGetCommStatus)
#pragma alloc_text(PAGE, SerialResetDevice)
#pragma alloc_text(PAGE, SerialPurge)
#pragma alloc_text(PAGE, SerialLSRMSTInsert)
#pragma alloc_text(PAGE, SerialGetBaudRate)
#pragma alloc_text(PAGE, SerialSetBaudRate)
#pragma alloc_text(PAGE, SerialSetQueueSize)
#pragma alloc_text(PAGE, SerialGetHandflow)
#pragma alloc_text(PAGE, SerialSetHandflow)
#pragma alloc_text(PAGE, SerialGetLineControl)
#pragma alloc_text(PAGE, SerialSetLineControl)
#pragma alloc_text(PAGE, SerialSetBreakOn)
#pragma alloc_text(PAGE, SerialSetBreakOff)
#pragma alloc_text(PAGE, SerialSetTimeouts)
#pragma alloc_text(PAGE, SerialSetDTR)
#pragma alloc_text(PAGE, SerialClrDTR)
#pragma alloc_text(PAGE, SerialSetRTS)
#pragma alloc_text(PAGE, SerialClrRTS)
#pragma alloc_text(PAGE, SerialSetWaitMask)
#pragma alloc_text(PAGE, SerialFlush)
#pragma alloc_text(PAGE, SerialSynchronousWrite)
#pragma alloc_text(PAGE, SerialSynchronousRead)

//
// NOTE:
//  all IOCTL_SERIAL_xxx control codes are built using the CTL_CODE macro
//  i.e. #define IOCTL_SERIAL_GET_BAUD_RATE                  \
//                       CTL_CODE( FILE_DEVICE_SERIAL_PORT,  \
//                                 20,                       \
//                                 METHOD_BUFFERED,          \
//                                 FILE_ANY_ACCESS)
//
//  the CTL_CODE macro is defined as:
//  #define CTL_CODE( DeviceType, Function, Method, Access )                   \
//    ( ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )
//
//  all of the serial io control codes use Method = METHOD_BUFFERED
//
//  when using the IoBuildDeviceIoControlRequest(..), the function checks
//  IOCTL_SERIAL_xxx & 3
//
//  since METHOD_BUFFERED = 0
//  IoBuildDeviceIoControlRequest will always follow case 0 and allocate a buffer
//  which is large enough to contain both the input and output buffers and then
//  set the appropriate fields in the irp.
//
//  the input buffer is always copied into the buffer, so we don't have to do
//  it in the following wrapper functions
//

VOID
SendIoctlToSerial(
    PDEVICE_OBJECT    DeviceObject,
    PIO_STATUS_BLOCK  StatusBlock,
    ULONG             IoCtl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    )

{
    KEVENT            Event;
    PIRP              Irp;
    NTSTATUS          Status;

    PAGED_CODE();

    if (DeviceObject == NULL) {

        DEBUGMSG(DBG_OUT, ("    SendIoctlToSerial() No device object.\n"));

        StatusBlock->Status=STATUS_INVALID_PARAMETER;

        return;
    }


    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    //
    // build irp to get performance stats and wait for event signalled
    //
    // irp is released by io manager
    //

    Irp = IoBuildDeviceIoControlRequest(
                IoCtl,                          // io control code
                DeviceObject,                   // device object
                InputBuffer,                           // input buffer
                InputBufferLength,              // input buffer length
                OutputBuffer,                     // output buffer
                OutputBufferLength,       // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &Event,                 // event to wait for completion
                StatusBlock                  // io status block to be set
                );

    if (Irp == NULL) {

        DEBUGMSG(DBG_OUT, ("    SendIoctlToSerial(): IoBuildDeviceIoControlRequest failed.\n"));
        StatusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;

        return;
    }

    Status = IoCallDriver(DeviceObject, Irp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject(
                    &Event,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //
    }

    return;
}


/*****************************************************************************
*
*  Function:   SerialGetStats
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetStats(
            IN  PDEVICE_OBJECT     pSerialDevObj,
            OUT PSERIALPERF_STATS  pPerfStats
            )
{
    SERIALPERF_STATS    PerfStats;
    IO_STATUS_BLOCK     ioStatusBlock;

    DEBUGMSG(DBG_FUNC, ("+SerialGetStats\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_STATS,
        NULL,
        0,
        &PerfStats,                     // output buffer
        sizeof(SERIALPERF_STATS)        // output buffer length
        );

    ASSERT(sizeof(*pPerfStats) >= sizeof(SERIALPERF_STATS));

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        RtlCopyMemory(pPerfStats, &PerfStats, sizeof(SERIALPERF_STATS));
    }

    DEBUGMSG(DBG_FUNC, ("-SerialGetStats\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialClearStats
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialClearStats(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialClearStats\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_CLEAR_STATS,
        NULL,
        0,
        NULL,                     // output buffer
        0                         // output buffer length
        );

   DEBUGMSG(DBG_FUNC, ("-SerialClearStats\n"));

   return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialGetProperties
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetProperties(
            IN  PDEVICE_OBJECT     pSerialDevObj,
            OUT PSERIAL_COMMPROP   pCommProp
            )
{
    SERIAL_COMMPROP     CommProp;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialGetProperties\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_PROPERTIES,
        NULL,
        0,
        &CommProp,                      // output buffer
        sizeof(SERIAL_COMMPROP)        // output buffer length
        );

    ASSERT(sizeof(*pCommProp) >= sizeof(SERIAL_COMMPROP));

    if (NT_SUCCESS(ioStatusBlock.Status)) {

       RtlCopyMemory(pCommProp, &CommProp, sizeof(SERIAL_COMMPROP));
    }

    DEBUGMSG(DBG_FUNC, ("-SerialGetProperties\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialGetModemStatus
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetModemStatus(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG          *pModemStatus
            )
{
    ULONG               ModemStatus;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialGetModemStatus\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_MODEMSTATUS,
        NULL,
        0,
        &ModemStatus,                   // output buffer
        sizeof(ULONG)                  // output buffer length
        );

    ASSERT(sizeof(*pModemStatus) >= sizeof(ULONG));

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        RtlCopyMemory(pModemStatus, &ModemStatus, sizeof(ULONG));
    }

    DEBUGMSG(DBG_FUNC, ("-SerialGetModemStatus\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialGetCommStatus
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetCommStatus(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT PSERIAL_STATUS pCommStatus
            )
{
    SERIAL_STATUS       CommStatus;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialGetCommStatus\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_COMMSTATUS,
        NULL,
        0,
        &CommStatus,                    // output buffer
        sizeof(SERIAL_STATUS)          // output buffer length
        );

    ASSERT(sizeof(*pCommStatus) >= sizeof(SERIAL_STATUS));

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        RtlCopyMemory(pCommStatus, &CommStatus, sizeof(SERIAL_STATUS));
    }

    DEBUGMSG(DBG_FUNC, ("-SerialGetCommStatus\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialResetDevice
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialResetDevice(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialResetDevice\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_RESET_DEVICE,
        NULL,
        0,
        NULL,
        0
        );

      DEBUGMSG(DBG_FUNC, ("-SerialResetDevice\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialPurge
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialPurge(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    ULONG               BitMask;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialPurge\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_PURGE,
        &BitMask,                       // input buffer
        sizeof(ULONG),                  // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialPurge\n"));

    return ioStatusBlock.Status;

}
#if 0
/*****************************************************************************
*
*  Function:   SerialLSRMSTInsert
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialLSRMSTInsert(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN UCHAR          *pInsertionMode
            )
{
    UCHAR               InsertionMode;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialLSRMSTInsert\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_LSRMST_INSERT,
        pInsertionMode,                 // input buffer
        sizeof(UCHAR),                  // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialLSRMSTInsert\n"));

    return IoStatusBlock.Status;

}
#endif
/*****************************************************************************
*
*  Function:   SerialGetBaudRate
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetBaudRate(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG          *pBaudRate
            )
{
    ULONG               BaudRate;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialGetBaudRate\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_BAUD_RATE,     // io control code
        NULL,
        0,
        &BaudRate,                      // output buffer
        sizeof(ULONG)                  // output buffer length
        );

    ASSERT(sizeof(*pBaudRate) >= sizeof(ULONG));

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        RtlCopyMemory(pBaudRate, &BaudRate, sizeof(ULONG));
    }

    DEBUGMSG(DBG_FUNC, ("-SerialGetBaudRate\n"));


    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialSetBaudRate
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetBaudRate(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN ULONG          *pBaudRate
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetBaudRate\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_BAUD_RATE,     // io control code
        pBaudRate,                      // input buffer
        sizeof(ULONG),                  // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetBaudRate\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialSetQueueSize
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetQueueSize(
            IN PDEVICE_OBJECT     pSerialDevObj,
            IN PSERIAL_QUEUE_SIZE pQueueSize
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetQueueSize\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_QUEUE_SIZE,    // io control code
        pQueueSize,                     // input buffer
        sizeof(SERIAL_QUEUE_SIZE),      // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetQueueSize\n"));

    return ioStatusBlock.Status;

}
#if 0
/*****************************************************************************
*
*  Function:   SerialGetHandflow
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetHandflow(
            IN  PDEVICE_OBJECT    pSerialDevObj,
            OUT PSERIAL_HANDFLOW  pHandflow
            )
{
    SERIAL_HANDFLOW     Handflow;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialGetHandflow\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_HANDFLOW,      // io control code
        NULL,
        0,
        &Handflow,                      // output buffer
        sizeof(SERIAL_HANDFLOW),        // output buffer length
        );

    ASSERT(sizeof(*pHandflow) >= sizeof(SERIAL_HANDFLOW));

    RtlCopyMemory(pHandflow, &Handflow, sizeof(SERIAL_HANDFLOW));

    DEBUGMSG(DBG_FUNC, ("-SerialGetHandflow\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialSetHandflow
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetHandflow(
            IN PDEVICE_OBJECT   pSerialDevObj,
            IN PSERIAL_HANDFLOW pHandflow
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetHandflow\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_HANDFLOW,      // io control code
        pHandflow,                      // input buffer
        sizeof(SERIAL_HANDFLOW),        // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetHandflow\n"));

    return ioStatusBlock.Status;

}
#endif
/*****************************************************************************
*
*  Function:   SerialGetLineControl
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetLineControl(
            IN  PDEVICE_OBJECT       pSerialDevObj,
            OUT PSERIAL_LINE_CONTROL pLineControl
            )
{
    SERIAL_LINE_CONTROL LineControl;
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialGetLineControl\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_GET_LINE_CONTROL,
        NULL,
        0,
        &LineControl,                   // output buffer
        sizeof(SERIAL_LINE_CONTROL)    // output buffer length
        );


    ASSERT(sizeof(*pLineControl) >= sizeof(SERIAL_LINE_CONTROL));

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        RtlCopyMemory(pLineControl, &LineControl, sizeof(SERIAL_LINE_CONTROL));
    }

    DEBUGMSG(DBG_FUNC, ("-SerialGetLineControl\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialSetLineControl
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetLineControl(
            IN PDEVICE_OBJECT       pSerialDevObj,
            IN PSERIAL_LINE_CONTROL pLineControl
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetLineControl\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_LINE_CONTROL,  // io control code
        pLineControl,                   // input buffer
        sizeof(SERIAL_LINE_CONTROL),    // input buffer length
        NULL,
        0
        );

      DEBUGMSG(DBG_FUNC, ("-SerialResetDevice\n"));

    return ioStatusBlock.Status;

}

/*****************************************************************************
*
*  Function:   SerialSetBreakOn
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetBreakOn(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetBreakOn\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_BREAK_ON,      // io control code
        NULL,
        0,
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetBreakOn\n"));

    return ioStatusBlock.Status;

}
/*****************************************************************************
*
*  Function:   SerialSetBreakOff
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetBreakOff(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetBreakOff\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_BREAK_OFF,      // io control code
        NULL,
        0,
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetBreakOff\n"));

    return ioStatusBlock.Status;

}
#if 0
/*****************************************************************************
*
*  Function:   SerialGetTimeouts
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetTimeouts(
            IN  PDEVICE_OBJECT    pSerialDevObj,
            OUT PSERIAL_TIMEOUTS  pTimeouts
            )
{
    PIRP                pIrp;
    SERIAL_TIMEOUTS     Timeouts;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialGetTimeouts\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to get baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_GET_TIMEOUTS,      // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                &Timeouts,                      // output buffer
                sizeof(SERIAL_TIMEOUTS),        // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    ASSERT(sizeof(*pTimeouts) >= sizeof(SERIAL_TIMEOUTS));

    RtlCopyMemory(pTimeouts, &Timeouts, sizeof(SERIAL_TIMEOUTS));

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialGetTimeouts\n"));
        return status;
}
#endif
/*****************************************************************************
*
*  Function:   SerialSetTimeouts
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetTimeouts(
            IN PDEVICE_OBJECT   pSerialDevObj,
            IN SERIAL_TIMEOUTS *pTimeouts
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetTimeouts\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_TIMEOUTS,      // io control code
        pTimeouts,                      // input buffer
        sizeof(SERIAL_TIMEOUTS),        // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetTimeouts\n"));

    return ioStatusBlock.Status;
}
#if 0
/*****************************************************************************
*
*  Function:   SerialImmediateChar
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialImmediateChar(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN UCHAR          *pImmediateChar
            )
{
    PIRP                pIrp;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialImmediateChar\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to set baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_IMMEDIATE_CHAR,    // io control code
                pSerialDevObj,                  // device object
                pImmediateChar,                 // input buffer
                sizeof(UCHAR),                  // input buffer length
                NULL,                           // output buffer
                0,                              // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialImmediateChar\n"));
        return status;
}
/*****************************************************************************
*
*  Function:   SerialXoffCounter
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NTSTATUS
SerialXoffCounter(
            IN PDEVICE_OBJECT       pSerialDevObj,
            IN PSERIAL_XOFF_COUNTER pXoffCounter
            )
{
    PIRP                pIrp;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialXoffCounter\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to set baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_XOFF_COUNTER,      // io control code
                pSerialDevObj,                  // device object
                pXoffCounter,                   // input buffer
                sizeof(SERIAL_XOFF_COUNTER),    // input buffer length
                NULL,                           // output buffer
                0,                              // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialXoffCounter\n"));
        return status;
}
#endif
/*****************************************************************************
*
*  Function:   SerialSetDTR
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetDTR(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetDTR\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_DTR,           // io control code
        NULL,
        0,
        NULL,
        0
        );


    DEBUGMSG(DBG_FUNC, ("-SerialSetDTR\n"));

    return ioStatusBlock.Status;
}

/*****************************************************************************
*
*  Function:   SerialClrDTR
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialClrDTR(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialClrDTR\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_CLR_DTR,           // io control code
        NULL,
        0,
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialClrDTR\n"));

    return ioStatusBlock.Status;
}

/*****************************************************************************
*
*  Function:   SerialSetRTS
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetRTS(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetRTS\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_RTS,           // io control code
        NULL,
        0,
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetRTS\n"));

    return ioStatusBlock.Status;
}

/*****************************************************************************
*
*  Function:   SerialClrRTS
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialClrRTS(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialClrRTS\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_CLR_RTS,           // io control code
        NULL,
        0,
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialClrRTS\n"));

    return ioStatusBlock.Status;
}
#if 0
/*****************************************************************************
*
*  Function:   SerialGetDtrRts
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetDtrRts(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG         *pDtrRts
            )
{
    PIRP                pIrp;
    ULONG               DtrRts;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialGetDtrRts\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to get baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_GET_DTRRTS,        // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                &DtrRts,                        // output buffer
                sizeof(ULONG),                  // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    ASSERT(sizeof(*pDtrRts) >= sizeof(ULONG));

    RtlCopyMemory(pDtrRts, &DtrRts, sizeof(ULONG));

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialGetDtrRts\n"));
        return status;
}
#endif
#if 0
/*****************************************************************************
*
*  Function:   SerialSetXon
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetXon(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    PIRP                pIrp;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialSetXon\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to set Xon and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_SET_XON,           // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                NULL,                           // output buffer
                0,                              // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialSetXon\n"));
        return status;
}

/*****************************************************************************
*
*  Function:   SerialSetXoff
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetXoff(
            IN PDEVICE_OBJECT pSerialDevObj
            )
{
    PIRP                pIrp;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialSetXoff\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to set Xoff and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_SET_XON,           // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                NULL,                           // output buffer
                0,                              // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialSetXoff\n"));
        return status;
}
#endif
#if 0
/*****************************************************************************
*
*  Function:   SerialGetWaitMask
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetWaitMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG         *pWaitMask
            )
{
    PIRP                pIrp;
    ULONG               WaitMask;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialGetWaitMask\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to get baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_GET_WAIT_MASK,     // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                &WaitMask,                      // output buffer
                sizeof(ULONG),                  // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    ASSERT(sizeof(*pWaitMask) >= sizeof(ULONG));

    RtlCopyMemory(pWaitMask, &WaitMask, sizeof(ULONG));

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialGetWaitMask\n"));
        return status;
}
#endif
/*****************************************************************************
*
*  Function:   SerialSetWaitMask
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetWaitMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN ULONG          *pWaitMask
            )
{
    IO_STATUS_BLOCK     ioStatusBlock;


    DEBUGMSG(DBG_FUNC, ("+SerialSetWaitMask\n"));

    SendIoctlToSerial(
        pSerialDevObj,
        &ioStatusBlock,
        IOCTL_SERIAL_SET_WAIT_MASK,     // io control code
        pWaitMask,                      // input buffer
        sizeof(ULONG),                  // input buffer length
        NULL,
        0
        );

    DEBUGMSG(DBG_FUNC, ("-SerialSetWaitMask\n"));

    return ioStatusBlock.Status;
}
#if 0
/*****************************************************************************
*
*  Function:   SerialWaitOnMask
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialWaitOnMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG         *pWaitOnMask
            )
{
    PIRP                pIrp;
    ULONG               WaitOnMask;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialWaitOnMask\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to get baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_WAIT_ON_MASK,      // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                &WaitOnMask,                    // output buffer
                sizeof(ULONG),                  // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    *pWaitOnMask = WaitOnMask;

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialWaitOnMask\n"));
        return status;
}
#endif
/*****************************************************************************
*
*  Function:   SerialCallbackOnMask
*
*  Synopsis:   Asynchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10-03-1998   stana     author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialCallbackOnMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PIO_COMPLETION_ROUTINE pRoutine,
            IN PIO_STATUS_BLOCK pIosb,
            IN PVOID Context,
            OUT PULONG pResult
            )
{
    PIRP                pIrp;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialCallbackOnMask\n"));

    NdisZeroMemory(pIosb, sizeof(IO_STATUS_BLOCK));

    //
    // build irp to get baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_WAIT_ON_MASK,      // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                pResult,                        // output buffer
                sizeof(ULONG),                  // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                NULL,                           // event to wait for completion
                pIosb                           // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    IoSetCompletionRoutine(pIrp, pRoutine, Context, TRUE, TRUE, TRUE);

    LOG_ENTRY('WI', Context, pIrp, 0);
    status = IoCallDriver(pSerialDevObj, pIrp);


    done:
        DEBUGMSG(DBG_FUNC, ("-SerialCallbackOnMask\n"));
        return status;
}

#if 0
/*****************************************************************************
*
*  Function:   SerialGetChars
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialGetChars(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT PSERIAL_CHARS  pChars
            )
{
    PIRP                pIrp;
    SERIAL_CHARS        Chars;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialGetChars\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to get baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_GET_CHARS,         // io control code
                pSerialDevObj,                  // device object
                NULL,                           // input buffer
                0,                              // input buffer length
                &Chars,                         // output buffer
                sizeof(SERIAL_CHARS),           // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    ASSERT(sizeof(*pChars) >= sizeof(SERIAL_CHARS));

    RtlCopyMemory(pChars, &Chars, sizeof(SERIAL_CHARS));

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialGetChars\n"));
        return status;
}

/*****************************************************************************
*
*  Function:   SerialSetChars
*
*  Synopsis:   Synchronous I/O control request to serial device object.
*
*  Arguments:
*
*  Returns:    STATUS_SUCCESS
*              STATUS_INSUFFICIENT_RESOURCES
*              STATUS_UNSUCCESSFUL or other failure if IoCallDriver fails
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              9/30/1996    sholden   author
*
*  Notes:
*
*  This routine must be called from IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialSetChars(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PSERIAL_CHARS  pChars
            )
{
    PIRP                pIrp;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;


    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialSetChars\n"));

    //
    // event to wait for completion of serial driver
    //

    KeInitializeEvent(
                &eventComplete,
                NotificationEvent,
                FALSE
                );

    //
    // build irp to set baud rate and wait for event signalled
    //
    // irp is released by io manager
    //

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_SERIAL_SET_CHARS,         // io control code
                pSerialDevObj,                  // device object
                pChars,                         // input buffer
                sizeof(SERIAL_CHARS),           // input buffer length
                NULL,                           // output buffer
                0,                              // output buffer length
                FALSE,                          // calls IRP_MJ_DEVICE_CONTROL
                                                // rather than IRP_MJ_INTERNAL_DEVICE_CONTROL
                &eventComplete,                 // event to wait for completion
                &ioStatusBlock                  // io status block to be set
                );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    IoBuildDeviceIoControlRequest() failed.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto done;
    }

    status = IoCallDriver(pSerialDevObj, pIrp);

    //
    // if IoCallDriver returns STATUS_PENDING, we need to wait for the event
    //

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
                    &eventComplete,     // object to wait for
                    Executive,          // reason to wait
                    KernelMode,         // processor mode
                    FALSE,              // alertable
                    NULL                // timeout
                    );

        //
        // we can get the status of the IoCallDriver from the io status
        // block
        //

        status = ioStatusBlock.Status;
    }

    //
    // if IoCallDriver returns something other that STATUS_PENDING, then it
    // is the same as what the serial driver set in ioStatusBlock.Status
    //

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    IoCallDriver() failed. Returned = 0x%.8x\n", status));

        goto done;
    }

    done:
        DEBUGMSG(DBG_FUNC, ("-SerialSetChars\n"));
        return status;
}
#endif

NTSTATUS IrpCompleteSetEvent(IN PDEVICE_OBJECT pDevObj,
                             IN PIRP           pIrp,
                             IN PVOID          pContext)
{
    PKEVENT pEvent = pContext;

    DEBUGMSG(DBG_FUNC, ("+IrpCompleteSetEvent\n"));
    KeSetEvent(pEvent, 0, FALSE);

    *pIrp->UserIosb = pIrp->IoStatus;

    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, ("-IrpCompleteSetEvent\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}
NTSTATUS
SerialFlush(IN PDEVICE_OBJECT pSerialDevObj)
{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IOStatus;
    ULONG               WaitMask = SERIAL_EV_TXEMPTY;

    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialFlush\n"));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    RtlZeroMemory(&IOStatus, sizeof(IOStatus));

    Irp = SerialBuildReadWriteIrp(pSerialDevObj,
                                  IRP_MJ_FLUSH_BUFFERS,
                                  NULL,
                                  0,
                                  &IOStatus);

    if (Irp == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto sfDone;
    }

    IoSetCompletionRoutine(Irp,
                           IrpCompleteSetEvent,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    Status = IoCallDriver(pSerialDevObj, Irp);

    if (Status == STATUS_PENDING)
    {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
    }
    Status = IOStatus.Status;

sfDone:

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERR, ("    SerialFlush() Failed. 0x%08X\n\n", Status));
    }
#endif

    DEBUGMSG(DBG_FUNC, ("-SerialFlush\n"));
    return Status;
}

NTSTATUS
SerialSynchronousWrite(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PVOID          pBuffer,
            IN ULONG          dwLength,
            OUT PULONG        pdwBytesWritten)
{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IOStatus;
    ULONG               WaitMask = SERIAL_EV_TXEMPTY;

    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialSynchronousWrite\n"));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //(void)SerialSetWaitMask(pSerialDevObj, &WaitMask);

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    RtlZeroMemory(&IOStatus, sizeof(IOStatus));

    Irp = SerialBuildReadWriteIrp(pSerialDevObj,
                                  IRP_MJ_WRITE,
                                  pBuffer,
                                  dwLength,
                                  &IOStatus);

    if (Irp == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto sswDone;
    }

    IoSetCompletionRoutine(Irp,
                           IrpCompleteSetEvent,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    Status = IoCallDriver(pSerialDevObj, Irp);

    if (Status == STATUS_PENDING)
    {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
    }
    Status = IOStatus.Status;

    // This truncates if 64 bits.  Don't think we'll be reading or writing more than
    // 4.5 GB to a serial port soon.
    *pdwBytesWritten = (ULONG)IOStatus.Information;

    (void)SerialFlush(pSerialDevObj);
    //(void)SerialWaitOnMask(pSerialDevObj, &WaitMask);

sswDone:

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERR, ("    SerialSynchronousWrite() Failed. 0x%08X\n\n", Status));
    }
#endif

    DEBUGMSG(DBG_FUNC, ("-SerialSynchronousWrite\n"));
    return Status;
}

NTSTATUS
SerialSynchronousRead(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT PVOID         pBuffer,
            IN ULONG          dwLength,
            OUT PULONG        pdwBytesRead)
{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IOStatus;

    *pdwBytesRead = 0;

    if (!pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialSynchronousRead\n"));

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    RtlZeroMemory(&IOStatus, sizeof(IOStatus));

    Irp = SerialBuildReadWriteIrp(pSerialDevObj,
                                  IRP_MJ_READ,
                                  pBuffer,
                                  dwLength,
                                  &IOStatus);

    if (Irp == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ssrDone;
    }

    IoSetCompletionRoutine(Irp,
                           IrpCompleteSetEvent,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    Status = IoCallDriver(pSerialDevObj, Irp);

    if (Status == STATUS_PENDING)
    {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
    }

    Status = IOStatus.Status;

    // This truncates if 64 bits.  Don't think we'll be reading or writing more than
    // 4.5 GB to a serial port soon.
    *pdwBytesRead = (ULONG)IOStatus.Information;


ssrDone:

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_WARN, ("    SerialSynchronousRead() Failed. 0x%08X\n\n", Status));
    }
#endif

    DEBUGMSG(DBG_FUNC, ("-SerialSynchronousRead\n"));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\ioctl.h ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   ioctl.h | IrSIR NDIS Minport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/1/1996 (created)
*
*       Contents:
*
*****************************************************************************/

#ifndef _IOCTL_H_
#define _IOCTL_H_

#include "irsir.h"

extern
NTSTATUS
SerialGetStats(
            IN  PDEVICE_OBJECT     pSerialDevObj,
            OUT PSERIALPERF_STATS  pPerfStats
            );

extern
NTSTATUS
SerialClearStats(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialGetProperties(
            IN  PDEVICE_OBJECT     pSerialDevObj,
            OUT PSERIAL_COMMPROP   pCommProp
            );

extern
NTSTATUS
SerialGetModemStatus(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG          *pModemStatus
            );

extern
NTSTATUS
SerialGetCommStatus(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT PSERIAL_STATUS pCommStatus
            );

extern
NTSTATUS
SerialResetDevice(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialPurge(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialLSRMSTInsert(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN UCHAR          *pInsertionMode
            );

extern
NTSTATUS
SerialGetBaudRate(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG          *pBaudRate
            );

extern
NTSTATUS
SerialSetBaudRate(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN ULONG          *pBaudRate
            );

extern
NTSTATUS
SerialSetQueueSize(
            IN PDEVICE_OBJECT     pSerialDevObj,
            IN PSERIAL_QUEUE_SIZE pQueueSize
            );

extern
NTSTATUS
SerialGetHandflow(
            IN  PDEVICE_OBJECT    pSerialDevObj,
            OUT PSERIAL_HANDFLOW  pHandflow
            );

extern
NTSTATUS
SerialSetHandflow(
            IN PDEVICE_OBJECT   pSerialDevObj,
            IN PSERIAL_HANDFLOW pHandflow
            );

extern
NTSTATUS
SerialGetLineControl(
            IN  PDEVICE_OBJECT       pSerialDevObj,
            OUT PSERIAL_LINE_CONTROL pLineControl
            );

extern
NTSTATUS
SerialSetLineControl(
            IN PDEVICE_OBJECT       pSerialDevObj,
            IN PSERIAL_LINE_CONTROL pLineControl
            );

extern
NTSTATUS
SerialSetBreakOn(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialSetBreakOff(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialGetTimeouts(
            IN  PDEVICE_OBJECT    pSerialDevObj,
            OUT PSERIAL_TIMEOUTS  pTimeouts
            );

extern
NTSTATUS
SerialSetTimeouts(
            IN PDEVICE_OBJECT   pSerialDevObj,
            IN PSERIAL_TIMEOUTS pTimeouts
            );

extern
NTSTATUS
SerialImmediateChar(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN UCHAR          *pImmediateChar
            );

extern
NTSTATUS
SerialXoffCounter(
            IN PDEVICE_OBJECT       pSerialDevObj,
            IN PSERIAL_XOFF_COUNTER pXoffCounter
            );

extern
NTSTATUS
SerialSetDTR(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialClrDTR(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialSetRTS(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialClrRTS(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialGetDtrRts(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG         *pDtrRts
            );

extern
NTSTATUS
SerialSetXon(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialSetXon(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialSetXoff(
            IN PDEVICE_OBJECT pSerialDevObj
            );

extern
NTSTATUS
SerialGetWaitMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG         *pWaitMask
            );

extern
NTSTATUS
SerialSetWaitMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN ULONG          *pWaitMask
            );

extern
NTSTATUS
SerialWaitOnMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            OUT ULONG         *pWaitOnMask
            );

extern
NTSTATUS
SerialCallbackOnMask(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PIO_COMPLETION_ROUTINE pRoutine,
            IN PIO_STATUS_BLOCK pIosb,
            IN PVOID Context,
            IN PULONG pResult
            );

extern
NTSTATUS
SerialGetChars(
            IN  PDEVICE_OBJECT pSerialDevObj,
            OUT PSERIAL_CHARS  pChars
            );

extern
NTSTATUS
SerialSetChars(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PSERIAL_CHARS  pChars
            );


#endif // _IOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\irsir.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   irsir.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/3/1996 (created)
*
*       Contents:
*
*****************************************************************************/

#include "irsir.h"

VOID
ResetCallback(
    PIR_WORK_ITEM pWorkItem
    );

NDIS_STATUS
ResetIrDevice(
    PIR_DEVICE pThisDev
    );

VOID
StopWorkerThread(
    PIR_DEVICE  pThisDev
    );



NDIS_STATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

#pragma NDIS_INIT_FUNCTION(DriverEntry)

#pragma alloc_text(PAGE,ResetCallback)
#pragma alloc_text(PAGE,IrsirHalt)
#pragma alloc_text(PAGE,ResetIrDevice)
#pragma alloc_text(PAGE,IrsirInitialize)
#pragma alloc_text(PAGE,IrsirHalt)
#pragma alloc_text(PAGE,PassiveLevelThread)
#pragma alloc_text(PAGE,SetIrFunctions)
#pragma alloc_text(PAGE,StopWorkerThread)


//
// Global list of device objects and a spin lock to interleave access
// to the global queue.
//


#ifdef DEBUG

    int DbgSettings =
                      //DBG_PNP |
                      //DBG_TIME     |
                      //DBG_DBG      |
                      //DBG_STAT     |
                      //DBG_FUNCTION |
                      DBG_ERROR    |
                      DBG_WARN |
                      //DBG_OUT |
                      0;

#endif

// We use these timeouts when we just have to return soon.
SERIAL_TIMEOUTS SerialTimeoutsInit =
{
    30,         // ReadIntervalTimeout
    0,          // ReadTotalTimeoutMultiplier
    250,        // ReadTotalTimeoutConstant
    0,          // WriteTotalTimeoutMultiplier
    20*1000     // WriteTotalTimeoutConstant
};

// We use the timeouts while we're running, and we want to return less frequently.
SERIAL_TIMEOUTS SerialTimeoutsIdle =
{
    MAXULONG,   // ReadIntervalTimeout
    0,          // ReadTotalTimeoutMultiplier
    10,         // ReadTotalTimeoutConstant
    0,          // WriteTotalTimeoutMultiplier
    20*1000     // WriteTotalTimeoutConstant
};
#if IRSIR_EVENT_DRIVEN
// We use the timeouts while we're running, and we want to return less frequently.
SERIAL_TIMEOUTS SerialTimeoutsActive =
{
    MAXULONG,   // ReadIntervalTimeout
    0,          // ReadTotalTimeoutMultiplier
    0,          // ReadTotalTimeoutConstant
    0,          // WriteTotalTimeoutMultiplier
    0           // WriteTotalTimeoutConstant
};
#endif

/*****************************************************************************
*
*  Function:   DriverEntry
*
*  Synopsis:   register driver entry functions with NDIS
*
*  Arguments:  DriverObject - the driver object being initialized
*              RegistryPath - registry path of the driver
*
*  Returns:    value returned by NdisMRegisterMiniport
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

//
// Mark the DriverEntry function to run once during initialization.
//



#ifndef MAX_PATH
#define MAX_PATH 2048
#endif


NDIS_STATUS
DriverEntry(
            IN PDRIVER_OBJECT  pDriverObject,
            IN PUNICODE_STRING pRegistryPath
            )
{
    NDIS_STATUS                     status;
#if NDIS_MAJOR_VERSION < 5
    NDIS40_MINIPORT_CHARACTERISTICS characteristics;
#else
    NDIS50_MINIPORT_CHARACTERISTICS characteristics;
#endif
    NDIS_HANDLE hWrapper;

#if MEM_CHECKING
    InitMemory();
#endif
    DEBUGMSG(DBG_FUNC, ("+DriverEntry(irsir)\n"));

    NdisMInitializeWrapper(
                &hWrapper,
                pDriverObject,
                pRegistryPath,
                NULL
                );

    NdisZeroMemory(&characteristics, sizeof(characteristics));

    characteristics.MajorNdisVersion        =    (UCHAR)NDIS_MAJOR_VERSION;
    characteristics.MinorNdisVersion        =    (UCHAR)NDIS_MINOR_VERSION;
    characteristics.Reserved                =    0;

    characteristics.HaltHandler             =    IrsirHalt;
    characteristics.InitializeHandler       =    IrsirInitialize;
    characteristics.QueryInformationHandler =    IrsirQueryInformation;
    characteristics.SetInformationHandler   =    IrsirSetInformation;
    characteristics.ResetHandler            =    IrsirReset;

    //
    // For now we will allow NDIS to send only one packet at a time.
    //

    characteristics.SendHandler             =    IrsirSend;
    characteristics.SendPacketsHandler      =    NULL;

    //
    // We don't use NdisMIndicateXxxReceive function, so we will
    // need a ReturnPacketHandler to retrieve our packet resources.
    //

    characteristics.ReturnPacketHandler     =    IrsirReturnPacket;
    characteristics.TransferDataHandler     =    NULL;

    //
    // NDIS never calls the ReconfigureHandler.
    //

    characteristics.ReconfigureHandler      =    NULL;

    //
    // Let NDIS handle the hangs for now.
    //
    // If a CheckForHangHandler is supplied, NDIS will call it every two
    // seconds (by default) or at a driver specified interval.
    //
    // When not supplied, NDIS will conclude that the miniport is hung:
    //   1) a send packet has been pending longer than twice the
    //      timeout period
    //   2) a request to IrsirQueryInformation or IrsirSetInformation
    //      is not completed in a period equal to twice the timeout
    //      period.
    // NDIS will keep track of the NdisMSendComplete calls and probably do
    // a better job of ensuring the miniport is not hung.
    //
    // If NDIS detects that the miniport is hung, NDIS calls
    // IrsirReset.
    //

    characteristics.CheckForHangHandler     =    NULL;

    //
    // This miniport driver does not handle interrupts.
    //

    characteristics.HandleInterruptHandler  =    NULL;
    characteristics.ISRHandler              =    NULL;
    characteristics.DisableInterruptHandler =    NULL;
    characteristics.EnableInterruptHandler  =    NULL;

    //
    // This miniport does not control a busmaster DMA with
    // NdisMAllocateShareMemoryAsysnc, AllocateCompleteHandler won't be
    // called from NDIS.
    //

    characteristics.AllocateCompleteHandler =    NULL;

    //
    // Need to initialize the ir device object queue and the spin lock
    // to interleave access to the queue at this point, since after we
    // return, the driver will only deal with the device level.
    //


    status = NdisMRegisterMiniport(
                hWrapper,
                (PNDIS_MINIPORT_CHARACTERISTICS)&characteristics,
                sizeof(characteristics)
                );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    NdisMRegisterMiniport failed. Returned 0x%.8x.\n", status));
    }

    DEBUGMSG(DBG_FUNC, ("-DriverEntry(irsir)\n"));

    return status;
}


// Provide some default functions for dongle handling.

NDIS_STATUS UnknownDongleInit(PDEVICE_OBJECT NotUsed)
{
    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS UnknownDongleQueryCaps(PDONGLE_CAPABILITIES NotUsed)
{
    return NDIS_STATUS_FAILURE;
}

void UnknownDongleDeinit(PDEVICE_OBJECT NotUsed)
{
    return;
}

NDIS_STATUS UnknownDongleSetSpeed(PDEVICE_OBJECT       pSerialDevObj,
                                  UINT                 bitsPerSec,
                                  UINT                 currentSpeed
                                  )
{
    return NDIS_STATUS_FAILURE;
}


NTSTATUS SetIrFunctions(PIR_DEVICE pThisDev)
{
    NTSTATUS Status = STATUS_SUCCESS;
    //
    // Need to initialize the dongle code.
    //
    switch (pThisDev->transceiverType)
    {
        case STANDARD_UART:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- UART\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = StdUart_QueryCaps;
            pThisDev->dongle.Initialize   = StdUart_Init;
            pThisDev->dongle.SetSpeed     = StdUart_SetSpeed;
            pThisDev->dongle.Deinitialize = StdUart_Deinit;

            break;

        case ESI_9680:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- ESI_9680\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = ESI_QueryCaps;
            pThisDev->dongle.Initialize   = ESI_Init;
            pThisDev->dongle.SetSpeed     = ESI_SetSpeed;
            pThisDev->dongle.Deinitialize = ESI_Deinit;

            break;

        case PARALLAX:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- PARALLAX\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = PARALLAX_QueryCaps;
            pThisDev->dongle.Initialize   = PARALLAX_Init;
            pThisDev->dongle.SetSpeed     = PARALLAX_SetSpeed;
            pThisDev->dongle.Deinitialize = PARALLAX_Deinit;

            break;

        case ACTISYS_200L:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- ACTISYS 200L\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = ACT200L_QueryCaps;
            pThisDev->dongle.Initialize   = ACT200L_Init;
            pThisDev->dongle.SetSpeed     = ACT200L_SetSpeed;
            pThisDev->dongle.Deinitialize = ACT200L_Deinit;

            break;

        case ACTISYS_220L:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- ACTISYS 220L\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = ACT220L_QueryCaps;
            pThisDev->dongle.Initialize   = ACT220L_Init;
            pThisDev->dongle.SetSpeed     = ACT220L_SetSpeed;
            pThisDev->dongle.Deinitialize = ACT220L_Deinit;

            break;

        case ACTISYS_220LPLUS:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- ACTISYS 220L\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = ACT220LPlus_QueryCaps;
            pThisDev->dongle.Initialize   = ACT220L_Init;
            pThisDev->dongle.SetSpeed     = ACT220L_SetSpeed;
            pThisDev->dongle.Deinitialize = ACT220L_Deinit;

            break;

        case TEKRAM_IRMATE_210:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- TEKRAM IRMATE 210 or PUMA\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = TEKRAM_QueryCaps;
            pThisDev->dongle.Initialize   = TEKRAM_Init;
            pThisDev->dongle.SetSpeed     = TEKRAM_SetSpeed;
            pThisDev->dongle.Deinitialize = TEKRAM_Deinit;

            break;


        case AMP_PHASIR:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- AMP PHASIR or CRYSTAL\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = Crystal_QueryCaps;
            pThisDev->dongle.Initialize   = Crystal_Init;
            pThisDev->dongle.SetSpeed     = Crystal_SetSpeed;
            pThisDev->dongle.Deinitialize = Crystal_Deinit;

            break;

        case TEMIC_TOIM3232:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- TEMIC TOIM3232\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = TEMIC_QueryCaps;
            pThisDev->dongle.Initialize   = TEMIC_Init;
            pThisDev->dongle.SetSpeed     = TEMIC_SetSpeed;
            pThisDev->dongle.Deinitialize = TEMIC_Deinit;

            break;

        case GIRBIL:
            DEBUGMSG(DBG_OUT, ("IRSIR: Dongle type:%d -- GIRBIL\n", pThisDev->transceiverType));
            pThisDev->dongle.QueryCaps    = GIRBIL_QueryCaps;
            pThisDev->dongle.Initialize   = GIRBIL_Init;
            pThisDev->dongle.SetSpeed     = GIRBIL_SetSpeed;
            pThisDev->dongle.Deinitialize = GIRBIL_Deinit;

            break;

//        case ADAPTEC:
//        case CRYSTAL:
//        case NSC_DEMO_BD:

        default:
            DEBUGMSG(DBG_ERROR, ("    Failure: Tranceiver type is NOT supported!\n"));

            pThisDev->dongle.QueryCaps    = UnknownDongleQueryCaps;
            pThisDev->dongle.Initialize   = UnknownDongleInit;
            pThisDev->dongle.SetSpeed     = UnknownDongleSetSpeed;
            pThisDev->dongle.Deinitialize = UnknownDongleDeinit;
            // The dongle functions have already been set to stubs in
            // InitializeDevice().

            Status = NDIS_STATUS_FAILURE;

            break;
    }

    return Status;
}


/*****************************************************************************
*
*  Function:   IrsirInitialize
*
*  Synopsis:   Initializes the NIC (serial.sys) and allocates all resources
*              required to carry out network io operations.
*
*  Arguments:  OpenErrorStatus - allows IrsirInitialize to return additional
*                                status code NDIS_STATUS_xxx if returning
*                                NDIS_STATUS_OPEN_FAILED
*              SelectedMediumIndex - specifies to NDIS the medium type the
*                                    driver uses
*              MediumArray - array of NdisMediumXXX the driver can choose
*              MediumArraySize
*              MiniportAdapterHandle - handle identifying miniport's NIC
*              WrapperConfigurationContext - used with Ndis config and init
*                                            routines
*
*  Returns:    NDIS_STATUS_SUCCESS if properly configure and resources allocated
*              NDIS_STATUS_FAILURE, otherwise
*          more specific failures:
*              NDIS_STATUS_UNSUPPORTED_MEDIA - driver can't support any medium
*              NDIS_STATUS_ADAPTER_NOT_FOUND - NdisOpenConfiguration or
*                                              NdisReadConfiguration failed
*              NDIS_STATUS_OPEN_FAILED       - failed to open serial.sys
*              NDIS_STATUS_NOT_ACCEPTED      - serial.sys does not accept the
*                                              configuration
*              NDIS_STATUS_RESOURCES         - could not claim sufficient
*                                              resources
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:      NDIS will not submit requests until this is complete.
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/


NDIS_STATUS
IrsirInitialize(
            OUT PNDIS_STATUS OpenErrorStatus,
            OUT PUINT        SelectedMediumIndex,
            IN  PNDIS_MEDIUM MediumArray,
            IN  UINT         MediumArraySize,
            IN  NDIS_HANDLE  NdisAdapterHandle,
            IN  NDIS_HANDLE  WrapperConfigurationContext
            )
{
    UINT                i;
    PIR_DEVICE          pThisDev = NULL;
    SERIAL_LINE_CONTROL serialLineControl;
    SERIAL_TIMEOUTS     serialTimeouts;
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    ULONG               bitsPerSec = 9600;

    DEBUGMSG(DBG_FUNC, ("+IrsirInitialize\n"));

    //
    // Search for the irda medium in the medium array.
    //

    for (i = 0; i < MediumArraySize; i++)
    {
        if (MediumArray[i] == NdisMediumIrda)
        {
            break;
        }
    }
    if (i < MediumArraySize)
    {
        *SelectedMediumIndex = i;
    }
    else
    {
        //
        // Irda medium not found.
        //

        DEBUGMSG(DBG_ERROR, ("    Failure: NdisMediumIrda not found!\n"));
        status = NDIS_STATUS_UNSUPPORTED_MEDIA;

        goto done;
    }

    //
    // Allocate a device object and zero memory.
    //

    pThisDev = NewDevice();

    if (pThisDev == NULL)
    {
        DEBUGMSG(DBG_ERROR, ("    NewDevice failed.\n"));
        status = NDIS_STATUS_RESOURCES;

        goto done;
    }

    pThisDev->dongle.Initialize   = UnknownDongleInit;
    pThisDev->dongle.SetSpeed     = UnknownDongleSetSpeed;
    pThisDev->dongle.Deinitialize = UnknownDongleDeinit;
    pThisDev->dongle.QueryCaps    = UnknownDongleQueryCaps;

    //
    // Initialize device object and resources.
    // All the queues and buffer/packets etc. are allocated here.
    //

    status = InitializeDevice(pThisDev);

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    InitializeDevice failed. Returned 0x%.8x\n",
                status));

        goto done;
    }


    //
    // Record the NdisAdapterHandle.
    //

    pThisDev->hNdisAdapter = NdisAdapterHandle;

    //
    // NdisMSetAttributes will associate our adapter handle with the wrapper's
    // adapter handle.  The wrapper will then always use our handle
    // when calling us.  We use a pointer to the device object as the context.
    //

    NdisMSetAttributesEx(NdisAdapterHandle,
                         (NDIS_HANDLE)pThisDev,
                         0,
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                         NDIS_ATTRIBUTE_DESERIALIZE,   // Magic bullet
                         NdisInterfaceInternal);

    //
    // Initialize a notification event for signalling PassiveLevelThread.
    //

    KeInitializeEvent(
                &pThisDev->eventPassiveThread,
                SynchronizationEvent, // auto-clearing event
                FALSE                 // event initially non-signalled
                );

    KeInitializeEvent(
                &pThisDev->eventKillThread,
                SynchronizationEvent, // auto-clearing event
                FALSE                 // event initially non-signalled
                );

    //
    // Create a thread to run at IRQL PASSIVE_LEVEL.
    //

    status = (NDIS_STATUS) PsCreateSystemThread(
                                            &pThisDev->hPassiveThread,
                                            (ACCESS_MASK) 0L,
                                            NULL,
                                            NULL,
                                            NULL,
                                            PassiveLevelThread,
                                            DEV_TO_CONTEXT(pThisDev)
                                            );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    PsCreateSystemThread failed. Returned 0x%.8x\n", status));

        goto done;
    }
    // At this point we've done everything but actually touch the serial
    // port.  We do so now.

    //
    // Get device configuration from the registry settings.
    // We are getting the transceiver type and which serial
    // device object to access.
    // The information which we get from the registry will outlast
    // any NIC resets.
    //

    status = GetDeviceConfiguration(
                    pThisDev,
                    WrapperConfigurationContext
                    );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    GetDeviceConfiguration failed. Returned 0x%.8x\n",
                status));

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }

    //
    // Open the serial device object specified in the registry.
    //

    status = SerialOpen(pThisDev);

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    SerialOpen failed. Returned 0x%.8x\n", status));

        status = NDIS_STATUS_SUCCESS; // We'll get the port later.
    }

    if (pThisDev->pSerialDevObj)
    {
        {
            //
            // Set the minimum port buffering.
            //

            SERIAL_QUEUE_SIZE QueueSize;

            QueueSize.InSize = 3*1024;  // 1.5 packet size
            QueueSize.OutSize = 0;

            // Ignore failure.  We'll still work, just not as well.
            (void)SerialSetQueueSize(pThisDev->pSerialDevObj, &QueueSize);
        }

    #if 0
        {
            SERIAL_HANDFLOW Handflow;

            SerialGetHandflow(pThisDev->pSerialDevObj, &Handflow);
            DEBUGMSG(DBG_PNP, ("IRSIR: Serial Handflow was: %x %x %x %x\n",
                               Handflow.ControlHandShake,
                               Handflow.FlowReplace,
                               Handflow.XonLimit,
                               Handflow.XoffLimit));
            Handflow.ControlHandShake = 0;
            Handflow.FlowReplace = 0;
            SerialSetHandflow(pThisDev->pSerialDevObj, &Handflow);
        }
    #endif
        //
        // Must set the timeout value of the serial port
        // for a read.
        //

        status = (NDIS_STATUS) SerialSetTimeouts(pThisDev->pSerialDevObj,
                                                 &SerialTimeoutsInit);

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    SerialSetTimeouts failed. Returned 0x%.8x\n", status));
            status = NDIS_STATUS_FAILURE;

            goto done;
        }

        (void)SerialSetBaudRate(pThisDev->pSerialDevObj, &bitsPerSec);

        serialLineControl.StopBits   = STOP_BIT_1;
        serialLineControl.Parity     = NO_PARITY ;
        serialLineControl.WordLength = 8;

        status = (NDIS_STATUS) SerialSetLineControl(
                                        pThisDev->pSerialDevObj,
                                        &serialLineControl
                                        );

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    SerialSetLineControl failed. Returned 0x%.8x\n", status));

            goto done;
        }
    }
    status = SetIrFunctions(pThisDev);
    if (status!=STATUS_SUCCESS)
    {
        goto done;
    }

    if (pThisDev->pSerialDevObj)
    {
        //
        // Now that a serial device object is open, we can initialize the
        // dongle and set the speed of the dongle to the default.
        //

        if (pThisDev->dongle.Initialize(pThisDev->pSerialDevObj)!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    IRSIR: dongle failed to init!\n"));
            status = NDIS_STATUS_FAILURE;
            goto done;
        }
    }
    pThisDev->dongle.QueryCaps(&pThisDev->dongleCaps);

    if (pThisDev->pSerialDevObj)
    {
        //
        // Set the speed of the uart and the dongle.
        //

        status = (NDIS_STATUS) SetSpeed(pThisDev);

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    IRSIR: Setspeed failed. Returned 0x%.8x\n", status));

            goto done;
        }

        //
        // Create an irp and do an MJ_READ to begin our receives.
        // NOTE: All other receive processing will be done in the read completion
        //       routine which is done set from this MJ_READ.
        //

        status = InitializeReceive(pThisDev);

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    InitializeReceive failed. Returned 0x%.8x\n", status));

            goto done;
        }
    }

done:

    if (status != NDIS_STATUS_SUCCESS) {

        DEBUGMSG(DBG_ERR, ("IRSIR: IrsirInitialize failed %x\n", status));

        if (pThisDev != NULL) {

            if (pThisDev->hPassiveThread) {

                pThisDev->fPendingHalt = TRUE;

                StopWorkerThread(pThisDev);
            }

            if (pThisDev->pSerialDevObj != NULL) {

                if (pThisDev->dongle.Deinitialize) {

                    pThisDev->dongle.Deinitialize(pThisDev->pSerialDevObj);
                }

                SerialClose(pThisDev);
            }

            DeinitializeDevice(pThisDev);
            FreeDevice(pThisDev);
        }
    }

    DEBUGMSG(DBG_FUNC, ("-IrsirInitialize\n"));

    return status;
}

/*****************************************************************************
*
*  Function:   IrsirHalt
*
*  Synopsis:   Deallocates resources when the NIC is removed and halts the
*              NIC.
*
*  Arguments:  Context - pointer to the ir device object
*
*  Returns:
*
*  Algorithm:  Mirror image of IrsirInitialize...undoes everything initialize
*              did.
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/8/1996    sholden   author
*
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

VOID
IrsirHalt(
            IN NDIS_HANDLE Context
            )
{
    PIR_DEVICE pThisDev;

    DEBUGMSG(DBG_FUNC, ("+IrsirHalt\n"));

    pThisDev = CONTEXT_TO_DEV(Context);

    //
    // Let the send completion and receive completion routine know that there
    // is a pending halt.
    //

    pThisDev->fPendingHalt = TRUE;

    //
    // We want to wait until all pending receives and sends to the
    // serial device object. We call serial purge to cancel any
    // irps. Wait until sends and receives have stopped.
    //

    SerialPurge(pThisDev->pSerialDevObj);

    PausePacketProcessing(&pThisDev->SendPacketQueue,TRUE);

    FlushQueuedPackets(&pThisDev->SendPacketQueue,pThisDev->hNdisAdapter);



    while(
          (pThisDev->fReceiving == TRUE)
          )
    {
        //
        // Sleep for 20 milliseconds.
        //

        NdisMSleep(20000);
    }

    //
    // Deinitialize the dongle.
    //

    ASSERT(pThisDev->packetsHeldByProtocol==0);

    pThisDev->dongle.Deinitialize(
                            pThisDev->pSerialDevObj
                            );

    //
    // Close the serial device object.
    //

    SerialClose(pThisDev);

    //
    // Need to terminate our worker threadxs. However, the thread
    // needs to call PsTerminateSystemThread itself. Therefore,
    // we will signal it.
    //

    StopWorkerThread(pThisDev);


    //
    // Deinitialize our own ir device object.
    //

    DeinitializeDevice(pThisDev);

    //
    // Free the device names.
    //

    if (pThisDev->serialDosName.Buffer)
    {
        MyMemFree(pThisDev->serialDosName.Buffer,
                  MAX_SERIAL_NAME_SIZE
                  );
        pThisDev->serialDosName.Buffer = NULL;
    }
    if (pThisDev->serialDevName.Buffer)
    {
        MyMemFree(
                  pThisDev->serialDevName.Buffer,
                  MAX_SERIAL_NAME_SIZE
                  );
        pThisDev->serialDevName.Buffer = NULL;
    }

    //
    // Free our own ir device object.
    //

    FreeDevice(pThisDev);


    DEBUGMSG(DBG_FUNC, ("-IrsirHalt\n"));

    return;
}

VOID
ResetCallback(
    PIR_WORK_ITEM pWorkItem
    )
{
    PIR_DEVICE      pThisDev = pWorkItem->pIrDevice;
    NDIS_STATUS     status;
    BOOLEAN         fSwitchSuccessful;
    NDIS_HANDLE     hSwitchToMiniport;

    //
    // Reset this device by request of IrsirReset.
    //

    DEBUGMSG(DBG_STAT, ("    primPassive = PASSIVE_RESET_DEVICE\n"));

    ASSERT(pThisDev->fPendingReset == TRUE);

    if (pThisDev->pSerialDevObj) {

        SerialPurge(pThisDev->pSerialDevObj);
    }

    PausePacketProcessing(&pThisDev->SendPacketQueue,TRUE);

    FlushQueuedPackets(&pThisDev->SendPacketQueue,pThisDev->hNdisAdapter);



    status = ResetIrDevice(pThisDev);

#if DBG

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    ResetIrDevice failed = 0x%.8x\n", status));
    }

#endif //DBG

    //
    //

    if (status != STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(pThisDev->hNdisAdapter,
                               NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
                               1,
                               status);
        status = NDIS_STATUS_HARD_ERRORS;
    }

    NdisMResetComplete(
            pThisDev->hNdisAdapter,
            (NDIS_STATUS)status,
            TRUE
            );

    FreeWorkItem(pWorkItem);

    ActivatePacketProcessing(&pThisDev->SendPacketQueue);

    pThisDev->fPendingReset = FALSE;


    return;
}

/*****************************************************************************
*
*  Function:   IrsirReset
*
*  Synopsis:   Resets the drivers software state.
*
*  Arguments:  AddressingReset - return arg. If set to TRUE, NDIS will call
*                                MiniportSetInformation to restore addressing
*                                information to the current values.
*              Context         - pointer to ir device object
*
*  Returns:    NDIS_STATUS_PENDING
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/9/1996    sholden   author
*
*  Notes:
*
*  Runs at IRQL_DISPATCH_LEVEL, therefore we need to call a thread at
*  passive level to perform the reset.
*
*****************************************************************************/

NDIS_STATUS
IrsirReset(
            OUT PBOOLEAN    AddressingReset,
            IN  NDIS_HANDLE MiniportAdapterContext
            )
{
    PIR_DEVICE  pThisDev;
    NDIS_STATUS status;

    DEBUGMSG(DBG_STAT, ("+IrsirReset\n"));

    pThisDev = CONTEXT_TO_DEV(MiniportAdapterContext);

    //
    // Let the receive completion routine know that there
    // is a pending reset.
    //

    pThisDev->fPendingReset = TRUE;


    *AddressingReset = TRUE;

    if (ScheduleWorkItem(PASSIVE_RESET_DEVICE, pThisDev,
                ResetCallback, NULL, 0) != NDIS_STATUS_SUCCESS)
    {
        status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        status = NDIS_STATUS_PENDING;
    }

    DEBUGMSG(DBG_STAT, ("-IrsirReset\n"));

    return status;
}

/*****************************************************************************
*
*  Function:   ResetIrDevice
*
*  Synopsis:
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/17/1996   sholden   author
*
*  Notes:
*
*  The following elements of the ir device object outlast the reset:
*
*      eventPassiveThread
*      hPassiveThread
*      primPassive
*
*      serialDevName
*      pSerialDevObj
*      TransceiverType
*      dongle
*
*      hNdisAdapter
*
*****************************************************************************/

NDIS_STATUS
ResetIrDevice(
    PIR_DEVICE pThisDev
    )
{
    SERIAL_LINE_CONTROL serialLineControl;
    SERIAL_TIMEOUTS     serialTimeouts;
    NDIS_STATUS         status;
    ULONG               bitsPerSec = 9600;

    DEBUGMSG(DBG_STAT, ("+ResetIrDeviceThread\n"));

    //
    // We need to wait for the completion of all pending sends and receives
    // to the serial driver.
    //

    //
    // We can speed up by purging the serial driver.
    //

    if (pThisDev->pSerialDevObj) {

        SerialPurge(pThisDev->pSerialDevObj);

        while(
              (pThisDev->fReceiving == TRUE)
              )
        {
            //
            // Sleep for 20 milliseconds.
            //

            NdisMSleep(20000);
        }

        //
        // Deinit the dongle.
        //

        pThisDev->dongle.Deinitialize(pThisDev->pSerialDevObj);

    } else {
        //
        //  we were not able to open the serial driver when the miniport first initialized.
        //  The thread will call this routine to attempt to open the device every 3 seconds.
        //
        status = SerialOpen(pThisDev);

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    SerialOpen failed. Returned 0x%.8x\n", status));

            goto done;
        }
    }

    if (pThisDev->pSerialDevObj)
    {
        {
            //
            // Set the minimum port buffering.
            //

            SERIAL_QUEUE_SIZE QueueSize;

            QueueSize.InSize = 3*1024;  // 1.5 packet size
            QueueSize.OutSize = 0;

            // Ignore failure.  We'll still work, just not as well.
            (void)SerialSetQueueSize(pThisDev->pSerialDevObj, &QueueSize);
        }

        //
        // Must set the timeout value of the serial port
        // for a read.
        //

        status = (NDIS_STATUS) SerialSetTimeouts(pThisDev->pSerialDevObj,
                                                 &SerialTimeoutsInit);

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    SerialSetTimeouts failed. Returned 0x%.8x\n", status));
            status = NDIS_STATUS_FAILURE;

            goto done;
        }

        (void)SerialSetBaudRate(pThisDev->pSerialDevObj, &bitsPerSec);

        serialLineControl.StopBits   = STOP_BIT_1;
        serialLineControl.Parity     = NO_PARITY ;
        serialLineControl.WordLength = 8;

        status = (NDIS_STATUS) SerialSetLineControl(
                                        pThisDev->pSerialDevObj,
                                        &serialLineControl
                                        );

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("    SerialSetLineControl failed. Returned 0x%.8x\n", status));

            goto done;
        }
    }


    status = SetIrFunctions(pThisDev);
    if (status!=STATUS_SUCCESS)
    {
        goto done;
    }

    //
    // Initialize the dongle.
    //

    status = (NDIS_STATUS) SerialSetTimeouts(pThisDev->pSerialDevObj,
                                             &SerialTimeoutsInit);

    pThisDev->dongle.Initialize(pThisDev->pSerialDevObj);

    pThisDev->dongle.QueryCaps(&pThisDev->dongleCaps);
    //
    // Set the speed of the uart and the dongle.
    //

    status = (NDIS_STATUS) SetSpeed(pThisDev);

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    SetSpeed failed. Returned 0x%.8x\n", status));

//        goto done;
    }

    serialLineControl.StopBits   = STOP_BIT_1;
    serialLineControl.Parity     = NO_PARITY ;
    serialLineControl.WordLength = 8;

    status = (NDIS_STATUS) SerialSetLineControl(
                                    pThisDev->pSerialDevObj,
                                    &serialLineControl
                                    );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    SerialSetLineControl failed. Returned 0x%.8x\n", status));

//        goto done;
    }

    //
    // Must set the timeout value of the serial port
    // for a read.
    //


    status = (NDIS_STATUS) SerialSetTimeouts(
                                        pThisDev->pSerialDevObj,
                                        &SerialTimeoutsInit
                                        );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    SerialSetTimeouts failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_FAILURE;

//        goto done;
    }

    //
    // Initialize receive loop.
    //

    status = InitializeReceive(pThisDev);

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    InitializeReceive failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_FAILURE;

//        goto done;
    }

    done:
        DEBUGMSG(DBG_STAT, ("-ResetIrDeviceThread\n"));

        return status;
}
/*****************************************************************************
*
*  Function:   PassiveLevelThread
*
*  Synopsis:   Thread running at IRQL PASSIVE_LEVEL.
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/22/1996   sholden   author
*
*  Notes:
*
*  Any PASSIVE_PRIMITIVE that can be called must be serialized.
*  i.e. when IrsirReset is called, NDIS will not make any other
*       requests of the miniport until NdisMResetComplete is called.
*
*****************************************************************************/

VOID
PassiveLevelThread(
            IN OUT PVOID Context
            )
{
    PIR_DEVICE  pThisDev;
    NTSTATUS    ntStatus;
    PLIST_ENTRY pListEntry;
    PKEVENT EventList[2];
    LARGE_INTEGER Timeout;
    ULONG       ulSerialOpenAttempts = 100;

    DEBUGMSG(DBG_FUNC, ("+PassiveLevelThread\n"));

    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    pThisDev = CONTEXT_TO_DEV(Context);

    Timeout.QuadPart = -10000 * 1000 * 3; // 3 second relative delay

    EventList[0] = &pThisDev->eventPassiveThread;
    EventList[1] = &pThisDev->eventKillThread;

    while (1) {
        //
        // The eventPassiveThread is an auto-clearing event, so
        // we don't need to reset the event.
        //

        ntStatus = KeWaitForMultipleObjects(2,
                                            EventList,
                                            WaitAny,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            (pThisDev->pSerialDevObj ? NULL : &Timeout),
                                            NULL);

        if (ntStatus==0 || ntStatus==STATUS_TIMEOUT) {
            //
            //  either the first event was signaled or a timeout occurred
            //
            if (!pThisDev->pSerialDevObj) {
                //
                //  we have not opened the serial driver yet, try again
                //
                ResetIrDevice(pThisDev);

                if ((pThisDev->pSerialDevObj == NULL) && (--ulSerialOpenAttempts == 0)) {
                    //
                    //  still could not open the device, tell ndis to remove it
                    //
                    NdisMRemoveMiniport(pThisDev->hNdisAdapter);
                }
            }
            while (pListEntry = MyInterlockedRemoveHeadList(&pThisDev->leWorkItems,
                                                            &pThisDev->slWorkItem))
            {
                PIR_WORK_ITEM pWorkItem = CONTAINING_RECORD(pListEntry,
                                                            IR_WORK_ITEM,
                                                            ListEntry);

                pWorkItem->Callback(pWorkItem);
            }

        } else {

            if (ntStatus==1) {
                //
                //  the second event was signaled, this means that the thread should exit
                //
                DEBUGMSG(DBG_STAT, ("    Thread: HALT\n"));

                // Free any pending requests

                while (pListEntry = MyInterlockedRemoveHeadList(&pThisDev->leWorkItems,
                                                                &pThisDev->slWorkItem))
                {
                    PIR_WORK_ITEM pWorkItem = CONTAINING_RECORD(pListEntry,
                                                                IR_WORK_ITEM,
                                                                ListEntry);

                    DEBUGMSG(DBG_WARN, ("IRSIR: Releasing work item %08x\n", pWorkItem->Callback));
                    FreeWorkItem(pWorkItem);
                }

                ASSERT(pThisDev->fPendingHalt == TRUE);

                //
                //  out of loop
                //
                break;
            }
        }

    }

    DEBUGMSG(DBG_FUNC, ("-PassiveLevelThread\n"));


    PsTerminateSystemThread(STATUS_SUCCESS);
}




VOID
StopWorkerThread(
    PIR_DEVICE  pThisDev
    )

{
    PVOID    ThreadObject;
    NTSTATUS Status;

    //
    //  get an object handle fomr the thread handle
    //
    Status=ObReferenceObjectByHandle(
        pThisDev->hPassiveThread,
        0,
        NULL,
        KernelMode,
        &ThreadObject,
        NULL
        );

    ASSERT(Status == STATUS_SUCCESS);

    //
    //  tell the thread to exit
    //
    KeSetEvent(
        &pThisDev->eventKillThread,
        0,
        FALSE
        );


    if (NT_SUCCESS(Status)) {

        KeWaitForSingleObject(
            ThreadObject,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        ObDereferenceObject(ThreadObject);
        ThreadObject=NULL;
    }

    //
    //  close the thread handle
    //
    ZwClose(pThisDev->hPassiveThread);
    pThisDev->hPassiveThread = NULL;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\parallax.c ===
/*****************************************************************************
*
*  Copyright (c) 1997-1999 Microsoft Corporation
*
*       @doc
*       @module   parallax.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     10/15/1997 (created)
*
*       Contents: Parallax PRA9500A dongle specific code for initialization,
*                 deinit, and setting the baud rate of the device.
*
*****************************************************************************/

#include "irsir.h"
#include "dongle.h"

#define PARALLAX_IRDA_SPEEDS	( \
                                    NDIS_IRDA_SPEED_2400	|	\
                                    NDIS_IRDA_SPEED_9600	|	\
                                    NDIS_IRDA_SPEED_19200	|	\
                                    NDIS_IRDA_SPEED_38400	|	\
                                    NDIS_IRDA_SPEED_57600	|	\
                                    NDIS_IRDA_SPEED_115200		\
                                )

NDIS_STATUS
PARALLAX_QueryCaps(
        OUT PDONGLE_CAPABILITIES pDongleCaps
        )
{
    DEBUGMSG(DBG_FUNC, ("+PARALLAX_Init\n"));

    ASSERT(pDongleCaps   != NULL);

    pDongleCaps->supportedSpeedsMask    = PARALLAX_IRDA_SPEEDS;
    pDongleCaps->turnAroundTime_usec    = 100;
    pDongleCaps->extraBOFsRequired      = 0;

    DEBUGMSG(DBG_FUNC, ("-PARALLAX_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   PARALLAX_Init
*
*  Synopsis:   Initialize the PARALLAX dongle.
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS
*              DONGLE_CAPABILITIES
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*****************************************************************************/

NDIS_STATUS
PARALLAX_Init(
        IN  PDEVICE_OBJECT       pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+PARALLAX_Init\n"));

    (void)SerialSetDTR(pSerialDevObj);
    (void)SerialSetRTS(pSerialDevObj);

    DEBUGMSG(DBG_FUNC, ("-PARALLAX_Init\n"));

    return NDIS_STATUS_SUCCESS;

}

/*****************************************************************************
*
*  Function:   PARALLAX_Deinit
*
*  Synopsis:   The PARALLAX dongle doesn't require any special deinit, but for
*              purposes of being symmetrical with other dongles...
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

VOID
PARALLAX_Deinit(
        IN PDEVICE_OBJECT pSerialDevObj
        )
{
    DEBUGMSG(DBG_FUNC, ("+PARALLAX_Deinit\n"));


    DEBUGMSG(DBG_FUNC, ("-PARALLAX_Deinit\n"));
    return;
}

/*****************************************************************************
*
*  Function:   PARALLAX_SetSpeed
*
*  Synopsis:   set the baud rate of the PARALLAX dongle
*
*  Arguments:
*
*  Returns:    NDIS_STATUS_SUCCESS if bitsPerSec = 9600 || 19200 || 115200
*              NDIS_STATUS_FAILURE otherwise
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/2/1996    sholden   author
*
*  Notes:
*              The caller of this function should set the baud rate of the
*              serial driver (UART) to 9600 first to ensure that dongle
*              receives the commands.
*
*
*****************************************************************************/

NDIS_STATUS
PARALLAX_SetSpeed(
        IN PDEVICE_OBJECT pSerialDevObj,
        IN UINT bitsPerSec,
        IN UINT currentSpeed
        )
{
    ULONG       NumToggles;
#if DBG
    LARGE_INTEGER StartTime, EndTime;
    ULONG       DbgNumToggles;
#endif

    DEBUGMSG(DBG_FUNC, ("+PARALLAX_SetSpeed\n"));


    if (bitsPerSec==currentSpeed)
    {
        return NDIS_STATUS_SUCCESS;
    }

    //
    // We will need to 'count down' from 115.2 Kbaud.
    //

    switch (bitsPerSec){
        case 2400:		NumToggles = 6;		break;
        case 4800:		NumToggles = 5;		break;
        case 9600:		NumToggles = 4;		break;
        case 19200:		NumToggles = 3;		break;
        case 38400:		NumToggles = 2;		break;
        case 57600:		NumToggles = 1;		break;
        case 115200:	NumToggles = 0;		break;
        default:
            /*
             *  Illegal speed
             */
            return NDIS_STATUS_FAILURE;
    }

    //
    // Set speed to 115200, enabling set-speed mode.
    //

    NdisMSleep(1000);
    (void)SerialClrRTS(pSerialDevObj);
    NdisMSleep(1000);
    (void)SerialSetRTS(pSerialDevObj);
    NdisMSleep(1000);

    while (NumToggles--)
    {
        (void)SerialClrDTR(pSerialDevObj);
        NdisMSleep(1000);
        (void)SerialSetDTR(pSerialDevObj);
        NdisMSleep(1000);
    }

    //
    // These NdisMSleep calls actually have a granularity of about 10ms under
    // NT, even though we're asking for 1ms.  Fortunately, in this case, it
    // works.
    //

    DEBUGMSG(DBG_FUNC, ("-PARALLAX_SetSpeed\n"));

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\parallax.h ===
/*****************************************************************************
*
*  Copyright (c) 1997-1999 Microsoft Corporation
*
*       @doc
*       @module   PARALLAX.h | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Stan Adermann (stana)
*
*       Date:     10/15/1997 (created)
*
*       Contents: PARALLAX PRA9500A dongle specific prototypes.
*
*****************************************************************************/


#ifndef PARALLAX_H
#define PARALLAX_H

#include "dongle.h"

NDIS_STATUS PARALLAX_QueryCaps(
                PDONGLE_CAPABILITIES pDongleCaps
                );

NDIS_STATUS PARALLAX_Init(
                PDEVICE_OBJECT       pSerialDevObj
                );

void PARALLAX_Deinit(
                PDEVICE_OBJECT       pSerialDevObj
                );

NDIS_STATUS PARALLAX_SetSpeed(
                PDEVICE_OBJECT       pSerialDevObj,
                UINT                 bitsPerSec,
                UINT                 currentSpeed
                );

#endif // PARALLAX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\irsir.h ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*     @doc
*     @module   irsir.h | IrSIR NDIS Miniport Driver
*     @comm
*
*-----------------------------------------------------------------------------
*
*     Author:   Scott Holden (sholden)
*
*     Date:     10/1/1996 (created)
*
*     Contents:
*
*****************************************************************************/

#ifndef _IRSIR_H
#define _IRSIR_H

#define IRSIR_EVENT_DRIVEN 0
//
// BINARY_COMPATIBLE = 0 is required so that we can include both
// ntos.h and ndis.h (it is a flag in ndis.h). I think that it
// is a flag to be binary compatible with Win95; however, since
// we are using I/O manager we won't be.
//

#define BINARY_COMPATIBLE 0

#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <ntddndis.h>  // defines OID's
#include <ntddser.h>   // defines structs to access serial info

#include "debug.h"
#include "ioctl.h"
#include "settings.h"
#include "queue.h"

//
// NDIS version compatibility.
//

#define NDIS_MAJOR_VERSION 5
#define NDIS_MINOR_VERSION 0

//
// Wrapper to NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO.
//

PNDIS_IRDA_PACKET_INFO static __inline GetPacketInfo(PNDIS_PACKET packet)
{
    MEDIA_SPECIFIC_INFORMATION *mediaInfo;
    UINT size;
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(packet, &mediaInfo, &size);
    return (PNDIS_IRDA_PACKET_INFO)mediaInfo->ClassInformation;
}

//
// Structure to keep track of receive packets and buffers to indicate
// receive data to the protocol.
//

typedef struct
{
    LIST_ENTRY        linkage;
    PNDIS_PACKET      packet;
    UINT              dataLen;
    PUCHAR            dataBuf;
} RCV_BUFFER, *PRCV_BUFFER;

//
// States for receive finite state machine.
//

typedef enum _RCV_PROCESS_STATE
{
    RCV_STATE_READY = 0,
    RCV_STATE_BOF,
    RCV_STATE_EOF,
    RCV_STATE_IN_ESC,
    RCV_STATE_RX
} RCV_PROCESS_STATE;

//
// Structure to keep track of current state and information
// of the receive state machine.
//

typedef struct _RCV_INFORMATION
{
    RCV_PROCESS_STATE rcvState;
    UINT              rcvBufPos;
    PRCV_BUFFER       pRcvBuffer;
}RCV_INFORMATION, *PRCV_INFORMATION;

//
// Serial receive buffer size???
//

#define SERIAL_RECEIVE_BUFFER_LENGTH  2048

//
// Serial timeouts to use.
//
// Keep the write timeouts same as the default.
//
// When the interval = MAXULONG, the timeouts behave as follows:
// 1) If both constant and multiplier are 0, then the serial device
//    object returns immediately with whatever it has...even if
//    it is nothing.
// 2) If constant and multiplier are not MAXULONG, then the serial device
//    object returns immediately if any characters are present. If nothing
//    is there then the device object uses the timeouts as specified.
// 3) If multiplier is MAXULONG, then the serial device object returns
//    immediately if any characters are present. If nothing is there, the
//    device object will return the first character that arrives or wait
//    for the specified timeout and return nothing.
//

#define SERIAL_READ_INTERVAL_TIMEOUT            MAXULONG
#define SERIAL_READ_TOTAL_TIMEOUT_MULTIPLIER    0
#define SERIAL_READ_TOTAL_TIMEOUT_CONSTANT      10
#define SERIAL_WRITE_TOTAL_TIMEOUT_MULTIPLIER   0
#define SERIAL_WRITE_TOTAL_TIMEOUT_CONSTANT     0

extern SERIAL_TIMEOUTS SerialTimeoutsInit;
extern SERIAL_TIMEOUTS SerialTimeoutsIdle;
extern SERIAL_TIMEOUTS SerialTimeoutsActive;

//
// Maximum size of the name of the serial device object.
//

#define MAX_SERIAL_NAME_SIZE 100


//
// Enumeration of primitives for the PASSIVE_LEVEL thread.
//

typedef enum _PASSIVE_PRIMITIVE
{
    PASSIVE_SET_SPEED = 1,
    PASSIVE_RESET_DEVICE,
    PASSIVE_QUERY_MEDIA_BUSY,
    PASSIVE_CLEAR_MEDIA_BUSY,
    PASSIVE_HALT
}PASSIVE_PRIMITIVE;

typedef struct _IR_DEVICE
{
    //
    // Allows the ir device object to be put on a queue.
    //

    LIST_ENTRY linkage;

    //
    // Keep track of the serial port name and device.
    //

    UNICODE_STRING  serialDosName;
    UNICODE_STRING  serialDevName;
    PDEVICE_OBJECT  pSerialDevObj;
    HANDLE          serialHandle;
    PFILE_OBJECT    pSerialFileObj;

    //
    // This is the handle that the NDIS wrapper associates with a connection.
    // (The handle that the miniport driver associates with the connection
    // is just an index into the devStates array).
    //

    NDIS_HANDLE hNdisAdapter;

    //
    // The dongle interface allows us to check the tranceiver type once
    // and then set up the interface to allow us to init, set speed,
    // and deinit the dongle.
    //
    // We also want the dongle capabilities.
    //

    IR_TRANSCEIVER_TYPE transceiverType;
    DONGLE_INTERFACE    dongle;
    DONGLE_CAPABILITIES dongleCaps;

    ULONG               AllowedSpeedsMask;


    //
    // NDIS calls most of the MiniportXxx function with IRQL DISPATCH_LEVEL.
    // There are a number of instances where the ir device must send
    // requests to the serial device which may not be synchronous and
    // we can't block in DISPATCH_LEVEL. Therefore, we set up a thread to deal
    // with request which require PASSIVE_LEVEL. An event is used to signal
    // the thread that work is required.
    //

    LIST_ENTRY        leWorkItems;
    NDIS_SPIN_LOCK    slWorkItem;
    HANDLE            hPassiveThread;
    KEVENT            eventPassiveThread;
    KEVENT            eventKillThread;

    //
    // Current speed setting, in bits/sec.
    // Note: This is updated when we ACTUALLY change the speed,
    //       not when we get the request to change speed via
    //       IrsirSetInformation.
    //

    UINT currentSpeed;

    //
    // Current link speed information. This also will maintain the
    // chosen speed if the protocol requests a speed change.
    //

    baudRateInfo *linkSpeedInfo;

    //
    // Maintain statistical debug info.
    //

    UINT packetsReceived;
    UINT packetsReceivedDropped;
    UINT packetsReceivedOverflow;
    UINT packetsSent;
    UINT packetsSentDropped;
    ULONG packetsHeldByProtocol;

    //
    // Indicates that we have received an OID_GEN_CURRENT_PACKET_FILTER
    // indication from the protocol. We can deliver received packets to the
    // protocol.
    //

    BOOLEAN fGotFilterIndication;

    //
    // The variable fMediaBusy is set TRUE any time that this miniport
    // driver receives a data frame. It can be reset by the protocol via
    // IrsirSetInformation and later checked via IrsirQueryInformation
    // to detect interleaving activity.
    //
    // In order to check for framing errors, when the protocol calls
    // IrsirSetInformation(OID_IRDA_MEDIA_BUSY), the miniport
    // sends an irp to the serial device object to clear the performance
    // statistics. When the protocol calls
    // IrsirQueryInformation(OID_IRDA_MEDIA_BUSY), if the miniport
    // hasn't sensed the media busy, the miniport will query the
    // serial device object for the performance statistics to check
    // for media busy.
    //
    // A spin lock is used to interleave access to fMediaBusy variable.
    //

    BOOLEAN         fMediaBusy;
    NDIS_SPIN_LOCK  mediaBusySpinLock;

    //
    // The variable fReceiving is used to indicate that the ir device
    // object in pending a receive from the serial device object. Note,
    // that this does NOT necessarily mean that any data is being
    // received from the serial device object, since we are constantly
    // polling the serial device object for data.
    //
    // Under normal circumstances fReceiving should always be TRUE.
    // However, when IrsirHalt or IrsirReset are called, the receive
    // has to be shut down and this variable is used to synchronize
    // the halt and reset handler.
    //

    BOOLEAN fReceiving;


    //
    // The variable fRequireMinTurnAround indicates whether a time
    // delay is required between the last byte of the last byte
    // of the last frame sent by ANOTHER station, and the point
    // at which it (the other station) is ready to receive the
    // first byte from THIS station.
    //
    // This variable is initially set to TRUE. Whenever this variable
    // is true and a send occurs, the a delay will be implemented by
    // a stall execution before the irp is sent to the serial
    // device object.
    //
    // After a transmission occurs with the min turnaround delay, this
    // variable is set to FALSE. Everytime data is received, the
    // variable is set to TRUE.
    //

    BOOLEAN fRequireMinTurnAround;

    //
    // The variable fPendingSetSpeed allows the receive completion routine
    // to check if the a set speed is required.
    //

    BOOLEAN fPendingSetSpeed;

    //
    // The variableis fPendingHalt/fPendingReset allows the send and receive
    // completion routines to complete the current pending irp and
    // then cleanup and stop sending irps to the serial driver.
    //

    BOOLEAN fPendingHalt;
    BOOLEAN fPendingReset;

    //
    // We keep an array of receive buffers so that we don't continually
    // need to allocate buffers to indicate packets to the protocol.
    // Since the protocol can retain ownership of up to eight packets
    // and we can be receiving some data while the protocol has
    // ownership of eight packets, we will allocate nine packets for
    // receiving.
    //

    #define NUM_RCV_BUFS 14

    RCV_BUFFER rcvBufs[NUM_RCV_BUFS];

    //
    // Handles to the NDIS packet pool and NDIS buffer pool
    // for allocating the receive buffers.
    //

    NDIS_HANDLE hPacketPool;
    NDIS_HANDLE hBufferPool;

    //
    // When we indicate a packet to the protocol, the protocol may
    // retain ownership until at some point (asynchronously), it calls
    // IrsirReturnPacket.  No assumption is made about packet order.
    //
    // Therefore, we maintain a free queue and a pending queue of
    // receive buffers. Originally, all nine buffers are put on the
    // free queue. When data is being received, a receive buffer is
    // maintained in the RCV_INFORMATION described below. After we
    // indicate a full packet to the protocol and if the protocol
    // retains ownership of the packet, the receive buffer is queued
    // on the pending queue until IrsirReturnPacket is called.
    //
    // A spin lock is used to interleave access to both the free and
    // pending queues. There are three routines which use the
    // receive queues: InitializeReceive, SerialIoCompleteRead, and
    // IrsirReturnPacket.
    //

    LIST_ENTRY     rcvFreeQueue;
    NDIS_SPIN_LOCK rcvQueueSpinLock;

    //
    // The rcvInfo object, allows the device to keep track of the
    // current receive buffer, the state of the finite state machine,
    // and the write position in the buffer.
    //

    RCV_INFORMATION rcvInfo;

    //
    // The send spin lock is used for both inserting and removing from the
    // send queue as well as checking and modifying the variable fSending.
    //

    //
    // Since we only want to send one packet at a time to the serial driver,
    // we need to queue other packets until each preceding send packet
    // has been completed by the serial device object.
    //
    // Therefore, we maintain a queue of send packets (if required).
    // The MiniportReserved element of the NDIS_PACKET is used as the
    // 'next' pointer. We keep a pointer to both the head and the
    // tail of the list to speed access to the queue.
    //

    PACKET_QUEUE    SendPacketQueue;
    //
    // We will allocate irp buffers both send
    // and receive irps only once.
    //

    PUCHAR pSendIrpBuffer;

    PUCHAR pRcvIrpBuffer;

    // irp buffers and io status block for WaitOnMask

    ULONG MaskResult;
    IO_STATUS_BLOCK WaitIosb;

    // We use the following flag to indicate that a Wait has been issued
    // for the End of Frame character (0xc1).  It's a ULONG because we
    // access it using InterlockedExchange()

    ULONG fWaitPending;

    PVOID pQueryInfoBuffer;

    BOOLEAN SerialBased;

    PVOID PnpNotificationEntry;


    // We do some timeout modulation during activity
    ULONG NumReads;
    ULONG ReadRecurseLevel;

}IR_DEVICE, *PIR_DEVICE;


VOID
SendPacketToSerial(
    PVOID           Context,
    PNDIS_PACKET    Packet
    );


typedef	VOID	(*WORK_PROC)(struct _IR_WORK_ITEM *);

typedef struct _IR_WORK_ITEM
{
    PASSIVE_PRIMITIVE   Prim;
    PIR_DEVICE          pIrDevice;
    WORK_PROC           Callback;
    PVOID               InfoBuf;
    ULONG               InfoBufLen;
    LIST_ENTRY          ListEntry;
} IR_WORK_ITEM, *PIR_WORK_ITEM;


//
// We use a pointer to the IR_DEVICE structure as the miniport's device context.
//

#define CONTEXT_TO_DEV(__deviceContext) ((PIR_DEVICE)(__deviceContext))
#define DEV_TO_CONTEXT(__irdev) ((NDIS_HANDLE)(__irdev))

#define IRSIR_TAG ' RIS'
#define DEVICE_PREFIX L"\\DEVICE\\"

#include "externs.h"

#endif // _IRSIR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\queue.c ===
#include "irsir.h"

#pragma alloc_text(PAGE,InitializePacketQueue)



VOID
InitializePacketQueue(
    PPACKET_QUEUE    PacketQueue,
    PVOID            Context,
    PACKET_STARTER   StarterRoutine
    )

{

    NdisZeroMemory(PacketQueue,sizeof(*PacketQueue));

    NdisAllocateSpinLock(&PacketQueue->Lock);

    PacketQueue->Context=Context;

    PacketQueue->Starter=StarterRoutine;

    PacketQueue->Active=TRUE;

    KeInitializeEvent(&PacketQueue->InactiveEvent,NotificationEvent,FALSE);

    return;

}

VOID
QueuePacket(
    PPACKET_QUEUE    PacketQueue,
    PNDIS_PACKET     Packet
    )

{

    NDIS_STATUS      Status;
    PPACKET_RESERVED_BLOCK   Reserved=(PPACKET_RESERVED_BLOCK)&Packet->MiniportReservedEx[0];

    NdisAcquireSpinLock(&PacketQueue->Lock);

    if ((PacketQueue->CurrentPacket == NULL) && PacketQueue->Active && (PacketQueue->HeadOfList == NULL)) {
        //
        //  not currently handling a packet and the queu is active and there are not other packets
        //  queued, so handle it now
        //

        PacketQueue->CurrentPacket=Packet;

        NdisReleaseSpinLock(&PacketQueue->Lock);

        (*PacketQueue->Starter)(
            PacketQueue->Context,
            Packet
            );

        return;

    }

    //
    //  need to queue the packet
    //
    Reserved->Next=NULL;

    if (PacketQueue->HeadOfList == NULL) {
        //
        //  the list is empty
        //
        PacketQueue->HeadOfList=Packet;

    } else {

        Reserved=(PPACKET_RESERVED_BLOCK)&PacketQueue->TailOfList->MiniportReservedEx[0];

        Reserved->Next=Packet;
    }

    PacketQueue->TailOfList=Packet;

    NdisReleaseSpinLock(&PacketQueue->Lock);

    return;

}


VOID
StartNextPacket(
    PPACKET_QUEUE    PacketQueue
    )

{

    NdisAcquireSpinLock(&PacketQueue->Lock);

    ASSERT(PacketQueue->CurrentPacket != NULL);

    //
    //  done with this one
    //
    PacketQueue->CurrentPacket=NULL;

    if (!PacketQueue->InStartNext) {
        //
        //  not already in this function
        //
        PacketQueue->InStartNext=TRUE;

        while ((PacketQueue->CurrentPacket == NULL) && PacketQueue->Active && (PacketQueue->HeadOfList != NULL)) {
            //
            //  there is a packet queued
            //
            PNDIS_PACKET             Packet;
            PPACKET_RESERVED_BLOCK   Reserved;

            //
            //  get the first packet on the list
            //
            Packet=PacketQueue->HeadOfList;

            //
            //  Get a pointer to miniport reserved area
            //
            Reserved=(PPACKET_RESERVED_BLOCK)&Packet->MiniportReservedEx[0];

            //
            //  move to the next one in the list
            //
            PacketQueue->HeadOfList=Reserved->Next;

#if DBG
            Reserved->Next=NULL;

            if (PacketQueue->HeadOfList == NULL) {

                PacketQueue->TailOfList=NULL;
            }
#endif
            //
            //  now the current one
            //
            PacketQueue->CurrentPacket=Packet;

            NdisReleaseSpinLock(&PacketQueue->Lock);

            //
            //  start the processing
            //
            (*PacketQueue->Starter)(
                PacketQueue->Context,
                Packet
                );

            NdisAcquireSpinLock(&PacketQueue->Lock);

        }

        if (!PacketQueue->Active && (PacketQueue->CurrentPacket == NULL)) {
            //
            //  the queue has been paused and we don't have a current packet, signal the event
            //
            KeSetEvent(
                &PacketQueue->InactiveEvent,
                IO_NO_INCREMENT,
                FALSE
                );
        }

        PacketQueue->InStartNext=FALSE;
    }

    NdisReleaseSpinLock(&PacketQueue->Lock);

    return;

}

VOID
PausePacketProcessing(
    PPACKET_QUEUE    PacketQueue,
    BOOLEAN          WaitForInactive
    )

{

    BOOLEAN   CurrentlyActive=FALSE;

    NdisAcquireSpinLock(&PacketQueue->Lock);

    PacketQueue->Active=FALSE;

    if (PacketQueue->CurrentPacket != NULL) {
        //
        //  there is a packet currently being processed
        //
        CurrentlyActive=TRUE;

        KeClearEvent(&PacketQueue->InactiveEvent);

    }

    NdisReleaseSpinLock(&PacketQueue->Lock);

    if (WaitForInactive  && CurrentlyActive) {
        //
        //  the caller wants use to wait for the queue to inactive, and it was active when
        //  theis was called
        //
        KeWaitForSingleObject(
            &PacketQueue->InactiveEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }

    return;

}

VOID
ActivatePacketProcessing(
    PPACKET_QUEUE    PacketQueue
    )

{

    NdisAcquireSpinLock(&PacketQueue->Lock);

    PacketQueue->Active=TRUE;

    if ((PacketQueue->CurrentPacket == NULL) && (PacketQueue->HeadOfList != NULL)) {
        //
        //  there is a packet queued
        //
        PNDIS_PACKET    Packet;
        PPACKET_RESERVED_BLOCK   Reserved;

        Packet=PacketQueue->HeadOfList;

        //
        //  get a pointer to the reserved area
        //
        Reserved=(PPACKET_RESERVED_BLOCK)&Packet->MiniportReservedEx[0];

        PacketQueue->HeadOfList=Reserved->Next;

        //
        //  now the current one
        //
        PacketQueue->CurrentPacket=Packet;

        NdisReleaseSpinLock(&PacketQueue->Lock);

        //
        //  start the processing
        //
        (*PacketQueue->Starter)(
            PacketQueue->Context,
            Packet
            );

        NdisAcquireSpinLock(&PacketQueue->Lock);

    }


    NdisReleaseSpinLock(&PacketQueue->Lock);

    return;

}



VOID
FlushQueuedPackets(
    PPACKET_QUEUE    PacketQueue,
    NDIS_HANDLE      WrapperHandle
    )

{
    //
    //  dispose of all of the queue packets, don't touch the current one though
    //
    NdisAcquireSpinLock(&PacketQueue->Lock);

    while (PacketQueue->HeadOfList != NULL) {
        //
        //  there is a packet queued
        //
        PNDIS_PACKET    Packet;
        PPACKET_RESERVED_BLOCK   Reserved;

        Packet=PacketQueue->HeadOfList;

        Reserved=(PPACKET_RESERVED_BLOCK)&Packet->MiniportReservedEx[0];

        PacketQueue->HeadOfList=Reserved->Next;


        NdisReleaseSpinLock(&PacketQueue->Lock);

        //
        //  start the processing
        //
        NdisMSendComplete(
            WrapperHandle,
            Packet,
            NDIS_STATUS_REQUEST_ABORTED
            );

        NdisAcquireSpinLock(&PacketQueue->Lock);

    }

    NdisReleaseSpinLock(&PacketQueue->Lock);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\openclos.c ===
/*****************************************************************************
`*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   openclos.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/3/1996 (created)
*
*       Contents: open and close functions for the device
*
*****************************************************************************/

#include "irsir.h"

#include <ntddmodm.h>

NTSTATUS
GetComPortNtDeviceName(
    IN     PUNICODE_STRING SerialDosName,
    IN OUT PUNICODE_STRING NtDevName
    );

PIRP
BuildSynchronousCreateCloseRequest(
    IN  PDEVICE_OBJECT   pSerialDevObj,
    IN  ULONG            MajorFunction,
    IN  PKEVENT          pEvent,
    OUT PIO_STATUS_BLOCK pIosb
    );

NTSTATUS
CheckForModemPort(
    PFILE_OBJECT      FileObject
    );



#pragma alloc_text(PAGE, SerialClose)
#pragma alloc_text(PAGE, GetComPortNtDeviceName)
#pragma alloc_text(PAGE, GetDeviceConfiguration)
#pragma alloc_text(PAGE, BuildSynchronousCreateCloseRequest)

#if 0
NTSTATUS PortNotificationCallback(PVOID NotificationStructure, PVOID Context)
{
    DEVICE_INTERFACE_CHANGE_NOTIFICATION *Notification = NotificationStructure;
    PIR_DEVICE pThisDev = Context;
    NDIS_STATUS Status;
    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+PortNotificationCallback\n"));

    DEBUGMSG(DBG_PNP, ("New port:%wZ\n", Notification->SymbolicLinkName));

    Status = GetComPortNtDeviceName(&pThisDev->serialDosName,
                                    &pThisDev->serialDevName);

    if (Status==NDIS_STATUS_SUCCESS)
    {
        // We found our port.  Initialize.

        Status = ResetIrDevice(pThisDev);

        if (Status!=NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERROR, ("IRSIR:ResetIrDevice failed in PortNotificationCallback (0x%x)\n", Status));
        }
        else
        {
            DEBUGMSG(DBG_PNP, ("IRSIR:Successfully opened port after delay.\n"));
            Status = IoUnregisterPlugPlayNotification(pThisDev->PnpNotificationEntry);
            ASSERT(Status==NDIS_STATUS_SUCCESS);
        }
    }
    else
    {
        // We didn't find it.  Wait for the next notification.
    }

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-PortNotificationCallback\n"));
    return STATUS_SUCCESS;
}
#endif

/*****************************************************************************
*
*  Function:   InitializeDevice
*
*  Synopsis:   allocate resources for a single ir device object
*
*  Arguments:  pThisDev - ir device object to open
*
*  Returns:    NDIS_STATUS_SUCCESS      - if device is successfully opened
*              NDIS_STATUS_RESOURCES    - could not claim sufficient
*                                         resources
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:
*              we do alot of stuff in this open device function
*              - allocate packet pool
*              - allocate buffer pool
*              - allocate packets/buffers/memory and chain together
*                (only one buffer per packet)
*              - initialize send queue
*
*  This function should be called with device lock held.
*
*  We don't initialize the following ir device object entries, since
*  these values will outlast an IrsirReset.
*       serialDevName
*       pSerialDevObj
*       hNdisAdapter
*       transceiverType
*       dongle
*       dongleCaps
*       fGotFilterIndication
*
*****************************************************************************/

NDIS_STATUS
InitializeDevice(
            IN OUT PIR_DEVICE pThisDev)
{
    int         i;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+InitializeDevice\n"));

    ASSERT(pThisDev != NULL);

    pThisDev->pSerialDevObj = NULL;

    //
    // Will set speed to 9600 baud initially.
    //

    pThisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];

    //
    // Current speed is unknown, SetSpeed will update this.
    //

    pThisDev->currentSpeed  = 0;

    //
    // Init statistical info.
    //

    pThisDev->packetsReceived         = 0;
    pThisDev->packetsReceivedDropped  = 0;
    pThisDev->packetsReceivedOverflow = 0;
    pThisDev->packetsSent             = 0;
    pThisDev->packetsSentDropped      = 0;

    InitializePacketQueue(
        &pThisDev->SendPacketQueue,
        pThisDev,
        SendPacketToSerial
        );



    //
    // Set fMediaBusy to TRUE initially.  That way, we won't
    // IndicateStatus to the protocol in the receive poll loop
    // unless the protocol has expressed interest by clearing this flag
    // via IrsirSetInformation(OID_IRDA_MEDIA_BUSY).
    //

    pThisDev->fMediaBusy            = TRUE;

    pThisDev->fReceiving            = FALSE;

    pThisDev->fRequireMinTurnAround = TRUE;

    pThisDev->fPendingSetSpeed      = FALSE;

    pThisDev->fPendingHalt          = FALSE;

    pThisDev->fPendingReset         = FALSE;

    //
    // Initialize spin locks
    //

    NdisAllocateSpinLock(&(pThisDev->mediaBusySpinLock));
    NdisAllocateSpinLock(&(pThisDev->slWorkItem));

    //
    // Initialize the queues.
    //

    NdisInitializeListHead(&(pThisDev->rcvFreeQueue));

    NdisInitializeListHead(&(pThisDev->leWorkItems));

    //
    // Initialize the spin lock for the two above queues.
    //

    NdisAllocateSpinLock(&(pThisDev->rcvQueueSpinLock));

    //
    // Initialize the receive information buffer.
    //

    pThisDev->rcvInfo.rcvState   = RCV_STATE_READY;
    pThisDev->rcvInfo.rcvBufPos  = 0;
    pThisDev->rcvInfo.pRcvBuffer = NULL;

    //
    // Allocate the NDIS packet and NDIS buffer pools
    // for this device's RECEIVE buffer queue.
    // Our receive packets must only contain one buffer apiece,
    // so #buffers == #packets.
    //

    NdisAllocatePacketPool(
                &status,                    // return status
                &pThisDev->hPacketPool,     // handle to the packet pool
                NUM_RCV_BUFS,               // number of packet descriptors
                16                          // number of bytes reserved for
                );                          //   ProtocolReserved field

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    NdisAllocatePacketPool failed. Returned 0x%.8x\n",
                status));

        goto done;
    }

    NdisAllocateBufferPool(
                &status,               // return status
                &pThisDev->hBufferPool,// handle to the buffer pool
                NUM_RCV_BUFS           // number of buffer descriptors
                );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_OUT, ("    NdisAllocateBufferPool failed. Returned 0x%.8x\n",
                status));

        goto done;
    }

    //
    //  Initialize each of the RECEIVE objects for this device.
    //

    for (i = 0; i < NUM_RCV_BUFS; i++)
    {
        PNDIS_BUFFER pBuffer = NULL;
        PRCV_BUFFER  pRcvBuf = &pThisDev->rcvBufs[i];

        //
        // Allocate a data buffer
        //
        // This buffer gets swapped with the one on comPortInfo
        // and must be the same size.
        //

        pRcvBuf->dataBuf = MyMemAlloc(RCV_BUFFER_SIZE);

        if (pRcvBuf->dataBuf == NULL)
        {
            status = NDIS_STATUS_RESOURCES;

            goto done;
        }

        NdisZeroMemory(
                    pRcvBuf->dataBuf,
                    RCV_BUFFER_SIZE
                    );

        pRcvBuf->dataLen = 0;

        //
        //  Allocate the NDIS_PACKET.
        //

        NdisAllocatePacket(
                    &status,              // return status
                    &pRcvBuf->packet,     // return pointer to allocated descriptor
                    pThisDev->hPacketPool // handle to packet pool
                    );

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_OUT, ("    NdisAllocatePacket failed. Returned 0x%.8x\n",
                    status));

            goto done;
        }

        //
        // Allocate the NDIS_BUFFER.
        //

        NdisAllocateBuffer(
                    &status,               // return status
                    &pBuffer,              // return pointer to allocated descriptor
                    pThisDev->hBufferPool, // handle to buffer pool
                    pRcvBuf->dataBuf,      // virtual address mapped to descriptor
                    RCV_BUFFER_SIZE        // number of bytes mapped
                    );

        if (status != NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_OUT, ("    NdisAllocateBuffer failed. Returned 0x%.8x\n",
                    status));

            goto done;
        }

        //
        // Need to chain the buffer to the packet.
        //

        NdisChainBufferAtFront(
                    pRcvBuf->packet, // packet descriptor
                    pBuffer          // buffer descriptor to add to chain
                    );

        //
        // For future convenience, set the MiniportReserved portion of the packet
        // to the index of the rcv buffer that contains it.
        // This will be used in IrsirReturnPacket.
        //

        {
            PPACKET_RESERVED_BLOCK   PacketReserved;

            PacketReserved=(PPACKET_RESERVED_BLOCK)&pRcvBuf->packet->MiniportReservedEx[0];

            PacketReserved->Context=pRcvBuf;
        }


        //
        // Add the receive buffer to the free queue.
        //

        MyInterlockedInsertTailList(
                    &(pThisDev->rcvFreeQueue),
                    &pRcvBuf->linkage,
                    &(pThisDev->rcvQueueSpinLock)
                    );
    }

    pThisDev->pRcvIrpBuffer = ExAllocatePoolWithTag(
                                    NonPagedPoolCacheAligned,
                                    SERIAL_RECEIVE_BUFFER_LENGTH,
                                    IRSIR_TAG
                                    );

    if (pThisDev->pRcvIrpBuffer == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    ExAllocatePool failed.\n"));
        status = NDIS_STATUS_RESOURCES;

        goto done;
    }

    pThisDev->pSendIrpBuffer = ExAllocatePoolWithTag(
                                    NonPagedPoolCacheAligned,
                                    MAX_IRDA_DATA_SIZE,
                                    IRSIR_TAG
                                    );

    if (pThisDev->pSendIrpBuffer == NULL)
    {
        DEBUGMSG(DBG_OUT, ("    ExAllocatePool failed.\n"));
        status = NDIS_STATUS_RESOURCES;

        goto done;
    }

done:

    //
    // If we didn't complete the init successfully, then we should clean
    // up what we did allocate.
    //

    if (status != NDIS_STATUS_SUCCESS)
    {
        DeinitializeDevice(pThisDev);
    }

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-InitializeDevice()\n"));

    return status;
}




/*****************************************************************************
*
*  Function:   DeinitializeDevice
*
*  Synopsis:   deallocate the resources of the ir device object
*
*  Arguments:  pThisDev - the ir device object to close
*
*  Returns:    none
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:
*
*  Called for shutdown and reset.
*  Don't clear hNdisAdapter, since we might just be resetting.
*  This function should be called with device lock held.
*
*****************************************************************************/

NDIS_STATUS
DeinitializeDevice(
            IN OUT PIR_DEVICE pThisDev
            )
{
    UINT        i;
    NDIS_HANDLE hSwitchToMiniport;
    BOOLEAN     fSwitchSuccessful;
    NDIS_STATUS status;

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+DeinitializeDevice\n"));

    status = NDIS_STATUS_SUCCESS;

    ASSERT(pThisDev != NULL);

    pThisDev->linkSpeedInfo = NULL;

    NdisFreeSpinLock(&(pThisDev->rcvQueueSpinLock));
    NdisFreeSpinLock(&(pThisDev->sendSpinLock));

    //
    // Free all resources for the RECEIVE buffer queue.
    //

    for (i = 0; i < NUM_RCV_BUFS; i++)
    {
        PNDIS_BUFFER pBuffer = NULL;
        PRCV_BUFFER  pRcvBuf = &pThisDev->rcvBufs[i];

        //
        // Need to unchain the packet and buffer combo.
        //

        if (pRcvBuf->packet)
        {
            NdisUnchainBufferAtFront(
                        pRcvBuf->packet,
                        &pBuffer
                        );
        }

        //
        // free the buffer, packet and data
        //

        if (pBuffer != NULL)
        {
            NdisFreeBuffer(pBuffer);
        }

        if (pRcvBuf->packet != NULL)
        {
            NdisFreePacket(pRcvBuf->packet);
            pRcvBuf->packet = NULL;
        }

        if (pRcvBuf->dataBuf != NULL)
        {
            MyMemFree(pRcvBuf->dataBuf, RCV_BUFFER_SIZE);
            pRcvBuf->dataBuf = NULL;
        }

        pRcvBuf->dataLen = 0;
    }

    //
    // Free the packet and buffer pool handles for this device.
    //

    if (pThisDev->hPacketPool)
    {
        NdisFreePacketPool(pThisDev->hPacketPool);
        pThisDev->hPacketPool = NULL;
    }

    if (pThisDev->hBufferPool)
    {
        NdisFreeBufferPool(pThisDev->hBufferPool);
        pThisDev->hBufferPool = NULL;
    }

    //
    // Free all resources for the SEND buffer queue.
    //
    FlushQueuedPackets(&pThisDev->SendPacketQueue,pThisDev->hNdisAdapter);

    //
    // Deallocate the irp buffers.
    //

    if (pThisDev->pRcvIrpBuffer != NULL)
    {
        ExFreePool(pThisDev->pRcvIrpBuffer);
        pThisDev->pRcvIrpBuffer = NULL;
    }
    if (pThisDev->pSendIrpBuffer != NULL)
    {
        ExFreePool(pThisDev->pSendIrpBuffer);
        pThisDev->pSendIrpBuffer = NULL;
    }

    pThisDev->fMediaBusy              = FALSE;

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-DeinitializeDevice\n"));

    return status;
}

NTSTATUS GetComPortNtDeviceName(IN     PUNICODE_STRING SerialDosName,
                                IN OUT PUNICODE_STRING NtDevName)
/*++

Routine Description:

    Retrieves the NT device name (\device\serial0) for a given COM port.

Arguments:

    SerialDosName - identifies the port, i.e. COM1
    NtDevName - Allocates a buffer (if necessary) and returns the associated
                nt device name.

Return Value:

    STATUS_SUCCESS or error code.

--*/
{
    UNICODE_STRING                  registryPath;
    OBJECT_ATTRIBUTES               objectAttributes;
    HANDLE                          hKey = 0;
    PKEY_VALUE_PARTIAL_INFORMATION  pKeyValuePartialInfo = 0;
    PKEY_VALUE_BASIC_INFORMATION    pKeyValueBasicInfo = 0;
    NTSTATUS                        status = STATUS_SUCCESS;
    int                             i;
    ULONG                           resultLength;
    UNICODE_STRING                  serialTmpString;

    DEBUGMSG(DBG_OUT, ("IRSIR: Retrieving NT device name for %wZ\n",
                       SerialDosName));

    RtlInitUnicodeString(
                &registryPath,
                L"\\Registry\\Machine\\Hardware\\DeviceMap\\SerialComm"
                );

    //
    // Initialize the serial device object name in the context of
    // our ir device object.
    //

    if (!NtDevName->Buffer)
    {
        NtDevName->Buffer   = MyMemAlloc(MAX_SERIAL_NAME_SIZE);
    }
    NtDevName->MaximumLength = MAX_SERIAL_NAME_SIZE;
    NtDevName->Length        = 0;

    InitializeObjectAttributes(
               &objectAttributes,
               &registryPath,
               OBJ_CASE_INSENSITIVE,
               NULL,
               NULL
               );

    hKey = NULL;

    status = ZwOpenKey(
                      &hKey,
                      KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS,
                      &objectAttributes
                      );

    if (status != STATUS_SUCCESS)
    {
        //DEBUGMSG(DBG_ERR, ("    ZwOpenKey failed = 0x%.8x\n", status));

        goto error10;
    }

    pKeyValuePartialInfo = MyMemAlloc(sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256);
    pKeyValueBasicInfo   = MyMemAlloc(sizeof(KEY_VALUE_BASIC_INFORMATION) + 256);

    if (pKeyValuePartialInfo && pKeyValueBasicInfo)
    {
        for (i = 0; ; i++)
        {
            NdisZeroMemory(
                        pKeyValuePartialInfo,
                        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256
                        );

            NdisZeroMemory(
                        pKeyValueBasicInfo,
                        sizeof(KEY_VALUE_BASIC_INFORMATION) + 256
                        );

            status = ZwEnumerateValueKey(
                            hKey,
                            i,
                            KeyValuePartialInformation,
                            pKeyValuePartialInfo,
                            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256,
                            &resultLength
                            );

            if (status != STATUS_SUCCESS)
            {
                if (status != STATUS_NO_MORE_ENTRIES)
                {
                    DEBUGMSG(DBG_ERR, ("    ZwEnumerateValueKey failed = 0x%.8x\n", status));
                }
                else
                {
                    DEBUGMSG(DBG_ERR, ("    Valid comm port not found.\n"));
                    status = NDIS_STATUS_ADAPTER_NOT_FOUND;
                }

                break;
            }

            pKeyValuePartialInfo->Data[pKeyValuePartialInfo->DataLength/sizeof(WCHAR)] =
                        UNICODE_NULL;

            RtlInitUnicodeString(
                        &serialTmpString,
                        (PCWSTR)pKeyValuePartialInfo->Data
                        );

            DEBUGMSG(DBG_OUT, ("    Value found = %wZ\n", &serialTmpString));

            if (RtlCompareUnicodeString(
                                &serialTmpString,
                                SerialDosName,
                                TRUE)                  // ignore case
                                == 0)

            {
                //
                // We have found the comm port. Now we need to get the
                // name like SerialX.
                //

                status = ZwEnumerateValueKey(
                            hKey,
                            i,
                            KeyValueBasicInformation,
                            pKeyValueBasicInfo,
                            sizeof(KEY_VALUE_BASIC_INFORMATION) + 256,
                            &resultLength
                            );

                if (status != STATUS_SUCCESS)
                {
                    if (status != STATUS_NO_MORE_ENTRIES)
                    {
                        DEBUGMSG(DBG_ERR, ("    ZwEnumerateValueKey failed = 0x%.8x\n", status));
                    }
                    else
                    {
                        DEBUGMSG(DBG_ERR, ("    COMx != Serial?.\n"));
                    }

                    break;
                }

                //
                // We have our key name.
                //

                if (pKeyValueBasicInfo->Name[0]!=L'\\')
                {
                    //
                    // The key name needs to start with \Device\,
                    // and apparently this one doesn't.  Add it.
                    //
                    RtlAppendUnicodeToString(NtDevName, L"\\Device\\");
                }

                //
                // Append the name.
                //

                status = RtlAppendUnicodeToString(
                               NtDevName,
                               pKeyValueBasicInfo->Name
                               );

                if (status != STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_ERR, ("    RtlAppendUnicodeToString failed = 0x%.8x\n", status));
                }

                break;
            } // if RtlCompareUnicodeString
        } // for
    }

    //
    // NOTE: This path is not necessarily STATUS_SUCCESS.
    //

    if (pKeyValueBasicInfo)
    {
        MyMemFree(
                pKeyValueBasicInfo,
                sizeof(KEY_VALUE_BASIC_INFORMATION) + 256
                );
    }
    if (pKeyValuePartialInfo)
    {
        MyMemFree(
                pKeyValuePartialInfo,
                sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256
                );
    }
    if (hKey)
    {
        ZwClose(hKey);
    }
error10:;
    return status;
}


/*****************************************************************************
*
*  Function:   GetDeviceConfiguration
*
*  Synopsis:   get the configuration from the  registry
*
*  Arguments:  pThisDev - pointer to the ir device object
*
*  Returns:    NDIS_STATUS_SUCCESS - if device retrieves configuration
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

NDIS_STATUS
GetDeviceConfiguration(
            IN OUT PIR_DEVICE  pThisDev,
            IN     NDIS_HANDLE WrapperConfigurationContext
            )
{
    NDIS_STATUS                     status, tmpStatus;
    NDIS_HANDLE                     hConfig;
    PNDIS_CONFIGURATION_PARAMETER   configParamPtr;
    UNICODE_STRING                  serialCommString;
    UNICODE_STRING                  serialTmpString;
    UNICODE_STRING                  NetCfgInstanceID;
    UNICODE_STRING                  registryPath;
    OBJECT_ATTRIBUTES               objectAttributes;
    HANDLE                          hKey;
    PKEY_VALUE_PARTIAL_INFORMATION  pKeyValuePartialInfo;
    PKEY_VALUE_BASIC_INFORMATION    pKeyValueBasicInfo;
    ULONG                           resultLength;
    int                             i;

    NDIS_STRING regKeyPortString          = NDIS_STRING_CONST("PORT");
    NDIS_STRING regKeyIRTransceiverString = NDIS_STRING_CONST("InfraredTransceiverType");
    NDIS_STRING regKeySerialBasedString   = NDIS_STRING_CONST("SerialBased");
    NDIS_STRING regKeyMaxConnectString    = NDIS_STRING_CONST("MaxConnectRate");
    NDIS_STRING regKeyNetCfgInstance      = NDIS_STRING_CONST("NetCfgInstanceID");
    NDIS_STRING ComPortStr = NDIS_STRING_CONST("COM1");

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+GetDeviceConfiguration\n"));

    //
    // Set the default value.
    //

    pThisDev->transceiverType = STANDARD_UART;

    //
    // Open up the registry with our WrapperConfigurationContext.
    //
    // HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\
    //             ?DriverName?[instance]\Parameters\
    //

    NdisOpenConfiguration(
                &status,                     // return status
                &hConfig,                    // configuration handle
                WrapperConfigurationContext  // handle input to IrsirInitialize
                );

    if (status != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERR, ("    NdisOpenConfiguration failed. Returned 0x%.8x\n",
                status));

        goto done;
    }

    //
    // Attempt to read the registry for transceiver string.
    //

    NdisReadConfiguration(
                &tmpStatus,                // return status
                &configParamPtr,           // return reg data
                hConfig,                   // handle to open reg configuration
                &regKeyIRTransceiverString,// keyword to look for in reg
                NdisParameterInteger       // we want a integer
                );

    if (tmpStatus == NDIS_STATUS_SUCCESS)
    {
        pThisDev->transceiverType =
                (IR_TRANSCEIVER_TYPE)configParamPtr->ParameterData.IntegerData;
        DEBUGMSG(DBG_OUT|DBG_PNP, ("TransceiverType:%d\n\n", pThisDev->transceiverType));
    }
    else
    {
        DEBUGMSG(DBG_ERR, ("    NdisReadConfiguration(TransceiverStr) failed. Returned 0x%.8x\n",
                status));
        DEBUGMSG(DBG_OUT|DBG_PNP, ("Using default TransceiverType:%d\n\n", pThisDev->transceiverType));
    }

    //
    // Attempt to read the registry for transceiver string.
    //

    NdisReadConfiguration(
                &tmpStatus,                // return status
                &configParamPtr,           // return reg data
                hConfig,                   // handle to open reg configuration
                &regKeyMaxConnectString,   // keyword to look for in reg
                NdisParameterInteger       // we want a integer
                );

    if (tmpStatus == NDIS_STATUS_SUCCESS)
    {
        pThisDev->AllowedSpeedsMask = 0;
        switch (configParamPtr->ParameterData.IntegerData)
        {
            default:
            case 115200:
                pThisDev->AllowedSpeedsMask |= NDIS_IRDA_SPEED_115200;
            case 57600:
                pThisDev->AllowedSpeedsMask |= NDIS_IRDA_SPEED_57600;
            case 38400:
                pThisDev->AllowedSpeedsMask |= NDIS_IRDA_SPEED_38400;
            case 19200:
                pThisDev->AllowedSpeedsMask |= NDIS_IRDA_SPEED_19200;
            case 2400:    // Always allow 9600
                pThisDev->AllowedSpeedsMask |= NDIS_IRDA_SPEED_2400;
            case 9600:
                pThisDev->AllowedSpeedsMask |= NDIS_IRDA_SPEED_9600;
                break;
        }
    }
    else
    {
        pThisDev->AllowedSpeedsMask = ALL_SLOW_IRDA_SPEEDS;
    }

    //
    // Attempt to read the registry to determine if we've been PNPed
    //

    NdisReadConfiguration(
                &tmpStatus,                // return status
                &configParamPtr,           // return reg data
                hConfig,                   // handle to open reg configuration
                &regKeySerialBasedString,  // keyword to look for in reg
                NdisParameterInteger       // we want a integer
                );

    if (tmpStatus == NDIS_STATUS_SUCCESS)
    {
        pThisDev->SerialBased =
                (BOOLEAN)configParamPtr->ParameterData.IntegerData;
    }
    else
    {
        pThisDev->SerialBased = TRUE;
    }
    DEBUGMSG(DBG_OUT|DBG_PNP, ("IRSIR: Adapter is%s serial-based.\n", (pThisDev->SerialBased ? "" : " NOT")));

    if (pThisDev->SerialBased)
    {
        if (!pThisDev->serialDosName.Buffer)
        {
            pThisDev->serialDosName.Buffer        = MyMemAlloc(MAX_SERIAL_NAME_SIZE);
        }
        pThisDev->serialDosName.MaximumLength = MAX_SERIAL_NAME_SIZE;
        pThisDev->serialDosName.Length        = 0;
        //
        // Attempt to read the registry for PORT...we want something
        // like COM1
        //

        NdisReadConfiguration(
                    &tmpStatus,         // return status
                    &configParamPtr,    // return reg data
                    hConfig,            // handle to open reg configuration
                    &regKeyPortString,  // keyword to look for in reg
                    NdisParameterString // we want a string
                    );

        if (tmpStatus == NDIS_STATUS_SUCCESS)
        {
            RtlInitUnicodeString(
                        &serialCommString,
                        configParamPtr->ParameterData.StringData.Buffer
                        );

        }
        else
        {
            RtlInitUnicodeString(
                        &serialCommString,
                        ComPortStr.Buffer
                        );
            DEBUGMSG(DBG_OUT|DBG_PNP, ("Using default port\n"));
        }

        RtlAppendUnicodeStringToString(
                       &pThisDev->serialDosName,
                       &configParamPtr->ParameterData.StringData
                       );

        DEBUGMSG(DBG_OUT, ("   Port = %wZ\n", &serialCommString));

#if 0
        status = GetComPortNtDeviceName(&pThisDev->serialDosName,
                                        &pThisDev->serialDevName);
        if (status!=STATUS_SUCCESS)
        {
#if 0
            // This would have been a nice mechanism to use, but it notifies us
            // before the SERIALCOMM entries are made.  It looks like this has
            // the potential to change, so we'll leave this code in and disabled
            // and revisit it later. - StanA
            NTSTATUS TmpStatus;
            //
            // The port isn't there yet, and we want to know when it is.
            // Register for PNP notifications.
            //
            TmpStatus = IoRegisterPlugPlayNotification(EventCategoryDeviceInterfaceChange,
                                                       PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                                                       (GUID*)&GUID_DEVCLASS_PORTS,
                                                       DriverObject,
                                                       PortNotificationCallback,
                                                       pThisDev,
                                                       &pThisDev->PnpNotificationEntry);
#endif
        }
#endif
    }
    else // ! SerialBased
    {
        NDIS_STRING IoBaseAddress = NDIS_STRING_CONST("IoBaseAddress");
        NDIS_STRING Interrupt = NDIS_STRING_CONST("InterruptNumber");

        NdisReadConfiguration(&tmpStatus,
                              &configParamPtr,
                              hConfig,
                              &IoBaseAddress,
                              NdisParameterHexInteger);
        DEBUGMSG(DBG_OUT|DBG_PNP, ("IRSIR: IoBaseAddress:%x\n", configParamPtr->ParameterData.IntegerData));

        NdisReadConfiguration(&tmpStatus,
                              &configParamPtr,
                              hConfig,
                              &Interrupt,
                              NdisParameterHexInteger);
        DEBUGMSG(DBG_OUT|DBG_PNP, ("IRSIR: Interrupt:%x\n", configParamPtr->ParameterData.IntegerData));

    }

    status = SetIrFunctions(pThisDev);
    if (status!=STATUS_SUCCESS)
    {
        goto error10;
    }

    status = pThisDev->dongle.QueryCaps(&pThisDev->dongleCaps);
    if (status!=STATUS_SUCCESS)
    {
        goto error10;
    }



    NdisCloseConfiguration(hConfig);

    goto done;

error10:
    NdisCloseConfiguration(hConfig);

done:
    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-GetDeviceConfiguration\n"));

    return status;
}

NTSTATUS
SyncOpenCloseCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context)
{
    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

/*****************************************************************************
*
*  Function:   BuildSynchronousCreateRequest
*
*  Synopsis:
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:
*              this is pretty much stolen from IoBuildDeviceIoControlRequest
*
*
*****************************************************************************/

PIRP
BuildSynchronousCreateCloseRequest(
    IN  PDEVICE_OBJECT   pSerialDevObj,
    IN  ULONG            MajorFunction,
    IN  PKEVENT          pEvent,
    OUT PIO_STATUS_BLOCK pIosb
    )
{
    PIRP               pIrp;
    PIO_STACK_LOCATION irpSp;

    //
    // Begin by allocating the IRP for this request.
    //

    pIrp = IoAllocateIrp(pSerialDevObj->StackSize, FALSE);

    if (pIrp == NULL)
    {
        return pIrp;
    }

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( pIrp );

    //
    // Set the major function code.
    //

    irpSp->MajorFunction = (UCHAR)MajorFunction;

    //
    // Set the appropriate irp fields.
    //

    if (MajorFunction == IRP_MJ_CREATE)
    {
        pIrp->Flags = IRP_CREATE_OPERATION;
    }
    else
    {
        pIrp->Flags = IRP_CLOSE_OPERATION;
    }

    pIrp->AssociatedIrp.SystemBuffer = NULL;
    pIrp->UserBuffer                 = NULL;

    //
    // Finally, set the address of the I/O status block and the address of
    // the kernel event object.  Note that I/O completion will not attempt
    // to dereference the event since there is no file object associated
    // with this operation.
    //

    pIrp->UserIosb  = pIosb;
    pIrp->UserEvent = pEvent;

    IoSetCompletionRoutine(pIrp,
                           SyncOpenCloseCompletion,
                           NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Simply return a pointer to the packet.
    //

    return pIrp;
}

/*****************************************************************************
*
*  Function:   SerialOpen
*
*  Synopsis:   open up the serial port
*
*  Arguments:  pThisDev - ir device object
*
*  Returns:    NDIS_STATUS_SUCCESS
*              NDIS_STATUS_OPEN_FAILED  - serial port can't be opened
*              NDIS_STATUS_NOT_ACCEPTED - serial.sys does not accept the
*                                         configuration
*              NDIS_STATUS_FAILURE
*              NDIS_STATUS_RESOURCES - irp not allocated
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/3/1996    sholden   author
*
*  Notes:
*
*  Converting from NTSTATUS to NDIS_STATUS is relatively pain free, since the
*  important codes remain the same.
*      NDIS_STATUS_PENDING   = STATUS_PENDING
*      NDIS_STATUS_SUCCESS   = STATUS_SUCCESS
*      NDIS_STATUS_FAILURE   = STATUS_UNSUCCESSFUL
*      NDIS_STATUS_RESOURCES = STATUS_INSUFFICIENT_RESOURCES
*
*  IoGetDeviceObjectPointer could return an error code which is
*  NOT mapped by an NDIS_STATUS code
*              STATUS_OBJECT_TYPE_MISMATCH
*              STATUS_INVALID_PARAMETER
*              STATUS_PRIVILEGE_NOT_HELD
*              STATUS_OBJECT_NAME_INVALID
*  These will be mapped to NDIS_STATUS_NOT_ACCEPTED.
*
*  If IoCallDriver fails, NDIS_STATUS_OPEN_FAILED will be returned.
*
*****************************************************************************/

NDIS_STATUS
SerialOpen(
            IN PIR_DEVICE pThisDev
            )
{
    PIRP                pIrp;
    NTSTATUS            status = NDIS_STATUS_SUCCESS;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;

    PAGED_CODE();

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+SerialOpen\n"));

    if (!pThisDev->SerialBased)
    {
        PDEVICE_OBJECT PhysicalDeviceObject;
        PDEVICE_OBJECT FunctionalDeviceObject;
        PDEVICE_OBJECT NextDeviceObject;
        PCM_RESOURCE_LIST AllocatedResources;
        PCM_RESOURCE_LIST AllocatedResourcesTranslated;


        NdisMGetDeviceProperty(pThisDev->hNdisAdapter,
                               &PhysicalDeviceObject,
                               &FunctionalDeviceObject,
                               &NextDeviceObject,
                               &AllocatedResources,
                               &AllocatedResourcesTranslated);

        pThisDev->pSerialDevObj = NextDeviceObject;

        DEBUGMSG(DBG_OUT|DBG_PNP, ("IRSIR: NdisMGetDeviceProperty returns:\n"));
        DBG_X(DBG_OUT|DBG_PNP, PhysicalDeviceObject);
        DBG_X(DBG_OUT|DBG_PNP, FunctionalDeviceObject);
        DBG_X(DBG_OUT|DBG_PNP, NextDeviceObject);
        DBG_X(DBG_OUT|DBG_PNP, AllocatedResources);
        DBG_X(DBG_OUT|DBG_PNP, AllocatedResourcesTranslated);

        //
        // Event to wait for completion of serial driver.
        //

        KeInitializeEvent(
                    &eventComplete,
                    NotificationEvent,
                    FALSE
                    );

        //
        // Build an irp to send to the serial driver with IRP_MJ_CREATE.
        //

        //
        // Irp is released by io manager.
        //

        pIrp = BuildSynchronousCreateCloseRequest(
                        pThisDev->pSerialDevObj,
                        IRP_MJ_CREATE,
                        &eventComplete,
                        &ioStatusBlock
                        );

        DEBUGMSG(DBG_OUT, ("    BuildSynchronousCreateCloseReqest\n"));

        if (pIrp == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DEBUGMSG(DBG_OUT, ("    IoAllocateIrp() failed.\n"));

            goto error10;
        }

        status = IoCallDriver(pThisDev->pSerialDevObj, pIrp);

        //
        // If IoCallDriver returns STATUS_PENDING, we need to wait for the event.
        //

        if (status == STATUS_PENDING)
        {
            DEBUGMSG(DBG_OUT, ("    IoCallDriver(MJ_CREATE) PENDING.\n"));

            KeWaitForSingleObject(
                        &eventComplete,     // object to wait for
                        Executive,          // reason to wait
                        KernelMode,         // processor mode
                        FALSE,              // alertable
                        NULL                // timeout
                        );

            //
            // We can get the status of the IoCallDriver from the io status
            // block.
            //

            status = ioStatusBlock.Status;
        }

        //
        // If IoCallDriver returns something other that STATUS_PENDING, then it
        // is the same as what the serial driver set in ioStatusBlock.Status.
        //

        if (status != STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_OUT, ("    IoCallDriver(MJ_CREATE) failed. Returned = 0x%.8x\n", status));
            status = (NTSTATUS)NDIS_STATUS_OPEN_FAILED;

            goto error10;
        }
    }
    else
    {
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK IoStatusBlock;
        UNICODE_STRING DosFileName;
        WCHAR DosFileNameBuffer[32];

        DosFileName.Length = 0;
        DosFileName.MaximumLength = sizeof(DosFileNameBuffer);
        DosFileName.Buffer = DosFileNameBuffer;

        RtlAppendUnicodeToString(&DosFileName, L"\\DosDevices\\");
        RtlAppendUnicodeStringToString(&DosFileName, &pThisDev->serialDosName);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &DosFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        NdisZeroMemory(&IoStatusBlock, sizeof(IO_STATUS_BLOCK));

        // We use NtOpenFile in the non-pnp case because it is much easier
        // than trying to map COM1 to \device\serial0.  It requires some
        // extra work, because we really need to extract the device object.

        status = ZwOpenFile(&pThisDev->serialHandle,
                            FILE_ALL_ACCESS,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            0,
                            0);

        if (!NT_SUCCESS(status))
        {
            DEBUGMSG(DBG_ERR, ("    NtOpenFile() failed. Returned = 0x%.8x\n", status));
            status = (NTSTATUS)NDIS_STATUS_NOT_ACCEPTED;
            goto error10;
        }


        //
        // Get the device object handle to the serial device object.
        //
        status = ObReferenceObjectByHandle(pThisDev->serialHandle,
                                           FILE_ALL_ACCESS,
                                           NULL,
                                           KernelMode,
                                           &pThisDev->pSerialFileObj,
                                           NULL);

        if (status != STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERR, ("    ObReferenceObjectByHandle() failed. Returned = 0x%.8x\n", status));
            status = (NTSTATUS)NDIS_STATUS_NOT_ACCEPTED;

            goto error10;
        }

        //
        //  see if we are connected to a com port exposed by a modem.
        //  if so fail
        //
        status=CheckForModemPort(pThisDev->pSerialFileObj);

        if (!NT_SUCCESS(status)) {

            DEBUGMSG(DBG_ERR, ("    CheckForModemPort() failed. Returned = 0x%.8x\n", status));
            status = (NTSTATUS)NDIS_STATUS_NOT_ACCEPTED;

            goto error10;
        }


        pThisDev->pSerialDevObj = IoGetRelatedDeviceObject(pThisDev->pSerialFileObj);


        status = ObReferenceObjectByPointer(pThisDev->pSerialDevObj,
                                        FILE_ALL_ACCESS,
                                        NULL,
                                        KernelMode);

        if (status != STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_ERR, ("    ObReferenceObjectByPointer() failed. Returned = 0x%.8x\n", status));

            status = (NTSTATUS)NDIS_STATUS_NOT_ACCEPTED;

            goto error10;
        }
    }



    goto done;

error10:
    if (pThisDev->pSerialDevObj)
    {
        if (pThisDev->SerialBased)
        {
            ObDereferenceObject(pThisDev->pSerialDevObj);
        }
        pThisDev->pSerialDevObj = NULL;
    }
    if (pThisDev->pSerialFileObj)
    {
        ObDereferenceObject(pThisDev->pSerialFileObj);
        pThisDev->pSerialFileObj = NULL;
    }
    if (pThisDev->serialHandle)
    {
        NtClose(pThisDev->serialHandle);
        pThisDev->serialHandle = 0;
    }

done:
    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-SerialOpen\n"));
    return((NDIS_STATUS)status);
}

/*****************************************************************************
*
*  Function:   SerialClose
*
*  Synopsis:   close the serial port
*
*  Arguments:
*
*  Returns:
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/8/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

NDIS_STATUS
SerialClose(
            PIR_DEVICE pThisDev
            )
{
    PIRP                pIrp;
    KEVENT              eventComplete;
    IO_STATUS_BLOCK     ioStatusBlock;
    NDIS_STATUS         status;

    PAGED_CODE();

    if (!pThisDev->pSerialDevObj)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialDevObj==NULL\n"));
        return NDIS_STATUS_SUCCESS;
    }

    DEBUGMSG(DBG_FUNC, ("+SerialClose\n"));

    status = NDIS_STATUS_SUCCESS;

    if (!pThisDev->SerialBased)
    {
        //
        // Event to wait for completion of serial driver.
        //

        KeInitializeEvent(
                    &eventComplete,
                    NotificationEvent,
                    FALSE
                    );

        //
        // Send an irp to close the serial device object.
        //

        //
        // Irp is released by io manager.
        //

        pIrp = BuildSynchronousCreateCloseRequest(
                        pThisDev->pSerialDevObj,
                        IRP_MJ_CLOSE,
                        &eventComplete,
                        &ioStatusBlock
                        );

        if (pIrp == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DEBUGMSG(DBG_OUT, ("    IoAllocateIrp failed.\n"));

            goto done;
        }

        status = IoCallDriver(pThisDev->pSerialDevObj, pIrp);

        //
        // If IoCallDriver returns STATUS_PENDING, we need to wait for the event.
        //

        if (status == STATUS_PENDING)
        {
            DEBUGMSG(DBG_OUT, ("    IoCallDriver(MJ_CLOSE) PENDING.\n"));

            KeWaitForSingleObject(
                        &eventComplete,     // object to wait for
                        Executive,          // reason to wait
                        KernelMode,         // processor mode
                        FALSE,              // alertable
                        NULL                // timeout
                        );

            //
            // We can get the status of the IoCallDriver from the io status
            // block.
            //

            status = ioStatusBlock.Status;
        }

        //
        // If IoCallDriver returns something other that STATUS_PENDING, then it
        // is the same as what the serial driver set in ioStatusBlock.Status.
        //

        if (status != STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_OUT, ("    IoCallDriver(MJ_CLOSE) failed. Returned = 0x%.8x\n", status));
            status = (NTSTATUS)NDIS_STATUS_OPEN_FAILED;

            goto done;
        }
    }

done:

    if (pThisDev->SerialBased)
    {
        if (pThisDev->pSerialDevObj)
        {
            //
            // Derefence the serial device object.
            //
            ObDereferenceObject(pThisDev->pSerialDevObj);
            pThisDev->pSerialDevObj = NULL;
        }
        if (pThisDev->pSerialFileObj)
        {
            ObDereferenceObject(pThisDev->pSerialFileObj);
            pThisDev->pSerialFileObj = NULL;
        }
        if (pThisDev->serialHandle)
        {
            NtClose(pThisDev->serialHandle);
            pThisDev->serialHandle = 0;
        }

    }


    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-SerialClose\n"));

    return status;
}





NTSTATUS
CheckForModemPort(
    PFILE_OBJECT      FileObject
    )

{

    PIRP   TempIrp;
    KEVENT Event;
    IO_STATUS_BLOCK   IoStatus;
    NTSTATUS          status;
    PDEVICE_OBJECT    DeviceObject;

    DeviceObject=IoGetRelatedDeviceObject(FileObject);

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    //
    //  build an IRP to send to the attched to driver to see if modem
    //  is in the stack.
    //
    TempIrp=IoBuildDeviceIoControlRequest(
        IOCTL_MODEM_CHECK_FOR_MODEM,
        DeviceObject,
        NULL,
        0,
        NULL,
        0,
        FALSE,
        &Event,
        &IoStatus
        );

    if (TempIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        PIO_STACK_LOCATION NextSp = IoGetNextIrpStackLocation(TempIrp);
        NextSp->FileObject=FileObject;

        status = IoCallDriver(DeviceObject, TempIrp);

        if (status == STATUS_PENDING) {

             KeWaitForSingleObject(
                 &Event,
                 Executive,
                 KernelMode,
                 FALSE,
                 NULL
                 );

             status=IoStatus.Status;
        }

        TempIrp=NULL;

        if (status == STATUS_SUCCESS) {
            //
            //  if success, then modem.sys is layered under us, fail
            //
            status = STATUS_PORT_DISCONNECTED;

        } else {
            //
            //  it didn't succeed so modem must not be below us
            //
            status=STATUS_SUCCESS;
        }
    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\queue.h ===
typedef VOID (*PACKET_STARTER)(
    PVOID                       Context,
    PNDIS_PACKET                Packet
    );



typedef struct _PACKET_QUEUE {

    PNDIS_PACKET    HeadOfList;
    PNDIS_PACKET    TailOfList;

    PNDIS_PACKET    CurrentPacket;

    BOOLEAN         Active;

    BOOLEAN         InStartNext;

    NDIS_SPIN_LOCK  Lock;

    PVOID           Context;

    PACKET_STARTER  Starter;

    KEVENT          InactiveEvent;

} PACKET_QUEUE, *PPACKET_QUEUE;


typedef struct _PACKET_RESERVED_BLOCK {

    PNDIS_PACKET    Next;
    PVOID           Context;

}   PACKET_RESERVED_BLOCK, *PPACKET_RESERVED_BLOCK;




VOID
InitializePacketQueue(
    PPACKET_QUEUE    PacketQueue,
    PVOID            Context,
    PACKET_STARTER   StarterRoutine
    );

VOID
QueuePacket(
    PPACKET_QUEUE    PacketQueue,
    PNDIS_PACKET     Packet
    );

VOID
StartNextPacket(
    PPACKET_QUEUE    PacketQueue
    );

VOID
PausePacketProcessing(
    PPACKET_QUEUE    PacketQueue,
    BOOLEAN          WaitForInactive
    );

VOID
ActivatePacketProcessing(
    PPACKET_QUEUE    PacketQueue
    );

VOID
FlushQueuedPackets(
    PPACKET_QUEUE    PacketQueue,
    NDIS_HANDLE      WrapperHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\request.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   request.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/10/1996 (created)
*
*       Contents: Query and set information handlers.
*
*****************************************************************************/

#include "irsir.h"

VOID
ClearMediaBusyCallback(
    PIR_WORK_ITEM pWorkItem
    );

VOID
QueryMediaBusyCallback(
    PIR_WORK_ITEM pWorkItem
    );

VOID
InitIrDeviceCallback(
    PIR_WORK_ITEM pWorkItem
    );

#pragma alloc_text(PAGE, ClearMediaBusyCallback)
#pragma alloc_text(PAGE, QueryMediaBusyCallback)
#pragma alloc_text(PAGE, InitIrDeviceCallback)

//
//  These are the OIDs we support for querying.
//

UINT supportedOIDs[] =
{
    //
    // General required OIDs.
    //

    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,

    //
    // Required statistical OIDs.
    //

    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,


    //
    // Infrared-specific OIDs.
    //

    OID_IRDA_RECEIVING,
    OID_IRDA_TURNAROUND_TIME,
    OID_IRDA_SUPPORTED_SPEEDS,
    OID_IRDA_LINK_SPEED,
    OID_IRDA_MEDIA_BUSY,
    OID_IRDA_EXTRA_RCV_BOFS

    //
    // Unsupported Infrared-specific OIDs.
    //
    // OID_IRDA_RATE_SNIFF,
    // OID_IRDA_UNICAST_LIST,
    // OID_IRDA_MAX_UNICAST_LIST_SIZE
    //

#if 1
   ,OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ENABLE_WAKE_UP
#endif
};


VOID
ClearMediaBusyCallback(PIR_WORK_ITEM pWorkItem)
{
    PIR_DEVICE      pThisDev = pWorkItem->pIrDevice;
    NDIS_STATUS     status;
    BOOLEAN         fSwitchSuccessful;
    NDIS_HANDLE     hSwitchToMiniport;

    SERIALPERF_STATS PerfStats;

    //DBGTIME("CLEAR_MEDIA_BUSY");
    DEBUGMSG(DBG_STAT, ("    primPassive = PASSIVE_CLEAR_MEDIA_BUSY\n"));

    status = (NDIS_STATUS) SerialClearStats(pThisDev->pSerialDevObj);

    if (status != NDIS_STATUS_SUCCESS)
    {
            DEBUGMSG(DBG_ERROR, ("    SerialClearStats failed = 0x%.8x\n", status));
    }

    {
        NdisMSetInformationComplete(pThisDev->hNdisAdapter,
                                    (NDIS_STATUS)status);

    }

    FreeWorkItem(pWorkItem);

    return;
}

VOID
QueryMediaBusyCallback(PIR_WORK_ITEM pWorkItem)
{
    PIR_DEVICE      pThisDev = pWorkItem->pIrDevice;
    NDIS_STATUS     status;
    BOOLEAN         fSwitchSuccessful;
    NDIS_HANDLE     hSwitchToMiniport;

    SERIALPERF_STATS PerfStats;

    ASSERT(pWorkItem->InfoBuf != NULL);
    ASSERT(pWorkItem->InfoBufLen >= sizeof(UINT));

    if (pThisDev->pSerialDevObj)
    {
        status = (NDIS_STATUS) SerialGetStats(pThisDev->pSerialDevObj, &PerfStats);
    }
    else
    {
        PerfStats.ReceivedCount = 1;  // Fake media busy
        status = NDIS_STATUS_SUCCESS;
    }

    if (status == NDIS_STATUS_SUCCESS)
    {
        if (PerfStats.ReceivedCount > 0 ||
            PerfStats.FrameErrorCount > 0 ||
            PerfStats.SerialOverrunErrorCount > 0 ||
            PerfStats.BufferOverrunErrorCount > 0 ||
            PerfStats.ParityErrorCount > 0)
        {
            DBGTIME("QUERY_MEDIA_BUSY:TRUE");
            pThisDev->fMediaBusy = TRUE;
        }
        else
        {
            DBGTIME("QUERY_MEDIA_BUSY:FALSE");
        }
    }
    else
    {
        DEBUGMSG(DBG_ERROR, ("    SerialGetStats failed = 0x%.8x\n", status));
    }

    *(UINT *)pWorkItem->InfoBuf = (UINT)pThisDev->fMediaBusy;
    pWorkItem->InfoBufLen = sizeof(UINT);

    {
        NdisMQueryInformationComplete(pThisDev->hNdisAdapter,
                                (NDIS_STATUS)status);

    }


    FreeWorkItem(pWorkItem);

    return;
}

VOID
InitIrDeviceCallback(PIR_WORK_ITEM pWorkItem)
{
    PIR_DEVICE      pThisDev = pWorkItem->pIrDevice;
    NDIS_STATUS     status = NDIS_STATUS_SUCCESS;
    BOOLEAN         fSwitchSuccessful;
    NDIS_HANDLE     hSwitchToMiniport;

    DEBUGMSG(DBG_FUNC, ("+InitIrDeviceCallback\n"));

    (void)ResetIrDevice(pThisDev);

    {
        NdisMQueryInformationComplete(pThisDev->hNdisAdapter,
                                (NDIS_STATUS)status);

    }


    FreeWorkItem(pWorkItem);

    DEBUGMSG(DBG_FUNC, ("-InitIrDeviceCallback\n"));
    return;
}
/*****************************************************************************
*
*  Function:   IrsirQueryInformation
*
*  Synopsis:   Queries the capabilities and status of the miniport driver.
*
*  Arguments:  MiniportAdapterContext  - miniport context area (PIR_DEVICE)
*              Oid                     - system defined OID_Xxx
*              InformationBuffer       - where to return Oid specific info
*              InformationBufferLength - specifies size of InformationBuffer
*              BytesWritten            - bytes written to InformationBuffer
*              BytesNeeded             - addition bytes required if
*                                        InformationBufferLength is less than
*                                        what the Oid requires to write
*
*  Returns:    NDIS_STATUS_SUCCESS       - success
*              NDIS_STATUS_PENDING       - will complete asynchronously and
*                                          call NdisMQueryInformationComplete
*              NDIS_STATUS_INVALID_OID   - don't recognize the Oid
*              NDIS_STATUS_INVALID_LENGTH- InformationBufferLength does not
*                                          match length for the Oid
*              NDIS_STATUS_NOT_ACCEPTED  - failure
*              NDIS_STATUS_NOT_SUPPORTED - do not support an optional Oid
*              NDIS_STATUS_RESOURCES     - failed allocation of resources
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/1/1996    sholden   author
*
*  Notes:
*       Supported OIDs:
*           OID_GEN_MAXIMUM_LOOKAHEAD
*               - indicate the number of bytes of look ahead data the NIC can
*                 provide
*           OID_GEN_MAC_OPTIONS
*               - indicate which NDIS_MAC_OPTION_Xxx the NIC supports
*           OID_GEN_MAXIMUM_SEND_PACKETS
*           OID_IRDA_RECEIVING
*           OID_IRDA_SUPPORTED_SPEEDS
*           OID_IRDA_LINK_SPEED
*           OID_IRDA_MEDIA_BUSY
*           OID_IRDA_TURNAROUND_TIME
*           OID_IRDA_EXTRA_RCV_BOFS
*
*       Unsupported OIDs:
*           OID_IRDA_UNICAST_LIST
*           OID_IRDA_MAX_UNICAST_LIST_SIZE
*           OID_IRDA_RATE_SNIFF
*
*****************************************************************************/

NDIS_STATUS
IrsirQueryInformation(
            IN  NDIS_HANDLE MiniportAdapterContext,
            IN  NDIS_OID    Oid,
            IN  PVOID       InformationBuffer,
            IN  ULONG       InformationBufferLength,
            OUT PULONG      BytesWritten,
            OUT PULONG      BytesNeeded
            )
{
    PIR_DEVICE      pThisDev;
    NDIS_STATUS     status;
    UINT            speeds;
    UINT            i;
    UINT            infoSizeNeeded;
    UINT            *infoPtr;
    PIR_WORK_ITEM   pWorkItem = NULL;
    ULONG           OidCategory = Oid & 0xFF000000;

    static char vendorDesc[] = "Serial Infrared (COM) Port";

    DEBUGMSG(DBG_FUNC, ("+IrsirQueryInformation\n"));

    pThisDev = CONTEXT_TO_DEV(MiniportAdapterContext);
    status = NDIS_STATUS_SUCCESS;

    //
    // Figure out buffer size needed.
    // Most OIDs just return a single UINT, but there are exceptions.
    //

    switch (Oid)
    {
        case OID_GEN_SUPPORTED_LIST:
            infoSizeNeeded = sizeof(supportedOIDs);

            break;

        case OID_GEN_DRIVER_VERSION:
            infoSizeNeeded = sizeof(USHORT);

            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            infoSizeNeeded = sizeof(vendorDesc);

            break;

        case OID_IRDA_SUPPORTED_SPEEDS:
            speeds = pThisDev->dongleCaps.supportedSpeedsMask &
                     ALL_SLOW_IRDA_SPEEDS;

            for (infoSizeNeeded = 0; speeds; infoSizeNeeded += sizeof(UINT))
            {
                //
                // This instruction clears the lowest set bit in speeds.
                // Trust me.
                //

                speeds &= (speeds - 1);
            }

            break;

        default:
            infoSizeNeeded = sizeof(UINT);

            break;
    }

    //
    // If the protocol provided a large enough buffer, we can go ahead
    // and complete the query.
    //

    if (InformationBufferLength >= infoSizeNeeded)
    {
        //
        // Set default results.
        //

        *BytesWritten = infoSizeNeeded;
        *BytesNeeded = 0;

        switch (Oid)
        {
            //
            // Generic OIDs.
            //

            case OID_GEN_SUPPORTED_LIST:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_SUPPORTED_LIST)\n"));

                NdisMoveMemory(
                            InformationBuffer,
                            (PVOID)supportedOIDs,
                            sizeof(supportedOIDs)
                            );

                break;

            case OID_GEN_HARDWARE_STATUS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_HARDWARE_STATUS)\n"));

                //
                // If we can be called with a context, then we are
                // initialized and ready.
                //

                *(UINT *)InformationBuffer = NdisHardwareStatusReady;

                break;

            case OID_GEN_MEDIA_SUPPORTED:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MEDIA_SUPPORTED)\n"));

                *(UINT *)InformationBuffer = NdisMediumIrda;

                break;

            case OID_GEN_MEDIA_IN_USE:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MEDIA_IN_USE)\n"));

                *(UINT *)InformationBuffer = NdisMediumIrda;

                break;

            case OID_GEN_MAXIMUM_LOOKAHEAD:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MAXIMUM_LOOKAHEAD)\n"));

                *(UINT *)InformationBuffer = 256;

                break;

            case OID_GEN_MAXIMUM_FRAME_SIZE:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MAXIMUM_FRAME_SIZE)\n"));

                *(UINT *)InformationBuffer = MAX_NDIS_DATA_SIZE;

                break;

            case OID_GEN_LINK_SPEED:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_LINK_SPEED)\n"));

                //
                // Return MAXIMUM POSSIBLE speed for this device in units
                // of 100 bits/sec.
                //

                *(UINT *)InformationBuffer = 115200/100;

                break;

            case OID_GEN_TRANSMIT_BUFFER_SPACE:
            case OID_GEN_RECEIVE_BUFFER_SPACE:
            case OID_GEN_TRANSMIT_BLOCK_SIZE:
            case OID_GEN_RECEIVE_BLOCK_SIZE:
                *(UINT *)InformationBuffer = MAX_I_DATA_SIZE;

                break;

            case OID_GEN_VENDOR_ID:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_VENDOR_ID)\n"));

                *(UINT *)InformationBuffer = 0x00ffffff;

                break;

            case OID_GEN_VENDOR_DESCRIPTION:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_VENDOR_DESCRIPTION)\n"));

                NdisMoveMemory(
                            InformationBuffer,
                            (PVOID)vendorDesc,
                            sizeof(vendorDesc)
                            );

                break;

            case OID_GEN_CURRENT_PACKET_FILTER:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_CURRENT_PACKET_FILTER)\n"));

                *(UINT *)InformationBuffer = NDIS_PACKET_TYPE_PROMISCUOUS;

                break;

            case OID_GEN_CURRENT_LOOKAHEAD:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_CURRENT_LOOKAHEAD)\n"));

                *(UINT *)InformationBuffer = 256;

                break;

            case OID_GEN_DRIVER_VERSION:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_DRIVER_VERSION)\n"));

                *(USHORT *)InformationBuffer = ((IRSIR_MAJOR_VERSION << 8) |
                                                 IRSIR_MINOR_VERSION);

                break;

            case OID_GEN_MAXIMUM_TOTAL_SIZE:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MAXIMUM_TOTAL_SIZE)\n"));

                *(UINT *)InformationBuffer = MAX_NDIS_DATA_SIZE;

                break;

            case OID_GEN_PROTOCOL_OPTIONS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_PROTOCOL_OPTIONS)\n"));

                DEBUGMSG(DBG_ERROR, ("This is a set-only OID\n"));
                *BytesWritten = 0;
                status = NDIS_STATUS_NOT_SUPPORTED;

                break;

            case OID_GEN_MAC_OPTIONS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MAC_OPTIONS)\n"));

                *(UINT *)InformationBuffer =
                    NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
                    NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;

                break;

            case OID_GEN_MEDIA_CONNECT_STATUS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MEDIA_CONNECT_STATUS)\n"));

                //
                // Since we are not physically connected to a LAN, we
                // cannot determine whether or not we are connected;
                // so always indicate that we are.
                //

                *(UINT *)InformationBuffer = NdisMediaStateConnected;

                break;

            case OID_GEN_MAXIMUM_SEND_PACKETS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_MAXIMUM_SEND_PACKETS)\n"));

                *(UINT *)InformationBuffer = 16;

                break;

            case OID_GEN_VENDOR_DRIVER_VERSION:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_VENDOR_DRIVER_VERSION)\n"));

                *(UINT *)InformationBuffer =
                                            ((IRSIR_MAJOR_VERSION << 16) |
                                              IRSIR_MINOR_VERSION);

                break;

            //
            // Required statistical OIDs.
            //

            case OID_GEN_XMIT_OK:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_XMIT_OK)\n"));

                *(UINT *)InformationBuffer =
                                (UINT)pThisDev->packetsSent;

                break;

            case OID_GEN_RCV_OK:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_RCV_OK)\n"));

                *(UINT *)InformationBuffer =
                                (UINT)pThisDev->packetsReceived;

                break;

            case OID_GEN_XMIT_ERROR:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_XMIT_ERROR)\n"));

                *(UINT *)InformationBuffer =
                                (UINT)pThisDev->packetsSentDropped;

                break;

            case OID_GEN_RCV_ERROR:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_RCV_ERROR)\n"));

                *(UINT *)InformationBuffer =
                                (UINT)pThisDev->packetsReceivedDropped;

                break;

            case OID_GEN_RCV_NO_BUFFER:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_GEN_RCV_NO_BUFFER)\n"));

                *(UINT *)InformationBuffer =
                                (UINT)pThisDev->packetsReceivedOverflow;

                break;

            //
            // Infrared OIDs.
            //

            case OID_IRDA_RECEIVING:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_IRDA_RECEIVING)\n"));

                *(UINT *)InformationBuffer = (UINT)pThisDev->fReceiving;

                break;

            case OID_IRDA_TURNAROUND_TIME:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_IRDA_TURNAROUND_TIME)\n"));

                //
                // Indicate that the tranceiver requires at least 5000us
                // (5 millisec) to recuperate after a send.
                //

                *(UINT *)InformationBuffer =
                            pThisDev->dongleCaps.turnAroundTime_usec;

                break;

            case OID_IRDA_SUPPORTED_SPEEDS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_IRDA_SUPPORTED_SPEEDS)\n"));

                if (!pThisDev->pSerialDevObj)
                {
                    (void)pThisDev->dongle.QueryCaps(&pThisDev->dongleCaps);
                }

                speeds = pThisDev->dongleCaps.supportedSpeedsMask &
                         pThisDev->AllowedSpeedsMask &
                         ALL_SLOW_IRDA_SPEEDS;


                *BytesWritten = 0;

                for (i = 0, infoPtr = (PUINT)InformationBuffer;
                     (i < NUM_BAUDRATES) &&
                     speeds &&
                     (InformationBufferLength >= sizeof(UINT));
                     i++)
                {
                    if (supportedBaudRateTable[i].ndisCode & speeds)
                    {
                        *infoPtr++ = supportedBaudRateTable[i].bitsPerSec;
                        InformationBufferLength -= sizeof(UINT);
                        *BytesWritten += sizeof(UINT);
                        speeds &= ~supportedBaudRateTable[i].ndisCode;
                        DEBUGMSG(DBG_OUT, (" - supporting speed %d bps\n", supportedBaudRateTable[i].bitsPerSec));
                    }
                }

                if (speeds)
                {
                    //
                    // This shouldn't happen, since we checked the
                    // InformationBuffer size earlier.
                    //

                    DEBUGMSG(DBG_ERROR, ("Something's wrong; previous check for buf size failed somehow\n"));

                    for (*BytesNeeded = 0; speeds; *BytesNeeded += sizeof(UINT))
                    {
                        //
                        // This instruction clears the lowest set bit in speeds.
                        // Trust me.
                        //

                        speeds &= (speeds - 1);
                    }

                    status = NDIS_STATUS_INVALID_LENGTH;
                }
                else
                {
                    status = NDIS_STATUS_SUCCESS;
                }

                break;

            case OID_IRDA_LINK_SPEED:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_IRDA_LINK_SPEED)\n"));

                if (pThisDev->linkSpeedInfo)
                {
                    *(UINT *)InformationBuffer =
                                pThisDev->linkSpeedInfo->bitsPerSec;
                }
                else {
                    *(UINT *)InformationBuffer = DEFAULT_BAUD_RATE;
                }

                break;


            case OID_IRDA_MEDIA_BUSY:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_IRDA_MEDIA_BUSY)\n"));

                //
                // If any data has been received, fMediaBusy = TRUE. However,
                // even if fMediaBusy = FALSE, the media may be busy. We need
                // to query the serial device object's performance statistics
                // to see if there are any overrun or framing errors.
                //

                //
                // NOTE: The serial device object's performance stats are
                //       cleared when the protocol set fMediaBusy to
                //       FALSE.
                //

                *(UINT *)InformationBuffer = pThisDev->fMediaBusy;

                if (pThisDev->fMediaBusy == FALSE)
                {
                    if (ScheduleWorkItem(PASSIVE_QUERY_MEDIA_BUSY, pThisDev,
                                QueryMediaBusyCallback, InformationBuffer,
                                InformationBufferLength) != NDIS_STATUS_SUCCESS)
                    {
                        status = NDIS_STATUS_SUCCESS;
                    }
                    else
                    {
                        status = NDIS_STATUS_PENDING;
                    }
                }
                else
                {
                    *(UINT *)InformationBuffer = (UINT)pThisDev->fMediaBusy;
                    status = NDIS_STATUS_SUCCESS;
                }

                break;

            case OID_IRDA_EXTRA_RCV_BOFS:
                DEBUGMSG(DBG_OUT, ("    IrsirQueryInformation(OID_IRDA_EXTRA_RCV_BOFS)\n"));

                //
                // Pass back the number of _extra_ BOFs to be prepended
                // to packets sent to this unit at 115.2 baud, the
                // maximum Slow IR speed.  This will be scaled for other
                // speed according to the table in the
                // 'Infrared Extensions to NDIS' spec.
                //

                *(UINT *)InformationBuffer =
                                pThisDev->dongleCaps.extraBOFsRequired;

                break;

            case OID_IRDA_MAX_RECEIVE_WINDOW_SIZE:
                *(PUINT)InformationBuffer = MAX_RX_PACKETS;
                break;

            case OID_IRDA_MAX_SEND_WINDOW_SIZE:
                *(PUINT)InformationBuffer = MAX_TX_PACKETS;
                break;

            //
            // We don't support these
            //

            case OID_IRDA_RATE_SNIFF:
                DEBUGMSG(DBG_WARN, ("    IrsirQueryInformation(OID_IRDA_RATE_SNIFF) - UNSUPPORTED\n"));

                status = NDIS_STATUS_NOT_SUPPORTED;

                break;

            case OID_IRDA_UNICAST_LIST:
                DEBUGMSG(DBG_WARN, ("    IrsirQueryInformation(OID_IRDA_UNICAST_LIST) - UNSUPPORTED\n"));

                status = NDIS_STATUS_NOT_SUPPORTED;

                break;

            case OID_IRDA_MAX_UNICAST_LIST_SIZE:
                DEBUGMSG(DBG_WARN, ("    IrsirQueryInformation(OID_IRDA_MAX_UNICAST_LIST_SIZE) - UNSUPPORTED\n"));

                status = NDIS_STATUS_NOT_SUPPORTED;

                break;


            // PNP OIDs

            case OID_PNP_CAPABILITIES:
            case OID_PNP_ENABLE_WAKE_UP:
            case OID_PNP_SET_POWER:
            case OID_PNP_QUERY_POWER:
                DEBUGMSG(DBG_WARN, ("IRSIR: PNP OID %x BufLen:%d\n", Oid, InformationBufferLength));
                break;

            default:
                DEBUGMSG(DBG_WARN, ("    IrsirQueryInformation(%d=0x%x), invalid OID\n", Oid, Oid));

                status = NDIS_STATUS_INVALID_OID;

                break;
        }
    }
    else
    {
        *BytesNeeded = infoSizeNeeded - InformationBufferLength;
        *BytesWritten = 0;
        status = NDIS_STATUS_INVALID_LENGTH;
    }


    DEBUGMSG(DBG_FUNC, ("-IrsirQueryInformation\n"));

    return status;
}

/*****************************************************************************
*
*  Function:   IrsirSetInformation
*
*  Synopsis:   IrsirSetInformation allows other layers of the network software
*              (e.g., a transport driver) to control the miniport driver
*              by changing information that the miniport driver maintains
*              in its OIDs, such as the packet filters or multicast addresses.
*
*  Arguments:  MiniportAdapterContext  - miniport context area (PIR_DEVICE)
*              Oid                     - system defined OID_Xxx
*              InformationBuffer       - buffer containing data for the set Oid
*              InformationBufferLength - specifies size of InformationBuffer
*              BytesRead               - bytes read from InformationBuffer
*              BytesNeeded             - addition bytes required if
*                                        InformationBufferLength is less than
*                                        what the Oid requires to read
*
*  Returns:    NDIS_STATUS_SUCCESS       - success
*              NDIS_STATUS_PENDING       - will complete asynchronously and
*                                          call NdisMSetInformationComplete
*              NDIS_STATUS_INVALID_OID   - don't recognize the Oid
*              NDIS_STATUS_INVALID_LENGTH- InformationBufferLength does not
*                                          match length for the Oid
*              NDIS_STATUS_INVALID_DATA  - supplied data was invalid for the
*                                          given Oid
*              NDIS_STATUS_NOT_ACCEPTED  - failure
*              NDIS_STATUS_NOT_SUPPORTED - do not support an optional Oid
*              NDIS_STATUS_RESOURCES     - failed allocation of resources
*
*  Algorithm:
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/1/1996    sholden   author
*
*  Notes:
*
*
*****************************************************************************/

NDIS_STATUS
IrsirSetInformation(
            IN  NDIS_HANDLE MiniportAdapterContext,
            IN  NDIS_OID    Oid,
            IN  PVOID       InformationBuffer,
            IN  ULONG       InformationBufferLength,
            OUT PULONG      BytesRead,
            OUT PULONG      BytesNeeded
            )
{
    NDIS_STATUS status;
    PIR_DEVICE pThisDev;
    SERIALPERF_STATS PerfStats;

    int i;

    DEBUGMSG(DBG_FUNC, ("+IrsirSetInformation\n"));

    status   = NDIS_STATUS_SUCCESS;
    pThisDev = CONTEXT_TO_DEV(MiniportAdapterContext);

    if (InformationBufferLength >= sizeof(UINT))
    {
        //
        //  Set default results.
        //

        UINT info = *(UINT *)InformationBuffer;
        *BytesRead = sizeof(UINT);
        *BytesNeeded = 0;

        switch (Oid)
        {
            //
            //  Generic OIDs.
            //

            case OID_GEN_CURRENT_PACKET_FILTER:
                DEBUGMSG(DBG_OUT, ("    IrsirSetInformation(OID_GEN_CURRENT_PACKET_FILTER, %xh)\n", info));

                //
                // We ignore the packet filter itself.
                //
                // Note:  The protocol may use a NULL filter, in which case
                //        we will not get this OID; so don't wait on
                //        OID_GEN_CURRENT_PACKET_FILTER to start receiving
                //        frames.
                //

                pThisDev->fGotFilterIndication = TRUE;

                break;

            case OID_GEN_CURRENT_LOOKAHEAD:
                DEBUGMSG(DBG_OUT, ("    IrsirSetInformation(OID_GEN_CURRENT_LOOKAHEAD, %xh)\n", info));

                //
                // We always indicate entire receive frames all at once,
                // so just ignore this.
                //

                break;

            case OID_GEN_PROTOCOL_OPTIONS:
                DEBUGMSG(DBG_OUT, ("    IrsirSetInformation(OID_GEN_PROTOCOL_OPTIONS, %xh)\n", info));

                //
                // Ignore.
                //

                break;

            //
            // Infrared OIDs.
            //

            case OID_IRDA_LINK_SPEED:
                DEBUGMSG(DBG_OUT, ("    IrsirSetInformation(OID_IRDA_LINK_SPEED, %xh)\n", info));

                if (pThisDev->currentSpeed == info)
                {
                    //
                    // We are already set to the requested speed.
                    //
                    status = NDIS_STATUS_SUCCESS;

                    DEBUGMSG(DBG_OUT, ("    Link speed already set.\n"));

                    break;
                }

                status = NDIS_STATUS_INVALID_DATA;

                for (i = 0; i < NUM_BAUDRATES; i++)
                {
                    if (supportedBaudRateTable[i].bitsPerSec == info)
                    {
                        //
                        // Keep a pointer to the link speed which has
                        // been requested.
                        //

                        pThisDev->linkSpeedInfo = &supportedBaudRateTable[i];
                        status = NDIS_STATUS_SUCCESS;
                        break;
                    }
                }

                if (status == NDIS_STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_OUT, ("    Link speed set pending!\n"));
                    //
                    // The requested speed is supported.
                    //

                    if (pThisDev->pSerialDevObj==NULL)
                    {
                        pThisDev->currentSpeed = info;
                        status = NDIS_STATUS_SUCCESS;
                        break;
                    }


                    //
                    // Set fPendingSetSpeed = TRUE.
                    //
                    // The receive completion/timeout routine checks the
                    // fPendingSetSpeed flag, waits for all sends to complete
                    // and then performs the SetSpeed.
                    //

                    pThisDev->fPendingSetSpeed = TRUE;

#if IRSIR_EVENT_DRIVEN
                    if (ScheduleWorkItem(PASSIVE_SET_SPEED, pThisDev,
                                SetSpeedCallback, NULL, 0) != NDIS_STATUS_SUCCESS)
                    {
                        status = NDIS_STATUS_SUCCESS;
                    }
                    else
                    {
                        status = NDIS_STATUS_PENDING;
                    }
#else
                    //
                    // We always return STATUS_PENDING to NDIS.
                    //
                    // After the SetSpeed is complete, the receive completion
                    // routine will call NdisMIndicateSetComplete.
                    //


                    status = NDIS_STATUS_PENDING;
#endif
                }
                else
                {
                    //
                    // status = NDIS_STATUS_INVALID_DATA
                    //

                    DEBUGMSG(DBG_OUT, ("    Invalid link speed\n"));

                    *BytesRead = 0;
                    *BytesNeeded = 0;
                }

                break;

            case OID_IRDA_MEDIA_BUSY:
                DEBUGMSG(DBG_OUT, ("    IrsirSetInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", info));

                pThisDev->fMediaBusy = (BOOLEAN)info;

                if (pThisDev->pSerialDevObj==NULL ||
                    ScheduleWorkItem(PASSIVE_CLEAR_MEDIA_BUSY,
                                     pThisDev, ClearMediaBusyCallback, NULL, 0)!=NDIS_STATUS_SUCCESS)
                {
                    status = NDIS_STATUS_SUCCESS;
                }
                else
                {
                    status = NDIS_STATUS_PENDING;
                }


                break;

            case OID_PNP_CAPABILITIES:
            case OID_PNP_ENABLE_WAKE_UP:
            case OID_PNP_SET_POWER:
            case OID_PNP_QUERY_POWER:
                DEBUGMSG(DBG_WARN, ("IRSIR: PNP OID %x BufLen:%d\n", Oid, InformationBufferLength));
                break;

            case OID_IRDA_RATE_SNIFF:
            case OID_IRDA_UNICAST_LIST:

                //
                // We don't support these
                //

                DEBUGMSG(DBG_ERROR, ("    IrsirSetInformation(OID=%d=0x%x, value=%xh) - unsupported OID\n", Oid, Oid, info));

                *BytesRead = 0;
                *BytesNeeded = 0;
                status = NDIS_STATUS_NOT_SUPPORTED;

                break;

            case OID_IRDA_SUPPORTED_SPEEDS:
            case OID_IRDA_MAX_UNICAST_LIST_SIZE:
            case OID_IRDA_TURNAROUND_TIME:

                //
                // These are query-only parameters (invalid).
                //

            default:
                DEBUGMSG(DBG_ERROR, ("    IrsirSetInformation(OID=%d=0x%x, value=%xh) - invalid OID\n", Oid, Oid, info));

                *BytesRead = 0;
                *BytesNeeded = 0;
                status = NDIS_STATUS_INVALID_OID;

                break;
        }
    }
    else
    {
        //
        // The given data buffer is not large enough for the information
        // to set.
        //

        *BytesRead = 0;
        *BytesNeeded = sizeof(UINT);
        status = NDIS_STATUS_INVALID_LENGTH;
    }

    DEBUGMSG(DBG_FUNC, ("-IrsirSetInformation\n"));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irsir\receive.c ===
/*****************************************************************************
*
*  Copyright (c) 1996-1999 Microsoft Corporation
*
*       @doc
*       @module   receive.c | IrSIR NDIS Miniport Driver
*       @comm
*
*-----------------------------------------------------------------------------
*
*       Author:   Scott Holden (sholden)
*
*       Date:     10/4/1996 (created)
*
*       Contents:
*
*****************************************************************************/

#include "irsir.h"

VOID
SetSpeedCallback(
    PIR_WORK_ITEM pWorkItem
    );




#if LOGGING
ULONG LogIndex = 0;
LOG   Log[NUM_LOG];
#endif

#ifdef DEBUG_IRSIR

    static ULONG_PTR irpCount;
    static ULONG_PTR bytesReceived;

#endif //DEBUG_IRSIR

//
// Declarations.
//

NTSTATUS SerialIoCompleteRead(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PIRP           pIrp,
            IN PVOID          Context
            );
NTSTATUS
SerialIoCompleteWait(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PIRP           pIrp,
            IN PVOID          Context
            );

NTSTATUS ProcessData(
            IN PIR_DEVICE pThisDev,
            IN PUCHAR     rawBuffer,
            IN UINT       rawBytesRead
            );
VOID
DeliverBuffer(
    IN  PIR_DEVICE pThisDev
    );

VOID StartSerialReadCallback(PIR_WORK_ITEM pWorkItem);

#pragma alloc_text(PAGE,SetSpeedCallback)
#pragma alloc_text(PAGE,StartSerialReadCallback)

VOID DBG_PrintBuf(PUCHAR bufptr, UINT buflen)
{
	UINT i, linei;

	#define ISPRINT(ch) (((ch) >= ' ') && ((ch) <= '~'))
	#define PRINTCHAR(ch) (UCHAR)(ISPRINT(ch) ? (ch) : '.')

	DbgPrint("\r\n         %d bytes @%x:", buflen, bufptr);

	/*
	 *  Print whole lines of 8 characters with HEX and ASCII
	 */
	for (i = 0; i+8 <= buflen; i += 8) {
		UCHAR ch0 = bufptr[i+0],
			ch1 = bufptr[i+1], ch2 = bufptr[i+2],
			ch3 = bufptr[i+3], ch4 = bufptr[i+4],
			ch5 = bufptr[i+5], ch6 = bufptr[i+6],
			ch7 = bufptr[i+7];

		DbgPrint("\r\n         %02x %02x %02x %02x %02x %02x %02x %02x"
			"   %c %c %c %c %c %c %c %c",
			ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7,
			PRINTCHAR(ch0), PRINTCHAR(ch1),
			PRINTCHAR(ch2), PRINTCHAR(ch3),
			PRINTCHAR(ch4), PRINTCHAR(ch5),
			PRINTCHAR(ch6), PRINTCHAR(ch7));
	}

	/*
	 *  Print final incomplete line
	 */
	DbgPrint("\r\n        ");
	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++){
		DbgPrint(" %02x", (UINT)(bufptr[i]));
	}

	DbgPrint("  ");
	i -= linei;
	while (linei++ < 8) DbgPrint("   ");

	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++){
		UCHAR ch = bufptr[i];
		DbgPrint(" %c", PRINTCHAR(ch));
	}

	DbgPrint("\t\t<>\r\n");

}


NTSTATUS StartSerialRead(IN PIR_DEVICE pThisDev)
/*++

Routine Description:

    Allocates an irp and calls the serial driver.

Arguments:

    pThisDev - Current IR device.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES or result of IoCallDriver

--*/
{
    NTSTATUS    Status;
    PIRP        pIrp;

    LOG_ENTRY('SR', pThisDev, 0, 0);

#if DBG
    NdisZeroMemory(
                pThisDev->pRcvIrpBuffer,
                SERIAL_RECEIVE_BUFFER_LENGTH
                );
#endif

    //
    // Now that we have processed the irp, we will send another read
    // request to the serial device object.
    //

    pIrp = SerialBuildReadWriteIrp(
                        pThisDev->pSerialDevObj,
                        IRP_MJ_READ,
                        pThisDev->pRcvIrpBuffer,
                        SERIAL_RECEIVE_BUFFER_LENGTH,
                        NULL
                        );

    if (pIrp == NULL)
    {
        DEBUGMSG(DBG_ERR, ("    SerialBuildReadWriteIrp failed.\n"));

        Status = STATUS_INSUFFICIENT_RESOURCES;

        pThisDev->fReceiving = FALSE;

        goto done;
    }

    //
    // Set up the io completion routine for the irp.
    //

    IoSetCompletionRoutine(
                pIrp,                      // irp to use
                SerialIoCompleteRead,      // routine to call when irp is done
                DEV_TO_CONTEXT(pThisDev),  // context to pass routine
                TRUE,                      // call on success
                TRUE,                      // call on error
                TRUE);                     // call on cancel

    //
    // Call IoCallDriver to send the irp to the serial port.
    //

    LOG_ENTRY('2I', pThisDev, pIrp, 0);
    IoCallDriver(
                pThisDev->pSerialDevObj,
                pIrp
                );

    Status=STATUS_PENDING;

done:

    return Status;
}

VOID
StartSerialReadCallback(PIR_WORK_ITEM pWorkItem)
/*++

Routine Description:



Arguments:

Return Value:
    none

--*/
{
    PIR_DEVICE      pThisDev = pWorkItem->pIrDevice;

    FreeWorkItem(pWorkItem);

    (void)StartSerialRead(pThisDev);

    return;
}


/*****************************************************************************
*
*  Function:   InitializeReceive
*
*  Synopsis:   Initialize the receive functionality.
*
*  Arguments:  pThisDevice - pointer to current ir device object
*
*  Returns:    NDIS_STATUS_SUCCESS   - if irp is successfully sent to serial
*                                      device object
*              NDIS_STATUS_RESOURCES - if mem can't be alloc'd
*              NDIS_STATUS_FAILURE   - otherwise
*
*  Algorithm:
*              1) Set the receive timeout to READ_INTERVAL_TIMEOUT_MSEC.
*              2) Initialize our rcvInfo and associate info for our
*                 receive state machine.
*              3) Build an IRP_MJ_READ irp to send to the serial device
*                 object, and set the completion(or timeout) routine
*                 to SerialIoCompleteRead.
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/4/1996    sholden   author
*
*  Notes:
*
*  This routine must be called in IRQL PASSIVE_LEVEL.
*
*****************************************************************************/

NDIS_STATUS
InitializeReceive(
            IN PIR_DEVICE pThisDev
            )
{
    PIRP               pIrp;
    PIO_STACK_LOCATION irpSp;
    NDIS_STATUS        status;
#if IRSIR_EVENT_DRIVEN
    NTSTATUS            NtStatus;
    SERIAL_CHARS        SerialChars;
#endif

    DEBUGMSG(DBG_FUNC, ("+InitializeReceive\n"));

#ifdef DEBUG_IRSIR

    irpCount      = 0;
    bytesReceived = 0;

#endif //DEBUG_IRSIR

    //
    // Set up the receive information for our read completion routine.
    //

    pThisDev->rcvInfo.rcvState   = RCV_STATE_READY;
    pThisDev->rcvInfo.rcvBufPos  = 0;

    if (pThisDev->rcvInfo.pRcvBuffer == NULL)
    {
        pThisDev->rcvInfo.pRcvBuffer =
                (PRCV_BUFFER)MyInterlockedRemoveHeadList(
                                        &(pThisDev->rcvFreeQueue),
                                        &(pThisDev->rcvQueueSpinLock)
                                        );

        ASSERT(pThisDev->rcvInfo.pRcvBuffer != NULL);
    }

#if IRSIR_EVENT_DRIVEN

    NtStatus = (NDIS_STATUS) SerialSetTimeouts(pThisDev->pSerialDevObj,
                                               &SerialTimeoutsActive);

    NtStatus = SerialGetChars(pThisDev->pSerialDevObj, &SerialChars);

    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialGetChars failed (0x%x:%d)\n", NtStatus));
    }
    else
    {
        SerialChars.EventChar = SLOW_IR_EOF;

        NtStatus = SerialSetChars(pThisDev->pSerialDevObj, &SerialChars);
    }

    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialSetChars failed (0x%x:%d)\n", NtStatus));
    }
    else
    {
        ULONG WaitMask = SERIAL_EV_RXFLAG | SERIAL_EV_RX80FULL;

        NtStatus = SerialSetWaitMask(pThisDev->pSerialDevObj, &WaitMask);
    }

    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialSetWaitMask failed (0x%x:%d)\n", NtStatus));
    }
    else
    {
        if (InterlockedExchange(&pThisDev->fWaitPending, 1)==0)
        {
            NtStatus = SerialCallbackOnMask(pThisDev->pSerialDevObj,
                                            SerialIoCompleteWait,
                                            &pThisDev->WaitIosb,
                                            DEV_TO_CONTEXT(pThisDev),
                                            &pThisDev->MaskResult);

            if (NtStatus==STATUS_PENDING)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("IRSIR: SerialCallbackOnMask failed (0x%x:%d)\n", NtStatus));
        ASSERT(0);
    }

    status = NtStatus;
#else

    pThisDev->fReceiving = TRUE;

    (void)SerialSetTimeouts(pThisDev->pSerialDevObj,
                            &SerialTimeoutsIdle);

    status = (NDIS_STATUS)StartSerialRead(pThisDev);

    if ( (status != STATUS_SUCCESS) &&
         (status != STATUS_PENDING) &&
         (status != STATUS_TIMEOUT) )
    {
        DEBUGMSG(DBG_ERR, ("    IoCallDriver failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_FAILURE;

        pThisDev->fReceiving = FALSE;

        goto error10;
    }

    //
    // If IoCallDriver returned STATUS_PENDING, we were successful
    // in sending the irp to the serial device object. This
    // routine will return STATUS_SUCCESS.
    //

    if (status == NDIS_STATUS_PENDING)
    {
        status = NDIS_STATUS_SUCCESS;
    }

    //
    // Set us into the receive state.
    //



    goto done;

    error10:

#endif
    done:
        DEBUGMSG(DBG_FUNC, ("-InitializeReceive\n"));

        return status;
}


VOID
SetSpeedCallback(
    PIR_WORK_ITEM pWorkItem
    )
{
    PIR_DEVICE      pThisDev = pWorkItem->pIrDevice;
    NDIS_STATUS     status;
    BOOLEAN         fSwitchSuccessful;
    NDIS_HANDLE     hSwitchToMiniport;

    //
    // Set speed of serial device object by request of
    // IrsirSetInformation(OID_IRDA_LINK_SPEED).
    //

    DEBUGMSG(DBG_STAT, ("    primPassive = PASSIVE_SET_SPEED\n"));

    //
    // The set speed event should not be set until a set
    // speed is required.
    //

    ASSERT(pThisDev->fPendingSetSpeed == TRUE);

    //
    // Ensure that receives and sends have been stopped.
    //

    ASSERT(pThisDev->fReceiving == FALSE);

    PausePacketProcessing(&pThisDev->SendPacketQueue,TRUE);

    //
    // We can perform the set speed now.
    //

    status = SetSpeed(pThisDev);

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_STAT, ("    SetSpeed failed. Returned 0x%.8x\n", status));
    }

    ActivatePacketProcessing(&pThisDev->SendPacketQueue);

    pThisDev->fPendingSetSpeed = FALSE;

    {
        NdisMSetInformationComplete(
                            pThisDev->hNdisAdapter,
                            (NDIS_STATUS)status
                            );
    }


    //
    // NOTE: PassiveLevelThread is only signalled with primPassive
    //       equal to PASSIVE_SET_SPEED from the receive completion
    //       routine. After this thread is signalled, the receive
    //       completion routine is shut down...we need to start
    //       it up again.
    //

    status = InitializeReceive(pThisDev);

    if (status != STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, ("    InitializeReceive failed = 0x%.8x\n", status));

    }


    FreeWorkItem(pWorkItem);

    return;
}

/*****************************************************************************
*
*  Function:   SerialIoCompleteRead
*
*  Synopsis:
*
*  Arguments:  pSerialDevObj - pointer to the serial device object which
*                              completed the irp
*              pIrp          - the irp which was completed by the serial device
*                              object
*              Context       - the context given to IoSetCompletionRoutine
*                              before calling IoCallDriver on the irp
*                              The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*  Algorithm:
*              This is the completion routine for all pending IRP_MJ_READ irps
*              sent to the serial device object.
*
*              If there is a pending halt or reset, we exit the completion
*              routine without sending another irp to the serial device object.
*
*              If there is a pending set speed, this function will wait for
*              any pending sends to complete and then perform the set speed.
*
*              If the IRP_MJ_READ irp returned either STATUS_SUCCESS or
*              STATUS_TIMEOUT, we must process any data (stripping BOFs, ESC
*              sequences, and EOF) into an NDIS_BUFFER and NDIS_PACKET.
*
*              Another irp is then built (we just re-use the incoming irp) and
*              sent to the serial device object with another IRP_MJ_READ
*              request.
*
*  History:    dd-mm-yyyy   Author    Comment
*              10/5/1996    sholden   author
*
*  Notes:
*
*  This routine is called (by the io manager) in IRQL DISPATCH_LEVEL.
*
*****************************************************************************/

NTSTATUS
SerialIoCompleteRead(
            IN PDEVICE_OBJECT pSerialDevObj,
            IN PIRP           pIrp,
            IN PVOID          Context
            )
{
    PIR_DEVICE  pThisDev;
    BOOLEAN     fSwitchSuccessful;
    NDIS_HANDLE hSwitchToMiniport;
    NTSTATUS    status;
    ULONG_PTR    BytesRead;
    BOOLEAN     NewRead = TRUE;

 //   DEBUGMSG(DBG_FUNC, ("+SerialIoCompleteRead\n"));

    //
    // The context given to IoSetCompletionRoutine is simply the the ir
    // device object pointer.
    //

    pThisDev = CONTEXT_TO_DEV(Context);

    //
    // Need to check if there is a pending halt or reset. If there is, we
    // just leave the receive completion. Since we maintain one irp associated
    // with the receive functionality, the irp will be deallocated in
    // the ir device object deinitialization routine.
    //

    if ((pThisDev->fPendingHalt  == TRUE) ||
        (pThisDev->fPendingReset == TRUE))
    {
        //
        // Set the fReceiving boolean so that the halt and reset routines
        // know when it is okay to continue.
        //

        pThisDev->fReceiving = FALSE;

        //
        // Free the irp and associate memory...the rest will be
        // freed in the halt or reset.
        //

        LOG_ENTRY('3i', pThisDev, pIrp, 0);
        IoFreeIrp(pIrp);

        goto done;
    }

    //
    // Next we take care of any pending set speeds.
    //

    //
    // This completion routine is running at IRQL DISPATCH_LEVEL. Therefore,
    // we cannot make a synchronous call to the serial driver. Set an event
    // to notify the PassiveLevelThread to perform the speed change. We will
    // exit this without creating another irp to the serial device object.
    // PassiveLevelThread will call InitializeReceive after the speed has
    // been set.
    //

    if (pThisDev->fPendingSetSpeed == TRUE)
    {
        pThisDev->fReceiving = FALSE;

        if (ScheduleWorkItem(PASSIVE_SET_SPEED, pThisDev,
                    SetSpeedCallback, NULL, 0) != NDIS_STATUS_SUCCESS)
        {
            status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            status = NDIS_STATUS_PENDING;
        }

        LOG_ENTRY('4i', pThisDev, pIrp, 0);
        IoFreeIrp(pIrp);

        goto done;
    }

    //
    // We have a number of cases:
    //      1) The serial read timed out and we received no data.
    //      2) The serial read timed out and we received some data.
    //      3) The serial read was successful and fully filled our irp buffer.
    //      4) The irp was cancelled.
    //      5) Some other failure from the serial device object.
    //


    status = pIrp->IoStatus.Status;
    BytesRead = pIrp->IoStatus.Information;
    LOG_ENTRY('CR', pThisDev, BytesRead, 0);

    switch (status)
    {
        case STATUS_SUCCESS:
        case STATUS_TIMEOUT:

            if (BytesRead > 0)
            {
            #ifdef DEBUG_IRSIR

                //
                // Count number of irps received with data. Count will be
                // reset when delivering a buffer to the protocol.
                //

                irpCount++;
                bytesReceived += pIrp->IoStatus.Information;

            #endif //DEBUG_IRSIR

                //
                // Indicate that the next send should implement
                // the min turnaround delay.
                //

                pThisDev->fRequireMinTurnAround = TRUE;

                ProcessData(
                            pThisDev,
                            pThisDev->pRcvIrpBuffer,
                            (UINT) pIrp->IoStatus.Information
                            );
            }

            break; // STATUS_SUCCESS || STATUS_TIMEOUT

        case STATUS_DELETE_PENDING:
            NewRead = FALSE;
            pThisDev->fReceiving = FALSE;
            break;

        case STATUS_CANCELLED:
            //
            // If our irp was cancelled, we just ignore and continue as if
            // we processed data.
            //

            break;

        case STATUS_PENDING:
        case STATUS_UNSUCCESSFUL:
        case STATUS_INSUFFICIENT_RESOURCES:
        default:

            ASSERT(FALSE);

            break;
    }

    //
    // Free the irp and reinit the buffer and status block.
    //

    LOG_ENTRY('5i', pThisDev, pIrp, 0);
    IoFreeIrp(pIrp);

    if (NewRead)
    {
        pThisDev->NumReads++;

        if (InterlockedIncrement(&pThisDev->ReadRecurseLevel)>1)
        {
            if (ScheduleWorkItem(0, pThisDev, StartSerialReadCallback, 0, 0)!=NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERR, ("IRSIR:SerialIoCompleteRead: Timed out and couldn't reschedule read.\n"
                                   "      We're going down.\n"));
                pThisDev->fReceiving = FALSE;
            }
        }
        else
        {
            StartSerialRead(pThisDev);
        }

        InterlockedDecrement(&pThisDev->ReadRecurseLevel);
    }

done:
//        DEBUGMSG(DBG_FUNC, ("-SerialIoCompleteRead\n"));

        //
        // We return STATUS_MORE_PROCESSING_REQUIRED so that the completion
        // routine (IofCompleteRequest) will stop working on the irp.
        //

        status = STATUS_MORE_PROCESSING_REQUIRED;

        return status;
}

/*****************************************************************************
*
*  Function:   ProcessData
*
*  Synopsis:   State machine to process the input data by stripping BOFs, EOFs
*              and ESC sequences in the data.
*
*  Arguments:  pThisDev     - a pointer to the current ir device object
*              rawBuffer    - a pointer to the input data to process
*              rawBytesRead - the number of bytes in rawBuffer
*
*  Returns:    STATUS_SUCCESS
*
*  Algorithm:
*
*      The state machine for receiving characters is as follows:
*
*      -------------------------------------------------------------------
*      | Event/State    || READY     | BOF       | IN_ESC    | RX        |
*      -------------------------------------------------------------------
*      -------------------------------------------------------------------
*      |                ||           |           |           |           |
*      | char = BOF     || state =   |           | reset     | reset     |
*      |                ||   BOF     |           | state =   | state =   |
*      |                ||           |           |   BOF     |   BOF     |
*      -------------------------------------------------------------------
*      |                ||           |           | error     |           |
*      | char = ESC     ||           | state =   | reset     | state =   |
*      |                ||           |   IN_ESC  | state =   |   IN_ESC  |
*      |                ||           |           |   READY   |           |
*      -------------------------------------------------------------------
*      |                ||           |           |           | if valid  |
*      | char = EOF     ||           |  state =  | error     |   FCS {   |
*      |                ||           |    READY  | reset     | indicate  |
*      |                ||           |           | state =   |   data    |
*      |                ||           |           |   READY   | state =   |
*      |                ||           |           |           |   READY } |
*      -------------------------------------------------------------------
*      |                ||           |           | complem