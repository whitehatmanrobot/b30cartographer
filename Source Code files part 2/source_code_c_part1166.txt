
GPCH_BUILD=daytona
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\cruntime.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	cruntime.cxx
//
//  Contents:	Implementation of Cruntimes that we need since we
//              can't use MSVCRT and WIn95 doesn't implement the lstr*W 
//              versions. (well, it implements them but they are just stubs)
//
//
//  Functions:	Laylstrcmp
//              Laylstrcpy
//              Laylstrcpyn
//              Laylstrlen
//              Laylstrcat
//
//  History:	20-Jun-96	SusiA	Created
//
//----------------------------------------------------------------------------

#pragma hdrstop
#include <string.h>

/***
* Laylstrcmp - compare two wchar_t strings,
*	 returning less than, equal to, or greater than
*
*Purpose:
*	wcscmp compares two wide-character strings and returns an integer
*	to indicate whether the first is less than the second, the two are
*	equal, or whether the first is greater than the second.
*
*	Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*	say that Null wchar_t(0) is less than any other character.
*
*Entry:
*	const wchar_t * src - string for left-hand side of comparison
*	const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*	returns -1 if src <  dst
*	returns  0 if src == dst
*	returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int Laylstrcmp (
	const wchar_t * src,
	const wchar_t * dst
	)
{
	int ret = 0 ;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}


/***
*wchar_t *Laylstrcat(dst, src) - concatenate (append) one wchar_t string to another
*
*Purpose:
*	Concatenates src onto the end of dest.	Assumes enough
*	space in dest.
*
*Entry:
*	wchar_t *dst - wchar_t string to which "src" is to be appended
*	const wchar_t *src - wchar_t string to be appended to the end of "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

wchar_t * Laylstrcat (
	wchar_t * dst,
	const wchar_t * src
	)
{
	wchar_t * cp = dst;

	while( *cp )
		cp++;			/* find end of dst */

	while( *cp++ = *src++ ) ;	/* Copy src to end of dst */

	return( dst );			/* return dst */

}


/***
*wchar_t *Laylstrcpy(dst, src) - copy one wchar_t string over another
*
*Purpose:
*	Copies the wchar_t string src into the spot specified by
*	dest; assumes enough room.
*
*Entry:
*	wchar_t * dst - wchar_t string over which "src" is to be copied
*	const wchar_t * src - wchar_t string to be copied over "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*******************************************************************************/

wchar_t * Laylstrcpy(wchar_t * dst, const wchar_t * src)
{
	wchar_t * cp = dst;

	while( *cp++ = *src++ )
		;		/* Copy src over dst */

	return( dst );
}


/***
*wchar_t *Laylstrcpyn(dest, source, count) - copy at most n wide characters
*
*Purpose:
*	Copies count characters from the source string to the
*	destination.  If count is less than the length of source,
*	NO NULL CHARACTER is put onto the end of the copied string.
*	If count is greater than the length of sources, dest is padded
*	with null characters to length count (wide-characters).
*
*
*Entry:
*	wchar_t *dest - pointer to destination
*	wchar_t *source - source string for copy
*	size_t count - max number of characters to copy
*
*Exit:
*	returns dest
*
*Exceptions:
*
*******************************************************************************/


wchar_t * Laylstrcpyn (
	wchar_t * dest,
	const wchar_t * source,
	size_t count
	)
{
	wchar_t *start = dest;

	while (count && (*dest++ = *source++))	  /* copy string */
		count--;

	if (count)				/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';

	return(start);
}

/***
*Laylstrlen - return the length of a null-terminated wide-character string
*
*Purpose:
*	Finds the length in wchar_t's of the given string, not including
*	the final null wchar_t (wide-characters).
*
*Entry:
*	const wchar_t * wcs - string whose length is to be computed
*
*Exit:
*	length of the string "wcs", exclusive of the final null wchar_t
*
*Exceptions:
*
*******************************************************************************/

size_t Laylstrlen (
	const wchar_t * wcs
	)
{
	const wchar_t *eos = wcs;

	while( *eos++ ) ;

	return( (size_t)(eos - wcs - 1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}
#ifdef _CHICAGO_
//int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType);
#define SSMessageBox MessageBox
#endif // _CHICAGO_


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
#ifdef _CAIRO_
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK;
#else
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
#endif
//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CDLLStaticMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  are memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifdef FLAT
            DebugBreak();
#else
            _asm int 3;
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifdef FLAT
        DebugBreak();
#else
        _asm int 3;
#endif
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintfA(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

# ifdef _CAIRO_
    // Other processes which are services also use this code, but they
    //  have no access to set gfService, so if the above failed with an
    //  access denied error (meaning no access to the default desktop)
    //  retry as a service popup. Also, remember that we are a service
    //  so we don't waste attempts later.
    if ( !gfService && !id
         && (GetLastError() == ERROR_ACCESS_DENIED) )
    {
        gfService = TRUE;
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
        id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                         dwMessageFlags);
    }
# endif

#else
    id = SSMessageBox(NULL, (char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

#endif

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}


#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\eqguid.cxx ===
#define _SYS_GUID_OPERATORS_
#include  <windows.h>
#include  <ole2.h>
#include  <stdlib.h>

//+-------------------------------------------------------------------------
//
//  Function:	IsEqualGUID  (public)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//  Note:
//      Only reason we have this function is because we exported it originally
//      from OLE32.DLL and forgot to take it out when we made it an inline
//      function in objbase.h.  Somebody out there may be relying on it being
//      available.  Internally we must use wIsEqualGUID.
//
//--------------------------------------------------------------------------
#undef IsEqualGUID  // undo the #define in objbase.h
extern "C" BOOL  __stdcall IsEqualGUID(GUID &guid1, GUID &guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}

//+-------------------------------------------------------------------------
//
//  Function:	wIsEqualGUID  (internal)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//--------------------------------------------------------------------------

BOOL  __fastcall wIsEqualGUID(REFGUID guid1, REFGUID guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   06-05-95  SVA   Added support for printing GUIDs.
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if defined(_WIN64)
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#elif PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

/* Brief description of the table, since I can't find maketab.c - t-stevan     */
/* Each entry in form 0xYZ. Here Z is a character class used in the macro      */
/* find_char_class defined below. The character classes are defined in the     */
/* CHARTYPE enum. For example, 'I' maps to CH_TYPE. To find a particular entry */
/* Subtract the ASCI value for the space char from the character, and that is  */
/* the index to look up. The Y value is holds state transition information.    */
/* It is used in the macro find_next_state. */
static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x38, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x07, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#if _INTEGRAL_MAX_BITS >= 64
LOCAL(__int64) get_int64_arg(va_list *pargptr);
#endif  /* _INTEGRAL_MAX_BITS >= 64    */

LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif

/* Defines for printing out GUIDs */
#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED

/* This is actually one less than the normal GUIDSTR_MAX */
/* Because we don't tag on a NULL byte */
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 /* + 1 */)

/* Make sure our buffer size is big enough to hold a GUID */
#if BUFFERSIZE < GUIDSTR_MAX
#undef BUFFERSIZE
#define BUFFERSIZE GUIDSTR_MAX
#endif

/* Function used to write a GUID to a string */
int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
	    case 't':
#ifdef _UNICODE
		flags |= FL_WIDE;
#endif
		break;

            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text); /* len of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            /* print a GUID */
            case 'I':
            {
                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

			    if (p == NULL)
			    {
			   		/* null ptr passed, use special string */
			   		text = nullstring;
					textlen = strlen(nullstring);
				}
				else
               	{
               		textlen = StrFromGUID(p, buffer, BUFFERSIZE);
               		text = buffer;
				}
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;

#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text);
                                /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif

#if _INTEGRAL_MAX_BITS >= 64
LOCAL(__int64) get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif  /* _INTEGRAL_MAX_BITS >= 64    */


/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}


const wchar_t a_wcDigits[] = L"0123456789ABCDEF";

//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNum
//
//  Synopsis:   Given a value, and a count of characters, translate
//		the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//		[chChars] -- Number of characters to format
//		[pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    5-31-95   t-stevan  Copied and Modified for use in debug output function
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
	while(chChars--)
	{
		pchStr[chChars] = (char) a_wcDigits[ulValue & 0xF];
		ulValue = ulValue >> 4;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   StrFromGUID     (private)
//
//  Synopsis:   Converts a GUID into a string (duh!)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax)  // internal
{
    if (cbMax < GUIDSTR_MAX)
	return 0;


//   Make the GUID into"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",

    *lpsz++ = '{';
    FormatHexNum( rguid->Data1, 8 , lpsz);
    lpsz += 8;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data2, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data3, 4 , lpsz);
    lpsz += 4;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[0], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[1], 2 , lpsz);
    lpsz += 2;
    *lpsz++ = '-';

    FormatHexNum( rguid->Data4[2], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[3], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[4], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[5], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[6], 2 , lpsz);
    lpsz += 2;
    FormatHexNum( rguid->Data4[7], 2 , lpsz);
    lpsz += 2;

    *lpsz++ = '}';
    /* We don't want to tag on a NULL char because we don't need to print one out *\
    /* *lpsz = 0; */


    return GUIDSTR_MAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static HANDLE fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == (HANDLE)-1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = GetStdHandle(ldummy)) == 0 || fh == (HANDLE)-1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\dfsetup\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\dfsetup\dfsetup.cxx ===
#include "windows.h"

__cdecl main(int argc, char **argv)
{
    char szSystemPath[_MAX_PATH];
    
    char szFilename[_MAX_PATH];
    char szCurPath[_MAX_PATH];
    
    int len;
    UINT dwFilename = _MAX_PATH;
    DWORD dwstatus;
    
    if (GetSystemDirectory(szSystemPath, _MAX_PATH) == 0)
    {
        return (dwstatus = GetLastError());
    }
      

    //Get the path to the install source directory
    if ((len = GetModuleFileName(NULL, szCurPath, _MAX_PATH)) == 0)
    {
        return (dwstatus =GetLastError());
    }
    
    while (szCurPath[--len] != '\\')
        continue;
    szCurPath[len+1] = '\0';

    // install the file to the system directory
    dwstatus = VerInstallFile(0,"DFLAYOUT.DLL", "DFLAYOUT.DLL",
                              szCurPath, szSystemPath, szSystemPath,
                              szFilename, &dwFilename);
    

    return dwstatus;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\dftool\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\dftool\dftool.cxx ===
#include "windows.h"

__cdecl main(int argc, char **argv)
{
    char szSystemPath[_MAX_PATH];
    
    char szFilename[_MAX_PATH];
    char szCurPath[_MAX_PATH];
    
    int len;
    UINT dwFilename = _MAX_PATH;
    DWORD dwstatus;
    
    if (GetSystemDirectory(szSystemPath, _MAX_PATH) == 0)
    {
        return (dwstatus = GetLastError());
    }
      

    //Get the path to the install source directory
    if ((len = GetModuleFileName(NULL, szCurPath, _MAX_PATH)) == 0)
    {
        return (dwstatus =GetLastError());
    }
    
    while (szCurPath[--len] != '\\')
        continue;
    szCurPath[len+1] = '\0';

    // install the file to the system directory
    dwstatus = VerInstallFile(0,"DFLAYOUT.DLL", "DFLAYOUT.DLL",
                              szCurPath, szSystemPath, szSystemPath,
                              szFilename, &dwFilename);
    if (dwstatus)
    {
        return dwstatus;
    }

	
    // install the file to the system directory
    dwFilename = _MAX_PATH;
    dwstatus = VerInstallFile(0,"DFLAYOUT.EXE", "DFLAYOUT.EXE",
                              szCurPath, szSystemPath, szSystemPath,
                              szFilename, &dwFilename);


    return dwstatus;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\asyncver.h ===
#ifdef RC_INVOKED

#include <winver.h>

#define VER_FILEVERSION_STR      "0.0\0"
#define VER_FILEVERSION          0,000,0000,0000

#define VER_PRODUCTNAME_STR      "Microsoft Asynchronous Storage for OLE\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1995\0"
#define VER_PRODUCTVERSION_STR   "0.0\0"
#define VER_PRODUCTVERSION       0,0000,0000,0000
#define VER_COMMENT_STR          "Microsoft Asynchronous Storage for OLE\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_NT_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "Microsoft Asynchronous Storage for OLE\0"

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\astghead.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:	astghead.cxx
//
//  Contents:	Precompiled header for async
//
//  History:	28-Mar-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ole2.h>
#include <ocidl.h>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <debnot.h>
#include <error.hxx>
#include <except.hxx>
#include <docfilep.hxx>
#include <dfmsp.hxx>


#include "astg.hxx"
#include "asyncerr.hxx"

#if defined (_CHICAGO_)
#include <widewrap.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\idl\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\filllkb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	filllkb.cxx
//
//  Contents:	IFillLockBytes and ILockBytes wrapper for async docfiles
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "filllkb.hxx"
#include <valid.h>
#include <utils.hxx>


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::CFillLockBytes, public
//
//  Synopsis:	Default constructor
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFillLockBytes::CFillLockBytes(ILockBytes *pilb)
{
    _pilb = pilb;
    pilb->AddRef();
    _ulHighWater = 0;
    _ulFailurePoint = 0;
    _dwTerminate = UNTERMINATED;
#ifdef ASYNC
    _ppc = NULL;
#else
    _hNotifyEvent = INVALID_HANDLE_VALUE;
#endif
    _fCSInitialized = FALSE;
    _cRefs = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::~CFillLockBytes, public
//
//  Synopsis:	Destructor
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFillLockBytes::~CFillLockBytes()
{
    astgAssert(_pilb == NULL);
#ifdef ASYNC
#ifdef MULTIHEAP    
    if (_ppc)
    {
        CSafeMultiHeap smh(_ppc);
        if (_ppc->ReleaseSharedMem() == 0)
            g_smAllocator.Uninit();
    }
#endif    
#else
    if (_hNotifyEvent != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hNotifyEvent);
    }
#endif
    if (_fCSInitialized)
        DeleteCriticalSection(&_csThreadProtect);
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Init, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CFillLockBytes::Init(void)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Init:%p()\n", this));

    if (FALSE == _fCSInitialized)
    {
        __try
        {
            InitializeCriticalSection(&_csThreadProtect);
            _fCSInitialized = TRUE;
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return HRESULT_FROM_WIN32( GetExceptionCode() );
        }
    }

#ifndef ASYNC
    _hNotifyEvent = CreateEvent(NULL,
                                TRUE,
                                FALSE,
                                NULL);
    if (_hNotifyEvent == NULL)
    {
        return Win32ErrorToScode(GetLastError());
    }
#endif    

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CFillLockBytes::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFillLockBytes::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::QueryInterface(?, %p)\n",
                ppvObj));
    
    astgChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;

    sc = S_OK;
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (ILockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_ILockBytes))
    {
        *ppvObj = (ILockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFillLockBytes::AddRef();
    }
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IFillInfo))
    {
        *ppvObj = (IFillInfo *)this;
        CFillLockBytes::AddRef();
    }
#endif    
    else if (IsEqualIID(iid, IID_IDefaultFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::QueryInterface => %p\n",
                ppvObj));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CFillLockBytes::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CFillLockBytes::AddRef(void)
{
    InterlockedIncrement (&_cRefs);
    return _cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Release, public
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFillLockBytes::Release(void)
{
    LONG lRet;
    InterlockedDecrement (&_cRefs);
    lRet = _cRefs;
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
#ifndef ASYNC        
        ILockBytes *ptempilb;
        if (SUCCEEDED(_pilb->QueryInterface(IID_IAsyncFileLockBytes,
                                            (void **)&ptempilb)))
        {
            ptempilb->Release();
            lRet = ((CFileLockBytes *)_pilb)->FileDeleteRelease();
        }
        else
#endif            
    }

    if (lRet == 0)
    {
        _pilb->Release();
        _pilb = NULL;
        delete this;
    }
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::ReadAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::ReadAt(ULARGE_INTEGER ulOffset,
                                    VOID HUGEP *pv,
                                    ULONG cb,
                                    ULONG *pcbRead)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::ReadAt:%p()\n", this));

        if (_dwTerminate == TERMINATED_ABNORMAL)
        {
            sc = STG_E_INCOMPLETE;
        }
        else if ((_dwTerminate == TERMINATED_NORMAL) ||
                 (ULIGetLow(ulOffset) + cb <= _ulHighWater))
        {
            sc = _pilb->ReadAt(ulOffset, pv, cb, pcbRead);
        }
        else
        {
            *pcbRead = 0;
            _ulFailurePoint = cb + ULIGetLow(ulOffset);
            sc = E_PENDING;
        }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::ReadAt\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::WriteAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::WriteAt(ULARGE_INTEGER ulOffset,
                                     VOID const HUGEP *pv,
                                     ULONG cb,
                                     ULONG *pcbWritten)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::WriteAt:%p()\n", this));

        if (_dwTerminate == TERMINATED_ABNORMAL)
        {
            sc = STG_E_INCOMPLETE;
        }
        else if ((_dwTerminate == TERMINATED_NORMAL) ||
                 (ULIGetLow(ulOffset) + cb <= _ulHighWater))
        {
            sc = _pilb->WriteAt(ulOffset, pv, cb, pcbWritten);
        }
        else
        {
            *pcbWritten = 0;
            _ulFailurePoint = cb + ULIGetLow(ulOffset);
            sc = E_PENDING;
        }
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::WriteAt\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Flush, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Flush(void)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Flush:%p()\n", this));
    sc = _pilb->Flush();
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Flush\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::SetSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::SetSize(ULARGE_INTEGER cb)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetSize:%p()\n", this));

        if (_dwTerminate == TERMINATED_ABNORMAL)
        {
            sc = STG_E_INCOMPLETE;
        }
        else if ((_dwTerminate == TERMINATED_NORMAL) ||
                 (ULIGetLow(cb) <= _ulHighWater))
        {
            sc = _pilb->SetSize(cb);
        }
        else
        {
            _ulFailurePoint = ULIGetLow(cb);
            sc = E_PENDING;
        }
        
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetSize\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::LockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::LockRegion:%p()\n", this));

    sc = _pilb->LockRegion(libOffset, cb, dwLockType);

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::LockRegion\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::UnlockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::UnlockRegion:%p()\n", this));
    sc = _pilb->UnlockRegion(libOffset, cb, dwLockType);
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::UnlockRegion\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Stat, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Stat:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->Stat(pstatstg, grfStatFlag);
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Stat\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::FillAppend, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::FillAppend(void const *pv,
                                        ULONG cb,
                                        ULONG *pcbWritten)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::FillAppend:%p()\n", this));

    sc = ValidateBuffer (pv, cb);
    if (!SUCCEEDED(sc))
        return sc;

    if (_dwTerminate != UNTERMINATED)
    {
        sc = STG_E_TERMINATED;
    }
    else
    {
        ULONG cbWritten;
        ULARGE_INTEGER uli;
        uli.QuadPart = _ulHighWater;
        sc = _pilb->WriteAt(uli, pv, cb, &cbWritten);
        _ulHighWater += cbWritten;
        if (pcbWritten != NULL)
        {
            *pcbWritten = cbWritten;
        }
#ifdef ASYNC        
        if (_ppc)
        {
            HANDLE hEvent = _ppc->GetNotificationEvent();
            if (!PulseEvent(hEvent))
            {
                sc = Win32ErrorToScode(GetLastError());
            }
        }
#else
        if (!PulseEvent(_hNotifyEvent))
        {
            sc = Win32ErrorToScode(GetLastError());
        }
#endif        
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::FillAppend\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::FillAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::FillAt(ULARGE_INTEGER ulOffset,
                                    void const *pv,
                                    ULONG cb,
                                    ULONG *pcbWritten)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::FillAt:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::FillAt\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::SetFillSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::SetFillSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetFillSize:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->SetSize(ulSize);
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetFillSize\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Terminate, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Terminate(BOOL bCanceled)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Terminate:%p()\n", this));
    _dwTerminate = (bCanceled) ? TERMINATED_ABNORMAL : TERMINATED_NORMAL;
#ifdef ASYNC
    if (_ppc)
    {
        HANDLE hEvent = _ppc->GetNotificationEvent();
        if (!SetEvent(hEvent))
        {
            return Win32ErrorToScode(GetLastError());
        }
    }
#else
    if (!SetEvent(_hNotifyEvent))
    {
        return Win32ErrorToScode(GetLastError());
    }
#endif    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Terminate\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetFailureInfo, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::GetFailureInfo(ULONG *pulWaterMark,
                                            ULONG *pulFailurePoint)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CFillLockBytes::GetFailureInfo:%p()\n", this));
    *pulWaterMark = _ulHighWater;
    *pulFailurePoint = _ulFailurePoint;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetFailureInfo\n"));
    return S_OK;
}

#ifndef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetNotificationEvent, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

HANDLE CFillLockBytes::GetNotificationEvent(void)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::GetNotificationEvent:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetNotificationEvent\n"));
    return _hNotifyEvent;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetTerminationStatus, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::GetTerminationStatus(DWORD *pdwFlags)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CFillLockBytes::GetTerminationStatus:%p()\n", this));
    *pdwFlags = _dwTerminate;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetTerminationStatus\n"));
    return S_OK;
}



SCODE CFillLockBytes::SetFailureInfo(ULONG ulWaterMark,
                                     ULONG ulFailurePoint)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetFailureInfo:%p()\n", this));
    _ulHighWater =ulWaterMark;
    _ulFailurePoint = ulFailurePoint ;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetFailureInfo\n"));
    return S_OK;
}
#if DBG==1
void CFillLockBytes::PulseFillEvent()
{
#ifdef ASYNC    
    if (_ppc)
    {
        HANDLE hEvent = _ppc->GetNotificationEvent();
        PulseEvent(hEvent);
    }
#else
    PulseEvent(_hNotifyEvent);
#endif    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\chicago\makefile.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!ifndef MIDL
MIDL = midl.exe
!endif


SDKINC=$(BASEDIR)\public\sdk\inc
INCLUDES=$(SDKINC);$(INCLUDES)
PASS0_HEADERDIR=$(SDKINC)
PASS0_SOURCEDIR=obj

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oi2 \
 -oldnames \
 -char unsigned \
 -error allocation \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES)

SSWITCH=-prefix sstub _

obj\iconn.h:	..\iconn.idl
     $(MIDL) $(MIDL_FLAGS) -header obj\iconn.h  iconn.idl

$(DOCFILEINC)\iconn.h: obj\iconn.h
     copy obj\iconn.h $(DOCFILEINC)\iconn.h

DEST_TREE=daytona

allidl:   obj\iconn.h

clean:
	  -erase obj\iconn.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\daytona\makefile.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!ifndef MIDL
MIDL = midl.exe
!endif


SDKINC=$(BASEDIR)\public\sdk\inc
INCLUDES=$(SDKINC);$(INCLUDES)
MIDL_UUIDDIR=$(O)
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_TLBDIR=$(O)

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oicf \
 -oldnames \
 -char unsigned \
 -error allocation \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES)

SSWITCH=-prefix sstub _

$(O)\iconn.h:	..\iconn.idl
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header iconn.h  iconn.idl

DEST_TREE=daytona

allidl:   $(O)\iconn.h

clean:
	  -erase $(O)\iconn.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\asyncapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       asyncapi.cxx
//
//  Contents:   APIs for async docfiles
//
//  Classes:
//
//  Functions:
//
//  History:    19-Dec-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#ifndef ASYNC
#define USE_FILELKB
#endif


#include "asyncapi.hxx"
#include "filllkb.hxx"
#ifdef USE_FILELKB
#include "filebyte.hxx"
#endif

#ifdef ASYNC
#include <expdf.hxx>
#endif


#if DBG == 1
DECLARE_INFOLEVEL(astg);
#endif

#ifdef ASYNC
#ifdef COORD
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               ITransaction *pTransaction,
               CExposedDocFile **ppdfExp,
               CLSID *pcid);
#else
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               CExposedDocFile **ppdfExp,
               CLSID *pcid);
#endif //COORD
#endif //ASYNC


STDAPI StgOpenAsyncDocfileOnIFillLockBytes(IFillLockBytes *pflb,
                                           DWORD grfMode,
                                           DWORD asyncFlags,
                                           IStorage **ppstgOpen)
{
#ifdef ASYNC
    SCODE sc;
    ILockBytes *pilb;
    IStorage *pstg;
    IFileLockBytes *pfl;

    sc = ValidateInterface(pflb, IID_IFillLockBytes);
    if (FAILED(sc))
    {
        return sc;
    }
    sc = ValidateOutPtrBuffer(ppstgOpen);
    if (FAILED(sc))
    {
        return sc;
    }
    *ppstgOpen = NULL;

    //We're going to do a song and dance here because the ILockBytes
    //implementation we return from StgGetIFillLockBytesOnFile won't
    //let you QI for ILockBytes (because those methods aren't thread safe,
    //among other things).  Instead we QI for a private interface and do
    //a direct cast if that succeeds.  Otherwise we're on someone else's
    //implementation so we just go right for ILockBytes.

    sc = pflb->QueryInterface(IID_IFileLockBytes, (void **)&pfl);
    if (FAILED(sc))
    {
	    sc = pflb->QueryInterface(IID_ILockBytes, (void **)&pilb);
	    if (FAILED(sc))
	    {
	        return sc;
	    }
    }
    else
    {
	    pilb = (ILockBytes *)((CFileStream *)pfl);
    }

    //If we're operating on the docfile owned ILockBytes, then we can
    //  go directly to DfFromLB instead of using StgOpenStorageOnILockBytes
    //  which will avoid creating another shared heap.

    if (pfl != NULL)
    {
        pfl->Release();
        pilb = NULL;

        CFileStream *pfst = (CFileStream *)pflb;
        CPerContext *ppc = pfst->GetContextPointer();
#ifdef MULTIHEAP
        CSafeMultiHeap smh(ppc);
#endif

#ifdef COORD
        astgChk(DfFromLB(ppc,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         NULL,
                         (CExposedDocFile **)&pstg,
                         NULL));
#else
        astgChk(DfFromLB(ppc,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         (CExposedDocFile **)&pstg,
                         NULL));
#endif
        //Note:  Don't release the ILB reference we got from the QI
        //  above, since DfFromLB recorded that pointer but didn't
        //  AddRef it.
        pfst->AddRef();  // CExposedDocfile will release this reference
    }
    else
    {
        IFillLockBytes *pflb2;
        if (SUCCEEDED(pilb->QueryInterface(IID_IDefaultFillLockBytes,
                                           (void **)&pflb2)))
        {
            CFillLockBytes *pflbDefault = (CFillLockBytes *)pflb;
            CPerContext *ppc;
            pflb2->Release();
            astgChk(StgOpenStorageOnILockBytes(pilb,
                                               NULL,
                                               grfMode,
                                               NULL,
                                               0,
                                               &pstg));
            //Get PerContext pointer from pstg
            ppc = ((CExposedDocFile *)pstg)->GetContext();
            pflbDefault->SetContext(ppc);
        }
        else
        {
            astgChk(StgOpenStorageOnILockBytes(pilb,
                                               NULL,
                                               grfMode,
                                               NULL,
                                               0,
                                               &pstg));
        }
        pilb->Release();
        pilb = NULL;
    }
    astgChkTo(EH_stg, ((CExposedDocFile *)pstg)->InitConnection(NULL));
    ((CExposedDocFile *)pstg)->SetAsyncFlags(asyncFlags);


    *ppstgOpen = pstg;

    return NOERROR;

EH_stg:
    pstg->Release();
Err:
    if (pilb != NULL)
        pilb->Release();
    if (sc == STG_E_PENDINGCONTROL)
    {
        sc = E_PENDING;
    }
    return ResultFromScode(sc);
#else
    HRESULT hr;
    ILockBytes *pilb;
    IStorage *pstg;

    hr = pflb->QueryInterface(IID_ILockBytes, (void **)&pilb);
    if (FAILED(hr))
    {
	return hr;
    }

    hr = StgOpenStorageOnILockBytes(pilb,
				    NULL,
				    grfMode,
				    NULL,
				    0,
				    &pstg);

    pilb->Release();
    if (FAILED(hr))
    {
        if (hr == STG_E_PENDINGCONTROL)
        {
            hr = E_PENDING;
        }
	return hr;
    }

    BOOL fDefault = FALSE;
    IFillLockBytes *pflbDefault;
    hr = pflb->QueryInterface(IID_IDefaultFillLockBytes,
                              (void **)&pflbDefault);
    if (SUCCEEDED(hr))
    {
        fDefault = TRUE;
        pflbDefault->Release();
    }

    *ppstgOpen = new CAsyncRootStorage(pstg, pflb, fDefault);
    if (*ppstgOpen == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }
    else
    {
        ((CAsyncRootStorage *)(*ppstgOpen))->SetAsyncFlags(asyncFlags);
    }

    return NOERROR;
#endif //ASYNC
}

STDAPI StgGetIFillLockBytesOnILockBytes( ILockBytes *pilb,
					 IFillLockBytes **ppflb)
{
    SCODE sc = S_OK;
    CFillLockBytes *pflb = NULL;

    sc = ValidateOutPtrBuffer(ppflb);
    if (FAILED(sc))
    {
        return sc;
    }
    sc = ValidateInterface(pilb, IID_ILockBytes);
    if (FAILED(sc))
    {
        return sc;
    }
    
    pflb = new CFillLockBytes(pilb);
    if (pflb == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }
    sc = pflb->Init();
    if (FAILED(sc))
    {
        pflb->Release();
	*ppflb = NULL;
	return sc;
    }

    *ppflb = pflb;
    return NOERROR;
}


STDAPI StgGetIFillLockBytesOnFile(OLECHAR const *pwcsName,
				  IFillLockBytes **ppflb)
{
#ifndef USE_FILELKB
    SCODE sc;
    IMalloc *pMalloc;
    CFileStream *plst;
    CFillLockBytes *pflb;
    CPerContext *ppc;

    astgChk(ValidateNameW(pwcsName, _MAX_PATH));
    astgChk(ValidateOutPtrBuffer(ppflb));
    
    DfInitSharedMemBase();
    astgHChk(DfCreateSharedAllocator(&pMalloc, FALSE));
    astgMemTo(EH_Malloc, plst = new (pMalloc) CFileStream(pMalloc));
    astgChkTo(EH_plst, plst->InitGlobal(RSF_CREATE,
                                       DF_DIRECT | DF_READ |
                                       DF_WRITE | DF_DENYALL));
    astgChkTo(EH_plst, plst->InitFile(pwcsName));

    astgMemTo(EH_plstInit, ppc = new (pMalloc) CPerContext(pMalloc));
    astgChkTo(EH_ppc, ppc->InitNewContext());
    //We want 0 normal references on the per context, and one reference
    //  to the shared memory.
    ppc->DecRef();
    plst->SetContext(ppc);
    plst->StartAsyncMode();
    astgChkTo(EH_plstInit, ppc->InitNotificationEvent(plst));

    *ppflb = (IFillLockBytes *)plst;

    return S_OK;

EH_ppc:
    delete ppc;
EH_plstInit:
    plst->Delete();
EH_plst:
    plst->Release();
EH_Malloc:
    pMalloc->Release();
Err:
    return sc;
#else
    SCODE sc;
    CFileLockBytes *pflb = NULL;
    pflb = new CFileLockBytes;
    if (pflb == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }
    sc = pflb->Init(pwcsName);
    if (SUCCEEDED(sc))
    {
	sc = StgGetIFillLockBytesOnILockBytes(pflb, ppflb);
    }
    return sc;
#endif // ASYNC
}



#if DBG == 1
STDAPI StgGetDebugFileLockBytes(OLECHAR const *pwcsName, ILockBytes **ppilb)
{
#ifdef ASYNC
    return STG_E_UNIMPLEMENTEDFUNCTION;
#else
    SCODE sc;
    CFileLockBytes *pflb;

    *ppilb = NULL;

    pflb = new CFileLockBytes;
    if (pflb == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }

    sc = pflb->Init(pwcsName);
    if (FAILED(sc))
    {
	delete pflb;
	pflb = NULL;
    }

    *ppilb = pflb;

    return sc;
#endif // ASYNC
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\docfile\stgconn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:	stgconn.cxx
//
//  Contents:	Connection points for Async Storage/Stream Wrappers
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include <sinklist.hxx>
#include <utils.hxx>

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::CConnectionPoint, public
//
//  Synopsis:	Constructor
//
//  Arguments:
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

CConnectionPoint::CConnectionPoint()
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::CConnectionPoint:%p()\n", this));
    _cReferences = 1;
    _dwCookie = 0;
    _pSinkHead = NULL;
    _pParentCP = NULL;

    _fCSInitialized = FALSE;
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::CConnectionPoint\n"));
}


CConnectionPoint::~CConnectionPoint()
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::~CConnectionPoint:%p()\n", this));
    TakeCS();
    if (_pParentCP)
        _pParentCP->Release();

    // clean up the advise list
    CSinkList *psltemp = _pSinkHead;
    CSinkList *pslprev = NULL;
    
    while (psltemp)
    {
        pslprev = psltemp;
        psltemp = psltemp->GetNext();
        pslprev->GetProgressNotify()->Release();
        delete pslprev;
    }

    if (_fCSInitialized)
    {
        ReleaseCS();
        DeleteCriticalSection(&_csSinkList);
    }
    
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::~CConnectionPoint\n"));
}

SCODE CConnectionPoint::Init()
{
    if (FALSE == _fCSInitialized)
    {
        __try
        {
            InitializeCriticalSection(&_csSinkList);
            _fCSInitialized = TRUE;
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return HRESULT_FROM_WIN32( GetExceptionCode() );
        }
    }
    return S_OK;
}

#ifndef ASYNC
void CConnectionPoint::Init(IConnectionPointContainer *pCPC)
{
    _pCPC = pCPC;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//              27-Feb-96       SusiA   Moved from Async wrappers 
//
//----------------------------------------------------------------------------
SCODE CConnectionPoint::Notify(SCODE scFailure,
                               IFillLockBytes *piflb,
                               BOOL fDefaultLockBytes)
{
    SCODE sc = S_OK;
    BOOL fAccurate = (scFailure == E_PENDING);
    ULONG ulWaterMark;
    ULONG ulFailurePoint;

    HANDLE hNotifyEvent;

    if (fDefaultLockBytes)
    {
        CFillLockBytes *pflb = (CFillLockBytes *)piflb;
        
        pflb->GetFailureInfo(&ulWaterMark,
                             &ulFailurePoint);

        pflb->ReleaseCriticalSection();
        
        while (((sc = NotifySinks(ulWaterMark,
                                  ulFailurePoint,
                                  fAccurate, 
                                  STG_S_MONITORING)) == STG_S_BLOCK) ||
               (sc == STG_S_MONITORING) ||
               // S_OK is a synonym for STG_S_MONITORING
               (sc == S_OK))
        {	
            DWORD dwFlags;
            
            // wait for an event to signal
            hNotifyEvent = pflb->GetNotificationEvent();
            WaitForSingleObject(hNotifyEvent, INFINITE);
			
            pflb->GetTerminationStatus(&dwFlags);
            // client terminated call?
            if (dwFlags == TERMINATED_ABNORMAL)
                return STG_E_INCOMPLETE;

            // download is complete
            else if (dwFlags == TERMINATED_NORMAL)
                return S_OK;

            else
            {
                //Note:  Don't overwrite the failure point we recorded
                //  before, since it may have been changed by some
                //  other thread.
                
                //Don't need to take the critical section here, since
                //we don't care about the current failure point.
                ULONG ulFailurePointCurrent;
                pflb->GetFailureInfo(&ulWaterMark,
                                     &ulFailurePointCurrent);

                // all the data is available now
                if (ulWaterMark >= ulFailurePoint)
                {
                    // we won't care what the return value is, so send STG_S_BLOCK,
                    // and all sinks are will have fOwner == FALSE
                    NotifySinks(ulWaterMark, ulFailurePoint, fAccurate, STG_S_BLOCK);
                    break;
                }
            }
				
        }
    }
    
    if ((sc == STG_S_RETRYNOW) || (sc == STG_S_BLOCK) || (sc == STG_S_MONITORING))
        return S_OK;
    else return sc;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::NotifySinks,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	23-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

SCODE CConnectionPoint::NotifySinks(ULONG ulProgressCurrent,
                                    ULONG ulProgressMaximum,
                                    BOOL  fAccurate,
                                    SCODE sc)
{
    
    CSinkList *pslTemp;
    TakeCS();


    // closest node with a connection point that wants to determine
    // behavior does
    // priority first to last on this Connection Point, then the 
    // parent connection point.

    pslTemp = GetHead();
	
    while (((sc == S_OK) ||(sc == STG_S_MONITORING))
            &&(pslTemp!=NULL))
    {
        sc = pslTemp->GetProgressNotify()
            ->OnProgress(ulProgressCurrent, ulProgressMaximum, fAccurate, TRUE);
        pslTemp = pslTemp->GetNext();
    }

    // notify the rest of the connections
    while (pslTemp !=NULL)
    {
        pslTemp->GetProgressNotify()
            ->OnProgress(ulProgressCurrent, ulProgressMaximum, fAccurate, FALSE);
        pslTemp = pslTemp->GetNext();
    }

    //call parent storage advise list next
    if (_pParentCP)
        sc = _pParentCP->NotifySinks(ulProgressCurrent,
                                     ulProgressMaximum,
                                     fAccurate,
                                     sc);
    
    ReleaseCS();
    return sc;

	
}

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::QueryInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	01-Jan-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::QueryInterface:%p()\n",
                  this));

    *ppvObj = NULL;

    if ((IsEqualIID(iid, IID_IUnknown)) ||
	(IsEqualIID(iid, IID_IDocfileAsyncConnectionPoint)))
    {
        *ppvObj = (IDocfileAsyncConnectionPoint *)this;
        CConnectionPoint::AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::QueryInterface\n"));
    return ResultFromScode(sc);
}



//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::AddRef, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void)
{
    ULONG ulRet;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::AddRef:%p()\n",
                  this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    
    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::AddRef\n"));
    return ulRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Release, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPoint::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::Release:%p()\n",
                  this));

    astgAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);

    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
    { 
        astgAssert((lRet > 0) && "Connection point released too many times.");
        lRet = 0;
    
    }
    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::Release\n"));
    return (ULONG)lRet;
}

#ifndef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::GetConnectionInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CConnectionPoint::GetConnectionInterface:%p()\n",
                  this));

    
    *pIID = IID_IProgressNotify;
          
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::GetConnectionInterface\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::GetConnectionPointContainer, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CConnectionPoint::GetConnectionPointContainer:%p()\n",
                  this));

    *ppCPC = _pCPC;
    _pCPC->AddRef();
    
    astgDebugOut((DEB_ITRACE,
                  "Out CConnectionPoint::GetConnectionPointContainer\n"));
    return S_OK;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Clone, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	26-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CConnectionPoint::Clone( CConnectionPoint *pcp)
{
    SCODE sc = S_OK;
    void *pv = NULL;

    astgDebugOut((DEB_ITRACE,"In  CConnectionPoint::Clone:%p()\n", this));

    TakeCS();
    pcp->TakeCS();

    CSinkList *pslNew = NULL;
    CSinkList *pslPrev = NULL;
    CSinkList *pslOld = pcp->GetHead();
    
    

    while (pslOld != NULL)
    {   
        astgMem(pslNew = new CSinkList);
        
        pslNew->SetNext(NULL);

        if (pslPrev)
            pslPrev->SetNext(pslNew);
        else
            _pSinkHead = pslNew;
        
        pslPrev = pslNew;
        
        pslNew->SetCookie(pslOld->GetCookie());
        
        //Note:  The QueryInterface will give us a reference to hold on to.
        astgChk(pslOld->GetProgressNotify()->QueryInterface(IID_IProgressNotify, &pv));
        pslNew->SetProgressNotify((IProgressNotify *)pv);
        
        pslOld= pslOld->GetNext();
    }

    _dwCookie = pcp->GetCookie();
    
    astgDebugOut((DEB_ITRACE,"Out CConnectionPoint::Clone\n"));

Err:
    while (_pSinkHead != NULL)
    {
        CSinkList *pSinkNext = _pSinkHead;
        delete _pSinkHead;
        _pSinkHead = pSinkNext;
    }

    pcp->ReleaseCS();
    ReleaseCS();

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint:: Advise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------
#ifdef ASYNC
STDMETHODIMP CConnectionPoint::AddConnection(IProgressNotify *pSink,
                                             DWORD *pdwCookie)
#else
STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnkSink,
                                      DWORD *pdwCookie)
#endif
{
    SCODE sc = S_OK;
    CSinkList *pslNew = NULL;
    CSinkList *pslTemp = _pSinkHead;
    
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::Advise:%p()\n", this));
    TakeCS();
    
    IProgressNotify *ppn;
	
    astgMem(pslNew = new CSinkList);
    *pdwCookie = ++_dwCookie;
    pslNew->SetCookie(*pdwCookie);
    
#ifdef ASYNC
    pSink->AddRef();
    pslNew->SetProgressNotify(pSink);
#else
    void *pv;
    //Note:  The QueryInterface will give us a reference to hold on to.
    astgChk(pUnkSink->QueryInterface(IID_IProgressNotify, &pv));
    pslNew->SetProgressNotify((IProgressNotify *)pv);
#endif
    
    //Add new node to end of list
    if (pslTemp == NULL)
        _pSinkHead = pslNew;
    else
    {
        while(pslTemp->GetNext() != NULL)
            pslTemp = pslTemp->GetNext();
        pslTemp->SetNext(pslNew); 
    }
    ReleaseCS();

    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::Advise\n"));
    return sc;
Err:
    ReleaseCS();
    delete pslNew;
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Unadvise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

#ifdef ASYNC
STDMETHODIMP CConnectionPoint::RemoveConnection(DWORD dwCookie)
#else
STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
#endif
{
    CSinkList *pslTemp;
    CSinkList *pslPrev;
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::Unadvise:%p()\n", this));
    
    TakeCS();
    
    pslTemp = _pSinkHead;
    pslPrev = NULL;
    
    while ((pslTemp != NULL) && (pslTemp->GetCookie() != dwCookie))
    {
        pslPrev = pslTemp;
        pslTemp = pslTemp->GetNext();
    }

    if (pslTemp != NULL)
    {
        //Found the sink.  Delete it from the list.
        if (pslPrev != NULL)
        {
            pslPrev->SetNext(pslTemp->GetNext());
        }
        else
        {
            _pSinkHead = pslTemp->GetNext();
        }
        pslTemp->GetProgressNotify()->Release();
        
        delete pslTemp;
    }
    else
    {   //Client passed in unknown cookie.
        ReleaseCS();
        return E_UNEXPECTED;
    }
    ReleaseCS();

    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::Unadvise\n"));
    return S_OK;
}

#ifndef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::EnumConnections, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::EnumConnections(
    IEnumConnections **ppEnum)
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::EnumConnections:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::EnumConnections\n"));
    return E_NOTIMPL;
}
#endif

#ifdef ASYNC
STDMETHODIMP CConnectionPoint::GetParent(IDocfileAsyncConnectionPoint **ppdacp)
{
    *ppdacp = _pParentCP;
    return S_OK;
}
#endif

void CConnectionPoint::TakeCS(void)
{
    astgAssert (_fCSInitialized);
    EnterCriticalSection(&_csSinkList);
}

void CConnectionPoint::ReleaseCS(void)
{
    astgAssert (_fCSInitialized);
    LeaveCriticalSection(&_csSinkList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\h\valid.h ===
#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__); goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); retVar = retval;  goto label; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\layapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	layapi.cxx
//
//  Contents:	API for layout tool
//
//  Classes:	
//
//  Functions:	
//
//  History:	12-Feb-96	PhilipLa	Created
//              21-Feb-96       SusiA           New API, moved ReLayoutDocfile to method
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include <header.hxx>

#include "laylkb.hxx"
#include "laywrap.hxx"

#if DBG == 1
DECLARE_INFOLEVEL(lay);
#endif

STDAPI StgOpenLayoutDocfile(OLECHAR const *pwcsDfName,
                            DWORD grfMode,
                            DWORD reserved,
                            IStorage **ppstgOpen)
{
    SCODE sc;
    CLayoutLockBytes *pllkb;
    IStorage *pstg;

    if ((reserved != 0) ||  (!ppstgOpen))
    {
        return STG_E_INVALIDPARAMETER;
    }
    if (!(pwcsDfName))
    {
        return STG_E_INVALIDNAME;
    }
    
    pllkb = new CLayoutLockBytes();
    if (pllkb == NULL)
    {
	return STG_E_INSUFFICIENTMEMORY;
    }

    if (FAILED(sc = pllkb->Init(pwcsDfName, grfMode)))
    {
        pllkb->Release();
        return sc;
    }
    
    sc = StgOpenStorageOnILockBytes(pllkb,
				    NULL,
				    grfMode,
				    NULL,
				    0,
				    &pstg);

    if (FAILED(sc))
    {
        pllkb->Release();
	return sc;
    }

    *ppstgOpen = new CLayoutRootStorage(pstg, pllkb);
    if (*ppstgOpen == NULL)
    {
        pstg->Release();
        pllkb->Release();
	return STG_E_INSUFFICIENTMEMORY;
    }

    pstg->Release();
    pllkb->Release();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\layouthd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	layouthd.cxx
//
//  Contents:	Precompiled header for docfile layout
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

#ifdef _MAC
#define MAC_DOCFILE
#endif

#ifdef MAC_DOCFILE

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ole2.h>
#include <error.hxx>
#include <debnot.h>
#include "machead.hxx"  


#else
#define SUPPORT_FILE_MAPPING
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <ole2.h>
#include <error.hxx>
#include <debnot.h>

// we have to implement these ourselves
#undef lstrcmpW
#define lstrcmpW Laylstrcmp
#undef lstrcpyW
#define lstrcpyW Laylstrcpy
#undef lstrcpynW
#define lstrcpynW Laylstrcpyn
#undef lstrlenW
#define lstrlenW Laylstrlen
#undef lstrcatW
#define lstrcatW Laylstrcat

#endif //_MAC



#include "layout.hxx"
#include "layouter.hxx"
#include <msf.hxx>

//#ifdef SUPPORT_FILE_MAPPING
//#define MAPFILE void
//#else
#define MAPFILE CMappedFile
//#endif

#include "mapfile.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\laylkb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	laylkb.cxx
//
//  Contents:	File ILockBytes implementation for layout storage
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include "laylkb.hxx"
#include <valid.h>
#include <dfver.h>


class CSafeCriticalSection
{
public:
    inline CSafeCriticalSection(CRITICAL_SECTION *pcs);
    inline ~CSafeCriticalSection();
private:
    CRITICAL_SECTION *_pcs;
};

inline CSafeCriticalSection::CSafeCriticalSection(CRITICAL_SECTION *pcs)
{
    _pcs = pcs;
    EnterCriticalSection(_pcs);
}

inline CSafeCriticalSection::~CSafeCriticalSection()
{
    LeaveCriticalSection(_pcs);
#if DBG == 1
    _pcs = NULL;
#endif
}

#define TAKE_CS CSafeCriticalSection scs(&_cs);
    


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::CLayoutLockBytes, public
//
//  Synopsis:	Default constructor
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

CLayoutLockBytes::CLayoutLockBytes(void)
{
    _cReferences = 1;
    _h = INVALID_HANDLE_VALUE;
    _hScript = INVALID_HANDLE_VALUE;
    _fLogging = FALSE;
    _cbSectorShift = 0;
    _atcScriptName[0] = TEXT('\0');
    _awcName[0] = L'\0';
    _fCSInitialized = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::~CLayoutLockBytes, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	20-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

CLayoutLockBytes::~CLayoutLockBytes()
{
    if (_h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_h);
        _h = INVALID_HANDLE_VALUE;
    }
    if (_hScript != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hScript);
        _hScript = INVALID_HANDLE_VALUE;
    }

    if (_fCSInitialized)
        DeleteCriticalSection(&_cs);
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Init, public
//
//  Synopsis:	Initialization function
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CLayoutLockBytes::Init(OLECHAR const *pwcsName,
                             DWORD grfMode)
{
    SCODE sc = S_OK;
    BYTE abHeader[sizeof(CMSFHeaderData)];
    ULONG cbRead;

    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Init:%p()\n", this));
    
    if (pwcsName == NULL)
        return STG_E_INVALIDNAME;

    if (FALSE == _fCSInitialized)
    {
        __try
        {
            InitializeCriticalSection(&_cs);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return HRESULT_FROM_WIN32( GetExceptionCode() );
        }

        _fCSInitialized = TRUE;
    }

    _grfMode = grfMode;

#ifndef UNICODE
    TCHAR atcPath[MAX_PATH + 1];
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!WideCharToMultiByte(
        uCodePage,
        0,
        pwcsName,
        -1,
        atcPath,
        MAX_PATH + 1,
        NULL,
        NULL))
    {
        return STG_E_INVALIDNAME;
    }

    _h = CreateFileA(atcPath,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING,                   
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);
#else    
    _h = CreateFile(pwcsName,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING,                   
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);
#endif    
  
    if (_h == INVALID_HANDLE_VALUE)
    {
        layErr(Err, Win32ErrorToScode(GetLastError()));
    }

    lstrcpyW(_awcName, pwcsName);

    //Get the sector size
    boolChk(ReadFile(_h, abHeader, sizeof(CMSFHeaderData), &cbRead, NULL));
    if (cbRead != sizeof(CMSFHeaderData))
    {
        return STG_E_READFAULT;
    }
    
    _cbSectorShift = ((CMSFHeaderData *)abHeader)->_uSectorShift;

    if (((CMSFHeaderData*)abHeader)->_uDllVersion > rmjlarge)
        return STG_E_OLDDLL;

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Init\n"));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CLayoutLockBytes::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::QueryInterface(?, %p)\n",
                 ppvObj));
    
    layChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;

    sc = S_OK;
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IUnknown *)this;
        CLayoutLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_ILockBytes))
    {
        *ppvObj = (ILockBytes *)this;
        CLayoutLockBytes::AddRef();
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::QueryInterface => %p\n",
                 ppvObj));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CLayoutLockBytes::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutLockBytes::AddRef(void)
{
    ULONG ulRet;

    layDebugOut((DEB_TRACE, "In  CLayoutLockBytes::AddRef()\n"));

    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;

    layDebugOut((DEB_TRACE, "Out CLayoutLockBytes::AddRef\n"));
    return ulRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Release, public
//
//  History:	20-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutLockBytes::Release(void)
{
    LONG lRet;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
    {
        lRet = 0;
    }
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Release\n"));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::ReadAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::ReadAt(ULARGE_INTEGER ulOffset,
                                      VOID HUGEP *pv,
                                      ULONG cb,
                                      ULONG *pcbRead)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::ReadAt:%p()\n", this));

    ULONG ulLow = ulOffset.LowPart;
    LONG lHigh = (LONG)ulOffset.HighPart;

    if ((_fLogging)&&(ulOffset.QuadPart >= sizeof(CMSFHeaderData)))
    {
        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return STG_E_INVALIDHANDLE;
        }

        ULONG ulFirstSector = (ULONG) ((ulOffset.QuadPart -
                                       (1 << _cbSectorShift))
                                       >> _cbSectorShift);
        
        ULONG ulLastSector = (ULONG) ((ulOffset.QuadPart + (cb - 1) -
                                      (1 << _cbSectorShift)) 
                                      >> _cbSectorShift);
        ULONG ulSect;
        ULONG cbScriptWritten;

        for (ulSect = ulFirstSector; ulSect <= ulLastSector; ulSect++)
        {
            
            layAssert(_hScript !=INVALID_HANDLE_VALUE);

            boolChk(WriteFile(_hScript,
                              (VOID *)&ulSect,
                              sizeof(ULONG),
                              &cbScriptWritten,
                              NULL));


            if (cbScriptWritten != sizeof(ULONG))
            {
                return STG_E_WRITEFAULT;
            }
        }    
    }

    negChk(SetFilePointer(_h,
                          ulLow,
                          &lHigh,
                          FILE_BEGIN));
    boolChk(ReadFile(_h, pv, cb, pcbRead, NULL));
    
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::ReadAt\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::WriteAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::WriteAt(ULARGE_INTEGER ulOffset,
                                       VOID const HUGEP *pv,
                                       ULONG cb,
                                       ULONG *pcbWritten)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::WriteAt:%p()\n", this));

    ULONG ulLow = ulOffset.LowPart;
    LONG lHigh = (LONG)ulOffset.HighPart;

    if ((_fLogging)&&(ulOffset.QuadPart >= sizeof(CMSFHeaderData)))
    {
        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return STG_E_INVALIDHANDLE;
        }

        ULONG ulFirstSector = (ULONG) ((ulOffset.QuadPart -
                                       (1 << _cbSectorShift))
                                       >> _cbSectorShift);
        ULONG ulLastSector = (ULONG) ((ulOffset.QuadPart + (cb - 1) -
                                      (1 << _cbSectorShift)) 
                                      >> _cbSectorShift);
        ULONG ulSect;
        ULONG cbScriptWritten;

        for (ulSect = ulFirstSector; ulSect <= ulLastSector; ulSect++)
        {
            boolChk(WriteFile(_hScript,
                              (VOID *)&ulSect,
                              sizeof(ULONG),
                              &cbScriptWritten,
                              NULL));
            if (cbScriptWritten != sizeof(ULONG))
            {
                return STG_E_WRITEFAULT;
            }
        }    
    }
    
    negChk(SetFilePointer(_h,
                          ulLow,
                          &lHigh,
                          FILE_BEGIN));
    boolChk(WriteFile(_h, pv, cb, pcbWritten, NULL));
    
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::WriteAt\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Flush, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::Flush(void)
{
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Flush:%p()\n", this));
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Flush\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::SetSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::SetSize(ULARGE_INTEGER cb)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::SetSize:%p()\n", this));
    LONG lHigh = (LONG)cb.HighPart;
    ULONG ulLow = cb.LowPart;

    negChk(SetFilePointer(_h, ulLow, &lHigh, FILE_BEGIN));
    boolChk(SetEndOfFile(_h));
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::SetSize\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::LockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::LockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::LockRegion:%p()\n", this));
    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    boolChk(LockFile(_h,
                     libOffset.LowPart,
                     libOffset.HighPart,
                     cb.LowPart,
                     cb.HighPart));
            
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::LockRegion\n"));
Err:    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::UnlockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::UnlockRegion(ULARGE_INTEGER libOffset,
                                            ULARGE_INTEGER cb,
                                            DWORD dwLockType)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::UnlockRegion:%p()\n", this));
    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    boolChk(UnlockFile(_h,
                       libOffset.LowPart,
                       libOffset.HighPart,
                       cb.LowPart,
                       cb.HighPart));
            
    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::UnlockRegion\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::Stat, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    CSafeCriticalSection scs(&_cs);
    
    SCODE sc;

    layDebugOut((DEB_ITRACE, "In  CLayoutLockBytes::Stat:%p()\n", this));

    negChk(pstatstg->cbSize.LowPart =
           GetFileSize(_h, &pstatstg->cbSize.HighPart));
    boolChk(GetFileTime(_h, &pstatstg->ctime, &pstatstg->atime,
                        &pstatstg->mtime));
    pstatstg->grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;
    
    pstatstg->type = STGTY_LOCKBYTES;
    pstatstg->grfMode = _grfMode;
    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        pstatstg->pwcsName = (OLECHAR *)CoTaskMemAlloc(
             (lstrlenW(_awcName) + 1) * sizeof(OLECHAR));
        if (pstatstg->pwcsName == NULL)
            return STG_E_INSUFFICIENTMEMORY;
        lstrcpyW(pstatstg->pwcsName, _awcName);
    }
    sc = S_OK;

    layDebugOut((DEB_ITRACE, "Out CLayoutLockBytes::Stat\n"));
    return NOERROR;

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::StartLogging, public
//
//  Returns:	Appropriate status code
//
//  Modifies:	_fLogging
//
//  History:	24-Feb-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CLayoutLockBytes::StartLogging(void)
{
    CSafeCriticalSection scs(&_cs);
    
    OLECHAR acTempPathName[MAX_PATH + 1];
    SCODE sc = S_OK;

    if (_fLogging)
    {
        return STG_E_INUSE;                   //logging already started!
    }
    

    if (_atcScriptName[0] != TEXT('\0'))
    {
        LONG dwDistanceToMoveHigh = 0;
        
        //Script has already been started.  Need to reopen it and seek
        //  to the end.
#ifndef UNICODE
        _hScript = CreateFileA
#else
        _hScript = CreateFile
#endif        
                   (_atcScriptName,
                    GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);

        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return LAST_STG_SCODE;
        }
        
        negChk(SetFilePointer(_hScript, 0, &dwDistanceToMoveHigh, FILE_END));
    }
    else
    {
        TCHAR atcPath[MAX_PATH + 1];
        //Generate the script name, then create it.
        
        boolChk(GetTempPath(MAX_PATH, atcPath));
        boolChk(GetTempFileName(atcPath, TEXT("SCR"), 0, _atcScriptName));
        
        //GetTempFileName actually creates the file, so we open with
        //  OPEN_EXISTING
#ifndef UNICODE
        _hScript = CreateFileA
#else
        _hScript = CreateFile
#endif        
                   (_atcScriptName,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    OPEN_EXISTING, 
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);

        if (_hScript == INVALID_HANDLE_VALUE)
        {
            return LAST_STG_SCODE;
        }
    }
    
    _fLogging = TRUE;

Err:
    return sc; 		
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutLockBytes::StopLogging, public
//
//  Returns:	Appropriate status code
//
//  Modifies:	_fLogging
//
//  History:	24-Feb-96	SusiA	Created
//
//  Notes:	
//
//-----------------------------------------------------------------------------
SCODE CLayoutLockBytes::StopLogging(void)
{
    SCODE sc = S_OK;
    CSafeCriticalSection scs(&_cs);
    
    if (!_fLogging)
    {
        return STG_E_UNKNOWN;
    }
    
    boolChk(CloseHandle(_hScript));
    _hScript = INVALID_HANDLE_VALUE; 
    _fLogging = FALSE;

Err:
    return sc; 		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\layout.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layout.cxx
//
//  Contents:	Code for the relayout tool
//
//  Classes:	
//
//  Functions:	
//
//  History:	12-Feb-96	PhilipLa	Created
//              21-Feb-96       SusiA           Put funtions on ILayoutStorage
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include <dirfunc.hxx>
#include "laylkb.hxx"
#include "laywrap.hxx"

#include <stddef.h>

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::LayoutScript
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pStorageLayout] -- Pointer to storage layout array
//              [nEntries] -- Number of entries in the array
//              [grfInterleavedFlag] -- Specifies disposition of control
//                                      structures
//
//  Returns:	Appropriate status code
//
//  History:	21-Feb-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::LayoutScript( StorageLayout  *pStorageLayout,
                                               DWORD nEntries,
                                               DWORD glfInterleavedFlag)
{

    SCODE sc;

    if ((LONG)nEntries < 0)
    {
        return E_INVALIDARG;
    }
    
    if ((LONG)nEntries == 0)
    {
        return  S_OK;
    }
    
    if ((glfInterleavedFlag != STG_LAYOUT_INTERLEAVED) &&
        (glfInterleavedFlag != STG_LAYOUT_SEQUENTIAL )   )
    {    
        return STG_E_INVALIDFLAG;
    }

    if (IsBadWritePtr( pStorageLayout, nEntries * sizeof(StorageLayout)))
    {   
        return STG_E_INVALIDPOINTER;
    }

    if (FAILED(sc = BeginMonitor()))
    {
        return sc;
    }
    
    if (FAILED(sc = ProcessLayout(pStorageLayout,
                                  nEntries,
                                  glfInterleavedFlag)))
    {
        // ignore errors from EndMonitor
        EndMonitor();
        return sc;
    }

    if (FAILED(sc = EndMonitor()))
    {
        return sc;
    }

    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::BeginMonitor
//
//  Synopsis:	Begin monitoring the ILockBytes operations for recording a
//              script.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	21-Feb-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::BeginMonitor(void)
{
    SCODE sc = S_OK;
    sc = _pllkb->StartLogging();
    return ResultFromScode(sc);   		

}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::EndMonitor
//
//  Synopsis:	Stop monitoring ILockBytes operations for script recording.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	21-Feb-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::EndMonitor(void)
{
    SCODE sc = S_OK;
    sc =  _pllkb->StopLogging();
    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ReLayoutDocfile
//
//  Synopsis:   Relayout the docfile into the new name specified.
//
//  Arguments:	[pwcsNewName] -- Name of destination file
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//      	21-Feb-96       SusiA           Made a method on ILayoutStorage
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::ReLayoutDocfile(OLECHAR *pwcsNewDfName)
{
    SCODE sc;

#if (!defined(UNICODE) && (!defined(_MAC)))

    WCHAR awcScriptName[MAX_PATH + 1];

	
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!MultiByteToWideChar(
        uCodePage,
        0,
        _pllkb->GetScriptName(),
        -1,
        awcScriptName,
        MAX_PATH + 1
        ))
    {
        return STG_E_INVALIDNAME;
    }
    sc = StgLayoutDocfile(_pllkb->GetHandle(),
                          pwcsNewDfName,
                          awcScriptName);
#else 
    
    
    sc = StgLayoutDocfile(_pllkb->GetHandle(),
                          pwcsNewDfName,
                          _pllkb->GetScriptName());
#endif //UNICODE

    if (FAILED(sc))
    {
        //Delete new file
#ifdef UNICODE        
        DeleteFileW(pwcsNewDfName);
#elif defined( _MAC)
        DeleteFile(pwcsNewDfName);
#else
		
        TCHAR atcPath[MAX_PATH + 1];

        UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

        //Note:  Intentionally ignore an error if it happens here.  We
        //  want to return the error from StgLayoutDocfile, not from
        //  the cleanup path.
        WideCharToMultiByte(
            uCodePage,
            0,
            pwcsNewDfName,
            -1,
            atcPath,
            _MAX_PATH + 1,
            NULL,
            NULL);
        DeleteFileA(atcPath);

#endif // UNICODE       
    }
    else
    {
        //Delete Script File
        DeleteFile(_pllkb->GetScriptName());
        //Note:  Intentionally ignore an error if it happens here.  We
        //  want to return the error from StgLayoutDocfile, not from
        //  the cleanup path.
        _pllkb->ClearScriptName();
            
    }
    return sc;
}

#if DBG == 1
STDMETHODIMP CLayoutRootStorage::GetScript(TCHAR **ptcsScriptFileName)
{
   
    *ptcsScriptFileName = _pllkb->GetScriptName();
    return S_OK;                                                                            
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ReLayoutDocfileOnILockBytes
//
//  Synopsis:   Relayout the docfile into a generic ILockBytes implementation.
//
//  Arguments:	[pILockBytes] -- destination relayout ILockBytes
//
//  Returns:	Appropriate status code
//
//  History:	09-Jun-96       SusiA           Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::ReLayoutDocfileOnILockBytes(ILockBytes *pILockBytes)
{
    return STG_E_UNIMPLEMENTEDFUNCTION;
}

//+---------------------------------------------------------------------------
//
//  Function:	StgLayoutDocfile
//
//  Synopsis:	Given an old file and an unprocessed script, relayout the
//              docfile into the new name specified.
//
//  Arguments:	[hOld] -- Handle of source file
//              [pwcsNewDfName] -- Name of destination file
//              [pwcsScriptName] -- Name of unprocessed script file
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE StgLayoutDocfile(HANDLE hOld,
                       OLECHAR const *pwcsNewDfName,
                       OLECHAR const *pwcsScriptName)
{
    SCODE sc = S_OK;
    CMappedFile mfOld, mfNew, mfScript;
    MAPFILE *pvOld, *pvNew, *pvScript;
    ULONG ulScriptSize;
    ULONG csectScript, csectProcessed, csectFile;
    ULONG cbSectorSize;
    ULONG i;
    
    SECT *psProcessedScript = NULL;
   
    if (pwcsNewDfName == NULL)
        return STG_E_INVALIDNAME;

#ifdef _MAC
    layChkTo(EH_End, mfOld.InitFromHandle(hOld,
                                          GENERIC_READ, 
                                          FALSE,
                                          NULL));
#else
    layChkTo(EH_End, mfOld.InitFromHandle(hOld,
                                          GENERIC_READ, 
                                          TRUE,
                                          NULL));
#endif
    layChkTo(EH_End, mfNew.Init(pwcsNewDfName,
                                mfOld.GetSize(),
                                GENERIC_READ | GENERIC_WRITE,
                                CREATE_ALWAYS,
                                NULL));

    
    if ((pwcsScriptName !=NULL)          && 
        (pwcsScriptName[0] != TEXT('\0'))   )
    {
        sc = mfScript.Init(pwcsScriptName,
                           0,
                           GENERIC_READ,
                           OPEN_EXISTING,
                           NULL);
        layChkTo(EH_End, sc);

        if (sc == STG_S_FILEEMPTY)
        {
            pvScript = NULL;
        }
        else 
        {
            pvScript = &mfScript;
        }
    }
    else
    {
        pvScript = NULL;
    }

    pvOld = &mfOld;
    pvNew = &mfNew;

    
    //From this point on, we may get an exception while we're poking around
    //  in one of the memory maps.  We need to handle this case and be able
    //  to properly return an error and clean up if it happens.

#ifndef _MAC
    __try
        {
#endif
            //Figure out how many sectors are in the file
            cbSectorSize = 1 << pvOld->GetUSHORT(
                (ULONG) offsetof(CMSFHeaderData,_uSectorShift));
            pvOld->SetSectorSize(cbSectorSize);
            pvNew->SetSectorSize(cbSectorSize);
		
            const ULONG cbHeader = cbSectorSize;
            csectFile = (mfOld.GetSize() + cbSectorSize - 1 -
                         cbHeader) / cbSectorSize;

            SECT sectRangeLocks = (OLOCKREGIONEND - cbHeader + cbSectorSize - 1)
                                   / cbSectorSize;

            if (pvScript)
            {   
                ulScriptSize = mfScript.GetSize();
            }
            else
            {
                ulScriptSize = 0;
            }

            csectProcessed = max(ulScriptSize / sizeof(SECT), csectFile);
            layMem(psProcessedScript = new SECT[csectProcessed]);

            for (i = 0; i < csectProcessed; i++)
            {
                psProcessedScript[i] = ENDOFCHAIN;
            }
    
            ULONG csectControl;
            layChk(ProcessControl(psProcessedScript,
                                  pvOld,
                                  &csectControl));
           
            layChk(ProcessScript(psProcessedScript,
                                 pvScript,
                                 csectFile,
                                 ulScriptSize / sizeof(SECT),
                                 csectControl,
                                 sectRangeLocks,
                                 &csectScript));

            //layAssert(csectScript == csectFile);

            layChk(CopyData(pvNew,
                            pvOld,
                            psProcessedScript,
                            csectFile,
                            cbSectorSize));

            layChk(RemapHeader(pvNew, psProcessedScript, csectFile));
            layChk(RemapDIF(pvNew, psProcessedScript, csectFile, cbSectorSize));
            layChk(RemapFat(pvNew,
                            pvOld,
                            psProcessedScript,
                            csectFile,
                            cbSectorSize));
            layChk(RemapDirectory(pvNew,
                                  psProcessedScript,
                                  csectFile,
                                  cbSectorSize));
        Err:
            delete psProcessedScript;

#ifndef _MAC
	}
    
    __except (EXCEPTION_EXECUTE_HANDLER)
        {
            sc = LAST_STG_SCODE;
        }
#endif

    pvOld = NULL;
    pvNew = NULL;

	 
EH_End:    
    return sc; 		
}


//+---------------------------------------------------------------------------
//
//  Function:	GetDIFSect
//
//  Synopsis:	Return a pointer to the appropriate sector in the DIF
//
//  Arguments:	[pvBase] -- Pointer to base address of memory mapped file
//              [iDIF] -- Index into DIF desired
//              [cbSectorSize] -- Size in bytes of sector
//
//  Returns:	Pointer to appropriate sector
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFatSect * GetDIFSect(MAPFILE *pvBase,
                      ULONG iDIF,
                      ULONG cbSectorSize,
                      SECT *psect)
{
    USHORT cSectPerFat = (USHORT)(cbSectorSize / sizeof(SECT));
    SECT sectDif = pvBase->GetULONG(
        (ULONG) offsetof(CMSFHeaderData,_sectDifStart));


    for (ULONG i = 0; i < iDIF; i++)
    {
        CFatSect  *pdif = pvBase->GetCFatSect((sectDif * cbSectorSize) +
                                              cbSectorSize);
		
        sectDif = pdif->GetSect(cSectPerFat - 1);
		
        pvBase->Remove(pdif);
    }

    if (psect)
    {
        *psect = sectDif;
    }
    return pvBase->GetCFatSect((sectDif * cbSectorSize) +
                               cbSectorSize);
}



//+---------------------------------------------------------------------------
//
//  Function:	GetFatSect
//
//  Synopsis:	Return a pointer to the appropriate sector in the fat
//
//  Arguments:	[pvBase] -- Pointer to base address of memory mapped file
//              [iFat] -- Index into fat desired
//              [cbSectorSize] -- Size in bytes of sector
//
//  Returns:	Pointer to appropriate sector
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFatSect *GetFatSect(MAPFILE *pvBase,
                     ULONG iFat,
                     ULONG cbSectorSize,
                     SECT *psect)
{
    SECT sectFat;
    
    if (iFat < CSECTFAT)
    {
        //Fatsect can be found in header
        sectFat = pvBase->GetULONG(
            (ULONG) offsetof(CMSFHeaderData,_sectFat[iFat]));
    }
    else
    {
        ULONG cFatPerDif = (cbSectorSize / sizeof(SECT)) - 1;
        ULONG iDIF = (iFat - CSECTFAT) / cFatPerDif;
        USHORT oDIF = (USHORT)((iFat - CSECTFAT) % cFatPerDif);
        CFatSect *pDif = GetDIFSect(pvBase, iDIF, cbSectorSize, NULL);
        sectFat = pDif->GetSect(oDIF);

        pvBase->Remove(pDif);
    }

    CFatSect *pbFat = pvBase->GetCFatSect(
        (sectFat * cbSectorSize) + cbSectorSize);

    if (psect)
    {
        *psect = sectFat;
    }
    return (CFatSect *)pbFat;
}



//+---------------------------------------------------------------------------
//
//  Function:	GetNext
//
//  Synopsis:	Given a sector, return the next sector in the fat chain
//
//  Arguments:	[pvBase] -- Pointer to base address of memory mapped file
//              [sect] -- Sect desired
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate SECT value
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SECT GetNext(MAPFILE *pvBase,
             SECT sect,
             ULONG cbSectorSize)
{
    SECT newsect;

    ULONG csectPerFat = cbSectorSize / sizeof(SECT);
    ULONG iFat = sect / csectPerFat;
    USHORT oFat = (USHORT)(sect % csectPerFat);
    CFatSect *pfs = GetFatSect(pvBase, iFat, cbSectorSize, NULL);
    
    newsect = pfs->GetSect(oFat);

    pvBase->Remove(pfs);

    return newsect;
}
            


//+---------------------------------------------------------------------------
//
//  Function:	ProcessControl, private
//
//  Synopsis:	Add control structures to processed script
//
//  Arguments:	[psProcessed] -- Pointer to processed script
//              [pvOld] -- Pointer to old file
//              [pcsectControl] -- Return location for total sectors processed
//
//  Returns:	Appropriate status code
//
//  History:	05-Mar-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE ProcessControl(SECT *psProcessed,
                     MAPFILE *pvOld,
                     ULONG *pcsectControl)
{
    SECT sectCurrent = 0;
    CMSFHeaderData *phdr = (CMSFHeaderData *)pvOld->GetCMSFHeaderData();

    ULONG csectDif, csectFat;
    ULONG cbSectorSize;

    csectDif = phdr->_csectDif;
    csectFat = phdr->_csectFat;
    cbSectorSize = 1 << phdr->_uSectorShift;

    //We want the structures in the following order:
    //1) Enough fat and DIFat sectors to hold themselves and all of the
    //    directory sectors.
    //2) All of the directory sectors
    //3) Everything else - the rest of the difat, the fat, and the minifat.

    //First find out how big the directory is
    SECT sectDir = phdr->_sectDirStart;
    ULONG csectDir = 0;
    while (sectDir != ENDOFCHAIN)
    {
        sectDir = GetNext(pvOld, sectDir, cbSectorSize);
        csectDir++;
    }

    //Now compute the number of fat sectors we need to hold the directory
    // plus the fat sectors themselves.
    ULONG csectFatNeeded = 0;
    ULONG csectDifNeeded = 0;
    ULONG csectNeededLast = 0;
    ULONG cfsSect = (cbSectorSize / sizeof(SECT));

    do
    {
        csectNeededLast = csectFatNeeded;
        csectFatNeeded = (csectFatNeeded + csectDifNeeded + csectDir +
                          cfsSect - 1) /
            cfsSect;
        if (csectFatNeeded > CSECTFAT)
        {
            csectDifNeeded = (csectFatNeeded - CSECTFAT + cfsSect - 2) /
                (cfsSect - 1);
        }
    }
    while (csectFatNeeded != csectNeededLast);

    //Now we know how many DIF, Fat, and Directory sectors we need.
    //Lay those out first.

    //For those of you keeping score, the docfile will need to have exactly
    //  csectFatNeeded + csectDifNeeded sectors downloaded before it can
    //  be opened.
    for (ULONG i = 0; i < csectDifNeeded; i++)
    {
        SECT sectDif;
        pvOld->Remove(GetDIFSect(pvOld, i, cbSectorSize, &sectDif));
        psProcessed[sectDif] = sectCurrent++;
    }

    for (i = 0; i < csectFatNeeded; i++)
    {
        SECT sectFat;

        pvOld->Remove(GetFatSect(pvOld, i, cbSectorSize, &sectFat));
        psProcessed[sectFat] = sectCurrent++;
    }
    sectDir = phdr->_sectDirStart;
    for (i = 0; i < csectDir; i++)
    {
        layAssert(sectDir != ENDOFCHAIN);
        psProcessed[sectDir] = sectCurrent++;
        sectDir = GetNext(pvOld, sectDir, cbSectorSize);
    }

    //Now put down everything else
    for (i = csectDifNeeded; i < csectDif; i++)
    {
        SECT sectDif;

        GetDIFSect(pvOld, i, cbSectorSize, &sectDif);
        pvOld->Remove(GetDIFSect(pvOld, i, cbSectorSize, &sectDif));
        psProcessed[sectDif] = sectCurrent++;
    }
    for (i = csectFatNeeded; i < csectFat; i++)
    {
        SECT sectFat;
        pvOld->Remove(GetFatSect(pvOld, i, cbSectorSize, &sectFat));
        psProcessed[sectFat] = sectCurrent++;
    }
    //Finally minifat
    SECT sectMiniFat = phdr->_sectMiniFatStart;
    while (sectMiniFat != ENDOFCHAIN)
    {
        psProcessed[sectMiniFat] = sectCurrent++;
        sectMiniFat = GetNext(pvOld, sectMiniFat, cbSectorSize);
    }
    
    *pcsectControl = sectCurrent;

    pvOld->Remove(phdr);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:	ProcessScript
//
//  Synopsis:	Given a list of sectors in order, construct a mapping
//              of old sector->new sector
//
//  Arguments:	[psProcessed] -- Pointer to destination buffer
//              [psOriginal] -- Pointer to source script buffer
//              [csectFile] -- Count of sectors in file
//              [csectOriginal] -- Count of entries in original script
//              [sectRangeLocks] -- sector containing docfile range locks
//              [pcsectProcessed] -- Return location for number of entries
//                                   in processed script
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE ProcessScript(SECT *psProcessed,
                    MAPFILE *psOriginal,
                    ULONG csectFile,
                    ULONG csectOriginal,
                    ULONG csectControl,
                    SECT  sectRangeLocks,
                    ULONG *pcsectProcessed)
{
    SCODE sc = S_OK;
#if DBG == 1    
    ULONG csectProcessed = 0;
#endif    
    ULONG cDuplicates = 0;
    ULONG cUnlisted = 0;
    
    for (ULONG i = 0; i < csectOriginal; i++)
    {
        SECT sectOld = (*psOriginal)[i];

        if (sectOld >= csectFile)
        {
            //Weird.  We're past the range of the file.
            return STG_E_UNKNOWN;
        }
        
#if DBG == 1            
        if (sectOld + 1> csectProcessed)
        {
            csectProcessed = sectOld + 1;
        }
#endif            

        if (psProcessed[sectOld] == ENDOFCHAIN)
        {
            psProcessed[sectOld] = i - cDuplicates + csectControl;
        }
        else
        {
            cDuplicates++;
        }
    }


    //Fill in holes
    for (i = 0; i < csectFile; i++)
    {
        if (psProcessed[i] == ENDOFCHAIN)
        {
            SECT sectNew = csectOriginal - cDuplicates + csectControl +
                cUnlisted;
            if (sectNew == sectRangeLocks)  // skip over range locks
            {
                sectNew++;
                cUnlisted++;
            }
            psProcessed[i] = sectNew;
            cUnlisted++;
#if DBG == 1            
            if (sectNew + 1> csectProcessed)
            {
                csectProcessed = sectNew + 1;
            }
#endif            
        }
#if DBG == 1
        //If we have control structures at the end of the file that are
        //  not in the script anywhere (which may happen particularly often
        //  on files produced with simple mode), we want to make sure to
        //  update the count on those.  For retail builds, we don't really
        //  care about the count, so we can skip this.
        else if (psProcessed[i] + 1 > csectProcessed)
        {
            csectProcessed = psProcessed[i] + 1;
        }
#endif        
    }
       
#if DBG == 1
    for (i = 0; i < csectProcessed; i++)
    {
        layDebugOut((DEB_IERROR, "Script[%lu] = %lx\n", i, psProcessed[i]));
    }
#endif

#if DBG == 1    
    *pcsectProcessed = csectProcessed;
#else
    *pcsectProcessed = csectFile;
#endif
    
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Function:	CopyData
//
//  Synopsis:	Given an old->new mapping, copy data from old mapping to
//              new mapping
//
//  Arguments:	[pvNew] -- Pointer to destination mapped file
//              [pvOld] -- Pointer to source mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in the file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CopyData(MAPFILE *pvNew,
               MAPFILE *pvOld,
               SECT *psScript,
               ULONG csectFile,
               ULONG cbSectorSize)
{
    SCODE sc = S_OK;

#ifdef SUPPORT_FILE_MAPPING    
    BYTE *pbSrc, *pbDest;

    pbSrc = (BYTE *)(pvOld->GetBaseAddress());
    pbDest = (BYTE *)(pvNew->GetBaseAddress());
#endif    
    
    for (ULONG i = 0; i < csectFile; i++)
    {
#ifdef SUPPORT_FILE_MAPPING        
		
        BYTE *pbSrcStart = (BYTE *)pbSrc + (i * cbSectorSize) +
            cbSectorSize;
        BYTE *pbDestStart = (BYTE *)pbDest + (psScript[i] * cbSectorSize) +
            cbSectorSize;
        
        if ((pbSrc != NULL) && pbDest != NULL)
        {
            CopyMemory(pbDestStart, pbSrcStart, cbSectorSize);
        }
        else
#endif // SUPPORT_FILE_MAPPING        
        {
            BYTE *pbBuffer = (BYTE *) CoTaskMemAlloc(cbSectorSize);
            
            if (!pbBuffer)
            {
                return STG_E_INSUFFICIENTMEMORY;
            }
            
            if (S_OK == (sc = pvOld->ReadFromFile(pbBuffer, 
                                                  (i * cbSectorSize) +
                                                  cbSectorSize,
                                                  cbSectorSize )))
            {
                sc = pvNew->WriteToFile(pbBuffer, 
                                                 (psScript[i] * cbSectorSize) +
                                                 cbSectorSize, 
                                                 cbSectorSize );
            }
            
            
            CoTaskMemFree(pbBuffer);

            if (S_OK != sc)
            {
                return sc;
            }
        }
        

    }
    //Also the header.
#ifdef SUPPORT_FILE_MAPPING

    if ((pbSrc != NULL) && (pbDest != NULL))
    {
        CopyMemory(pbDest, pbSrc, sizeof(CMSFHeaderData));
    }
    else
#endif
    {
	
        BYTE *pbBuffer = (BYTE *) CoTaskMemAlloc(sizeof(CMSFHeaderData));
	
        if (!pbBuffer)
        {
            return STG_E_INSUFFICIENTMEMORY;
        }
	
        if (S_OK == (sc = pvOld->ReadFromFile( pbBuffer, 
                                               0,
                                               sizeof(CMSFHeaderData) )))
        {
            sc = pvNew->WriteToFile( pbBuffer, 
                                              0, 
                                              sizeof(CMSFHeaderData) );
        }
        
        

        CoTaskMemFree(pbBuffer);

        if (S_OK != sc)
        {
            return sc;
        }
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapHeader
//
//  Synopsis:	Remap the docfile header using a processed script
//
//  Arguments:	[pvNew] -- Pointer to base of memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE RemapHeader(MAPFILE *pvNew, SECT *psScript, ULONG csectFile)
{

    SCODE sc = S_OK;

    CMSFHeaderData *ph = (CMSFHeaderData *)pvNew->GetCMSFHeaderData();

    //Directory start will never be EOC

    ph->_sectDirStart = psScript[ph->_sectDirStart];

    if (ph->_sectMiniFatStart != ENDOFCHAIN)
        ph->_sectMiniFatStart = psScript[ph->_sectMiniFatStart];

    if (ph->_sectDifStart != ENDOFCHAIN)
        ph->_sectDifStart = psScript[ph->_sectDifStart];

    for (ULONG i = 0; i < CSECTFAT; i++)
    {
        if (ph->_sectFat[i] != FREESECT)
        {
            ph->_sectFat[i] = psScript[ph->_sectFat[i]];
        }
    }

    sc = pvNew->WriteToFile(ph);
    pvNew->Remove(ph);
    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapDIF
//
//  Synopsis:	Remap the DIF according to a processed script
//
//  Arguments:	[pvNew] -- Pointer to base of memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE RemapDIF(MAPFILE *pvNew,
               SECT *psScript,
               ULONG csectFile,
               ULONG cbSectorSize)
{
    CMSFHeaderData *ph = (CMSFHeaderData *)pvNew->GetCMSFHeaderData();

    SCODE sc = S_OK;

    CFatSect *pfs = NULL;
    USHORT csectPerDif = (USHORT)(cbSectorSize / sizeof(SECT));
    SECT sectDif = ph->_sectDifStart;

    for (ULONG i = 0; i < ph->_csectDif; i++)
    {

        pfs = pvNew->GetCFatSect((sectDif * cbSectorSize) +
                                 cbSectorSize    );

        for (USHORT j = 0; j < csectPerDif; j++)
        {
            SECT sectOld = pfs->GetSect(j);
            
            if ((sectOld != FREESECT) &&
                (sectOld != ENDOFCHAIN))
            {
                pfs->SetSect(j, psScript[sectOld]);
            }
        }

        sectDif = pfs->GetNextFat(csectPerDif - 1);

        sc = pvNew->WriteToFile(pfs);
        pvNew->Remove(pfs);

    }

    pvNew->Remove(ph);
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapFat
//
//  Synopsis:	Remap the Fat according to a processed script and the original
//              file
//
//  Arguments:	[pvNew] -- Pointer to base of destination memory mapped file
//              [pvOld] -- Pointer to base of source memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//  Notes:	Since the processed script does not contain information
//              about individual fat chains, we need the old file in order
//              to construct the new fat.
//
//----------------------------------------------------------------------------

SCODE RemapFat(MAPFILE *pvNew,
               MAPFILE *pvOld,
               SECT *psScript,
               ULONG csectFile,
               ULONG cbSectorSize)
{
    CFatSect *pfsNew;
    CFatSect *pfsOld;

    SCODE sc = S_OK;

    ULONG csectFat = pvNew->GetULONG(
        (ULONG) offsetof(CMSFHeaderData, _csectFat));

    USHORT csectPerFat = (USHORT)(cbSectorSize / sizeof(SECT));

    for (ULONG i = 0; i < csectFat; i++)
    {
        pfsNew = GetFatSect(pvNew, i, cbSectorSize, NULL);
        memset(pfsNew, 0xFF, cbSectorSize);

        sc = pvNew->WriteToFile(pfsNew);
        if (sc != S_OK)
        {
            return sc;
        }
        pvNew->Remove(pfsNew);
    }

    for (i = 0; i < csectFat; i++)
    {
        pfsOld = GetFatSect(pvOld, i, cbSectorSize, NULL);

        for (USHORT j = 0; j < csectPerFat; j++)
        {
            if (i * csectPerFat + j >= csectFile)
            {
                //Sector outside of current file size - no remapping
                //is necessary, and sector has already been marked
                //as free above.
                break;
            }
            
            SECT sectOld = pfsOld->GetSect(j);
            SECT sectNew = psScript[i * csectPerFat + j];
            ULONG iFatNew = sectNew / csectPerFat;
            USHORT oFatNew = (USHORT)(sectNew % csectPerFat);
            
            CFatSect *pfsNew = GetFatSect(pvNew, iFatNew, cbSectorSize, NULL);
            
            if (sectOld > MAXREGSECT)
            {
                pfsNew->SetSect(oFatNew, sectOld);
            }
            else
            {
                //Need to map contents.
                SECT sectMap = psScript[sectOld];
                pfsNew->SetSect(oFatNew, sectMap);
            }
            sc = pvNew->WriteToFile(pfsNew);
            pvNew->Remove(pfsNew);
        }

        pvOld->Remove(pfsOld);
    }
    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	RemapDirectory
//
//  Synopsis:	Remap a directory based on a processed script
//
//  Arguments:	[pvNew] -- Pointer to base of memory mapped file
//              [psScript] -- Pointer to processed script
//              [csectFile] -- Count of sectors in file
//              [cbSectorSize] -- Sector size in bytes
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE RemapDirectory(MAPFILE *pvNew,
                     SECT *psScript,
                     ULONG csectFile,
                     ULONG cbSectorSize)
{
    CMSFHeaderData *ph = (CMSFHeaderData *)pvNew->GetCMSFHeaderData();

    SCODE sc = S_OK;

    USHORT csectPerFat = (USHORT)(cbSectorSize / sizeof(SECT));
    USHORT cEntryPerSect = (USHORT)(cbSectorSize / sizeof(CDirEntry));
    SECT sectDir = ph->_sectDirStart;

    while (sectDir != ENDOFCHAIN)
    {
        CDirSect *pds = pvNew->GetCDirSect((sectDir * cbSectorSize) +
                                           cbSectorSize   );

        for (USHORT i = 0; i < cEntryPerSect; i++)
        {
            CDirEntry *pde = pds->GetEntry(i);

            if (STREAMLIKE(pde->GetFlags()))
            {
                SECT sectOld = (ULONG) pde->GetStart();
#ifdef LARGE_STREAMS
                ULONGLONG ulSize = pde->GetSize(cbSectorSize > 512);
#else
                ULONG ulSize = pde->GetSize();
#endif
                swap ((char *) &sectOld, sizeof(SECT));
                swap ((char *) &ulSize, sizeof(ulSize));
				
				            
                if ((ulSize >= ph->_ulMiniSectorCutoff) ||
                    (pde->GetFlags() == STGTY_ROOT))
                {
                    if ((sectOld != ENDOFCHAIN) && (sectOld != FREESECT))
                    {
                        SECT sectNew = psScript[sectOld];
                        swap ((char *) &sectNew, sizeof(SECT));
                        pde->SetStart(sectNew);
                    }
                }
            }
        }
        sectDir = GetNext(pvNew, sectDir, cbSectorSize);

        sc = pvNew->WriteToFile(pds);
        pvNew->Remove(pds);
    }
    pvNew->Remove(ph);
        
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\layscrpt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layscrpt.cxx
//
//  Contents:	Code for  the LayoutScript method
//
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include <dirfunc.hxx>
#include "layout.hxx"
#include "laylkb.hxx"
#include "laywrap.hxx"

#define NULL_TERM               L'\0'
#define BACKSLASH               L'\\'
#define MAX_BUFFER              0x10000

//#define UNIT_TEST     


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::FreeStmList
//
//  Synopsis:	Free the stream linked list
//
//  Arguments:	[pStmList] -- Pointer STREAMLIST node
//
//----------------------------------------------------------------------------

void  CLayoutRootStorage::FreeStmList( STREAMLIST *pStmList)
{
    STREAMLIST *ptmp = pStmList;

    while (pStmList)
    {
        ptmp = pStmList->pnext;

#ifdef UNIT_TEST     
        wprintf(L"STGTY_STREAM    %ls\n", pStmList->pwcsStmName );
#endif        
        CoTaskMemFree(pStmList->pwcsStmName);
        pStmList->pStm->Release();
        delete pStmList;
        
        pStmList = ptmp;

    }


    
}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::FreeStgList
//
//  Synopsis:	Free the storage linked list
//
//  Arguments:	[pStgList] -- Pointer STORAGELIST node
//
//----------------------------------------------------------------------------

void  CLayoutRootStorage::FreeStgList( STORAGELIST *pStgList)
{
    STORAGELIST *ptmp;

    while (pStgList)
    {
        ptmp = pStgList->pnext;
#ifdef UNIT_TEST     
        wprintf(L"STGTY_STORAGE    %ls\n", pStgList->pwcsStgName );
#endif

        CoTaskMemFree(pStgList->pwcsStgName);
        pStgList->pStg->Release();
        delete pStgList;

        pStgList = ptmp;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessOpen
//
//  Synopsis:	Open the storage or stream
//
//  Arguments:	[pwcsElementPathName] -- full "path" name of element to open
//              [dwType] STGTY_STORAGE or STGTY_STREAM
//              [ppIstgStm] interface pointer to the opened Storage or Stream
//              [cOffset]  offset of beginning of the read
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------

SCODE CLayoutRootStorage::ProcessOpen(OLECHAR *pwcsElementPathName, 
                                      DWORD dwType, 
                                      void **ppIStgStm,
                                      LARGE_INTEGER cOffset)
{    
    SCODE sc = S_OK;

    IStorage *pStgNew;
    IStream  *pStmNew;

    IStorage *pStg = this;

    STORAGELIST *pStgList;
    STREAMLIST  *pStmList;

    OLECHAR  *pwcsStg = pwcsElementPathName,
             *pwcsTemp = pwcsElementPathName;
    
    OLECHAR  *pwcsBuffer;

    if ( (!pwcsElementPathName) || (pwcsElementPathName[0] == NULL_TERM))
    {
        return STG_E_PATHNOTFOUND;
    }
   
    // process storage path
    while (1)
    {
        while ((*pwcsTemp) && (*pwcsTemp != BACKSLASH))
        { 
            pwcsTemp++;
        }

        pwcsBuffer = (OLECHAR *) CoTaskMemAlloc
                     ((INT)(pwcsTemp - pwcsElementPathName + 1) *
                      sizeof(OLECHAR) );
        
        if (!pwcsBuffer)
        {
            return STG_E_INSUFFICIENTMEMORY;   
        }
        
        lstrcpynW (pwcsBuffer, 
                  pwcsElementPathName,
                  (INT)(pwcsTemp - pwcsElementPathName + 1));

        pwcsBuffer[pwcsTemp - pwcsElementPathName] = NULL_TERM;

        if (!(*pwcsTemp))
        {
            //we are at the end, now handle leaf Storage or stream
            break;
        }

        pStgList = _pStgList;

        // see if this storage is already in the list
        while (pStgList)
        {
            if (!(lstrcmpW(pwcsBuffer, pStgList->pwcsStgName )))
            {
                break;
            }

            pStgList = pStgList->pnext;     
        }
        if (pStgList)
        {
            pStgNew = pStgList->pStg;
            CoTaskMemFree(pwcsBuffer);
        }
        else
        {
            sc = pStg->OpenStorage(pwcsBuffer+(pwcsStg-pwcsElementPathName),
                            NULL,
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL,
                            0,
                            &pStgNew);
            if (FAILED(sc))
            {
                CoTaskMemFree(pwcsBuffer);
                return sc;
            }
        
            // add the storage to the list    
            pStgList = _pStgList;
                
            if (NULL == (_pStgList = new STORAGELIST))
            {
                CoTaskMemFree(pwcsBuffer);
                pStgNew->Release();
                return STG_E_INSUFFICIENTMEMORY;
            }

            _pStgList->pwcsStgName = pwcsBuffer;
            _pStgList->pStg = pStgNew;
            _pStgList->pnext = pStgList;

        }

        pStg = pStgNew;
        pwcsStg = ++pwcsTemp;
    
    }
    
    //process leaf storage
    if (dwType == STGTY_STORAGE)
    {
        sc = pStg->OpenStorage(pwcsBuffer+(pwcsStg-pwcsElementPathName),
                            NULL,
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL,
                            0,
                            &pStgNew);
        if (FAILED(sc))
        {
            CoTaskMemFree(pwcsBuffer);
            return sc;
        }

        // add the storage to the list    
        pStgList = _pStgList;
                
        if (NULL == (_pStgList = new STORAGELIST))
        {
           CoTaskMemFree(pwcsBuffer);
           pStgNew->Release();
           return STG_E_INSUFFICIENTMEMORY;
        }

        _pStgList->pwcsStgName = pwcsBuffer;
        _pStgList->pStg = pStgNew;
        _pStgList->pnext = pStgList;

        *ppIStgStm = (void *) pStgNew;
    }
    //process leaf stream
    else 
    {
        sc = pStg->OpenStream(pwcsBuffer+(pwcsStg-pwcsElementPathName),
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        0,
                        &pStmNew);
                
        if (FAILED(sc))
        {
           CoTaskMemFree(pwcsBuffer); 
           return sc;
        }

        pStmList = _pStmList;

        if (NULL == (_pStmList = new STREAMLIST))
        {
           CoTaskMemFree(pwcsBuffer);
           pStmNew->Release();
           return STG_E_INSUFFICIENTMEMORY;
        }
        
        _pStmList->pwcsStmName = pwcsBuffer;
        _pStmList->pStm = pStmNew;
        _pStmList->fDone = FALSE;
        _pStmList->cOffset = cOffset;
        _pStmList->pnext = pStmList;
         
        *ppIStgStm = (void *) pStmNew; 
   }

   return sc;

}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessItem
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pLayoutItem] -- Pointer to a StorageLayout element of the array
//              [fStmDone] -- indicate whether the stream finished reading
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------

SCODE CLayoutRootStorage::ProcessItem( StorageLayout  *pLayoutItem, BOOL *fStmDone )
{
    SCODE sc = S_OK;

    STREAMLIST *pStmList = _pStmList;
    STORAGELIST *pStgList = _pStgList;
    IStorage *pStgNew;
    IStream *pStmNew;

    ULARGE_INTEGER libNewPosition;
    ULONG cbRead;

    BYTE abBuffer[MAX_BUFFER];  
    BYTE *pb = abBuffer;
    BOOL fBigBuffer = FALSE;

    *fStmDone = FALSE;

    if ((pLayoutItem->cOffset.QuadPart < 0) || (pLayoutItem->cBytes.QuadPart < 0))
    {
        return STG_E_INVALIDPARAMETER;
    }
    
    switch (pLayoutItem->LayoutType)
    {
        
        case STGTY_STORAGE:

#ifdef UNIT_TEST
            wprintf(L"STGTY_STORAGE    %ls      %lu%lu         %lu%lu\n", 
                  pLayoutItem->pwcsElementName,
                  pLayoutItem->cOffset.HighPart,
                  pLayoutItem->cOffset.LowPart,
                  pLayoutItem->cBytes.HighPart,
                  pLayoutItem->cBytes.LowPart);
#endif
           
            while (pStgList)
            {
                if (!(lstrcmpW(pLayoutItem->pwcsElementName,
                                pStgList->pwcsStgName )))
                {
                    break;
                }

                pStgList = pStgList->pnext;     
            }
            
            // if storage was not found in the list, open the storage
            // and add it to the list
            if (!pStgList)
            {
                sc = ProcessOpen(pLayoutItem->pwcsElementName, 
                            STGTY_STORAGE, 
                            (void **)&pStgNew,
                            pLayoutItem->cOffset);
                     
                if (FAILED(sc))
                {
                    // the application may try to open Storages 
                    // that do not really exist in the compound file,
                    // and we will let them try.
                    if (sc == STG_E_FILENOTFOUND)
                    {
                        return S_OK;
                    }
                    else
                    {
                        return sc;
                    }
                }
            
            }

            break;

        case STGTY_STREAM:    

#ifdef UNIT_TEST
            wprintf(L"STGTY_STREAM    %ls      %lu%lu         %lu%lu\n", 
                  pLayoutItem->pwcsElementName,
                  pLayoutItem->cOffset.HighPart,
                  pLayoutItem->cOffset.LowPart,
                  pLayoutItem->cBytes.HighPart,
                  pLayoutItem->cBytes.LowPart);
#endif
            
            while (pStmList)
            {
                if (!(lstrcmpW(pLayoutItem->pwcsElementName,
                                pStmList->pwcsStmName )))
                {
                    pStmNew = pStmList->pStm;
                    break;
                }
                pStmList = pStmList->pnext;     
            }
            
            // if stream was not found in the list, open the stream, 
            // and add it to the list
            if (pStmList)
            {
                if( pStmList->fDone )
                {
                    *fStmDone = TRUE;
                    return S_OK;
                }
            }
            else
            {
                
                sc = ProcessOpen(pLayoutItem->pwcsElementName, 
                                STGTY_STREAM, 
                                (void **)&pStmNew,
                                pLayoutItem->cOffset);
                
                if (FAILED(sc))
                {
                    // the application may try to open Streams 
                    // that do not really exist in the compound file,
                    // and we will let them try.
                    if (sc == STG_E_FILENOTFOUND)
                    {
                        return S_OK;
                    }
                    else
                    {
                        return sc;
                    }
                }

                pStmList = _pStmList;
                
            }

            // seek to the correct position
            
            sc = pStmNew->Seek(
                    pStmList->cOffset,
                    STREAM_SEEK_SET,	
                    &libNewPosition );
            
            if (FAILED(sc))
            {
               return sc;
            }

            // read the stream and update the script information

            if (pLayoutItem->cBytes.LowPart > MAX_BUFFER)
            {       
                if (NULL == (pb = (BYTE  *) CoTaskMemAlloc(pLayoutItem->cBytes.LowPart)) )
                {
                    return STG_E_INSUFFICIENTMEMORY;
                }
                fBigBuffer = TRUE;
            }
            sc = pStmNew->Read(pb, 
                    pLayoutItem->cBytes.LowPart,
                    &cbRead);

            if (fBigBuffer)
            {
                CoTaskMemFree(pb);
                fBigBuffer = FALSE;
                pb = abBuffer;
                
            }
    
            if (FAILED(sc))
            {
               return sc;
            }
            //we have reached the end of the stream, mark it as done
            if (cbRead < pLayoutItem->cBytes.LowPart)
            {
	        pStmList->fDone = TRUE;
            }
	    
            pStmList->cOffset.QuadPart += cbRead;
           
            break;
        
        
        default:
            // we just handle storages and stream types
            return  STG_E_INVALIDPARAMETER;

    }
    
    return sc;
   
}

//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessRepeatLoop
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pStorageLayout] -- Pointer to storage layout array
//              [nEntries] -- Number of entries in the array
//              [nRepeatStart] -- address of index of start of repeat loop
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------
SCODE CLayoutRootStorage::ProcessRepeatLoop( StorageLayout  *pStorageLayout,
                                DWORD nEntries,
                                int * nRepeatStart)
{
    SCODE       sc = S_OK;

    int         i,
                nLoopCount = 0, 
                nLoopTimes;
    
    BOOL        fDone = FALSE,
                fUntilDone;


    // Are we going to repeat until all streams are read to the end?
    if ((nLoopTimes = (LONG) pStorageLayout[*nRepeatStart].cBytes.LowPart) != STG_TOEND)
        fUntilDone = FALSE; 
    else
    {
        fUntilDone = TRUE;
        nLoopTimes =  1;
    }
    // finished when all streams are completely read, or we have
    // looped through the specified amount of times
    while ((!fDone)&&(nLoopCount < nLoopTimes))
    {
        if (!fUntilDone)
            nLoopCount ++;

        i = *nRepeatStart;
        fDone = TRUE;

        // STGTY_REPEAT with 0 bytes indicates the end of this repeat block
        while (!((pStorageLayout[++i].LayoutType == STGTY_REPEAT ) &&
                 (pStorageLayout[i].cBytes.QuadPart == 0)) )                               
        {
            if (i >= (LONG) nEntries)
            {
                return E_INVALIDARG;
            }
            
             // beginning of another repeat block    
            if (pStorageLayout[i].LayoutType == STGTY_REPEAT )
            {
                if ((pStorageLayout[i].pwcsElementName !=NULL) ||
                    (pStorageLayout[i].cOffset.QuadPart < 0) || 
                    (pStorageLayout[i].cBytes.QuadPart < 0) )
                {
                    return  STG_E_INVALIDPARAMETER;
                }
                layChk(ProcessRepeatLoop(pStorageLayout,
                                     nEntries,
                                     &i));
            }
                    
            else
            {
                 layChk(ProcessItem(&(pStorageLayout[i]), &fDone));                            
                   
            }
        }
     }   
     *nRepeatStart = i;

Err:

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:	CLayoutRootStorage::ProcessLayout
//
//  Synopsis:	Construct an unprocessed script from an app provided script
//
//  Arguments:	[pStorageLayout] -- Pointer to storage layout array
//              [nEntries] -- Number of entries in the array
//              [grfInterleavedFlag] -- Specifies disposition of control
//                                      structures
//
//  Returns:	Appropriate status code
//
//  History:	22-Apr-96       SusiA           Created
//
//----------------------------------------------------------------------------


SCODE CLayoutRootStorage::ProcessLayout( StorageLayout  *pStorageLayout,
                                DWORD nEntries,
                                DWORD glfInterleavedFlag)
{

    SCODE       sc = S_OK;
    int         i; 
	BOOL        fUnused;
    
    
    TCHAR       *patcScriptName = _pllkb->GetScriptName();

   
    for (i = 0; i < (LONG) nEntries; i++)
    {
            
        if (pStorageLayout[i].LayoutType == STGTY_REPEAT )
        {

            if (pStorageLayout[i].cBytes.QuadPart != 0)
            {
                if ((pStorageLayout[i].pwcsElementName !=NULL) ||
                    (pStorageLayout[i].cOffset.QuadPart < 0) || 
                    (pStorageLayout[i].cBytes.QuadPart < 0) )
                {
                    return  STG_E_INVALIDPARAMETER;
                }
                layChk(ProcessRepeatLoop(pStorageLayout,
                                     nEntries,
                                     &i));
            }
            else  //end repeat block with no matching beginning
            {
                sc = E_INVALIDARG;
                layChk(sc);

            }


        }
        else // (pStorageLayout[i].LayoutType == STGTY_REPEAT )
        {
            layChk(ProcessItem(&(pStorageLayout[i]), &fUnused));
        }
    }    

 
    

Err:
    if (_pStgList)
    {
        FreeStgList(_pStgList);
        _pStgList = NULL;
    }
    if (_pStmList)
    {
        FreeStmList(_pStmList);
        _pStmList = NULL;
    }
    return sc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\laywrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	laywrap.cxx
//
//  Contents:	IStorage wrapper for layout docfile
//
//  Classes:	
//
//  Functions:	
//
//  History:	14-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

#include "laywrap.hxx"
#include "layouter.hxx"

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::QueryInterface, public
//
//  History:	14-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    *ppvObj = NULL;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::QueryInterface:%p()\n", this));    
 
    if (IsEqualIID(iid, IID_IUnknown)) 
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IStorage))
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IRootStorage))
    {
        IRootStorage *prstg;
        if (FAILED(_pRealStg->QueryInterface(IID_IRootStorage,
                                             (void **) &prstg)))
        {
            return E_NOINTERFACE;
        }

        prstg->Release();
        
        *ppvObj = (IRootStorage *)this;
    }
    else if (IsEqualIID(iid, IID_ILayoutStorage))
    {
        *ppvObj = (ILayoutStorage *)this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
    {
        AddRef();
    }
    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::QueryInterface:%p()\n", this));    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::AddRef, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutRootStorage::AddRef(void)
{	
    ULONG ulRet;
    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::AddRef:%p()\n", this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::AddRef\n"));
    return ulRet;
	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Release, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CLayoutRootStorage::Release(void)
{
    LONG lRet;
    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Release\n"));
    return (ULONG)lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::CreateStream, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::CreateStream(OLECHAR const *pwcsName,
                                              DWORD grfMode,
                                              DWORD reserved1,
                                              DWORD reserved2,
                                              IStream **ppstm)
{
    SCODE sc;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::CreateStream:%p()\n", this));
    
    sc = _pRealStg->CreateStream(pwcsName,
                                 grfMode,
                                 reserved1,
                                 reserved2,
                                 ppstm);


    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::CreateStream:%p()\n", this));

    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::OpenStream, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::OpenStream(OLECHAR const *pwcsName,
                                            void *reserved1,
                                            DWORD grfMode,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::OpenStream:%p()\n", this));
    
    sc = _pRealStg->OpenStream(pwcsName,
                               reserved1,
                               grfMode,
                               reserved2,
                               ppstm);

    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::OpenStream:%p()\n", this));
    
    return ResultFromScode(sc);   		

}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::CreateStorage, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::CreateStorage(OLECHAR const *pwcsName,
                                               DWORD grfMode,
                                               DWORD reserved1,
                                               LPSTGSECURITY reserved2,
                                               IStorage **ppstg)
{
    SCODE sc = S_OK;
    
    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::CreateStorage:%p()\n", this));
  
    sc = _pRealStg->CreateStorage( pwcsName,
                                   grfMode,
                                   reserved1,
                                   reserved2,
                                   ppstg);
		
    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::CreateStorage:%p()\n", this));
    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::OpenStorage, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::OpenStorage(OLECHAR const *pwcsName,
                                             IStorage *pstgPriority,
                                             DWORD grfMode,
                                             SNB snbExclude,
                                             DWORD reserved,
                                             IStorage **ppstg)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::OpenStorage:%p()\n", this));
	
    sc = _pRealStg->OpenStorage(pwcsName,
                                pstgPriority,
                                grfMode,
                                snbExclude,
                                reserved,
                                ppstg);
		
    layDebugOut((DEB_ITRACE,
                 "Out  CLayoutRootStorage::OpenStorage:%p()\n", this));
    return ResultFromScode(sc);   		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::CopyTo, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::CopyTo(DWORD ciidExclude,
                                        IID const *rgiidExclude,
                                        SNB snbExclude,
                                        IStorage *pstgDest)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::CopyTo%p()\n", this));
   
    sc = _pRealStg->CopyTo(ciidExclude,
                           rgiidExclude,
                           snbExclude,
                           pstgDest);

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::CopyTo\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::MoveElementTo, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::MoveElementTo(OLECHAR const *lpszName,
                                               IStorage *pstgDest,
                                               OLECHAR const *lpszNewName,
                                               DWORD grfFlags)
{
    SCODE sc = S_OK;
	
    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::MoveElementTo%p()\n", this));
    
    sc = _pRealStg->MoveElementTo(lpszName,
                                  pstgDest,
                                  lpszNewName,
                                  grfFlags) ;

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::MoveElementTo\n"));
    
    return ResultFromScode(sc); 		
	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Commit, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::Commit(DWORD grfCommitFlags)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Commit%p()\n", this));
   
    sc = _pRealStg->Commit(grfCommitFlags);
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Commit\n"));	
    return ResultFromScode(sc); 		
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Revert, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::Revert(void)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Revert%p()\n", this));
   
    sc = _pRealStg->Revert();
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Revert\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::EnumElements, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::EnumElements(DWORD reserved1,
                                              void *reserved2,
                                              DWORD reserved3,
                                              IEnumSTATSTG **ppenm)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE,
                 "In  CLayoutRootStorage::EnumElements%p()\n", this));
   
    sc = _pRealStg->EnumElements(reserved1,
                                 reserved2,
                                 reserved3,
                                 ppenm);

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::EnumElements\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::DestroyElement, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::DestroyElement(OLECHAR const *pwcsName)
{
    SCODE sc = S_OK;
    
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::DestroyElement\n"));
    
    sc = _pRealStg->DestroyElement(pwcsName);
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::DestroyElement\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::RenameElement, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::RenameElement(OLECHAR const *pwcsOldName,
                                               OLECHAR const *pwcsNewName)
{
    SCODE sc = S_OK;

    sc = _pRealStg->RenameElement(pwcsOldName, pwcsNewName);
    
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::RenameElement\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SetElementTimes, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SetElementTimes(const OLECHAR *lpszName,
                                                 FILETIME const *pctime,
                                                 FILETIME const *patime,
                                                 FILETIME const *pmtime)
{
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::SetElementTimes\n"));

    sc = _pRealStg->SetElementTimes(lpszName,
                                    pctime,
                                    patime,
                                    pmtime);
		
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::SetElementTimes\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SetClass, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SetClass(REFCLSID clsid)
{
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::SetClass\n"));	
    
    sc = _pRealStg->SetClass(clsid);

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::SetClass\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SetStateBits, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SetStateBits(DWORD grfStateBits,
                                              DWORD grfMask)
{
    SCODE sc = S_OK;
    layDebugOut((DEB_ITRACE, "In CLayoutRootStorage::SetStateBits\n"));

    sc = _pRealStg->SetStateBits(grfStateBits, grfMask);
		
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::SetStateBits\n"));
    
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::Stat, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::Stat%p()\n", this));
   
    sc = _pRealStg->Stat( pstatstg,  grfStatFlag);
	
    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::Stat\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutRootStorage::SwitchToFile, public
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CLayoutRootStorage::SwitchToFile(OLECHAR *ptcsFile)
{
    SCODE sc = S_OK;
    IRootStorage *prstg;

    layDebugOut((DEB_ITRACE, "In  CLayoutRootStorage::%p()\n", this));

    layVerify(SUCCEEDED(_pRealStg->QueryInterface(IID_IRootStorage,
                                                  (void **) &prstg)));

    sc = prstg->SwitchToFile(ptcsFile);

    prstg->Release();

    layDebugOut((DEB_ITRACE, "Out CLayoutRootStorage::\n"));	
    return ResultFromScode(sc); 	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\mapfile.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	mapfile.cxx
//
//  Contents:	Mapped file class implementation
//
//  Classes:	
//
//  Functions:	
//
//  History:	12-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop

//#define TEST_MAPPING_LOWMEM

CMappedFile::~CMappedFile(void)
{
#ifdef SUPPORT_FILE_MAPPING
    if (_pbBase != NULL)
    {
        UnmapViewOfFile(_pbBase);
    }
    if (_hMapping != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hMapping);
    }
#endif
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMappedFile::InitFromHandle, public
//
//  Synopsis:	Initialize object based on file handle
//
//  Arguments:	[h] -- File handle
//              [fReadOnly] -- TRUE if mapping is to be read-only
//              [fDuplicate] -- TRUE if handle is to be duplicated
//              [pvDesiredBaseAddress] -- Desired address for mapping
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMappedFile::InitFromHandle(HANDLE h,
                                  BOOL fReadOnly,
                                  BOOL fDuplicate,
                                  void *pvDesiredBaseAddress)
{
    SCODE sc = S_OK;

    if (fDuplicate)
    {
        if (!DuplicateHandle(GetCurrentProcess(),
                             h,
                             GetCurrentProcess(),
                             &_hFile,
                             0,
                             TRUE,
                             DUPLICATE_SAME_ACCESS))
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }
    }
    else
    {
        _hFile = h;
    }
#ifdef SUPPORT_FILE_MAPPING

#ifndef UNICODE
    _hMapping = CreateFileMappingA
#else
    _hMapping = CreateFileMapping
#endif
                 (_hFile,
                  NULL, // No security
                  (fReadOnly) ? PAGE_READONLY : PAGE_READWRITE,
                  0,
                  0, //File size determines map size
                  NULL); // Unnamed

#ifdef TEST_MAPPING_LOWMEM
    CloseHandle(_hMapping);
    _hMapping = NULL;
#endif
    
    if (_hMapping != NULL)
    {
        //Mapping created OK, now map view
        _pbBase = MapViewOfFileEx(_hMapping,
                                  (fReadOnly) ? FILE_MAP_READ : FILE_MAP_WRITE,
                                  0,
                                  0,
                                  0,
                                  pvDesiredBaseAddress);

        if (_pbBase == NULL)
        {
            CloseHandle(_hMapping);
            _hMapping = INVALID_HANDLE_VALUE;
        }
    }

#endif //SUPPORT_FILE_MAPPING

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMappedFile::Init, public
//
//  Synopsis:	Initialize based on a filename
//
//  Arguments:	[pwcsName] -- Filename for file
//              [dwSize] -- Desired size of file, 0 for no size change
//              [dwAccess] -- Access mode for file (see CreateFile)
//              [dwCreationDisposition] -- Creation for file (see CreateFile)
//              [pvDesiredBaseAddress] -- Desired base address for mapping
//
//  Returns:	Appropriate status code
//
//  History:	13-Feb-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMappedFile::Init(OLECHAR const *pwcsName,
                        DWORD dwSize,
                        DWORD dwAccess,
                        DWORD dwCreationDisposition,
                        void *pvDesiredBaseAddress)
{
    SCODE sc;
    BOOL fReadOnly = ((dwAccess & GENERIC_WRITE) == 0);

    layAssert(!fReadOnly || (dwSize == 0));
    if (pwcsName == NULL)
        return STG_E_INVALIDNAME;

#if (!defined(UNICODE) && !defined(_MAC))

    TCHAR atcPath[MAX_PATH + 1];
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!WideCharToMultiByte(
        uCodePage,
        0,
        pwcsName,
        -1,
        atcPath,
        MAX_PATH + 1,
        NULL,
        NULL))
    {
        return STG_E_INVALIDNAME;
    }

    _hFile = CreateFileA(atcPath,
                        dwAccess,
                        0, //No sharing
                        NULL, //No security
                        dwCreationDisposition,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL); // No template file
#else    
    _hFile = CreateFile(pwcsName,
                        dwAccess,
                        0, //No sharing
                        NULL, //No security
                        dwCreationDisposition,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL); // No template file
#endif    
    


    if (_hFile == INVALID_HANDLE_VALUE)
    {
        layErr(Err, STG_SCODE(GetLastError()));
    }

    if (dwSize != 0)
    {
        DWORD dw = SetFilePointer(_hFile,
                                  dwSize,
                                  NULL,
                                  FILE_BEGIN);
        if (dw == 0xFFFFFFFF)
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }

        if (!SetEndOfFile(_hFile))
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }
    }
    else 
    {   
        DWORD dwFileSize;

        dwFileSize = GetFileSize(_hFile, NULL);

        if (dwFileSize == 0xFFFFFFFF)
        {
            layErr(Err, STG_SCODE(GetLastError()));
        }
        
        if ( dwFileSize == 0 )
        {
            return STG_S_FILEEMPTY;
        }

    }   
    layChk(InitFromHandle(_hFile, fReadOnly, FALSE, pvDesiredBaseAddress));

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\layouter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layouter.cxx
//
//  Contents:	Error functions
//
//  Classes:	
//
//  Functions:	
//
//  History:	21-Feb-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layouthd.cxx"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:	Win32ErrorToScode, public
//
//  Synopsis:	Map a Win32 error into a corresponding scode, remapping
//              into Facility_Storage if appropriate.
//
//  Arguments:	[dwErr] -- Win32 error to map
//
//  Returns:	Appropriate scode
//
//  History:	22-Sep-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE Win32ErrorToScode(DWORD dwErr)
{
    layAssert((dwErr != NO_ERROR) &&
             "Win32ErrorToScode called on NO_ERROR");

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
        sc = STG_E_INVALIDFUNCTION;
        break;
    case ERROR_FILE_NOT_FOUND:
        sc = STG_E_FILENOTFOUND;
        break;
    case ERROR_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;
    case ERROR_TOO_MANY_OPEN_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;
    case ERROR_INVALID_HANDLE:
        sc = STG_E_INVALIDHANDLE;
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;
    case ERROR_NO_MORE_FILES:
        sc = STG_E_NOMOREFILES;
        break;
    case ERROR_WRITE_PROTECT:
        sc = STG_E_DISKISWRITEPROTECTED;
        break;
    case ERROR_SEEK:
        sc = STG_E_SEEKERROR;
        break;
    case ERROR_WRITE_FAULT:
        sc = STG_E_WRITEFAULT;
        break;
    case ERROR_READ_FAULT:
        sc = STG_E_READFAULT;
        break;
    case ERROR_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;
    case ERROR_LOCK_VIOLATION:
        sc = STG_E_LOCKVIOLATION;
        break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
        sc = STG_E_FILEALREADYEXISTS;
        break;
    case ERROR_INVALID_PARAMETER:
        sc = STG_E_INVALIDPARAMETER;
        break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
        sc = STG_E_INVALIDNAME;
        break;
    case ERROR_INVALID_FLAGS:
        sc = STG_E_INVALIDFLAG;
        break;
    default:
        sc = WIN32_SCODE(dwErr);
        break;
    }
        
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\test\pch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	pch.cxx
//
//  History:	09-Sep-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <time.h>

#include <windows.h>
//#include <stgint.h>
#include <objbase.h>

#include <debnot.h>
#include <error.hxx>

#include "tutils.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\test\laytest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	laytest.cxx
//
//  History:	15-May-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "scripts.hxx"


HRESULT StgLayoutDocfile(HANDLE hOld,
                         OLECHAR const *pwcsNewName,
                         OLECHAR const *pwcsScriptName);

typedef ULONG SECT;


#define FailMsg(MSG) {printf MSG; exit(1);}

#define DoCmd(MSG, CODE, FAILMSG) \
printf(MSG " => %s (0x%lX)\n", (sc = ResultFromScode(CODE), ScText(sc)), sc); \
if (FAILED(sc)) {printf(FAILMSG "\n");}

#define SHIFT(c,v)  ( (c)--, (v)++)

#include <assert.h>

void BeginTest(void)
{
    HRESULT hr;

    hr = CoInitialize(NULL);
    Result(hr, "CoInitialize");
}


void EndTest(int rc)
{
    if (rc == 0)
        printf("Test SUCCEEDED\n");
    else
        printf("Test FAILED\n");
    CoUninitialize();
    exit(rc);
}

void PrintStat(STATSTG *pstat, BOOL fEnum)
{
    printf("%s: '%ws'\n", pstat->type == STGTY_STORAGE ? "Storage" : "Stream",
           pstat->pwcsName);
    //printf("Type: %lu, %lu\n", pstat->type, pstat->dwStgFmt);
    printf("Type: %lu, %lu\n", pstat->type);
    if (!fEnum)
        printf("Mode: %lX\n", pstat->grfMode);
    if (pstat->type == STGTY_STREAM)
    {
        printf("Size: %lu:%lu\n", pstat->cbSize.HighPart,
               pstat->cbSize.LowPart);
        if (!fEnum)
            printf("Locks: %lX\n", pstat->grfLocksSupported);
    }
    else
    {
        if (pstat->ctime.dwHighDateTime != 0 ||
            pstat->ctime.dwLowDateTime != 0)
            printf("Ctime: %s\n", FileTimeText(&pstat->ctime));
        if (pstat->mtime.dwHighDateTime != 0 ||
            pstat->mtime.dwLowDateTime != 0)
            printf("Mtime: %s\n", FileTimeText(&pstat->mtime));
        if (pstat->atime.dwHighDateTime != 0 ||
            pstat->atime.dwLowDateTime != 0)
            printf("Atime: %s\n", FileTimeText(&pstat->atime));
    }
    if (!fEnum)
        printf("Clsid: %s\n", GuidText(&pstat->clsid));
}
void PrintStatInfo(STATSTG *pstat)
{
    PrintStat(pstat, TRUE);
}

#define OLDFILENAME L"StartDocfile.Doc"
#define NEWFILENAME L"d:\\scratch\\NewD.doc"
#define SCRIPTFILENAME L"Script"
#define DOCFILENAME L"d:\\nt\\private\\ole32\\stg\\async\\layout\\test\\test.doc"

void t_script(void)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgNew, *pstgOld;
    ILayoutStorage *pLayout;
    
    int i;

    BYTE buffer[4096];
    

    sc = StgOpenLayoutDocfile(DOCFILENAME,
                            STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            0,
                            &pstgRoot);
    Result(sc, "StgOpenLayoutDocfile");


    pstgRoot->QueryInterface(IID_ILayoutStorage,(void **) &pLayout);
    
    for (i=0; i < NUMTESTS; i++)
    {
        sc = pLayout->LayoutScript(
	    arrWord[i].LayoutArray,
	    arrWord[i].nEntries,
	    STG_LAYOUT_SEQUENTIAL); // sequential (all up front) control structures

        Result(sc, "LayoutScript");


    }
    // Write new compound file with desired layout
    sc = pLayout->ReLayoutDocfile(NEWFILENAME);
    
    Result(sc, "ReLayoutDocfile");

    sc = StgOpenStorage(NEWFILENAME,
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,
                        0,
                        &pstgNew);
    Result(sc, "Open new file");

    if (!CompareStorages(pstgRoot, pstgNew))
    {
        Fail("Files did not compare identical\n");
    }
    
    pLayout->Release();
    pstgNew->Release();
    pstgRoot->Release();
}

void __cdecl main(int argc, char **argv)
{
    SCODE sc;
    BeginTest();

    //t_layout();

    t_script();

    EndTest(0);
    exit(0);	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layoutui\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layoutui\layoutui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layoutui.cxx
//
//  Contents:	UI implementation on Docfile Layout Tool
//
//  Classes:    CLayoutApp	
//
//  Functions:	
//
//  History:	23-Mar-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layoutui.hxx"

// Constants for File Addition dialogs
#define MAX_FILES_BUFFER        2048
#define MAX_TITLE_LEN           256
#define MAX_FILTER_LEN          256
#define MAX_PREFIX_LEN          5

#define WIDTH                   500
#define HEIGHT                  300

#define NULL_TERM               TEXT('\0')
#define BACKSLASH               TEXT("\\")
#define SPACE                   TEXT(' ')

#define MALLOC(x)               LocalAlloc( LMEM_FIXED , x );
#define FREE(x)                 LocalFree( x );
#define JumpOnFail(sc)          if( FAILED(sc) ) goto Err;

#ifdef UNICODE
#define STRING_LEN(x)           Laylstrlen(x)
#define CopyString(dst, src)    Laylstrcpy(dst, src)
#define CatString(dst, src)     Laylstrcat(dst, src)
#else
#define STRING_LEN(x)           lstrlen(x)
#define CopyString(dst, src)    lstrcpy(dst, src)
#define CatString(dst, src)     lstrcat(dst, src)
#endif

// Since the LayoutDlgProc must be static for the Callback,
// we need a way to reference the member variables inside of
// LayoutDlgProc
static CLayoutApp *pStaticThis;

#ifdef STRICT
static WNDPROC lpfnwpListBoxProc = NULL;
static WNDPROC lpfnwpButtonProc  = NULL;
#define SUBCLASS_WNDPROC  WNDPROC
#else
static FARPROC lpfnwpListBoxProc = NULL;
static FARPROC lpfnwpButtonProc  = NULL;
#define SUBCLASS_WNDPROC  FARPROC
#endif

// currently supported version of NT
#define NT_MAJOR_VER 3
#define NT_MINOR_VER 51
// currently supported version of Win95
#define WIN95_MAJOR_VER 4

BOOL 	g_fIsNT351 = FALSE;

//+---------------------------------------------------------------------------
//  
//  Function IsOperatingSystemOK
//  
//  Synopsis:	Checks to see if thid OS version is compatible
//              with this application. 
//              NT40 Win95 and NT3.51 are supprted.
//              Sets g_fIsNT351
//              
//  History:	27-July-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL  IsOperatingSystemOK(void)
{
    OSVERSIONINFO osversioninfo = {0};

    // get operating system info
    osversioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osversioninfo))
    {
        return FALSE;
    }

    // if NT, check version
    if (osversioninfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if ( osversioninfo.dwMajorVersion <  NT_MAJOR_VER )
        {
            return FALSE;
        }
        if ( osversioninfo.dwMajorVersion ==  NT_MAJOR_VER )
            if ( osversioninfo.dwMinorVersion <  NT_MINOR_VER )
        {
            return FALSE;
        }
        if ( osversioninfo.dwMajorVersion ==  NT_MAJOR_VER )
            if ( osversioninfo.dwMinorVersion ==  NT_MINOR_VER )
        {
            g_fIsNT351 = TRUE;
            return TRUE;
        }
        return TRUE;
        

    }
	
    // else if Win95 check version
    else if (osversioninfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {	
		if ( osversioninfo.dwMajorVersion <  WIN95_MAJOR_VER )
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    // else unrecognized OS  (should never make it here)
    else
    {
        return FALSE;
    }

    

}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::CLayoutApp public
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


CLayoutApp::CLayoutApp(HINSTANCE hInst)
{
    m_hInst        = hInst;
    m_hwndMain     = hwndNil;
    
    pStaticThis    = this;
    m_bOptimizing  = FALSE;    
    m_bCancelled   = FALSE;
    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::InitApp public
//
//  Synopsis:	Initialize the application
//
//  Returns:	TRUE is sucessful, FALSE is FAILED
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL CLayoutApp::InitApp(void)
{
    
    if (!IsOperatingSystemOK())
    {
        return FALSE;
    }

    if( !InitWindow() )
    {
        DisplayMessage(NULL, 
                    IDS_MAIN_WINDOW_FAIL,
                    IDS_MAIN_WINDOW_FAIL_TITLE, 
                    MB_ICONSTOP);
        return FALSE;
    }

    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DoAppMessageLoop public
//
//  Synopsis:	Main window message loop
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


INT CLayoutApp::DoAppMessageLoop(void)
{
    MSG msg;
    HACCEL hAccel;

    hAccel = LoadAccelerators( m_hInst, MAKEINTRESOURCE(IDR_ACCELERATOR1) );

    while (GetMessage (&msg, NULL, 0, 0))
          {
          if (m_hwndMain == 0 || !IsDialogMessage (m_hwndMain, &msg))
               {
               TranslateMessage (&msg) ;
               DispatchMessage  (&msg) ;
               }
          }
    
    return (INT) msg.wParam;
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::InitWindow public
//
//  Synopsis:	Initialize the main window
//
//  Returns:	TRUE is sucessful, FALSE is FAILED
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL CLayoutApp::InitWindow (void)
{
    m_hwndMain = CreateDialog(  m_hInst,
                 MAKEINTRESOURCE(IDD_MAIN),
                 NULL,
                 (DLGPROC)LayoutDlgProc);

    if( m_hwndMain == NULL )
        return FALSE;

    EnableButtons();
    DragAcceptFiles(m_hwndMain, TRUE);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::InitApp public
//
//  Synopsis:	Application Callback function
//
//  Returns:	TRUE is message was handled.  FALSE otherwise
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


LONG CALLBACK CLayoutApp::ListBoxWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{   
    switch (uMsg)
    {
    case WM_SETCURSOR:
        if( (HWND)wParam == pStaticThis->m_hwndMain )
            SetCursor(LoadCursor(NULL, (pStaticThis->m_bCancelled ? IDC_WAIT : IDC_ARROW)));

        return bMsgHandled;
    }

    return (LONG) CallWindowProc(lpfnwpListBoxProc, hWnd, uMsg, wParam, lParam);
}


LONG CALLBACK CLayoutApp::ButtonWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{   
    switch (uMsg)
    {
    case WM_SETCURSOR:
        if( (HWND)wParam == pStaticThis->m_hwndMain )
            SetCursor(LoadCursor(NULL, (pStaticThis->m_bCancelled ? IDC_WAIT : IDC_ARROW)));

        return bMsgHandled;
    }

    return  (LONG) CallWindowProc(lpfnwpButtonProc, hWnd, uMsg, wParam, lParam);
}


BOOL CALLBACK CLayoutApp::LayoutDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{   
    SCODE sc          = S_OK;
    WORD  wId         = LOWORD((DWORD)wParam);
    WORD  wNotifyCode = HIWORD((DWORD)wParam);
    DWORD thrdid;
    static HANDLE hthread;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pStaticThis->m_hwndBtnAdd      = GetDlgItem( hDlg, IDC_BTN_ADD );
        pStaticThis->m_hwndBtnRemove   = GetDlgItem( hDlg, IDC_BTN_REMOVE );
        pStaticThis->m_hwndBtnOptimize = GetDlgItem( hDlg, IDC_BTN_OPTIMIZE );
        pStaticThis->m_hwndListFiles   = GetDlgItem( hDlg, IDC_LIST_FILES );
        pStaticThis->m_hwndStaticFiles = GetDlgItem( hDlg, IDC_STATIC_FILES );

#ifdef _WIN64
        lpfnwpListBoxProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndListFiles,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ListBoxWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndBtnAdd,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndBtnRemove,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLongPtr(
            pStaticThis->m_hwndBtnOptimize,
            GWLP_WNDPROC,
            (ULONG_PTR)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );
#else
        lpfnwpListBoxProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndListFiles,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ListBoxWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndBtnAdd,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndBtnRemove,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );

        lpfnwpButtonProc = (SUBCLASS_WNDPROC)SetWindowLong(
            pStaticThis->m_hwndBtnOptimize,
            GWL_WNDPROC,
            (LONG)(WNDPROC)MakeProcInstance(
                (FARPROC)ButtonWndProc,
                pStaticThis->m_hInst
                )
            );
#endif // _WIN64

	// resize dialog and center it on the screen
	{
		RECT rcScreen;
		GetWindowRect(GetDesktopWindow(), &rcScreen);

		SetWindowPos(
			hDlg,
			HWND_TOP,
			(rcScreen.right - rcScreen.left - WIDTH) / 2,
			(rcScreen.bottom - rcScreen.top - HEIGHT) / 2,
			WIDTH,
			HEIGHT,
			SWP_SHOWWINDOW);
	}
        return TRUE;

    case WM_SIZE:
		pStaticThis->ReSizeWindow(lParam);
		return bMsgHandled;

    case WM_GETMINMAXINFO:
	{
	LPMINMAXINFO lpminmax = (LPMINMAXINFO) lParam;

	lpminmax->ptMinTrackSize.x = gdxWndMin;
	lpminmax->ptMinTrackSize.y = gdyWndMin;
	}
	return bMsgHandled;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        PostQuitMessage(0);
        return bMsgHandled;

    case WM_DROPFILES:
        {
            TCHAR atcFileName[MAX_PATH];
            HDROP hdrop  = (HDROP)wParam;
            INT   nFiles = DragQueryFile(hdrop, 0xFFFFFFFF, NULL, 0);
            INT   i;

            for( i=0; i < nFiles; i++ )
            {
                if( DragQueryFile(hdrop, i, atcFileName, MAX_PATH) != 0 )
                    pStaticThis->AddFileToListBox(atcFileName);
            }
            DragFinish(hdrop);
            pStaticThis->EnableButtons();
        }
        return bMsgHandled;

    case WM_SETCURSOR:
        if( (HWND)wParam == pStaticThis->m_hwndMain )
            SetCursor(LoadCursor(NULL, (pStaticThis->m_bCancelled ? IDC_WAIT : IDC_ARROW)));

        return bMsgHandled;

    case WM_COMMAND:
        switch( wId )
	{ 
	case IDC_BTN_ADD:
            pStaticThis->AddFiles();
            return bMsgHandled;

	case IDC_BTN_REMOVE:
            pStaticThis->RemoveFiles();
            return bMsgHandled;

	case IDC_BTN_OPTIMIZE:
            
            if (pStaticThis->m_bOptimizing)  //Cancel Button click
            {   
                pStaticThis->m_bCancelled = TRUE;
                
                //SetCursor(LoadCursor(NULL, IDC_WAIT));
                
                return bMsgHandled; 
            }
            else                //Optimize Button Click
            {
                
                pStaticThis->m_bOptimizing = TRUE;
                pStaticThis->SetActionButton( IDS_CANCEL );
                hthread = CreateThread(NULL,0,
                            (LPTHREAD_START_ROUTINE) &(pStaticThis->OptimizeFiles),
			     NULL, 0, &thrdid);
                
                return bMsgHandled;

            }

        case IDC_LIST_FILES:
            switch( wNotifyCode )
            {
            case LBN_SELCHANGE:
                pStaticThis->EnableButtons();
                return bMsgHandled;
            
            default:
                break;
            }

        default:
            break;
        }

        break;

    }

    return bMsgNotHandled;
}    

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::ReSizeWindow public
//
//  Synopsis:	Handle resizing the main dialog
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::ReSizeWindow (LPARAM lParam)
{
	int nW = LOWORD(lParam);
	int nH = HIWORD(lParam);

	int nBorder  = 10;
        int nButtonH = 25;
	int nButtonW = 100;
	int nStaticH = 15;

        int nListY = nBorder + nStaticH;
        int nListW = nW - 3 * nBorder - nButtonW;
        int nListH = nH - nListY - nBorder;

        int nButtonX = 2 * nBorder + nListW;

        MoveWindow(m_hwndStaticFiles, nBorder,  nBorder, nListW, nStaticH, TRUE);
        MoveWindow(m_hwndListFiles  , nBorder,  nListY,  nListW, nH - nButtonH - nBorder, TRUE);

        MoveWindow(m_hwndBtnAdd     , nButtonX, nListY, nButtonW, nButtonH, TRUE);
        MoveWindow(m_hwndBtnRemove  , nButtonX, nListY + 3 * nBorder, nButtonW, nButtonH, TRUE);
        MoveWindow(m_hwndBtnOptimize, nButtonX, nListY + nListH - nButtonH, nButtonW, nButtonH, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::AddFiles public
//
//  Synopsis:	Add and display selected files to the dialog window
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::AddFiles (void)
{
    //We add 1 to atcFile so that we can double null terminate 
    //the string they give us in the 3.51 case

    TCHAR atcFile[MAX_FILES_BUFFER +1 ];
    
    TCHAR atcTitle[MAX_TITLE_LEN];
    TCHAR atcFilter[MAX_FILTER_LEN];

    
    OPENFILENAME ofn;
    FillMemory( (LPVOID)&ofn, sizeof(ofn), 0 );

    ofn.lStructSize = sizeof( ofn );
    ofn.hwndOwner = m_hwndMain;
    ofn.hInstance = m_hInst;

    FormFilterString( atcFilter, MAX_FILTER_LEN );
    ofn.lpstrFilter = atcFilter;

    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex = 0;

    *atcFile = NULL_TERM;
    ofn.lpstrFile = atcFile;
    ofn.nMaxFile = MAX_FILES_BUFFER;

    ofn.lpstrFileTitle = NULL;
    ofn.lpstrInitialDir = NULL;

    LoadString( m_hInst, IDS_ADDFILES_TITLE, atcTitle, MAX_TITLE_LEN );
    ofn.lpstrTitle = atcTitle;

    if (g_fIsNT351)  //NT 3.51 doesn't support OFN_EXPLORER
    {
        ofn.Flags = OFN_ALLOWMULTISELECT |
                OFN_HIDEREADONLY     |
                OFN_FILEMUSTEXIST    |
                OFN_PATHMUSTEXIST;
    }
    else
    {
        ofn.Flags = OFN_ALLOWMULTISELECT |
                OFN_HIDEREADONLY     |
                OFN_EXPLORER         |
                OFN_FILEMUSTEXIST    |
                OFN_PATHMUSTEXIST;
    }

    if( !GetOpenFileName( &ofn ) )
    {
        DWORD dw = CommDlgExtendedError();
        
        if( dw == FNERR_BUFFERTOOSMALL )
            DisplayMessage( m_hwndMain,
                            IDS_ADDFILES_BUFFERTOOSMALL,
                            IDS_ADDFILES_BUFFERTOOSMALL_TITLE,
                            0);
        return;
    }

    WriteFilesToList( atcFile );
    
    EnableButtons();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::FormFilterString public
//
//  Synopsis:	Specifies which files (with which extension are to be displayed
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::FormFilterString( TCHAR *patcFilter, INT nMaxLen )
{
    int nLen;
    UINT uStrID;

    //NOTE:  the string resources must be in sequence
    uStrID = IDS_FILTER_BEGIN+1;

    // this is an internal function and so we aren't checking for
    // enough room in the string buffer, patcFilter
    while( uStrID != IDS_FILTER_END )
    {
        LoadString( m_hInst, uStrID++, patcFilter, nMaxLen );
        nLen = STRING_LEN( patcFilter );
        nMaxLen -= nLen + 1;
        patcFilter += nLen;
        *patcFilter++ = NULL_TERM;
    }

    *patcFilter = NULL_TERM;
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::WriteFilesToList public
//
//  Synopsis:   For NT4.0 and Win95
//              Gets and writes the files, complete with path, to the File List
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::WriteFilesToList( TCHAR *patcFilesList )
{
    TCHAR *patcDir;
    TCHAR atcFile[MAX_PATH];
    BOOL bOneFile = TRUE;
    
    patcDir = patcFilesList;
        
    if (g_fIsNT351)  
    {
        // NT 3.51 stores SPACES instead of NULLs
        // between multiple file names
        // so we need some preprocessing here
        
        while ( *patcFilesList != NULL_TERM )
        {
            if (*patcFilesList == SPACE)
            {
               *patcFilesList = NULL_TERM;
            }
            patcFilesList++;
        }

        // and we need to double NULL terminate
        *(++patcFilesList) = NULL_TERM;
         
        //reset the pointer to the start
        patcFilesList = patcDir;

    }    
    
    while( *patcFilesList++ != NULL_TERM )
        ;

    while( *patcFilesList != NULL_TERM )
    {
        bOneFile = FALSE;
        CopyString( atcFile, patcDir );
        CatString( atcFile, BACKSLASH );
        CatString( atcFile, patcFilesList );
        AddFileToListBox( atcFile );
        while( *patcFilesList++ != NULL_TERM )
            ;
    }

    // if only one file was selected, 
    // the filename isn't separated by it's path, 
    // but is one complete filename
    if( bOneFile )
    {
        AddFileToListBox( patcDir );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::AddFileToListBox public
//
//  Synopsis:   displays the file to the dialog list box
//
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::AddFileToListBox( TCHAR *patcFile )
{
    
    // add the file iff the file is not already displayed
    if (LB_ERR == SendMessage(m_hwndListFiles, 
                            LB_FINDSTRING, 
                            (WPARAM)0, 
                            (LPARAM)(LPCTSTR)patcFile))
    {
        SendMessage(m_hwndListFiles,
                    LB_ADDSTRING,
                    (WPARAM)0,
                    (LPARAM)(LPCTSTR)patcFile);
    }

    SetListBoxExtent();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::RemoveFileFromListBox public
//
//  Synopsis:   remove the displayed the file from the dialog list box
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::RemoveFileFromListBox( INT nIndex )
{
    SendMessage(m_hwndListFiles, 
                LB_DELETESTRING, 
                (WPARAM)nIndex, 
                (LPARAM)0);

    SetListBoxExtent();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::SetListBoxExtent public
//
//  Synopsis:   Handles making a horizontal scroll bar if necessary
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::SetListBoxExtent( void )
{
    INT i;
    INT nExtent = 0;
    LPARAM nItems  =  SendMessage( m_hwndListFiles,
                                LB_GETCOUNT, 
                                (WPARAM)0, 
                                (LPARAM)0);
    TCHAR atcFile[MAX_PATH];
    HDC hdc = NULL;
    SIZE size;

    
    if( nItems == 0 )
        goto lSetListBoxExtent_Exit;

    if( (hdc = GetDC(m_hwndMain)) == NULL)
        goto lSetListBoxExtent_Exit;

    for( i=0; i < (INT) nItems; i++ )
    {
        SendMessage(m_hwndListFiles, 
                    LB_GETTEXT, 
                    (WPARAM)i, 
                    (LPARAM)(LPCTSTR)atcFile);
        

        GetTextExtentPoint32(
            hdc,
            atcFile,
            STRING_LEN(atcFile),
            &size);

        nExtent = max(nExtent, (INT)size.cx);
    }

lSetListBoxExtent_Exit:

    if( hdc )
        ReleaseDC( m_hwndMain, hdc );

    SendMessage(m_hwndListFiles, 
                LB_SETHORIZONTALEXTENT, 
                (WPARAM)nExtent, 
                (LPARAM)0);
}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::RemoveFiles public
//
//  Synopsis:   remove one or more files from displayed list
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::RemoveFiles (void)
{
    INT  i;
    INT *pnSelItems;;
    LPARAM nSelItems = SendMessage(  m_hwndListFiles,
                                   LB_GETSELCOUNT, 
                                   (WPARAM)0, 
                                   (LPARAM)0);

    if( nSelItems == 0 )
        return;

    pnSelItems = (LPINT) MALLOC( sizeof(INT)* (INT)nSelItems );

    if( !pnSelItems )
        return;

    SendMessage(m_hwndListFiles, 
                LB_GETSELITEMS, 
                (WPARAM)nSelItems, 
                (LPARAM)(LPINT)pnSelItems);

    // start from bottom of list to keep the indices correct
    for( i= (INT)nSelItems; --i >= 0; )
        RemoveFileFromListBox( pnSelItems[i] );

    FREE( pnSelItems );

    EnableButtons();
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DisplayMessage public
//
//  Synopsis:   message box general routine with no file names
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

INT CLayoutApp::DisplayMessage(HWND hWnd,
                               UINT uMessageID,
                               UINT uTitleID,
                               UINT uFlags)
{
    TCHAR atcMessage[MAX_PATH];
    TCHAR atcTitle[MAX_PATH];

    LoadString(m_hInst, uMessageID, atcMessage, MAX_PATH);
    LoadString(m_hInst, uTitleID, atcTitle, MAX_PATH);

    if( hWnd )
	SetForegroundWindow(hWnd);

    return MessageBox(hWnd, atcMessage, atcTitle, uFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DisplayMessageWithFileName public
//
//  Synopsis:   message box general routine with 1 file name
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

INT CLayoutApp::DisplayMessageWithFileName(HWND hWnd,
                               UINT uMessageIDBefore,
                               UINT uMessageIDAfter,
                               UINT uTitleID,
                               UINT uFlags,
                               TCHAR *patcFileName)
{
    TCHAR atcMessageBefore[MAX_PATH];
    TCHAR atcMessageAfter[MAX_PATH];
    TCHAR atcTitle[MAX_PATH];
    TCHAR atcFileErrorMsg[MAX_PATH*2];


    LoadString(m_hInst, uMessageIDBefore, atcMessageBefore, MAX_PATH);
    LoadString(m_hInst, uMessageIDAfter, atcMessageAfter, MAX_PATH);
    LoadString(m_hInst, uTitleID, atcTitle, MAX_PATH);

    CopyString(atcFileErrorMsg, atcMessageBefore);
    CatString(atcFileErrorMsg, patcFileName);
    CatString(atcFileErrorMsg, atcMessageAfter);

    if( hWnd )
	SetForegroundWindow(hWnd);

    return MessageBox(hWnd, atcFileErrorMsg, atcTitle, uFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DisplayMessageWithTwoFileNames public
//
//  Synopsis:   message box general routine with 2 file names
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

INT CLayoutApp::DisplayMessageWithTwoFileNames(HWND hWnd,
                               UINT uMessageID,
                               UINT uTitleID,
                               UINT uFlags,
                               TCHAR *patcFirstFileName,
                               TCHAR *patcLastFileName)
{
    TCHAR atcMessage[MAX_PATH];
    TCHAR atcTitle[MAX_PATH];
    TCHAR atcFileErrorMsg[MAX_PATH*2];


    LoadString(m_hInst, uMessageID, atcMessage, MAX_PATH);
    LoadString(m_hInst, uTitleID, atcTitle, MAX_PATH);

    CopyString(atcFileErrorMsg, patcFirstFileName);
    CatString(atcFileErrorMsg, atcMessage);
    CatString(atcFileErrorMsg, patcLastFileName); 

    if( hWnd )
	SetForegroundWindow(hWnd);

    return MessageBox(hWnd, atcFileErrorMsg, atcTitle, uFlags);
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::EnableButtons public
//
//  Synopsis:   Updates the buttons.  Optimize turns to Cancel 
//              during optimize function.
//              Remove is greyed if no files are displayed
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

VOID CLayoutApp::EnableButtons( BOOL bShowOptimizeBtn )
{
    LPARAM nItems    = SendMessage(  m_hwndListFiles,
                                  LB_GETCOUNT, 
                                  (WPARAM)0, 
                                  (LPARAM)0);
    LPARAM nSelItems = SendMessage(  m_hwndListFiles,
                                  LB_GETSELCOUNT, 
                                  (WPARAM)0, 
                                  (LPARAM)0);

    EnableWindow( m_hwndBtnAdd,      TRUE          );
    EnableWindow( m_hwndBtnRemove,   nSelItems > 0 );
    EnableWindow( m_hwndBtnOptimize, nItems > 0 && bShowOptimizeBtn );
}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::OptimizeFiles public
//
//  Synopsis:   Static function to call the optimizeFiles worker routine
//
//  Returns:	Appropriate status code
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

DWORD CLayoutApp::OptimizeFiles (void *args)
{
    SCODE sc;

    sc = CoInitialize(NULL);
    
    sc = pStaticThis->OptimizeFilesWorker();
    
    CoUninitialize();

    pStaticThis->HandleOptimizeReturnCode(sc);

                pStaticThis->m_bCancelled = FALSE;

                pStaticThis->SetActionButton( IDS_OPTIMIZE );
                pStaticThis->m_bOptimizing = FALSE;
                
                //SetCursor(LoadCursor(NULL, IDC_ARROW));
                    
    return 0;

    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::OptimizeFilesWorker public
//
//  Synopsis:   Optimize all the displayed files.  Make temp files,
//              optimize to temp file, then rename temp back to original file.
//
//  Returns:	Appropriate status code
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

SCODE CLayoutApp::OptimizeFilesWorker (void)
{
    INT   i, j;
    SCODE sc = S_OK;
    HRESULT  hr;
    
    TCHAR atcFileName[MAX_PATH];
    TCHAR atcTempPath[MAX_PATH];
    TCHAR atcTempFile[MAX_PATH];
    TCHAR atcPrefix[MAX_PREFIX_LEN];
    TCHAR **ppatcTempFiles = NULL;
    INT   *pintErrorFlag = NULL;
    INT   nItems = (INT) SendMessage( m_hwndListFiles,
                                LB_GETCOUNT, 
                                (WPARAM)0, 
                                (LPARAM)0 );

    if( nItems == 0 )
        return S_OK;

    ppatcTempFiles = (TCHAR **) MALLOC( sizeof(TCHAR *) * nItems );
    
    if( !ppatcTempFiles )
        return STG_E_INSUFFICIENTMEMORY;

    FillMemory( (LPVOID)ppatcTempFiles, sizeof(TCHAR *) * nItems, 0 );

    pintErrorFlag = (INT *) MALLOC( sizeof(INT) * nItems );
    
    if( !pintErrorFlag )
    {
        sc = STG_E_INSUFFICIENTMEMORY;
        JumpOnFail(sc);
    }
    
    FillMemory( (LPVOID)pintErrorFlag, sizeof(INT) * nItems, 0 );
    
    if( GetTempPath( MAX_PATH, atcTempPath ) == 0 )
    {   
         sc = GetLastError();
         JumpOnFail(sc);
    }

    LoadString( m_hInst, IDS_TEMPFILE_PREFIX, atcPrefix, MAX_PREFIX_LEN );

    for( i=0; i < nItems; i++ )
    {
        
        // handle Cancel pressed and cleanup
        if (m_bCancelled)
        {   
            m_bCancelled = FALSE;

            for( j=0; j < i ; j++ )
                DeleteFile(ppatcTempFiles[j]);
         
            sc = STG_E_NONEOPTIMIZED;
            JumpOnFail(sc);
        }

        if( GetTempFileName( atcTempPath, atcPrefix, (UINT)0, atcTempFile ) == 0 )
        {
            sc = GetLastError();
            JumpOnFail(sc);
        }

        ppatcTempFiles[i] =
            (TCHAR *) MALLOC( (STRING_LEN(atcTempFile) + 1) * sizeof(TCHAR) );

        if( !ppatcTempFiles[i] )
        {
            sc = STG_E_INSUFFICIENTMEMORY;
            JumpOnFail(sc);
        }

        CopyString( ppatcTempFiles[i], atcTempFile );
    }

     
    for( i=0; i < nItems; i++ )
    {
        // handle Cancel pressed and cleanup
        if (m_bCancelled)
        {   
            m_bCancelled = FALSE;

            for( j=i; j < nItems ; j++ )
            {
                DeleteFile(ppatcTempFiles[j]);
                pintErrorFlag[j] = 1;    
            }
            sc = STG_E_NONEOPTIMIZED;
                
            for( j=nItems; --j >= 0; )
            {
                if (pintErrorFlag[j])
                {
                    RemoveFileFromListBox(j);
                }
                else 
                {
                    sc = S_OK;
                }
        
            }
            EnableButtons();
            goto Err;
        }
        
        SendMessage( m_hwndListFiles, 
                     LB_GETTEXT, 
                     (WPARAM)i, 
                     (LPARAM)(LPINT)atcFileName );

        sc = DoOptimizeFile( atcFileName, ppatcTempFiles[i] );

#if DBG==1
        //check that files are identical here.
       if ((SUCCEEDED(sc)) && (!IdenticalFiles( atcFileName, ppatcTempFiles[i])))
       {   
           sc = STG_E_DOCFILECORRUPT;
           
       }
#endif
              
        if (!SUCCEEDED(sc))
        {    
            // This file could not be optimized.  Display Error message  
            switch( sc )
            {
            // the file is read only
            case STG_E_ACCESSDENIED:
    
                DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_FILE_AFTER_READ_ONLY,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);
                break;

            // the file is not in a legal docfile format.
            case STG_E_FILEALREADYEXISTS:
        
                DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_FILE_AFTER_NOTDOCFILE,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);
                break;

            default:
                DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_OPTIMIZE_ERROR,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);       
                break;
            }
            
            pintErrorFlag[i] = 1;
            DeleteFile( ppatcTempFiles[i] );
            continue;    
        }
        
        
        //remove the (unoptimized) original file        
        hr = DeleteFile( atcFileName );
        if (!hr)
        {   
            sc = GetLastError();

            DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_DELETE_ERROR,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName);   
                
            DisplayMessageWithTwoFileNames(m_hwndMain, 
                        IDS_RENAME_MESSAGE,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName,
                        ppatcTempFiles[i]);   

            SendMessage( m_hwndListFiles, 
                     LB_DELETESTRING, 
                     (WPARAM)i, 
                     (LPARAM)0);

            SendMessage( m_hwndListFiles, 
                     LB_INSERTSTRING, 
                     (WPARAM)i, 
                     (LPARAM)(LPINT)ppatcTempFiles[i] );
            
            continue;
        }
            
        // rename the optimized file to the original file name    
        hr = MoveFile( ppatcTempFiles[i], atcFileName );
        
        if (!hr)
        {   
            sc = GetLastError();

            DisplayMessageWithFileName(m_hwndMain, 
                        IDS_FILE_BEFORE,
                        IDS_RENAME_ERROR,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        ppatcTempFiles[i]);   
                
            DisplayMessageWithTwoFileNames(m_hwndMain, 
                        IDS_RENAME_MESSAGE,
                        IDS_OPTIMIZE_FAILED_TITLE,
                        0,
                        atcFileName,
                        ppatcTempFiles[i]);   

            SendMessage( m_hwndListFiles, 
                        LB_DELETESTRING, 
                        (WPARAM)i, 
                        (LPARAM)0);

            SendMessage( m_hwndListFiles, 
                        LB_INSERTSTRING, 
                        (WPARAM)i, 
                        (LPARAM)(LPINT)ppatcTempFiles[i] );
                
            continue;
        }
          
        DeleteFile( ppatcTempFiles[i] );
    }    

    // remove files from list box that could not be optimized
    //bSuccess is set if at least one file was sucessfully optimized.
    sc = STG_E_NONEOPTIMIZED;
    
    for( i=nItems; --i >= 0; )
    {
        if (pintErrorFlag[i])
        {
            RemoveFileFromListBox(i);
        }
        else 
        {
            sc = S_OK;
        }
        
    }
    EnableButtons();
Err:

    if ( pintErrorFlag )
        FREE( pintErrorFlag);

    if( ppatcTempFiles )
    {
        for( i=0; i < nItems; i++ )
        {
            if( ppatcTempFiles[i] )
                FREE( ppatcTempFiles[i] );
        }
    
        FREE( ppatcTempFiles );
    }
    return sc;
    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::DoOptimizeFile public
//
//  Synopsis:   Monitor and relayout docfile to temp file.
//
//  Returns:	Appropriate status code
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

SCODE CLayoutApp::DoOptimizeFile( TCHAR *patcFileName, TCHAR *patcTempFile )
{
    IStorage        *pStg       = NULL;
    ILayoutStorage  *pLayoutStg = NULL;
    IUnknown        *punkApp    = NULL;
    IPersistStorage *pPersist   = NULL;
    IOleObject      *pObj       = NULL;
    COleClientSite  *pSite      = NULL;
    SCODE            sc         = S_OK;
    STATSTG          stat;
    OLECHAR          awcNewFileName[MAX_PATH];


    sc = StgOpenLayoutDocfile
            (TCharToOleChar(patcFileName, awcNewFileName, MAX_PATH),
             STGM_DIRECT |
             STGM_READWRITE | 
             STGM_SHARE_EXCLUSIVE, 
             NULL,
             &pStg);

 
    JumpOnFail(sc);

    sc = pStg->QueryInterface( IID_ILayoutStorage, (void**) &pLayoutStg );
    JumpOnFail(sc);
    pStg->Release();

    // begin monitoring
    sc = pLayoutStg->BeginMonitor();
    JumpOnFail(sc);

    sc = pStg->Stat(&stat, STATFLAG_NONAME);
    JumpOnFail(sc);
   
    // open the application type of the input storage
    sc = CoCreateInstance( stat.clsid, 
                           NULL,
                           (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD),
                           IID_IUnknown,
                           (void**) &punkApp );
    JumpOnFail(sc);
  
    // load the document through the IPersistStorage Interface
    sc = punkApp->QueryInterface( IID_IPersistStorage, (void**) &pPersist );
    JumpOnFail(sc);
    punkApp->Release();


    sc = pPersist->Load( pStg );
    JumpOnFail(sc);

    sc = punkApp->QueryInterface( IID_IOleObject, (void**) &pObj );
    JumpOnFail(sc);
    punkApp->Release();

    // Open as a client
    pSite = new COleClientSite;
    pSite->m_patcFile = patcFileName;
    
    sc = pObj->DoVerb(OLEIVERB_OPEN, NULL, (IOleClientSite*) pSite, 0, NULL, NULL);
    JumpOnFail(sc);

    pObj->Close( OLECLOSE_NOSAVE );
    
    // end monitoring and relayout
    if( pLayoutStg )
    {
        sc = pLayoutStg->EndMonitor();
        JumpOnFail(sc);
    
        sc = pLayoutStg->ReLayoutDocfile(
            TCharToOleChar(patcTempFile, awcNewFileName, MAX_PATH) );
        JumpOnFail(sc);
    }

Err:

    if( pStg )
        pStg->Release();

    if( punkApp )
        punkApp->Release();

    if( pSite )
        pSite->Release();

    return sc;
  }
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::HandleOptimizeReturnCode public
//
//  Synopsis:   message box general routine to display apprpriate message 
//              based on the Optimize returned SCODE
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::HandleOptimizeReturnCode( SCODE sc )
{
    switch( sc )
    {
    case S_OK:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_SUCCESS, IDS_OPTIMIZE_SUCCESS_TITLE, 0);
        break;

    case STG_E_FILENOTFOUND:
    case STG_E_INSUFFICIENTMEMORY:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_OUTOFMEM, IDS_OPTIMIZE_OUTOFMEM_TITLE, 0);
        break;
    
    case STG_E_PATHNOTFOUND:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_NOPATH, IDS_OPTIMIZE_NOPATH_TITLE, 0);
        break;
    case STG_E_NONEOPTIMIZED:
        // already displayed errors for why each file could not be optimized.
        break;

    default:
        DisplayMessage(m_hwndMain, IDS_OPTIMIZE_FAILED, IDS_OPTIMIZE_FAILED_TITLE, 0);
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::TCharToOleChar public
//
//  Synopsis:   helper function for UNICODE/ANSI TCHAR to OLEchar conversion
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


OLECHAR *CLayoutApp::TCharToOleChar(TCHAR *patcSrc, OLECHAR *pawcDst, INT nDstLen)
{
#ifdef UNICODE
    
    // this is already UNICODE
    return patcSrc;

#else

    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    *pawcDst = NULL_TERM;

    // convert to UNICODE
    MultiByteToWideChar(
        uCodePage,
        0,
        patcSrc,
        -1,
        pawcDst,
        nDstLen-1 );

    return pawcDst;

#endif
}
//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::SetActionButton public
//
//  Synopsis:   change the text of the button
//
//  History:	03-April-96	SusiA	Created
//
//----------------------------------------------------------------------------


VOID CLayoutApp::SetActionButton( UINT uID )
{
    TCHAR atcText[MAX_PATH];

    LoadString( m_hInst, uID, atcText, MAX_PATH );

    SetWindowText( m_hwndBtnOptimize, atcText );

    UpdateWindow( m_hwndMain );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layoutui\laymain.cxx ===
#include "layoutui.hxx"


INT WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR  lpCmdLine,
    INT    nCmdShow
)
{
    CLayoutApp *pLayoutApp;

    pLayoutApp = new CLayoutApp(hInstance);

    if( !pLayoutApp )
        return 0;

    if( !pLayoutApp->InitApp() )
        return 0;

    return pLayoutApp->DoAppMessageLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layoutui\cklayout.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	layoutui.cxx
//
//  Contents:	debug UI implementation on Docfile Layout Tool
//
//  Classes:    CLayoutApp	
//
//  Functions:	
//
//  History:	07-Apr-96	SusiA	Created
//
//----------------------------------------------------------------------------

#include "layoutui.hxx"

#if DBG==1

BOOL CompareStatStg(STATSTG *pstat1, STATSTG *pstat2)
{
    if (Laylstrcmp(pstat1->pwcsName, pstat2->pwcsName) != 0)
    {
        return FALSE;
    }
    if (pstat1->type != pstat2->type)
    {
        return FALSE;
    }
    if (!IsEqualIID(pstat1->clsid, pstat2->clsid))
    {
        return FALSE;
    }
    if (pstat1->type == STGTY_STREAM)
    {
        if ((pstat1->cbSize).QuadPart != (pstat2->cbSize).QuadPart)
        {
            return FALSE;
        }
    }
    //Also check statebits and timestamps?
    
    return TRUE;
}


BOOL CompareStreams(IStream *pstm1, IStream *pstm2)
{
    const ULONG BUFSIZE = 4096;
    BYTE buffer1[BUFSIZE];
    BYTE buffer2[BUFSIZE];
    ULONG cbRead1;
    ULONG cbRead2;
    STATSTG stat1;
    STATSTG stat2;
    LARGE_INTEGER li;
    li.QuadPart = 0;

    pstm1->Seek(li, STREAM_SEEK_SET, NULL);
    pstm2->Seek(li, STREAM_SEEK_SET, NULL);

    do
    {
        SCODE sc;
        sc = pstm1->Read(buffer1, BUFSIZE, &cbRead1);
        if (FAILED(sc))
        {
            return FALSE;
        }
        sc = pstm2->Read(buffer2, BUFSIZE, &cbRead2);
        if (FAILED(sc))
        {
            return FALSE;
        }
        if ((cbRead1 != cbRead2) || (memcmp(buffer1, buffer2, cbRead1) != 0))
        {
            return FALSE;
        }
    }
    while (cbRead1 == BUFSIZE);
    
    return TRUE;
}


BOOL CompareStorages(IStorage *pstg1, IStorage *pstg2)
{
    SCODE           sc1, sc2, sc;
    HRESULT         hr = TRUE;

    IStorage        *pstgChild1,
                    *pstgChild2;
    
    IStream         *pstmChild1,
                    *pstmChild2;

    IEnumSTATSTG    *penum1 = NULL,
                    *penum2 = NULL;
    STATSTG         stat1, 
                    stat2;

    pstg1->EnumElements(0, 0, 0, &penum1);

    if (!penum1)
        return FALSE;

    pstg2->EnumElements(0, 0, 0, &penum2);
    
    if (!penum2)
    {
        penum1->Release();
        return FALSE;
    }

    do
    {
        ULONG celtFetched1, celtFetched2;
        
        sc1 = penum1->Next(1, &stat1, &celtFetched1);
        if (FAILED(sc1))
        {
            hr = FALSE;
            goto Done;
        }
        sc2 = penum2->Next(1, &stat2, &celtFetched2);
        if (FAILED(sc2) || (celtFetched1 != celtFetched2) || (sc1 != sc2))
        {
            hr = FALSE;
            goto Done;
        }
        if (celtFetched1 == 0)
        {
            // we are done
            hr = TRUE;
            goto Done;
            
        }
        
        if (!CompareStatStg(&stat1, &stat2))
        {
            hr = FALSE;
            goto Done;
        }

        //Items have compared OK so far.  Now compare contents.
        if (stat1.type == STGTY_STREAM)
        {
            sc = pstg1->OpenStream(stat1.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild1);
            if (FAILED(sc))
            {
                hr = FALSE;
                goto Done;
            }
            sc = pstg2->OpenStream(stat2.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild2);
            if (FAILED(sc))
            {
                pstmChild1->Release();
                hr = FALSE;
                goto Done;
            }
            if (!CompareStreams(pstmChild1, pstmChild2))
            {
                pstmChild1->Release();
                pstmChild2->Release();
                hr = FALSE;
                goto Done;
            }
            pstmChild1->Release();
            pstmChild2->Release();
        }
        else
        {
            //Compare storages
            sc = pstg1->OpenStorage(stat1.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild1);
            if (FAILED(sc))
            {
                hr = FALSE;
                goto Done;
            }

            sc = pstg2->OpenStorage(stat2.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild2);
            if (FAILED(sc))
            {
                pstgChild1->Release();
                hr = FALSE;
                goto Done;
            }
            if (!CompareStorages(pstgChild1, pstgChild2))
            {
                pstgChild1->Release();
                pstgChild2->Release();
                hr = FALSE;
                goto Done;        
            }
            pstgChild1->Release();
            pstgChild2->Release();
        }

        CoTaskMemFree(stat1.pwcsName);
        CoTaskMemFree(stat2.pwcsName);

    } while (sc1 != S_FALSE);
    
    
Done:
    
    penum1->Release();
    penum2->Release();
    
    return hr;

    
}

//+---------------------------------------------------------------------------
//
//  Member:	CLayoutApp::IdenticalFiles public
//
//  Synopsis:	Check two docfiles to ensure they are the same
//
//  Returns:	TRUE is the files are identical, FALSE is they are not
//
//  History:	07-April-96	SusiA	Created
//
//----------------------------------------------------------------------------

BOOL CLayoutApp::IdenticalFiles( TCHAR *patcFileOne,
                               TCHAR *patcFileTwo)
{
    
    SCODE            sc;
    IStorage         *pstgOne, 
                     *pstgTwo;
    OLECHAR          awcNewFileOne[MAX_PATH];
    OLECHAR          awcNewFileTwo[MAX_PATH];


    sc = StgOpenStorage(TCharToOleChar(patcFileOne, awcNewFileOne, MAX_PATH),
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,
                        0,
                        &pstgOne);
    if (FAILED(sc))
    {
        return FALSE;
    }
    
    sc = StgOpenStorage (TCharToOleChar(patcFileTwo, awcNewFileTwo, MAX_PATH),
                        NULL,
                        STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,
                        0,
                        &pstgTwo);
    if (FAILED(sc))
    {
        pstgOne->Release();
        return FALSE;
    }
        

    sc = CompareStorages(pstgOne, pstgTwo);
    
    pstgOne->Release();
    pstgTwo->Release();

    if (sc) 
        return TRUE;
    else
        return FALSE;
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layout\test\tutils.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	tutils.cxx
//
//  Contents:	Generic utilities for tests
//
//  History:	06-Aug-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

static BOOL fExitOnFail = TRUE;

BOOL GetExitOnFail(void)
{
    return fExitOnFail;
}

void SetExitOnFail(BOOL set)
{
    fExitOnFail = set;
}

// Print out an error message and terminate
void Fail(char *fmt, ...)
{
    va_list args;

    args = va_start(args, fmt);
    fprintf(stderr, "** Fatal error **: ");
    vfprintf(stderr, fmt, args);
    va_end(args);
    EndTest(1);
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "<Unknown SCODE>";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr, char *fmt, ...)
{
    SCODE sc;
    va_list args;

    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    sc = GetScode(hr);
    printf(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        Fail("Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(HRESULT hr, char *fmt, ...)
{
    SCODE sc;
    va_list args;

    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    sc = GetScode(hr);
    printf(" - %s (0x%lX)\n", ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        Fail("Unexpected call success\n");
    return hr;
}

char *TcsText(TCHAR *ptcs)
{
    static char buf[256];

    TTOA(ptcs, buf, 256);
    return buf;
}

char *FileTimeText(FILETIME *pft)
{
    static char buf[80];
    struct tm ctm;
#ifndef FLAT    
    WORD dosdate, dostime;

    if (CoFileTimeToDosDateTime(pft, &dosdate, &dostime))
    {
        ctm.tm_sec   = (dostime & 31)*2;
        ctm.tm_min   = (dostime >> 5) & 63;
        ctm.tm_hour  = dostime >> 11;
        ctm.tm_mday  = dosdate & 31;
        ctm.tm_mon   = ((dosdate >> 5) & 15)-1;
        ctm.tm_year  = (dosdate >> 9)+80;
        ctm.tm_wday  = 0;
#else
    SYSTEMTIME st;
        
    if (FileTimeToSystemTime(pft, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
#endif        
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidText(GUID *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}

#define CROW 16

void BinText(ULONG cbSize, BYTE *pb)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                putchar(pb[i]);
            else
                putchar('.');
        pb += cb;
        printf("'\n");
    }
}

TCHAR *TestFile(TCHAR *ptcsName, char *pszFile)
{
    char achFn[MAX_PATH];
    char *dir, *file;
    int len;
    
    dir = getenv("DFDATA");
    if (dir)
        strcpy(achFn, dir);
    else
        strcpy(achFn, ".");
    len = strlen(achFn);
    if (achFn[len-1] != '\\')
        achFn[len++] = '\\';
        
    if (pszFile)
    {
        strcpy(achFn+len, pszFile);
    }    
    else
    {
        file = getenv("DFFILE");
        if (file)
            strcpy(achFn+len, file);
        else
            strcpy(achFn+len, "TEST.DFL");
    }
    
    ATOT(achFn, ptcsName, MAX_PATH);
    return ptcsName+len;
}

#if WIN32 == 300
char *TestFormat(DWORD *pdwFmt, DWORD *pgrfMode)
{
    char *fmt;
        
    fmt = getenv("STGFMT");
    if (fmt == NULL || !strcmp(fmt, "doc"))
    {
        fmt = "document";
        *pdwFmt = STGFMT_DOCUMENT;
    }
    else if (!strcmp(fmt, "file"))
    {
        fmt = "file";
        *pdwFmt = STGFMT_FILE;
    }
    else
    {
        fmt = "directory";
        *pdwFmt = STGFMT_DIRECTORY;
        *pgrfMode &= ~STGM_CREATE;
    }
    return fmt;
}
#endif

BOOL CompareStatStg(STATSTG *pstat1, STATSTG *pstat2)
{
    if (wcscmp(pstat1->pwcsName, pstat2->pwcsName) != 0)
    {
        printf("Names compared wrong: %ws and %ws\n",
               pstat1->pwcsName, pstat2->pwcsName);
        return FALSE;
    }
    if (pstat1->type != pstat2->type)
    {
        printf("Types compares wrong on %ws and %ws: %lu and %lu\n",
               pstat1->pwcsName,
               pstat2->pwcsName,
               pstat2->type,
               pstat2->type);
        
        return FALSE;
    }
    if (!IsEqualIID(pstat1->clsid, pstat2->clsid))
    {
        printf("Class IDs for %ws and %ws compared bad\n",
               pstat1->pwcsName,
               pstat2->pwcsName);
        return FALSE;
    }
    if (pstat1->type == STGTY_STREAM)
    {
        if ((pstat1->cbSize).QuadPart != (pstat2->cbSize).QuadPart)
        {
            printf("Sizes for %ws and %ws compared bad: %lu and %lu\n",
                   pstat1->pwcsName,
                   pstat2->pwcsName,
                   (pstat1->cbSize).LowPart,
                   (pstat2->cbSize).LowPart);
            
            return FALSE;
        }
    }
    //Also check statebits and timestamps?
    
    return TRUE;
}


BOOL CompareStreams(IStream *pstm1, IStream *pstm2)
{
    const ULONG BUFSIZE = 4096;
    BYTE buffer1[BUFSIZE];
    BYTE buffer2[BUFSIZE];
    ULONG cbRead1;
    ULONG cbRead2;
    STATSTG stat1;
    STATSTG stat2;
    LARGE_INTEGER li;
    li.QuadPart = 0;

    pstm1->Seek(li, STREAM_SEEK_SET, NULL);
    pstm2->Seek(li, STREAM_SEEK_SET, NULL);

    do
    {
        SCODE sc;
        sc = pstm1->Read(buffer1, BUFSIZE, &cbRead1);
        if (FAILED(sc))
        {
            printf("Read failed with %lx\n", sc);
            return FALSE;
        }
        sc = pstm2->Read(buffer2, BUFSIZE, &cbRead2);
        if (FAILED(sc))
        {
            printf("Read failed with %lx\n", sc);
            return FALSE;
        }
        if ((cbRead1 != cbRead2) || (memcmp(buffer1, buffer2, cbRead1) != 0))
        {
            if (cbRead1 != cbRead2)
            {
                printf("Stream compare returned different bytes read: %lu and %lu\n",
                       cbRead1,
                       cbRead2);
            }
            else
            {
                printf("Data mismatch.\n");
            }
            return FALSE;
        }
    }
    while (cbRead1 == BUFSIZE);
    
    return TRUE;
}


BOOL CompareStorages(IStorage *pstg1, IStorage *pstg2)
{
    SCODE sc1, sc2, sc;
    IStorage *pstgChild1, *pstgChild2;
    IStream *pstmChild1, *pstmChild2;
    IEnumSTATSTG *penum1, *penum2;
    STATSTG stat1, stat2;

    pstg1->EnumElements(0, 0, 0, &penum1);
    pstg2->EnumElements(0, 0, 0, &penum2);

    do
    {
        ULONG celtFetched1, celtFetched2;
        
        sc1 = penum1->Next(1, &stat1, &celtFetched1);
        if (FAILED(sc1))
        {
            printf("EnumElements 1 failed with %lx\n", sc1);
            return FALSE;
        }
        sc2 = penum2->Next(1, &stat2, &celtFetched2);
        if (FAILED(sc2) || (celtFetched1 != celtFetched2) || (sc1 != sc2))
        {
            if (FAILED(sc2))
            {
                printf("EnumElements 2 failed with %lx\n", sc2);
            }
            else
            {
                printf("Return code mismatch: %lx and %lx\n", sc1, sc2);
            }
            return FALSE;
        }
        if (celtFetched1 == 0)
        {
            //We're done.
            return TRUE;
        }
        
        if (!CompareStatStg(&stat1, &stat2))
        {
            return FALSE;
        }

        //Items have compared OK so far.  Now compare contents.
        if (stat1.type == STGTY_STREAM)
        {
            sc = pstg1->OpenStream(stat1.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild1);
            if (FAILED(sc))
            {
                printf("OpenStream on pstg1 for %ws failed with %lx\n",
                       stat1.pwcsName,
                       sc);
                return FALSE;
            }
            sc = pstg2->OpenStream(stat2.pwcsName,
                                   0,
                                   STGM_DIRECT |
                                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pstmChild2);
            if (FAILED(sc))
            {
                printf("OpenStream on pstg2 for %ws failed with %lx\n",
                       stat2.pwcsName,
                       sc);
                return FALSE;
            }
            if (!CompareStreams(pstmChild1, pstmChild2))
            {
                printf("Stream compare on %ws and %ws failed.\n",
                       stat1.pwcsName,
                       stat2.pwcsName);
                return FALSE;
            }
            pstmChild1->Release();
            pstmChild2->Release();
        }
        else
        {
            //Compare storages
            sc = pstg1->OpenStorage(stat1.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild1);
            if (FAILED(sc))
            {
                printf("OpenStorage on pstg1 for %ws failed with %lx\n",
                       stat1.pwcsName,
                       sc);
                return FALSE;
            }

            sc = pstg2->OpenStorage(stat2.pwcsName,
                                    NULL,
                                    STGM_DIRECT | STGM_READ |
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0,
                                    &pstgChild2);
            if (FAILED(sc))
            {
                printf("OpenStorage on pstg2 for %ws failed with %lx\n",
                       stat2.pwcsName,
                       sc);
                return FALSE;
            }
            if (!CompareStorages(pstgChild1, pstgChild2))
            {
                printf("CompareStorages failed for %ws and %ws\n",
                       stat1.pwcsName,
                       stat2.pwcsName);
                return FALSE;
            }
            pstgChild1->Release();
            pstgChild2->Release();
        }

        //printf("Object %ws compared OK.\n", stat1.pwcsName);
        CoTaskMemFree(stat1.pwcsName);
        CoTaskMemFree(stat2.pwcsName);

    } while (sc1 != S_FALSE);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layoutui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by layoutui.rc
//
#define IDS_ADDFILES_TITLE              20
#define IDS_TEMPFILE_PREFIX             21
#define IDS_FILTER_BEGIN                100
#define IDD_MAIN                        101
#define IDS_ALL_FILES                   101
#define IDS_ALL_FILES_EXT               102
#define IDS_WORD_FILES                  103
#define IDS_WORD_FILES_EXT              104
#define IDS_EXCEL_FILES                 105
#define IDS_EXCEL_FILES_EXT             106
#define IDS_PPT_FILES                   107
#define IDS_PPT_FILES_EXT               108
#define IDS_PUB_FILES                   109
#define IDS_PUB_FILES_EXT               110
#define IDS_FILTER_END                  111
#define IDR_ACCELERATOR1                133
#define IDS_MAIN_WINDOW_FAIL            200
#define IDC_BTN_ADD                     201
#define IDS_MAIN_WINDOW_FAIL_TITLE      201
#define IDC_BTN_REMOVE                  202
#define IDS_ADDFILES_BUFFERTOOSMALL     202
#define IDC_BTN_OPTIMIZE                203
#define IDS_ADDFILES_BUFFERTOOSMALL_TITLE 203
#define IDS_OPTIMIZE_SUCCESS            204
#define IDS_OPTIMIZE_SUCCESS_TITLE      205
#define IDS_OPTIMIZE_OUTOFMEM           206
#define IDS_OPTIMIZE_OUTOFMEM_TITLE     207
#define IDS_OPTIMIZE_NOPATH             208
#define IDS_OPTIMIZE_NOPATH_TITLE       209
#define IDS_ERROR_FILE_NOT_CREATED      210
#define IDS_OPTIMIZE_FAILED             212
#define IDS_OPTIMIZE_FAILED_TITLE       213
#define IDS_FILE_BEFORE                 214
#define IDS_FILE_AFTER_NOTFOUND         215
#define IDS_FILE_AFTER_NOTDOCFILE       216
#define IDS_FILE_AFTER_CORRUPT          217
#define IDS_FILE_AFTER_COMPLETE         218
#define IDS_FILE_AFTER_FILE_NOT_OPENED  219
#define IDS_OPTIMIZING_FILES            220
#define IDS_RENAME_ERROR                221
#define IDS_RENAME_MESSAGE              222
#define IDS_DELETE_ERROR                223
#define IDS_FILE_AFTER_READ_ONLY   	224
#define IDS_OPTIMIZE_ERROR	   	225 
#define IDS_OPTIMIZE                    300
#define IDC_LIST_FILES                  301
#define IDS_CANCEL                      301
#define IDC_STATIC_FILES                401

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\layoutui\olesite.cxx ===
#include "layoutui.hxx"


STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, void** ppObject)
{
	if (riid==IID_IUnknown || riid==IID_IOleClientSite) 
        {
		*ppObject=(IOleClientSite*) this;
                AddRef();
        }	
        else 
        {
	        return E_NOINTERFACE;
	}
	return NO_ERROR;
}

STDMETHODIMP_(ULONG) COleClientSite::AddRef() 
{
    InterlockedIncrement( &_cReferences);
    return _cReferences;
}

STDMETHODIMP_(ULONG) COleClientSite::Release() 
{
    InterlockedDecrement(&_cReferences);
    if (_cReferences == 0)
    {
        delete this;
    }

    return _cReferences;
}

STDMETHODIMP COleClientSite::SaveObject( void)
{
    return E_FAIL;
}

STDMETHODIMP COleClientSite::GetMoniker( 
     /* [in] */ DWORD dwAssign,
    /* [in] */ DWORD dwWhichMoniker,
    /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmk)
{
    return S_OK;
}

STDMETHODIMP COleClientSite::GetContainer( 
    /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer)
{
    *ppContainer=NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP COleClientSite::ShowObject( void)
{
    return S_OK;
}

STDMETHODIMP COleClientSite::OnShowWindow( 
    /* [in] */ BOOL fShow)
{
    return S_OK;
}

STDMETHODIMP COleClientSite::RequestNewObjectLayout( void)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#if DBG == 1

#define _W4SPRINTF_
#include "printf.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//		w4vprintf
//  		w4dprintf
//		w4vdprintf
//		
//  History:    18-Oct-91   vich	Created
//	
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#if DBG == 1

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\dll\dummy.c ===
void __DummyRoutineUncalled__(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  _Assert
//              _PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92  BryanT    Switched to w4crt.h instead of wchar.h
//
//----------------------------------------------------------------------------

//
// This one file **always** uses debugging options
//

#if DBG == 1

#include <stdarg.h>

# include <debnot.h>
# include <dprintf.h>            // w4printf, w4dprintf prototypes

extern "C"
{
#include <windows.h>

#ifndef WIN32
#define MessageBoxA MessageBox
#define wsprintfA wsprintf
#endif
}

int APINOT _PopUpError(char const *szMsg,int iLine, char const *szFile);

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void _asdprintf(char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


void APINOT _Win4Assert(char const * szFile, int iLine, char const * szMessage)
{
    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = _PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifndef FLAT
            _asm int 3;
#else
            DebugBreak();
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifndef FLAT
        _asm int 3;
#else
        DebugBreak();
#endif
    }
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4InfoLevel(unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4InfoMask(unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

unsigned long APINOT _SetWin4AssertLevel(unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    _PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT _PopUpError(char const *szMsg,int iLine, char const *szFile)
{

    int id;
    static char szAssertCaption[100];
#ifdef WIN32
#undef wsprintfA
#undef MessageBoxA
#endif
    wsprintfA(szAssertCaption, "File: %s line %u", szFile,iLine);

    id = MessageBoxA(NULL,
                     (char *) szMsg,
                     (LPSTR) szAssertCaption,
		     MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL);
    return id;
}


//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT vdprintf(unsigned long ulCompMask,
              char const *pszComp,
              char const *ppszfmt,
              va_list     pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {

        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);

            // Chicago and Win32s debugging is usually through wdeb386
            // which needs carriage returns
#if WIN32 == 50 || WIN32 == 200
            w4dprintf("\r");
#endif
        }
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*
*******************************************************************************/

#if DBG == 1

#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS			// Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT	     1	     /* 1 means long is same size as int */
#  define SHORT_IS_INT	     0	     /* 1 means short is same size as int */
#  define PTR_IS_INT	     1	     /* 1 means ptr is same size as int */
#  define PTR_IS_LONG	     0	     /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT	     0	     /* 1 means long is same size as int */
#  define SHORT_IS_INT	     1	     /* 1 means short is same size as int */
#  define PTR_IS_INT	     0	     /* 1 means ptr is same size as int */
#  define PTR_IS_LONG	     1	     /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0	     /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if defined(_WIN64)
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#elif PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE	    /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001	  /* put plus or minus in front */
#define FL_SIGNSP     0x0002	  /* put space or minus in front */
#define FL_LEFT       0x0004	  /* left justify */
#define FL_LEADZERO   0x0008	  /* pad with leading zeros */
#define FL_LONG       0x0010	  /* long value given */
#define FL_SHORT      0x0020	  /* short value given */
#define FL_SIGNED     0x0040	  /* signed data given */
#define FL_ALTERNATE  0x0080	  /* alternate form requested */
#define FL_NEGATIVE   0x0100	  /* value is negative */
#define FL_FORCEOCTAL 0x0200	  /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400	  /* long double value given */
#define FL_WIDE	      0x0800	  /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,		    /* normal state; outputting literal chars */
    ST_PERCENT, 	    /* just read '%' */
    ST_FLAG,		    /* just read flag character */
    ST_WIDTH,		    /* just read width specifier */
    ST_DOT,		    /* just read '.' */
    ST_PRECIS,		    /* just read precision specifier */
    ST_SIZE,		    /* just read size specifier */
    ST_TYPE		    /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,		    /* character with no special meaning */
    CH_PERCENT, 	    /* '%' */
    CH_DOT,		    /* '.' */
    CH_STAR,		    /* '*' */
    CH_ZERO,		    /* '0' */
    CH_DIGIT,		    /* '1'..'9' */
    CH_FLAG,		    /* ' ', '+', '-', '#' */
    CH_SIZE,		    /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE		    /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";	/* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any	  */
/* character; while the uper nybble of the byte gives the next state	  */
/* to enter.  See the macros below the table for details.		  */
/*									  */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.								  */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)		\
	((c) < ' ' || (c) > 'x' ?	\
	    CH_OTHER			\
	:				\
	    lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)	\
	(lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
LOCAL(void) writestring(char *string,
			int len,
			struct w4io *f,
			int *pcchwritten,
			int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)	    (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)	    (*_cfltcvt_tab[3])(a)
#define _positive(a)	    (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.	It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*	The format string is parsed by using a finite state automaton
*	based on the current state and the current character read from
*	the format string.  Thus, looping is on a per-character basis,
*	not a per conversion specifier basis.  Once the format specififying
*	character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd; 	/* offset to add to number to get 'a'..'f' */
    char ch;		/* character just read */
    wchar_t wc;		/* wide character temp */
    wchar_t *pwc;	/* wide character temp pointer */
    int flags;		/* flag word -- see #defines above for flag values */
    enum STATE state;	/* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;		/* current conversion radix */
    int charsout;	/* characters currently written so far, -1 = IO error */
    int fldwidth;	/* selected field with -- 0 means default */
    int fwide;
    int precision;	/* selected precision -- -1 means default */
    char prefix[2];	/* numeric prefix -- up to two characters */
    int prefixlen;	/* length of prefix -- 0 means no prefix */
    int capexp; 	/* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;	/* non-zero = prodcue no output for this specifier */
    char *text; 	/* pointer text to be printed, not zero terminated */
    int textlen;	/* length of the text to be printed */
    char buffer[BUFFERSIZE];	/* buffer for conversions */

    charsout = 0;		/* no characters written yet */
    state = ST_NORMAL;		/* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
	chclass = find_char_class(ch);	/* find character class */
	state = find_next_state(chclass, state); /* find next state */

	/* execute code for each state */
	switch (state) {

	case ST_NORMAL:
	    /* normal state -- just write character */
	    f->writechar(ch, 1, f, &charsout);
	    break;

	case ST_PERCENT:
	    /* set default value of conversion parameters */
	    prefixlen = fldwidth = no_output = capexp = 0;
	    flags = 0;
	    precision = -1;
	    fwide = 0;
	    break;

	case ST_FLAG:
	    /* set flag based on which flag character */
	    switch (ch) {
	    case '-':
		flags |= FL_LEFT;	/* '-' => left justify */
		break;
	    case '+':
		flags |= FL_SIGN;	/* '+' => force sign indicator */
		break;
	    case ' ':
		flags |= FL_SIGNSP;	/* ' ' => force sign or space */
		break;
	    case '#':
		flags |= FL_ALTERNATE;	/* '#' => alternate form */
		break;
	    case '0':
		flags |= FL_LEADZERO;	/* '0' => pad with leading zeros */
		break;
	    }
	    break;

	case ST_WIDTH:
	    /* update width value */
	    if (ch == '*') {
		/* get width from arg list */
		fldwidth = get_int_arg(&argptr);
		if (fldwidth < 0) {
		    /* ANSI says neg fld width means '-' flag and pos width */
		    flags |= FL_LEFT;
		    fldwidth = -fldwidth;
		}
	    }
	    else {
		/* add digit to current field width */
		fldwidth = fldwidth * 10 + (ch - '0');
	    }
	    break;

	case ST_DOT:
	    /* zero the precision, since dot with no number means 0
	       not default, according to ANSI */
	    precision = 0;
	    break;

	case ST_PRECIS:
	    /* update precison value */
	    if (ch == '*') {
		/* get precision from arg list */
		precision = get_int_arg(&argptr);
		if (precision < 0)
		    precision = -1;	/* neg precision means default */
	    }
	    else {
		/* add digit to current precision */
		precision = precision * 10 + (ch - '0');
	    }
	    break;

	case ST_SIZE:
	    /* just read a size specifier, set the flags based on it */
	    switch (ch) {
#if !LONG_IS_INT
	    case 'l':
		flags |= FL_LONG;   /* 'l' => long int */
		break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
	    case 'L':
		flags |= FL_LONGDOUBLE; /* 'L' => long double */
		break;
#endif

#if !SHORT_IS_INT
	    case 'h':
		flags |= FL_SHORT;  /* 'h' => short int */
		break;
#endif
	    case 'w':
		flags |= FL_WIDE;   /* 'w' => wide character */
		break;
	    }
	    break;

	case ST_TYPE:
	    /* we have finally read the actual type character, so we	   */
	    /* now format and "print" the output.  We use a big switch	   */
	    /* statement that sets 'text' to point to the text that should */
	    /* be printed, and 'textlen' to the length of this text.	   */
	    /* Common code later on takes care of justifying it and	   */
	    /* other miscellaneous chores.  Note that cases share code,    */
	    /* in particular, all integer formatting is doen in one place. */
	    /* Look at those funky goto statements!			   */

	    switch (ch) {

	    case 'c': {
		/* print a single character specified by int argument */
		wc = (wchar_t) get_int_arg(&argptr);	/* get char to print */
		* (wchar_t *) buffer = wc;
		text = buffer;
		textlen = 1;	    /* print just a single character */
	    }
	    break;

	    case 'S': {
		/* print a Counted String

		int i;
		char *p;       /* temps */
                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

		pstr = get_ptr_arg(&argptr);
		if (pstr == NULL || pstr->Buffer == NULL) {
		    /* null ptr passed, use special string */
		    text = nullstring;
                    textlen = strlen(text);
		    flags &= ~FL_WIDE;
		} else {
                    text = pstr->Buffer;
                    textlen = pstr->Length;
                }

	    }
	    break;

	    case 's': {
		/* print a string --				*/
		/* ANSI rules on how much of string to print:	*/
		/*   all if precision is default,		*/
		/*   min(precision, length) if precision given. */
		/* prints '(null)' if a null string is passed	*/

		int i;
		char *p;       /* temps */

		text = get_ptr_arg(&argptr);
		if (text == NULL) {
		    /* null ptr passed, use special string */
		    text = nullstring;
		    flags &= ~FL_WIDE;
		}

		/* At this point it is tempting to use strlen(), but */
		/* if a precision is specified, we're not allowed to */
		/* scan past there, because there might be no null   */
		/* at all.  Thus, we must do our own scan.	     */

		i = (precision == -1) ? INT_MAX : precision;

		/* scan for null upto i characters */
		if (flags & FL_WIDE) {
		    pwc = (wchar_t *) text;
		    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
			++pwc;
			if (wc & 0xff00) {	// if high byte set,
			    break;		// error will be indicated
			}
		    }
		    textlen = pwc - (wchar_t *) text;  /* length of string */
		} else {
		    p = text;
		    while (i-- && *p) {
			++p;
		    }
		    textlen = p - text;    /* length of the string */
		}
	    }
	    break;

	    case 'n': {
		/* write count of characters seen so far into */
		/* short/int/long thru ptr read from args */

		void *p;	    /* temp */

		p = get_ptr_arg(&argptr);

		/* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
		if (flags & FL_LONG)
		    *(long *)p = charsout;
		else
#endif

#if !SHORT_IS_INT
		if (flags & FL_SHORT)
		    *(short *)p = (short) charsout;
		else
#endif
		    *(int *)p = charsout;

		no_output = 1;		    /* force no output */
	    }
	    break;


#ifndef NOFLOATS
	    case 'E':
	    case 'G':
		capexp = 1;		    /* capitalize exponent */
		ch += 'a' - 'A';	    /* convert format char to lower */
		/* DROP THROUGH */
	    case 'e':
	    case 'f':
	    case 'g':	{
		/* floating point conversion -- we call cfltcvt routines */
		/* to do the work for us.				 */
		flags |= FL_SIGNED;	    /* floating point is signed conversion */
		text = buffer;		    /* put result in buffer */
		flags &= ~FL_WIDE;	    /* 8 bit string */

		/* compute the precision value */
		if (precision < 0)
		    precision = 6;	/* default precision: 6 */
		else if (precision == 0 && ch == 'g')
		    precision = 1;	/* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
		/* do the conversion */
		if (flags & FL_LONGDOUBLE) {
		    _cldcvt(argptr, text, ch, precision, capexp);
		    va_arg(argptr, LONGDOUBLE);
		}
		else
#endif
		{
		    _cfltcvt(argptr, text, ch, precision, capexp);
		    va_arg(argptr, DOUBLE);
		}

		/* '#' and precision == 0 means force a decimal point */
		if ((flags & FL_ALTERNATE) && precision == 0)
		    _forcdecpt(text);

		/* 'g' format means crop zero unless '#' given */
		if (ch == 'g' && !(flags & FL_ALTERNATE))
		    _cropzeros(text);

		/* check if result was negative, save '-' for later */
		/* and point to positive part (this is for '0' padding) */
		if (*text == '-') {
		    flags |= FL_NEGATIVE;
		    ++text;
		}

		textlen = strlen(text);     /* compute length of text */
	    }
	    break;
#endif // NOFLOATS

	    case 'd':
	    case 'i':
		/* signed decimal output */
		flags |= FL_SIGNED;
		radix = 10;
		goto COMMON_INT;

	    case 'u':
		radix = 10;
		goto COMMON_INT;

	    case 'p':
		/* write a pointer -- this is like an integer or long */
		/* except we force precision to pad with zeros and */
		/* output in big hex. */

		precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
		flags |= FL_LONG;	/* assume we're converting a long */
#endif
		/* DROP THROUGH to hex formatting */

	    case 'C':
	    case 'X':
		/* unsigned upper hex output */
		hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
		goto COMMON_HEX;

	    case 'x':
		/* unsigned lower hex output */
		hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
		/* DROP THROUGH TO COMMON_HEX */

	    COMMON_HEX:
		radix = 16;
		if (flags & FL_ALTERNATE) {
		    /* alternate form means '0x' prefix */
		    prefix[0] = '0';
		    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);	/* 'x' or 'X' */
		    prefixlen = 2;
		}
		goto COMMON_INT;

	    case 'o':
		/* unsigned octal output */
		radix = 8;
		if (flags & FL_ALTERNATE) {
		    /* alternate form means force a leading 0 */
		    flags |= FL_FORCEOCTAL;
		}
		/* DROP THROUGH to COMMON_INT */

	    COMMON_INT: {
		/* This is the general integer formatting routine. */
		/* Basically, we get an argument, make it positive */
		/* if necessary, and convert it according to the */
		/* correct radix, setting text and textlen */
		/* appropriately. */

		unsigned long number;	/* number to convert */
		int digit;		/* ascii value of digit */
		long l; 		/* temp long value */

		/* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
		if (flags & FL_LONG)
		    l = get_long_arg(&argptr);
		else
#endif

#if !SHORT_IS_INT
		if (flags & FL_SHORT) {
		    if (flags & FL_SIGNED)
			l = (short) get_int_arg(&argptr); /* sign extend */
		    else
			l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
		}
		else
#endif
		{
		    if (flags & FL_SIGNED)
			l = get_int_arg(&argptr); /* sign extend */
		    else
			l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
		}

		/* 2. check for negative; copy into number */
		if ( (flags & FL_SIGNED) && l < 0) {
		    number = -l;
		    flags |= FL_NEGATIVE;   /* remember negative sign */
		}
		else {
		    number = l;
		}

		/* 3. check precision value for default; non-default */
		/*    turns off 0 flag, according to ANSI. */
		if (precision < 0)
		    precision = 1;		/* default precision */
		else
		    flags &= ~FL_LEADZERO;

		/* 4. Check if data is 0; if so, turn off hex prefix */
		if (number == 0)
		    prefixlen = 0;

		/* 5. Convert data to ASCII -- note if precision is zero */
		/*    and number is zero, we get no digits at all.	 */

		text = &buffer[BUFFERSIZE-1];	// last digit at end of buffer
		flags &= ~FL_WIDE;		// 8 bit characters

		while (precision-- > 0 || number != 0) {
		    digit = (int)(number % radix) + '0';
		    number /= radix;		/* reduce number */
		    if (digit > '9') {
			/* a hex digit, make it a letter */
			digit += hexadd;
		    }
		    *text-- = (char)digit;	/* store the digit */
		}

		textlen = (char *)&buffer[BUFFERSIZE-1] - text; /* compute length of number */
		++text; 	/* text points to first digit now */


		/* 6. Force a leading zero if FORCEOCTAL flag set */
		if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
		    *--text = '0';
		    ++textlen;		/* add a zero */
		}
	    }
	    break;
	    }

	    /* At this point, we have done the specific conversion, and */
	    /* 'text' points to text to print; 'textlen' is length.  Now we */
	    /* justify it, put on prefixes, leading zeros, and then */
	    /* print it. */

	    if (!no_output) {
		int padding;	/* amount of padding, negative means zero */

		if (flags & FL_SIGNED) {
		    if (flags & FL_NEGATIVE) {
			/* prefix is a '-' */
			prefix[0] = '-';
			prefixlen = 1;
		    }
		    else if (flags & FL_SIGN) {
			/* prefix is '+' */
			prefix[0] = '+';
			prefixlen = 1;
		    }
		    else if (flags & FL_SIGNSP) {
			/* prefix is ' ' */
			prefix[0] = ' ';
			prefixlen = 1;
		    }
		}

		/* calculate amount of padding -- might be negative, */
		/* but this will just mean zero */
		padding = fldwidth - textlen - prefixlen;

		/* put out the padding, prefix, and text, in the correct order */

		if (!(flags & (FL_LEFT | FL_LEADZERO))) {
		    /* pad on left with blanks */
		    f->writechar(' ', padding, f, &charsout);
		}

		/* write prefix */
		writestring(prefix, prefixlen, f, &charsout, 0);

		if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
		    /* write leading zeros */
		    f->writechar('0', padding, f, &charsout);
		}

		/* write text */
		writestring(text, textlen, f, &charsout, flags & FL_WIDE);

		if (flags & FL_LEFT) {
		    /* pad on right with blanks */
		    f->writechar(' ', padding, f, &charsout);
		}

		/* we're done! */
	    }
	    break;
	}
    }

    return charsout;	    /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif



/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len	     - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide	     - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
	char *string,
	int len,
	struct w4io *f,
	int *pcchwritten,
	int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
	pwc = (wchar_t *) string;
	while (len-- > 0) {
	    if (*pwc & 0xff00) {
		f->writechar('^', 1, f, pcchwritten);
	    }
	    f->writechar((char) *pwc++, 1, f, pcchwritten);
	}
    } else {
	while (len-- > 0) {
	    f->writechar(*string++, 1, f, pcchwritten);
	}
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <stdarg.h>
#include <limits.h>
#include <windows.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifndef FLAT
#     define OutputDebugStringA OutputDebugString
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugStringA("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugStringA(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\dll\cairo\makefile.inc ===
obj\i386\storag32.def: storag32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\dll\chicago\makefile.inc ===
obj\i386\storag32.def: storag32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\common\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(FLAT)
#  ifndef FLAT
#    define FLAT
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

struct w4io
{
    union
    {
	struct
	{
	    wchar_t *_pwcbuf;	// wchar_t output buffer
	    wchar_t *_pwcstart;
	} wc;
	struct
	{
	    char *_pchbuf;	// char output buffer
	    char *_pchstart;
	} ch;
    } buf ;
    unsigned int cchleft;	// output buffer character count
    void (_cdecl *writechar)(int ch,
			     int num,
			     struct w4io *f,
			     int *pcchwritten);
};

#define pwcbuf		buf.wc._pwcbuf
#define pwcstart	buf.wc._pwcstart
#define pchbuf		buf.ch._pchbuf
#define pchstart	buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\dll\daytona\makefile.inc ===
obj\$(TARGET_DIRECTORY)\storag32.def: storag32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\chinst.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       chinst.cxx
//
//  Contents:   DocFile child instance management code
//
//  History:    19-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

// Permissions checked in the less-restrictive rule
#define TCANTSET DF_READ
#define DCANTSET (DF_READ | DF_WRITE)
#define CANTCLEAR (DF_DENYREAD | DF_DENYWRITE)

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::Add, private
//
//  Synopsis:   Registers an instance of a child
//
//  Arguments:  [prv] - Child
//
//  History:    17-Oct-91       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_Add)
#endif

void CChildInstanceList::Add(PRevertable *prv)
{
    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::Add(%p)\n", prv));
    prv->_prvNext = _prvHead;
    _prvHead = P_TO_BP(CBasedRevertablePtr, prv);
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::Add\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FindByName, private
//
//  Synopsis:   Finds a child instance by name
//
//  Arguments:  [pdfn] - Name
//
//  Returns:    Pointer to instance or NULL
//
//  History:    12-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_FindByName)
#endif

PRevertable *CChildInstanceList::FindByName(CDfName const *pdfn)
{
    PRevertable *prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FindByName:%p(%ws)\n",
                this, pdfn->GetBuffer()));
    for (prv = BP_TO_P(PRevertable *, _prvHead);
         prv;
         prv = BP_TO_P(PRevertable *, prv->_prvNext))
    {
        if (prv->_dfn.IsEqual(pdfn))
            return prv;
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FindByName\n"));
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChildInstanceList::FlushBufferedData, private
//
//  Synopsis:   Calls each child, instructing it to flush property data.
//
//  Arguments:  [recursionlevel] -- current level in hierachy below initial
//                                  entry point.
//
//  Returns:    SCODE
//
//  History:    5-May-1995       BillMo Created
//
//----------------------------------------------------------------------------

#ifdef NEWPROPS

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_FindByName)
#endif

SCODE CChildInstanceList::FlushBufferedData(int recursionlevel)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::FlushBufferedData:%p\n",
                this));

    for (prv = BP_TO_P(PRevertable *, _prvHead);
         prv && sc == S_OK;
         prv = BP_TO_P(PRevertable *, prv->_prvNext))
    {
        sc = prv->FlushBufferedData(recursionlevel + 1);
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::FlushBufferedData\n"));
    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::DeleteByName, private
//
//  Synopsis:   Removes an instance from the instance list
//              and reverts it
//
//  Arguments:  [pdfn] - Name or NULL
//
//  History:    17-Oct-91       DrewB   Created
//
//  Notes:      The entry does not have to exist
//              There can be multiple entries
//              If name is NULL, all entries match
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_DeleteByName)
#endif

void CChildInstanceList::DeleteByName(CDfName const *pdfn)
{
    CBasedRevertablePtr *pprv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::DeleteByName(%ws)\n",
                pdfn->GetBuffer()));
    for (pprv = &_prvHead; *pprv; )
        if (NULL == pdfn || (*pprv)->_dfn.IsEqual(pdfn))
        {
            (*pprv)->RevertFromAbove();
            *pprv = (*pprv)->_prvNext;
        }
        else
            pprv = &(*pprv)->_prvNext;
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::DeleteByName\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::RemoveRv, private
//
//  Synopsis:   Removes a specific instance from the instance list
//
//  Arguments:  [prv] - Instance
//
//  History:    17-Oct-91       DrewB   Created
//
//  Notes:      The entry does not have to exist
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_RemoveRv)
#endif

void CChildInstanceList::RemoveRv(PRevertable *prvRv)
{
    CBasedRevertablePtr *prv;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::RemoveRv(%p)\n", prvRv));
    for (prv = &_prvHead; *prv; prv = &(*prv)->_prvNext)
        if (*prv == prvRv)
        {
            *prv = (*prv)->_prvNext;
            break;
        }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::RemoveRv\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CChildInstanceList::IsDenied, private
//
//  Synopsis:   Checks the parent instantiation list for a previous
//              instance of the given child with DENY flags on
//              Also determines whether child mode flags are
//              less restrictive than the parent's
//
//  Arguments:  [pdfn] - Instance name
//              [dfCheck] - Access modes to check for denial
//              [dfAgainst] - Access modes to check against
//
//  Returns:    Appropriate status code
//
//  History:    17-Oct-91       DrewB   Created
//              28-Oct-92       AlexT   Converted to names
//
//  Notes:      The instance doesn't have to be in the list.
//              If it isn't, it's not denied
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CChildInstanceList_IsDenied)
#endif

SCODE CChildInstanceList::IsDenied(CDfName const *pdfn,
                                   DFLAGS const dfCheck,
                                   DFLAGS const dfAgainst)
{
    PRevertable *prv;
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CChildInstanceList::IsDenied("
                "%p, %lX, %lX)\n", pdfn, dfCheck, dfAgainst));

    olAssert(pdfn != NULL && aMsg("IsDenied, null name"));

    // Check to see if permissions are less restrictive than
    // parent permissions
    // This checks to see that a child isn't specifying
    // a permission that its parent doesn't
    // For example, giving read permission when the parent
    // doesn't
    if ((~dfAgainst & dfCheck &
         (P_TRANSACTED(dfAgainst) ? TCANTSET : DCANTSET)) ||
        (dfAgainst & ~dfCheck & CANTCLEAR))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // Check for DENY_*
    olAssert((DF_DENYALL >> DF_DENIALSHIFT) == DF_READWRITE);
    for (prv = BP_TO_P(PRevertable *, _prvHead);
         prv != NULL; prv = prv->GetNext())
    {
        if (prv->_dfn.IsEqual(pdfn))
        {
            // Check for existing instance with DENY_* mode
            if ((((prv->GetDFlags() & DF_DENYALL) >> DF_DENIALSHIFT) &
                 dfCheck) != 0 ||
            // Check for instance with permission already given that
            // new instance wants to deny
                (((dfCheck & DF_DENYALL) >> DF_DENIALSHIFT) &
                 prv->GetDFlags()) != 0)
            {
                sc = STG_E_ACCESSDENIED;
                break;
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out CChildInstanceList::IsDenied\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member: CChildInstanceList::EmptyCache, public
//
//  Synopsis:   empties the stream caches
//
//  History:    22-Jun-99   HenryLee  Created
//
//---------------------------------------------------------------

void CChildInstanceList::EmptyCache ()
{
    for (PRevertable *prv = BP_TO_P(PRevertable *, _prvHead);
         prv != NULL; prv = prv->GetNext())
    {
        prv->EmptyCache();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dfhead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    26-Oct-92 AlexT    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <ole2.h>

#include <propset.h>
#include <propapi.h>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <propstm.hxx>

#include <msf.hxx>

#include <olesem.hxx>
#include <dfexcept.hxx>
#include <docfilep.hxx>
#include <publicdf.hxx>
#include <psstream.hxx>
#include <wdocfile.hxx>
#include <dffuncs.hxx>
#include <funcs.hxx>
#include <debug.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\cdocfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       cdocfile.cxx
//
//  Contents:   Implementation of CDocFile methods for DocFiles
//
//  History:    11-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <vectfunc.hxx>

//+--------------------------------------------------------------
//
//  Member:     CDocFile::InitFromEntry, public
//
//  Synopsis:   Creation/Instantiation constructor for embeddings
//
//  Arguments:  [pstghParent] - Parent handle
//              [pdfn] - Name
//              [fCreate] - Create/Instantiate
//              [dwType] - Type of entry
//
//  Returns:    Appropriate status code
//
//  History:    16-Dec-91       DrewB   Created
//
//  Algorithm:  Create or get the entry from the multistream
//
//---------------------------------------------------------------

SCODE CDocFile::InitFromEntry(CStgHandle *pstghParent,
                              CDfName const *pdfn,
                              BOOL const fCreate)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::InitFromEntry(%p, %ws, %d)\n",
                pstghParent, pdfn, fCreate));
    if (fCreate)
        sc = pstghParent->CreateEntry(pdfn, STGTY_STORAGE, &_stgh);
    else
        sc = pstghParent->GetEntry(pdfn, STGTY_STORAGE, &_stgh);

    if (SUCCEEDED(sc))
        AddRef();
    olDebugOut((DEB_ITRACE, "Out CDocFile::InitFromEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::CreateDocFile, public
//
//  Synopsis:   Creates a DocFile object in a parent
//
//  Arguments:  [pdfn] - Name of DocFile
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry
//              [ppdfDocFile] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    11-Dec-91       DrewB   Created
//
//  Algorithm:  Allocate new docfile and init from given entry
//
//---------------------------------------------------------------

SCODE CDocFile::CreateDocFile(CDfName const *pdfn,
                              DFLAGS const df,
                              DFLUID dlSet,
                              PDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateDocFile:%p("
                "%ws, %X, %lu, %p)\n", this, pdfn, df, dlSet,
                ppdfDocFile));

    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDocFile::GetNewLuid(_pdfb->GetMalloc());

    pdf = GetReservedDocfile(dlSet);
    olAssert(pdf != NULL && aMsg("Reserved Docfile not found"));

    if (pdf != NULL)
        olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, TRUE));

    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdf:
    pdf->ReturnToReserve(BP_TO_P(CDFBasis *,_pdfb));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetDocFile, public
//
//  Synopsis:   Instantiates an existing docfile
//
//  Arguments:  [pdfn] - Name of stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppdfDocFile] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    11-Dec-91       DrewB   Created
//
//  Algorithm:  Allocate new docfile and init from given entry
//
//---------------------------------------------------------------

SCODE CDocFile::GetDocFile(CDfName const *pdfn,
                           DFLAGS const df,
                           PDocFile **ppdfDocFile)
{
    CDocFile *pdf;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n", this, pdfn, df, ppdfDocFile));

    UNREFERENCED_PARM(df);

    DFLUID dl = CDocFile::GetNewLuid(_pdfb->GetMalloc());
    olMem(pdf = new (_pdfb->GetMalloc()) CDocFile(dl,
                                                  BP_TO_P(CDFBasis *, _pdfb)));

    olChkTo(EH_pdf, pdf->InitFromEntry(&_stgh, pdfn, FALSE));

    *ppdfDocFile = pdf;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdf:
    delete pdf;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::RenameEntry, public
//
//  Synopsis:   Renames a child
//
//  Arguments:  [pdfnName] - Old name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    12-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::RenameEntry(CDfName const *pdfnName,
                            CDfName const *pdfnNewName)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::RenameEntry(%ws, %ws)\n",
                pdfnName, pdfnNewName));
    sc = _stgh.RenameEntry(pdfnName, pdfnNewName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::RenameEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently destroys a child
//
//  Arguments:  [pdfnName] - Name of child
//              [fClean] - Ignored
//
//  Returns:    Appropriate status code
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::DestroyEntry(CDfName const *pdfnName,
                             BOOL fClean)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));
    UNREFERENCED_PARM(fClean);
    sc = _stgh.DestroyEntry(pdfnName);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DestroyEntry\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::IsEntry, public
//
//  Synopsis:   Determines whether the given object is a member
//              of the DocFile
//
//  Arguments:  [pdfnName] - Name
//              [peb] - Entry buffer to fill in
//
//  Returns:    Appropriate status code
//
//  Modifies:   [peb]
//
//  History:    07-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::IsEntry(CDfName const *pdfnName,
                        SEntryBuffer *peb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::IsEntry(%ws, %p)\n",
                pdfnName, peb));
    sc = _stgh.IsEntry(pdfnName, peb);
    olDebugOut((DEB_ITRACE, "Out CDocFile::IsEntry => %lu, %lu, %lu\n",
                sc, peb->luid, peb->dwType));
    return sc;
}

#ifdef INDINST
//+--------------------------------------------------------------
//
//  Member:     CDocFile::Destroy, public
//
//  Synopsis:   Destroys the DocFile
//
//  History:    12-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

void CDocFile::Destroy(void)
{
    olDebugOut((DEB_ITRACE, "In  CDocFile::Destroy()\n"));
    olAssert(_cReferences == 1);
    olVerSucc(_stgh.DestroyEntry(NULL);
    CDocFile::Release();
    olDebugOut((DEB_ITRACE, "Out CDocFile::Destroy\n"));
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetTime, public
//
//  Synopsis:   Gets a time
//
//  Arguments:  [wt] - Which time
//              [ptm] - Time return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ptm]
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    return _stgh.GetTime(wt, ptm);
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::GetAllTimes, public
//
//  Synopsis:   Gets all time values
//
//  Arguments:  [patm] - Access Time
//              [pmtm] - Modification Time
//		[pctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:   [patm]
//		[pmtm]
//		[pctm]	
//
//  History:    26-May-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CDocFile::GetAllTimes(TIME_T *patm, TIME_T *pmtm, TIME_T *pctm)
{
    return _stgh.GetAllTimes(patm, pmtm, pctm);
}
//+--------------------------------------------------------------
//
//  Member:     CDocFile::SetAllTimes, public
//
//  Synopsis:   Sets all time values
//
//  Arguments:  [atm] - Access Time
//              [mtm] - Modification Time
//				[ctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:  	
//
//  History:    22-Nov-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CDocFile::SetAllTimes(TIME_T atm, TIME_T mtm, TIME_T ctm)
{
    return _stgh.SetAllTimes(atm, mtm, ctm);
}


//+--------------------------------------------------------------
//
//  Member:     CDocFile::SetTime, public
//
//  Synopsis:   Sets a time
//
//  Arguments:  [wt] - Which time
//              [tm] - New time
//
//  Returns:    Appropriate status code
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::SetTime(WHICHTIME wt, TIME_T tm)
{
    return _stgh.SetTime(wt, tm);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetClass, public
//
//  Synopsis:   Gets the class ID
//
//  Arguments:  [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetClass(CLSID *pclsid)
{
    return _stgh.GetClass(pclsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - New class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetClass(REFCLSID clsid)
{
    return _stgh.SetClass(clsid);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::GetStateBits, public
//
//  Synopsis:   Gets the state bits
//
//  Arguments:  [pgrfStateBits] - State bits return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pgrfStateBits]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    return _stgh.GetStateBits(pgrfStateBits);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - Bits to set
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return _stgh.SetStateBits(grfStateBits, grfMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       dffuncs.cxx
//
//  Contents:   Private support functions for the DocFile code
//
//  Methods:    StartMS
//              DeleteContents
//
//  History:    11-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Method:     CDocFile::DeleteContents, public
//
//  Synopsis:   Deletes all entries in a DocFile recursing on entries
//              with children
//
//  Returns:    Appropriate status code
//
//  History:    25-Sep-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::DeleteContents(void)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::DeleteContents()\n"));
    sc = _stgh.DestroyEntry(NULL);
    olDebugOut((DEB_ITRACE, "Out CDocFile::DeleteContents\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CDocFile::ApplyChanges, public
//
//  Synopsis:   Applies a list of updates to a docfile
//              Creates source entries in destination and links
//              them to child instances in the given TL
//
//  Arguments:  [ulChanged] - List of changes
//
//  Returns:    Appropriate status code
//
//  History:    12-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::ApplyChanges(CUpdateList &ulChanged)
{
    SCODE sc = S_OK;
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CDocFile::ApplyChanges(%p)\n",
                ulChanged.GetHead()));

    for (pud = ulChanged.GetHead(); pud; pud = pud->GetNext())
    {
        if (pud->IsDelete())
            olChk(DestroyEntry(pud->GetOriginalName(), FALSE));
        else if (pud->IsRename())
            olChk(RenameEntry(pud->GetOriginalName(),
                              pud->GetCurrentName()));
        else
        {
            olAssert(pud->IsCreate());
            olChk(CreateFromUpdate(pud, this, DF_WRITE));
        }
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::ApplyChanges\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::CopyTo, public
//
//  Synopsis:   Copies the contents of one DocFile to another
//
//  Arguments:  [pdfTo] - Destination DocFile
//              [dwFlags] - Control flags
//              [snbExclude] - Partial instantiation list
//
//  Returns:    Appropriate status code
//
//  History:    26-Sep-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::CopyTo(CDocFile *pdfTo,
                       DWORD dwFlags,
                       SNBW snbExclude)
{
    CDfName dfnKey;
    SIterBuffer ib;
    PSStream *psstFrom, *psstTo;
    CDocFile *pdfFromChild, *pdfToChild;
    DFLUID dlLUID = DF_NOLUID;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CopyTo:%p(%p, %lX, %p)\n", this,
               pdfTo, dwFlags, snbExclude));
    for (;;)
    {
	if (FAILED(FindGreaterEntry(&dfnKey, &ib, NULL)))
	    break;
        dfnKey.Set(&ib.dfnName);

        switch(REAL_STGTY(ib.type))
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            olChkTo(EH_pwcsName, GetDocFile(&ib.dfnName, DF_READ, ib.type,
                                            (PDocFile **)&pdfFromChild));
            // Destination must be a direct docfile
            olChkTo(EH_Get, CDocFile::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
            olChkTo(EH_Reserve, pdfTo->CreateDocFile(&ib.dfnName, DF_WRITE,
                                                     dlLUID, ib.type,
                                                   (PDocFile **)&pdfToChild));
            if (dwFlags & CDF_EXACT)
                pdfToChild->CopyTimesFrom(pdfFromChild);

            CLSID clsid;
            olChkTo(EH_Create, pdfFromChild->GetClass(&clsid));
            olChkTo(EH_Create, pdfToChild->SetClass(clsid));

            DWORD grfStateBits;
            olChkTo(EH_Create, pdfFromChild->GetStateBits(&grfStateBits));
            olChkTo(EH_Create, pdfToChild->SetStateBits(grfStateBits,
                                                        0xffffffff));

            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && NameInSNB(&ib.dfnName, snbExclude) ==
                  S_OK))
                olChkTo(EH_Create,
                        pdfFromChild->CopyTo(pdfToChild, dwFlags, NULL));

            pdfFromChild->Release();
            pdfToChild->Release();
            break;

        case STGTY_STREAM:
            olChkTo(EH_pwcsName, GetStream(&ib.dfnName, DF_READ,
                                           ib.type, &psstFrom));
            // Destination must be a direct docfile
            olChkTo(EH_Get,
                    CDirectStream::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
            
            olChkTo(EH_Reserve,
                    pdfTo->CreateStream(&ib.dfnName, DF_WRITE, dlLUID,
                                        ib.type, &psstTo));

            if ((dwFlags & CDF_ENTRIESONLY) == 0 &&
                !(snbExclude && NameInSNB(&ib.dfnName, snbExclude) ==
                  S_OK))
                olChkTo(EH_Create, CopySStreamToSStream(psstFrom, psstTo));

            psstFrom->Release();
            psstTo->Release();
            break;

        default:
            olAssert(!aMsg("Unknown entry type in CDocFile::CopyTo"));
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::CopyTo\n"));
    return S_OK;

 EH_Create:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE)
        pdfToChild->Release();
    else if (REAL_STGTY(ib.type) == STGTY_STREAM)
        psstTo->Release();
    olAssert(&ib.dfnName);
    olVerSucc(pdfTo->DestroyEntry(&ib.dfnName, TRUE));
    goto EH_Get;
 EH_Reserve:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE)
        CDocFile::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
    else if (REAL_STGTY(ib.type) == STGTY_STREAM)
        CDirectStream::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Get:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE)
        pdfFromChild->Release();
    else if (REAL_STGTY(ib.type) == STGTY_STREAM)
        psstFrom->Release();
 EH_pwcsName:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dfbasis.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dfbasis.cxx
//
//  Contents:   Docfile basis implementation
//
//  History:    28-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <sstream.hxx>
#include <ole.hxx>
#include <entry.hxx>
#include <smalloc.hxx>
#include <lock.hxx>

size_t CDFBasis::_aReserveSize[CDFB_CLASSCOUNT] =
{
    sizeof(CDocFile),
    sizeof(CDirectStream),
    sizeof(CWrappedDocFile),
    sizeof(CTransactedStream)
};

//+--------------------------------------------------------------
//
//  Member:     CDFBasis::Release, public
//
//  Synopsis:   Decrease reference count and free memory
//
//  History:    02-Mar-92       DrewB   Created
//		24-Jul-95	SusiA   Take mutex prior to delete
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDFBasis_vRelease)
#endif

void CDFBasis::vRelease(void)
{
    LONG lRet;
    
    olDebugOut((DEB_ITRACE, "In  CDFBasis::Release()\n"));
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
#if !defined(MULTIHEAP)
        //take the mutex here instead of in the allocator.
        g_smAllocator.GetMutex()->Take(DFM_TIMEOUT); 
#endif
	delete this;
#if !defined(MULTIHEAP)
	g_smAllocator.GetMutex()->Release();
#endif
 
    
    }
    olDebugOut((DEB_ITRACE, "Out CDFBasis::Release()\n"));
}

#ifdef DIRECTWRITERLOCK
//+--------------------------------------------------------------
//
//  Member:     CDFBasis::TryReadLocks, public
//
//  Synopsis:   attempts to obtain read locks
//
//  Arguments:  [ulOpenLock] - lock index for this open docfile
//              [ulMask]     - range lock mask
//
//  History:    30-Apr-96    HenryLee     Created
//
//  Notes:      tree mutex and update lock must be taken
//
//---------------------------------------------------------------
HRESULT CDFBasis::TryReadLocks (CGlobalContext *pgc, ULONG ulMask) 
{
    HRESULT sc = S_OK;
    ULARGE_INTEGER cbLength = {0,0};
    ULARGE_INTEGER ulOffset = {0,0};
    ILockBytes *plst = GetBase();

    olAssert (pgc != NULL);

    ULISetLow(cbLength, COPENLOCKS);
        
    ULISetLow(ulOffset, ODIRECTWRITERLOCK & ulMask);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    olVerSucc(plst->UnlockRegion(ulOffset,cbLength,LOCK_ONLYONCE));

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDFBasis::WaitForWriteAccess, public
//
//  Synopsis:   attempts to obtain write access
//
//  Arguments:  [dwTimeout]  - in milliseconds
//              [ulOpenLock] - lock index for this open docfile
//
//  History:    30-Apr-96    HenryLee     Created
//
//  Notes:      tree mutex must be taken
//
//---------------------------------------------------------------
HRESULT CDFBasis::WaitForWriteAccess (DWORD dwTimeout, CGlobalContext *pgc)
{
    olDebugOut((DEB_ITRACE,"In  CDFBasis::WaitForWriteAccess(%d)\n",dwTimeout));

    HRESULT sc = S_OK;
    BOOL    fUpdateLocked = FALSE;
    BOOL    fDenyLocked = FALSE;
    ULARGE_INTEGER cbLength = {0,0};
    ULARGE_INTEGER ulOffset = {0,0};
    ILockBytes *plst = GetBase();
    const ULONG ulMask = 0xFFFFFFFF;

    // lock out other opens
    ULISetLow(ulOffset, OUPDATE & ulMask);
    ULISetLow(cbLength, 1);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    fUpdateLocked = TRUE;

    // lock out future readers
    ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
    ULISetLow(cbLength, COPENLOCKS);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    fDenyLocked = TRUE;

    // try to identify current readers
    sc = TryReadLocks (pgc, ulMask);

    if (sc == STG_E_LOCKVIOLATION && dwTimeout != 0)
    {
        const DWORD dwWaitInitial = 100;
        DWORD dwWait = dwWaitInitial, dwWaitTotal = 0; 
        for (;;)
        {
            sc = TryReadLocks (pgc, ulMask);
            if (sc != STG_E_LOCKVIOLATION || dwWaitTotal >= dwTimeout)
            {
                break;
            }
            Sleep(dwWait);
            dwWaitTotal += dwWait;
            dwWait *= 2;
        }
    }

EH_Err:
    if (fDenyLocked && !SUCCEEDED(sc))

    {
        ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
        ULISetLow(cbLength, COPENLOCKS);
        olVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }

    if (fUpdateLocked)
    {
        ULISetLow(ulOffset, OUPDATE & ulMask);
        ULISetLow(cbLength, 1);
        olVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }

    if (sc == STG_E_LOCKVIOLATION) sc = STG_E_INUSE;
    if (SUCCEEDED(sc)) _fWriteLocked = TRUE;

    olDebugOut((DEB_ITRACE,"Out CDFBasis::WaitForWriteAccess(%x)\n", sc));
    return sc;
};

//+--------------------------------------------------------------
//
//  Member:     CDFBasis::ReleaseWriteAccess, public
//
//  Synopsis:   relinquishes write access
//              releases all locks except for ulOpenLock
//
//  History:    30-Apr-96    HenryLee     Created
//
//  Notes:      tree mutex must be taken
//
//---------------------------------------------------------------
HRESULT CDFBasis::ReleaseWriteAccess ()
{
    olDebugOut((DEB_ITRACE,"In  CDFBasis::ReleaseWriteAccess()\n"));

    HRESULT sc = S_OK;
    BOOL    fUpdateLocked = FALSE;
    ULARGE_INTEGER cbLength = {0,0};
    ULARGE_INTEGER ulOffset = {0,0};
    const ULONG ulMask = 0xFFFFFFFF;
    ILockBytes *plst = GetBase();

    // lock out other opens
    ULISetLow(ulOffset, OUPDATE & ulMask);
    ULISetLow(cbLength, 1);
    olChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    fUpdateLocked = TRUE;

    // undo WaitForWriteAccess
    ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
    ULISetLow(cbLength, COPENLOCKS);
    olChk(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));

EH_Err:
    if (fUpdateLocked)
    {
        ULISetLow(ulOffset, OUPDATE & ulMask);
        ULISetLow(cbLength, 1);
        olVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }

    if (SUCCEEDED(sc)) _fWriteLocked = FALSE;

    olDebugOut((DEB_ITRACE,"Out CDFBasis::ReleaseWriteAccess(%x)\n", sc));
    return sc;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\debug.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992
//
//  File:       debug.cxx
//
//  Contents:   Debugging routines
//
//  History:    07-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#if DBG == 1
//#include <w4wchar.h>

#include <stdarg.h>
#include <dfdeb.hxx>
#include <logfile.hxx>
#include <df32.hxx>

//+-------------------------------------------------------------
//
//  Function:   DfDebug, public
//
//  Synopsis:   Sets debugging level
//
//---------------------------------------------------------------

DECLARE_INFOLEVEL(ol);

#define LOGFILENAME L"logfile.txt"

static CGlobalFileStream *_pgfstLogFiles = NULL;
WCHAR gwcsLogFile[] = LOGFILENAME;

STDAPI_(void) DfDebug(ULONG ulLevel, ULONG ulMSFLevel)
{
#if DBG == 1
    olInfoLevel = ulLevel;
    SetInfoLevel(ulMSFLevel);
    _SetWin4InfoLevel(ulLevel | ulMSFLevel);

    olDebugOut((DEB_ITRACE, "\n--  DfDebug(0x%lX, 0x%lX)\n",
                ulLevel, ulMSFLevel));
#endif
}

// Resource limits

static LONG lResourceLimits[CDBRESOURCES] =
{
    0x7fffffff,                         // DBR_MEMORY
    0x7fffffff,                         // DBR_XSCOMMITS
    0x0,                                // DBR_FAILCOUNT
    0x0,                                // DBR_FAILLIMIT
    0x0,                                // DBR_FAILTYPES
    0x0,                                // DBRQ_MEMORY_ALLOCATED
    0x0,                                // DBRI_ALLOC_LIST
    0x0,                                // DBRI_LOGFILE_LIST
    0x0,                                // DBRF_LOGGING
    0x0,                                // DBRQ_HEAPS
    0x0                                 // DBRF_SIFTENABLE
};

#define CBRESOURCES sizeof(lResourceLimits)

#define RESLIMIT(n) lResourceLimits[n]
#define TAKEMTX
#define RELEASEMTX

//+---------------------------------------------------------------------------
//
//  Function:   DfSetResLimit, public
//
//  Synopsis:   Sets a resource limit
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(void) DfSetResLimit(UINT iRes, LONG lLimit)
{
    TAKEMTX;

    RESLIMIT(iRes) = lLimit;

    RELEASEMTX;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfGetResLimit, public
//
//  Synopsis:   Gets a resource limit
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(LONG) DfGetResLimit(UINT iRes)
{
    // Doesn't need serialization
    return RESLIMIT(iRes);
}

STDAPI_(void) DfSetFailureType(LONG lTypes)
{
    RESLIMIT(DBR_FAILTYPES) = lTypes;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   HaveResource, private
//
//  Synopsis:   Checks to see if a resource limit is exceeded
//              and consumes resource if not
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

BOOL HaveResource(UINT iRes, LONG lRequest)
{
    if (RESLIMIT(DBRF_SIFTENABLE) == FALSE)
        return TRUE;

    if (RESLIMIT(iRes) >= lRequest)
    {
        TAKEMTX;

        RESLIMIT(iRes) -= lRequest;

        RELEASEMTX;

        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ModifyResLimit, private
//
//  Synopsis:   Adds to a resource limit
//
//  History:    24-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

LONG ModifyResLimit(UINT iRes, LONG lChange)
{
    LONG l;

    TAKEMTX;

    RESLIMIT(iRes) += lChange;
    l = RESLIMIT(iRes);

    RELEASEMTX;

    return l;
}

//+-------------------------------------------------------------------------
//
//  Function:   SimulateFailure
//
//  Synopsis:   Check for simulated failure
//
//  Effects:    Tracks failure count
//
//  Arguments:  [failure] -- failure type
//
//  Returns:    TRUE if call should fail, FALSE if call should succeed
//
//  Modifies:   RESLIMIT(DBR_FAILCOUNT)
//
//  Algorithm:  Increment failure count, fail if count has succeeded
//              limit
//
//  History:    21-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

BOOL SimulateFailure(DBFAILURE failure)
{
    LONG l;
    BOOL fFail;

    //  We don't special case failure types, yet.

    if (RESLIMIT(DBRF_SIFTENABLE) != FALSE &&
        (failure & RESLIMIT(DBR_FAILTYPES)))
    {
        TAKEMTX;

        RESLIMIT(DBR_FAILCOUNT)++;
        l = RESLIMIT(DBR_FAILLIMIT);
        fFail = RESLIMIT(DBR_FAILCOUNT) >= l;

        RELEASEMTX;

        if (l == 0)
        {
            //  We're not simulating any failures;  just tracking them
            return(FALSE);
        }

        return fFail;
    }
    else
    {
        return FALSE;
    }
}

//+--------------------------------------------------------------
//
//  Class:      CChecksumBlock (cb)
//
//  Purpose:    Holds a memory block that is being checksummed
//
//  Interface:  See below
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

class CChecksumBlock
{
public:
    CChecksumBlock(char *pszName,
                   void *pvAddr,
                   ULONG cBytes,
                   DWORD dwFlags,
                   CChecksumBlock *pcbNext,
                   CChecksumBlock *pcbPrev);
    ~CChecksumBlock(void);

    char *_pszName;
    void *_pvAddr;
    ULONG _cBytes;
    DWORD _dwFlags;
    CChecksumBlock *_pcbNext, *_pcbPrev;
    ULONG _ulChecksum;
};

// Global list of checksummed blocks
static CChecksumBlock *pcbChkBlocks = NULL;

//+--------------------------------------------------------------
//
//  Member:     CChecksumBlock::CChecksumBlock, private
//
//  Synopsis:   Ctor
//
//  Arguments:  [pszName] - Block name
//              [pvAddr] - Starting addr
//              [cBytes] - Length
//              [dwFlags] - Type flags
//              [pcbNext] - Next checksum block
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

CChecksumBlock::CChecksumBlock(char *pszName,
                               void *pvAddr,
                               ULONG cBytes,
                               DWORD dwFlags,
                               CChecksumBlock *pcbNext,
                               CChecksumBlock *pcbPrev)
{
    ULONG i;
    char *pc;

    olVerify(_pszName = new char[strlen(pszName)+1]);
    strcpy(_pszName, pszName);
    _pvAddr = pvAddr;
    _cBytes = cBytes;
    _dwFlags = dwFlags;
    _pcbNext = pcbNext;
    if (pcbNext)
        pcbNext->_pcbPrev = this;
    _pcbPrev = pcbPrev;
    if (pcbPrev)
        pcbPrev->_pcbNext = this;
    _ulChecksum = 0;
    pc = (char *)pvAddr;
    for (i = 0; i<cBytes; i++)
        _ulChecksum += *pc++;
}

//+--------------------------------------------------------------
//
//  Member:     CChecksumBlock::~CChecksumBlock, private
//
//  Synopsis:   Dtor
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

CChecksumBlock::~CChecksumBlock(void)
{
    delete _pszName;
}

//+--------------------------------------------------------------
//
//  Function:   DbgChkBlocks, private
//
//  Synopsis:   Verify checksums on all current blocks
//
//  Arguments:  [dwFlags] - Types of blocks to check
//              [pszFile] - File check was called from
//              [iLine] - Line in file
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgChkBlocks(DWORD dwFlags, char *pszFile, int iLine)
{
    CChecksumBlock *pcb;

    for (pcb = pcbChkBlocks; pcb; pcb = pcb->_pcbNext)
        if (pcb->_dwFlags & dwFlags)
        {
            ULONG i, ulSum = 0;
            char *pc;

            for (pc = (char *)pcb->_pvAddr, i = 0; i<pcb->_cBytes; i++)
                ulSum += *pc++;
            if (ulSum != pcb->_ulChecksum)
                olDebugOut((DEB_ERROR, "* Bad checksum %s:%d '%s' %p:%lu *\n",
                            pszFile, iLine, pcb->_pszName,
                            pcb->_pvAddr, pcb->_cBytes));
            else if (dwFlags & DBG_VERBOSE)
                olDebugOut((DEB_ERROR, "* Checksum passed %s:%d"
                            " '%s' %p:%lu *\n",
                            pszFile, iLine, pcb->_pszName,
                            pcb->_pvAddr, pcb->_cBytes));
        }
}

//+--------------------------------------------------------------
//
//  Function:   DbgAddChkBlock, private
//
//  Synopsis:   Adds a checksum block
//
//  Arguments:  [pszName] - Name of block
//              [pvAddr] - Starting addr
//              [cBytes] - Length
//              [dwFlags] - Type flags
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgAddChkBlock(char *pszName,
                    void *pvAddr,
                    ULONG cBytes,
                    DWORD dwFlags)
{
    CChecksumBlock *pcb;

    olVerify(pcb = new CChecksumBlock(pszName, pvAddr, cBytes,
                                      dwFlags, pcbChkBlocks, NULL));
    pcbChkBlocks = pcb;
}

//+--------------------------------------------------------------
//
//  Function:   DbgFreeChkBlock, private
//
//  Synopsis:   Removes a block from the list
//
//  Arguments:  [pvAddr] - Block's check address
//
//  History:    10-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgFreeChkBlock(void *pvAddr)
{
    CChecksumBlock *pcb;

    for (pcb = pcbChkBlocks; pcb; pcb = pcb->_pcbNext)
        if (pcb->_pvAddr == pvAddr)
        {
            if (pcb->_pcbPrev)
                pcb->_pcbPrev->_pcbNext = pcb->_pcbNext;
            else
                pcbChkBlocks = pcb->_pcbNext;
            if (pcb->_pcbNext)
                pcb->_pcbNext->_pcbPrev = pcb->_pcbPrev;
            delete pcb;
            return;
        }
}

//+--------------------------------------------------------------
//
//  Function:   DbgFreeChkBlocks, private
//
//  Synopsis:   Frees all checksum blocks
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void DbgFreeChkBlocks(void)
{
    CChecksumBlock *pcb;

    while (pcbChkBlocks)
    {
        pcb = pcbChkBlocks->_pcbNext;
        delete pcbChkBlocks;
        pcbChkBlocks = pcb;
    }
}

static CGlobalFileStream *g_pDebugLogGlobalFileStream = NULL;

inline CGlobalFileStream *GetGlobalFileStream()
{
    return g_pDebugLogGlobalFileStream;
}

inline void SetGlobalFileStream(CGlobalFileStream *pgfst)
{
    g_pDebugLogGlobalFileStream = pgfst;
}

#ifdef MULTIHEAP
static CFileStream *g_pDebugLogFileStream = NULL;
#endif


SCODE GetLogFile(CFileStream **pfs)
#ifdef MULTIHEAP
{
    // Do not use shared memory to write log files
    SCODE sc = S_OK;

    if (GetGlobalFileStream() == NULL)
    {
        g_pDebugLogGlobalFileStream = ::new CGlobalFileStream
                (NULL, 0, LOGFILEDFFLAGS, LOGFILESTARTFLAGS);
        SetGlobalFileStream (g_pDebugLogGlobalFileStream);

        g_pDebugLogFileStream = ::new CFileStream (NULL);
    }
    g_pDebugLogFileStream->InitFromGlobal(GetGlobalFileStream());
    *pfs = g_pDebugLogFileStream;
    return sc;
}
#else
{
    SCODE sc = S_OK;
    CFileStream *pfsLoop = NULL;

    *pfs = NULL;

    if (GetGlobalFileStream() == NULL)
    {
        IMalloc *pMalloc;

        olHChk(DfCreateSharedAllocator(&pMalloc));
        SetGlobalFileStream(new (pMalloc) CGlobalFileStream(pMalloc,
                                                            0, LOGFILEDFFLAGS,
                                                            LOGFILESTARTFLAGS));
        pMalloc->Release();
    }

    if (GetGlobalFileStream() != NULL)
    {
        pfsLoop = GetGlobalFileStream()->Find(GetCurrentContextId());

        if (pfsLoop == NULL)
        {
            IMalloc *pMalloc;
            olHChk(DfCreateSharedAllocator(&pMalloc));

            pfsLoop = new (pMalloc) CFileStream(pMalloc);
            pMalloc->Release();

            if (pfsLoop != NULL)
                pfsLoop->InitFromGlobal(GetGlobalFileStream());
        }
    }

EH_Err:
    *pfs = pfsLoop;
    return sc;
}
#endif // MULIHEAP

SCODE _FreeLogFile(void)
{
#ifdef MULTIHEAP
    if (GetGlobalFileStream())
    {
        g_pDebugLogFileStream->RemoveFromGlobal();
        memset (g_pDebugLogGlobalFileStream, 0, sizeof(CContextList));
        ::delete g_pDebugLogFileStream;
        ::delete g_pDebugLogGlobalFileStream;
        SetGlobalFileStream (NULL);
    }
    return S_OK;
#else
    CFileStream *pfsLoop = NULL;

    if (GetGlobalFileStream())
        pfsLoop = GetGlobalFileStream()->Find(GetCurrentContextId());

    if (pfsLoop != NULL)
    {
        pfsLoop->vRelease();
        GetGlobalFileStream()->Release();
        SetGlobalFileStream(NULL);
        return S_OK;
    }

    return STG_E_UNKNOWN;
#endif
}

long cLogNestings = 0;

void OutputLogfileMessage(char const *format, ...)
{
    int length;
    char achPreFormat[] = "PID[%lx] TID[%lx] ";
    char achBuffer[256];
    ULONG cbWritten;
    CFileStream *pfs = NULL;
    va_list arglist;
    STATSTG stat;

    if (cLogNestings > 0)
        return;

    TAKEMTX;
    cLogNestings++;

    va_start(arglist, format);

    GetLogFile(&pfs);

    if (NULL != pfs)
    {
        pfs->InitFile(gwcsLogFile);
        pfs->Stat(&stat, STATFLAG_NONAME);

        if (DfGetResLimit(DBRF_LOGGING) & DFLOG_PIDTID)
        {
            //  Prepare prefix string
            length = wsprintfA(achBuffer, "PID[%8lx] TID[%8lx] ",
                             GetCurrentProcessId(), GetCurrentThreadId());

            //  length does not include NULL terminator

            pfs->WriteAt(stat.cbSize, achBuffer, length, &cbWritten);
            stat.cbSize.LowPart += cbWritten;
        }

        //  Write caller data to logfile
#if WIN32 == 300
        wsprintfA(achBuffer, format, arglist);
#else
        wsprintfA(achBuffer, format, arglist);
#endif

        length = strlen(achBuffer);
        for (int i = 0; i < length; i++)
        {
            if (((achBuffer[i] < 32) || (achBuffer[i] > 127)) &&
                (achBuffer[i] != '\n') && (achBuffer[i] != '\t'))
            {
                achBuffer[i] = '.';
            }
        }

        pfs->WriteAt(stat.cbSize, achBuffer, length, &cbWritten);
    }

    cLogNestings--;
    RELEASEMTX;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dfname.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	dfname.cxx
//
//  Contents:	CDfName implementation
//
//  History:	14-May-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:	CDfName::IsEqual, public
//
//  Synopsis:	Compares two CDfNames
//
//  Arguments:	[pdfn] - Name to compare against
//
//  Returns:	TRUE/FALSE
//
//  History:	11-May-93	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef FLAT
BOOL CDfName::IsEqual(CDfName const *pdfn) const
{
    if (_cb != pdfn->_cb)
        return FALSE;
    return dfwcsnicmp((WCHAR *)_ab, (WCHAR *)pdfn->_ab, _cb) == 0;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CDfName::CopyString, public
//
//  Synopsis:	Makes a proper copy of a name in a WCHAR string
//
//  Arguments:	[pwcs] - String
//
//  History:	14-May-93	DrewB	Created
//
//  Notes:	Uses leading characters to determine the format of
//              the name in the string
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDfName_CopyString)
#endif

void CDfName::CopyString(WCHAR const *pwcs)
{
    Set(pwcs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dfiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dfiter.cxx
//
//  Contents:   Implementations of CDocFile iterator methods
//
//  History:    16-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Member:	CDocFile::FindGreaterEntry, public
//
//  Synopsis:	Returns the next greater child
//
//  Arguments:	[pdfnKey] - Previous key
//              [pib] - Fast iterator buffer
//              [pstat] - Full iterator buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDocFile_FindGreaterEntry) // Iterate_TEXT
#endif

SCODE CDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                 SIterBuffer *pib,
                                 STATSTGW *pstat)
{
    SID sidChild;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::FindGreaterEntry:%p(%p, %p, %p)\n",
                this, pdfnKey, pib, pstat));
    olAssert((pib == NULL) != (pstat == NULL));

    if (SUCCEEDED(sc = _stgh.GetMS()->GetChild(_stgh.GetSid(), &sidChild)))
    {
        if (sidChild == NOSTREAM)
        {
            sc = STG_E_NOMOREFILES;
        }
        else
        {
            SID sid = 0;  // initialize recursion count to 0
            if (SUCCEEDED(sc = _stgh.GetMS()->FindGreaterEntry(sidChild,
                                                               pdfnKey,
                                                               &sid)))
            {
                sc = _stgh.GetMS()->StatEntry(sid, pib, pstat);
            }
        }
    }

    olDebugOut((DEB_ITRACE, "Out CDocFile::FindGreaterEntry\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDocFile::StatEntry, public
//
//  Synopsis:	Gets information for a child
//
//  Arguments:	[pdfn] - Child name
//              [pib] - Short information
//              [pstat] - Full information
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDocFile_StatEntry)
#endif

SCODE CDocFile::StatEntry(CDfName const *pdfn,
                          SIterBuffer *pib,
                          STATSTGW *pstat)
{
    SEntryBuffer eb;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CDocFile::StatEntry:%p(%p, %p, %p)\n",
                this, pdfn, pib, pstat));
    olAssert((pib == NULL) != (pstat == NULL));

    olChk(_stgh.GetMS()->IsEntry(_stgh.GetSid(), pdfn, &eb));
    sc = _stgh.GetMS()->StatEntry(eb.sid, pib, pstat);

    olDebugOut((DEB_ITRACE, "Out CDocFile::StatEntry\n"));
 EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dfstream.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dfstream.cxx
//
//  Contents:   Implementations of CDocFile stream methods
//
//  History:    18-Oct-91       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Method:     CDocFile::CreateStream, public
//
//  Synopsis:   Creates a named stream in a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry to be created
//              [ppsstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppsstStream]
//
//  History:    22-Aug-91       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDocFile_CreateStream) // Dirdf_Create_TEXT
#endif

SCODE CDocFile::CreateStream(CDfName const *pdfn,
                             DFLAGS const df,
                             DFLUID dlSet,
                             PSStream **ppsstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::CreateStream("
            "%ws, %X, %lu, %p)\n",
                pdfn, df, dlSet, ppsstStream));

    UNREFERENCED_PARM(df);

    if (dlSet == DF_NOLUID)
        dlSet = CDirectStream::GetNewLuid(_pdfb->GetMalloc());
#ifndef REF
    pstm = new (BP_TO_P(CDFBasis *, _pdfb)) CDirectStream(dlSet);
    olAssert(pstm != NULL && aMsg("Reserved stream unavailable"));
#else
    olMem(pstm = new CDirectStream(dlSet));
#endif //!REF

    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, TRUE));

    *ppsstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::CreateStream => %p\n",
                *ppsstStream));
    return S_OK;

EH_pstm:
#ifndef REF
    pstm->ReturnToReserve(BP_TO_P(CDFBasis *, _pdfb));
#else
    delete pstm;
EH_Err:
#endif //!REF
    return sc;
}

//+--------------------------------------------------------------
//
//  Method:     CDocFile::GetStream, public
//
//  Synopsis:   Retrieves an existing stream from a DocFile
//
//  Arguments:  [pwcsName] - Name of the stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppsstStream] - Pointer to storage for the stream pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:   [ppsstStream]
//
//  History:    22-Aug-91       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CDocFile_GetStream) // Dirdf_Open_TEXT
#endif

SCODE CDocFile::GetStream(CDfName const *pdfn,
                          DFLAGS const df,
                          PSStream **ppsstStream)
{
    SCODE sc;
    CDirectStream *pstm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::GetStream(%ws, %X, %p)\n",
                pdfn, df, ppsstStream));

    UNREFERENCED_PARM(df);

    DFLUID dl = CDirectStream::GetNewLuid(_pdfb->GetMalloc());
#ifndef REF
    olMem(pstm = new(_pdfb->GetMalloc()) CDirectStream(dl));
#else
    olMem(pstm = new CDirectStream(dl));
#endif //!REF

    olChkTo(EH_pstm, pstm->Init(&_stgh, pdfn, FALSE));

    *ppsstStream = pstm;
    olDebugOut((DEB_ITRACE, "Out CDocFile::GetStream => %p\n",
                *ppsstStream));
    return S_OK;

EH_pstm:
    delete pstm;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\dfxact.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dfxact.cxx
//
//  Contents:   CDocFile transactioning methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CDocFile::BeginCommitFromChild, public
//
//  Synopsis:   Start two-phase commit, requested by child
//
//  Arguments:  [ulChanged] - Update list
//              [dwFlags] - Flags controlling commit
//              [pdfChild] - Child object
//
//  Returns:    Appropriate status code
//
//  History:    04-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

SCODE CDocFile::BeginCommitFromChild(CUpdateList &ulChanged,
                                     DWORD const dwFlags,
                                     CWrappedDocFile *pdfChild)
{
    SCODE sc;
    TIME_T tm;

    olDebugOut((DEB_ITRACE, "In  CDocFile::BeginCommitFromChild:%p("
                "%p, %lX, %p)\n", this, ulChanged.GetHead(), dwFlags,
                pdfChild));
    UNREFERENCED_PARM(dwFlags);

    // Copy-on-write will back these changes out if they fail
    if (pdfChild->GetDirty() & DIRTY_CREATETIME)
    {
        olVerSucc(pdfChild->GetTime(WT_CREATION, &tm));
        olChk(SetTime(WT_CREATION, tm));
    }
    if (pdfChild->GetDirty() & DIRTY_MODIFYTIME)
    {
        olVerSucc(pdfChild->GetTime(WT_MODIFICATION, &tm));
        olChk(SetTime(WT_MODIFICATION, tm));
    }
    if (pdfChild->GetDirty() & DIRTY_ACCESSTIME)
    {
        olVerSucc(pdfChild->GetTime(WT_ACCESS, &tm));
        olChk(SetTime(WT_ACCESS, tm));
    }
    if (pdfChild->GetDirty() & DIRTY_CLASS)
    {
        CLSID clsid;

        olVerSucc(pdfChild->GetClass(&clsid));
        olChk(SetClass(clsid));
    }
    if (pdfChild->GetDirty() & DIRTY_STATEBITS)
    {
        DWORD grfStateBits;

        olVerSucc(pdfChild->GetStateBits(&grfStateBits));
        olChk(SetStateBits(grfStateBits, 0xffffffff));
    }

    _ulChangedHolder = ulChanged;
    sc = ApplyChanges(ulChanged);

    olDebugOut((DEB_ITRACE, "Out CDocFile::BeginCommitFromChild\n"));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CDocFile::EndCommitFromChild
//
//  Synopsis:   Ends two-phase commit, requested by child
//
//  Arguments:  [df] - COMMIT/ABORT
//              [pdfChild] - Child object
//
//  History:    07-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

void CDocFile::EndCommitFromChild(DFLAGS const df,
                                  CWrappedDocFile *pdfChild)
{
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CDocFile::EndCommitFromChild:%p(%X, %p)\n",
                this, df, pdfChild));

    UNREFERENCED_PARM(pdfChild);

    if (P_COMMIT(df))
    {
        // Finalize updates
        for (pud = _ulChangedHolder.GetHead(); pud; pud = pud->GetNext())
            if (pud->IsCreate())
                // Remove reference to child's XSM so that list destruction
                // won't free it
                pud->SetXSM(NULL);
        _ulChangedHolder.Empty();
    }
    else
    {
        for (pud = _ulChangedHolder.GetTail(); pud; pud = pud->GetPrev())
            if (pud->IsCreate())
            {
                // We need to do two things:
                //
                // Break any SetBase links that might have been created
                //
                // Return newly created objects to the creators so
                // that they can be returned to the preallocation
                // pool

                if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                    STGTY_STORAGE)
                {
                    CWrappedDocFile *pwdf = (CWrappedDocFile *)pud->GetXSM();
                    CDocFile *pddf;

                    if (pwdf != NULL && 
                        (pddf = (CDocFile *)pwdf->GetBase()) != NULL)
                    {
                        // AddRef so SetBase won't free memory
                        pddf->AddRef();
                        pwdf->SetBase(NULL);
                        ReturnDocFile(pddf);
                    }
                }
                else
                {
                    CTransactedStream *pwstm = (CTransactedStream *)pud->
                        GetXSM();
                    CDirectStream *pdstm;

                    olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
                             == STGTY_STREAM);
                    if (pwstm != NULL &&
                        (pdstm = (CDirectStream *)pwstm->GetBase()) != NULL)
                    {
                        // AddRef so SetBase won't free memory
                        pdstm->AddRef();
                        pwstm->SetBase(NULL);
                        ReturnStream(pdstm);
                    }
                }
            }
        _ulChangedHolder.Unlink();
    }
    olDebugOut((DEB_ITRACE, "Out CDocFile::EndCommitFromChild\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\fastlock.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992
//
//  File:       fastlock.cxx
//
//  Contents:   Implementation of CDfMutex methods for DocFiles
//
//  History:    26-Jul-94       DonnaLi   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>
#pragma hdrstop

#include <df32.hxx>
#include <secdes.hxx>   // from com\inc

#ifdef UNICODE
#define GLOBAL_CS L"GlobalCsMutex"
#else
#define GLOBAL_CS "GlobalCsMutex"
#endif

//
// This is the number of characters to skip over in the name
// pased to CDfMutex::Init.  The name consists of the string
// OleDfRoot followed by the hex representation of a unique
// number for each Docfile.  We skip CHARS_TO_SKIP number of
// characters in the name to produce a related and yet unique
// name for the file mapping containing global state for the
// critical section.
//
#define CHARS_TO_SKIP 3


//+--------------------------------------------------------------
//
//  Member:     CDfMutex::Init, public
//
//  Synopsis:   This routine creates and initializes the global
//              critical section if it does not already exist.
//              It then attaches to the global critical section.
//
//  Arguments:  [lpName] - Supplies the critical section name
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Uses a mutex to serialize global critical section
//              creation and initialization
//              The name passed in is used to create or open the
//              semaphore embedded in the global critical section.
//              The name with the first CHARS_TO_SKIP characters
//              skipped is used to create or open the file mapping
//              containing global state of the critical section.
//              If a file mapping with that name already exists,
//              it is not reinitialized.  The caller instead just
//              attaches to it.
//
//---------------------------------------------------------------

SCODE
CDfMutex::Init(
    TCHAR * lpName
    )
{
    HANDLE                  hGlobalMutex;
    SCODE                   scResult = S_OK;
    DWORD                   dwResult;
    LPSECURITY_ATTRIBUTES   lpsa = NULL;

#if WIN32 == 100 || WIN32 > 200
    CGlobalSecurity         gs;
    if (FAILED(scResult = gs.Init(TRUE))) return scResult;
#else
    LPSECURITY_ATTRIBUTES gs = NULL;
#endif

#ifndef MULTIHEAP
#if WIN32 == 100 || WIN32 > 200
    CWorldSecurityDescriptor wsd;
    SECURITY_ATTRIBUTES secattr;

    secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
    secattr.lpSecurityDescriptor = &wsd;
    secattr.bInheritHandle = FALSE;
#endif

    //
    // Serialize all global critical section initialization
    //

    hGlobalMutex = CreateMutex(
#if WIN32 == 100 || WIN32 > 200
            &secattr,           //  LPSECURITY_ATTRIBUTES   lpsa
#else
            gs,
#endif
            TRUE,               //  BOOL                    fInitialOwner
            GLOBAL_CS           //  LPCTSTR                 lpszMutexName
            );

    //
    // If the mutex create/open failed, then bail
    //

    if ( !hGlobalMutex )
    {
        return LAST_SCODE;
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS )
    {

        //
        // Since the mutex already existed, the request for ownership has
        // no effect.
        //
        // wait for the mutex
        //

        if ( WaitForSingleObject (hGlobalMutex, INFINITE) == WAIT_FAILED )
        {
            scResult = LAST_SCODE;
            CloseHandle (hGlobalMutex);
            return scResult;
        }
    }

    //
    // We now own the global critical section creation mutex. Create/Open the
    // named semaphore.
    //
#endif

    _hLockSemaphore = CreateSemaphore (
            gs,             //  LPSECURITY_ATTRIBUTES   lpsa
            0,              //  LONG                    cSemInitial
            MAXLONG-1,      //  LONG                    cSemMax
            lpName          //  LPCTSTR                 lpszSemName
            );

    //
    // If the semaphore create/open failed, then bail
    //

    if ( !_hLockSemaphore )
    {
        scResult = LAST_SCODE;
    }
    else
    {
        //
        // Create/open a shared file mapping object
        // If we created it, we need to initialize the global structure.
        // Otherwise just point to it.
        // The global critical section creation mutex allows us to do
        // this safely.
        //

        _hSharedMapping = CreateFileMappingT (
                INVALID_HANDLE_VALUE, //  HANDLE                  hFile
                gs,                 //  LPSECURITY_ATTRIBUTES   lpsa
                PAGE_READWRITE,     //  DWORD                   fdwProtect
                0,                  //  DWORD               dwMaximumSizeHigh
                1024,               //  DWORD               dwMaximumSizeLow
                lpName+CHARS_TO_SKIP//  LPCTSTR             lpszMapName
                );

        if ( !_hSharedMapping )
        {
            scResult = LAST_SCODE;
            CloseHandle (_hLockSemaphore);
            _hLockSemaphore = (HANDLE)NULL;
        }
        else
        {
            dwResult = GetLastError();

            _pGlobalPortion = (PGLOBAL_SHARED_CRITICAL_SECTION)
                    MapViewOfFile (
                    _hSharedMapping,    //  HANDLE          hMapObject
                    FILE_MAP_WRITE,     //  DWORD           fdwAccess
                    0,                  //  DWORD           dwOffsetHigh
                    0,                  //  DWORD           dwOffsetLow
                    0                   //  DWORD           cbMap
                    );

            if (!_pGlobalPortion)
            {
                scResult = LAST_SCODE;
                CloseHandle (_hLockSemaphore);
                _hLockSemaphore = (HANDLE)NULL;
                CloseHandle (_hSharedMapping);
                _hSharedMapping = (HANDLE)NULL;
            }
            else if (dwResult != ERROR_ALREADY_EXISTS )
            {
                //
                // We created the file mapping, so initialize the
                // global portion.
                //

                _pGlobalPortion->LockCount = -1;
#ifdef SUPPORT_RECURSIVE_LOCK
                _pGlobalPortion->RecursionCount = 0;
                _pGlobalPortion->OwningThread = 0;
#else
#if DBG == 1
                _pGlobalPortion->OwningThread = 0;
#endif
#endif
                _pGlobalPortion->Reserved = 0;
            }
        }
    }


#ifndef MULTIHEAP
    ReleaseMutex (hGlobalMutex);
    CloseHandle (hGlobalMutex);
#endif

    return scResult;
}


//+--------------------------------------------------------------
//
//  Member:     CDfMutex::~CDfMutex, public
//
//  Synopsis:   This routine detaches from an existing global
//              critical section.
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Create or get the entry from the multistream
//
//---------------------------------------------------------------

CDfMutex::~CDfMutex(
    void
    )
{
    //If we're holding the mutex, we need to get rid of it here.

#ifdef SUPPORT_RECURSIVE_LOCK
    if ((_pGlobalPortion) &&
        (_pGlobalPortion->OwningThread == GetCurrentThreadId()))
    {
#else
    if (_pGlobalPortion)
    {
#if DBG == 1
        olAssert (_pGlobalPortion->OwningThread == 0 || _pGlobalPortion->OwningThread == GetCurrentThreadId());
#endif
#endif
        Release();
    }

    if ( _pGlobalPortion )
    {
        UnmapViewOfFile (_pGlobalPortion);
    }

    if ( _hLockSemaphore )
    {
        CloseHandle (_hLockSemaphore);
    }
    if ( _hSharedMapping )
    {
        CloseHandle (_hSharedMapping);
    }
}

//+--------------------------------------------------------------
//
//  Member:     CDfMutex::Take, public
//
//  Synopsis:   This routine enters the global critical section.
//
//  Arguments:  [dwTimeout] - Supplies the timeout
//
//  Returns:    Appropriate status code
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Enters the critical section if nobody owns it or
//              if the current thread already owns it.
//              Waits for the critical section otherwise.
//
//---------------------------------------------------------------

SCODE
CDfMutex::Take (
    DWORD   dwTimeout
    )
{
    olAssert (_pGlobalPortion->LockCount >= -1);

#ifdef SUPPORT_RECURSIVE_LOCK

    olAssert (_pGlobalPortion->RecursionCount >= 0);

    DWORD ThreadId;

    ThreadId = GetCurrentThreadId();

#endif

    //
    // Increment the lock variable. On the transition to 0, the caller
    // becomes the absolute owner of the lock. Otherwise, the caller is
    // either recursing, or is going to have to wait
    //

    if ( !InterlockedIncrement (&_pGlobalPortion->LockCount) )
    {
        //
        // lock count went from -1 to 0, so the caller
        // is the owner of the lock
        //

#ifdef SUPPORT_RECURSIVE_LOCK
        _pGlobalPortion->RecursionCount = 1;
        _pGlobalPortion->OwningThread = ThreadId;
#else
#if DBG == 1
        _pGlobalPortion->OwningThread = GetCurrentThreadId();
#endif
#endif
        return S_OK;
    }
    else
    {
#ifdef SUPPORT_RECURSIVE_LOCK
        //
        // If the caller is recursing, then increment the recursion count
        //

        if ( _pGlobalPortion->OwningThread == ThreadId )
        {
            _pGlobalPortion->RecursionCount++;
            return S_OK;
        }
        else
        {
#else
#if DBG == 1
        olAssert (_pGlobalPortion->OwningThread != GetCurrentThreadId());
#endif
#endif
            switch (WaitForSingleObject(
                    _hLockSemaphore,
                    dwTimeout
                    ))
            {
                case WAIT_OBJECT_0:
                case WAIT_ABANDONED:
#ifdef SUPPORT_RECURSIVE_LOCK
                    _pGlobalPortion->RecursionCount = 1;
                    _pGlobalPortion->OwningThread = ThreadId;
#else
#if DBG == 1
                    _pGlobalPortion->OwningThread = GetCurrentThreadId();
#endif
#endif
                    return S_OK;
                case WAIT_TIMEOUT:
                    return STG_E_INUSE;
                default:
                    return LAST_SCODE;
            }
#ifdef SUPPORT_RECURSIVE_LOCK
        }
#endif
    }
}


//+--------------------------------------------------------------
//
//  Member:     CDfMutex::Release, public
//
//  Synopsis:   This routine leaves the global critical section
//
//  History:    26-Jul-94       DonnaLi   Created
//
//  Algorithm:  Leaves the critical section if this is the owning
//              thread.
//
//---------------------------------------------------------------

VOID
CDfMutex::Release(
    void
    )
{
#ifdef SUPPORT_RECURSIVE_LOCK
    if ( _pGlobalPortion->OwningThread != GetCurrentThreadId() ) return;
#else
#if DBG == 1
    olAssert (_pGlobalPortion->OwningThread == 0 || _pGlobalPortion->OwningThread == GetCurrentThreadId());
#endif
#endif

    olAssert (_pGlobalPortion->LockCount >= -1);

#ifdef SUPPORT_RECURSIVE_LOCK
    olAssert (_pGlobalPortion->RecursionCount >= 0);

    //
    // decrement the recursion count. If it is still non-zero, then
    // we are still the owner so don't do anything other than dec the lock
    // count
    //

    if ( --_pGlobalPortion->RecursionCount )
    {
        InterlockedDecrement(&_pGlobalPortion->LockCount);
    }
    else
    {
        //
        // We are really leaving, so give up ownership and decrement the
        // lock count
        //

        _pGlobalPortion->OwningThread = 0;
#else
#if DBG == 1
        _pGlobalPortion->OwningThread = 0;
#endif
#endif

        //
        // Check to see if there are other waiters. If so, then wake up a waiter
        //

        if ( InterlockedDecrement(&_pGlobalPortion->LockCount) >= 0 )
        {
            ReleaseSemaphore(
                    _hLockSemaphore,    //  HANDLE  hSemaphore
                    1,                  //  LONG    cReleaseCount
                    NULL                //  LPLONG  lplPreviousCount
                    );
        }
#ifdef SUPPORT_RECURSIVE_LOCK
    }
#endif
}

//+--------------------------------------------------------------
//
//  Member:     CDfMutex::IsHandleValid, public
//
//  Synopsis:   This routine checks the mutex handle for validity
//
//  History:    09-May-2001      HenryLee    created
//
//---------------------------------------------------------------

BOOL CDfMutex::IsHandleValid (TCHAR *ptcsName)
{
#if WIN32 == 100
    BOOL fValid = FALSE;
    NTSTATUS nts = STATUS_SUCCESS;
    WCHAR wcsBuffer[MAX_PATH] = L"";
    OBJECT_NAME_INFORMATION *poni = (OBJECT_NAME_INFORMATION *) wcsBuffer;

    nts = NtQueryObject (_hLockSemaphore, ObjectNameInformation, poni,
                         sizeof(wcsBuffer), NULL);

    if (NT_SUCCESS(nts))
    {
        if (poni->Name.Length < sizeof(wcsBuffer) - sizeof (*poni))
        {
            poni->Name.Buffer[poni->Name.Length / sizeof(WCHAR)] = L'\0';
            if (!lstrcmp (poni->Name.Buffer, ptcsName))
                fValid = TRUE;
        }
    }
#else
    BOOL fValid = TRUE;
#endif

    return fValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\freelist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       freelist.cxx
//
//  Contents:   CFreeList implementation
//
//  History:    05-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <freelist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CFreeList::Reserve, public
//
//  Synopsis:   Allocates memory for a given number of blocks
//
//  Arguments:  [pMalloc] - Allocator to use to allocate blocks
//              [cBlocks] - Number of blocks to allocate
//              [cbBlock] - Block size
//
//  Returns:    Appropriate status code
//
//  History:    05-Nov-92       DrewB   Created
//              21-May-93       AlexT   Add allocator
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CFreeList_Reserve)
#endif

SCODE CFreeList::Reserve(IMalloc *pMalloc, UINT cBlocks, size_t cbBlock)
{
    SFreeBlock *pfb;
    UINT i;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CFreeList::Reserve:%p(%lu, %u)\n",
                this, cBlocks, cbBlock));
    olAssert(cbBlock >= sizeof(SFreeBlock));
    for (i = 0; i<cBlocks; i++)
    {
        olMem(pfb = (SFreeBlock *)
              CMallocBased::operator new (cbBlock, pMalloc));
        pfb->pfbNext = _pfbHead;
        _pfbHead = P_TO_BP(CBasedFreeBlockPtr, pfb);
    }
    olDebugOut((DEB_ITRACE, "Out CFreeList::Reserve\n"));
    return S_OK;

 EH_Err:
    SFreeBlock *pfbT;

    for (; i>0; i--)
    {
        olAssert(_pfbHead != NULL);
        pfbT = BP_TO_P(SFreeBlock *, _pfbHead->pfbNext);
        delete (CMallocBased *) BP_TO_P(SFreeBlock *, _pfbHead);
        _pfbHead = P_TO_BP(CBasedFreeBlockPtr, pfbT);
    }
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFreeList::Unreserve, public
//
//  Synopsis:   Removes N blocks from the list
//
//  Arguments:  [cBlocks] - Number of blocks to free
//
//  History:    05-Nov-92       DrewB   Created
//              21-May-93       AlexT   Switch to CMallocBased
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CFreeList_Unreserve)
#endif

void CFreeList::Unreserve(UINT cBlocks)
{
    SFreeBlock *pfbT;

    olDebugOut((DEB_ITRACE, "In  CFreeList::Unreserve:%p(%lu)\n",
                this, cBlocks));
    for (; cBlocks>0; cBlocks--)
    {
        olAssert(_pfbHead != NULL);
        pfbT = BP_TO_P(SFreeBlock *, _pfbHead->pfbNext);
        delete (CMallocBased *) BP_TO_P(SFreeBlock *, _pfbHead);
        _pfbHead = P_TO_BP(CBasedFreeBlockPtr, pfbT);
    }
    olDebugOut((DEB_ITRACE, "Out CFreeList::Unreserve\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\entry.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       entry.cxx
//
//  Contents:   Entry implementations
//
//  History:    29-Jul-92       DrewB   Created
//              10-Apr-95       HenryLee remove Sleep
//
//---------------------------------------------------------------

#include <dfhead.cxx>
#include <smalloc.hxx>

#pragma hdrstop

#define PDOCFILE_VCALL(x)                             \
    if (_sig == CDOCFILE_SIG)                         \
        return ((CDocFile *)this)->x;                 \
    else if (_sig == CWRAPPEDDOCFILE_SIG)             \
        return ((CWrappedDocFile *)this)->x;          \
    else olAssert (!"Invalid signature on PDocFile!");\
    return STG_E_INVALIDFUNCTION;                     

#define PSSTREAM_VCALL(x)                             \
    if (_sig == CDIRECTSTREAM_SIG)                    \
        return ((CDirectStream *)this)->x;            \
    else if (_sig == CTRANSACTEDSTREAM_SIG)           \
        return ((CTransactedStream *)this)->x;        \
    else olAssert (!"Invalid signature on PSStream!");\
    return STG_E_INVALIDFUNCTION;

#define PTIMEENTRY_VCALL(x)                           \
    if (_sig == CDOCFILE_SIG)                         \
        return ((CDocFile *)this)->x;                 \
    else if (_sig == CWRAPPEDDOCFILE_SIG)             \
        return ((CWrappedDocFile *)this)->x;          \
    else olAssert (!"Invalid signature on PTimeEntry");\
    return STG_E_INVALIDFUNCTION;

//+--------------------------------------------------------------
//
//  Member:     PTimeEntry::CopyTimesFrom, public
//
//  Synopsis:   Copies one entries times to another
//
//  Arguments:  [ptenFrom] - From
//
//  Returns:    Appropriate status code
//
//  History:    29-Jul-92       DrewB   Created
//		26-May-95	SusiA	Removed GetTime; Added GetAllTimes
//		22-Nov-95	SusiA	SetAllTimes at once
//
//---------------------------------------------------------------

SCODE PTimeEntry::CopyTimesFrom(PTimeEntry *ptenFrom)
{
    SCODE sc;
    TIME_T atm;  //Access time
    TIME_T mtm;	 //Modification time
    TIME_T ctm;  //Creation time

    olDebugOut((DEB_ITRACE, "In  PTimeEntry::CopyTimesFrom(%p)\n",
                ptenFrom));
    olChk(ptenFrom->GetAllTimes(&atm, &mtm, &ctm));
    olChk(SetAllTimes(atm, mtm, ctm));
    olDebugOut((DEB_ITRACE, "Out PTimeEntry::CopyTimesFrom\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	PBasicEntry::GetNewLuid, public
//
//  Synopsis:	Returns a new luid
//
//  History:	21-Oct-92	AlexT	Created
//
//---------------------------------------------------------------

//We used to have a mutex here - it turns out that this is unnecessary,
//  since we're already holding the tree mutex.  We get a performance
//  win by eliminating the mutex.
//Using CSmAllocator mutex and took out Sleep()
//static CStaticDfMutex _sdmtxLuids(TSTR("DfLuidsProtector"));

DFLUID PBasicEntry::GetNewLuid(const IMalloc *pMalloc)
{
    DFLUID luid;

    luid = ((CSmAllocator *)pMalloc)->IncrementLuid();
    return luid;
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::GetTime, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    PTIMEENTRY_VCALL (GetTime (wt, ptm));
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::SetTime, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::SetTime(WHICHTIME wt, TIME_T tm)
{
    PTIMEENTRY_VCALL (SetTime (wt, tm));
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::GetAllTimes, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::GetAllTimes(TIME_T *patm, TIME_T *pmtm, TIME_T *pctm)
{
    PTIMEENTRY_VCALL (GetAllTimes (patm, pmtm, pctm));
}

//+--------------------------------------------------------------
//
//  Member: PTimeEntry::SetTime, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTimeEntry::SetAllTimes(TIME_T atm, TIME_T mtm, TIME_T ctm)
{
    PTIMEENTRY_VCALL (SetAllTimes (atm, mtm, ctm));
}

//+--------------------------------------------------------------
//
//  Member:     PBasicEntry::Release, public
//
//  Synopsis:   Release resources for a PBasicEntry
//
//  History:    11-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

void PBasicEntry::Release(void)
{
    LONG lRet;

    olDebugOut((DEB_ITRACE, "In  PBasicEntry::Release()\n"));
    olAssert(_cReferences > 0);

    lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        if (_sig == CDOCFILE_SIG)
            delete (CDocFile *)this;
        else if (_sig == CWRAPPEDDOCFILE_SIG)
            delete (CWrappedDocFile *)this;
        else if (_sig == CDIRECTSTREAM_SIG)
            delete (CDirectStream *)this;
        else if (_sig == CTRANSACTEDSTREAM_SIG)
            delete (CTransactedStream *)this;
        else
            olAssert (!"Invalid signature on PBasicEntry!");
    }
    olDebugOut((DEB_ITRACE, "Out PBasicEntry::Release\n"));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::BeginCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PSStream::BeginCommitFromChild(
#ifdef LARGE_STREAMS
                ULONGLONG ulSize,
#else
                ULONG ulSize,
#endif
                CDeltaList *pDelta,
                CTransactedStream *pstChild)
{
    PSSTREAM_VCALL (BeginCommitFromChild (ulSize, pDelta, pstChild));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::EndCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PSStream::EndCommitFromChild(DFLAGS df, CTransactedStream *pstChild)
{
    if (_sig == CDIRECTSTREAM_SIG)
        ((CDirectStream *)this)->EndCommitFromChild (df, pstChild);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->EndCommitFromChild (df, pstChild);
    else olAssert (!"Invalid signature on PSStream!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PSStream::EmptyCache, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PSStream::EmptyCache()
{
    if (_sig == CDIRECTSTREAM_SIG)
        ((CDirectStream *)this)->EmptyCache();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->EmptyCache();
    else olAssert (!"Invalid signature on PSStream!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PSStream::GetDeltaList, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

CDeltaList * PSStream::GetDeltaList(void)
{
    if (_sig == CDIRECTSTREAM_SIG)
        return ((CDirectStream *)this)->GetDeltaList ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        return ((CTransactedStream *)this)->GetDeltaList ();
    else olAssert (!"Invalid signature on PSStream!");
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member: PSStream::ReadAt, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PSStream::ReadAt(
#ifdef LARGE_STREAMS
                ULONGLONG ulOffset,
#else
                ULONG ulOffset,
#endif
                VOID *pBuffer,
                ULONG ulCount,
                ULONG STACKBASED *pulRetval)
{
    PSSTREAM_VCALL (ReadAt (ulOffset, pBuffer, ulCount, pulRetval));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::WriteAt, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PSStream::WriteAt(
#ifdef LARGE_STREAMS
                ULONGLONG ulOffset,
#else
                ULONG ulOffset,
#endif
                VOID const *pBuffer,
                ULONG ulCount,
                ULONG STACKBASED *pulRetval)
{
    PSSTREAM_VCALL (WriteAt (ulOffset, pBuffer, ulCount, pulRetval));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::SetSize, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE PSStream::SetSize(ULONGLONG ulNewSize)
#else
SCODE PSStream::SetSize(ULONG ulNewSize)
#endif
{
    PSSTREAM_VCALL (SetSize (ulNewSize));
}

//+--------------------------------------------------------------
//
//  Member: PSStream::GetSize, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
void PSStream::GetSize(ULONGLONG *pulSize)
#else
void PSStream::GetSize(ULONG *pulSize)
#endif
{
    if (_sig == CDIRECTSTREAM_SIG)
        ((CDirectStream *)this)->GetSize (pulSize);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->GetSize (pulSize);
    else olAssert (!"Invalid signature on PSStream!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::DestroyEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::DestroyEntry(CDfName const *pdfnName,
                               BOOL fClean)
{
    PDOCFILE_VCALL (DestroyEntry(pdfnName, fClean));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::RenameEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::RenameEntry(CDfName const *pdfnName,
                  CDfName const *pdfnNewName)
{
    PDOCFILE_VCALL (RenameEntry (pdfnName, pdfnNewName));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetClass, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetClass(CLSID *pclsid)
{
    PDOCFILE_VCALL (GetClass (pclsid));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::SetClass, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::SetClass(REFCLSID clsid)
{
    PDOCFILE_VCALL (SetClass (clsid));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetStateBits, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    PDOCFILE_VCALL (GetStateBits (pgrfStateBits));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::SetStateBits, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    PDOCFILE_VCALL (SetStateBits (grfStateBits, grfMask));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::CreateDocFile, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::CreateDocFile(CDfName const *pdfnName,
                DFLAGS const df,
                DFLUID luidSet,
                PDocFile **ppdfDocFile)
{
    PDOCFILE_VCALL (CreateDocFile (pdfnName, df, luidSet, ppdfDocFile));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetDocFile, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetDocFile(CDfName const *pdfnName,
                 DFLAGS const df,
                 PDocFile **ppdfDocFile)
{
    PDOCFILE_VCALL (GetDocFile (pdfnName, df, ppdfDocFile));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::CreateStream, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::CreateStream(CDfName const *pdfnName,
                   DFLAGS const df,
                   DFLUID luidSet,
                   PSStream **ppsstStream)
{
    PDOCFILE_VCALL (CreateStream (pdfnName, df, luidSet, ppsstStream));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::GetStream, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::GetStream(CDfName const *pdfnName,
                DFLAGS const df,
                PSStream **ppsstStream)
{
    PDOCFILE_VCALL (GetStream (pdfnName, df, ppsstStream));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::FindGreaterEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                   SIterBuffer *pib,
                                   STATSTGW *pstat)
{
    PDOCFILE_VCALL (FindGreaterEntry (pdfnKey, pib, pstat));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::StatEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::StatEntry(CDfName const *pdfn,
                            SIterBuffer *pib,
                            STATSTGW *pstat)
{
    PDOCFILE_VCALL (StatEntry (pdfn, pib, pstat));
}


//+--------------------------------------------------------------
//
//  Member: PDocFile::BeginCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::BeginCommitFromChild(CUpdateList &ulChanged,
                       DWORD const dwFlags,
                                       CWrappedDocFile *pdfChild)
{
    PDOCFILE_VCALL (BeginCommitFromChild (ulChanged, dwFlags, pdfChild));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::EndCommitFromChild, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PDocFile::EndCommitFromChild(DFLAGS const df,
                                    CWrappedDocFile *pdfChild)
{
    if (_sig == CDOCFILE_SIG)
        ((CDocFile *)this)->EndCommitFromChild (df, pdfChild);
    else if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->EndCommitFromChild (df, pdfChild);
    else olAssert (!"Invalid signature on PTimeEntry!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::IsEntry, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::IsEntry(CDfName const *pdfnName,
              SEntryBuffer *peb)
{
    PDOCFILE_VCALL (IsEntry (pdfnName, peb));
}

//+--------------------------------------------------------------
//
//  Member: PDocFile::DeleteContents, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PDocFile::DeleteContents(void)
{
    PDOCFILE_VCALL (DeleteContents());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\funcs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       funcs.cxx
//
//  Contents:   Generic DocFile support functions
//
//  Functions:  ModeToTFlags
//              CheckName
//              VerifyPerms
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <df32.hxx>


//+--------------------------------------------------------------
//
//  Function:   ModeToDFlags, private
//
//  Synopsis:   Translates STGM flags to DF flags
//
//  Arguments:  [dwModeFlags]
//
//  Returns:    DF_*
//
//  History:    04-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

DFLAGS ModeToDFlags(DWORD const dwModeFlags)
{
    DFLAGS df;

    olDebugOut((DEB_ITRACE, "In  ModeToDFlags(%lX)\n", dwModeFlags));
    if ((dwModeFlags & STGM_TRANSACTED) == 0)
        df = DF_DIRECT;
    else
        df = DF_TRANSACTED;
    if ((dwModeFlags & STGM_TRANSACTED) &&
        (dwModeFlags & STGM_PRIORITY) == 0 &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_DENY_WRITE &&
        (dwModeFlags & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
        df |= DF_INDEPENDENT;
    switch(dwModeFlags & STGM_RDWR)
    {
    case STGM_READ:
        df |= DF_READ;
        break;
    case STGM_WRITE:
        df |= DF_WRITE;
        break;
    case STGM_READWRITE:
        df |= DF_READWRITE;
        break;
    default:
        olAssert(FALSE);
        break;
    }
    switch(dwModeFlags & STGM_DENY)
    {
    case STGM_SHARE_DENY_READ:
        df |= DF_DENYREAD;
        break;
    case STGM_SHARE_DENY_WRITE:
        df |= DF_DENYWRITE;
        break;
    case STGM_SHARE_EXCLUSIVE:
        df |= DF_DENYALL;
        break;
        // Default is deny none
    }
    if (dwModeFlags & STGM_PRIORITY)
        df |= DF_PRIORITY;

#ifdef USE_NOSNAPSHOT_ALWAYS
    //This makes all transacted-writeable !deny-write instances no-snapshot,
    //  for testing.
    if ((dwModeFlags & STGM_TRANSACTED) &&
        !(df & DF_DENYWRITE) &&
        (df & DF_WRITE))
    {
        df |= DF_NOSNAPSHOT;
        df &= ~DF_INDEPENDENT;
    }
#else
    if (dwModeFlags & STGM_NOSNAPSHOT)
    {
        df |= DF_NOSNAPSHOT;
        df &= ~DF_INDEPENDENT;
    }
#endif //USE_NOSNAPSHOT_ALWAYS

#ifdef USE_NOSCRATCH_ALWAYS
    //This makes everything NOSCRATCH, for testing.
    if ((dwModeFlags & STGM_TRANSACTED) && (df & DF_WRITE))
        df |= DF_NOSCRATCH;
#else
    if (dwModeFlags & STGM_NOSCRATCH)
        df |= DF_NOSCRATCH;
#endif
#if WIN32 == 300
    if (dwModeFlags & STGM_EDIT_ACCESS_RIGHTS)
        df |= DF_ACCESSCONTROL;
#endif

    olDebugOut((DEB_ITRACE, "Out ModeToDFlags => %lX\n", df));
    return df;
}

//+--------------------------------------------------------------
//
//  Function:   DFlagsToMode, private
//
//  Synopsis:   Converts the read/write/denials/transacted/priority
//              to STGM flags
//
//  Arguments:  [df] - DFlags
//
//  Returns:    STGM flags
//
//  History:    24-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

DWORD DFlagsToMode(DFLAGS const df)
{
    DWORD dwMode = 0;

    olDebugOut((DEB_ITRACE, "In  DFlagsToMode(%X)\n", df));
    if (P_READ(df))
        if (P_WRITE(df))
            dwMode = STGM_READWRITE;
        else
            dwMode = STGM_READ;
    else if (P_WRITE(df))
        dwMode = STGM_WRITE;
    // Must have either read or write, so no else

    if (P_DENYREAD(df))
        if (P_DENYWRITE(df))
            dwMode |= STGM_SHARE_EXCLUSIVE;
        else
            dwMode |= STGM_SHARE_DENY_READ;
    else if (P_DENYWRITE(df))
        dwMode |= STGM_SHARE_DENY_WRITE;
    else
        dwMode |= STGM_SHARE_DENY_NONE;

    if (P_TRANSACTED(df))
        dwMode |= STGM_TRANSACTED;

    if (P_PRIORITY(df))
        dwMode |= STGM_PRIORITY;

    if (P_NOSCRATCH(df))
        dwMode |= STGM_NOSCRATCH;

    if (P_NOSNAPSHOT(df))
        dwMode |= STGM_NOSNAPSHOT;

    olDebugOut((DEB_ITRACE, "Out DFlagsToMode\n"));
    return dwMode;
}

//+--------------------------------------------------------------
//
//  Function:   VerifyPerms, private
//
//  Synopsis:   Checks flags to see if they are valid
//
//  Arguments:  [grfMode] - Permissions
//              [fRoot] - TRUE if checking root storage
//
//  Returns:    Appropriate status code
//
//  Notes:      This routine is called when opening a root storage
//              or a subelement.  When changing root permissions,
//              use the fRoot flag to preserve compatibily for
//              return codes when opening subelements
//
//  History:    19-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE VerifyPerms(DWORD grfMode, BOOL fRoot)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  VerifyPerms(%lX)\n", grfMode));

    // Check for valid flags
    if ((grfMode & STGM_RDWR) > STGM_READWRITE ||
        (grfMode & STGM_DENY) > STGM_SHARE_DENY_NONE ||
        (grfMode & ~(STGM_RDWR | STGM_DENY | STGM_DIRECT | STGM_TRANSACTED |
                     STGM_PRIORITY | STGM_CREATE | STGM_CONVERT | STGM_SIMPLE |
                     STGM_NOSCRATCH |
#ifndef DISABLE_NOSNAPSHOT
                     STGM_NOSNAPSHOT |
#endif
#if WIN32 >= 300
                     STGM_EDIT_ACCESS_RIGHTS |
#endif
#ifdef DIRECTWRITERLOCK
             STGM_DIRECT_SWMR |
#endif
                     STGM_FAILIFTHERE | STGM_DELETEONRELEASE)))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // If priority is specified...
    if (grfMode & STGM_PRIORITY)
    {
        // Make sure no priority-denied permissions are specified
        if ((grfMode & STGM_RDWR) == STGM_WRITE ||
            (grfMode & STGM_RDWR) == STGM_READWRITE ||
            (grfMode & STGM_TRANSACTED))
            olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    // Check to make sure only one existence flag is specified
    // FAILIFTHERE is zero so it can't be checked
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) ==
        (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    // If not transacted and not priority, you can either be
    // read-only deny write or read-write deny all
    if ((grfMode & (STGM_TRANSACTED | STGM_PRIORITY)) == 0)
    {
        if ((grfMode & STGM_RDWR) == STGM_READ)
        {
            //  we're asking for read-only access

            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
#ifdef DIRECTWRITERLOCK
                    (!fRoot ||
             (grfMode & STGM_DIRECT_SWMR) == 0 ||
             (grfMode & STGM_DENY) != STGM_SHARE_DENY_NONE) &&
#endif
                (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE)
            {
                //  Can't allow others to have write access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
        else
        {
            //  we're asking for write access

#ifdef DIRECTWRITERLOCK
            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE &&
            (!fRoot ||
             (grfMode & STGM_DIRECT_SWMR) == 0 ||
             (grfMode & STGM_DENY) != STGM_SHARE_DENY_WRITE))
#else
            if ((grfMode & STGM_DENY) != STGM_SHARE_EXCLUSIVE)
#endif
            {
                //  Can't allow others to have any access
                olErr(EH_Err, STG_E_INVALIDFLAG);
            }
        }
    }

    //If this is not a root open, we can't pass STGM_NOSCRATCH or
    // STGM_NOSNAPSHOT
    if (!fRoot && (grfMode & (STGM_NOSCRATCH | STGM_NOSNAPSHOT)))
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    if (grfMode & STGM_NOSCRATCH)
    {
        if (((grfMode & STGM_RDWR) == STGM_READ) ||
            ((grfMode & STGM_TRANSACTED) == 0))
        {
            olErr(EH_Err, STG_E_INVALIDFLAG);
        }
    }

    if (grfMode & STGM_NOSNAPSHOT)
    {
        if (((grfMode & STGM_DENY) == STGM_SHARE_EXCLUSIVE) ||
            ((grfMode & STGM_DENY) == STGM_SHARE_DENY_WRITE) ||
            ((grfMode & STGM_TRANSACTED) == 0) ||
            ((grfMode & STGM_NOSCRATCH) != 0) ||
            ((grfMode & STGM_CREATE) != 0) ||
            ((grfMode & STGM_CONVERT) != 0))
        {
            olErr(EH_Err, STG_E_INVALIDFLAG);
        }
    }

    olDebugOut((DEB_ITRACE, "Out VerifyPerms\n"));
    // Fall through
EH_Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:     ValidateNameW, public
//
//  Synopsis:   Validate that a name is valid and no longer than the
//              size specified.
//
//  Arguments:  [pwcsName] -- Pointer to wide character string
//              [cchMax] -- Maximum length for string
//
//  Returns:    Appropriate status code
//
//  History:    23-Nov-98       PhilipLa        Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

SCODE ValidateNameW(LPCWSTR pwcsName, UINT cchMax)
{
    SCODE sc = S_OK;

#if WIN32 == 200
    if (IsBadReadPtrW(pwcsName, sizeof(WCHAR)))
        sc = STG_E_INVALIDNAME;
#else
    if (IsBadStringPtrW(pwcsName, cchMax))
        sc = STG_E_INVALIDNAME;
#endif
    else
    {
        __try
        {
                if ((UINT)lstrlenW(pwcsName) >= cchMax)
                    sc = STG_E_INVALIDNAME;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            sc = STG_E_INVALIDNAME;
        }
    }
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   CheckName, public
//
//  Synopsis:   Checks name for illegal characters and length
//
//  Arguments:  [pwcsName] - Name
//
//  Returns:    Appropriate status code
//
//  History:    11-Feb-92       DrewB   Created
//                              04-Dec-95               SusiA   Optimized
//
//---------------------------------------------------------------

SCODE CheckName(WCHAR const *pwcsName)
{
    LPCWSTR pChar;
        
        //Each character's position in the array is detrmined by its ascii numeric
        //value.  ":" is 58, so bit 58 of the array will be 1 if ":" is illegal.
        //32bits per position in the array, so 58/32 is in Invalid[1].
        //58%32 = 28th bit ( 0x04000000 ) in Invalid[1].

    /* Invalid characters:                               :  /  !   \ */
    static ULONG const Invalid[128/32] =
        {0x00000000,0x04008002,0x10000000,0x00000000};

    SCODE sc = STG_E_INVALIDNAME;
    olDebugOut((DEB_ITRACE, "In  CheckName(%ws)\n", pwcsName));

    __try
        {
                for (pChar = (LPCWSTR)pwcsName;
                         pChar < (LPCWSTR) &pwcsName[CWCMAXPATHCOMPLEN];
             pChar++)
                {
            if (*pChar == L'\0')
            {
                sc = S_OK;
                break;                  // Success
            }

            // Test to see if this is an invalid character
            if (*pChar < 128 &&
                // All values above 128 are valid
                (Invalid[*pChar / 32] & (1 << (*pChar % 32))) != 0)
                // check to see if this character's bit is set
            {
                break;                  // Failure: invalid Char
            }
        }
    }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
    }

        olDebugOut((DEB_ITRACE, "Out CheckName\n"));
    return sc;
        
}


//+--------------------------------------------------------------
//
//  Function:   ValidateSNB, private
//
//  Synopsis:   Validates SNB memory
//
//  Arguments:  [snb] - SNB
//
//  Returns:    Appropriate status code
//
//  History:    10-Jun-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE ValidateSNB(SNBW snb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ValidateSNB(%p)\n", snb));
    for (;;)
    {
        olChk(ValidatePtrBuffer(snb));
        if (*snb == NULL)
            break;
        olChk(ValidateNameW(*snb, CWCMAXPATHCOMPLEN));
        snb++;
    }
    olDebugOut((DEB_ITRACE, "Out ValidateSNB\n"));
    return S_OK;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   CopySStreamToSStream
//
//  Synopsis:   Copies the contents of a stream to another stream
//
//  Arguments:  [psstFrom] - Stream to copy from
//              [psstTo] - Stream to copy to
//
//  Returns:    Appropriate status code
//
//  History:    13-Sep-91       DrewB   Created
//
//  Notes:      This function may fail due to out of memory.  It
//              may not be used by callers who must not fail due
//              to out of memory.
//
//---------------------------------------------------------------

SCODE CopySStreamToSStream(PSStream *psstFrom, PSStream *psstTo)
{
    BYTE *pbBuffer = NULL;
    SCODE sc;
#ifdef LARGE_STREAMS
    ULONGLONG cbSize = 0, cbPos;
    ULONG cbRead, cbWritten;
#else
    ULONG cbRead, cbWritten, cbSize, cbPos;
#endif

    // We're allowed to fail due to out of memory
    olMem(pbBuffer = (BYTE *) DfMemAlloc(STREAMBUFFERSIZE));

    // Set destination size for contiguity
    psstFrom->GetSize(&cbSize);
    olChk(psstTo->SetSize(cbSize));

    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        olChk(psstFrom->ReadAt(cbPos, pbBuffer, STREAMBUFFERSIZE,
                               (ULONG STACKBASED *)&cbRead));
        if (cbRead == 0) // EOF
            break;
        olChk(psstTo->WriteAt(cbPos, pbBuffer, cbRead,
                              (ULONG STACKBASED *)&cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }

EH_Err:
    DfMemFree(pbBuffer);
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   dfwcsnicmp, public
//
//  Synopsis:   wide character string compare that interoperates with what
//              we did on 16-bit windows.
//
//  Arguments:  [wcsa] -- First string
//              [wcsb] -- Second string
//              [len] -- Length to compare to
//
//  Returns:    > 0 if wcsa > wcsb
//              < 0 if wcsa < wcsb
//              0 is wcsa == wcsb
//
//  History:    11-May-95       PhilipLa        Created
//                              22-Nov-95       SusiA           Optimize comparisons
//
//  Notes:      This function is necessary because on 16-bit windows our
//              wcsnicmp function converted everything to uppercase and
//              compared the strings, whereas the 32-bit runtimes convert
//              everything to lowercase and compare.  This means that the
//              sort order is different for string containing [\]^_`
//
//----------------------------------------------------------------------------

int dfwcsnicmp(const WCHAR *wcsa, const WCHAR *wcsb, size_t len)
{
    if (!len)
        return 0;

    while (--len && *wcsa &&
                   ( *wcsa == *wcsb ||
                     CharUpperW((LPWSTR)*wcsa) == CharUpperW((LPWSTR)*wcsb)))
    {
        wcsa++;
        wcsb++;
    }
    return (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsa) -
           (int)(LONG_PTR)CharUpperW((LPWSTR)*wcsb);
}


//+--------------------------------------------------------------
//
//  Function:   NameInSNB, private
//
//  Synopsis:   Determines whether the given name is in the SNB
//
//  Arguments:  [dfn] - Name
//              [snb] - SNB
//
//  Returns:    S_OK or S_FALSE
//
//  History:    19-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE NameInSNB(CDfName const *dfn, SNBW snb)
{
    SCODE sc = S_FALSE;

    olDebugOut((DEB_ITRACE, "In  NameInSNB(%ws, %p)\n", dfn, snb));
    TRY
    {
        for (; *snb; snb++)
            if ((lstrlenW(*snb)+1)*sizeof(WCHAR) == dfn->GetLength() &&
#ifdef CASE_SENSITIVE
                memcmp(dfn->GetBuffer(), *snb, dfn->GetLength()) == 0)
#else
                dfwcsnicmp((WCHAR *)dfn->GetBuffer(), (WCHAR *)*snb,
                           dfn->GetLength()/sizeof(WCHAR)) == 0)
#endif
            {
                sc = S_OK;
                break;
            }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_ITRACE, "Out NameInSNB\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Win32ErrorToScode, public
//
//  Synopsis:   Map a Win32 error into a corresponding scode, remapping
//              into Facility_Storage if appropriate.
//
//  Arguments:  [dwErr] -- Win32 error to map
//
//  Returns:    Appropriate scode
//
//  History:    22-Sep-93       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE Win32ErrorToScode(DWORD dwErr)
{
    olAssert((dwErr != NO_ERROR) &&
             aMsg("Win32ErrorToScode called on NO_ERROR"));

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
        sc = STG_E_INVALIDFUNCTION;
        break;
    case ERROR_FILE_NOT_FOUND:
        sc = STG_E_FILENOTFOUND;
        break;
    case ERROR_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;
    case ERROR_TOO_MANY_OPEN_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;
    case ERROR_INVALID_HANDLE:
        sc = STG_E_INVALIDHANDLE;
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;
    case ERROR_NO_MORE_FILES:
        sc = STG_E_NOMOREFILES;
        break;
    case ERROR_WRITE_PROTECT:
        sc = STG_E_DISKISWRITEPROTECTED;
        break;
    case ERROR_SEEK:
        sc = STG_E_SEEKERROR;
        break;
    case ERROR_WRITE_FAULT:
        sc = STG_E_WRITEFAULT;
        break;
    case ERROR_READ_FAULT:
        sc = STG_E_READFAULT;
        break;
    case ERROR_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;
    case ERROR_LOCK_VIOLATION:
        sc = STG_E_LOCKVIOLATION;
        break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
        sc = STG_E_FILEALREADYEXISTS;
        break;
    case ERROR_INVALID_PARAMETER:
        sc = STG_E_INVALIDPARAMETER;
        break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
        sc = STG_E_INVALIDNAME;
        break;
    case ERROR_INVALID_FLAGS:
        sc = STG_E_INVALIDFLAG;
        break;
    case ERROR_CANT_ACCESS_FILE:
        sc= STG_E_DOCFILECORRUPT;
        break;
    default:
        sc = WIN32_SCODE(dwErr);
        break;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidStgInterface
//
//  Synopsis:   a copy of the old IsValidInterface() from COM
//
//  Arguments:  [pv] -- interface to validate
//
//  Returns:    Appropriate flag
//
//  History:    08-May-2000     HenryLee        Created
//
//----------------------------------------------------------------------------

BOOL IsValidStgInterface( void * pv )
{
    ULONG_PTR *      pVtbl;
    BYTE      *      pFcn;
    volatile BYTE           bInstr;

    __try {
        pVtbl = *(ULONG_PTR **) pv;         // beginning of vtable

#if DBG==1
        for (int i=0 ; i<3; ++i)            // loop through qi,addref,rel
#else
        int i=1;                            // in retail, just do AddRef
#endif
        {
            pFcn = *(BYTE **) &pVtbl[i]; 
#if DBG==1
            if (IsBadCodePtr((FARPROC)pFcn)) {
                return FALSE;
            }
#endif
            bInstr = *(BYTE *) pFcn;        // get 1st byte of 1st instruction
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\publicdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       publicdf.cxx
//
//  Contents:   Public DocFile implementation
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <time.h>
#include <pbstream.hxx>
#include <tstream.hxx>
#include <sstream.hxx>
#include <lock.hxx>
#include <rpubdf.hxx>

//+--------------------------------------------------------------
//
//  Member: PRevertable::RevertFromAbove, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PRevertable::RevertFromAbove(void)
{
    if (_sig == CPUBDOCFILE_SIG || _sig == CROOTPUBDOCFILE_SIG)
        ((CPubDocFile *)this)->RevertFromAbove();
    else if (_sig == CPUBSTREAM_SIG)
        ((CPubStream *)this)->RevertFromAbove();
    else olAssert (!"Invalid signature on PRevertable");
}

//+--------------------------------------------------------------
//
//  Member: PRevertable::FlushBufferedData, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PRevertable::FlushBufferedData(int recursionlevel)
{
    if (_sig == CPUBDOCFILE_SIG || _sig == CROOTPUBDOCFILE_SIG)
        return ((CPubDocFile *)this)->FlushBufferedData(recursionlevel);
    else if (_sig == CPUBSTREAM_SIG)
        return ((CPubStream *)this)->FlushBufferedData(recursionlevel);
    else olAssert (!"Invalid signature on PRevertable");
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member: PRevertable::EmptyCache, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PRevertable::EmptyCache()
{
    if (_sig == CPUBDOCFILE_SIG || _sig == CROOTPUBDOCFILE_SIG)
        ((CPubDocFile *)this)->EmptyCache();
    else if (_sig == CPUBSTREAM_SIG)
        ((CPubStream *)this)->EmptyCache();
    else olAssert (!"Invalid signature on PRevertable");
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::CPubDocFile, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdfParent] - Parent PubDocFile
//              [pdf] - DocFile basis
//              [df] - Permissions
//              [luid] - LUID
//              [pdfb] - Basis
//              [pdfn] - name
//              [cTransactedDepth] - Number of transacted parents
//              [pmsBase] - Base multistream
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CPubDocFile::CPubDocFile(CPubDocFile *pdfParent,
        PDocFile *pdf,
        DFLAGS const df,
        DFLUID luid,
        CDFBasis *pdfb,
        CDfName const *pdfn,
        UINT cTransactedDepth,
        CMStream *pmsBase)
{
    olDebugOut((DEB_ITRACE, "In  CPubDocFile::CPubDocFile("
            "%p, %p, %X, %lu, %p, %p, %lu, %p)\n",
            pdfParent, pdf, df, luid, pdfb, pdfn, cTransactedDepth,
            pmsBase));
    _pdfParent = P_TO_BP(CBasedPubDocFilePtr, pdfParent);
    _pdf = P_TO_BP(CBasedDocFilePtr, pdf);
    _df = df;
    _luid = luid;
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _cTransactedDepth = cTransactedDepth;

    _wFlags = 0;
    _pmsBase = P_TO_BP(CBasedMStreamPtr, pmsBase);

    _cReferences = 1;
    if (pdfn)
    {
        _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    }
    else
    {
        _dfn.Set((WORD)0, (BYTE *)NULL);
    }

    if (!IsRoot())
        _pdfParent->AddChild(this);

    _sig = CPUBDOCFILE_SIG;

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::CPubDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::~CPubDocFile, public
//
//  Synopsis:   Destructor
//
//  History:    23-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::vdtor(void)
{
    olAssert(_cReferences == 0);

    if (_sig == CROOTPUBDOCFILE_SIG)
    {
        ((CRootPubDocFile *)this)->vdtor();
        return;
    }

    _sig = CPUBDOCFILE_SIGDEL;

    if (SUCCEEDED(CheckReverted()))
    {
        ChangeXs(DF_NOLUID, XSO_RELEASE);
        olAssert(!IsRoot());
        _pdfParent->ReleaseChild(this);

        _cilChildren.DeleteByName(NULL);

        if (_pdf)
            _pdf->Release();
    }
    delete this;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Release, public
//
//  Synopsis:   Releases resources for a CPubDocFile
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::vRelease(void)
{
    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Release()\n"));

    olAssert(_cReferences > 0);

    if (_pdf && !P_TRANSACTED(_df) && SUCCEEDED(CheckReverted()))
    {
        TIME_T tm;

#ifdef ACCESSTIME
        olVerSucc(DfGetTOD(&tm));
        olVerSucc(_pdf->SetTime(WT_ACCESS, tm));
#endif

#ifdef NEWPROPS
        olVerSucc(FlushBufferedData(0));
#endif
        if (IsDirty())
        {
            olVerSucc(DfGetTOD(&tm));
            olVerSucc(_pdf->SetTime(WT_MODIFICATION, tm));
            if (!IsRoot())
                _pdfParent->SetDirty();
            else
            {
                msfAssert(P_WRITE(_df) &&
                        aMsg("Dirty & Direct but no write access"));
            }
            SetClean();
        }
        if (IsRoot() && P_WRITE(_df))
        {
            SCODE sc;
            sc = _pmsBase->Flush(0);
#if DBG == 1
            if (FAILED(sc))
            {
                olDebugOut((DEB_ERROR,
                            "ILockBytes::Flush() failed in release path "
                            "with error %lx\n", sc));
            }
#endif
        }
    }

    vDecRef();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::Release()\n"));
}

//+--------------------------------------------------------------
//
//  Method:     CPubDocFile::CopyLStreamToLStream, private
//
//  Synopsis:   Copies the contents of a stream to another stream
//
//  Arguments:  [plstFrom] - Stream to copy from
//              [plstTo] - Stream to copy to
//
//  Returns:    Appropriate status code
//
//  History:    13-Sep-91       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::CopyLStreamToLStream(ILockBytes *plstFrom,
        ILockBytes *plstTo)
{
    BYTE *pbBuffer;
    ULONG cbBuffer = 0;
    SCODE sc;
    ULONG cbRead, cbWritten;
    ULARGE_INTEGER cbPos;
    STATSTG stat;
    ULONG cbBufferSave;

    GetSafeBuffer(CB_SMALLBUFFER, CB_LARGEBUFFER, &pbBuffer, &cbBuffer);
    olAssert((pbBuffer != NULL) && aMsg("Couldn't get scratch buffer"));

    // Set destination size for contiguity
    olHChk(plstFrom->Stat(&stat, STATFLAG_NONAME));
    olHChk(plstTo->SetSize(stat.cbSize));

    // Copy between streams
    ULISet32 (cbPos, 0);
    for (;;)
    {
        BOOL fRangeLocks = IsInRangeLocks (cbPos.QuadPart, cbBuffer);
        if (fRangeLocks)
        {
            ULONG ulRangeLocksBegin = OLOCKREGIONEND_SECTORALIGNED;
            // For unbuffered I/O, make sure we skip a whole page
            cbBufferSave = cbBuffer;

            ulRangeLocksBegin -= (_pdfb->GetOpenFlags() & DF_LARGE) ?
                                  CB_PAGEBUFFER : HEADERSIZE;
            cbBuffer = ulRangeLocksBegin - cbPos.LowPart;
        }

        cbWritten = 0;
        if (cbBuffer > 0)
        {
            olHChk(plstFrom->ReadAt(cbPos, pbBuffer, cbBuffer, &cbRead));
            if (cbRead == 0) // EOF
                break;
            olHChk(plstTo->WriteAt(cbPos, pbBuffer, cbRead, &cbWritten));
            if (cbRead != cbWritten)
                olErr(EH_Err, STG_E_WRITEFAULT);
        }

        if (fRangeLocks)
        {
            cbBuffer = cbBufferSave;
            cbWritten = cbBuffer;
        }
        cbPos.QuadPart += cbWritten;
    }
    // Fall through
 EH_Err:
    FreeBuffer(pbBuffer);
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPubDocFile::PrepareForOverwrite, private
//
//  Synopsis:   Make sure that there is enough space to do a commit
//              when the overwrite flag has been specified.
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  History:    08-Jul-92       PhilipLa        Created.
//
//--------------------------------------------------------------------------


SCODE CPubDocFile::PrepareForOverwrite(void)
{
    SCODE sc;
#ifdef LARGE_DOCFILE
    ULONGLONG ulSize;
#else
    ULONG ulSize;
#endif
    ULARGE_INTEGER ulNewSize;

    olChk(GetCommitSize(&ulSize));

    ulNewSize.QuadPart = ulSize;

    if (P_INDEPENDENT(_df))
    {
        STATSTG statOrig;

        olHChk(_pdfb->GetOriginal()->Stat(&statOrig, STATFLAG_NONAME));
        olAssert(ULIGetHigh(statOrig.cbSize) == 0);

        if (ulNewSize.QuadPart > statOrig.cbSize.QuadPart)
        {
            olHChk(_pdfb->GetOriginal()->SetSize(ulNewSize));
        }
    }

    sc = DfGetScode(_pmsBase->GetILB()->SetSize(ulNewSize));
    // Fall through
 EH_Err:
    olDebugOut((DEB_ITRACE,"Out CPubDocFile::PrepareForOverwrite() =>"
            "%lu\n", sc));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPubDocFile::GetCommitSize, public
//
//  Synopsis:	Get the total size needed to commit the current docfile
//              with overwrite permissions.
//
//  Arguments:	[pulSize] -- Return location for size
//
//  Returns:	Appropriate status code
//
//  Algorithm:  For each Transaction Set Member call GetCommitInfo()
//              1)  If Tset member is a Docfile, then GetCommitInfo
//                  returns number of deleted entries and number of
//                  newly created entries.
//              2)  If Tset member is a stream, GetCommitInfo returns
//                  current size and size of base.
//              Determine the number of DirSectors needed to handle
//                  newly created entries.
//              Determine number of data sectors needed to hold new
//                  stream info.
//              Determine number of fat sectors needed to hold new
//                  data and dir sectors.
//              Determine number of DI Fat sectors needed to hold new
//                  fat sectors.
//              Add size of new sectors to the current size of the
//                  base and return that value.
//
//  History:	15-Jun-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#ifdef LARGE_DOCFILE
SCODE CPubDocFile::GetCommitSize(ULONGLONG *pulSize)
#else
SCODE CPubDocFile::GetCommitSize(ULONG *pulSize)
#endif
{
    SCODE sc;
    PTSetMember *ptsm;
    ULONG cDirEntries = 0;
    ULONG cNewSectors = 0;
    ULONG cMiniSectors = 0;
    ULONG cMiniFatSectors;
    ULONG cFatSectors = 0;
    ULONG cFatLast;
    ULONG cDIFatSectors = 0;

    olDebugOut((DEB_ITRACE,"In CPubDocFile::PrepareForOverwrite()\n"));
    //Bytes per sector
    ULONG cbSect = _pmsBase->GetSectorSize();

    if (!(_wFlags & PF_PREPARED))
    {
        //DirEntries per sector
        ULONG cdsSect = cbSect / sizeof(CDirEntry);

        //Fat entries per sector
        ULONG cfsSect = cbSect / sizeof(SECT);

        //Minisectors per sector
        ULONG cmsSect = cbSect / MINISECTORSIZE;

#ifdef LARGE_STREAMS
        ULONGLONG ulRet1 = 0, ulRet2 = 0;
#else
        ULONG ulRet1, ulRet2;
#endif
        for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
        {
            ptsm->GetCommitInfo(&ulRet1, &ulRet2);
            switch(REAL_STGTY(ptsm->ObjectType()))
            {
            case STGTY_STORAGE:
                if (ulRet2 < ulRet1)
                {
                    cDirEntries += (ULONG)(ulRet1 - ulRet2);
                }
                break;
            case STGTY_STREAM:
                //If new size is larger than old...
                if (ulRet2 > ulRet1)
                {
                    if (ulRet2 < MINISTREAMSIZE)
                    {
                        cMiniSectors += (ULONG)(((ulRet2 + MINISECTORSIZE - 1)
                                / MINISECTORSIZE) -
                                ((ulRet1 + MINISECTORSIZE - 1)
                                 / MINISECTORSIZE));
                    }
                    else
                    {
                        ULONG csectOld = (ULONG)((ulRet1 + cbSect - 1)/cbSect);
                        ULONG csectNew = (ULONG)((ulRet2 + cbSect - 1)/cbSect);

                        cNewSectors += (csectNew - csectOld);
                    }
                }
                break;
            default:
                olAssert(!aMsg("Unknown pstm object type"));
                break;
            }
        }

        cNewSectors += (cDirEntries + cdsSect - 1) / cdsSect;
        cMiniFatSectors = ((cMiniSectors + cfsSect - 1) / cfsSect);

        cNewSectors += cMiniFatSectors + ((cMiniSectors + cmsSect -1) / cmsSect);

        do
        {
            cFatLast = cFatSectors;

            cFatSectors = (cNewSectors + cDIFatSectors + cFatSectors + cbSect - 1)
                / cbSect;

            cDIFatSectors = (cFatSectors + cfsSect - 1) / cfsSect;

        }
        while (cFatLast != cFatSectors);

        cNewSectors += cFatSectors + cDIFatSectors;

    }

    STATSTG stat;
    olHChk(_pmsBase->GetILB()->Stat(&stat, STATFLAG_NONAME));

#ifdef LARGE_DOCFILE
    *pulSize = stat.cbSize.QuadPart + cNewSectors * cbSect;
#else
    *pulSize = stat.cbSize.LowPart + cNewSectors * cbSect;
#endif

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::Commit(DWORD const dwFlags)
{
    SCODE sc=S_OK;
#ifndef COORD
    TIME_T tm;
    PTSetMember *ptsm;
    ULONG ulLock = 0;
    DFSIGNATURE sigMSF;

    BOOL fFlush = FLUSH_CACHE(dwFlags);

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Commit:%p(%lX)\n",
                this, dwFlags));

    olChk(CheckReverted());
    if (!P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    if (IsDirty())
    {
        olChk(DfGetTOD(&tm));
        olChk(_pdf->SetTime(WT_MODIFICATION, tm));
    }

    if (P_NOSNAPSHOT(_df) && (dwFlags & STGC_OVERWRITE))
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }

#ifdef ACCESSTIME
    olChk(DfGetTOD(&tm));
    olChk(_pdf->SetTime(WT_ACCESS, tm));
#endif

#ifdef NEWPROPS
    olChk(FlushBufferedData(0));
#endif

    if (!P_TRANSACTED(_df))
    {
        if (IsDirty())
        {
            if (!IsRoot())
                _pdfParent->SetDirty();
            SetClean();
        }

        if (_cTransactedDepth == 0)
        {
            if(STGC_CONSOLIDATE & dwFlags)
                sc = Consolidate(dwFlags);

            olChk(_pmsBase->Flush(fFlush));
        }
        return S_OK;
    }

    olAssert(GetTransactedDepth() > 0 &&
             aMsg("Transaction depth/flags conflict"));

    if (GetTransactedDepth() == 1)
    {
        // A transacted depth of 1 means this is the lowest transacted
        // level and committed changes will go into the real file,
        // so do all the special contents protection and locking

        if (_pdfb->GetOrigLockFlags() & LOCK_ONLYONCE)
            olChk(WaitForAccess(_pdfb->GetOriginal(), DF_WRITE,
                                &ulLock));

        olChkTo(EH_GetAccess, _pmsBase->BeginCopyOnWrite(dwFlags));

        if (dwFlags & STGC_OVERWRITE)
        {
            olChkTo(EH_COW, PrepareForOverwrite());
        }

        if (P_INDEPENDENT(_df) || P_NOSNAPSHOT(_df))
        {
            if (_sigMSF == DF_INVALIDSIGNATURE)
            {
                if ((dwFlags & STGC_ONLYIFCURRENT) &&
                    DllIsMultiStream(_pdfb->GetOriginal()) == S_OK)
                    olErr(EH_COW, STG_E_NOTCURRENT);
            }
            else
            {
                olChkTo(EH_COW, DllGetCommitSig(_pdfb->GetOriginal(),
                                                      &sigMSF));
                if (dwFlags & STGC_ONLYIFCURRENT)
                    if (sigMSF != _sigMSF)
                        olErr(EH_COW, STG_E_NOTCURRENT);
            }
        }
    }

    for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
        if ((ptsm->GetFlags() & XSM_DELETED) == 0)
            olChkTo(EH_NoCommit, ptsm->BeginCommit(dwFlags));

    //  10/02/92 - To handle low disk space situations well, we
    //  preallocate the space we'll need to copy (when independent).

    STATSTG statBase, statOrig;

    if (P_INDEPENDENT(_df))
    {
        // With DELAYFLUSH we can't be sure of the size
        // of the file until EndCopyOnWrite, but we do
        // know that the file won't grow so this is safe

        olHChkTo(EH_NoCommit, _pdfb->GetBase()->Stat(&statBase,
                                                     STATFLAG_NONAME));
        olAssert(ULIGetHigh(statBase.cbSize) == 0);

        olHChkTo(EH_NoCommit, _pdfb->GetOriginal()->Stat(&statOrig,
                                                         STATFLAG_NONAME));
        olAssert(ULIGetHigh(statOrig.cbSize) == 0);

        if (ULIGetLow(statBase.cbSize) > ULIGetLow(statOrig.cbSize))
        {
            olHChkTo(EH_NoCommit,
                     _pdfb->GetOriginal()->SetSize(statBase.cbSize));
        }
    }

    //End of phase 1 of commit.

    if (GetTransactedDepth() == 1)
    {
        olChkTo(EH_ResetSize,
            _pmsBase->EndCopyOnWrite(dwFlags, DF_COMMIT));
    }

    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // End commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_COMMIT);

    //
    // Do consolidation here, before we might
    // copy the snapshot back to the original file.
    //
    if(STGC_CONSOLIDATE & dwFlags)
    {
        sc = Consolidate(dwFlags);
    }

    //
    // If this is a root storage in transacted w/ snapshot mode.
    // Copy the snapshot back to the original file.  Only the root
    // transacted storage can be intependent so transacted substorages
    // of direct mode opens do not qualify.
    //
    if (P_INDEPENDENT(_df))
    {
        SCODE scTemp;
        // Not robust against power failure!
        // We made sure we had enough disk space by presetting the larger
        // size.  But should the write fail part way through for other
        // reasons then we have lost the original file!
        // To do this robustly we could "commit" the whole base file to the
        // end of the original file.  Then consolidate the result.
        // But... we don't.  Perhaps we could revisit this later.

        olVerSucc(scTemp = CopyLStreamToLStream(_pdfb->GetBase(),
                                       _pdfb->GetOriginal()));
        olVerSucc(_pdfb->GetOriginal()->Flush());
    }

    if (P_INDEPENDENT(_df) || P_NOSNAPSHOT(_df))
    {
        if (_sigMSF == DF_INVALIDSIGNATURE)
        {
            olVerSucc(DllGetCommitSig(_pdfb->GetOriginal(), &_sigMSF));
        }
        else
        {
            _sigMSF = sigMSF+1;
            olVerSucc(DllSetCommitSig(_pdfb->GetOriginal(), _sigMSF));
        }
    }

    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);

    //  Dirty all parents up to the next transacted storage
    if (IsDirty())
    {
        if (!IsRoot())
            _pdfParent->SetDirty();
        SetClean();
    }

    olDebugOut((DEB_ITRACE, "Out CTransactionLevel::Commit\n"));
#if DBG == 1
    VerifyXSMemberBases();
#endif
    _wFlags = (_wFlags & ~PF_PREPARED);

    if (_sig == CROOTPUBDOCFILE_SIG)
    {
        ((CRootPubDocFile *)this)->CommitTimestamps(dwFlags);
    }

    return sc;

EH_ResetSize:
    if (P_INDEPENDENT(_df) &&
        (ULIGetLow(statBase.cbSize) > ULIGetLow(statOrig.cbSize)))
    {
        _pdfb->GetOriginal()->SetSize(statOrig.cbSize);
    }
EH_NoCommit:
    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // Abort commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_ABORT);
EH_COW:
    if (GetTransactedDepth() == 1)
    {
        olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));
    }
EH_GetAccess:
    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);
EH_Err:
    return sc;

#else //COORD
    ULONG ulLock = 0;
    DFSIGNATURE sigMSF;
    ULONG cbSizeBase;
    ULONG cbSizeOrig;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Commit:%p(%lX)\n",
                this, dwFlags));

    sc = CommitPhase1(dwFlags, &ulLock, &sigMSF, &cbSizeBase, &cbSizeOrig);

    //Only do phase 2 if we're transacted and phase 1 succeeded.
    if (P_TRANSACTED(_df) && SUCCEEDED(sc))
    {
        sc = CommitPhase2(dwFlags,
                          TRUE,
                          ulLock,
                          sigMSF,
                          cbSizeBase,
                          cbSizeOrig);
    }

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::Commit -> %lX\n", sc));

    return sc;
#endif //!COORD
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Consolidate, private
//
//  Synopsis:   Consolidates a Docfile by moving sectors down
//              and filling in free space holes in the file.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    10-Feb-1997       BChapman   Created
//
//---------------------------------------------------------------

SCODE CPubDocFile::Consolidate(DWORD dwFlags)
{
    SCODE sc;

    //
    // Consolidation only makes sense when we are writting to the
    // real file, so we only consolidate on top level commits.
    //
    if(GetTransactedDepth() > 1)
    {
        return STG_S_CANNOTCONSOLIDATE;
    }

    //
    // Consolidating NoScratch is not supported.
    //
    if(P_NOSCRATCH(_df))
    {
        return STG_S_CANNOTCONSOLIDATE;
    }

    //
    // We can only Considate if there is one "seperate" open of the
    // file.  Marshaled opens are OK.
    //

    if(P_NOSNAPSHOT(_df))
    {
        sc = IsSingleWriter();
        if (sc != S_OK)
        {
            return STG_S_MULTIPLEOPENS;
        }
    }

    //
    // Make A backup copy of the FAT, header, etc...
    // Get ready to try to make some revertable changes to the file.
    //
    olChk(_pmsBase->BeginCopyOnWrite(dwFlags));

    //
    // Pack the file down.
    //
    olChkTo(EH_Abort, _pmsBase->Consolidate());
    EmptyCache();

    //
    // Finally commit the consolidation.
    //
    olChkTo(EH_Abort, _pmsBase->EndCopyOnWrite(dwFlags, DF_COMMIT));

    return S_OK;

EH_Abort:
    EmptyCache();
    olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));

EH_Err:
    return STG_S_CONSOLIDATIONFAILED;
}


//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::IsSingleWriter, private
//
//  Synopsis:   Compare the number of locks on the file with the number
//              of Contexts that have this file open.
//
//  Arguments:
//
//  Returns:
//
//  History:    10-Feb-1997       BChapman   Created
//
//---------------------------------------------------------------

SCODE CPubDocFile::IsSingleWriter(void)
{
    ILockBytes *ilb;
    SCODE sc;
    ULONG i, cWriteLocks=0;
    ULARGE_INTEGER uliOffset, ulicbLength;

    ilb = _pdfb->GetBase();

    ulicbLength.QuadPart = 1;
    for (i = 0; i < COPENLOCKS; i++)
    {
        uliOffset.QuadPart = (OOPENWRITELOCK+i);
        if(FAILED(ilb->LockRegion(uliOffset, ulicbLength, LOCK_ONLYONCE)))
        {
            ++cWriteLocks;
        }
        else
        {
            ilb->UnlockRegion(uliOffset, ulicbLength, LOCK_ONLYONCE);
        }
    }
    if(_pdfb->CountContexts() == cWriteLocks)
        return S_OK;

    return S_FALSE;
}


//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pdfnName] - Name of element
//              [fClean] - Whether this was invoked as cleanup or not
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::DestroyEntry(CDfName const *pdfnName,
                                BOOL fClean)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));
    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_pdf->DestroyEntry(pdfnName, fClean));
    _cilChildren.DeleteByName(pdfnName);
    SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::DestroyEntry\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::RenameEntry, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pdfnName] - Current name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//              28-Oct-92       AlexT   Add names to XSM's
//              09-Aug-93       AlexT   Disallow renames of open children
//
//---------------------------------------------------------------


SCODE CPubDocFile::RenameEntry(CDfName const *pdfnName,
                               CDfName const *pdfnNewName)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::RenameEntry(%ws, %ws)\n",
               pdfnName, pdfnNewName));
    olChk(CheckReverted());
    if (FAILED(_cilChildren.IsDenied(pdfnName, DF_WRITE | DF_DENYALL, _df)))
    {
        //  Translate all denial errors to STG_E_ACCESSDENIED
        sc = STG_E_ACCESSDENIED;
    }
    else
    {
        sc = _pdf->RenameEntry(pdfnName, pdfnNewName);

        if (SUCCEEDED(sc))
        {
            SetDirty();
        }
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::RenameEntry\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::CreateDocFile, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::CreateDocFile(CDfName const *pdfnName,
                                 DFLAGS const df,
                                 CPubDocFile **ppdfDocFile)
{
    PDocFile *pdf;
    SCODE sc;
    CWrappedDocFile *pdfWrapped = NULL;
    SEntryBuffer eb;
    UINT cNewTDepth;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::CreateDocFile:%p("
               "%ws, %X, %p)\n", this, pdfnName, df, ppdfDocFile));

    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(CDocFile::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
    cNewTDepth = _cTransactedDepth+(P_TRANSACTED(df) ? 1 : 0);
    olChkTo(EH_DirectReserve,
            CWrappedDocFile::Reserve(cNewTDepth, BP_TO_P(CDFBasis *, _pdfb)));

    olChkTo(EH_Reserve, _pdf->CreateDocFile(pdfnName, df, DF_NOLUID,
                                            &pdf));

    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();

    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    olMemTo(EH_pdf,
            *ppdfDocFile = new (_pmsBase->GetMalloc())
                               CPubDocFile(this, pdf, df, eb.luid,
                                           BP_TO_P(CDFBasis *, _pdfb),
                                           pdfnName, cNewTDepth,
                                           BP_TO_P(CMStream *, _pmsBase)));

    if (P_TRANSACTED(df))
    {
        pdfWrapped = new(BP_TO_P(CDFBasis *, _pdfb))
            CWrappedDocFile(pdfnName, eb.luid, df,
                            BP_TO_P(CDFBasis *, _pdfb), *ppdfDocFile);
        olAssert(pdfWrapped != NULL && aMsg("Reserved DocFile not found"));
        olChkTo(EH_pdfWrapped,
                pdfWrapped->Init(pdf));
        (*ppdfDocFile)->AddXSMember(NULL, pdfWrapped, eb.luid);
        (*ppdfDocFile)->SetDF(pdfWrapped);
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::CreateDocFile\n"));
    return S_OK;

 EH_pdfWrapped:
    delete pdfWrapped;
    (*ppdfDocFile)->vRelease();
    goto EH_Destroy;
 EH_pdf:
    pdf->Release();
    if (P_TRANSACTED(df))
        CWrappedDocFile::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Destroy:
    olVerSucc(_pdf->DestroyEntry(pdfnName, TRUE));
    return sc;
 EH_Reserve:
    CWrappedDocFile::Unreserve(cNewTDepth, BP_TO_P(CDFBasis *, _pdfb));
 EH_DirectReserve:
    CDocFile::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::GetDocFile, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdfDocFile] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfDocFile]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::GetDocFile(CDfName const *pdfnName,
                              DFLAGS const df,
                              CPubDocFile **ppdfDocFile)
{
    PDocFile *pdf;
    SCODE sc;
    CWrappedDocFile *pdfWrapped;
    SEntryBuffer eb;
    UINT cNewTDepth;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n",
               this, pdfnName, df, ppdfDocFile));

    olChk(CheckReverted());
    if (!P_READ(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check to see if an instance with DENY_* exists
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetDocFile(pdfnName, df, &pdf));

    eb.luid = pdf->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("DocFile id is DF_NOLUID!"));
    cNewTDepth = _cTransactedDepth+(P_TRANSACTED(df) ? 1 : 0);
    olMemTo(EH_pdf,
            *ppdfDocFile = new (_pmsBase->GetMalloc())
                               CPubDocFile(this, pdf, df, eb.luid,
                                           BP_TO_P(CDFBasis *, _pdfb),
                                           pdfnName, cNewTDepth,
                                           BP_TO_P(CMStream *, _pmsBase)));

    if (P_TRANSACTED(df))
    {
        olMemTo(EH_ppdf, pdfWrapped = new(_pmsBase->GetMalloc())
                CWrappedDocFile(pdfnName, eb.luid, df,
                                BP_TO_P(CDFBasis *, _pdfb), *ppdfDocFile));
        olChkTo(EH_pdfWrapped,
                pdfWrapped->Init(pdf));
        (*ppdfDocFile)->AddXSMember(NULL, pdfWrapped, eb.luid);
        (*ppdfDocFile)->SetDF(pdfWrapped);
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::GetDocFile\n"));
    return S_OK;

EH_pdfWrapped:
    delete pdfWrapped;
EH_ppdf:
    (*ppdfDocFile)->vRelease();
    return sc;
EH_pdf:
    pdf->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdstStream]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::CreateStream(CDfName const *pdfnName,
                                DFLAGS const df,
                                CPubStream **ppdstStream)
{
    PSStream *psst;
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::CreateStream:%p("
                "%ws, %X, %p)\n", this, pdfnName, df, ppdstStream));

    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(CDirectStream::Reserve(1, BP_TO_P(CDFBasis *, _pdfb)));
    olChkTo(EH_DirectReserve,
            CTransactedStream::Reserve(_cTransactedDepth,
                                       BP_TO_P(CDFBasis *, _pdfb)));
    olChkTo(EH_Reserve,
            _pdf->CreateStream(pdfnName, df, DF_NOLUID, &psst));

    //  As soon as we have a base we dirty ourself (in case
    //  we get an error later) so that we'll flush properly.
    SetDirty();

    eb.luid = psst->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("Stream id is DF_NOLUID!"));

    olMemTo(EH_Create, *ppdstStream = new (_pmsBase->GetMalloc())
                                          CPubStream(this, df, pdfnName));
    (*ppdstStream)->Init(psst, eb.luid);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::CreateStream\n"));
    return S_OK;

 EH_Create:
    psst->Release();
    olVerSucc(_pdf->DestroyEntry(pdfnName, TRUE));
    return sc;
 EH_Reserve:
    CTransactedStream::Unreserve(_cTransactedDepth,
                                 BP_TO_P(CDFBasis *, _pdfb));
 EH_DirectReserve:
    CDirectStream::Unreserve(1, BP_TO_P(CDFBasis *, _pdfb));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::GetStream, public
//
//  Synopsis:   Gets an existing stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [ppdstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdstStream]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::GetStream(CDfName const *pdfnName,
                             DFLAGS const df,
                             CPubStream **ppdstStream)
{
    PSStream *psst;
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::GetStream(%ws, %X, %p)\n",
                  pdfnName, df, ppdstStream));

    olChk(CheckReverted());
    if (!P_READ(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    // Check permissions
    olChk(_cilChildren.IsDenied(pdfnName, df, _df));

    olChk(_pdf->GetStream(pdfnName, df, &psst));

    eb.luid = psst->GetLuid();
    olAssert(eb.luid != DF_NOLUID && aMsg("Stream id is DF_NOLUID!"));

    olMemTo(EH_Get, *ppdstStream = new (_pmsBase->GetMalloc())
                                       CPubStream(this, df, pdfnName));


    (*ppdstStream)->Init(psst, eb.luid);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::GetStream\n"));
    return S_OK;

EH_Get:
    psst->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::Stat, public
//
//  Synopsis:   Fills in a stat buffer
//
//  Arguments:  [pstatstg] - Buffer
//              [grfStatFlag] - Stat flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CPubDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    if (_sig == CROOTPUBDOCFILE_SIG)
        return ((CRootPubDocFile *)this)->Stat (pstatstg, grfStatFlag);

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::Stat(%p, %lu)\n",
                pstatstg, grfStatFlag));
    olAssert(SUCCEEDED(VerifyStatFlag(grfStatFlag)));
    olChk(CheckReverted());

    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
#ifdef COORD
        if (P_COORD(_df))
        {
            olHChk(_pdfb->GetOriginal()->Stat((STATSTG *)pstatstg,
                                              grfStatFlag));
        }
        else
#endif
        {
            olMem(pstatstg->pwcsName =
                  (WCHAR *)TaskMemAlloc(_dfn.GetLength()));
            memcpy(pstatstg->pwcsName, _dfn.GetBuffer(), _dfn.GetLength());
        }
    }

    olChk(_pdf->GetTime(WT_CREATION, &pstatstg->ctime));
    olChk(_pdf->GetTime(WT_MODIFICATION, &pstatstg->mtime));
    pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
    olChk(_pdf->GetClass(&pstatstg->clsid));
    olChk(_pdf->GetStateBits(&pstatstg->grfStateBits));
    olAssert(!IsRoot());


    pstatstg->grfMode = DFlagsToMode(_df);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::Stat\n"));
    // Fall through
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::RevertFromAbove, public
//
//  Synopsis:   Parent has asked for reversion
//
//  History:    29-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::RevertFromAbove(void)
{
    olDebugOut((DEB_ITRACE, "In  CPubDocFile::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;

    _cilChildren.DeleteByName(NULL);

    ChangeXs(DF_NOLUID, XSO_RELEASE);
    _pdf->Release();
    _pdf = NULL;
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::RevertFromAbove\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::FlushBufferedData, public
//
//  Synopsis:   Flush buffered data in any child streams.
//
//  History:    5-May-1995       BillMo Created
//
//---------------------------------------------------------------

#ifdef NEWPROPS

SCODE CPubDocFile::FlushBufferedData(int recursionlevel)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::FlushBufferedData:%p()\n", this));

    if ((recursionlevel == 0 && (_df & DF_TRANSACTED)) ||
        (_df & DF_TRANSACTED) == 0)
    {
        sc = _cilChildren.FlushBufferedData(recursionlevel);
    }
    else
    {
        sc = S_OK;
    }

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::FlushBufferedData\n"));

    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::ChangeXs, public
//
//  Synopsis:   Performs an operation on the XS
//
//  Arguments:  [luidTree] - LUID of tree or DF_NOLUID
//              [dwOp] - Operation
//
//  History:    30-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::ChangeXs(DFLUID const luidTree,
                           DWORD const dwOp)
{
    olAssert((dwOp == XSO_RELEASE) || (dwOp == XSO_REVERT));

    PTSetMember *ptsmNext, *ptsmCur, *ptsmPrev;

    for (ptsmNext = _tss.GetHead(); ptsmNext; )
    {
        ptsmCur = ptsmNext;
        ptsmNext = ptsmCur->GetNext();
        olAssert ((ptsmCur->GetName() != ptsmCur->GetTree()));

        if (luidTree == DF_NOLUID || ptsmCur->GetName() == luidTree)
        {
            switch(dwOp)
            {
            case XSO_RELEASE:
                ptsmPrev = ptsmCur->GetPrev();
                _tss.RemoveMember(ptsmCur);
                ptsmCur->Release();
                if (ptsmPrev == NULL)
                    ptsmNext = _tss.GetHead();
                else
                    ptsmNext = ptsmPrev->GetNext();
                break;
            case XSO_REVERT:
                ptsmCur->Revert();
                // Revert might have changed the next pointer
                ptsmNext = ptsmCur->GetNext();
                break;
            }
        }
        else if (luidTree != DF_NOLUID && luidTree == ptsmCur->GetTree())
        {
//         This weirdness is necessary because ptsm will be
//         deleted by the call to ChangeXs.  Since ptsm->GetNext()
//         could also be deleted, we would have no way to continue.
//         ptsm->GetPrev() will never be deleted by the call to
//         ChangeXs, since all children of a node appear _after_
//         that node in the list.  Therefore, ptsm->GetPrev()->GetNext()
//         is the best place to resume the loop.

            ptsmPrev = ptsmCur->GetPrev();

            ChangeXs(ptsmCur->GetName(), dwOp);
            if (ptsmPrev == NULL)
                ptsmNext = _tss.GetHead();
            else
                ptsmNext = ptsmPrev->GetNext();
        }
    }

}

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::AddXSMember, public
//
//  Synopsis:   Adds an object to the XS
//
//  Arguments:  [ptsmRequestor] - Object requesting add or NULL if
//                      first addition
//              [ptsmAdd] - Object to add
//              [luid] - LUID of object
//
//  History:    29-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


void CPubDocFile::AddXSMember(PTSetMember *ptsmRequestor,
                              PTSetMember *ptsmAdd,
                              DFLUID luid)
{
    DFLUID luidTree;
    ULONG ulLevel;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::AddXSMember:%p("
                "%p, %p, %ld)\n", this, ptsmRequestor, ptsmAdd, luid));
    if (ptsmRequestor == NULL)
    {
        // If we're starting the XS, this is a new TL and we have
        // no tree
        luidTree = DF_NOLUID;
        ulLevel = 0;
    }
    else
    {
        // We're creating a subobject so it goes in the parent's tree
        luidTree = ptsmRequestor->GetName();
        ulLevel = ptsmRequestor->GetLevel()+1;
    }
    ptsmAdd->SetXsInfo(luidTree, luid, ulLevel);
    InsertXSMember(ptsmAdd);
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::AddXSMember\n"));
}

#if DBG == 1

//+--------------------------------------------------------------
//
//  Member:     CPubDocFile::VerifyXSMemberBases,public
//
//  Synopsis:   Verify that all XS members have valid bases
//
//  History:    15-Sep-92       AlexT   Created
//
//---------------------------------------------------------------

void CPubDocFile::VerifyXSMemberBases()
{
    PTSetMember *ptsm;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::VerifyXSMemberBases\n"));
    for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
    {
        DWORD otype = REAL_STGTY(ptsm->ObjectType());
        olAssert(otype == STGTY_STORAGE || otype == STGTY_STREAM);
        if (otype == STGTY_STORAGE)
        {
            CWrappedDocFile *pdf = (CWrappedDocFile *) ptsm;
            olAssert(pdf->GetBase() != NULL);
        }
        else
        {
            CTransactedStream *pstm = (CTransactedStream *) ptsm;
            olAssert(pstm->GetBase() != NULL);
        }
    }
    olDebugOut((DEB_ITRACE, "Out CPubDocFile::VerifyXSMemberBases\n"));
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::SetElementTimes, public
//
//  Synopsis:   Sets the times for an element
//
//  Arguments:  [pdfnName] - Name
//              [pctime] - Create time
//              [patime] - Access time
//              [pmtime] - Modify time
//
//  Returns:    Appropriate status code
//
//  History:    10-Nov-92       DrewB     Created
//              06-Sep-95       MikeHill  Added call to CMStream::MaintainFLBModifyTimestamp().
//              26-Apr-99       RogerCh   Removed call to CMStram::MaintainFLBModifyTimestamp().
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::SetElementTimes(CDfName const *pdfnName,
                                   FILETIME const *pctime,
                                   FILETIME const *patime,
                                   FILETIME const *pmtime)
{
    SCODE sc;
    PDocFile *pdf;
    PTSetMember *ptsm = NULL;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::SetElementTimes:%p("
                "%ws, %p, %p, %p)\n", this, pdfnName, pctime,
                patime, pmtime));
    olChk(CheckReverted());

    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
    {
        olErr(EH_Err, STG_E_ACCESSDENIED);
    }
           
    if (pdfnName != NULL)
    {
        if (_cilChildren.FindByName(pdfnName) != NULL)
            olErr(EH_Err, STG_E_ACCESSDENIED);
    }

    if (pdfnName == NULL)
    {
        //Set pdf to the transacted self object.
        pdf = BP_TO_P(PDocFile *, _pdf);
    }
    else if ((ptsm = FindXSMember(pdfnName, _luid)) != NULL)
    {
        if (ptsm->ObjectType() != STGTY_STORAGE)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        pdf = (CWrappedDocFile *)ptsm;
    }
    else olChk(_pdf->GetDocFile(pdfnName, DF_WRITE, &pdf));


    if (pctime)
    {
        olChkTo(EH_pdf, pdf->SetTime(WT_CREATION, *pctime));
    }
    if (pmtime)
    {
        olChkTo(EH_pdf, pdf->SetTime(WT_MODIFICATION, *pmtime));
    }
    if (patime)
    {
        olChkTo(EH_pdf, pdf->SetTime(WT_ACCESS, *patime));
    }

    if (pdfnName != NULL)
        SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::SetElementTimes\n"));
    // Fall through
 EH_pdf:
    if ((ptsm == NULL) && (pdfnName != NULL))
        pdf->Release();
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - Class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::SetClass(REFCLSID clsid)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::SetClass:%p(?)\n", this));
    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    sc = _pdf->SetClass(clsid);

    SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::SetClass\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - State bits
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CPubDocFile::SetStateBits:%p(%lu, %lu)\n",
                this, grfStateBits, grfMask));
    olChk(CheckReverted());
    if (!P_TRANSACTED(_df) && !P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    sc = _pdf->SetStateBits(grfStateBits, grfMask);

    SetDirty();

    olDebugOut((DEB_ITRACE, "Out CPubDocFile::SetStateBits\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubDocFile::Validate, public static
//
//  Synopsis:   Validates a possibly invalid public docfile pointer
//
//  Arguments:  [pdf] - Memory to check
//
//  Returns:    Appropriate status code
//
//  History:    26-Mar-93       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CPubDocFile::Validate(CPubDocFile *pdf)
{
    if (FAILED(ValidateBuffer(pdf, sizeof(CPubDocFile))) ||
        (pdf->_sig != CPUBDOCFILE_SIG && pdf->_sig != CROOTPUBDOCFILE_SIG))
    {
        return STG_E_INVALIDHANDLE;
    }
    return S_OK;
}



#ifdef COORD
//+---------------------------------------------------------------------------
//
//  Member:	CPubDocFile::CommitPhase1, public
//
//  Synopsis:	Do phase 1 of the commit sequence
//
//  Arguments:	[dwFlags] -- Commit flags
//
//  Returns:	Appropriate status code
//
//  History:	07-Aug-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPubDocFile::CommitPhase1(DWORD const dwFlags,
                                ULONG *pulLock,
                                DFSIGNATURE *psigMSF,
                                ULONG *pcbSizeBase,
                                ULONG *pcbSizeOrig)
{
    SCODE sc;
    TIME_T tm;
    PTSetMember *ptsm;
    ULONG ulLock = 0;
    DFSIGNATURE sigMSF;

    BOOL fFlush = FLUSH_CACHE(dwFlags);

    olChk(CheckReverted());
    if (!P_WRITE(_df))
        olErr(EH_Err, STG_E_ACCESSDENIED);

    if (IsDirty())
    {
        olChk(DfGetTOD(&tm));
        olChk(_pdf->SetTime(WT_MODIFICATION, tm));
    }


#ifdef ACCESSTIME
    olChk(DfGetTOD(&tm));
    olChk(_pdf->SetTime(WT_ACCESS, tm));
#endif

    if (!P_TRANSACTED(_df))
    {
        if (IsDirty())
        {
            if (!IsRoot())
                _pdfParent->SetDirty();
            SetClean();
        }

        if (_cTransactedDepth == 0)
        {
            //  Direct all the way
            olChk(_pmsBase->Flush(fFlush));
        }
        return S_OK;
    }

    olAssert(GetTransactedDepth() > 0 &&
             aMsg("Transaction depth/flags conflict"));

    if (GetTransactedDepth() == 1)
    {
        // A transacted depth of 1 means this is the lowest transacted
        // level and committed changes will go into the real file,
        // so do all the special contents protection and locking

        olChk(_pmsBase->BeginCopyOnWrite(dwFlags));

        if (dwFlags & STGC_OVERWRITE)
        {
            olChk(PrepareForOverwrite());
        }

        if (_pdfb->GetOrigLockFlags() & LOCK_ONLYONCE)
            olChkTo(EH_COW, WaitForAccess(_pdfb->GetOriginal(), DF_WRITE,
                                          &ulLock));

        if (P_INDEPENDENT(_df) | P_NOSNAPSHOT(_df))
        {
            if (_sigMSF == DF_INVALIDSIGNATURE)
            {
                if ((dwFlags & STGC_ONLYIFCURRENT) &&
                    DllIsMultiStream(_pdfb->GetOriginal()) == S_OK)
                    olErr(EH_GetAccess, STG_E_NOTCURRENT);
            }
            else
            {
                olChkTo(EH_GetAccess, DllGetCommitSig(_pdfb->GetOriginal(),
                                                      &sigMSF));
                if (dwFlags & STGC_ONLYIFCURRENT)
                    if (sigMSF != _sigMSF)
                        olErr(EH_GetAccess, STG_E_NOTCURRENT);
            }
        }
    }

    for (ptsm = _tss.GetHead(); ptsm; ptsm = ptsm->GetNext())
        if ((ptsm->GetFlags() & XSM_DELETED) == 0)
            olChkTo(EH_NoCommit, ptsm->BeginCommit(dwFlags));

    //  10/02/92 - To handle low disk space situations well, we
    //  preallocate the space we'll need to copy (when independent).

    if (P_INDEPENDENT(_df))
    {
        STATSTG statBase, statOrig;

        // With DELAYFLUSH we can't be sure of the size
        // of the file until EndCopyOnWrite, but we do
        // know that the file won't grow so this is safe

        olHChkTo(EH_NoCommit, _pdfb->GetBase()->Stat(&statBase,
                                                     STATFLAG_NONAME));
        olAssert(ULIGetHigh(statBase.cbSize) == 0);

        olHChkTo(EH_NoCommit, _pdfb->GetOriginal()->Stat(&statOrig,
                                                         STATFLAG_NONAME));
        olAssert(ULIGetHigh(statOrig.cbSize) == 0);

        if (ULIGetLow(statBase.cbSize) > ULIGetLow(statOrig.cbSize))
        {
            olHChkTo(EH_NoCommit,
                     _pdfb->GetOriginal()->SetSize(statBase.cbSize));
        }
        *pcbSizeBase = ULIGetLow(statBase.cbSize);
        *pcbSizeOrig = ULIGetLow(statOrig.cbSize);
    }
    *pulLock = ulLock;
    *psigMSF = sigMSF;

    return S_OK;

EH_NoCommit:
    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // Abort commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_ABORT);
EH_GetAccess:
    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);
EH_COW:
    if (GetTransactedDepth() == 1)
    {
        olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));
    }
EH_Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CPubDocFile::CommitPhase2, public
//
//  Synopsis:	Do phase 2 of commit
//
//  Arguments:	[dwFlags] -- Commit flags
//
//  Returns:	This can only fail if EndCopyOnWrite fails, which should
//               never happen (but can due to a hard disk error).  We
//               include cleanup code just in case.
//
//  History:	07-Aug-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPubDocFile::CommitPhase2(DWORD const dwFlags,
                                BOOL fCommit,
                                ULONG ulLock,
                                DFSIGNATURE sigMSF,
                                ULONG cbSizeBase,
                                ULONG cbSizeOrig)
{
    SCODE sc;
    PTSetMember *ptsm;

    //The commit was aborted for some reason external to this particular
    //  docfile.  We can handle this by calling directly to our cleanup
    //  code, which will abort and return success.
    if (!fCommit)
    {
        sc = S_OK;
        goto EH_Err;
    }

    if (GetTransactedDepth() == 1)
    {
        olChk(_pmsBase->EndCopyOnWrite(dwFlags, DF_COMMIT));
    }

    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // End commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_COMMIT);

    if (P_INDEPENDENT(_df))
    {
        // Not robust, but we made sure we had enough
        // disk space by presetting the larger size
        // There is no practical way of making this robust
        // and we have never guaranteed behavior in the face
        // of disk errors, so this is good enough

        olVerSucc(CopyLStreamToLStream(_pdfb->GetBase(),
                                       _pdfb->GetOriginal()));
        olVerSucc(_pdfb->GetOriginal()->Flush());
    }

    if (P_INDEPENDENT(_df) || P_NOSNAPSHOT(_df))
    {
        if (_sigMSF == DF_INVALIDSIGNATURE)
        {
            olVerSucc(DllGetCommitSig(_pdfb->GetOriginal(), &_sigMSF));
        }
        else
        {
            _sigMSF = sigMSF+1;
            olVerSucc(DllSetCommitSig(_pdfb->GetOriginal(), _sigMSF));
        }
    }
    
    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);

    //  Dirty all parents up to the next transacted storage
    if (IsDirty())
    {
        if (!IsRoot())
            _pdfParent->SetDirty();
        SetClean();
    }

#if DBG == 1
    VerifyXSMemberBases();
#endif
    _wFlags = (_wFlags & ~PF_PREPARED);

    return S_OK;

EH_Err:
    if (P_INDEPENDENT(_df) && (cbSizeBase > cbSizeOrig))
    {
        ULARGE_INTEGER uliSize;
        ULISet32(uliSize, cbSizeOrig);

        _pdfb->GetOriginal()->SetSize(uliSize);
    }

    // Move to end of list
    for (ptsm = _tss.GetHead();
         ptsm && ptsm->GetNext();
         ptsm = ptsm->GetNext())
        NULL;
    // Abort commits in reverse
    for (; ptsm; ptsm = ptsm->GetPrev())
        ptsm->EndCommit(DF_ABORT);

    if (ulLock != 0)
        ReleaseAccess(_pdfb->GetOriginal(), DF_WRITE, ulLock);

    if (GetTransactedDepth() == 1)
    {
        olVerSucc(_pmsBase->EndCopyOnWrite(dwFlags, DF_ABORT));
    }

    return sc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\tlsets.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       tlsets.cxx
//
//  Contents:   Transaction level set manager implementation
//
//  History:    20-Jan-1992     PhilipL Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CTSSet::~CTSSet, public
//
//  Synopsis:   destructor
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_1CTSSet)    // inline?
#endif

CTSSet::~CTSSet()
{
    // Last element should be TS, but we can't check this
    // so allow one last element to exist, assuming it will
    // be the TS
    olAssert(_ptsmHead == NULL ||
             _ptsmHead->GetNext() == NULL);
}

//+--------------------------------------------------------------
//
//  Member:     CTSSet::FindName, public
//
//  Synopsis:   Return the element in the TS with the given name
//
//  Arguments:  [pdfn] - name
//              [ulLevel] - level
//
//  Returns:    Matching element or NULL
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//              28-Oct-1992     AlexT   Convert to name
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_FindName)
#endif

PTSetMember *CTSSet::FindName(CDfName const *pdfn, DFLUID dlTree)
{
    PTSetMember *ptsm;

    olDebugOut((DEB_ITRACE, "In  CTSSet::FindName(%p)\n", pdfn));
    olAssert(pdfn != NULL && aMsg("Can't search for Null name"));

    for (ptsm = BP_TO_P(PTSetMember *, _ptsmHead);
         ptsm; ptsm = ptsm->GetNext())
    {
        if (ptsm->GetDfName()->IsEqual(pdfn) && ptsm->GetTree() == dlTree)
            break;
    }
    olDebugOut((DEB_ITRACE, "Out CTSSet::FindName => %p\n", ptsm));
    return ptsm;
}

//+--------------------------------------------------------------
//
//  Member:     CTSSet::AddMember, public
//
//  Synopsis:   Add the member to the correct position in the list
//
//  Arguments:  [ptsmAdd] - Element to add
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//
//  Notes:      This function inserts the provided element into the
//              list in its correct sorted position.
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_AddMember)
#endif

void CTSSet::AddMember(PTSetMember *ptsmAdd)
{
    PTSetMember *ptsm, *ptsmPrev;

    olDebugOut((DEB_ITRACE, "In  CTSSet::AddMember(%p)\n", ptsmAdd));
    for (ptsm = BP_TO_P(PTSetMember *, _ptsmHead), ptsmPrev = NULL;
         ptsm;
         ptsmPrev = ptsm, ptsm = ptsm->GetNext())
        if (ptsm->GetLevel() >= ptsmAdd->GetLevel())
            break;
    if (ptsm == NULL)
        if (ptsmPrev == NULL)
            // Empty list
            _ptsmHead = P_TO_BP(CBasedTSetMemberPtr, ptsmAdd);
        else
        {
            // Nothing with a higher level, add to end of list
            ptsmPrev->SetNext(ptsmAdd);
            ptsmAdd->SetPrev(ptsmPrev);
        }
    else
    {
        // Add before element with higher level
        ptsmAdd->SetNext(ptsm);
        ptsmAdd->SetPrev(ptsm->GetPrev());
        if (ptsm->GetPrev())
            ptsm->GetPrev()->SetNext(ptsmAdd);
        else
            _ptsmHead = P_TO_BP(CBasedTSetMemberPtr, ptsmAdd);
        ptsm->SetPrev(ptsmAdd);
    }
    olDebugOut((DEB_ITRACE, "Out CTSSet::AddMember\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CTSSet::RemoveMember, public
//
//  Synopsis:   Removes the member from the list
//
//  Arguments:  [ptsmRemove] - Element to remove
//
//  History:    22-Jan-1992     Philipl Created
//              08-Apr-1992     DrewB   Rewritten
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CTSSet_RemoveMember)
#endif

void CTSSet::RemoveMember(PTSetMember *ptsmRemove)
{
    olDebugOut((DEB_ITRACE, "In  CTSSet::RemoveMember(%p)\n", ptsmRemove));
    PTSetMember *ptsmNext = ptsmRemove->GetNext();
    
    if (ptsmRemove->GetPrev())
        ptsmRemove->GetPrev()->SetNext(ptsmNext);
    else
        _ptsmHead = P_TO_BP(CBasedTSetMemberPtr, ptsmNext);
    if (ptsmRemove->GetNext())
        ptsmRemove->GetNext()->SetPrev(ptsmRemove->GetPrev());
    ptsmRemove->SetNext(NULL);
    ptsmRemove->SetPrev(NULL);
    olDebugOut((DEB_ITRACE, "Out CTSSet::RemoveMember\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\rpubdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       rpubdf.cxx
//
//  Contents:   CRootPubDocFile implementation
//
//  History:    26-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <header.hxx>
#include <rpubdf.hxx>
#include <lock.hxx>
#include <filelkb.hxx>

// Priority mode lock permissions
#define PRIORITY_PERMS DF_READ

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::CRootPubDocFile, public
//
//  Synopsis:   Ctor - Initializes empty object
//
//  History:    30-Mar-92       DrewB     Created
//              05-Sep-5        MikeHill  Init _timeModifyAtCommit.
//
//
//---------------------------------------------------------------


CRootPubDocFile::CRootPubDocFile(IMalloc * const pMalloc) :
    _pMalloc(pMalloc),
    CPubDocFile(NULL, NULL, 0, ROOT_LUID, NULL, NULL, 0, NULL)
{
    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::CRootPubDocFile()\n"));


    _ulPriLock = 0;
	
    // Default to an invalid value.
    _timeModifyAtCommit.dwLowDateTime = _timeModifyAtCommit.dwHighDateTime = (DWORD) -1L;
	
    _sig = CROOTPUBDOCFILE_SIG;

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::CRootPubDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::InitInd, private
//
//  Synopsis:   Initializes independent root
//
//  Arguments:  [plstBase] - Base
//              [snbExclude] - Limited instantiation exclusions
//              [dwStartFlags] - Startup flags
//              [df] - Transactioning flags
//
//  Returns:    Appropriate status code
//
//  History:    11-Jun-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::InitInd(ILockBytes *plstBase,
                               SNBW snbExclude,
                               DWORD const dwStartFlags,
                               DFLAGS const df)
{
    CFileStream *pfstCopy;
    ILockBytes *plkbCopy;
    ULONG ulLock = 0;
    CDocFile *pdfFrom, *pdfTo;
    SCODE sc;
    CMStream *pms;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::InitInd()\n"));

    if ((sc = DllGetCommitSig(plstBase, &_sigMSF)) == STG_E_INVALIDHEADER ||
        sc == STG_E_UNKNOWN)
    {
        _sigMSF = DF_INVALIDSIGNATURE;
    }
    else if (FAILED(sc))
    {
        olErr(EH_Err,sc);
    }

    olMem(pfstCopy = new (_pMalloc) CFileStream(_pMalloc));

    olChkTo(EH_pfstCopy, pfstCopy->InitGlobal(
                        RSF_CREATE | RSF_DELETEONRELEASE | RSF_SNAPSHOT |
                        (dwStartFlags & RSF_ENCRYPTED),
                        DF_READWRITE));
    olChkTo(EH_pfstCopy, pfstCopy->InitSnapShot());

    if (!P_PRIORITY(df) && (_pdfb->GetOrigLockFlags() & LOCK_ONLYONCE))
        olChkTo(EH_pfstCopyInit, WaitForAccess(plstBase, DF_READ, &ulLock));
    if (snbExclude)
    {
        plkbCopy = pfstCopy;
        olChkTo(EH_GetAccess, DllMultiStreamFromStream(_pMalloc,
                                                       &pms, &plstBase,
                                                       dwStartFlags,
                                                       df));
        olMemTo(EH_pmsFrom, pdfFrom = new (_pMalloc)
                CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));
        pdfFrom->AddRef();
        olChkTo(EH_pdfFrom, DllMultiStreamFromStream(_pMalloc,
                                                     &pms, &plkbCopy,
                                                     RSF_CREATE,
                                                     0));
        olMemTo(EH_pmsTo, pdfTo = new (_pMalloc)
                CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));
        pdfTo->AddRef();
        olChkTo(EH_pdfTo, pdfFrom->CopyTo(pdfTo, CDF_EXACT, snbExclude));
        olChkTo(EH_pdfTo, pms->Flush(0));

        pdfFrom->Release();
        pdfTo->Release();
    }
    else if ((dwStartFlags & RSF_TRUNCATE) == 0)
    {
        olChkTo(EH_GetAccess, CopyLStreamToLStream(plstBase, pfstCopy));
    }
    if (!P_PRIORITY(df) && ulLock != 0)
        ReleaseAccess(plstBase, DF_READ, ulLock);

    _pdfb->SetBase(pfstCopy);
    _pdfb->SetOriginal(plstBase);
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::InitInd\n"));
    return S_OK;

EH_pdfTo:
    pdfTo->Release();
    goto EH_pdfFrom;
EH_pmsTo:
    DllReleaseMultiStream(pms);
EH_pdfFrom:
    pdfFrom->Release();
    goto EH_GetAccess;
EH_pmsFrom:
    DllReleaseMultiStream(pms);
EH_GetAccess:
    if (!P_PRIORITY(df) && ulLock != 0)
        ReleaseAccess(plstBase, DF_READ, ulLock);
EH_pfstCopyInit:
EH_pfstCopy:
    olVerSucc(pfstCopy->Release());
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::InitNotInd, private
//
//  Synopsis:   Dependent root initialization
//
//  Arguments:  [plstBase] - Base
//              [snbExclude] - Limited instantiation exclusions
//              [dwStartFlags] - Startup flags
//
//  Returns:    Appropriate status code
//
//  History:    11-Jun-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::InitNotInd(ILockBytes *plstBase,
                            SNBW snbExclude,
                            DWORD const dwStartFlags,
                            DFLAGS const df)
{
    CDocFile *pdf;
    SCODE sc;
    CMStream *pms;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::InitNotInd()\n"));

    if (snbExclude)
    {
        olChk(DllMultiStreamFromStream(_pMalloc,
                                       &pms, &plstBase, dwStartFlags,
                                       df));
        olMemTo(EH_pms, pdf = new(_pMalloc)
              CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));
        pdf->AddRef();
        olChkTo(EH_pdf, PDocFile::ExcludeEntries(pdf, snbExclude));
        olChkTo(EH_pdf, pms->Flush(0));
        pdf->Release();
    }
    _pdfb->SetBase(plstBase);
    plstBase->AddRef();
    _pdfb->SetOriginal(plstBase);
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::InitNotInd\n"));
    return S_OK;

EH_pdf:
    //pdf->Release() will also release the multistream.
    pdf->Release();
    return sc;
EH_pms:
    DllReleaseMultiStream(pms);
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::InitRoot, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [plstBase] - Base LStream
//              [dwStartFlags] - How to start things
//              [df] - Transactioning flags
//              [snbExclude] - Parital instantiation list
//              [ppdfb] - Basis pointer return
//              [pulOpenLock] - Open lock index return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfb]
//              [pulOpenLock]
//
//  History:    09-Dec-91       DrewB           Created
//              09-Jun-92       PhilipLa        Added conversion support
//              05-Sep-95       MikeHill        Initialize _timeModifyAtCommit.
//                                              Removed duplicate call to pdfWrapped->CopyTimesFrom
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::InitRoot(ILockBytes *plstBase,
                                DWORD dwStartFlags,
                                DFLAGS const df,
                                SNBW snbExclude,
                                CDFBasis **ppdfb,
                                ULONG *pulOpenLock,
                                CGlobalContext *pgc)
{
    CWrappedDocFile *pdfWrapped;
    CDocFile *pdfBase;
    CFileStream *pfstScratch;
    CMStream *pmsScratch;
    SCODE sc, scConv = S_OK;
    STATSTG statstg;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::InitRoot("
                "%p, %lX, %lX, %p, %p)\n",
                plstBase, dwStartFlags, df, snbExclude, ppdfb));

    // Exclusion only works with a plain open
    olAssert(snbExclude == NULL ||
             (dwStartFlags & (RSF_CREATEFLAGS | RSF_CONVERT)) == 0);

    //  ILockBytes::Stat calls are very expensive;  we avoid one here
    //  if possible

    HRESULT hr;
    IFileLockBytes *pfl;
    if (SUCCEEDED(plstBase->QueryInterface(IID_IFileLockBytes,
                                              (void**) &pfl)))
    {
        //  This is our private ILockBytes implementation.

        hr = pfl->GetLocksSupported(&statstg.grfLocksSupported);
        if (pfl->IsEncryptedFile())
            dwStartFlags |= RSF_ENCRYPTED;
        pfl->Release();
    }
    else
        hr = plstBase->Stat(&statstg, STATFLAG_NONAME);

    olHChk(hr);

    *pulOpenLock = 0;
    if (statstg.grfLocksSupported & LOCK_ONLYONCE)
        olChk(GetOpen(plstBase, df, TRUE, pulOpenLock));
    if (P_PRIORITY(df) && (statstg.grfLocksSupported & LOCK_ONLYONCE))
        olChkTo(EH_GetOpen, GetAccess(plstBase, PRIORITY_PERMS, &_ulPriLock));

    olMemTo(EH_GetPriority, *ppdfb = new (_pMalloc) CDFBasis(_pMalloc, df,
                                          statstg.grfLocksSupported, pgc));
    _pdfb = P_TO_BP(CBasedDFBasisPtr, *ppdfb);


    if (P_INDEPENDENT(df))
        olChkTo(EH_GetPriority, InitInd(plstBase, snbExclude, dwStartFlags,
                                    df));
    else
        olChkTo(EH_GetPriority,
                InitNotInd(plstBase, snbExclude, dwStartFlags, df));

    olMemTo(EH_SubInit, pfstScratch = new (_pMalloc) CFileStream(_pMalloc));
    olChkTo(EH_pfstScratchInit, pfstScratch->InitGlobal(
                            RSF_CREATE | RSF_DELETEONRELEASE | RSF_SCRATCH |
                            (dwStartFlags & RSF_ENCRYPTED),
                            DF_READWRITE));
    _pdfb->SetDirty(pfstScratch);

    CMStream *pms;
    scConv = DllMultiStreamFromStream(_pMalloc,
                                      &pms, _pdfb->GetPBase(),
                                      dwStartFlags |
                                      ((!P_INDEPENDENT(df) &&
                                        P_TRANSACTED(df)) ? RSF_DELAY : 0),
                                      df);
    _pmsBase = P_TO_BP(CBasedMStreamPtr, pms);

    if (scConv == STG_E_INVALIDHEADER)
        scConv = STG_E_FILEALREADYEXISTS;
    olChkTo(EH_pfstScratchInit, scConv);

    if (P_NOSNAPSHOT(df))
    {
        if ((sc = DllGetCommitSig(plstBase, &_sigMSF)) == STG_E_INVALIDHEADER ||
            sc == STG_E_UNKNOWN)
        {
            _sigMSF = DF_INVALIDSIGNATURE;
        }
        else if (FAILED(sc))
        {
            olErr(EH_pmsBase,sc);
        }
    }
    

    olMemTo(EH_pmsBase, pdfBase = new (_pMalloc)
            CDocFile(pms, SIDROOT, ROOT_LUID, BP_TO_P(CDFBasis *, _pdfb)));

    pdfBase->AddRef();

    if (P_TRANSACTED(df))
    {
        _cTransactedDepth = 1;
        CDfName dfnNull;        //  auto-initialized to 0
        WCHAR wcZero = 0;
        dfnNull.Set(2, (BYTE*)&wcZero);

        //  3/11/93 - Demand scratch when opening/creating transacted
        olChkTo(EH_pdfBaseInit, _pdfb->GetDirty()->InitScratch());

        olMemTo(EH_pdfBaseInit, pdfWrapped = new(_pMalloc)
                        CWrappedDocFile(&dfnNull, pdfBase->GetLuid(), df,
                                BP_TO_P(CDFBasis *, _pdfb), this));
        olChkTo(EH_pdfWrapped,
                pdfWrapped->Init(pdfBase));
        AddXSMember(NULL, pdfWrapped, pdfWrapped->GetLuid());
        _pdf = P_TO_BP(CBasedDocFilePtr, (PDocFile *)pdfWrapped);

    }
    else
        _pdf = P_TO_BP(CBasedDocFilePtr, (PDocFile *)pdfBase);


     // For no-scratch transacted files, also save the Docfile's current modify
     // time.  This will be used on the Release (in vdtor).

     if( P_NOSCRATCH( df ))
     {
        if( FAILED( _pmsBase->GetTime( SIDROOT, WT_MODIFICATION, &_timeModifyAtCommit )))
        {
           // Do not return an error, but record an error flag so that
           // vdtor will not try to use it.

           _timeModifyAtCommit.dwLowDateTime = _timeModifyAtCommit.dwHighDateTime = (DWORD) -1;
        }
     }


    olChkTo(EH_pfstScratchInit,
            DllGetScratchMultiStream(&pmsScratch,
                                     (df & DF_NOSCRATCH),
                                     (ILockBytes **)_pdfb->GetPDirty(),
                                     pms));

    _pdfb->SetScratch(pmsScratch);


    if (df & DF_NOSCRATCH)
    {
        _pdfb->SetBaseMultiStream(pms);
        olChkTo(EH_pfstScratchInit, pmsScratch->InitScratch(pms, TRUE));
        _pmsBase->SetScratchMS(pmsScratch);
    }
    else
    {
        _pdfb->SetBaseMultiStream(NULL);
    }


    _df = df;


   // _pdfb->mxs is constructed automatically
	

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::InitRoot\n"));
    return scConv;


EH_pdfWrapped:
    delete pdfWrapped;
EH_pdfBaseInit:
    pdfBase->Release();
    goto EH_pfstScratchInit;

EH_pmsBase:
    DllReleaseMultiStream(BP_TO_P(CMStream *, _pmsBase));

EH_pfstScratchInit:
    olVerSucc(pfstScratch->Release());
    _pdfb->SetDirty(NULL);
EH_SubInit:
    olVerSucc(_pdfb->GetBase()->Release());
    _pdfb->SetBase(NULL);
EH_GetPriority:
    if (_ulPriLock > 0)
    {
        olAssert(P_PRIORITY(df) &&
                 (statstg.grfLocksSupported & LOCK_ONLYONCE));
        ReleaseAccess(plstBase, PRIORITY_PERMS, _ulPriLock);
        _ulPriLock = 0;
    }
EH_GetOpen:
    if (*pulOpenLock != 0)
    {
        olAssert(statstg.grfLocksSupported & LOCK_ONLYONCE);
        ReleaseOpen(plstBase, df, *pulOpenLock);
        *pulOpenLock = 0;
    }
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::~CRootPubDocFile, public
//
//  Synopsis:   dtor
//
//  History:    09-Dec-91       DrewB     Created
//              05-Sep-95       MikeHill  Revert time using _timeModifyAtCommit.
//
//---------------------------------------------------------------


void CRootPubDocFile::vdtor(void)
{
    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::~CRootPubDocFile\n"));

    olAssert(_cReferences == 0);



   // If this is a no-scratch transacted file, revert the Modify timestamp
   // on the Docfile to that of the last commit.
	
   if( P_NOSCRATCH( _df )
       &&
       ( _timeModifyAtCommit.dwLowDateTime != -1L )  // Don't use an invalid timestamp.
     )
   {
      // We call SetFileLockBytesTime, rather than SetTime, so that
      // the underlying Docfile's timestamp is changed, but the Storage's
      // timestamp in the Directory is unchanged.  If we changed the
      // Directory, we would have to flush the Multi-Stream.

      // An error here is ignored.

      _pmsBase->SetFileLockBytesTime( WT_MODIFICATION, _timeModifyAtCommit );
   }


    // We can't rely on CPubDocFile::~CPubDocFile to do this since
    // we're using a virtual destructor
    _sig = CROOTPUBDOCFILE_SIGDEL;

    if (SUCCEEDED(CheckReverted()))
    {
        ChangeXs(DF_NOLUID, XSO_RELEASE);
        _cilChildren.DeleteByName(NULL);
        if (_ulPriLock > 0)
        {
            // Priority instantiation can't be independent
            olAssert(!P_INDEPENDENT(_df));
            ReleaseAccess(_pdfb->GetBase(), PRIORITY_PERMS, _ulPriLock);
        }

        if (_pdf)
            _pdf->Release();
        if (_pdfb)
            _pdfb->vRelease();


    }
	
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::~CRootPubDocFile\n"));
    delete this;
}


//+---------------------------------------------------------------------------
//
//  Member:	CRootPubDocFile::ReleaseLocks, public
//
//  Synopsis:	Release any locks using the given ILockBytes
//
//  Arguments:	[plkb] -- ILockBytes to use for release
//
//  Returns:	void
//
//  History:	24-Jan-95	PhilipLa	Created
//
//  Notes:	This is a cleanup function used to resolve the many
//              conflicts we get trying to release locks using an
//              ILockBytes in a basis that's already been released.
//
//----------------------------------------------------------------------------

void CRootPubDocFile::ReleaseLocks(ILockBytes *plkb)
{
    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::ReleaseLocks:%p()\n", this));
    if (_ulPriLock > 0)
    {
        // Priority instantiation can't be independent
        olAssert(!P_INDEPENDENT(_df));
        ReleaseAccess(plkb, PRIORITY_PERMS, _ulPriLock);
        _ulPriLock = 0;
    }

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::ReleaseLocks\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::Stat, public
//
//  Synopsis:   Fills in a stat buffer from the base LStream
//
//  Arguments:  [pstatstg] - Stat buffer
//              [grfStatFlag] - Stat flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    25-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CRootPubDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::Stat(%p, %lu)\n",
                pstatstg, grfStatFlag));
    olChk(CheckReverted());
    olHChk(_pdfb->GetOriginal()->Stat((STATSTG *)pstatstg, grfStatFlag));
    pstatstg->grfMode = DFlagsToMode(_df);
    olChkTo(EH_pwcsName, _pdf->GetClass(&pstatstg->clsid));
    olChkTo(EH_pwcsName, _pdf->GetStateBits(&pstatstg->grfStateBits));
    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::Stat\n"));
    return S_OK;

EH_pwcsName:
    if (pstatstg->pwcsName)
        TaskMemFree(pstatstg->pwcsName);
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootPubDocFile::SwitchToFile, public
//
//  Synopsis:   Switches the underlying file in the base ILockBytes
//
//  Arguments:  [ptcsFile] - Filename
//              [plkb] - The ILockBytes to operate on
//              [pulOpenLock] - On entry, the current open lock
//                              On exit, the new open lock
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pulOpenLock]
//
//  History:    08-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CRootPubDocFile::SwitchToFile(OLECHAR const *ptcsFile,
                                    ILockBytes *plkb,
                                    ULONG *pulOpenLock)
{
    IFileLockBytes *pfl;
    SCODE sc;
    BYTE *pbBuffer;
    ULONG cbBuffer;

    olDebugOut((DEB_ITRACE, "In  CRootPubDocFile::SwitchToFile:%p("
                "%s, %p, %p)\n", this, ptcsFile, plkb, pulOpenLock));

    // If you're transacted, nothing can be dirty in the base
    // If you're not dirty, there's no point in flushing
    // This is also necessary to allow SwitchToFile with a read-only source
    if (!P_TRANSACTED(_df) && IsDirty())
    {
        // Make sure pending changes are flushed
        olChk(_pmsBase->Flush(0));

        // Make sure ILockBytes contents are on disk
        olHChk(plkb->Flush());
    }

#ifdef LARGE_DOCFILE
    ULONGLONG ulCommitSize;
#else
    ULONG ulCommitSize;
#endif
    olChk(GetCommitSize(&ulCommitSize));

    // Check for FileLockBytes
    olHChkTo(EH_NotFile, plkb->QueryInterface(IID_IFileLockBytes,
                                              (void **)&pfl));

    // Release old locks
    if (*pulOpenLock)
        ReleaseOpen(plkb, _df, *pulOpenLock);

    // Ask ILockBytes to switch
    GetSafeBuffer(CB_SMALLBUFFER, CB_LARGEBUFFER, &pbBuffer, &cbBuffer);
    olAssert(pbBuffer != NULL);
    sc = DfGetScode(pfl->SwitchToFile(
            ptcsFile,
            ulCommitSize,
            cbBuffer,
            pbBuffer));

    pfl->Release();
    FreeBuffer(pbBuffer);

    //Record the fact that we have enough space for overwrite commit.
    _wFlags = _wFlags | PF_PREPARED;


    // Attempt to get new locks
    // If SwitchToFile failed, the ILockBytes is the same so this will
    //   restore our open locks released above
    // If SwitchToFile succeeded, the ILockBytes is working on the new file
    //   so this will get locks for that
    if (*pulOpenLock)
    {
        ULONG ulLock;

        // Don't propagate failures here since there's nothing
        // that can be done
        if (SUCCEEDED(GetOpen(plkb, _df, FALSE, &ulLock)))
            *pulOpenLock = ulLock;
    }

    olDebugOut((DEB_ITRACE, "Out CRootPubDocFile::SwitchToFile\n"));
EH_Err:
    return sc;

EH_NotFile:
    return(STG_E_NOTFILEBASEDSTORAGE);
}



//+--------------------------------------------------------------
//
//  Member:     CRootPubDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    29-Aug-95       MikeHill   Created
//              26-Apr-99       RogerCh    Changed to use GetSystemTimeAsFileTime
//
//---------------------------------------------------------------


void CRootPubDocFile::CommitTimestamps(DWORD const dwFlags)
{
    // For no-scratch transacted files, also save the Docfile's modify
    // time.  This will be used to restore the file's current time on a Release.

    if( P_NOSCRATCH( _df ) && P_TRANSACTED( _df ))
    {
        GetSystemTimeAsFileTime(&_timeModifyAtCommit);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\mem.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Mem.CXX
//
//  Contents:   Memory tracking code
//
//  Classes:    CMemAlloc
//
//  Functions:  DfCreateSharedAllocator
//              DfPrintAllocs
//              DfGetMemAlloced
//
//  History:    17-May-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#if defined(WIN32)

#include <smalloc.hxx>
#include <olesem.hxx>
#include <utils.hxx>

// This global variable holds the base address of the shared memory region.
// It is required by the based pointer stuff and is accessed directly.
// Initialization is a side effect of calling DfCreateSharedAllocator or
//  DfSyncSharedMemory

#ifdef MULTIHEAP
//__declspec(thread) void *DFBASEPTR = NULL;
#else
void *DFBASEPTR = NULL;
#endif

#endif

#if DBG == 1
#include <dfdeb.hxx>

#ifdef MEMTRACK
#ifdef WIN32
// Multithread protection for allocation list
CStaticDfMutex _sdmtxAllocs(TSTR("DfAllocList"));

#define TAKE_ALLOCS_MUTEX olVerSucc(_sdmtxAllocs.Take(INFINITE))
#define RELEASE_ALLOCS_MUTEX _sdmtxAllocs.Release()
#else
#define TAKE_ALLOCS_MUTEX
#define RELEASE_ALLOCS_MUTEX
#endif

#define GET_ALLOC_LIST_HEAD ((CMemAlloc *)DfGetResLimit(DBRI_ALLOC_LIST))
#define SET_ALLOC_LIST_HEAD(pma) DfSetResLimit(DBRI_ALLOC_LIST, (LONG)(pma))
#endif // MEMTRACK

#define DEB_MEMORY 0x01000000
#define DEB_LEAKS  0x01100000

const int NEWMEM = 0xDEDE;
const int OLDMEM = 0xEDED;

//+--------------------------------------------------------------
//
//  Class:      CMemAlloc (ma)
//
//  Purpose:    Tracks memory allocations
//
//  Interface:  See below
//
//  History:    08-Jul-92       DrewB   Created
//              17-May-93       AlexT   Add idContext
//
//---------------------------------------------------------------

class CMemAlloc
{
public:
    void *pvCaller;
    void *pvMem;
    ULONG cbSize;
    ContextId idContext;
#ifdef MEMTRACK
    CMemAlloc *pmaPrev, *pmaNext;
#endif
};

//+---------------------------------------------------------------------------
//
//  Function:	AddAlloc, private
//
//  Synopsis:	Puts an allocation into the allocation list
//
//  Arguments:	[pma] - Allocation descriptor
//              [pvCaller] - Allocator
//              [cbSize] - Real size
//              [pvMem] - Memory block
//              [cid] - Context ID
//
//  History:	11-Jan-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static void AddAlloc(CMemAlloc *pma, void *pvCaller, ULONG cbSize,
                     void *pvMem, ContextId cid)
{
    pma->pvCaller = pvCaller;
    pma->cbSize = cbSize;
    pma->pvMem = pvMem;
    pma->idContext = cid;

#ifdef MEMTRACK
    TAKE_ALLOCS_MUTEX;

    pma->pmaNext = GET_ALLOC_LIST_HEAD;
    if (pma->pmaNext)
        pma->pmaNext->pmaPrev = pma;
    pma->pmaPrev = NULL;
    olAssert(!IsBadReadPtr(pma, sizeof(CMemAlloc)));
    SET_ALLOC_LIST_HEAD(pma);

    RELEASE_ALLOCS_MUTEX;

    ModifyResLimit(DBRQ_MEMORY_ALLOCATED, (LONG)cbSize);

    olDebugOut((DEB_MEMORY, "%s alloced %p:%lu, total %ld\n",
                cid != 0 ? "Task" : "Shrd",
                pvMem, pma->cbSize, DfGetResLimit(DBRQ_MEMORY_ALLOCATED)));

#endif
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:	RemoveAlloc, private
//
//  Synopsis:	Takes an allocation out of the allocation list
//
//  Arguments:	[pma] - Allocation descriptor
//              [pvMem] - Real allocation
//              [cid] - Context ID
//
//  History:	11-Jan-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static void RemoveAlloc(CMemAlloc *pma, void *pvMem, ContextId cid)
{
#ifdef MEMTRACK
    olAssert(pma->pvMem == pvMem && aMsg("Address mismatch"));
    olAssert(pma->idContext == cid && aMsg("Context mismatch"));

    TAKE_ALLOCS_MUTEX;

    olAssert(pma->pmaNext == NULL ||
             !IsBadReadPtr(pma->pmaNext, sizeof(CMemAlloc)));
    olAssert(pma->pmaPrev == NULL ||
             !IsBadReadPtr(pma->pmaPrev, sizeof(CMemAlloc)));
    if (pma->pmaPrev)
    {
        pma->pmaPrev->pmaNext = pma->pmaNext;
    }
    else
    {
        SET_ALLOC_LIST_HEAD(pma->pmaNext);
    }
    if (pma->pmaNext)
    {
        pma->pmaNext->pmaPrev = pma->pmaPrev;
    }

    RELEASE_ALLOCS_MUTEX;

    ModifyResLimit(DBR_MEMORY, (LONG)pma->cbSize);

    ModifyResLimit(DBRQ_MEMORY_ALLOCATED, -(LONG)pma->cbSize);
    olAssert(DfGetResLimit(DBRQ_MEMORY_ALLOCATED) >= 0);

    olDebugOut((DEB_MEMORY, "%s freed %p:%lu, total %ld\n",
                cid != 0 ? "Task" : "Shrd",
                pma->pvMem, pma->cbSize,
                DfGetResLimit(DBRQ_MEMORY_ALLOCATED)));
#endif
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DfGetMemAlloced, private
//
//  Synopsis:   Returns the amount of memory currently allocated
//
//  History:    08-Jul-92       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(LONG) DfGetMemAlloced(void)
{
    return DfGetResLimit(DBRQ_MEMORY_ALLOCATED);
}

//+--------------------------------------------------------------
//
//  Function:   DfPrintAllocs, private
//
//  Synopsis:   Walks the allocation list and prints out their info
//
//  History:    08-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI_(void) DfPrintAllocs(void)
{
#ifdef MEMTRACK
    CMemAlloc *pma;

    olDebugOut((DEB_ITRACE, "In  DfPrintAllocs()\n"));

    TAKE_ALLOCS_MUTEX;

    pma = GET_ALLOC_LIST_HEAD;
    while (pma != NULL)
    {
        olDebugOut((DEB_LEAKS, "Alloc %s: %p alloc %p:%4lu bytes\n",
                    pma->idContext ? "LOCAL" : "SHARED",
                    pma->pvCaller, pma->pvMem, pma->cbSize));
        pma = pma->pmaNext;
    }

    RELEASE_ALLOCS_MUTEX;

    olDebugOut((DEB_ITRACE, "Out DfPrintAllocs\n"));
#endif
}

#endif

#ifdef MULTIHEAP

CSmAllocator g_SmAllocator;      // optimization for single threaded case
CErrorSmAllocator g_ErrorSmAllocator;
IMalloc *g_pTaskAllocator = 0;
CSharedMemoryBlock g_smb;        // optimize single threaded case
ULONG        g_ulHeapName = 0;   // name of the above heap
TEB *        g_pteb = NtCurrentTeb();

CSmAllocator& GetTlsSmAllocator()
{
    HRESULT hr;
    COleTls otls(hr); // even for main thread, we need to initialize TLS
    memAssert (SUCCEEDED(hr) && "Error initializing TLS");

    if (g_pteb == NtCurrentTeb())
    {
        // return the static global allocator for main thread
        // DoThreadSpecificCleanup does not deallocate this allocator
        return g_SmAllocator;
    }

    if (otls->pSmAllocator == NULL)
    {
        if ((otls->pSmAllocator = new CSmAllocator()) == NULL)
             otls->pSmAllocator = &g_ErrorSmAllocator;
        // DoThreadSpecificCleanup will deallocate this when thread goes away
    }
    return *(otls->pSmAllocator);
}

//
// This initialization used to be done in the global allocator
// which is now a per thread allocator
//
class CResourceCriticalSection
{
public:
    CResourceCriticalSection ()
    {
#if WIN32 == 100
        _nts = RtlInitializeCriticalSection(&g_csScratchBuffer);
#else
        InitializeCriticalSection(&g_csScratchBuffer);
#endif
    }

    ~CResourceCriticalSection ()
    {
#if WIN32 == 100
        if (NT_SUCCESS(_nts))
#endif
            DeleteCriticalSection(&g_csScratchBuffer);
    }

#if WIN32 == 100
    HRESULT GetInitializationError ()
    {
        return NtStatusToScode(_nts);
    }

private:
    NTSTATUS    _nts;
#endif
};
CResourceCriticalSection g_ResourceCriticalSection;

#else
CSmAllocator g_smAllocator;
#endif // MULTIHEAP

//+-------------------------------------------------------------------------
//
//  Member:     CMallocBased::operator new, public
//
//  Synopsis:   Overridden allocator
//
//  Effects:    Allocates memory from given allocator
//
//  Arguments:  [size] -- byte count to allocate
//              [pMalloc] --  allocator
//
//  Returns:    memory block address
//
//  Algorithm:
//
//  History:    21-May-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void *CMallocBased::operator new(size_t size, IMalloc * const pMalloc)

{
#ifndef WIN32
    olAssert(DfGetResLimit(DBRQ_MEMORY_ALLOCATED) >= 0);
#endif
    olAssert(size > 0);

#if DBG==1
    if (SimulateFailure(DBF_MEMORY))
    {
        return(NULL);
    }

    if (!HaveResource(DBR_MEMORY, (LONG)size))
    {
        // Artificial limit exceeded so force failure
        return NULL;
    }
#endif

    void *pv = g_smAllocator.Alloc(
#if DBG==1
                              sizeof(CMemAlloc) +
#endif
                              size);

    if (pv == NULL)
    {
#if DBG==1
        ModifyResLimit(DBR_MEMORY, (LONG)size);
#endif
        return NULL;
    }

#if DBG==1
    memset(pv, NEWMEM, sizeof(CMemAlloc) + size);
#endif



#if DBG==1
    // Put debug info in buffer
    // Note: This assumes CMemAlloc will end up properly aligned
    CMemAlloc *pma = (CMemAlloc *) pv;
    pv = (void *) ((CMemAlloc *) pv + 1);

#if defined(_X86_)
    PVOID ra = *(((void **)&size)-1);
#else
    PVOID ra = _ReturnAddress();
#endif

    AddAlloc(pma, ra, size, pv, 0);
#endif

    return pv;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMallocBased::operator delete
//
//  Synopsis:   Overridden deallocator
//
//  Effects:    Frees memory block
//
//  Arguments:  [pv] -- memory block address
//
//  Algorithm:
//
//  History:    21-May-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CMallocBased::operator delete(void *pv)

{
    if (pv == NULL)
        return;

#if DBG==1
    // Assumes ma ends up properly aligned
    CMemAlloc *pma = (CMemAlloc *) pv;
    pma--;

    RemoveAlloc(pma, pv, 0);

    pv = (void *) pma;

    memset(pv, OLDMEM, (size_t) pma->cbSize);
#endif

    g_smAllocator.Free(pv);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMallocBased::deleteNoMutex
//
//  Synopsis:   deallocator function without Mutex
//
//  Effects:    Frees memory block
//
//  Arguments:  [pv] -- memory block address
//  Algorithm:
//
//  History:    19-Jul-95 	SusiA    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void CMallocBased::deleteNoMutex(void *pv)

{
    if (pv == NULL)
        return;

#if DBG==1
    // Assumes ma ends up properly aligned
    CMemAlloc *pma = (CMemAlloc *) pv;
    pma--;

    RemoveAlloc(pma, pv, 0);

    pv = (void *) pma;

    memset(pv, OLDMEM, (size_t) pma->cbSize);
#endif

    g_smAllocator.FreeNoMutex(pv);
}



#if !defined(WIN32) && DBG==1

//+-------------------------------------------------------------------------
//
//  Class:      CSharedMalloc
//
//  Purpose:    Track shared allocators
//
//  Interface:  IMalloc
//
//  History:    28-May-93 AlexT     Created
//
//  Notes:      This is only for builds that use CoCreateStandardMalloc
//              (which is non-WIN32 builds for now).  We inherit from
//              CMallocBased to pick up memory tracking.
//
//--------------------------------------------------------------------------

class CSharedMalloc : public IMalloc, public CMallocBased
{
public:
    CSharedMalloc(IMalloc *pMalloc);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ SIZE_T cb);
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, SIZE_T cb);
    STDMETHOD_(void, Free) (THIS_ void FAR* pv);
    STDMETHOD_(SIZE_T, GetSize) (THIS_ void FAR* pv);
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv);
    STDMETHOD_(void, HeapMinimize) (THIS);

private:
    IMalloc * const _pMalloc;
};

CSharedMalloc::CSharedMalloc(IMalloc *pMalloc)
: _pMalloc(pMalloc)
{
    _pMalloc->AddRef();
}

STDMETHODIMP CSharedMalloc::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
    olAssert(!aMsg("CSharedMalloc::QueryInterface unsupported"));
    return(ResultFromScode(E_UNEXPECTED));
}

STDMETHODIMP_(ULONG) CSharedMalloc::AddRef (THIS)
{
    return(_pMalloc->AddRef());
}

STDMETHODIMP_(ULONG) CSharedMalloc::Release (THIS)
{
    ULONG cRef = _pMalloc->Release();

    if (cRef == 0)
        delete this;

    return (ULONG) cRef;
}

STDMETHODIMP_(void FAR*) CSharedMalloc::Alloc (THIS_ SIZE_T cb)
{
    return _pMalloc->Alloc(cb);
}

STDMETHODIMP_(void FAR*) CSharedMalloc::Realloc (THIS_ void FAR* pv, SIZE_T cb)
{
    olAssert(!aMsg("CSharedMalloc::Realloc unsupported"));
    return(NULL);
}

STDMETHODIMP_(void) CSharedMalloc::Free (THIS_ void FAR* pv)
{
    _pMalloc->Free(pv);
}

STDMETHODIMP_(SIZE_T) CSharedMalloc::GetSize (THIS_ void FAR* pv)
{
    olAssert(!aMsg("CSharedMalloc::GetSize unsupported"));
    return(0);
}

STDMETHODIMP_(int) CSharedMalloc::DidAlloc (THIS_ void FAR* pv)
{
    olAssert(!aMsg("CSharedMalloc::DidAlloc unsupported"));
    return(TRUE);
}

STDMETHODIMP_(void) CSharedMalloc::HeapMinimize (THIS)
{
    olAssert(!aMsg("CSharedMalloc::HeapMinimize unsupported"));
}

#endif


#if !defined(MULTIHEAP)
COleStaticMutexSem mxsInitSm;
BOOL fInitialisedSm = FALSE;

//+-------------------------------------------------------------------------
//
//  Function:   DfCreateSharedAllocator
//
//  Synopsis:   Initialises the shared memory region for this process.
//
//  Arguments:  [ppm]		-- return address for shared memory IMalloc*
//
//  Returns:    status code
//
//  History:    27-May-94	MikeSe	Created
//
//  Notes:      This routine is called indirectly through DfCreateSharedAllocator, in
//		such a way that in most circumstances it will be executed
//		exactly once per process. (Because we overwrite the contents
//		of DfCreateSharedAllocator if successful).
//
//		However, in order to be multi-thread safe, we need a process
//		mutex to prevent execution of the initialisation code twice.
//
//		Furthermore, since we are initialising system-wide state
//		(namely the shared memory region) we must provide cross-process
//		mutual exclusion over this activity.
//
//--------------------------------------------------------------------------

HRESULT DfCreateSharedAllocator (IMalloc ** ppm, BOOL fTaskMemory )
{
    // multi-thread safety

    mxsInitSm.Request();

    HRESULT hr = S_OK;

    if ( !fInitialisedSm )
    {
	// We need to do the initialisation. Obtain exclusion against
	//  other processes.

	SECURITY_ATTRIBUTES secattr;
	secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
#ifndef _CHICAGO_
	CWorldSecurityDescriptor wsd;
	secattr.lpSecurityDescriptor = &wsd;
#else
	secattr.lpSecurityDescriptor = NULL;
#endif // !_CHICAGO_
	secattr.bInheritHandle = FALSE;

        HANDLE hMutex = CreateMutex ( &secattr, FALSE, TEXT("OleDfSharedMemoryMutex"));

        if ( hMutex == NULL && GetLastError() == ERROR_ACCESS_DENIED )
            hMutex = OpenMutex(SYNCHRONIZE, FALSE, TEXT("OleDfSharedMemoryMutex"));

	if ( hMutex != NULL )
	{
	    WaitForSingleObject ( hMutex, INFINITE );
            hr = g_smAllocator.Init ( DOCFILE_SM_NAME );
	    if ( SUCCEEDED(hr) )
	    {
	        *ppm = &g_smAllocator;
		// Also set up base address
#ifdef USEBASED
	        DFBASEPTR = g_smAllocator.GetBase();
#endif
	        fInitialisedSm = TRUE;
	    }
	    ReleaseMutex ( hMutex );
	}
        else
	    hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else   // fInitialisedSm is TRUE
    {
        *ppm = &g_smAllocator;
    }
    mxsInitSm.Release();
    return hr;
}

#endif // !defined(MULTIHEAP)

#ifdef MULTIHEAP
//+-------------------------------------------------------------------------
//
//  Function:   DfCreateSharedAllocator
//
//  Synopsis:   Initialises a shared memory region for this process.
//
//  Arguments:  [ppm]       -- return address for shared memory IMalloc*
//
//  Returns:    status code
//
//  History:    20-Nov-95   HenryLee Created
//
//  Notes:      This routine is called indirectly by DfCreateSharedAllocator
//      such a way that in most circumstances it will be executed
//      exactly once per docfile open.
//
//--------------------------------------------------------------------------

HRESULT DfCreateSharedAllocator (IMalloc ** ppm, BOOL fTaskMemory )
{
    HRESULT hr = S_OK;


#if WIN32 == 100
    hr = g_ResourceCriticalSection.GetInitializationError();
    if (!SUCCEEDED(hr))
        return hr;
#endif

    CSmAllocator *pMalloc = &g_smAllocator;
    *ppm = NULL;

    if ((gs_iSharedHeaps > (DOCFILE_SM_LIMIT / DOCFILE_SM_SIZE)) ||
        fTaskMemory)
    {
        // use task allocator if we eat up 1Gig of address space
        if (g_pTaskAllocator == NULL)
        {
            hr = CoGetMalloc (MEMCTX_TASK, &g_pTaskAllocator);
            if (!SUCCEEDED(hr))
                return hr;
        }

        // reset the allocator state to initialize it properly
        pMalloc->SetState (NULL, NULL, NULL, NULL, 0);

        DFBASEPTR = 0;
        *ppm = g_pTaskAllocator;
    }
    else
    {
        LUID luid;    // generate a unique name
        if (AllocateLocallyUniqueId (&luid) == FALSE)
            return HRESULT_FROM_WIN32(GetLastError());

        // reset the allocator state to initialize it properly
        pMalloc->SetState (NULL, NULL, NULL, NULL, 0);

        hr = pMalloc->Init ( luid.LowPart, FALSE );
        if ( SUCCEEDED(hr) )
        {
            *ppm = pMalloc;
            DFBASEPTR = pMalloc->GetBase();
            pMalloc->AddRef();
        }
    }

    return hr;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:	DfSyncSharedMemory, public
//
//  Synopsis:	Sync up shared memory
//
//  Returns:	Appropriate status code
//
//  History:	08-Apr-94	PhilipLa	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef MULTIHEAP
SCODE DfSyncSharedMemory(ULONG ulHeapName)
#else
SCODE DfSyncSharedMemory(void)
#endif
{
    // make sure we have initialised
    HRESULT hr = S_OK;

#ifdef MULTIHEAP
    CSmAllocator *pMalloc = &g_smAllocator;
    if (ulHeapName != 0)     // reopen a shared heap for unmarshaling
    {
        // reset the allocator state to initialize it properly
        pMalloc->SetState (NULL, NULL, NULL, NULL, 0);

        hr = pMalloc->Init ( ulHeapName, TRUE);
        DFBASEPTR = pMalloc->GetBase();

    }
    else                     // try to create a new shared heap
#else
    if (!fInitialisedSm)
#endif // MULTIHEAP
    {
        IMalloc * pm;
        hr = DfCreateSharedAllocator ( &pm, FALSE );
    }
    if ( SUCCEEDED(hr) )
#ifdef MULTIHEAP
    hr = pMalloc->Sync();
#else
	hr = g_smAllocator.Sync();
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:	DfInitSharedMemBase, public
//
//  Synopsis:	Set up the base of shared memory
//
//  History:	31-May-94	MikeSe	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DfInitSharedMemBase()
{
#if !defined MULTIHEAP
    // make sure we have initialised. This is sufficient to ensure
    //  that DFBASEPTR is set up
    if (!fInitialisedSm)
    {
        IMalloc * pm;
        HRESULT hr = DfCreateSharedAllocator ( &pm );
    }
#endif
}


#if DBG==1 && !defined(MULTIHEAP)

//+-------------------------------------------------------------------------
//
//  Method:     CLocalAlloc::operator new, public
//
//  Synopsis:   Overloaded new operator to allocate objects from
//		task local space.
//
//  Arguments:  [size] -- Size of block to allocate
//
//  Returns:    Pointer to memory allocated.
//
//  History:    17-Aug-92 	PhilipLa    Created.
//              18-May-93       AlexT       Switch to task IMalloc
//
//--------------------------------------------------------------------------

void *CLocalAlloc::operator new(size_t size)
{
#ifndef WIN32
    olAssert(DfGetResLimit(DBRQ_MEMORY_ALLOCATED) >= 0);
#endif
    olAssert(size > 0);

    if (SimulateFailure(DBF_MEMORY))
    {
        return(NULL);
    }

    if (!HaveResource(DBR_MEMORY, (LONG)size))
    {
        // Artificial limit exceeded so force failure
        return NULL;
    }

    void *pv = TaskMemAlloc(sizeof(CMemAlloc *) + size);

    if (pv != NULL)
    {
        void * const pvOrig = pv;

        memset(pv, NEWMEM, sizeof(CMemAlloc *) + size);

        CMemAlloc *pma = NULL;

        //  Allocate tracking block (with shared memory)
        IMalloc *pMalloc;

#ifdef WIN32
#ifdef MULTIHEAP
        pMalloc = &g_smAllocator;
#else
	if ( FAILED(DfCreateSharedAllocator ( &pMalloc )) )
	    pMalloc = NULL;
#endif // MULTIHEAP
#else
        if (FAILED(DfGetScode(CoGetMalloc(MEMCTX_SHARED, &pMalloc))))
            pMalloc = NULL;
#endif

        if (pMalloc)
        {
            pma = (CMemAlloc *) pMalloc->Alloc(sizeof(CMemAlloc));
            if (pma != NULL)
            {
                memset(pma, NEWMEM, sizeof(CMemAlloc));
                CMemAlloc **ppma = (CMemAlloc **) pv;
                pv = (void *) ((CMemAlloc **)pv + 1);
                *ppma = pma;

                AddAlloc(pma, *(((void **)&size)-1), size, pv,
                         GetCurrentContextId());
            }

            pMalloc->Release();
        }

        if (pma == NULL)
        {
            //  Couldn't allocate tracking block - fail allocation
            TaskMemFree(pvOrig);
            pv = NULL;
        }
    }

    if (pv == NULL)
    {
        ModifyResLimit(DBR_MEMORY, (LONG)size);
    }

    return(pv);
}

//+-------------------------------------------------------------------------
//
//  Method:     CLocalAlloc::operator delete, public
//
//  Synopsis:   Free memory from task local space
//
//  Arguments:  [pv] -- Pointer to memory to free
//
//  History:    17-Aug-92 	PhilipLa    Created.
//              18-May-93       AlexT       Switch to task IMalloc
//
//--------------------------------------------------------------------------

void CLocalAlloc::operator delete(void *pv)
{
    if (pv == NULL)
        return;

    CMemAlloc **ppma = (CMemAlloc **)pv;
    ppma--;

    CMemAlloc *pma = *ppma;

    RemoveAlloc(pma, pv, GetCurrentContextId());

    pv = (void *) ppma;
    memset(pv, OLDMEM, (size_t) pma->cbSize);

    //  Free tracking block
    IMalloc *pMalloc = NULL;

#ifdef WIN32
#ifdef MULTIHEAP
    pMalloc = &g_smAllocator;
#else
    if ( FAILED(DfCreateSharedAllocator ( &pMalloc )) )
        pMalloc = NULL;
#endif // MULTIHEAP
#else
    if (FAILED(DfGetScode(CoGetMalloc(MEMCTX_SHARED, &pMalloc))))
        pMalloc = NULL;
#endif

    if (pMalloc != NULL)
    {
        memset(pma, OLDMEM, sizeof(CMemAlloc));
        pMalloc->Free(pma);
        pMalloc->Release();
    }
    else
        olAssert(!aMsg("Unable to get shared allocator\n"));

    TaskMemFree(pv);
}

#endif // DBG==1 && !defined(MULTIHEAP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\pdffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       pdffuncs.cxx
//
//  Contents:   PDocFile static member functions
//
//  History:    22-Jun-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <tstream.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     PDocFile::CreateFromUpdate, public
//
//  Synopsis:   Creates an object from an update list entry
//
//  Arguments:  [pud] - Update entry
//              [pdf] - Docfile
//              [df] - Permissions
//
//  Returns:    Appropriate status code
//
//  History:    02-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE PDocFile::CreateFromUpdate(CUpdate *pud,
                                 PDocFile *pdf,
                                 DFLAGS df)
{
    PDocFile *pdfChild;
    PSStream *pstChild;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  PDocFile::CreateFromUpdate(%p, %p, %X)\n",
                pud, pdf, df));
    olAssert(pud->GetXSM() != NULL);
    switch(pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
    {
    case STGTY_STORAGE:
        olChk(pdf->CreateDocFile(pud->GetCurrentName(), df, pud->GetLUID(),
                                 pud->GetFlags() & ULF_TYPEFLAGS, &pdfChild));
        olChkTo(EH_Create,
                ((CWrappedDocFile *)pud->GetXSM())->SetBase(pdfChild));
        break;
    case STGTY_STREAM:
        olChk(pdf->CreateStream(pud->GetCurrentName(), df, pud->GetLUID(),
                                pud->GetFlags() & ULF_TYPEFLAGS, &pstChild));
        olChkTo(EH_Create,
                ((CTransactedStream *)pud->GetXSM())->SetBase(pstChild));
        break;
    default:
        olAssert(FALSE && aMsg("Unknown type in update list entry"));
        break;
    }
    olDebugOut((DEB_ITRACE, "Out PDocFile::CreateFromUpdate\n"));
    return S_OK;

 EH_Create:
    if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) == STGTY_STORAGE)
        pdfChild->Release();
    else
    {
        olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                 STGTY_STREAM);
        pstChild->Release();
    }
    olVerSucc(pdf->DestroyEntry(pud->GetCurrentName(), TRUE));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     PDocFile::ExcludeEntries, public
//
//  Synopsis:   Excludes the given entries
//
//  Arguments:  [snbExclude] - Entries to exclude
//
//  Returns:    Appropriate status code
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE PDocFile::ExcludeEntries(PDocFile *pdf,
                               SNBW snbExclude)
{
    PSStream *psstChild;
    PDocFile *pdfChild;
    SCODE sc;
    CDfName dfnKey;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  PDocFile::ExcludeEntries(%p)\n",
                snbExclude));
    for (;;)
    {
	if (FAILED(pdf->FindGreaterEntry(&dfnKey, &ib, NULL)))
	    break;
        dfnKey.Set(&ib.dfnName);

	if (NameInSNB(&ib.dfnName, snbExclude) == S_OK)
	{
	    switch(REAL_STGTY(ib.type))
	    {
	    case STGTY_STORAGE:
		olChkTo(EH_pwcsName, pdf->GetDocFile(&ib.dfnName, DF_READ |
						     DF_WRITE, ib.type,
						     &pdfChild));
		olChkTo(EH_Get, pdfChild->DeleteContents());
		pdfChild->Release();
		break;
	    case STGTY_STREAM:
		olChkTo(EH_pwcsName, pdf->GetStream(&ib.dfnName, DF_WRITE,
                                                    ib.type, &psstChild));
                olChkTo(EH_Get, psstChild->SetSize(0));
                psstChild->Release();
                break;
            }
        }
    }
    olDebugOut((DEB_ITRACE, "Out ExcludeEntries\n"));
    return S_OK;

EH_Get:
    if (REAL_STGTY(ib.type) == STGTY_STORAGE)
        pdfChild->Release();
    else if (REAL_STGTY(ib.type) == STGTY_STREAM)
        psstChild->Release();
EH_pwcsName:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\smalloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       smalloc.cxx
//
//  Contents:   Shared memory heap implementation
//
//  Classes:    
//
//  Functions:  
//
//  History:    29-Mar-94       PhilipLa        Created
//              05-Feb-95   KentCe      Use Win95 Shared Heap.
//              10-May-95   KentCe      Defer Heap Destruction to the last
//                                      process detach.
//
//----------------------------------------------------------------------------

#include <dfhead.cxx>
#pragma hdrstop

#include <smalloc.hxx>
#include <dfdeb.hxx>


#ifdef NEWPROPS
#define FULLIMPL
#endif

//
//  Take advantage of unique Win95 support of a shared heap.
//
#if defined(_CHICAGO_)

#define HEAP_SHARED 0x04000000          // Secret feature of Win95 only.

//
//  Locate the following in a shared data segment.
//
#pragma data_seg(".sdata")

HANDLE gs_hSharedHeap      = NULL;      // hSharedHeap Handle for Win95.
DFLUID gs_dfluid           = LUID_BASE; // shared docfile global LUID

#pragma data_seg()

#define PRINTSTATS

#else // defined(_CHICAGO_)

#ifdef MULTIHEAP
DFLUID gs_dfluid           = LUID_BASE; // task memory heap support
INT    gs_iSharedHeaps     = 0;
#endif
#define DLL

#define DEB_STATS 0x00010000
#define DEB_PRINT 0x00020000

#ifdef DLL

#define PERCENT(a,b,c) (int)((((double)a + (double)b) / (double)c) * 100.0)

#define PRINTSTATS \
        memDebugOut((DEB_STATS,  \
                     "Total size: %lu, Space:  Free: %lu, Alloced: %lu"\
                     "  Blocks:  Free: %lu, Alloced: %lu"\
                     "  Efficiency: %.2f%%\n",\
                     _cbSize,\
                     GetHeader()->_ulFreeBytes,\
                     GetHeader()->_ulAllocedBytes,\
                     GetHeader()->_ulFreeBlocks,\
                     GetHeader()->GetAllocedBlocks(),\
                     PERCENT(GetHeader()->_ulFreeBytes,\
                             GetHeader()->_ulAllocedBytes, _cbSize)));
                     
#else
#define PRINTSTATS \
        printf( \
                "Total size: %lu, Free space: %lu, Alloced space: %lu"\
                "  Efficiency: %.2f%%\n",\
                _cbSize,\
                GetHeader()->_ulFreeBytes,\
                GetHeader()->_ulAllocedBytes,\
                ((double)(GetHeader()->_ulFreeBytes +\
                        GetHeader()->_ulAllocedBytes) / \
                (double)_cbSize) * (double)100);
#endif


#if DBG == 1
inline BOOL IsAligned(void *pv)
{
    return !((ULONG_PTR)pv & 7);
}
#else
#define IsAligned(x) TRUE
#endif


#define SHAREDMEMBASE NULL

#endif // !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Init, public
//
//  Synopsis:   Initialize heap for use
//
//  Arguments:  [pszName] -- Name of shared memory heap to use
//
//  Returns:    Appropriate status code
//
//  History:    29-Mar-94       PhilipLa        Created
//              05-Feb-95       KentCe          Use Win95 Shared Heap.
//
//  Remarks:    Review the class destructor if you change this code.
//
//----------------------------------------------------------------------------

#if !defined(MULTIHEAP)
SCODE CSmAllocator::Init(LPWSTR pszName)
#else
SCODE CSmAllocator::Init(ULONG ulHeapName, BOOL fUnmarshal)
#endif
{
    SCODE sc = S_OK;

#if !defined(MULTIHEAP)
    // Initialize the mutex
    sc = _dmtx.Init(TEXT("DocfileAllocatorMutex"));
    if (FAILED(sc))
    {
        return sc;
    }

    sc = _dmtx.Take(DFM_TIMEOUT);
    if (FAILED(sc))
    {
        return sc;
    }
#endif

#if defined(_CHICAGO_)
    //
    //  Create a new shared heap if this is the first time thru.
    //
    if (gs_hSharedHeap == NULL)
    {
        gs_hSharedHeap = HeapCreate(HEAP_SHARED, 0, 0);
#if DBG == 1
        ModifyResLimit(DBRQ_HEAPS, 1);
#endif        
    }

    //
    //  We keep a copy of the shared heap as a flag so the destructor logic
    //  does the right thing.
    //
    //
    m_hSharedHeap = gs_hSharedHeap;

#else
    CSharedMemoryBlock *psmb = NULL;
#ifdef MULTIHEAP
    _cbSize = 0;
    if (!fUnmarshal && g_pteb == NtCurrentTeb())  // only for main thread
    {
        if (g_ulHeapName != 0)  // the global shared memory block is active
        {
            _psmb = &g_smb;                             // needed for GetHeader
            _pbBase = (BYTE *)(_psmb->GetBase());       // needed for GetHeader
            if (_pbBase != NULL && GetHeader()->GetAllocedBlocks() == 0)
            {                                           // its' empty reuse it
                psmb = _psmb;
                _ulHeapName = g_ulHeapName;
                memDebugOut ((DEB_ITRACE, "Out CSmAllocator::Init "
                              " reuse %x\n", g_ulHeapName));
                return sc;
            }
        }
        else
        {
            psmb = _psmb = &g_smb;             // initialize g_smb
        }
    }

    if (psmb == NULL)
    {
        psmb = _psmb = new CSharedMemoryBlock ();
        if (psmb == NULL)
            return STG_E_INSUFFICIENTMEMORY;
    }

    WCHAR pszName[DOCFILE_SM_NAMELEN];
    wsprintf(pszName, L"DfSharedHeap%X", ulHeapName);
#else
    psmb = &_smb;
#endif

#if WIN32 == 100 || WIN32 > 200
    CGlobalSecurity         gs;
    if (SUCCEEDED(sc = gs.Init(TRUE)))
    {
#else
    LPSECURITY_ATTRIBUTES gs = NULL;
#endif

    //  the SMB needs a few bytes for its own header. If we request
    //  a page sized allocation, those few header bytes will cause an
    //  extra page to be allocated, so to prevent that we subtract off
    //  the header space from our requests.

    sc = psmb->Init(pszName,
                   DOCFILE_SM_SIZE - psmb->GetHdrSize(),        // reserve size
                   INITIALHEAPSIZE - psmb->GetHdrSize(),        // commit size
                   SHAREDMEMBASE,               // base address
                   (SECURITY_DESCRIPTOR *)gs,               // security descriptor
                   TRUE);                       // create if doesn't exist

    // Always pass in TRUE for "fOKToCreate", since passing FALSE
    // will open an existing mapping in read-only mode, but we need read-write

#if WIN32 == 100 || WIN32 > 200
    }
#endif

    if (SUCCEEDED(sc))
    {
#if DBG == 1
        ModifyResLimit(DBRQ_HEAPS, 1);
#endif                
        _cbSize = psmb->GetSize();
        _pbBase = (BYTE *)(psmb->GetBase());
#ifdef MULTIHEAP
        gs_iSharedHeaps++;
        _ulHeapName = ulHeapName;
#endif
        
            if (psmb->Created())
        {
            if (fUnmarshal)  // do not allow creates for unmarshals
            {
                Uninit();
                memErr (EH_Err, STG_E_INVALIDFUNCTION);
            }
            else
            {
                Reset();
            }
        }
        
#ifdef MULTIHEAP
        if (psmb == &g_smb)
            g_ulHeapName = ulHeapName;         // store global heap name
#endif
        PRINTSTATS;
    }
#endif
    
#if defined(MULTIHEAP)
    memDebugOut ((DEB_ITRACE, "Out CSmAllocator::Init sc=%x %x\n",
                  sc, ulHeapName));
#else
    _dmtx.Release();
    memDebugOut ((DEB_ITRACE, "Out CSmAllocator::Init sc=%x\n",
                  sc));
#endif

EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::QueryInterface, public
//
//  Synopsis:   Standard QI
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSmAllocator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::QueryInterface:%p()\n", this));

    if (IsEqualIID(iid, IID_IMalloc) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IMalloc *) this;
        CSmAllocator::AddRef();
    }
    else
        sc = E_NOINTERFACE;
        
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::QueryInterface\n"));

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSmAllocator::AddRef(void)
{
#ifdef MULTIHEAP
    return ++_cRefs;
#else
    return 1;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Release, public
//
//  Synopsis:   Release
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSmAllocator::Release(void)
{
#ifdef MULTIHEAP
    ULONG cRefs = --_cRefs;
    if (cRefs <= 0 && this != &g_ErrorSmAllocator)
        delete this;
    return cRefs;
#else
    return 0;
#endif
}

#if !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::FindBlock, private
//
//  Synopsis:   Find an appropriately sized block in the heap.
//
//  Arguments:  [cb] -- Size of block required
//
//  Returns:    Pointer to block, NULL on failure
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

CBlockHeader * CSmAllocator::FindBlock(SIZE_T cb, CBlockHeader **ppbhPrev)
{
    CBlockHeader *pbhCurrent = GetAddress(GetHeader()->GetFirstFree());
    *ppbhPrev = NULL;
    
    while (pbhCurrent != NULL)
    {
        memAssert(IsAligned(pbhCurrent));
        
        if ((pbhCurrent->GetSize() >= cb) && (pbhCurrent->IsFree()))
        {
            memAssert(pbhCurrent->GetSize() < _cbSize);  //MULTIHEAP
            memAssert((BYTE *)pbhCurrent >= _pbBase && 
                      (BYTE *)pbhCurrent < _pbBase + _cbSize);  // MULTIHEAP
            break;
        }
        else
        {
            memAssert (pbhCurrent->GetNext() <= _cbSize);   // MULITHEAP
            *ppbhPrev = pbhCurrent;
            pbhCurrent = GetAddress(pbhCurrent->GetNext());
        }
    }
    return pbhCurrent;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Reset, private
//
//  Synopsis:   Reset the heap to its original empty state.
//
//  Returns:    Appropriate status code
//
//  History:    04-Apr-94       PhilipLa        Created
//
//  Notes:
//
//----------------------------------------------------------------------------

inline SCODE CSmAllocator::Reset(void)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Reset:%p()\n", this));

    CBlockHeader *pbh = (CBlockHeader *)
        (_pbBase + sizeof(CHeapHeader));
            
    memAssert(IsAligned(pbh));
    pbh->SetFree();
    pbh->SetSize(_cbSize - sizeof(CHeapHeader));
    pbh->SetNext(0);

    memAssert((BYTE *)pbh + pbh->GetSize() == _pbBase + _cbSize);
    GetHeader()->SetFirstFree(GetOffset(pbh));
    GetHeader()->SetCompacted();
    GetHeader()->ResetAllocedBlocks();
    GetHeader()->ResetLuid();

#if DBG == 1
    GetHeader()->_ulAllocedBytes = 0;
    GetHeader()->_ulFreeBytes =
        pbh->GetSize() - sizeof(CBlockPreHeader);
    GetHeader()->_ulFreeBlocks = 1;
#endif
        
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Reset\n"));

    return S_OK;
}

#endif // !defined(_CHICAGO_)


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Alloc, public
//
//  Synopsis:   Allocate memory
//
//  Arguments:  [cb] -- Number of bytes to allocate
//
//  Returns:    Pointer to block, NULL if failure
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) CSmAllocator::Alloc (
        SIZE_T cb )
{
    void *pv = NULL;
#if DBG == 1
    SIZE_T cbSize = cb;
#endif
    
#if !defined(_CHICAGO_)
    CBlockHeader *pbh = NULL;
    CBlockHeader *pbhPrev = NULL;
    SCODE sc;
#endif

    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Alloc:%p(%lu)\n", this, cb));

#if defined(_CHICAGO_)

    pv = HeapAlloc(m_hSharedHeap, 0, cb);

#else // !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->Alloc (cb);
    }
#endif

    Sync();

    //The block must be at least large enough to hold the standard
    //  header (size and free bit) and a pointer to the next block.
    if (cb < sizeof(CBlockHeader) - sizeof(CBlockPreHeader))
    {
        cb = sizeof(CBlockHeader) - sizeof(CBlockPreHeader);
    }
    
    cb = cb + sizeof(CBlockPreHeader);

    //Make cb 8 byte aligned.
    if (cb & 7)
    {
        cb += (8 - (cb & 7));
    }

    memAssert((cb >= CBLOCKMIN) && "Undersized block requested.");
    pbh = FindBlock(cb, &pbhPrev);

    if (pbh == NULL)
    {
        if (!(GetHeader()->IsCompacted()))
        {
            //Do a heap merge and try to allocate again.
            CSmAllocator::HeapMinimize();
            pbh = FindBlock(cb, &pbhPrev);
        }
        
        if (pbh == NULL)
        {
#ifdef MULTIHEAP
            CSharedMemoryBlock *psmb = _psmb;
#else
            CSharedMemoryBlock *psmb = &_smb;
#endif
#if DBG == 1
            ULONG ulOldSize = psmb->GetSize();
#endif
            sc = (ULONG)psmb->Commit(_cbSize + (ULONG)max(cb, MINHEAPGROWTH));
            if (SUCCEEDED(sc))
            {
                //Attach newly committed space to free list.
                CBlockHeader *pbhNew = (CBlockHeader *)
                    (_pbBase + _cbSize);

                _cbSize = psmb->GetSize();

                memAssert((pbhPrev == NULL) || (pbhPrev->GetNext() == 0));
                memAssert(_cbSize > ulOldSize);

                if (pbhPrev != NULL)
                {
                    pbhPrev->SetNext(GetOffset(pbhNew));
                }
                else
                {
                    GetHeader()->SetFirstFree(GetOffset(pbhNew));
                }

                pbhNew->SetNext(0);
                pbhNew->SetSize(max(cb, MINHEAPGROWTH));
                pbhNew->SetFree();

                
                memAssert((BYTE *)pbhNew + pbhNew->GetSize() ==
                          _pbBase + _cbSize);
                
#if DBG == 1
                GetHeader()->_ulFreeBytes +=
                    pbhNew->GetSize() - sizeof(CBlockPreHeader);
                GetHeader()->_ulFreeBlocks += 1;
#endif
                
                pbh = pbhNew;
            }
#if DBG == 1
            else
            {
                memDebugOut((DEB_ERROR, "Can't grow shared memory\n"));
                PrintAllocatedBlocks();
            }
#endif            
        }
    }

    if (pbh != NULL)
    {
        //Allocate the found block.
        if ((pbh->GetSize() > cb) &&
            (pbh->GetSize() - cb > CBLOCKMIN))
        {
            //Split an existing block.  No free list update required.
            
            CBlockHeader *pbhNew =
                (CBlockHeader *)((BYTE *)pbh + (pbh->GetSize() - cb));

            pbhNew->SetSize(cb);
            pbhNew->ResetFree();
            pbhNew->SetNext(0);
            
            pbh->SetSize(pbh->GetSize() - cb);
#if DBG == 1
            cbSize = cb;
            GetHeader()->_ulAllocedBytes += (cb - sizeof(CBlockPreHeader));
            //The number of available free bytes decreases by the number
            //  of bytes allocated
            GetHeader()->_ulFreeBytes -= cb;
#endif
            memAssert(IsAligned(pbhNew));
            memAssert(IsAligned(pbh));
            
            pbh = pbhNew;
        }
        else
        {
            //Use an entire block.  Update free list appropriately.
            memAssert(IsAligned(pbh));
            pbh->ResetFree();
            if (pbhPrev != NULL)
            {
                pbhPrev->SetNext(pbh->GetNext());
            }
            else
            {
                GetHeader()->SetFirstFree(pbh->GetNext());
            }
#if DBG == 1
            cbSize = pbh->GetSize() - sizeof(CBlockPreHeader);
            GetHeader()->_ulAllocedBytes += cbSize;
            GetHeader()->_ulFreeBytes -= cbSize;
            GetHeader()->_ulFreeBlocks--;
#endif
            pbh->SetNext(0);
        }
    }

    if (pbh != NULL)
    {
        pv = (BYTE *)pbh + sizeof(CBlockPreHeader);
        GetHeader()->IncrementAllocedBlocks();
    }
#endif // !defined(_CHICAGO_)

    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Alloc=> %p\n", pv));

#if !defined(_CHICAGO_)
    memAssert(IsAligned(pv));
#endif // !defined(_CHICAGO_)

    PRINTSTATS;
    
#if DBG == 1 
    if (pv == NULL)
    {
#if defined(_CHICAGO_)
        memDebugOut((DEB_ERROR,
                     "Failed allocation of %lu bytes.\n",
                     cb));
#else  // !defined(_CHICAGO_)
        memDebugOut((DEB_ERROR,
                     "Failed allocation of %lu bytes.  Heap size is %lu\n",
                     cb,
                     _cbSize));
#endif // !defined(_CHICAGO_)
    }
    else
    {
        //Allocated some bytes.  Record this for leak tracking.
        ModifyResLimit(DBRQ_MEMORY_ALLOCATED, (LONG)pbh->GetSize());
    }
#endif
    
    return pv;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Realloc, public
//
//  Synopsis:   Resize the block given
//
//  Arguments:  [pv] -- Pointer to block to realloc
//              [cb] -- New size for block
//
//  Returns:    Pointer to new block, NULL if failure
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void *) CSmAllocator::Realloc(
        void *pv,
        SIZE_T cb )
{
    void *pvNew = NULL;
#ifdef FULLIMPL
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Realloc:%p()\n", this));

#if defined(_CHICAGO_)

    pvNew = HeapReAlloc(m_hSharedHeap, 0, pv, cb);

#else
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->Realloc (pv, cb);
    }
#endif

    if ((pv != NULL) && (cb == 0))
    {
        CSmAllocator::Free(pv);
        return NULL;
    }

    pvNew = CSmAllocator::Alloc(cb);
    if (pvNew != NULL && pv != NULL)
    {
        //Copy contents
        memcpy(pvNew, pv, min(cb, CSmAllocator::GetSize(pv)));
        CSmAllocator::Free(pv);
    }
#endif
    
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Realloc\n"));
#endif
    PRINTSTATS;
    
    return pvNew;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::DoFree, private
//
//  Synopsis:   Free a memory block
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//  History:    26-Jul-95       SusiA   Created
//
//----------------------------------------------------------------------------
inline void CSmAllocator::DoFree(void *pv)
{
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        g_pTaskAllocator->Free (pv);
        return;
    }
#endif
   memDebugOut((DEB_ITRACE, "In  CSmAllocator::DoFree:%p(%p)\n", this, pv));
#if DBG == 1
   SSIZE_T cbSize = 0;
#endif   

#if defined(_CHICAGO_)

    if (pv != NULL)
    {
#if DBG == 1
        cbSize = HeapSize(m_hSharedHeap, 0, pv);
#endif        
        HeapFree(m_hSharedHeap, 0, pv);
    }

#else

    Sync();
    
    if (pv != NULL)
    {
        CBlockHeader *pbh = (CBlockHeader *)
            ((BYTE *)pv - sizeof(CBlockPreHeader));
#ifdef MULTIHEAP
        SIZE_T ulSize = pbh->GetSize();  // temporary to hold size for debug
#if DBG == 1
        cbSize = ulSize;
#endif        
#endif

        memAssert(IsAligned(pbh));
        memAssert((BYTE*)pbh >= _pbBase && 
                  (BYTE*)pbh < _pbBase + _cbSize);      // MULTIHEAP
        pbh->SetFree();
        pbh->SetNext(GetHeader()->GetFirstFree());

        GetHeader()->SetFirstFree(GetOffset(pbh));
        GetHeader()->ResetCompacted();
        if (GetHeader()->DecrementAllocedBlocks() == 0)
        {
#ifdef MULTIHEAP
            Uninit();
#else
            
            Reset();
#endif
        }
        
#if DBG == 1
        else
        {
            GetHeader()->_ulAllocedBytes -=
                (pbh->GetSize() - sizeof(CBlockPreHeader));
            memAssert (GetHeader()->_ulAllocedBytes <= _cbSize);
            GetHeader()->_ulFreeBytes +=
                (pbh->GetSize() - sizeof(CBlockPreHeader));
            GetHeader()->_ulFreeBlocks++;
        }
#endif
#ifdef MULTIHEAP
        memDebugOut((DEB_ITRACE, "Out CSmAllocator::DoFree.  Freed %lu\n",
                     ulSize));  // don't access shared memory
#else
        memDebugOut((DEB_ITRACE, "Out CSmAllocator::DoFree.  Freed %lu\n",
                     pbh->GetSize()));
#endif
    }
#endif
#if !defined(MULTIHEAP)
    // the shared heap may have been unmapped, mustn't read it now
    PRINTSTATS;
#endif
#if DBG == 1
   //Freed some bytes, so record that.
   ModifyResLimit(DBRQ_MEMORY_ALLOCATED, (LONG)-cbSize);
#endif   
   
}
//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::Free, public
//
//  Synopsis:   Free a memory block
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//  History:    29-Mar-94       PhilipLa        Created
//              26-Jul-95       SusiA           Moved bulk of work to DoFree to
//                                              share code between Free and
//                                              FreeNoMutex
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CSmAllocator::Free(void *pv)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Free:%p(%p)\n", this, pv));
    
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#endif
    DoFree(pv);

}
//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::FreeNoMutex, public
//
//  Synopsis:   Free a memory block without first aquiring the mutex.
//              This function is equivalent to Free above, except that is does 
//              not attempt to first aquire the mutex.  It should be used OLNY 
//              when the calling function guarantees to already have the mutex.         
//    
//
//  Arguments:  [pv] -- Pointer to block to free
//
//  Returns:    void
//
//  History:    19-Jul-95       SusiA           Created
//
//----------------------------------------------------------------------------

void CSmAllocator::FreeNoMutex(void *pv)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::FreeNoMutex:%p(%p)\n", this, pv));
    
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
   //ensure we already have the mutex
    memAssert(_dmtx.HaveMutex());
#endif
#endif
    DoFree(pv);

}


//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::GetSize, public
//
//  Synopsis:   Return the size of the given block
//
//  Arguments:  [pv] -- Block to get size of
//
//  Returns:    Size of block pointer to by pv
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(SIZE_T) CSmAllocator::GetSize(void * pv)
{
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->GetSize (pv);
    }
#endif
    
    Sync();
    
    SIZE_T ulSize = (SIZE_T)-1;
#ifdef FULLIMPL
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::GetSize:%p()\n", this));
    if (pv != NULL)
    {
#if defined(_CHICAGO_)
        ulSize = HeapSize(m_hSharedHeap, 0, pv);
#else
        CBlockHeader *pbh;
        pbh = (CBlockHeader *)((BYTE *)pv - sizeof(CBlockPreHeader));
        
        ulSize = pbh->GetSize() - sizeof(CBlockPreHeader);
#endif
    }
        
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::GetSize\n"));
#endif
    return ulSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::DidAlloc, public
//
//  Synopsis:   Return '1' if this heap allocated pointer at pv
//
//  Arguments:  [pv] -- Pointer to block
//
//  Returns:    '1' == This heap allocated block.
//              '0' == This heap did not allocate block.
//              '-1' == Could not determine if this heap allocated block.
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(int) CSmAllocator::DidAlloc(void FAR * pv)
{
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        return g_pTaskAllocator->DidAlloc (pv);
    }
#endif
    int i = -1;
#ifdef FULLIMPL
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::DidAlloc:%p()\n", this));
#if defined(_CHICAGO_)
    if (HeapValidate(m_hSharedHeap, 0, pv))
    {
       i = 1;
    }
    else
    {
       i = 0;
    }
#else  // !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif

    i = ((BYTE *)pv >= _pbBase) && ((BYTE *)pv <= (_pbBase + _cbSize));
#endif // !defined(_CHICAGO_)
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::DidAlloc\n"));
#endif
    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::HeapMinimize, public
//
//  Synopsis:   Minimize the heap
//
//  Arguments:  None.
//
//  Returns:    void.
//
//  History:    29-Mar-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(void) CSmAllocator::HeapMinimize(void)
{
#if !defined(_CHICAGO_)
#if !defined(MULTIHEAP)
    CLockDfMutex lckdmtx(_dmtx);
#endif
#endif
#ifdef MULTIHEAP
    if (_pbBase == NULL)
    {
        memAssert (g_pTaskAllocator != NULL);
        g_pTaskAllocator->HeapMinimize ();
        return;
    }
#endif
    
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::HeapMinimize:%p()\n", this));

    PRINTSTATS;
    
#if defined(_CHICAGO_)

    HeapCompact(m_hSharedHeap, 0);

#else  // !defined(_CHICAGO_)

    CBlockHeader *pbhCurrent;
    CBlockHeader *pbhLast = NULL;
    BYTE *pbEnd = _pbBase + _cbSize;

#if DBG == 1
    PrintFreeBlocks();
    GetHeader()->_ulAllocedBytes = 0;
    GetHeader()->_ulFreeBytes = 0;
    GetHeader()->_ulFreeBlocks = 0;
#endif
    
    pbhCurrent = (CBlockHeader *)(_pbBase + sizeof(CHeapHeader));

    while ((BYTE *)pbhCurrent < pbEnd)
    {
        memAssert(IsAligned(pbhCurrent));
        memAssert((pbhCurrent->GetSize() != 0) &&
                  "Zero size block found.");
        if (pbhCurrent->IsFree())
        {
            //Check last block.  If adjacent, merge them.  If not,
            //  update pbhNext.
            
            if (pbhLast == NULL)
            {
                GetHeader()->SetFirstFree(GetOffset(pbhCurrent));
#if DBG == 1
                GetHeader()->_ulFreeBlocks = 1;
#endif
            }
            else
            {
                if (pbhLast->GetSize() + GetOffset(pbhLast) ==
                    GetOffset(pbhCurrent))
                {
                    //Merge the blocks.
                    pbhLast->SetSize(pbhLast->GetSize() +
                                     pbhCurrent->GetSize());
                    pbhCurrent = pbhLast;
                }
                else
                {
#if DBG == 1
                    GetHeader()->_ulFreeBytes +=
                        (pbhLast->GetSize() - sizeof(CBlockPreHeader));
                    GetHeader()->_ulFreeBlocks++;
#endif
                    pbhLast->SetNext(GetOffset(pbhCurrent));
                }
            }
            pbhLast = pbhCurrent;
        }
#if DBG == 1
        else
        {
            GetHeader()->_ulAllocedBytes +=
                (pbhCurrent->GetSize() - sizeof(CBlockPreHeader));
        }
#endif
        //Move to next block.
        pbhCurrent =
            (CBlockHeader *)((BYTE *)pbhCurrent + pbhCurrent->GetSize());
    }

    if (pbhLast != NULL)
    {
                    
#if DBG == 1
        GetHeader()->_ulFreeBytes +=
            (pbhLast->GetSize() - sizeof(CBlockPreHeader));
#endif
        pbhLast->SetNext(0);
    }
    else
    {
        GetHeader()->SetFirstFree(0);
    }

    GetHeader()->SetCompacted();
#if DBG == 1
    PrintFreeBlocks();
#endif

#endif // !defined(_CHICAGO_)
    
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::HeapMinimize\n"));
    
    PRINTSTATS;
}

#if !defined(_CHICAGO_)
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     CSmAllocator::PrintFreeBlocks, private
//
//  Synopsis:   Debug code to print sizes of free blocks
//
//  History:    25-Apr-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

void CSmAllocator::PrintFreeBlocks(void)
{
    CBlockHeader *pbhCurrent = GetAddress(GetHeader()->GetFirstFree());

    memDebugOut((DEB_PRINT, "There are %lu total free blocks\n",
                 GetHeader()->_ulFreeBlocks));
    
    while (pbhCurrent != NULL)
    {
        memDebugOut((DEB_PRINT, "Free block %p has size %lu\n", pbhCurrent,
                     pbhCurrent->GetSize()));
        pbhCurrent = GetAddress(pbhCurrent->GetNext());
    }
}
#endif

#ifdef MULTIHEAP
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::PrintAllocatedBlocks, private
//
//  Synopsis:   Debug code to find allocated block(s) that leaked
//
//  History:    25-Nov-95   HenryLee    Created
//
//----------------------------------------------------------------------------
void CSmAllocator::PrintAllocatedBlocks(void)
{
    CBlockHeader *pbhCurrent;
    CBlockHeader *pbhLast = NULL;
    BYTE *pbEnd = _pbBase + _cbSize;
    ULONG *pul;

    if (_psmb != NULL)
    {
        pbhCurrent = (CBlockHeader *)(_pbBase + sizeof(CHeapHeader));

        while ((BYTE *)pbhCurrent < pbEnd)
        {
            memAssert(IsAligned(pbhCurrent));
            memAssert((pbhCurrent->GetSize() != 0) && "Zero size block found.");
            if (!pbhCurrent->IsFree())
            {
                pul = (ULONG *)((BYTE *)pbhCurrent + sizeof(CBlockPreHeader));
                memDebugOut((DEB_ERROR, "Allocated Block %p %8x %8x (size %lu)\n",
                             pul, *pul, *(pul+1), pbhCurrent->GetSize()));
                
            }
            else
            {
                pul = (ULONG *)pbhCurrent;
                memDebugOut((DEB_ERROR, "Free      Block %p %8x %8x (size %lu)\n",
                             pul, *pul, *(pul+1), pbhCurrent->GetSize()));
            }
            pbhCurrent =
                (CBlockHeader *)((BYTE *)pbhCurrent + pbhCurrent->GetSize());
        }
    }
}
#endif // DBG == 1

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::SetState
//
//  Synopsis:   replace thread local state by PerContext state
//
//  History:    20-Nov-95  Henrylee    Created
//
//----------------------------------------------------------------------------
void CSmAllocator::SetState (CSharedMemoryBlock *psmb, BYTE * pbBase,
                             ULONG ulHeapName, CPerContext ** ppcPrev,
                             CPerContext *ppcOwner)
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::SetState(%p, %p, %lx, %p, %p, %p) (this == %p)\n", psmb, pbBase, ulHeapName, ppcPrev, ppcOwner, _ppcOwner, this));

    _psmb = psmb;
    _pbBase = pbBase;
    _cbSize = (_psmb) ? _psmb->GetSize() : 0;
    _ulHeapName = ulHeapName;
    DFBASEPTR = _pbBase;

    if (ppcPrev != NULL)
        *ppcPrev = _ppcOwner;
    _ppcOwner = ppcOwner;

//    memAssert (g_smAllocator.GetBase() == DFBASEPTR);
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::SetState()\n"));
}

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::GetState
//
//  Synopsis:   retrive thread local allocator state into percontext
//
//  History:    20-Nov-95  Henrylee    Created
//
//----------------------------------------------------------------------------
void CSmAllocator::GetState (CSharedMemoryBlock **ppsmb,
                             BYTE ** ppbBase, ULONG *pulHeapName)
{
    *ppsmb = _psmb;
    *ppbBase = _pbBase;
    *pulHeapName = _ulHeapName;
}

//+---------------------------------------------------------------------------
//
//  Member: CSmAllocator::Uninit
//
//  Synopsis:   unmap the shared memory region
//
//  History:    20-Nov-95  Henrylee    Created
//
//----------------------------------------------------------------------------
SCODE CSmAllocator::Uninit ()
{
    memDebugOut((DEB_ITRACE, "In  CSmAllocator::Uninit\n"));
    if (_psmb != NULL)
    {
        if (_psmb != &g_smb)
        {
            // This is last block in the heap, so we can close the heap
            // now.  There must be no shared heap accesses after this.
            delete _psmb;
#if DBG == 1
            ModifyResLimit(DBRQ_HEAPS, -1);
#endif            
            gs_iSharedHeaps--;
        }
        else
        {
            if (GetHeader()->GetAllocedBlocks() == 0)
                Reset();           // for g_smb
        }
        _psmb = NULL;
    }
    _pbBase = NULL;
    memDebugOut((DEB_ITRACE, "Out CSmAllocator::Uninit %x\n", _ulHeapName));

    _ulHeapName = 0;

    return S_OK;
}

#endif // MULTIHEAP

#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\ulist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       ulist.cxx
//
//  Contents:   CUpdateList implementation and support routines
//
//  History:    15-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CUpdate::CUpdate, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdfnCurrentName] - Current name pointer
//              [pdfnOriginalName] - Original name pointer
//              [dlLUID] - LUID
//              [dwFlags] - Flags
//              [ptsm] - Entry object
//
//  History:    15-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdate_CUpdate)
#endif

CUpdate::CUpdate(CDfName const *pdfnCurrent,
                 CDfName const *pdfnOriginal,
                 DFLUID dlLUID,
                 DWORD dwFlags,
                 PTSetMember *ptsm)
{
    SetCurrentName(pdfnCurrent);
    SetOriginalName(pdfnOriginal);
    _dl = dlLUID;
    _dwFlags = dwFlags;
    _ptsm = P_TO_BP(CBasedTSetMemberPtr, ptsm);
    _pudNext = _pudPrev = NULL;
    if (_ptsm)
        _ptsm->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdate::~CUpdate, public
//
//  Synopsis:   Destructor
//
//  History:    05-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdate_1CUpdate)  // inline?
#endif

CUpdate::~CUpdate(void)
{
    if (_ptsm)
        _ptsm->Release();
}

//+--------------------------------------------------------------
//
//  Member:     CUpdateList::Add, public
//
//  Synopsis:   Adds an element to an update list
//
//  Arguments:  [pdfnCurrent] - Current name
//              [pdfnOriginal] - Original name
//              [dlLUID] - LUID
//              [dwFlags] - Flags
//              [ptsm] - Entry object
//
//  Returns:    The new element or NULL
//
//  History:    15-Jan-92       DrewB   Created
//
//  Notes:      Caller must handle NULL
//              Entries must be added in the list in the order of
//              Add calls
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Add)
#endif

CUpdate *CUpdateList::Add(IMalloc * const pMalloc,
                          CDfName const *pdfnCurrent,
                          CDfName const *pdfnOriginal,
                          DFLUID dlLUID,
                          DWORD dwFlags,
                          PTSetMember *ptsm)
{
    CUpdate *pudNew;

    olDebugOut((DEB_ITRACE, "In  CUpdateList::Add:%p("
                "%ws, %ws, %ld, %lX, %p)\n", this, pdfnCurrent->GetBuffer(),
                pdfnOriginal->GetBuffer(), dlLUID, dwFlags, ptsm));

    olAssert((dlLUID != DF_NOLUID || pdfnOriginal != NULL) &&
             aMsg("Create update luid can't be DF_NOLUID"));

    pudNew = new (pMalloc) CUpdate(pdfnCurrent, pdfnOriginal, dlLUID,
                                   dwFlags, ptsm);
    if (pudNew)
    {
        Append(pudNew);
    }
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Add => %p\n", pudNew));
    return pudNew;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::Append, public
//
//  Synopsis:   Appends an update to the list
//
//  Arguments:  [pud] - Update
//
//  History:    25-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Append)
#endif

void CUpdateList::Append(CUpdate *pud)
{
    olDebugOut((DEB_ITRACE, "In  CUpdateList::Append:%p(%p)\n", this, pud));
    if (_pudTail)
        _pudTail->SetNext(pud);
    else
        _pudHead = P_TO_BP(CBasedUpdatePtr, pud);
    pud->SetPrev(BP_TO_P(CUpdate *, _pudTail));
    pud->SetNext(NULL);
    _pudTail = P_TO_BP(CBasedUpdatePtr, pud);
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Append\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::Remove, public
//
//  Synopsis:   Removes an element from the list
//
//  Arguments:  [pud] - Element to remove
//
//  History:    25-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Remove)
#endif

void CUpdateList::Remove(CUpdate *pud)
{
    olDebugOut((DEB_ITRACE, "In CUpdateList::Remove:%p(%p)\n", this, pud));
    olAssert(pud != NULL);
    CUpdate *pudNext = pud->GetNext();
    CUpdate *pudPrev = pud->GetPrev();
    
    if (pud->GetNext())
        pudNext->SetPrev(pudPrev);
    if (pud->GetPrev())
        pudPrev->SetNext(pudNext);
    if (pud == _pudHead)
        _pudHead = P_TO_BP(CBasedUpdatePtr, pudNext);
    if (pud == _pudTail)
        _pudTail = P_TO_BP(CBasedUpdatePtr, pudPrev);
    pud->SetNext(NULL);
    pud->SetPrev(NULL);
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Remove\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CUpdateList::Empty, public
//
//  Synopsis:   Frees all elements in an update list
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_Empty)
#endif

void CUpdateList::Empty(void)
{
    CUpdate *pudTmp;

    olDebugOut((DEB_ITRACE, "In  CUpdateList::Empty()\n"));
    while (_pudHead)
    {
        pudTmp = _pudHead->GetNext();
        delete BP_TO_P(CUpdate *, _pudHead);
        _pudHead = P_TO_BP(CBasedUpdatePtr, pudTmp);
    }
    _pudTail = NULL;
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Empty\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::IsEntry, public
//
//  Synopsis:   Checks the update list to see if the given name represents
//              and existing entry in the list
//
//  Arguments:  [pdfn] - Name
//              [ppud] - Update entry return or NULL
//
//  Returns:    UIE_CURRENT - Found as a current name
//              UIE_ORIGINAL - Found as an original name
//              UIE_NOTFOUND
//
//  Modifies:   [ppud]
//
//  History:    02-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_IsEntry)
#endif

UlIsEntry CUpdateList::IsEntry(CDfName const *pdfn, CUpdate **ppud)
{
    CUpdate *pud;
    UlIsEntry ret = UIE_NOTFOUND;

    olDebugOut((DEB_ITRACE, "In  CUpdateList::IsEntry:%p(%ws, %p)\n", this,
                pdfn->GetBuffer(), ppud));
    olAssert(pdfn != NULL && pdfn->GetLength() > 0);
    for (pud = BP_TO_P(CUpdate *, _pudTail); pud; pud = pud->GetPrev())
    {
        if (pdfn->IsEqual(pud->GetCurrentName()))
        {
            ret = UIE_CURRENT;
            break;
        }
        else if (pdfn->IsEqual(pud->GetOriginalName()))
        {
            ret = UIE_ORIGINAL;
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CUpdateList::IsEntry\n"));
    if (ppud)
        *ppud = pud;
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUpdateList::Concat, public
//
//  Synopsis:   Concatenates an update list onto the end of this one
//
//  Arguments:  [ul] - List to concatenate
//
//  History:    02-Nov-92       DrewB   Created
//
//  Notes:      [ul]'s head may be modified
//
//+---------------------------------------------------------------------------

#ifdef FUTURECODE
void CUpdateList::Concat(CUpdateList &ul)
{
    olDebugOut((DEB_ITRACE, "In  CUpdateList::Concat:%p(ul)\n", this));
    if (_pudTail)
    {
        _pudTail->SetNext(ul.GetHead());
        if (ul.GetHead())
        {
            ul.GetHead()->SetPrev(_pudTail);
            olAssert(ul.GetTail() != NULL);
            _pudTail = ul.GetTail();
        }
    }
    else
    {
        olAssert(_pudHead == NULL);
        _pudHead = ul.GetHead();
        _pudTail = ul.GetTail();
    }
    olDebugOut((DEB_ITRACE, "Out CUpdateList::Concat\n"));
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CUpdateList::Exists, public static
//
//  Synopsis:	Traverses an update list from a particular point
//              and determines whether a given name exists or
//              is renamed
//
//  Arguments:	[pud] - Update to look from
//              [ppdfn] - Name in/out
//              [fRename] - Perform renames or quit
//
//  Returns:	TRUE if exists
//              FALSE if deleted
//
//  History:	03-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef FUTURECODE
BOOL CUpdateList::Exists(CUpdate *pud,
                         CDfName **ppdfn,
                         BOOL fRename)
{
    for (; pud; pud = pud->GetNext())
    {
        if (pud->IsRename() &&
            (*ppdfn)->IsEqual(pud->GetOriginalName()))
        {
            if (fRename)
                *ppdfn = pud->GetCurrentName();
            else
                return FALSE;
        }
        else if (pud->IsDelete() &&
                 (*ppdfn)->IsEqual(pud->GetOriginalName()))
        {
            return FALSE;
        }
    }
    return TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:	CUpdateList::FindBase, public static
//
//  Synopsis:	Searches backwards in an update list for the creation of
//              a particular object, applying renames if necessary
//
//  Arguments:	[pud] - Update to start from
//              [ppdfn] - Name in/out
//
//  Returns:	Pointer to update entry for creation or NULL if
//              no creation entry.  [ppdfn] is changed to point to
//              the base name.
//
//  Modifies:   [ppdfn]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:      Does not kill the search on deletions; primarily
//              intended to be used with names that represent existing
//              entries, although it will work on any name
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CUpdateList_FindBase)
#endif

CUpdate *CUpdateList::FindBase(CUpdate *pud, CDfName const **ppdfn)
{
    for (; pud; pud = pud->GetPrev())
    {
        if (pud->IsRename() &&
            (*ppdfn)->IsEqual(pud->GetCurrentName()))
        {
            *ppdfn = pud->GetOriginalName();
        }
        else if (pud->IsCreate() &&
                 (*ppdfn)->IsEqual(pud->GetCurrentName()))
        {
            return pud;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\wdfiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdfiter.cxx
//
//  Contents:   CWrappedDocFile iterator methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:	CWrappedDocFile::FindGreaterEntry, public
//
//  Synopsis:	Returns the next greater child
//
//  Arguments:	[pdfnKey] - Previous key
//              [pib] - Fast iterator buffer
//              [pstat] - Full iterator buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_FindGreaterEntry) // Iterate_TEXT
#endif

SCODE CWrappedDocFile::FindGreaterEntry(CDfName const *pdfnKey,
                                        SIterBuffer *pib,
                                        STATSTGW *pstat)
{
    SCODE sc;
    CDfName *pdfnGreater, *pdfn;
    CUpdate *pud, *pudGreater;
    BOOL fFilled = FALSE;
    WCHAR *pwcsName;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::FindGreaterEntry:%p("
                "%p, %p, %p)\n", this, pdfnKey, pib, pstat));
    olAssert(pib == NULL || pstat == NULL);

    // Find the update entry that has the next greater name than the key
    pudGreater = NULL;
    for (pud = _ulChanged.GetHead(); pud; pud = pud->GetNext())
    {
        if (pud->IsCreate() || pud->IsRename())
        {
            pdfn = pud->GetCurrentName();
            if (_ulChanged.IsEntry(pdfn, NULL) == UIE_CURRENT &&
                CDirectory::NameCompare(pdfn, pdfnKey) > 0 &&
                (pudGreater == NULL ||
                 CDirectory::NameCompare(pdfn,
                                         pudGreater->GetCurrentName()) < 0))
            {
                pudGreater = pud;
                pdfnGreater = pdfn;
            }
        }
    }

    // Request the next greater name from the base
    if (_pdfBase != NULL)
    {
        CDfName dfnKey;

        // Loop until we either get a valid name or we run out
        dfnKey.Set(pdfnKey);
        for (;;)
        {
            if (FAILED(sc = _pdfBase->FindGreaterEntry(&dfnKey, pib, pstat)))
            {
                if (sc != STG_E_NOMOREFILES)
                {
                    olErr(EH_Err, sc);
                }
                else
                {
                    break;
                }
            }
            if (pib)
                dfnKey.Set(&pib->dfnName);
            else
            {
                olAssert(pstat != NULL);
                dfnKey.CopyString(pstat->pwcsName);
            }

            // Filter this name against the update list
            pdfn = &dfnKey;
            if (_ulChanged.IsEntry(pdfn, NULL) == UIE_ORIGINAL)
            {
                if (pstat)
                    TaskMemFree(pstat->pwcsName);
                continue;
            }

            // If this name is less than the update list name, use
            // the stat entry
            if (pudGreater == NULL ||
                CDirectory::NameCompare(pdfn,
                                        pudGreater->GetCurrentName()) < 0)
            {
                PTSetMember *ptsm;

                fFilled = TRUE;

                if (pstat && (ptsm = _ppubdf->FindXSMember(pdfn, GetName())))
                {
                    pwcsName = pstat->pwcsName;
                    // We want to keep the name already in pstat but pick
                    // up any new times on the XSM
                    olChkTo(EH_name, ptsm->Stat(pstat, STATFLAG_NONAME));
                    pstat->pwcsName = pwcsName;
                }

                // No need to check for renames because Exists would
                // have failed if there was a rename
            }
            else if (pstat)
            {
                TaskMemFree(pstat->pwcsName);
            }

            // Found a valid name, so stop looping
            break;
        }
    }

    if (!fFilled)
    {
        if (pudGreater == NULL)
        {
            sc = STG_E_NOMOREFILES;
        }
        else
        {
            if (pstat)
            {
                if (pudGreater->IsCreate())
                {
                    olChk(pudGreater->GetXSM()->Stat(pstat, 0));
                }
                else
                {
                    olAssert(pudGreater->IsRename());
                    olChk(StatEntry(pudGreater->GetCurrentName(), pib, pstat));
                }
            }
            else
            {
                olAssert(pib != NULL);
                pib->dfnName.Set(pudGreater->GetCurrentName());
                pib->type = pudGreater->GetFlags() & ULF_TYPEFLAGS;
            }
            sc = S_OK;
        }
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::FindGreaterEntry\n"));
 EH_Err:
    return sc;

 EH_name:
    if (pstat)
        TaskMemFree(pwcsName);
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CWrappedDocFile::StatEntry, public
//
//  Synopsis:	Gets information for a child
//
//  Arguments:	[pdfn] - Child name
//              [pib] - Short information
//              [pstat] - Full information
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pib] or [pstat]
//
//  History:	16-Apr-93	DrewB	Created
//
//  Notes:	Either [pib] or [pstat] must be NULL
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_StatEntry)
#endif

SCODE CWrappedDocFile::StatEntry(CDfName const *pdfn,
                                 SIterBuffer *pib,
                                 STATSTGW *pstat)
{
    CUpdate *pud;
    UlIsEntry uie;
    SCODE sc = S_FALSE;
    CDfName const *pdfnBase = pdfn;
    BOOL fResult = FALSE;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::StatEntry:%p(%p, %p, %p)\n",
                this, pdfn, pib, pstat));
    olAssert((pib != NULL) != (pstat != NULL));

    // Attempt to find the name in the update list
    uie = _ulChanged.IsEntry(pdfn, &pud);
    if (uie == UIE_ORIGINAL)
    {
        // Name has been renamed or deleted
        sc = STG_E_FILENOTFOUND;
        fResult = TRUE;
    }
    else if (uie == UIE_CURRENT)
    {
        if (pib)
        {
            pib->dfnName.Set(pud->GetCurrentName());
            pib->type = pud->GetFlags() & ULF_TYPEFLAGS;
            fResult = TRUE;
            sc = S_OK;
        }
        else
        {

            olAssert(pstat != NULL);

            // Find whether the given name came from a create entry
            // or resolve the name to the base name
            pud = CUpdateList::FindBase(pud, &pdfnBase);
            if (pud != NULL)
            {
                // Stat creation update entry
                olChk(pud->GetXSM()->Stat(pstat, 0));
                fResult = TRUE;
            }
            // else the update entry is a rename of an object in the base
            // and FindBase changed pdfnBase to the base name
        }
    }

    olAssert(fResult || sc == S_FALSE);

    if (!fResult)
    {
        // Haven't found the entry so try the base
        if (_pdfBase)
        {
            olChk(_pdfBase->StatEntry(pdfnBase, pib, pstat));

            // Check to see if we need to return a renamed name
            if (!pdfn->IsEqual(pdfnBase))
            {
                if (pib)
                    pib->dfnName.Set(pdfn);
                else
                {
                    TaskMemFree(pstat->pwcsName);
                    olMem(pstat->pwcsName =
                          (WCHAR *)TaskMemAlloc(pdfn->GetLength()));
                    memcpy(pstat->pwcsName, pdfn->GetBuffer(),
                           pdfn->GetLength());
                }
            }
        }
        else
            sc = STG_E_FILENOTFOUND;
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::StatEntry\n"));
 EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\wdffuncs.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdffuncs.cxx
//
//  Contents:   CWrappedDocFile support methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::DeleteContents, public
//
//  Synopsis:   Destroys the contents of a docfile
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_DeleteContents)    // Wrapdf_TEXT inline?
#endif

SCODE CWrappedDocFile::DeleteContents(void)
{
#ifdef WRAPPED_DELETE_CONTENTS
    PDocFileIterator *pdfi;
    SCODE sc;
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::DeleteContents:%p()\n",
                this));
    _ulChanged.Empty();
    olChk(GetIterator(&pdfi));
    for (;;)
    {
        if (FAILED(pdfi->BufferGetNext(&ib)))
            break;
        olChkTo(EH_pdfi, DestroyEntry(&ib.dfnName, FALSE));
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::DeleteContents\n"));
    // Fall through
EH_pdfi:
    pdfi->Release();
EH_Err:
    return sc;
#else
    olAssert(!aMsg("CWrappedDocFile::DeleteContents called"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetInitialState, private
//
//  Synopsis:   Sets inital values from a base or defaults
//
//  Arguments:  [pdfBase] - Base object or NULL
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB    Created
//              05-Sep-95       MikeHill Clear the time bits after CopyTimesFrom(base)
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_SetInitialState)
#endif

SCODE CWrappedDocFile::SetInitialState(PDocFile *pdfBase)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetInitialState:%p(%p)\n",
                this, pdfBase));
    if (pdfBase == NULL)
    {
        TIME_T tm;

        olChk(DfGetTOD(&tm));
        _tten.SetTime(WT_CREATION, tm);
        _tten.SetTime(WT_MODIFICATION, tm);
        _tten.SetTime(WT_ACCESS, tm);
        _clsid = CLSID_NULL;
        _grfStateBits = 0;
    }
    else
    {
        olChk(CopyTimesFrom(pdfBase));

        // There's no need for the time bits to be dirty; they don't need
        // to be written to the base because they were just read from the base.

        _fDirty &= ~(BOOL)( DIRTY_CREATETIME | DIRTY_MODIFYTIME | DIRTY_ACCESSTIME );

        olChk(pdfBase->GetClass(&_clsid));
        olChk(pdfBase->GetStateBits(&_grfStateBits));
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetInitialState\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::RevertUpdate, private
//
//  Synopsis:   Reverses an update list entry's effect
//
//  Arguments:  [pud] - Update entry
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CWrappedDocFile_RevertUpdate) // Wrapdf_Revert_TEXT
#endif

void CWrappedDocFile::RevertUpdate(CUpdate *pud)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::RevertUpdate:%p(%p)\n",
                this, pud));
    if (pud->IsCreate())
    {
        CDFBasis *pdfb = BP_TO_P(CDFBasis *, _pdfb);

        olAssert(pud->GetLUID() != DF_NOLUID);
        _ppubdf->DestroyChild(pud->GetLUID());
        if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) == STGTY_STORAGE)
        {
            CDocFile::Unreserve(1, pdfb);
            CWrappedDocFile::Unreserve(_ppubdf->GetTransactedDepth()-1,
                                       pdfb);
        }
        else
        {
            CDirectStream::Unreserve(1, pdfb);
            CTransactedStream::Unreserve(_ppubdf->GetTransactedDepth()-1,
                                         pdfb);
        }
    }
   else if (pud->IsRename())
    {
        // Roll back renames
        olAssert(_ppubdf->FindXSMember(pud->GetOriginalName(),
                                       GetName()) == NULL &&
                 aMsg("Revert rename precondition"));

        _ppubdf->RenameChild(pud->GetCurrentName(), GetName(),
                             pud->GetOriginalName());

        olAssert(_ppubdf->FindXSMember(pud->GetCurrentName(),
                                       GetName()) == NULL &&
                 aMsg("Revert rename postcondition"));
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::RevertUpdate\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\wdfxact.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdfxact.cxx
//
//  Contents:   CWrappedDocFile transactioning methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <sstream.hxx>
#include <tstream.hxx>
#include <dfdeb.hxx>

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::BeginCommit, public
//
//  Synopsis:   Allocates commit resources for two-phase commit
//
//  Arguments:  [dwFlags] - Flags
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::BeginCommit(DWORD const dwFlags)
{
    SCODE sc;
#ifdef INDINST
    DFSIGNATURE sigNew;
#endif

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::BeginCommit(%lX)\n",
                dwFlags));

    olAssert(_pdfBase != NULL);
    olAssert(P_TRANSACTED(_df));

#if DBG == 1
    if (!HaveResource(DBR_XSCOMMITS, 1))
        olErr(EH_Err, STG_E_ABNORMALAPIEXIT);
#endif

    _fBeginCommit = TRUE;
#ifdef INDINST
    _ppubdf->GetNewSignature(&sigNew);
    olChk(_pdfBase->BeginCommitFromChild(_ulChanged, NULL,
                                         _sigBase, sigNew, dwFlags, _ppubdf));
    // INDINST - Ownership of dirty and changed?
    if (P_INDEPENDENT(_df) && _pdfParent)
        olChkTo(EH_Begin,
                _pdfParent->BeginCommitFromChild(_ulChanged,
                                                 _pdfBase, _sigBase, sigNew,
                                                 dwFlags, _ppubdf));
    _sigBaseOld = _sigBase;
    _sigCombinedOld = _sigCombined;
    _sigBase = _sigCombined = sigNew;
#else
    olChk(_pdfBase->BeginCommitFromChild(_ulChanged, dwFlags, this));
#endif
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::BeginCommit\n"));
    return S_OK;

#ifdef INDINST
EH_Begin:
    _pdfBase->EndCommitFromChild(DF_ABORT);
#endif
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::EndCommit, public
//
//  Synopsis:   Performs actual commit/abort for two-phase commit
//
//  Arguments:  [df] - COMMIT/ABORT
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CWrappedDocFile::EndCommit(DFLAGS const df)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::EndCommit(%X)\n",
                df));

    olAssert(P_TRANSACTED(_df));

    if (!_fBeginCommit)
        return;
    _fBeginCommit = FALSE;

#if DBG == 1
    if (P_COMMIT(df))
        ModifyResLimit(DBR_XSCOMMITS, 1);
#endif

    _pdfBase->EndCommitFromChild(df, this);
#ifdef INDINST
    if (P_INDEPENDENT(_df) && _pdfParent)
        olVerSucc(_pdfParent->EndCommitFromChild(df));
#endif

    if (P_COMMIT(df))
    {
        // These are nulled because the memory should be gone
        _ulChanged.Unlink();
        SetClean();
    }
    else
    {
#ifdef INDINST
        _sigBase = _sigBaseOld;
        _sigCombined = _sigCombinedOld;
#endif
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::EndCommit\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::Revert, public
//
//  Synopsis:   Transaction level has requested revert
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CWrappedDocFile::Revert(void)
{
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile %p::Revert()\n", this));
    for (pud = _ulChanged.GetTail(); pud; pud = pud->GetPrev())
        RevertUpdate(pud);
    _ulChanged.Empty();
    olVerSucc(SetInitialState(BP_TO_P(PDocFile *, _pdfBase)));
    SetClean();

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::Revert\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::BeginCommitFromChild, public
//
//  Synopsis:   Start two-phase commit, requested by child
//
//  Arguments:  [ulChanged] - Change list
//              [dwFlags] - Flags controlling commit
//              [pdfChild] - Child object
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::BeginCommitFromChild(CUpdateList &ulChanged,
                                            DWORD const dwFlags,
                                            CWrappedDocFile *pdfChild)
{
    CUpdate *pud, *pudNext;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::BeginCommitFromChild:%p("
                "%p, %lX, %p)\n", this, ulChanged.GetHead(), dwFlags,
                pdfChild));

    UNREFERENCED_PARM(pdfChild);

    olAssert(P_TRANSACTED(_df));
    olAssert(_tssDeletedHolder.GetHead() == NULL);

    _ulChangedHolder = ulChanged;
    _ulChangedOld = _ulChanged;

    for (pud = ulChanged.GetHead(); pud; pud = pudNext)
    {
        if (pud->IsRename())
            _ppubdf->RenameChild(pud->GetOriginalName(), GetName(),
                                 pud->GetCurrentName());
        else if (pud->IsDelete())
        {
            PTSetMember *ptsm;
            if ((ptsm = _ppubdf->FindXSMember(pud->GetOriginalName(),
                                              GetName())) != NULL)
            {
                olAssert(ptsm->GetName() != DF_NOLUID &&
                         aMsg("Can't destroy NOLUID XSM"));
                // Take a reference because RemoveXSMember
                // will call Release
                ptsm->AddRef();
                _ppubdf->RemoveXSMember(ptsm);
                _tssDeletedHolder.AddMember(ptsm);
            }
        }
        else
            if (pud->IsCreate())
                olVerSucc(CreateFromUpdate(pud, this,
                                           DF_WRITE | DF_NOUPDATE |
                                           DF_TRANSACTED));
        pudNext = pud->GetNext();
        _ulChanged.Append(pud);
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::BeginCommitFromChild\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::EndCommitFromChild
//
//  Synopsis:   Ends two-phase commit, requested by child
//
//  Arguments:  [df] - COMMIT/ABORT
//              [pdfChild] - Child object
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CWrappedDocFile::EndCommitFromChild(DFLAGS const df,
                                         CWrappedDocFile *pdfChild)
{
    PTSetMember *ptsm;
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::EndCommitFromChild:%p("
                "%X, %p)\n", this, df, pdfChild));

    olAssert(P_TRANSACTED(_df));

    if (!P_COMMIT(df))
    {
        // Restore our update list
        _ulChanged = _ulChangedOld;

        // Unconcat _ulChanged and ulChanged
        if (_ulChanged.GetTail())
            _ulChanged.GetTail()->SetNext(NULL);
        if (_ulChangedHolder.GetHead())
            _ulChangedHolder.GetHead()->SetPrev(NULL);

        // Back out updates
        for (pud = _ulChangedHolder.GetTail(); pud; pud = pud->GetPrev())
            if (pud->IsCreate())
            {
                // We need to do two things:
                //
                // Break any SetBase links that might have been created
                //
                // Return newly created objects to the creators so
                // that they can be returned to the preallocation
                // pool

                if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                    STGTY_STORAGE)
                {
                    CWrappedDocFile *pwdf = (CWrappedDocFile *)pud->GetXSM();
                    CWrappedDocFile *pwdfBase;

                    if (pwdf != NULL &&
                        (pwdfBase = (CWrappedDocFile *)pwdf->GetBase()) !=
                        NULL)
                    {
                        // Increase ref count because SetBase will release
                        pwdfBase->AddRef();
                        pwdf->SetBase(NULL);
                        ReturnDocFile(pwdfBase);
                    }
                }
                else
                {
                    CTransactedStream *ptstm = (CTransactedStream *)pud->
                        GetXSM();
                    CTransactedStream *ptstmBase;

                    olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
                             == STGTY_STREAM);
                    if (ptstm != NULL &&
                        (ptstmBase = (CTransactedStream *)ptstm->GetBase()) !=
                        NULL)
                    {
                        // Increase ref count because SetBase will release
                        ptstmBase->AddRef();
                        ptstm->SetBase(NULL);
                        ReturnStream(ptstmBase);
                    }
                }
            }
            else if (pud->IsDelete())
            {
                // We use GetName() as the tree because we know that
                // only immediate children can show up in delete records
                if ((ptsm = _tssDeletedHolder.FindName(pud->GetOriginalName(),
                                                       GetName())) != NULL)
                {
                    _tssDeletedHolder.RemoveMember(ptsm);
                    _ppubdf->InsertXSMember(ptsm);
                    // Release the reference we took in BeginCommitFromChild
                    // because InsertXSMember takes a reference
                    ptsm->Release();
                }
            }
            else if (pud->IsRename())
            {
                // Roll back renames
                olAssert(_ppubdf->FindXSMember(pud->GetOriginalName(),
                                               GetName()) == NULL &&
                         aMsg("Abort commit rename precondition"));

                _ppubdf->RenameChild(pud->GetCurrentName(), GetName(),
                                     pud->GetOriginalName());

                olAssert(_ppubdf->FindXSMember(pud->GetCurrentName(),
                                               GetName()) == NULL &&
                         aMsg("Abort commit rename postcondition"));
            }
    }
    else
    {
        // Finalize creations
        for (pud = _ulChangedHolder.GetHead(); pud; pud = pud->GetNext())
            if (pud->IsCreate())
            {
                // Since the object pointed to by GetBase is at our level,
                // we know it is transacted so we can safely cast to
                // PTSetMember
                if ((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL)) ==
                    STGTY_STORAGE)
                {
                    ptsm = (CWrappedDocFile *)
                        ((CWrappedDocFile *)pud->GetXSM())->GetBase();
                }
                else
                {
                    olAssert((pud->GetFlags() & (ULF_TYPEFLAGS & STGTY_REAL))
                             == STGTY_STREAM);
                    ptsm = (CTransactedStream *)
                        ((CTransactedStream *)pud->GetXSM())->GetBase();
                }
                pud->SetXSM(ptsm);
            }

        // Finalize deletions
        while (ptsm = _tssDeletedHolder.GetHead())
        {
            olAssert(ptsm->GetName() != DF_NOLUID &&
                     aMsg("Can't destroy NOLUID XSM"));
            _ppubdf->DestroyChild(ptsm->GetName());
            _tssDeletedHolder.RemoveMember(ptsm);
            ptsm->Release();
        }

        // Pick up state information
        TIME_T tm;

        if (pdfChild->GetDirty() & DIRTY_CREATETIME)
        {
            olVerSucc(pdfChild->GetTime(WT_CREATION, &tm));
            olVerSucc(SetTime(WT_CREATION, tm));
        }
        if (pdfChild->GetDirty() & DIRTY_MODIFYTIME)
        {
            olVerSucc(pdfChild->GetTime(WT_MODIFICATION, &tm));
            olVerSucc(SetTime(WT_MODIFICATION, tm));
        }
        if (pdfChild->GetDirty() & DIRTY_ACCESSTIME)
        {
            olVerSucc(pdfChild->GetTime(WT_ACCESS, &tm));
            olVerSucc(SetTime(WT_ACCESS, tm));
        }
        if (pdfChild->GetDirty() & DIRTY_CLASS)
        {
            CLSID cls;
            
            olVerSucc(pdfChild->GetClass(&cls));
            olVerSucc(SetClass(cls));
        }
        if (pdfChild->GetDirty() & DIRTY_STATEBITS)
        {
            DWORD dwState;
            
            olVerSucc(pdfChild->GetStateBits(&dwState));
            olVerSucc(SetStateBits(dwState, 0xffffffff));
        }
    }

    // Forget temporary commit lists
    _ulChangedOld.Unlink();
    _ulChangedHolder.Unlink();

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::EndCommitFromChild\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetSignature, public
//
//  Synopsis:   Returns signature
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef INDINST
void CWrappedDocFile::GetSignature(DFSIGNATURE *psig)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetSignature()\n"));
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetSignature => %ld\n",
                _sigCombined));
    *psig = _sigCombined;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetSignature, public
//
//  Synopsis:   Sets the signature
//
//  Arguments:  [sig] - Signature
//
//  Returns:    Appropriate status code
//
//  History:    04-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef INDINST
void CWrappedDocFile::SetSignature(DFSIGNATURE sig)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetSignature(%ld)\n", sig));
    _sigCombined = sig;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetSignature\n"));
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetBase, public
//
//  Synopsis:   Sets Base pointer
//
//  Arguments:  [pdf] - New base
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::SetBase(PDocFile *pdf)
{
    SCODE sc = S_OK;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetBase(%p)\n", pdf));
    olAssert(_pdfBase == NULL || pdf == NULL);
    if (_pdfBase)
        _pdfBase->Release();
    if (pdf)
    {
        olChk(pdf->CopyTimesFrom(this));
        olChk(pdf->SetClass(_clsid));
        olChk(pdf->SetStateBits(_grfStateBits, 0xffffffff));
    }
    _pdfBase = P_TO_BP(CBasedDocFilePtr, pdf);
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetBase\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CopySelf, public
//
//  Synopsis:   Duplicates this object
//
//  Arguments:  [ptsm] - New object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [*pstm] holds pointer to new object if successful
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef INDINST
SCODE CWrappedDocFile::CopySelf(PTSetMember **pptsm)
{
    CDocFile *pdfCopy;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CopySelf()\n"));
    olChk(_ppubdf->GetScratchDocFile(&pdfCopy));
    olChkTo(EH_pdfCopy,
            CopyDocFileToDocFile(this, pdfCopy, TRUE, FALSE, TRUE, NULL));
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CopySelf => %p\n",
                pdfCopy));
    *pptsm = pdfCopy;
    return S_OK;

EH_pdfCopy:
    pdfCopy->Destroy();
EH_Err:
    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetCommitInfo, public
//
//  Synopsis:   Returns space accounting information for commits
//
//  Arguments:  [pulRet1] - Return for number of new entries
//              [pulRet2] - Return for number of deleted entries
//
//  Modifies:   [pulRet1]
//              [pulRet2]
//
//  History:    07-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
void CWrappedDocFile::GetCommitInfo(ULONGLONG *pulRet1, ULONGLONG *pulRet2)
#else
void CWrappedDocFile::GetCommitInfo(ULONG *pulRet1, ULONG *pulRet2)
#endif
{
    CUpdate *pud;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetCommitInfo(%p, %p)\n",
                pulRet1, pulRet2));
    *pulRet1 = 0;
    *pulRet2 = 0;
    for (pud = _ulChanged.GetHead(); pud; pud = pud->GetNext())
        if (pud->IsCreate())
            (*pulRet1)++;
        else if (pud->IsDelete())
            (*pulRet2)++;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetCommitInfo => %Lu, %Lu\n",
                *pulRet1, *pulRet2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\drt.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       drt.cxx
//
//  Contents:   DRT main routine
//
//  History:    22-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "tests.hxx"
#include "illeg.hxx"

// Test flags and type
typedef ULONG FLAGS;

#define TF_NONE                 0x00000000

// Suppression flags
#define TF_SUPPRESS             0x0000FFFF
#define TFS_ILLEGITIMATE        0x00000001
#define TFS_16BIT               0x00000002

// Enabling flags
#define TF_ENABLE               0xFFFF0000
#define TFE_DIRECT              0x00010000
#define TFE_TRANSACTED          0x00020000
#define TFE_INDEPENDENT         0x00040000
#define TFE_ANY                 (TFE_DIRECT | TFE_TRANSACTED | TFE_INDEPENDENT)

// Pointer to a test function
typedef void (*TestFn)(void);

static struct
{
    char *pszName;
    char *pszDesc;
    TestFn tfn;
    FLAGS flags;
} tests[] =
{
    "Create",   "Creation",
        t_create, TFE_ANY,
    "Open",     "Opening",
        t_open, TFE_ANY,
    "AddRef",   "AddRef/Release",
        t_addref, TFE_ANY,
    "TModify",  "Transacted modify/Commit/Revert",
        t_tmodify, TFE_TRANSACTED | TFE_INDEPENDENT,
    "DModify",  "Direct modifications",
        t_dmodify, TFE_DIRECT,
    "Stat",     "Stat",
        t_stat, TFE_ANY,
    "Stream",   "Stream operations",
        t_stream, TFE_ANY,
    "Enum",     "Enumerator operations",
        t_enum, TFE_ANY,
    "StgCopyTo", "IStorage::CopyTo",
        t_stgcopyto, TFE_ANY,
    "MoveCopy", "IStorage::MoveElementTo",
        t_movecopy, TFE_ANY,
    "Marshal",  "IMarshal operations",
        t_marshal, TFE_ANY
#if WIN32 == 200
        // No marshalling on Chicago
        | TFS_16BIT
#endif
        ,
    "ILockBytes", "ILockBytes usage",
        t_ilb, TFE_ANY,
    "StgMisc",  "Miscellaneous Stg functions",
        t_stgmisc, TFE_ANY,

    "IllStg", "Illegitimate IStorage calls",
        i_storage, TFE_ANY | TFS_ILLEGITIMATE,
    "IllStm", "Illegitimate IStream calls",
        i_stream, TFE_ANY | TFS_ILLEGITIMATE,
    "IllEnum", "Illegitimate enumerator calls",
        i_enum, TFE_ANY | TFS_ILLEGITIMATE
};
#define NTESTS (sizeof(tests)/sizeof(tests[0]))

DWORD dwTransacted = 0;
DWORD dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
BOOL fVerbose = FALSE;
OLECHAR atcDrtDocfile[_MAX_PATH];

static BOOL fRun[NTESTS];
#ifdef FLAT
static FLAGS flTests = TF_NONE;
#else
static FLAGS flTests = TF_NONE | TFS_16BIT;
#endif

static void Initialize(void)
{
    SCODE sc;

    SetData();
#if WIN32 == 300
    if (FAILED(sc = DfGetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
        error(EXIT_UNKNOWN,
              "CoInitializeEx failed with sc = 0x%lX\n", sc);
#else
    if (FAILED(sc = DfGetScode(CoInitialize(NULL))))
        error(EXIT_UNKNOWN,
              "CoInitialize failed with sc = 0x%lX\n", sc);
#endif
}

static void Uninitialize(void)
{
    UnsetData();
    CoUninitialize();
}

static int FindTest(char *pszName)
{
    int i, cchName;

    cchName = strlen(pszName);
    for (i = 0; i<NTESTS; i++)
        if (!_strnicmp(pszName, tests[i].pszName, cchName))
            return i;
    return -1;
}

static void RunTests(void)
{
    int i;

    for (i = 0; i<NTESTS; i++)
        // For a test to run:
        // 1)  fRun[test] must be TRUE
        // 2)  No suppression flags can be set that are not set in flTests
        // 3)  At least one enabling flag must be set that is set in flTests
        if (fRun[i] &&
            (tests[i].flags & ~flTests & TF_SUPPRESS) == 0 &&
            (tests[i].flags & flTests & TF_ENABLE) != 0)
        {
            out("\n----- Test #%2d - %s -----\n", i+1, tests[i].pszDesc);
            tests[i].tfn();
            CheckMemory();
            CleanData();
        }
}

static void Usage(void)
{
    int i;

    printf("Usage: drt [options]\n");
    printf("Options are:\n");
    printf("  -h        - This message\n");
    printf("  -d        - Suppress direct tests\n");
    printf("  -t        - Suppress transacted tests\n");
    printf("  -w        - Suppress independent tests\n");
    printf("  -i        - Enable illegitimate tests\n");
    printf("  -v        - Display test output\n");
    printf("  -y<kind>  - Control debug output (a, d, m, i, M, L)\n");
    printf("  -#[+|-]<number>   - Turn test <number> on (+) or off (-)\n");
    printf("                      No number means all\n");
    printf("  -n[+|-]<prefix>   - Turn test <prefix> on or off\n");
    printf("  -N<file>  - Set file to use for tests\n");
    printf("Prefix can be any prefix of:\n");
    for (i = 0; i<NTESTS; i++)
        printf("  %s\n", tests[i].pszName);
    exit(1);
}

void __cdecl main(int argc, char **argv)
{
    int i, iTest;
    BOOL fDirect = TRUE, fTrans = TRUE, fIndep = TRUE;

    SetDebug(0x101, 0x101);
    for (i = 0; i<NTESTS; i++)
        fRun[i] = TRUE;
    ATOOLE("drt.dfl", atcDrtDocfile, _MAX_PATH);
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '#':
                if (sscanf(argv[0]+3, "%d", &iTest) != 1)
                    iTest = -1;
                else
                    iTest--;
                for (i = 0; i<NTESTS; i++)
                    if (iTest == -1 || iTest == i)
                        fRun[i] = argv[0][2] == '+';
                break;
            case 'd':
                fDirect = FALSE;
                break;
            case 'i':
                flTests |= TFS_ILLEGITIMATE;
                break;
            case 'n':
                iTest = FindTest(argv[0]+3);
                if (iTest >= 0)
                    fRun[iTest] = argv[0][2] == '+';
                break;
            case 'N':
                ATOOLE(argv[0]+2, atcDrtDocfile, _MAX_PATH);
                break;
            case 't':
                fTrans = FALSE;
                break;
            case 'v':
                fVerbose = TRUE;
                break;
            case 'w':
                fIndep = FALSE;
                break;
            case 'y':
                switch(argv[0][2])
                {
                case 'a':
                    SetDebug(0xffffffff, 0xffffffff);
                    break;
                case 'd':
                    SetDebug(0xffffffff, 0x101);
                    break;
                case 'm':
                    SetDebug(0x101, 0xffffffff);
                    break;
                case 'i':
                    SetDebug(0x101, 0x101);
                    break;
                case 'M':
                    SetDebug(0x01100000, 0);
                    break;
                case 'L':
                    SetDebug(0x00100000, 0);
                    break;
                }
                break;
            case 'h':
            default:
                Usage();
            }
        }
        else
            Usage();
    }

    Initialize();

    if (fDirect)
    {
        out("\n---------- Direct ----------\n");
        dwTransacted = 0;
        dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
        flTests |= TFE_DIRECT;
        RunTests();
        flTests &= ~TFE_DIRECT;
    }

    if (fTrans)
    {
        out("\n---------- Transacted ----------\n");
        dwTransacted = STGM_TRANSACTED;
        dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
        flTests |= TFE_TRANSACTED;
        RunTests();
        flTests &= ~TFE_TRANSACTED;
    }

    if (fIndep)
    {
        out("\n---------- Independent ----------\n");
        dwTransacted = STGM_TRANSACTED;
        dwRootDenyWrite = STGM_SHARE_DENY_NONE;
        flTests |= TFE_INDEPENDENT;
        RunTests();
        flTests &= ~TFE_INDEPENDENT;
    }

    printf("Docfile DRT - PASSED\n");

    Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\wdfstrm.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdfstrm.cxx
//
//  Contents:   CWrappedDocFile stream methods
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

#include <tstream.hxx>

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CreateStream, public
//
//  Synopsis:   Creates a wrapped stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [pppstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pppstStream]
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::CreateStream(CDfName const *pdfnName,
                                    DFLAGS const df,
                                    DFLUID dlSet,
                                    PSStream **ppsstStream)
{
    SEntryBuffer eb;
    SCODE sc;
    CTransactedStream *pstWrapped;
    CUpdate *pud = NULL;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CreateStream("
               "%ws, %X, %lu, %p)\n", pdfnName, df, dlSet,
                ppsstStream));

    if (SUCCEEDED(IsEntry(pdfnName, &eb)))
        olErr(EH_Err, STG_E_FILEALREADYEXISTS);

    olAssert(P_TRANSACTED(_df));

    if (dlSet == DF_NOLUID)
        dlSet = CTransactedStream::GetNewLuid(_pdfb->GetMalloc());
    pstWrapped = GetReservedStream(pdfnName, dlSet, _df);
    if (!P_NOUPDATE(df))
    {
        olMemTo(EH_pstWrapped,
                (pud = _ulChanged.Add(_pdfb->GetMalloc(),
                                      pdfnName, NULL, dlSet,
                                      STGTY_STREAM, pstWrapped)));
    }
    if (pstWrapped != NULL)
    {
        olChkTo(EH_pud, pstWrapped->Init(NULL));
        _ppubdf->AddXSMember(this, pstWrapped, dlSet);
    }
    *ppsstStream = pstWrapped;

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CreateStream => %p\n",
                *ppsstStream));
    return S_OK;

 EH_pud:
    if (pud)
        _ulChanged.Delete(pud);
 EH_pstWrapped:
    pstWrapped->ReturnToReserve(BP_TO_P(CDFBasis *, _pdfb));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetStream, public
//
//  Synopsis:   Instantiates a wrapped stream
//
//  Arguments:  [pdfnName] - Name
//              [df] - Permissions
//              [pppstStream] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pppstStream]
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetStream(CDfName const *pdfnName,
                                 DFLAGS const df,
                                 PSStream **ppsstStream)
{
    PSStream *psstNew;
    PTSetMember *ptsm;
    CTransactedStream *pstWrapped;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetStream("
               "%ws, %X, %p)\n", pdfnName, df, ppsstStream));

    olAssert(P_TRANSACTED(_df));

    //  Look for this name in this level transaction set

    if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
    {
        if (ptsm->ObjectType() != STGTY_STREAM)
            olErr(EH_Err, STG_E_FILENOTFOUND);
        ptsm->AddRef();
        *ppsstStream = (CTransactedStream *)ptsm;
    }
    else if (_pdfBase == NULL ||
             _ulChanged.IsEntry(pdfnName, NULL) == UIE_ORIGINAL)
    {
        // named entry has been renamed or deleted
        // (we can't have a rename or delete without a base)

        olErr(EH_Err, STG_E_FILENOTFOUND);
    }
    else
    {
        //  We didn't find it here, so we need to ask our parent
        //  Find the right name to ask of the parent

	CDfName const *pdfnRealName = pdfnName;
	CUpdate *pud;
	
	if (_ulChanged.IsEntry(pdfnName, &pud) == UIE_CURRENT &&
	    pud->IsRename())
        {
	    pdfnRealName = pud->GetCurrentName();
            // We don't have to worry about picking up creates
            // because any create would have an XSM that would
            // be detected above
            olVerify(_ulChanged.FindBase(pud, &pdfnRealName) == NULL);
        }

	olAssert(_pdfBase != NULL);
        olChk(_pdfBase->GetStream(pdfnRealName, df, &psstNew));
        olAssert(psstNew->GetLuid() != DF_NOLUID &&
                 aMsg("Stream id is DF_NOLUID!"));

#ifdef USE_NOSCRATCH                                  
        olMemTo(EH_Get, pstWrapped = new(_pdfb->GetMalloc())
                CTransactedStream(pdfnName, psstNew->GetLuid(), _df,
                                  _pdfb->GetBaseMultiStream(),
                                  _pdfb->GetScratch()));
#else
        olMemTo(EH_Get, pstWrapped = new(_pdfb->GetMalloc())
                CTransactedStream(pdfnName, psstNew->GetLuid(), _df,
                                  _pdfb->GetScratch()));
#endif                                  
        olChkTo(EH_pstWrapped, pstWrapped->Init(psstNew));
        *ppsstStream = pstWrapped;
        _ppubdf->AddXSMember(this, pstWrapped, pstWrapped->GetLuid());
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetStream => %p\n",
                *ppsstStream));
    return S_OK;

EH_pstWrapped:
    delete pstWrapped;
EH_Get:
    psstNew->Release();
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\tset.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	tset.cxx
//
//  Contents:	PTSetMember methods
//
//  History:	16-Apr-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "dfhead.cxx"

#pragma hdrstop

#include <entry.hxx>

//+---------------------------------------------------------------------------
//
//  Member:	PTSetMember::Stat, public
//
//  Synopsis:	Fills in a STATSTG for the XSM
//
//  Arguments:	[pstat] - Buffer to fill in
//              [dwFlags] - STATFLAG_*
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pstat]
//
//  History:	12-Apr-93	DrewB	Created
//
//----------------------------------------------------------------------------

SCODE PTSetMember::Stat(STATSTGW *pstat, DWORD dwFlags)
{
    CWrappedDocFile *pwdf;
    CTransactedStream *ptstm;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  PTSetMember::Stat:%p(%p, %lX)\n",
                this, pstat, dwFlags));

    pstat->type = ObjectType();

    if ((pstat->type & STGTY_REAL) == STGTY_STORAGE)
    {
        PTimeEntry *pen;
        
        pwdf = (CWrappedDocFile *)this;
        pen = pwdf;
        olChk(pen->GetTime(WT_CREATION, &pstat->ctime));
        olChk(pen->GetTime(WT_ACCESS, &pstat->atime));
        olChk(pen->GetTime(WT_MODIFICATION, &pstat->mtime));

        olChk(pwdf->GetClass(&pstat->clsid));
        olChk(pwdf->GetStateBits(&pstat->grfStateBits));
        
        ULISet32(pstat->cbSize, 0);
    }
    else
    {
#ifdef LARGE_STREAMS
        ULONGLONG cbSize;
#else
        ULONG cbSize;
#endif

        ptstm = (CTransactedStream *)this;
        ptstm->GetSize(&cbSize);
        pstat->cbSize.QuadPart = cbSize;
    }

    if ((dwFlags & STATFLAG_NONAME) == 0)
    {
        olMem(pstat->pwcsName =
              (WCHAR *)TaskMemAlloc(_dfnName.GetLength()));
        memcpy(pstat->pwcsName, _dfnName.GetBuffer(), _dfnName.GetLength());
    }
    else
    {
        pstat->pwcsName = NULL;
    }
    
    sc = S_OK;

    olDebugOut((DEB_ITRACE, "Out PTSetMember::Stat\n"));
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::BeginCommit, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

SCODE PTSetMember::BeginCommit(DWORD const dwFlags)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        return ((CWrappedDocFile *)this)->BeginCommit(dwFlags);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        return ((CTransactedStream *)this)->BeginCommit (dwFlags);
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::EndCommit, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::EndCommit(DFLAGS const df)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->EndCommit (df);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->EndCommit (df);
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::Revert, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::Revert(void)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->Revert ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->Revert ();
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::GetCommitInfo, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

#ifdef LARGE_STREAMS
void PTSetMember::GetCommitInfo(ULONGLONG *pulRet1, ULONGLONG *pulRet2) 
#else
void PTSetMember::GetCommitInfo(ULONG *pulRet1, ULONG *pulRet2) 
#endif
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->GetCommitInfo (pulRet1, pulRet2);
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->GetCommitInfo (pulRet1, pulRet2);
    else
    {
        *pulRet1 = 0;
        *pulRet2 = 0;
        olAssert (!"Invalid signature on PTSetMember!");
    }
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::AddRef, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::AddRef(void)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->AddRef ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->AddRef ();
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}

//+--------------------------------------------------------------
//
//  Member: PTSetMember::Release, public
//
//  Synopsis:   calls to derived object
//
//  History:    20-Jan-98   HenryLee Created
//
//---------------------------------------------------------------

void PTSetMember::Release (void)
{
    if (_sig == CWRAPPEDDOCFILE_SIG)
        ((CWrappedDocFile *)this)->Release ();
    else if (_sig == CTRANSACTEDSTREAM_SIG)
        ((CTransactedStream *)this)->Release ();
    else
        olAssert (!"Invalid signature on PTSetMember!");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\docfile\wdocfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       wdocfile.cxx
//
//  Contents:   Implementation of CWrappedDocFile methods for DocFiles
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <dfhead.cxx>

#pragma hdrstop

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CWrappedDocFile, public
//
//  Synopsis:   Empty object constructor
//
//  Arguments:  [pdfn] - Name
//              [dl] - LUID
//              [df] - Transactioning flags
//              [dwType] - Type of object
//              [pdfb] - Basis
//              [ppubdf] - Public docfile
//
//  History:    30-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

CWrappedDocFile::CWrappedDocFile(CDfName const *pdfn,
                                 DFLUID dl,
                                 DFLAGS const df,
                                 CDFBasis *pdfb,
                                 CPubDocFile *ppubdf)
        : PTSetMember(pdfn, STGTY_STORAGE),
          PDocFile(dl),
          _pdfb(P_TO_BP(CBasedDFBasisPtr, pdfb))
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CWrappedDocFile:%p("
                "%ws, %lu, %X, %p, %p)\n", this, pdfn->GetBuffer(),
                dl, df, pdfb, ppubdf));

    _df = df;
    _fBeginCommit = FALSE;
    _cReferences = 0;
    _pdfParent = NULL;
    _ppubdf = P_TO_BP(CBasedPubDocFilePtr, ppubdf);
    _fDirty = 0;
    _pdfBase = NULL;
    PBasicEntry::_sig = CWRAPPEDDOCFILE_SIG;
    PTSetMember::_sig = CWRAPPEDDOCFILE_SIG;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CWrappedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::Init, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdfBase] - Base DocFile
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::Init(PDocFile *pdfBase)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CWrappedDocFile:%p(%p)\n",
                this, pdfBase));

    olChk(SetInitialState(pdfBase));
    _pdfBase = P_TO_BP(CBasedDocFilePtr, pdfBase);
    AddRef();
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CWrappedDocFile\n"));
    // Fall through
EH_Err:
    return sc;
}


#ifdef COORD
//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::InitPub, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [ppubdf] - Enclosing CPubDocFile
//
//  Returns:    Appropriate status code
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::InitPub(CPubDocFile *ppubdf)
{
    _ppubdf = P_TO_BP(CBasedPubDocFilePtr, ppubdf);
    return S_OK;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::~CWrappedDocFile, public
//
//  Synopsis:   Destructor
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

CWrappedDocFile::~CWrappedDocFile(void)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::~CWrappedDocFile()\n"));
    olAssert(_cReferences == 0);
    PBasicEntry::_sig = CWRAPPEDDOCFILE_SIGDEL;
    PTSetMember::_sig = CWRAPPEDDOCFILE_SIGDEL;
#ifdef INDINST
    if (P_INDEPENDENT(_df))
        ((CDocFile *)_pdfBase)->Destroy();
    else
#endif
        if (_pdfBase)
            _pdfBase->Release();
    // We don't want SetInitialState in Revert to actually refer to the
    // base because this object is dying and we shouldn't communicate
    // with out base except for the above Release
    _pdfBase = NULL;
    CWrappedDocFile::Revert();
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::~CWrappedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::CreateDocFile, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pdfnName] - Name of DocFile
//              [df] - Transactioning flags
//              [dlSet] - LUID to set or DF_NOLUID
//              [dwType] - Type of entry
//              [ppdfDocFile] - DocFile pointer return
//
//  Returns:    Appropriate error code
//
//  Modifies:   [*ppdfDocFile] holds DocFile pointer if successful
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::CreateDocFile(CDfName const *pdfnName,
                                     DFLAGS const df,
                                     DFLUID dlSet,
                                     PDocFile **ppdfDocFile)
{
    CWrappedDocFile *pdfWrapped;
    SEntryBuffer eb;
    SCODE sc;
    CUpdate *pud = NULL;
    CDFBasis *pdfb = BP_TO_P(CDFBasis *, _pdfb);

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::CreateDocFile:%p("
               "%ws, %X, %lu, %p, %p)\n", this, pdfnName, df, dlSet,
                ppdfDocFile));

    if (SUCCEEDED(IsEntry(pdfnName, &eb)))
        olErr(EH_Err, STG_E_FILEALREADYEXISTS);

    olAssert(P_TRANSACTED(_df));

    if (dlSet == DF_NOLUID)
        dlSet = CWrappedDocFile::GetNewLuid(_pdfb->GetMalloc());

    pdfWrapped = new (pdfb)
        CWrappedDocFile(pdfnName, dlSet, _df,
                        pdfb, BP_TO_P(CPubDocFile *, _ppubdf));
    olAssert(pdfWrapped != NULL && aMsg("Reserved DocFile not found"));

    if (!P_NOUPDATE(df))
    {
        olMemTo(EH_pdfWrapped,
                (pud = _ulChanged.Add(pdfb->GetMalloc(),
                                      pdfnName, NULL, dlSet,
                                      STGTY_STORAGE, pdfWrapped)));
    }
    olChkTo(EH_pud, pdfWrapped->Init(NULL));
    _ppubdf->AddXSMember(this, pdfWrapped, dlSet);
    *ppdfDocFile = pdfWrapped;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::CreateDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

 EH_pud:
    if (pud)
        _ulChanged.Delete(pud);
 EH_pdfWrapped:
    pdfWrapped->ReturnToReserve(pdfb);
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetDocFile, public
//
//  Synopsis:   Instantiates or converts an existing stream to a
//              DocFile
//
//  Arguments:  [pdfnName] - Name of stream
//              [df] - Transactioning flags
//              [dwType] - Type of entry
//              [ppdfDocFile] - Pointer to return new object
//
//  Returns:    Appropriate error code
//
//  Modifies:   [*ppdfDocFile] holds DocFile pointer if successful
//
//  History:    06-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetDocFile(CDfName const *pdfnName,
                                  DFLAGS const df,
                                  PDocFile **ppdfDocFile)
{
    PDocFile *pdfNew;
    PTSetMember *ptsm;
    CWrappedDocFile *pdfWrapped;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetDocFile:%p("
                "%ws, %X, %p)\n", this, pdfnName, df, ppdfDocFile));

    olAssert(P_TRANSACTED(_df));

    //  Look for this name in this level transaction set

    if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
    {
        if (ptsm->ObjectType() != STGTY_STORAGE)
            olErr(EH_Err, STG_E_FILENOTFOUND);

        ptsm->AddRef();
        *ppdfDocFile = (CWrappedDocFile *)ptsm;
    }
    else if (_pdfBase == NULL ||
             _ulChanged.IsEntry(pdfnName, NULL) == UIE_ORIGINAL)
    {
        // named entry has been renamed or deleted
        // (we can't have a rename or delete without a base)

        olErr(EH_Err, STG_E_FILENOTFOUND);
    }
    else
    {
	CDfName const *pdfnRealName = pdfnName;
	CUpdate *pud;
	
	if (_ulChanged.IsEntry(pdfnName, &pud) == UIE_CURRENT &&
            pud->IsRename())
        {
	    pdfnRealName = pud->GetCurrentName();
            // We don't have to worry about picking up creates
            // because any create would have an XSM that would
            // be detected above
            olVerify(_ulChanged.FindBase(pud, &pdfnRealName) == NULL);
        }

	olAssert(_pdfBase != NULL);
	olChk(_pdfBase->GetDocFile(pdfnRealName, df, &pdfNew));
        olAssert(pdfNew->GetLuid() != DF_NOLUID &&
                 aMsg("Docfile id is DF_NOLUID!"));

        CDFBasis *pdfb;
        pdfb = BP_TO_P(CDFBasis *, _pdfb);
        
        olMemTo(EH_Get, pdfWrapped = new(pdfb->GetMalloc())
                CWrappedDocFile(pdfnName, pdfNew->GetLuid(),
                                _df, pdfb, BP_TO_P(CPubDocFile *, _ppubdf)));
        olChkTo(EH_pdfWrapped, pdfWrapped->Init(pdfNew));
        _ppubdf->AddXSMember(this, pdfWrapped, pdfWrapped->GetLuid());
        *ppdfDocFile = pdfWrapped;
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetDocFile => %p\n",
                *ppdfDocFile));
    return S_OK;

EH_pdfWrapped:
    delete pdfWrapped;
EH_Get:
    pdfNew->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::IsEntry, public
//
//  Synopsis:   Determines whether the given object is in the DocFile
//              or not
//
//  Arguments:  [pdfnName] - Object name
//              [peb] - Entry buffer to fill in
//
//  Returns:    Appropriate error code
//
//  Modifies:   [peb]
//
//  History:    15-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::IsEntry(CDfName const *pdfnName,
                               SEntryBuffer *peb)
{
    CUpdate *pud;
    SCODE sc = S_OK;
    UlIsEntry uie;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::IsEntry(%ws, %p)\n",
                pdfnName, peb));

    //  Look in XSM's (for open/created things)

    PTSetMember *ptsm;
    if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
    {
        peb->luid = ptsm->GetName();
        peb->dwType = ptsm->ObjectType();
    }
    else
    {
        uie = _ulChanged.IsEntry(pdfnName, &pud);
        if (uie == UIE_CURRENT)
        {
            peb->luid = pud->GetLUID();
            peb->dwType = pud->GetFlags() & ULF_TYPEFLAGS;
        }
        else if (uie == UIE_ORIGINAL || _pdfBase == NULL)
        {
            sc = STG_E_FILENOTFOUND;
        }
        else
        {
            sc = _pdfBase->IsEntry(pdfnName, peb);
        }
    }
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::IsEntry => %lu, %lu, %lu\n",
                sc, peb->luid, peb->dwType));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::RenameEntry, public
//
//  Synopsis:   Renames an element of the DocFile
//
//  Arguments:  [pdfnName] - Current name
//              [pdfnNewName] - New name
//
//  Returns:    Appropriate error code
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::RenameEntry(CDfName const *pdfnName,
                                   CDfName const *pdfnNewName)
{
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::RenameEntry(%ws, %ws)\n",
                pdfnName, pdfnNewName));

    olAssert(P_TRANSACTED(_df));

    if (SUCCEEDED(sc = IsEntry(pdfnNewName, &eb)))
        olErr(EH_Err, STG_E_ACCESSDENIED)
    else if (sc != STG_E_FILENOTFOUND)
        olErr(EH_Err, sc);

    olChk(IsEntry(pdfnName, &eb));
    olMem(_ulChanged.Add(_pdfb->GetMalloc(),
                         pdfnNewName, pdfnName, eb.luid, eb.dwType, NULL));

    _ppubdf->RenameChild(pdfnName, GetName(), pdfnNewName);

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::RenameEntry\n"));
    return S_OK;

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::DestroyEntry, public
//
//  Synopsis:   Permanently destroys a child
//
//  Arguments:  [pdfnName] - Name
//              [fClean] - If true, remove create entry from update list
//                         rather than appending a delete update entry
//
//  Returns:    Appropriate error code
//
//  History:    09-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::DestroyEntry(CDfName const *pdfnName,
                                    BOOL fClean)
{
    SCODE sc;
    SEntryBuffer eb;

    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::DestroyEntry:%p(%ws, %d)\n",
                this, pdfnName, fClean));

    olAssert(P_TRANSACTED(_df));

    if (fClean)
    {
        CUpdate *pud = NULL;
        UlIsEntry uie;

        uie = _ulChanged.IsEntry(pdfnName, &pud);
        olAssert(uie == UIE_CURRENT);
        RevertUpdate(pud);
        _ulChanged.Delete(pud);
    }
    else
    {
        PTSetMember *ptsm;

        olChk(IsEntry(pdfnName, &eb));
        olMem(_ulChanged.Add(_pdfb->GetMalloc(),
                             NULL, pdfnName, eb.luid, eb.dwType, NULL));

        if ((ptsm = _ppubdf->FindXSMember(pdfnName, GetName())) != NULL)
        {
            olAssert(ptsm->GetName() != DF_NOLUID &&
                     aMsg("Can't destroy NOLUID XSM"));
            _ppubdf->DestroyChild(ptsm->GetName());
        }
    }

    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::DestroyEntry\n"));
    return S_OK;

EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetTime, public
//
//  Synopsis:   Gets a time
//
//  Arguments:  [wt] - Which time
//              [ptm] - Time return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ptm]
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    _tten.GetTime(wt, ptm);
    return S_OK;
}
//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetAllTimes, public
//
//  Synopsis:   Gets all times
//
//  Arguments:  [patm] - Access Time
//              [pmtm] - Modification Time
//		[pctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:   [atm], [mtm], [ctm]
//
//  History:    26-May-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::GetAllTimes(TIME_T *patm, TIME_T *pmtm, TIME_T *pctm)
{
    _tten.GetAllTimes(patm, pmtm, pctm);
    return S_OK;
}
//+--------------------------------------------------------------
//
//  Member:      CWrappedDocFile::SetAllTimes, public
//
//  Synopsis:   Sets all time values
//
//  Arguments:  [atm] - Access Time
//              [mtm] - Modification Time
//				[ctm] - Creation Time
//
//  Returns:    Appropriate status code
//
//  Modifies:  	
//
//  History:    22-Nov-95       SusiA   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::SetAllTimes(TIME_T atm, TIME_T mtm, TIME_T ctm)
{
    SetDirty((1 << WT_CREATION) | (1 << WT_MODIFICATION) |(1 << WT_ACCESS));
	_tten.SetAllTimes(atm, mtm, ctm);
	return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetTime, public
//
//  Synopsis:   Sets a time
//
//  Arguments:  [wt] - Which time
//              [tm] - New time
//
//  Returns:    Appropriate status code
//
//  History:    31-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CWrappedDocFile::SetTime(WHICHTIME wt, TIME_T tm)
{
    olAssert((1 << WT_CREATION) == DIRTY_CREATETIME);
    olAssert((1 << WT_MODIFICATION) == DIRTY_MODIFYTIME);
    olAssert((1 << WT_ACCESS) == DIRTY_ACCESSTIME);
    SetDirty(1 << wt);
    _tten.SetTime(wt, tm);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetClass, public
//
//  Synopsis:   Gets the class ID
//
//  Arguments:  [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::GetClass(CLSID *pclsid)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetClass:%p(%p)\n",
                this, pclsid));
    *pclsid = _clsid;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetClass\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetClass, public
//
//  Synopsis:   Sets the class ID
//
//  Arguments:  [clsid] - New class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::SetClass(REFCLSID clsid)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetClass:%p(?)\n", this));
    _clsid = clsid;
    SetDirty(DIRTY_CLASS);
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetClass\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::GetStateBits, public
//
//  Synopsis:   Gets the state bits
//
//  Arguments:  [pgrfStateBits] - State bits return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pgrfStateBits]
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::GetStateBits(DWORD *pgrfStateBits)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::GetStateBits:%p(%p)\n",
                this, pgrfStateBits));
    *pgrfStateBits = _grfStateBits;
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::GetStateBits\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWrappedDocFile::SetStateBits, public
//
//  Synopsis:   Sets the state bits
//
//  Arguments:  [grfStateBits] - Bits to set
//              [grfMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CWrappedDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    olDebugOut((DEB_ITRACE, "In  CWrappedDocFile::SetStateBits:%p("
                "%lu, %lu)\n", this, grfStateBits, grfMask));
    _grfStateBits = (_grfStateBits & ~grfMask) | (grfStateBits & grfMask);
    SetDirty(DIRTY_STATEBITS);
    olDebugOut((DEB_ITRACE, "Out CWrappedDocFile::SetStateBits\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\drtguid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	drtguid.cxx
//
//  Contents:	Define GUIDs needed by the DRT
//
//  History:	04-Nov-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <initguid.h>

#if WIN32 == 100 || WIN32 == 200
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers
//
//  History:    05-Nov-92 AlexT    Created
//
//--------------------------------------------------------------------------

#if defined(WIN32) && WIN32 != 300
//  32-bit non-Cairo hack - windows.h includes ole.h which is incompatible
//  with ole2.h, as well as rpc.h which is incompatible with compobj.h
#define _INC_OLE
#define __RPC_H__
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#if WIN32 != 300
#include <storage.h>
#endif

#include <debnot.h>

#include <drt.hxx>
#include <wrap.hxx>
#include <util.hxx>
#include <strlist.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\illeg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	illeg.cxx
//
//  Contents:	Illegitimate tests
//
//  History:	17-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "illeg.hxx"

void i_storage(void)
{
    WStorage *pwstg;
    IStorage *pstg, *pstg2;
    IStream *pstm;

    IllResult("StgCreateDocfile with NULL ppstg",
             StgCreateDocfile(NULL, 0, 0, NULL));
    IllResult("StgCreateDocfile with non-zero reserved",
             StgCreateDocfile(NULL, 0, 1, &pstg));
    IllResult("StgCreateDocfile with illegal permissions",
             StgCreateDocfile(NULL, 0, 0, &pstg));

    int fd;
    fd = _creat(OlecsOut(DRTDF), _S_IREAD);
    if (fd<0)
        error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);
    IllResult("StgCreateDocfile with STGM_WRITE over read-only file",
             StgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pstg));
    _chmod(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);

    IllResult("StgOpenStorage with NULL ppstg",
             StgOpenStorage(NULL, NULL, 0, NULL, 0, NULL));
    IllResult("StgOpenStorage with NULL name",
             StgOpenStorage(NULL, NULL, 0, NULL, 0, &pstg));
    IllResult("StgOpenStorage with illegal permissions",
             StgOpenStorage(DRTDF, NULL, 0xffffffff, NULL, 0, &pstg));
    IllResult("StgOpenStorage with non-zero reserved",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            1, &pstg));
#if WIN32 != 300
    // This will work on Cairo because it will open a file storage
    IllResult("StgOpenStorage on non-docfile",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            0, &pstg));
#endif
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE) | STGM_CREATE, 0, &pwstg);
    pstg = pwstg->GetI();
    IllResult("OpenStream that doesn't exist",
             pstg->OpenStream(STR("NoName"), 0, STMP(STGM_READWRITE),
                              0, &pstm));
    IllResult("OpenStorage that doesn't exist",
             pstg->OpenStorage(STR("NoName"), NULL, STGP(STGM_READWRITE),
                               NULL, 0, &pstg2));
    pwstg->Unwrap();
}

#define STREAMSIZE 128

void i_stream(void)
{
    WStorage *pwstg;
    WStream *pwstm;
    IStream *pstm;
    BYTE bBuffer[STREAMSIZE];
    ULONG cbRead;
    LARGE_INTEGER liSeek;
    ULARGE_INTEGER uliPos;
    ULARGE_INTEGER uliSize;
    ULARGE_INTEGER cb;

    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pwstg->CreateStream(STR("Stream"), STMP(STGM_READ), 0, 0, &pwstm);
    pstm = pwstm->GetI();
    
    IllResult("Read with NULL buffer",
             pstm->Read(NULL, STREAMSIZE, NULL));
    fExitOnFail = FALSE;
    pwstm->Read(bBuffer, STREAMSIZE, &cbRead);
    fExitOnFail = TRUE;
    if (cbRead != 0)
        error(EXIT_BADSC, "Read %lu bytes on zero-length stream\n", cbRead);

    IllResult("Write with NULL buffer",
             pstm->Write(NULL, STREAMSIZE, NULL));
    IllResult("Write on read-only stream",
             pstm->Write(bBuffer, STREAMSIZE, NULL));

    LISet32(liSeek, 0);
    IllResult("Seek with invalid origin",
             pstm->Seek(liSeek, (DWORD)(~STREAM_SEEK_SET), NULL));
    LISet32(liSeek, (ULONG)-1);
    IllResult("Seek before beginning",
             pstm->Seek(liSeek, STREAM_SEEK_CUR, NULL));

    ULISet32(uliSize, STREAMSIZE);
    IllResult("SetSize on read-only stream",
             pstm->SetSize(uliSize));

    ULISet32(uliPos, 0);
    ULISet32(cb, STREAMSIZE);
    IllResult("LockRegion attempt",
             pstm->LockRegion(uliPos, cb, LOCK_ONLYONCE));
    IllResult("UnlockRegion attempt",
             pstm->UnlockRegion(uliPos, cb, LOCK_ONLYONCE));
    
    pwstm->Unwrap();
    pwstg->Unwrap();
}

void i_enum(void)
{
    WStorage *pwstg;
    IStorage *pstg;
    IEnumSTATSTG *penm;
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pstg = pwstg->GetI();
    
    IllResult("EnumElements with NULL ppenm",
             pstg->EnumElements(0, NULL, 0, NULL));
    IllResult("EnumElements with non-zero reserved1",
             pstg->EnumElements(1, NULL, 0, &penm));
    IllResult("EnumElements with non-zero reserved2",
             pstg->EnumElements(0, (void *)1, 0, &penm));
    IllResult("EnumElements with non-zero reserved3",
             pstg->EnumElements(0, NULL, 1, &penm));
    
    pwstg->Unwrap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\wrap.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	wrap.cxx
//
//  Contents:	Wrapper implementations
//
//  History:	22-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <dfentry.hxx>

// Retrieve interface pointer for possibly NULL objects
#define SAFEI(obj) ((obj) ? (obj)->GetI() : NULL)

//+--------------------------------------------------------------
//
//  IStorage wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WStorage *WStorage::Wrap(IStorage *pistg)
{
    WStorage *wstg;

    wstg = new WStorage(pistg);
    if (wstg == NULL)
	error(EXIT_OOM, "Unable to wrap IStorage\n");
    return wstg;
}

WStorage::WStorage(IStorage *pstg)
{
    // Note:  takes ownership of pstg
    _pstg = pstg;
}

WStorage::~WStorage(void)
{
    if (_pstg)
	Release();
}

void WStorage::Unwrap(void)
{
    delete this;
}

HRESULT WStorage::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStorage %p::QueryInterface(riid, %p)", _pstg, ppvObj);
    return Result(_pstg->QueryInterface(riid, ppvObj));
}

ULONG WStorage::AddRef(void)
{
    ULONG ul;

    ul = _pstg->AddRef();
    out("IStorage %p::AddRef() - %lu\n", _pstg, ul);
    return ul;
}

ULONG WStorage::Release(void)
{
    ULONG ul;

    ul = _pstg->Release();
    out("IStorage %p::Release() - %lu\n", _pstg, ul);
    if (ul == 0)
	_pstg = NULL;
    return ul;
}

HRESULT WStorage::CreateStream(const OLECHAR * pwcsName,
			     const DWORD grfMode,
			     DWORD reserved1,
			     DWORD reserved2,
			     WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::CreateStream(%s, 0x%lX, %lu, %lu, %p)", _pstg,
	OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstm);
    hr = Result(_pstg->CreateStream(pwcsName, grfMode, reserved1,
                                    reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::OpenStream(const OLECHAR * pwcsName,
			   void *reserved1,
			   const DWORD grfMode,
			   DWORD reserved2,
			   WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::OpenStream(%s, %p, 0x%lX, %lu, %p)", _pstg,
	OlecsOut(pwcsName), reserved1, grfMode, reserved2, ppstm);
    hr = Result(_pstg->OpenStream(pwcsName, reserved1, grfMode,
				 reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::CreateStorage(const OLECHAR * pwcsName,
			      const DWORD grfMode,
			      DWORD reserved1,
                              DWORD reserved2,
			      WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::CreateStorage(%s, 0x%lX, %lu, %lu, %p)", _pstg,
        OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstg);
    hr = Result(_pstg->CreateStorage(pwcsName, grfMode, reserved1,
                                     (LPSTGSECURITY)reserved2, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::OpenStorage(const OLECHAR * pwcsName,
			    WStorage *pstgPriority,
			    const DWORD grfMode,
			    SNB snbExclude,
			    DWORD reserved,
			    WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::OpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", _pstg,
	OlecsOut(pwcsName), SAFEI(pstgPriority), grfMode,
	snbExclude, reserved, ppstg);
    hr = Result(_pstg->OpenStorage(pwcsName, SAFEI(pstgPriority),
                                   grfMode, snbExclude,
                                   reserved, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::CopyTo(DWORD ciidExclude,
		       IID *rgiidExclude,
		       SNB snbExclude,
		       WStorage *pstgDest)
{
    out("IStorage %p::CopyTo(%lu, %p, %p, %p)", _pstg, ciidExclude,
	rgiidExclude, snbExclude, pstgDest->GetI());
    return Result(_pstg->CopyTo(ciidExclude, rgiidExclude, snbExclude,
                                pstgDest->GetI()));
}

HRESULT WStorage::MoveElementTo(OLECHAR const FAR* lpszName,
    			WStorage FAR *pstgDest,
                        OLECHAR const FAR* lpszNewName,
                        DWORD grfFlags)
{
    out("IStorage %p::MoveElementTo(%p, %p, %p, %lu)", _pstg, lpszName,
	pstgDest->GetI(), lpszNewName, grfFlags);
    return Result(_pstg->MoveElementTo(lpszName, pstgDest->GetI(),
                                       lpszNewName, grfFlags));
}

HRESULT WStorage::Commit(const DWORD grfCommitFlags)
{
    out("IStorage %p::Commit(0x%lX)", _pstg, grfCommitFlags);
    return Result(_pstg->Commit(grfCommitFlags));
}

HRESULT WStorage::Revert(void)
{
    out("IStorage %p::Revert()", _pstg);
    return Result(_pstg->Revert());
}

HRESULT WStorage::EnumElements(DWORD reserved1,
			     void *reserved2,
			     DWORD reserved3,
			     WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IStorage %p::EnumElements(%lu, %p, %lu, %p)", _pstg,
	reserved1, reserved2, reserved3, ppenm);
    hr = Result(_pstg->EnumElements(reserved1, reserved2, reserved3, &pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

HRESULT WStorage::DestroyElement(const OLECHAR * pwcsName)
{
    out("IStorage %p::DestroyElement(%s)", _pstg, OlecsOut(pwcsName));
    return Result(_pstg->DestroyElement(pwcsName));
}

HRESULT WStorage::RenameElement(const OLECHAR * pwcsOldName,
			      const OLECHAR * pwcsNewName)
{
    out("IStorage %p::RenameElement(%s, %s)", _pstg, OlecsOut(pwcsOldName),
	OlecsOut(pwcsNewName));
    return Result(_pstg->RenameElement(pwcsOldName, pwcsNewName));
}

HRESULT WStorage::SetElementTimes(const OLECHAR *lpszName,
                                FILETIME const *pctime,
                                FILETIME const *patime,
                                FILETIME const *pmtime)
{
    out("IStorage %p::SetElementTimes(%s, %p, %p, %p)", _pstg,
        OlecsOut(lpszName), pctime, patime, pmtime);
    return Result(_pstg->SetElementTimes(lpszName, pctime, patime, pmtime));
}

HRESULT WStorage::SetClass(REFCLSID clsid)
{
    out("IStorage %p::SetClass(%s)", _pstg, GuidText(&clsid));
    return Result(_pstg->SetClass(clsid));
}

HRESULT WStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    out("IStorage %p::SetStateBits(0x%lX, 0x%lX)", _pstg, grfStateBits,
        grfMask);
    return Result(_pstg->SetStateBits(grfStateBits, grfMask));
}

HRESULT WStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStorage %p::Stat(%p, %lu)", _pstg, pstatstg, grfStatFlag);
    return Result(_pstg->Stat(pstatstg, grfStatFlag));
}

//+--------------------------------------------------------------
//
//  IStream wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WStream *WStream::Wrap(IStream *pistm)
{
    WStream *wstm;

    wstm = new WStream(pistm);
    if (wstm == NULL)
	error(EXIT_OOM, "Unable to wrap IStream\n");
    return wstm;
}

WStream::WStream(IStream *pstm)
{
    // Note:  takes ownership of pstm
    _pstm = pstm;
}

WStream::~WStream(void)
{
    if (_pstm)
	Release();
}

void WStream::Unwrap(void)
{
    delete this;
}

HRESULT WStream::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStream %p::QueryInterface(riid, %p)", _pstm, ppvObj);
    return Result(_pstm->QueryInterface(riid, ppvObj));
}

ULONG WStream::AddRef(void)
{
    ULONG ul;

    ul = _pstm->AddRef();
    out("IStream %p::AddRef() - %lu\n", _pstm, ul);
    return ul;
}

ULONG WStream::Release(void)
{
    ULONG ul;

    ul = _pstm->Release();
    out("IStream %p::Release() - %lu\n", _pstm, ul);
    if (ul == 0)
	_pstm = NULL;
    return ul;
}

HRESULT WStream::Read(VOID *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    out("IStream %p::Read(%p, %lu, %p)", _pstm, pv, cb, pcbRead);
    hr = _pstm->Read(pv, cb, pcbRead);
    if (pcbRead)
	out(" - %lu bytes", *pcbRead);
    Result(hr);
    if (pcbRead && *pcbRead != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't read data\n");
    return hr;
}

HRESULT WStream::Write(VOID *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr;

    out("IStream %p::Write(%p, %lu, %p)", _pstm, pv, cb, pcbWritten);
    hr = _pstm->Write(pv, cb, pcbWritten);
    if (pcbWritten)
	out(" - %lu bytes", *pcbWritten);
    Result(hr);
    if (pcbWritten && *pcbWritten != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't write data\n");
    return hr;
}

HRESULT WStream::Seek(LONG dlibMove,
		    DWORD dwOrigin,
		    ULONG *plibNewPosition)
{
    HRESULT hr;
    LARGE_INTEGER dlib;
    ULARGE_INTEGER plib;

    out("IStream %p::Seek(%ld, %lu, %p)", _pstm, dlibMove, dwOrigin,
	plibNewPosition);
    LISet32(dlib, dlibMove);
    hr = _pstm->Seek(dlib, dwOrigin, &plib);
    if (plibNewPosition)
    {
        *plibNewPosition = ULIGetLow(plib);
	out(" - ptr %lu", *plibNewPosition);
    }
    return Result(hr);
}

HRESULT WStream::SetSize(ULONG libNewSize)
{
    ULARGE_INTEGER lib;
    
    out("IStream %p::SetSize(%lu)", _pstm, libNewSize);
    ULISet32(lib, libNewSize);
    return Result(_pstm->SetSize(lib));
}

HRESULT WStream::Commit(const DWORD dwFlags)
{
    out("IStream %p:Commit(%lu)", _pstm, dwFlags);
    return Result(_pstm->Commit(dwFlags));
}

HRESULT WStream::CopyTo(WStream *pstm,
		      ULONG cb,
		      ULONG *pcbRead,
		      ULONG *pcbWritten)
{
    ULARGE_INTEGER lcb, pcbr, pcbw;
    HRESULT hr;
    
    out("IStream %p::CopyTo(%p, %lu, %p, %p)", _pstm, pstm->GetI(), cb,
	pcbRead, pcbWritten);
    ULISet32(lcb, cb);
    hr = Result(_pstm->CopyTo(pstm->GetI(), lcb, &pcbr, &pcbw));
    if (pcbRead)
        *pcbRead = ULIGetLow(pcbr);
    if (pcbWritten)
        *pcbWritten = ULIGetLow(pcbw);
    return hr;
}

HRESULT WStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStream %p::Stat(%p, %lu)", _pstm, pstatstg, grfStatFlag);
    return Result(_pstm->Stat(pstatstg, grfStatFlag));
}

HRESULT WStream::Clone(WStream * *ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStream %p::Clone(%p)", _pstm, ppstm);
    hr = Result(_pstm->Clone(&pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IEnumSTATSTG wrappers
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WEnumSTATSTG *WEnumSTATSTG::Wrap(IEnumSTATSTG *pienm)
{
    WEnumSTATSTG *wenm;

    wenm = new WEnumSTATSTG(pienm);
    if (wenm == NULL)
	error(EXIT_OOM, "Unable to wrap IEnumSTATSTG\n");
    return wenm;
}

WEnumSTATSTG::WEnumSTATSTG(IEnumSTATSTG *penm)
{
    // Note:  takes ownership of penm
    _penm = penm;
}

WEnumSTATSTG::~WEnumSTATSTG(void)
{
    if (_penm)
	Release();
}

void WEnumSTATSTG::Unwrap(void)
{
    delete this;
}

HRESULT WEnumSTATSTG::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IEnumSTATSTG %p::QueryInterface(riid, %p)", _penm, ppvObj);
    return Result(_penm->QueryInterface(riid, ppvObj));
}

ULONG WEnumSTATSTG::AddRef(void)
{
    ULONG ul;

    ul = _penm->AddRef();
    out("IEnumSTATSTG %p::AddRef() - %lu\n", _penm, ul);
    return ul;
}

ULONG WEnumSTATSTG::Release(void)
{
    ULONG ul;

    ul = _penm->Release();
    out("IEnumSTATSTG %p::Release() - %lu\n", _penm, ul);
    if (ul == 0)
	_penm = NULL;
    return ul;
}

HRESULT WEnumSTATSTG::Next(ULONG celt, STATSTG rgelt[], ULONG *pceltFetched)
{
    out("IEnumSTATSTG %p::Next(%lu, rgelt, %p)", _penm, celt, pceltFetched);
    return Result(_penm->Next(celt, rgelt, pceltFetched));
}

HRESULT WEnumSTATSTG::Skip(ULONG celt)
{
    out("IEnumSTATSTG %p::Skip(%lu)", _penm, celt);
    return Result(_penm->Skip(celt));
}

HRESULT WEnumSTATSTG::Reset(void)
{
    out("IEnumSTATSTG %p::Reset()", _penm);
    return Result(_penm->Reset());
}

HRESULT WEnumSTATSTG::Clone(WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IEnumSTATSTG %p::Clone(%p)", _penm, ppenm);
    hr = Result(_penm->Clone(&pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IMarshal wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

WMarshal *WMarshal::Wrap(IMarshal *pimsh)
{
    WMarshal *wmsh;

    wmsh = new WMarshal(pimsh);
    if (wmsh == NULL)
	error(EXIT_OOM, "Unable to wrap IMarshal\n");
    return wmsh;
}

WMarshal::WMarshal(IMarshal *pmsh)
{
    // Note:  takes ownership of pmsh
    _pmsh = pmsh;
}

WMarshal::~WMarshal(void)
{
    if (_pmsh)
	Release();
}

void WMarshal::Unwrap(void)
{
    delete this;
}

HRESULT WMarshal::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IMarshal %p::QueryInterface(riid, %p)", _pmsh, ppvObj);
    return Result(_pmsh->QueryInterface(riid, ppvObj));
}

ULONG WMarshal::AddRef(void)
{
    ULONG ul;

    ul = _pmsh->AddRef();
    out("IMarshal %p::AddRef() - %lu\n", _pmsh, ul);
    return ul;
}

ULONG WMarshal::Release(void)
{
    ULONG ul;

    ul = _pmsh->Release();
    out("IMarshal %p::Release() - %lu\n", _pmsh, ul);
    if (ul == 0)
	_pmsh = NULL;
    return ul;
}

HRESULT WMarshal::MarshalInterface(WStream * pStm,
                                   REFIID riid,
                                   LPVOID pv,
                                   DWORD dwDestContext,
				   LPVOID pvDestContext,
                                   DWORD mshlflags)
{
    out("IMarshal %p::MarshalInterface(%p, riid, %p, %lu, %lu, %lu)",
	_pmsh, pStm->GetI(), pv, dwDestContext, pvDestContext, mshlflags);
    return Result(_pmsh->MarshalInterface(pStm->GetI(), riid, pv,
                                          dwDestContext,
					  pvDestContext,
                                          mshlflags));
}

//+--------------------------------------------------------------
//
//  Root level wrappers
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

HRESULT WStgCreateDocfile(const OLECHAR * pwcsName,
			const DWORD grfMode,
			DWORD reserved,
			WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgCreateDocfile(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);
    hr = Result(StgCreateDocfile(pwcsName, grfMode,
                                 reserved, &pistg));

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
				    const DWORD grfMode,
				    DWORD reserved,
				    WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgCreateDocfileOnILockBytes(%p, 0x%lX, %lu, %p)",
	plkbyt, grfMode, reserved, ppstgOpen);
    hr = Result(StgCreateDocfileOnILockBytes(plkbyt, grfMode,
                                             reserved, &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorage(const OLECHAR * pwcsName,
		      WStorage *pstgPriority,
		      const DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", OlecsOut(pwcsName),
	SAFEI(pstgPriority), grfMode, snbExclude, reserved, ppstgOpen);
    hr = Result(StgOpenStorage(pwcsName, SAFEI(pstgPriority), grfMode,
			      snbExclude,
                               reserved, &pistg));

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  WStorage *pstgPriority,
				  const DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorageOnILockBytes(%p, %p, 0x%lX, %p, %lu, %p)",
	plkbyt, SAFEI(pstgPriority), grfMode, snbExclude, reserved,
	ppstgOpen);
    hr = Result(StgOpenStorageOnILockBytes(plkbyt, SAFEI(pstgPriority),
					  grfMode, snbExclude, reserved,
					  &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgIsStorageFile(const OLECHAR * pwcsName)
{
    out("StgIsStorageFile(%s)", OlecsOut(pwcsName));
    return Result(StgIsStorageFile(pwcsName));
}

HRESULT WStgIsStorageILockBytes(ILockBytes * plkbyt)
{
    out("StgIsStorageILockBytes(%p)", plkbyt);
    return Result(StgIsStorageILockBytes(plkbyt));
}

HRESULT WCoMarshalInterface(WStream *pStm,
                            REFIID iid,
                            IUnknown *pUnk,
                            DWORD dwDestContext,
                            LPVOID pvDestContext,
                            DWORD mshlflags)
{
    out("CoMarshalInterface(%p, iid, %p, %lu, %p, %lX)", pStm->GetI(),
        pUnk, dwDestContext, pvDestContext, mshlflags);
    return Result(CoMarshalInterface(pStm->GetI(), iid, pUnk, dwDestContext,
                                     pvDestContext, mshlflags));
}

HRESULT WCoUnmarshalInterface(WStream *pStm,
                              REFIID riid,
                              LPVOID *ppv)
{
    out("CoUnmarshalInterface(%p, iid, %p)", pStm->GetI(), ppv);
    return Result(CoUnmarshalInterface(pStm->GetI(), riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\strlist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	strlist.cxx
//
//  Contents:	CStrList implementation
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <string.h>

//+--------------------------------------------------------------
//
//  Member:	CStrList::CStrList, public
//
//  Synopsis:	Ctor
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

CStrList::CStrList(void)
{
    _pseHead = NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::~CStrList, public
//
//  Synopsis:	Dtor
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

CStrList::~CStrList(void)
{
    Empty();
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Add, public
//
//  Synopsis:	Adds a string to the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Pointer to entry or NULL
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

SStrEntry *CStrList::Add(OLECHAR *ptcs)
{
    SStrEntry *pse;

    // One char of string already counted in sizeof
    pse = (SStrEntry *)new
        char[sizeof(SStrEntry)+olecslen(ptcs)*sizeof(OLECHAR)];
    if (pse == NULL)
	return NULL;
    pse->pseNext = _pseHead;
    pse->psePrev = NULL;
    if (_pseHead)
	_pseHead->psePrev = pse;
    _pseHead = pse;
    olecscpy(pse->atc, ptcs);
    return pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Remove, public
//
//  Synopsis:	Removes an entry from the list
//
//  Arguments:	[pse] - Entry
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

void CStrList::Remove(SStrEntry *pse)
{
    if (pse->psePrev)
	pse->psePrev->pseNext = pse->pseNext;
    else
	_pseHead = pse->pseNext;
    if (pse->pseNext)
	pse->pseNext->psePrev = pse->psePrev;
    delete pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Find, public
//
//  Synopsis:	Attempts to find a string in the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Entry or NULL
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

SStrEntry *CStrList::Find(OLECHAR *ptcs)
{
    SStrEntry *pse;

    for (pse = _pseHead; pse; pse = pse->pseNext)
	if (!olecscmp(ptcs, pse->atc))
	    return pse;
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Empty, public
//
//  Synopsis:	Frees all elements in list
//
//  History:	24-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

void CStrList::Empty(void)
{
    SStrEntry *pse;

    while (_pseHead)
    {
	pse = _pseHead->pseNext;
	delete _pseHead;
	_pseHead = pse;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\util.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	util.cxx
//
//  Contents:	DRT support routines
//
//  History:	22-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <stdarg.h>
#include <direct.h>
#include <io.h>

#if DBG == 1
#include <dfdeb.hxx>
#endif

#define DEFAULT_DATA_DIR "."

BOOL fExitOnFail = TRUE;

char szOrigDir[_MAX_PATH] = ".";

// Preserve the current directory and change
// directory into the data directory
void SetData(void)
{
    char *pszDataDir;

    _getcwd(szOrigDir, _MAX_PATH);
    pszDataDir = getenv("DRTDATA");
    if (pszDataDir == NULL)
	pszDataDir = DEFAULT_DATA_DIR;
    _chdir(pszDataDir);
}

// Clean up the data directory
void CleanData(void)
{
    _unlink(OlecsOut(DRTDF));
    _unlink(OlecsOut(MARSHALDF));
}

// Restore the original directory
void UnsetData(void)
{
    _chdir(szOrigDir);
}

// Output a message if fVerbose is true
void out(char *fmt, ...)
{
    va_list args;

    if (fVerbose)
    {
	va_start(args, fmt);
	vprintf(fmt, args);
	va_end(args);
    }
}

// Print out an error message and terminate the DRT
void error(int code, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
#if !defined(FLAT) || defined(FPRINTF_WORKS)
    fprintf(stderr, "** Fatal error **: ");
    vfprintf(stderr, fmt, args);
#else
    printf("** Fatal error **: ");
    vprintf(fmt, args);
#endif
    va_end(args);
    CleanData();
    UnsetData();
    exit(code);
}

// Converts a TCHAR string to a char pointer in a temporary buffer
// This implementation treats the conversion buffer as a circular
// buffer so more than one string can be held (depending on the size
// of the strings)

#define BUFSIZE 1024

char *OlecsOut(OLECHAR const *ptcs)
{
#ifdef OLEWIDECHAR
    static char szBuffer[BUFSIZE];
    static char *pszBuf = szBuffer;
    char *pszTmp;

    if (ptcs == NULL)
        return NULL;
    if (wcslen(ptcs) >= (size_t)(BUFSIZE-(pszBuf-szBuffer)))
        pszBuf = szBuffer;
    wcstombs(pszBuf, ptcs, BUFSIZE);
    szBuffer[BUFSIZE-1] = 0;
    pszTmp = pszBuf;
    pszBuf += strlen(pszBuf)+1;
    return pszTmp;
#else
    return (char *)ptcs;
#endif
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_E_EXTANTMARSHALLINGS, "STG_E_EXTANTMARSHALLINGS",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "?";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(char *pszText, HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out("%s - %s (0x%lX)\n", pszText, ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call success\n");
    return hr;
}

// DEBUG - Check for memory leaks
void CheckMemory(void)
{
#if DBG == 1
    if (fVerbose || DfGetMemAlloced() != 0)
    {
	out("Memory held: %lu bytes\n", DfGetMemAlloced());
	if (DfGetMemAlloced() != 0)
	{
	    DfPrintAllocs();
            error(EXIT_BADSC, "Memory leak\n");
	}
    }
#endif
}

// DEBUG - Set the debugging level
void SetDebug(ULONG ulDf, ULONG ulMsf)
{
#if DBG == 1
    DfDebug(ulDf, ulMsf);
#endif
}

// Check whether a given storage has a certain
// structure or not
// Structure is given as a string with elements:
//   <Type><Name><Options>[,...]
//   Type - d for docfile and s for stream
//   Name - Characters up to a '(' or ','
//   Options - For a docfile, you can specify a recursive check
//     in parentheses
//
// Example:  dDocfile(sStream,dDocfile)
char *VerifyStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    char chType;
    SCODE sc;
    CStrList sl;
    SStrEntry *pse;
    IEnumSTATSTG *penm;
    STATSTG stat;
    OLECHAR atcName[CWCSTORAGENAME];

    if (FAILED(sc = DfGetScode(pstg->EnumElements(0, NULL, 0, &penm))))
	error(EXIT_BADSC, "VerifyStructure: Unable to create enumerator - "
	      "%s (0x%lX)\n", ScText(sc), sc);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, &stat, NULL));
	if (sc == S_FALSE)
	    break;
	else if (FAILED(sc))
	    error(EXIT_BADSC, "VerifyStructure: Unable to enumerate - "
	      "%s (0x%lX)\n", ScText(sc), sc);
	pse = sl.Add(stat.pwcsName);
	if (pse == NULL)
	    error(EXIT_OOM, "VerifyStructure: Unable to allocate string\n");
	pse->user.dw = stat.type;
	drtMemFree(stat.pwcsName);
    }
    penm->Release();
    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	pse = sl.Find(atcName);
	if (pse == NULL)
	    error(EXIT_BADSC, "VerifyStructure: '%s' not found\n", szName);
	switch(chType)
	{
	case 'd':
	    if (pse->user.dw != STGTY_STORAGE)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a storage\n",
		      szName);
	    sc = DfGetScode(pstg->OpenStorage(atcName, NULL,
                                              STGP(STGM_READWRITE), NULL,
                                              0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "VerifyStructure: can't open storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = VerifyStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    if (pse->user.dw != STGTY_STREAM)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a stream\n",
		      szName);
	    break;
	}
	sl.Remove(pse);
	if (*pszStructure == ',')
	    pszStructure++;
    }
    for (pse = sl.GetHead(); pse; pse = pse->pseNext)
	error(EXIT_BADSC, "VerifyStructure: additional member '%s'\n",
	      OlecsOut(pse->atc));
    return pszStructure;
}

// Creates a structure using the same syntax
// as VerifyStructure
char *CreateStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    IStream *pstmChild;
    char chType;
    SCODE sc;
    OLECHAR atcName[CWCSTORAGENAME];

    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	switch(chType)
	{
	case 'd':
	    sc = DfGetScode(pstg->CreateStorage(atcName, STGP(STGM_READWRITE),
                                                0, 0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = CreateStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    sc = DfGetScode(pstg->CreateStream(atcName, STMP(STGM_READWRITE),
                                               0, 0, &pstmChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create stream "
		      "'%s' - %s\n", szName, ScText(sc));
	    pstmChild->Release();
	    break;
	}
	if (*pszStructure == ',')
	    pszStructure++;
    }
    pstg->Commit(0);
    return pszStructure;
}

// Verifies the fields of a STATSTG
void VerifyStat(STATSTG *pstat, OLECHAR *ptcsName, DWORD type, DWORD grfMode)
{
    if (ptcsName == NULL)
    {
        if (pstat->pwcsName != NULL)
	    error(EXIT_BADSC, "Stat name should be NULL - is %p\n",
                  pstat->pwcsName);
    }
    else if (olecscmp(pstat->pwcsName, ptcsName))
	error(EXIT_BADSC, "Stat name mismatch - has '%s' vs. '%s'\n",
	      OlecsOut(pstat->pwcsName), OlecsOut(ptcsName));
    if (pstat->type != type)
	error(EXIT_BADSC, "Stat type mismatch - has %lu vs. %lu\n",
	      pstat->type, type);
    if (pstat->grfMode != grfMode)
	error(EXIT_BADSC, "Stat mode mismatch - has 0x%lX vs. 0x%lX\n",
	      pstat->grfMode, grfMode);
}

// Checks on a file's existence
BOOL Exists(OLECHAR *file)
{
    OFSTRUCT of;

#ifndef OLEWIDECHAR
    return OpenFile(file, &of, OF_EXIST | OF_SHARE_DENY_NONE) !=
	HFILE_ERROR ? TRUE : FALSE;
#else
    char szName[_MAX_PATH];
    wcstombs(szName, file, _MAX_PATH);
    return OpenFile(szName, &of, OF_EXIST | OF_SHARE_DENY_NONE) !=
	HFILE_ERROR ? TRUE : FALSE;
#endif
}

// Gets a file's length
ULONG Length(OLECHAR *file)
{
    OFSTRUCT of;
    ULONG cb;
    int hf;

#ifndef OLEWIDECHAR
    hf = OpenFile(file, &of, OF_READ | OF_SHARE_DENY_NONE);
#else
    char szName[_MAX_PATH];
    wcstombs(szName, file, _MAX_PATH);
    hf = OpenFile(szName, &of, OF_READ | OF_SHARE_DENY_NONE);
#endif
    if (hf == HFILE_ERROR)
        error(EXIT_BADSC, "Length: Unable to open '%s'\n", OlecsOut(file));
    cb = (ULONG)_llseek(hf, 0, SEEK_END);
    if (cb == (ULONG)HFILE_ERROR)
        error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
              OlecsOut(file));
    _lclose(hf);
    return cb;
}

// Original mode when a new mode is forced
// Used by ForceDirect, ForceTransacted and Unforce
static DWORD dwTransOld;
static DWORD dwRDWOld;

// Forces direct mode to be active
// Note:  this uses a static variable so it can\'t be nested
void ForceDirect(void)
{
    dwTransOld = dwTransacted;
    dwTransacted = STGM_DIRECT;
    dwRDWOld = dwRootDenyWrite;
    dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
}

// Forces transacted mode similarly to ForceDirect
void ForceTransacted(void)
{
    dwTransOld = dwTransacted;
    dwRDWOld = dwRootDenyWrite;
    dwTransacted = STGM_TRANSACTED;
}

// Returns to the original mode after a ForceDirect or ForceTransacted
void Unforce(void)
{
    dwTransacted = dwTransOld;
    dwRootDenyWrite = dwRDWOld;
}

// Equality for FILETIME
BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
    return ttTime.dwLowDateTime == ttCheck.dwLowDateTime &&
        ttTime.dwHighDateTime == ttCheck.dwHighDateTime;
}

// Get a fully qualified path for a file name
void GetFullPath(OLECHAR *file, OLECHAR *path)
{
#ifndef UNICODE
    char buf[_MAX_PATH];
    OFSTRUCT of;

    OLETOA(file, buf, _MAX_PATH);
    OpenFile(buf, &of, OF_PARSE);
    ATOOLE((char *)of.szPathName, path, _MAX_PATH);
#else
    OLECHAR *ptcsFile;

    GetFullPathName(file, _MAX_PATH, path, &ptcsFile);
#endif
}

//  Memory helper functions

HRESULT drtMemAlloc(ULONG ulcb, void **ppv)
{
    HRESULT hr;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(DfGetScode(hr = CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        *ppv = pMalloc->Alloc(ulcb);
        pMalloc->Release();

        if (*ppv == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    }

    return hr;
}

void drtMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidText(GUID const *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\tests.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	tests.cxx
//
//  Contents:	DRT tests
//
//  History:	23-Sep-92	DrewB	Created
//
//---------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "tests.hxx"
#include "ilb.hxx"

void t_create(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0, 0,
			     &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    pstgChild2->Unwrap();
    pstgChild->Commit(0);
    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Unwrap();
}

void t_open(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		     0, &pstgRoot);
    CreateStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Commit(0);
    pstgRoot->Unwrap();

    WStgOpenStorage(DRTDF, NULL, ROOTP(WSTG_READWRITE), NULL,
		    0, &pstgRoot);
    pstgRoot->OpenStorage(STR("Child"), NULL, STGP(WSTG_READWRITE), NULL, 0,
			  &pstgChild);
    pstgChild->OpenStorage(STR("Child2"), NULL, STGP(WSTG_READWRITE), NULL, 0,
			   &pstgChild2);
    pstgChild2->OpenStream(STR("Stream"), NULL, STMP(WSTG_READWRITE), 0,
			   &pstm);
    pstm->Unwrap();
    pstgChild2->Unwrap();
    pstgChild->Unwrap();
    pstgRoot->Unwrap();
}

void t_addref(void)
{
    WStorage *pstg;
    WStream *pstm;
    ULONG ul;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
#ifndef FLAT
    if ((ul = pstm->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#else
    if ((ul = pstm->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#endif
    pstg->Unwrap();
}

void t_tmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    // This test must use transacted mode to reproduce the
    // expected behavior
    ForceTransacted();

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test rename reversion
    pstgChild2->Revert();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test destruction of closed object
    pstgChild2->DestroyElement(STR("Stream"));
    pstgChild2->Commit(0);

    // Test create of previously deleted object
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstgChild2->Commit(0);
    VerifyStructure(pstgChild2->GetI(), "sStream");

#if 0
    // 08/11/93 - Renaming open children no longer allowed
    // Test renaming an open stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");
#endif

    pstgChild2->Revert();
    VerifyStructure(pstgChild2->GetI(), "sStream");
    pstgChild2->DestroyElement(STR("Stream"));
    pstgChild2->Commit(0);
    pstm->Unwrap();

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test rename of storage
    pstgChild->RenameElement(STR("Child2"), STR("RenamedChild"));
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(STR("Stream"));
    pstgChild->Commit(0);

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x9abcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(STR("RenamedChild"), &tm, NULL, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, &tm, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, NULL, &tm);

    pstgChild->OpenStorage(STR("RenamedChild"), NULL, STGP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set to %s\n", GuidText(&stat.clsid));
    if (stat.grfStateBits != 0x11881188)
        error(EXIT_BADSC, "State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Revert();
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, CLSID_NULL))
        error(EXIT_BADSC, "Class ID reverted to %s\n", GuidText(&stat.clsid));
    if (stat.grfStateBits != 0)
        error(EXIT_BADSC, "State bits reverted improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "");
    pstgRoot->Unwrap();
    Unforce();
}

void t_dmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    ULONG cbSize1, cbSize2;

    // This test must use direct mode to reproduce the
    // expected behavior
    ForceDirect();

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(STR("Child2"), STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test destroying a stream
    pstgChild2->DestroyElement(STR("RenamedStream"));

#if 0
    // 08/11/93 - Renaming open child no longer allowed
    // Test renaming an open stream
    pstgChild2->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    VerifyStructure(pstgChild2->GetI(), "sStream");
    pstgChild2->RenameElement(STR("Stream"), STR("RenamedStream"));
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");
    pstgChild2->DestroyElement(STR("RenamedStream"));
    pstm->Unwrap();
#endif

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test renaming a storage
    pstgChild->RenameElement(STR("Child2"), STR("RenamedChild"));
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(STR("Stream"));

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x9abcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(STR("RenamedChild"), &tm, NULL, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, &tm, NULL);
    pstgChild->SetElementTimes(STR("RenamedChild"), NULL, NULL, &tm);

    pstgChild->OpenStorage(STR("RenamedChild"), NULL, STMP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        error(EXIT_BADSC, "State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->DestroyElement(STR("Child"));
    VerifyStructure(pstgRoot->GetI(), "");

    // Verify that space is reclaimed after modifications
    pstgRoot->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize1 = Length(DRTDF);
    pstgRoot->DestroyElement(STR("Stream"));
    pstgRoot->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize2 = Length(DRTDF);
    if (cbSize1 != cbSize2)
        error(EXIT_BADSC, "Space is not being reclaimed, original %lu, "
              "now %lu\n", cbSize1, cbSize2);

    pstgRoot->Unwrap();

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgRoot);

    //  removal cases
    //    1) no right child

    CreateStructure(pstgRoot->GetI(), "d64,d32");
    VerifyStructure(pstgRoot->GetI(), "d64,d32");
    pstgRoot->DestroyElement(STR("64"));
    VerifyStructure(pstgRoot->GetI(), "d32");

    //    2) right child has no left child

    CreateStructure(pstgRoot->GetI(), "d64");
    VerifyStructure(pstgRoot->GetI(), "d32,d64");
    pstgRoot->DestroyElement(STR("32"));
    VerifyStructure(pstgRoot->GetI(), "d64");

    //    3) right child has left child

    CreateStructure(pstgRoot->GetI(), "d96,d80");
    VerifyStructure(pstgRoot->GetI(), "d64,d80,d96");
    pstgRoot->DestroyElement(STR("64"));
    VerifyStructure(pstgRoot->GetI(), "d80,d96");

    //    4) right child's left child has children

    CreateStructure(pstgRoot->GetI(), "d88,d84,d92");
    VerifyStructure(pstgRoot->GetI(), "d80,d84,d88,d92,d96");
    pstgRoot->DestroyElement(STR("80"));
    VerifyStructure(pstgRoot->GetI(), "d84,d88,d92,d96");

    pstgRoot->Unwrap();

    Unforce();
}

void t_stat(void)
{
    WStorage *pstgRoot, *pstgChild;
    WStream *pstm;
    STATSTG stat;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(STR("Child"), STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);

    pstm->Stat(&stat, 0);
    VerifyStat(&stat, STR("Stream"), STGTY_STREAM, STMP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstm->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STREAM, STMP(WSTG_READWRITE));

    pstm->Unwrap();

    pstgChild->Stat(&stat, 0);
    VerifyStat(&stat, STR("Child"), STGTY_STORAGE, STGP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgChild->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, STGP(WSTG_READWRITE));

    pstgChild->Unwrap();

    pstgRoot->Stat(&stat, 0);
    OLECHAR atcFullPath[_MAX_PATH];
    GetFullPath(DRTDF, atcFullPath);
    VerifyStat(&stat, atcFullPath, STGTY_STORAGE, ROOTP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgRoot->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, ROOTP(WSTG_READWRITE));

    pstgRoot->Unwrap();
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

void t_stream(void)
{
    WStorage *pstg;
    WStream *pstm, *pstmC;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb, ulPos;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(NUMBERS, sizeof(NUMBERS), &cb);
    pstm->Commit(0);
    pstm->Seek(0, WSTM_SEEK_SET, &ulPos);
    if (ulPos != 0)
	error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos);
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    if (strcmp(buf, NUMBERS))
	error(EXIT_BADSC, "Incorrect stream contents\n");
    pstm->SetSize(sizeof(NUMBERS)/2);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    fExitOnFail = FALSE;
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    fExitOnFail = TRUE;
    if (cb != sizeof(NUMBERS)/2)
	error(EXIT_BADSC, "SetSize failed to size stream properly\n");
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "SetSize corrupted contents\n");
    pstm->Clone(&pstmC);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)/2, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)&~1, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb);
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "Stream contents incorrect\n");
    pstmC->Unwrap();
    pstm->Unwrap();
    pstg->Unwrap();
}

// Number of entries for enumeration test
#define ENUMENTRIES 10

// Flag indicating a name has already shown up in enumeration,
// must not conflict with STGTY_*
#define ENTRY_SEEN 0x100

// Check the validity of an enumeration element
static void elt_check(STATSTG *pstat, CStrList *psl)
{
    SStrEntry *pse;

    pse = psl->Find(pstat->pwcsName);
    if (pse == NULL)
        error(EXIT_BADSC, "Spurious element '%s'\n", pstat->pwcsName);
    else if ((pse->user.dw & ~ENTRY_SEEN) != pstat->type)
        error(EXIT_BADSC, "Element '%s' has wrong type - "
              "has %lX vs. %lX\n", pstat->pwcsName, pstat->type,
              pse->user.dw & ~ENTRY_SEEN);
    else if (pse->user.dw & ENTRY_SEEN)
        error(EXIT_BADSC, "Element '%s' has already been seen\n",
              pstat->pwcsName);
    pse->user.dw |= ENTRY_SEEN;
}

// Do final validity checks for enumeration
static void enum_list_check(CStrList *psl)
{
    SStrEntry *pse;

    for (pse = psl->GetHead(); pse; pse = pse->pseNext)
    {
        if ((pse->user.dw & ENTRY_SEEN) == 0)
            error(EXIT_BADSC, "Element '%s' not found\n", pse->atc);
        pse->user.dw &= ~ENTRY_SEEN;
    }
}

void t_enum(void)
{
    int i;
    OLECHAR atcName[CWCSTORAGENAME];
    WStorage *pstg, *pstg2;
    WStream *pstm;
    SStrEntry *pse;
    CStrList sl;

    // Create some entries to enumerate
    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    for (i = 0; i<ENUMENTRIES; i++)
    {
	olecsprintf(atcName, STR("Name%d"), rand());
	pse = sl.Add(atcName);
	if (rand()%100 < 50)
	{
	    pse->user.dw = STGTY_STORAGE;
	    pstg->CreateStorage(atcName, STGP(WSTG_READWRITE), 0, 0, &pstg2);
	    pstg2->Unwrap();
	}
	else
	{
	    pse->user.dw = STGTY_STREAM;
	    pstg->CreateStream(atcName, STMP(WSTG_READWRITE), 0, 0, &pstm);
	    pstm->Unwrap();
	}
    }

    WEnumSTATSTG *penm;
    STATSTG stat[2*ENUMENTRIES];
    SCODE sc;

    // Test plain, single element enumeration
    pstg->EnumElements(0, NULL, 0, &penm);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, stat, NULL));
	if (sc == S_FALSE)
	    break;
        elt_check(stat, &sl);
        drtMemFree(stat->pwcsName);

    }
    enum_list_check(&sl);

    ULONG cFound;

    // Test rewind and multiple element enumeration with too many elements
    penm->Reset();
    sc = DfGetScode(penm->Next(ENUMENTRIES*2, stat, &cFound));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    enum_list_check(&sl);

    // Test skip and multiple enumeration with exact number of elements
    penm->Reset();
    penm->Skip(ENUMENTRIES/2);
    sc = DfGetScode(penm->Next(ENUMENTRIES-ENUMENTRIES/2, stat, &cFound));
    if (sc != S_OK)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_OK\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES-ENUMENTRIES/2)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES-ENUMENTRIES/2);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    sc = DfGetScode(penm->Next(1, stat, NULL));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);

    penm->Unwrap();
    pstg->Unwrap();
}

#define SCT_CLASSID IID_ILockBytes
#define SCT_STATEBITS 0xfef1f0f0

void t_stgcopyto(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    // Set some interesting values to make sure they're copied
    pstgFrom->SetClass(SCT_CLASSID);
    pstgFrom->SetStateBits(SCT_STATEBITS, 0xffffffff);

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");
    CreateStructure(pstgTo->GetI(), "dA(dY(sZ),sBs)");

    pstgFrom->CopyTo(0, NULL, NULL, pstgTo);

    VerifyStructure(pstgTo->GetI(),
		    "dA(dB(dC(sA,sB,sC),sCs),dY(sZ),sBs),sAs");
    pstgTo->Stat(&statTo, 0);
    if (!IsEqualCLSID(statTo.clsid, SCT_CLASSID))
        error(EXIT_BADSC, "Class ID mismatch after copy\n");
    if (statTo.grfStateBits != SCT_STATEBITS)
        error(EXIT_BADSC, "State bits mismatch: has %lX vs. %lX\n",
              statTo.grfStateBits, SCT_STATEBITS);

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}

#define MARSHAL_STM STR("Marshal")

static void do_marshal(WStorage *pstg, WStream *pstm)
{
    WStorage *pstgMarshal;
    WStream *pstmMarshal;

    WStgCreateDocfile(MARSHALDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgMarshal);
    pstgMarshal->CreateStream(MARSHAL_STM, STMP(WSTG_READWRITE), 0, 0,
			      &pstmMarshal);
    WCoMarshalInterface(pstmMarshal, IID_IStorage, pstg->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    WCoMarshalInterface(pstmMarshal, IID_IStream, pstm->GetI(), 0, NULL,
                        MSHLFLAGS_NORMAL);
    pstmMarshal->Unwrap();
    pstgMarshal->Commit(0);
    pstgMarshal->Unwrap();
}

static char STREAM_DATA[] = "This is data to be written";

static void do_unmarshal(WStorage **ppstg, WStream **ppstm)
{
    IStorage *pistg;
    WStorage *pstgMarshal;
    WStream *pstmMarshal;
    IStream *pistm;

    WStgOpenStorage(MARSHALDF, NULL, ROOTP(WSTG_READWRITE), NULL, 0,
		    &pstgMarshal);
    pstgMarshal->OpenStream(MARSHAL_STM, NULL, STMP(WSTG_READWRITE), 0,
			    &pstmMarshal);
    WCoUnmarshalInterface(pstmMarshal, IID_IStorage, (void **)&pistg);
    *ppstg = WStorage::Wrap(pistg);
    WCoUnmarshalInterface(pstmMarshal, IID_IStream, (void **)&pistm);
    *ppstm = WStream::Wrap(pistm);
    pstmMarshal->Unwrap();
    pstgMarshal->Unwrap();
}

void t_marshal(void)
{
    WStorage *pstg, *pstgM;
    WStream *pstm, *pstmM;
    ULONG cbRead, cbWritten;
    char buf[sizeof(STREAM_DATA)];

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->CreateStream(STR("Stream"), STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(STREAM_DATA, sizeof(STREAM_DATA), &cbWritten);
    CreateStructure(pstg->GetI(), "dChild(dChild(sStream))");

    do_marshal(pstg, pstm);
    do_unmarshal(&pstgM, &pstmM);
    pstm->Unwrap();
    pstg->Unwrap();

    pstmM->Seek(0, WSTM_SEEK_SET, NULL);
    pstmM->Read(buf, sizeof(STREAM_DATA), &cbRead);
    if (strcmp(buf, STREAM_DATA))
	error(EXIT_BADSC, "Stream data mismatch\n");
    pstmM->Unwrap();

    VerifyStructure(pstgM->GetI(), "dChild(dChild(sStream)),sStream");
    pstgM->Unwrap();
}

void t_stgmisc(void)
{
    WStorage *pstg;
    SCODE sc;
    STATSTG stat;

    // Can't make this call in transacted mode because we want
    // the storage signature to make it into the file right away
    WStgCreateDocfile(DRTDF, WSTG_READWRITE | WSTG_CREATE |
	WSTG_SHARE_EXCLUSIVE, 0, &pstg);
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open file - Should be a storage object\n");
    pstg->Unwrap();
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Closed file - Should be a storage object\n");
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
	    WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->Stat(&stat, 0);
    if (!Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not created\n", stat.pwcsName);
    pstg->Unwrap();
    if (Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted on release\n",
	    stat.pwcsName);
    drtMemFree(stat.pwcsName);
}

void t_ilb(void)
{
    WStorage *pstg;
    SCODE sc;
    //  create an ILockBytes

    ILockBytes *pilb = new CMapBytes();
    if (pilb == NULL)
	error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");

    //  create a storage on the ILockBytes

    WStgCreateDocfileOnILockBytes(pilb,
				  WSTG_READWRITE |
                                  WSTG_CREATE    |
                                  WSTG_SHARE_EXCLUSIVE,
                                  0, &pstg);

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open ILockBytes - Should be a storage object\n");

    //  release the storage

    pstg->Unwrap();

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));

    if (sc == S_FALSE)
	error(EXIT_BADSC, "Released ILockBytes - Should be a storage object\n");

    //  open the ILockBytes

    WStgOpenStorageOnILockBytes(pilb, NULL, ROOTP(WSTG_READWRITE),
				NULL, 0, &pstg);


    //  release the storage

    pstg->Unwrap();

    //  release the ILockBytes

    pilb->Release();
}

void t_movecopy(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    //  create a source
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    //  create a destination
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    pstgTo->Stat(&statTo, 0);

    //  populate source
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");

    //  move a storage
    pstgFrom->MoveElementTo(STR("A"), pstgTo, STR("M"), STGMOVE_MOVE);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs)");

    //  copy a stream
    pstgFrom->MoveElementTo(STR("As"), pstgTo, STR("Bs"), STGMOVE_COPY);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs),sBs");

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\drt\ilb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	ilbmem.cx
//
//  Contents:	ILockBytes memory implementation
//
//  Classes:	CMapBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <memory.h>
#include <ilb.hxx>

#if DBG == 1

DECLARE_INFOLEVEL(ol);

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::CMapBytes, public
//
//  Synopsis:   constructor
//
//  Effects:    initialize member variables
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:      Returns a fully initialized CMapBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CMapBytes::CMapBytes(void)
{
    _ulSize = 0;
    _pv = 0;

    _ulRef = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::QueryInterface, public
//
//  Arguments:	[riid] - interface id
//		[ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Returns:    post reference count
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::AddRef(void)
{
    AtomicInc(&_ulRef);
    return(_ulRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Release, public
//
//  Synopsis:	release reference
//
//  Effects:	deletes object when reference count reaches zero
//
//  Returns:	post reference count
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::Release(void)
{
    AtomicDec(&_ulRef);

    if (_ulRef > 0)
        return(_ulRef);

    free(_pv);

    delete this;

    return(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::ReadAt
//
//  Synopsis:   Reads bytes from memory
//
//  Arguments:  [ulOffset] - byte offset
//		[pv]       - input buffer
//		[cb]       - count of bytes to read
//		[pcbRead]  - count of bytes read
//
//  Returns:    SCODE
//
//  Modifies:   pv, pcbRead
//
//  Derivation: ILockBytes
//
//  History:    30-Oct-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::ReadAt(ULARGE_INTEGER uliOffset,
			       VOID HUGEP *pv,
			       ULONG cb,
			       ULONG *pcbRead)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    if (ulOffset >= _ulSize)
    {
        //  truncate read
        cb = 0;
    }
    else if (cb > (_ulSize - ulOffset))
    {
        //  truncate range that exceeds size
        cb = _ulSize - ulOffset;
    }

    memcpy(pv, (void*)(((BYTE*)_pv) + ulOffset), (size_t) cb);
    *pcbRead = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to memory
//
//  Effects:	May change memory size
//
//  Arguments:	[uliOffset]  - byte offset
//		[pv]         - output buffer
//		[cb]         - count of bytes to write
//		[pcbWritten] - count of bytes written
//
//  Returns:	SCODE
//
//  Modifies:	pcbWritten
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::WriteAt(ULARGE_INTEGER uliOffset,
				VOID const HUGEP *pv,
				ULONG cb,
				ULONG FAR *pcbWritten)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    HRESULT hr;

    if (ulOffset + cb > _ulSize)
    {
        //  increase memory buffer to accomodate write

        ULARGE_INTEGER uliSize;

        ULISetHigh(uliSize, 0);
        ULISetLow(uliSize, ulOffset + cb);
        hr = SetSize(uliSize);

        if (FAILED(DfGetScode(hr)))
        {
            //  don't bother writing partial buffers

            *pcbWritten = 0;
            return hr;
        }
    }

    memcpy((void *)(((BYTE*)_pv) + ulOffset), pv, (size_t) cb);
    *pcbWritten = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Flush, public
//
//  Synopsis:	flushes memory - not appropriate for this implementation
//
//  Effects:	none
//
//  Returns:    SUCCESS_SUCCESS
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Flush(void)
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::GetSize, public
//
//  Synopsis:	gets memory buffer size
//
//  Arguments:	[pcb] - size place holder
//
//  Returns:	SUCCESS_SUCCESS
//
//  Modifies:	pcb
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::GetSize(ULARGE_INTEGER FAR *pcb)
{
    ULISetHigh(*pcb, 0);
    ULISetLow(*pcb, _ulSize);
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size
//
//  Effects:	may change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:	SCODE
//
//  Derivation: ILockBytes
//
//  Algorithm:  realloc the buffer
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::SetSize(ULARGE_INTEGER ulicb)
{
    olAssert(ULIGetHigh(ulicb) == 0);

    ULONG cb = ULIGetLow(ulicb);

    if (cb == _ulSize)
        return NOERROR;

    void *pv = realloc(_pv, (size_t) cb);

    if ((cb > 0) && (pv == NULL))
    {
        //  Unable to allocate memory
        //  Leave current memory and size alone

        return ResultFromScode(E_OUTOFMEMORY);
    }

    _pv = pv;
    _ulSize = cb;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::LockRegion(ULARGE_INTEGER libOffset,
				   ULARGE_INTEGER cb,
				   DWORD dwLockType)
{
    olAssert(0 && "Can't lock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::UnlockRegion(ULARGE_INTEGER libOffset,
				     ULARGE_INTEGER cb,
				     DWORD dwLockType)
{
    olAssert(0 && "Can't unlock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		[grfStatFlag] - status flags
//
//  Returns:	SCODE
//
//  Modifies:	pstatstg
//
//  Derivation: ILockBytes
//
//  History:    06-Nov-92 AlexT     Created
//
//  Notes:	No time stamps
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        static char const abName[] = "Memory";

        HRESULT hr;

        if (FAILED(DfGetScode(hr = drtMemAlloc(sizeof(abName),
                                             (void **) &pstatstg->pwcsName))))
            return hr;

        memcpy(pstatstg->pwcsName, abName, sizeof(abName));
    }

    pstatstg->type = STGTY_LOCKBYTES;

    ULISetHigh(pstatstg->cbSize, 0);
    ULISetLow(pstatstg->cbSize, _ulSize);

    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\cntxlist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       cntxlist.cxx
//
//  Contents:   CContextList implementation
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <cntxlist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CContextList::_Find, public
//
//  Synopsis:   Looks through the list for a matching context
//
//  Arguments:  [ctxid] - Context to look for
//
//  Returns:    Pointer to object or NULL
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CContextList_Find)
#endif

CContext *CContextList::_Find(ContextId ctxid)
{
    CBasedContextPtr pctx;

    olDebugOut((DEB_ITRACE, "In  CContextList::_Find:%p(%lu)\n", this,
                (ULONG)ctxid));
    for (pctx = _pctxHead; pctx; pctx = pctx->pctxNext)
        if (pctx->ctxid != INVALID_CONTEXT_ID &&
            pctx->ctxid == ctxid)
            break;
    olDebugOut((DEB_ITRACE, "Out CContextList::_Find\n"));
    return BP_TO_P(CContext *, pctx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CContextList::Add, public
//
//  Synopsis:   Adds a context to the list
//
//  Arguments:  [pctx] - Context
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CContextList_Add)
#endif

void CContextList::Add(CContext *pctx)
{
    olDebugOut((DEB_ITRACE, "In  CContextList::Add:%p(%p)\n", this, pctx));
    pctx->pctxNext = _pctxHead;
    pctx->ctxid = GetCurrentContextId();
    _pctxHead = P_TO_BP(CBasedContextPtr, pctx);
    olDebugOut((DEB_ITRACE, "Out CContextList::Add\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CContextList::Remove, public
//
//  Synopsis:   Removes a context from the list
//
//  Arguments:  [pctx] - Context
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CContextList_Remove)
#endif

void CContextList::Remove(CContext *pctx)
{
    CBasedContextPtr *ppctx;
#if DBG == 1
    BOOL fFound = FALSE;
#endif

    olDebugOut((DEB_ITRACE, "In  CContextList::Remove:%p(%p)\n", this, pctx));
    for (ppctx = &_pctxHead; *ppctx; ppctx = &(*ppctx)->pctxNext)
        if (*ppctx == pctx)
        {
#if DBG == 1
            fFound = TRUE;
#endif
            *ppctx = pctx->pctxNext;
            break;
        }
    olAssert(fFound == TRUE);
    olDebugOut((DEB_ITRACE, "Out CContextList::Remove\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\dfguid.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	dfguid.cxx
//
//  Contents:	GUID definitions for useful GUIDS
//
//  History:	16-Aug-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <initguid.h>

#ifdef CODESEGMENTS
#pragma code_seg("Marshal_TEXT")
#endif

DEFINE_OLEGUID(CLSID_DfMarshal,			0x0000030b, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\api.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   api.cxx
//
//  Contents:   API entry points
//
//  History:    30-Jun-93   DrewB   Created
//
//----------------------------------------------------------------------------


#include "exphead.cxx"
#pragma hdrstop

#include <propapi.h>
#include <hntfsstg.hxx>
#include <dfentry.hxx>
#include <winefs.h>       // for DuplicateEncryptionInfoFile

SCODE ValidateGrfMode( DWORD grfMode, BOOL fCreateAPI );
HRESULT GetNFFTempName (const WCHAR *pwcsFileName, WCHAR *awcsTmpName);
SCODE ValidateStgOptions (STGOPTIONS * pStgOptions, DWORD stgfmt, BOOL fCreate);
inline SCODE ValidateGrfAttrs (DWORD grfAttrs, DWORD stgfmt)
{
    if (stgfmt != STGFMT_DOCFILE)
    {
        if (grfAttrs != 0)
            return STG_E_INVALIDFLAG;
    }
    else
    {
        if ((grfAttrs & ~FILE_FLAG_NO_BUFFERING) != 0)
            return STG_E_INVALIDFLAG;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfOpenStorageEx
//
//  Synopsis:   Open storage and stream objects
//
//  Arguments:  [pwcsUsersName] - pathanme of the file
//              [fCreateAPI] - create or open
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee    Created
//
//----------------------------------------------------------------------------

STDAPI DfOpenStorageEx (
            const WCHAR* pwcsUsersName,
            BOOL     fCreateAPI,         // create vs open
            DWORD    grfMode,
            DWORD    stgfmt,             // enum
            DWORD    grfAttrs,           // reserved
            STGOPTIONS *pStgOptions,
            void *   reserved,
            REFIID   riid,
            void **  ppObjectOpen)
{
    HRESULT sc = S_OK;
    CSmAllocator *pMalloc = NULL;
    ULONG_PTR uHeapBase;

    DWORD dwFullPathLen;
    WCHAR awcsFullName[_MAX_PATH], *pwcsFile;
    WCHAR awcsTmpPath[_MAX_PATH], *pwcsNameSnapshot = NULL;

    //
    // The ANY and STORAGE formats recursivly call back through here
    // for the correct real format (DOCFILE, NATIVE or FILE).  We only call
    // GetFullPathName on real formats, to avoid redundant calls as we
    // recurse.
    //  This then *requires* that the ANY and STORAGE must recurse (i.e. can't
    // call NFFOpen or NSS directly) because the filename has not been
    // properly prepared.
    //
    // For STGFMT_DOCFILE, let the docfile layer handle name checking
    //
    if(STGFMT_ANY != stgfmt &&
       STGFMT_STORAGE != stgfmt &&
       STGFMT_DOCFILE != stgfmt)
    {
        dwFullPathLen = GetFullPathNameW(pwcsUsersName, _MAX_PATH,
                                         awcsFullName,&pwcsFile);

        if (dwFullPathLen == 0)
        {
            DWORD dwErr = GetLastError();

            // In some circumstances (name == " ", for instance),
            // GetFullPathNameW can return 0 and GetLastError returns 0.
            // We want to return STG_E_INVALIDNAME for these.
            if (dwErr != NOERROR)
            {
                olErr(EH_Err, Win32ErrorToScode(dwErr));
            }
            else
            {
                olErr(EH_Err, STG_E_INVALIDNAME);
            }
        }
        else if (dwFullPathLen > _MAX_PATH)
            olErr(EH_Err, STG_E_PATHNOTFOUND);
    }

    //-----------------------------------------
    //  Switch on STGFMT_
    //      STORAGE, NATIVE, DOCFILE, FILE, ANY
    //
    switch(stgfmt)
    {
    case STGFMT_FILE:
      {
        olChk( NFFOpen( awcsFullName, grfMode, NFFOPEN_NORMAL,
                          fCreateAPI, riid, ppObjectOpen) );

      } // case STGFMT_FILE
    break;

    case STGFMT_ANY:
      {
        DWORD stgfmt=STGFMT_STORAGE;
        //
        // Attempting to CREATE a Storage with STGFMT_ANY is ambiguous,
        // On NTFS either STGFMT_NATIVE or STGFMT_FILE could be appropriate,
        // and is therefore invalid.
        //
        if (fCreateAPI)
            olChk (STG_E_INVALIDPARAMETER);

        //
        //   If IsNffAppropriate() returns S_OK use STGFMT_FILE
        // If it returns STG_E_INVALIDFUNCTION try storage (FAT-FS or Docfile).
        // Any other Error, bubble back to the user
        //
        sc = CNtfsStorage::IsNffAppropriate( pwcsUsersName );
        if( SUCCEEDED( sc ) )
        {
            stgfmt = STGFMT_FILE;
        }
        else
        {
            if( STG_E_INVALIDFUNCTION == sc )
                stgfmt = STGFMT_STORAGE;
            else
                olChk( sc );
        }

        sc = DfOpenStorageEx (pwcsUsersName, fCreateAPI, grfMode, stgfmt,
                                grfAttrs, pStgOptions, reserved,
                                riid, ppObjectOpen);

        olChk(sc);

      } // case STGFMT_ANY;
    break;

    case STGFMT_STORAGE:
    case STGFMT_DOCFILE:  // GetFullPathName has not yet been called.
      {
        IStorage *pstg = NULL;
        ULONG ulSectorSize;

        if( fCreateAPI )
        {
            if (grfAttrs & FILE_ATTRIBUTE_TEMPORARY)  // create temp file
                pwcsUsersName = NULL;
            olChk( DfCreateDocfile (pwcsUsersName,
                NULL, grfMode, NULL,
                pStgOptions ? pStgOptions->ulSectorSize : 512,
                grfAttrs, &pstg));
        }
        else
            olChk( DfOpenDocfile (pwcsUsersName,
                    NULL,
                    NULL,
                    grfMode,
                    NULL,
                    0,
                    &ulSectorSize,
                    grfAttrs,
                    &pstg));

        if( IID_IStorage != riid )
        {
            sc = pstg->QueryInterface( riid, ppObjectOpen );
            pstg->Release();

            if (fCreateAPI && !SUCCEEDED(sc) && pwcsUsersName != NULL)
            {
                DeleteFileW (pwcsUsersName); //delete newly create file
            }
        }
        else
        {
            *ppObjectOpen = pstg;
            if (pStgOptions != NULL && !fCreateAPI)
                pStgOptions->ulSectorSize = ulSectorSize;
        }

        olChk(sc);

      }   // case STGFMT_DOCFILE
    break;

    case STGFMT_NATIVE:
    default:
        olErr (EH_Err, STG_E_INVALIDPARAMETER);
        break;
    }

EH_Err:
    return sc;

};

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateStorageEx, public
//
//  Synopsis:   Creates a storage or stream object
//
//  Arguments:  [pwcsName] - pathname of file
//              [grfMode] - open mode flags
//              [stgfmt] -  storage format
//              [grfAttrs] -  reserved
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee   Created
//
//----------------------------------------------------------------------------

STDAPI StgCreateStorageEx (const WCHAR* pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            STGOPTIONS * pStgOptions,
            void * reserved,
            REFIID riid,
            void ** ppObjectOpen)
{
    HRESULT sc = S_OK;
    WCHAR awcsTmpPath[_MAX_PATH];

    olDebugOut((DEB_TRACE, "In  StgCreateStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    olChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (reserved != NULL)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    olChk( ValidateGrfAttrs (grfAttrs, stgfmt));
    olChk( ValidateGrfMode( grfMode, TRUE ) );
    olChk( VerifyPerms( grfMode, TRUE ) );

    if (pStgOptions != NULL)
        olChk( ValidateStgOptions(pStgOptions, stgfmt, TRUE));

    if (stgfmt == STGFMT_FILE)
    {
      if (pwcsName != NULL)
      {
        olChk (ValidateNameW (pwcsName, _MAX_PATH));
      }
      else
      {
            olChk (GetNFFTempName (pwcsName, awcsTmpPath));
            pwcsName = awcsTmpPath;

            //Add the STGM_CREATE flag so we don't fail with
            //STG_E_FILEALREADYEXISTS when we see that the file already exists
            //later.
            grfMode |= STGM_CREATE;
            grfAttrs |= FILE_ATTRIBUTE_TEMPORARY;
      }
    }

    if (stgfmt == STGFMT_DOCFILE && 
        pStgOptions != NULL &&
        pStgOptions->usVersion >= 2 &&
        pStgOptions->pwcsTemplateFile != NULL)
    {
        DWORD dwAttrs = GetFileAttributes (pStgOptions->pwcsTemplateFile);

        if (dwAttrs == 0xFFFFFFFF)
            olChk (WIN32_SCODE (GetLastError()));

        if (dwAttrs & FILE_ATTRIBUTE_ENCRYPTED)
        {
            DWORD dwErr = DuplicateEncryptionInfoFile(
                pStgOptions->pwcsTemplateFile,
                pwcsName,
                grfMode & STGM_CREATE ? CREATE_ALWAYS : CREATE_NEW,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
            if (dwErr != ERROR_SUCCESS)
                olChk (WIN32_SCODE(dwErr));

            grfAttrs |= FILE_ATTRIBUTE_ENCRYPTED;
        }
    }

    olChk (DfOpenStorageEx (pwcsName, TRUE, grfMode, stgfmt, grfAttrs,
             pStgOptions, reserved, riid, ppObjectOpen));

    olDebugOut((DEB_TRACE, "Out StgCreateStorageEx => %p\n", *ppObjectOpen));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   StgOpenStorageEx
//
//  Synopsis:   Open storage and stream objects
//
//  Arguments:  [pwcsName] - pathanme of the file
//              [grfMode] - open mode flags
//              [grfAttrs] -  reserved
//              [stgfmt] -  storage format
//              [pSecurity] - reserved
//              [pTransaction] - reserved
//              [riid] - GUID of interface pointer to return
//              [ppObjectOpen] - interface pointer to return
//  Returns:    Appropriate status code
//
//  History:    12-Jul-95   HenryLee    Created
//
//----------------------------------------------------------------------------

STDAPI StgOpenStorageEx (const WCHAR *pwcsName,
            DWORD grfMode,
            DWORD stgfmt,               // enum
            DWORD grfAttrs,             // reserved
            STGOPTIONS * pStgOptions,
            void * reserved,
            REFIID riid,
            void ** ppObjectOpen)
{
    HRESULT sc = S_OK;

    olDebugOut((DEB_TRACE, "In  StgOpenStorageEx(%ws, %p, %p, %p, %p)\n",
                pwcsName, grfMode, stgfmt, riid, ppObjectOpen));

    olChk(ValidatePtrBuffer(ppObjectOpen));
    *ppObjectOpen = NULL;

    if (reserved != NULL)
        olErr (EH_Err, STG_E_INVALIDPARAMETER);

    olChk (ValidateNameW (pwcsName, _MAX_PATH));

    olChk( ValidateGrfAttrs (grfAttrs, stgfmt));
    olChk( ValidateGrfMode( grfMode, FALSE ) );
    olChk( VerifyPerms( grfMode, TRUE ) );

    if (pStgOptions != NULL)
        olChk( ValidateStgOptions(pStgOptions, stgfmt, FALSE));

    olChk (DfOpenStorageEx (pwcsName, FALSE, grfMode, stgfmt, grfAttrs,
             pStgOptions, reserved, riid, ppObjectOpen));


    olDebugOut((DEB_TRACE, "Out StgOpenStorageEx => %p\n", *ppObjectOpen));
EH_Err:

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateGrfMode
//
//  Synopsis:   Sanity checking for the grfMode. (all implementations)
//
//  Arguments:  [grfMode] -- grfMode to check
//              [fCreateAPI] -- Called from CreateStorage vs. OpenStorage.
//
//  Returns:    Appropriate status code
//
//  History:    30-Mar-98   BChapman    Created
//
//----------------------------------------------------------------------------


SCODE ValidateGrfMode( DWORD grfMode, BOOL fCreateAPI )
{
    HRESULT sc=S_OK;

    // If there are any invalid bits set (error)
    if( 0 != ( grfMode & ~( STGM_DIRECT           |   //         0
                            STGM_TRANSACTED       |   //    1 0000
                            STGM_SIMPLE           |   //  800 0000
                            STGM_READ             |   //         0
                            STGM_WRITE            |   //         1
                            STGM_READWRITE        |   //         2
                            STGM_SHARE_DENY_NONE  |   //        40
                            STGM_SHARE_DENY_READ  |   //        30
                            STGM_SHARE_DENY_WRITE |   //        20
                            STGM_SHARE_EXCLUSIVE  |   //        10
                            STGM_PRIORITY         |   //    4 0000
                            STGM_DELETEONRELEASE  |   //  400 0000
                            STGM_NOSCRATCH        |   //   10 0000
                            STGM_CREATE           |   //      1000
                            STGM_CONVERT          |   //    2 0000
                            STGM_FAILIFTHERE      |   //         0
                            STGM_DIRECT_SWMR      |
                            STGM_NOSNAPSHOT  ) ) )    //   20 0000
    {
        olErr( EH_Err, STG_E_INVALIDFLAG );
    }

    // If you Create for ReadOnly (error)
    if( fCreateAPI && ( ( grfMode & STGM_RDWR ) == STGM_READ ) )
        olErr( EH_Err, STG_E_INVALIDFLAG );

    // if you Open/Create for Convert And DeleteOnRelease (error)
    if( ( grfMode & ( STGM_DELETEONRELEASE | STGM_CONVERT ) )
                    == ( STGM_DELETEONRELEASE | STGM_CONVERT ) )
    {
        olErr(EH_Err, STG_E_INVALIDFLAG);
    }

    if( grfMode & STGM_SIMPLE )
    {
        if( fCreateAPI )
        {
            // If you Create Simple it must be exactly this way.
            if( grfMode != ( STGM_SIMPLE | STGM_READWRITE |
                             STGM_SHARE_EXCLUSIVE | STGM_CREATE ) )
                olErr( EH_Err, STG_E_INVALIDFLAG );
        }
        else
        {
            // If you Open Simple it must be one of these two ways.
            if( grfMode != (STGM_SIMPLE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE )
             && grfMode != (STGM_SIMPLE | STGM_SHARE_EXCLUSIVE | STGM_READ ) )
                olErr( EH_Err, STG_E_INVALIDFLAG );
        }
    }

    if( !fCreateAPI )
    {
        if (grfMode & STGM_DELETEONRELEASE)
            olErr(EH_Err, STG_E_INVALIDFUNCTION);

        if (grfMode & (STGM_CREATE | STGM_CONVERT))
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
    }
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateStgOptions
//
//  Synopsis:   Sanity checking for the StgOptions
//
//  Arguments:  [pStgOptions] -- options to check
//              [stgfmt] -- intended storage format
//
//  Returns:    Appropriate status code
//
//  History:    30-Mar-98   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE ValidateStgOptions (STGOPTIONS * pStgOptions, DWORD stgfmt, BOOL fCreate)
{
#ifdef LARGE_DOCFILE
    HRESULT sc = S_OK;

    olChk(ValidatePtrBuffer(pStgOptions));
    if (pStgOptions->usVersion > STGOPTIONS_VERSION ||
        pStgOptions->usVersion == 0 ||
        pStgOptions->reserved != 0)

    {
        olErr (EH_Err, STG_E_INVALIDPARAMETER);
    }

    if (fCreate)
    {
        // enable large sector support only for docfiles
        if (pStgOptions->ulSectorSize != 512 && stgfmt != STGFMT_DOCFILE)
        {
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }

        if (pStgOptions->ulSectorSize != 512 &&
            pStgOptions->ulSectorSize != 4096)
        /*  pStgOptions->ulSectorSize != 8192 &&   */
        /*  pStgOptions->ulSectorSize != 16384 &&  */
        /*  pStgOptions->ulSectorSize != 32768)    */
        {
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }

        if (pStgOptions->usVersion >= 2)
        {
            if (stgfmt != STGFMT_DOCFILE)
            {
                olErr (EH_Err, STG_E_INVALIDPARAMETER);
            }
            else if (pStgOptions->pwcsTemplateFile != NULL)
                olChk (ValidatePtrBuffer (pStgOptions->pwcsTemplateFile));
        }
    }
    else
    {
        if (stgfmt != STGFMT_DOCFILE)
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
        if (pStgOptions->usVersion >= 2 && pStgOptions->pwcsTemplateFile !=NULL)
            olErr (EH_Err, STG_E_INVALIDPARAMETER);
    }
EH_Err:
#else
    HRESULT sc = STG_E_INVALIDPARAMETER;
#endif

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member: GetNFFTempName, public
//
//  Synopsis:   returns a filename for temporary NSS files
//
//  Arguments:  [pwcsFileName] - original file name
//              [ppwcsTmpName] - output temporary name
//
//  Returns:    Appropriate status code
//
//  History:    01-Jul-97   HenryLee    Created
//
//----------------------------------------------------------------------------

HRESULT GetNFFTempName (const WCHAR *pwcsFileName, WCHAR *awcsTmpName)
{
    HRESULT sc = S_OK;
    WCHAR awcsDir[_MAX_PATH];
    WCHAR *pwcsFile = NULL;

    //
    // Create a temp file in pwcsFileName's directory
    //
    if (pwcsFileName != NULL)
    {
        if (GetFullPathNameW (pwcsFileName, _MAX_PATH, awcsDir, &pwcsFile) == 0)
        {
            const DWORD dwErr = GetLastError();

            //In some circumstances (name == " ", for instance),
            // GetFullPathNameW can return 0 and GetLastError returns 0.
            // We want to return STG_E_INVALIDNAME for these.

            olErr(EH_Err, (dwErr != NOERROR) ? Win32ErrorToScode(dwErr) :
                                                 STG_E_INVALIDNAME);
        }
        else if (pwcsFile) *pwcsFile = L'\0';
    }
    else
    {
        // Create a temp file for StgCreateDocfile (NULL name)
        //
        // try %temp%
        if(0 == GetTempPath(_MAX_PATH, awcsDir))
        {
            // next try %windir%
            if(0 == GetWindowsDirectory(awcsDir, _MAX_PATH))
            {
                // finally use current directory
                lstrcpyW (awcsDir, L".");
            }

        }
    }

    if (GetTempFileNameW (awcsDir, TEMPFILE_PREFIX, 0, awcsTmpName)==FALSE)
        olErr (EH_Err, Win32ErrorToScode(GetLastError()));

EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\astgconn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:	astgconn.cxx
//
//  Contents:	
//
//  Classes:	
//
//  Functions:	
//
//  History:	03-Apr-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "exphead.cxx"
#pragma hdrstop

#include "astgconn.hxx"
#include <filllkb.hxx>
#include <asyncerr.hxx>


SCODE CAsyncConnection::Init(IConnectionPointContainer *pCPC,
                             CAsyncConnection *pacParent)
{
    SCODE sc = S_OK;
    CConnectionPoint *pcpoint;
    olAssert(_pdacp == NULL);

    if (pacParent)
        _dwAsyncFlags = pacParent->_dwAsyncFlags;
    
    olMem(pcpoint = new CConnectionPoint());
    olChk(pcpoint->Init());
    if ((pacParent) && (_dwAsyncFlags & ASYNC_MODE_COMPATIBILITY))
    {
        pcpoint->SetParent(pacParent->_pdacp);
    }
    else
    {
        pcpoint->SetParent(NULL);
    }

    _pCPC = pCPC;
    _pdacp = pcpoint;
EH_Err:
    return sc;
}


SCODE CAsyncConnection::InitClone(IConnectionPointContainer *pCPC,
                                  CAsyncConnection *pac)
{
    SCODE sc = S_OK;
    CConnectionPoint *pcpoint;
    olAssert(pac != NULL);

    _dwAsyncFlags = pac->_dwAsyncFlags;
    
    olMem(pcpoint = new CConnectionPoint());
    olChk(pcpoint->Init());
    if (_dwAsyncFlags & ASYNC_MODE_COMPATIBILITY)
    {
        IDocfileAsyncConnectionPoint *pdacp;
        if (FAILED(sc = pac->_pdacp->GetParent(&pdacp)))
        {
            delete pcpoint;
            return sc;
        }
        pcpoint->SetParent(pdacp);
    }
    else
    {
        pcpoint->SetParent(NULL);
    }

    _pCPC = pCPC;
    _pdacp = pcpoint;
EH_Err:
    return sc;
}

SCODE CAsyncConnection::InitMarshal(IConnectionPointContainer *pCPC,
                                    DWORD dwAsyncFlags,
                                    IDocfileAsyncConnectionPoint *pdacp)
{
    SCODE sc = S_OK;
    _dwAsyncFlags = dwAsyncFlags;
    
    _pCPC = pCPC;
    _pdacp = pdacp;
    if (_pdacp)
        _pdacp->AddRef();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::~CAsyncConnection, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	03-Apr-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

CAsyncConnection::~CAsyncConnection()
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnection::~CAsyncConnection:%p()\n", this));
    //Note:  _pdacp must be released outside of the tree mutex, which
    //  means we need to extract the pointer and release it elsewhere.
#if 0    
    if (_pdacp != NULL)
    {
        _pdacp->Release();
    }
#endif    
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnection::~CAsyncConnection\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::QueryInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	01-Jan-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    olDebugOut((DEB_TRACE,
                  "In  CAsyncConnection::QueryInterface:%p()\n",
                  this));

    *ppvObj = NULL;

    if ((IsEqualIID(iid, IID_IUnknown)) ||
	(IsEqualIID(iid, IID_IConnectionPoint)))
    {
        *ppvObj = (IConnectionPoint *)this;
        CAsyncConnection::AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    olDebugOut((DEB_TRACE, "Out CAsyncConnection::QueryInterface\n"));
    return ResultFromScode(sc);
}



//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::AddRef, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAsyncConnection::AddRef(void)
{
    ULONG ulRet;
    olDebugOut((DEB_TRACE,
                  "In  CAsyncConnection::AddRef:%p()\n",
                  this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    
    olDebugOut((DEB_TRACE, "Out CAsyncConnection::AddRef\n"));
    return ulRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::Release, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAsyncConnection::Release(void)
{
    LONG lRet;
    olDebugOut((DEB_TRACE,
                  "In  CAsyncConnection::Release:%p()\n",
                  this));

    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);

    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
    { 
        olAssert((lRet > 0) && "Connection point released too many times.");
        lRet = 0;
    
    }
    olDebugOut((DEB_TRACE, "Out CAsyncConnection::Release\n"));
    return (ULONG)lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//              27-Feb-96       SusiA   Moved from Async wrappers 
//
//----------------------------------------------------------------------------
SCODE CAsyncConnection::Notify(SCODE scFailure,
                               ILockBytes *pilb,
                               CPerContext *ppc,
                               CSafeSem *pss)
{
    SCODE sc = S_OK;
    BOOL fAccurate = (scFailure == E_PENDING);
    IFillInfo *pfi = ppc->GetFillInfo();
    ULONG ulWaterMark;
    ULONG ulFailurePoint;

    HANDLE hNotifyEvent;

    if (pfi != NULL)
    {
        pfi->GetFailureInfo(&ulWaterMark,
                            &ulFailurePoint);

        pss->Release();
        
        while (((sc = _pdacp->NotifySinks(ulWaterMark,
                                          ulFailurePoint,
                                          fAccurate,
                                          STG_S_MONITORING)) == STG_S_BLOCK) ||
               (sc == STG_S_MONITORING) ||
               // S_OK is a synonym for STG_S_MONITORING
               (sc == S_OK))
        {	
            DWORD dwFlags;

            // wait for an event to signal
            hNotifyEvent = ppc->GetNotificationEvent();
            WaitForSingleObject(hNotifyEvent, INFINITE);

            pfi->GetTerminationStatus(&dwFlags);
            // client terminated call?
            if (dwFlags == TERMINATED_ABNORMAL)
            {
                return STG_E_INCOMPLETE;
            }
            // download is complete
            else if (dwFlags == TERMINATED_NORMAL)
            {
                return S_OK;
            }
            else
            {
                //Note:  Don't overwrite the failure point we recorded
                //  before, since it may have been changed by some
                //  other thread.
                
                //Don't need to take the critical section here, since
                //we don't care about the current failure point.
                ULONG ulFailurePointCurrent;
                pfi->GetFailureInfo(&ulWaterMark,
                                     &ulFailurePointCurrent);

                // all the data is available now
                if (ulWaterMark >= ulFailurePoint)
                {
                    //We don't care what the return value is, so send
                    //STG_S_BLOCK and all sinks will have fOwner == FALSE
                    _pdacp->NotifySinks(ulWaterMark,
                                        ulFailurePoint,
                                        fAccurate,
                                        STG_S_BLOCK);
                    break;
                }
            }
        }
    }
    
    if ((sc == STG_S_RETRYNOW) ||
        (sc == STG_S_BLOCK) ||
        (sc == STG_S_MONITORING))
    {
        return S_OK;
    }
    else return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::GetConnectionInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::GetConnectionInterface(IID *pIID)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnection::GetConnectionInterface:%p()\n",
                this));

    
    *pIID = IID_IProgressNotify;
          
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::GetConnectionInterface\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::GetConnectionPointContainer, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnection::GetConnectionPointContainer:%p()\n",
                this));

    *ppCPC = _pCPC;
    _pCPC->AddRef();
    
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnection::GetConnectionPointContainer\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::EnumConnections, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::EnumConnections(
    IEnumConnections **ppEnum)
{
    olDebugOut((DEB_ITRACE, "In  CAsyncConnection::EnumConnections:%p()\n", this));
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::EnumConnections\n"));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection:: Advise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::Advise(IUnknown *pUnkSink,
                                      DWORD *pdwCookie)
{
    SCODE sc;
    IProgressNotify *ppnSink;
    
    olDebugOut((DEB_ITRACE, "In  CAsyncConnection::Advise:%p()\n", this));

    olChk(pUnkSink->QueryInterface(IID_IProgressNotify, (void **)&ppnSink));
    sc = _pdacp->AddConnection(ppnSink, pdwCookie);
    ppnSink->Release();
    
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::Advise\n"));
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnection::Unadvise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnection::Unadvise(DWORD dwCookie)
{
    SCODE sc;
    olDebugOut((DEB_ITRACE, "In  CAsyncConnection::Unadvise:%p()\n", this));
    sc = _pdacp->RemoveConnection(dwCookie);
    olDebugOut((DEB_ITRACE, "Out CAsyncConnection::Unadvise\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::EnumConnectionPoints, public
//
//  Synopsis:	Return enumerator on connection points
//
//  Arguments:	[ppEnum] -- Return pointer of enumerator
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnectionContainer::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnectionContainer::EnumConnectionPoints:%p()\n",
                this));
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnectionContainer::EnumConnectionPoints\n"));
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::FindConnectionPoint, public
//
//  Synopsis:	Return a connection point given an IID
//
//  Arguments:	[iid] -- IID to return connection point for
//              [ppCP] -- Return location for pointer
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncConnectionContainer::FindConnectionPoint(
    REFIID iid,
    IConnectionPoint **ppCP)
{
    olDebugOut((DEB_ITRACE,
                "In  CAsyncConnectionContainer::FindConnectionPoint:%p()\n",
                this));

    CAsyncConnection *pcp;
    
    if (IsEqualIID(iid, IID_IProgressNotify))
    {
        pcp = &_cpoint;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    pcp->AddRef();
    *ppCP = pcp;
    
    olDebugOut((DEB_ITRACE,
                "Out CAsyncConnectionContainer::FindConnectionPoint\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::InitConnection, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	10-Apr-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CAsyncConnectionContainer::InitConnection(CAsyncConnection *pacParent)
{
    return _cpoint.Init(this, pacParent);
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncConnectionContainer::InitClone, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	10-Apr-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CAsyncConnectionContainer::InitClone(CAsyncConnection *pac)
{
    return _cpoint.InitClone(this, pac);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\context.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       context.cxx
//
//  Contents:   CPerContext implementation
//
//  History:    14-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <lock.hxx>

//+--------------------------------------------------------------
//
//  Member:     CPerContext::~CPerContext, public
//
//  Synopsis:   Releases internal objects
//
//  History:    14-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CPerContext_1CPerContext)
#endif

CPerContext::~CPerContext(void)
{
#ifndef ASYNC
    //In the ASYNC case, the Close() happens in the Release method.
    if (_plkbBase != NULL)
        Close();
#endif
    if (_pgc)
    {
        _pgc->Remove(this);
        _pgc->Release();
    }

#ifdef ASYNC
    if (_hNotificationEvent != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hNotificationEvent);
        _hNotificationEvent = INVALID_HANDLE_VALUE;
    }
#endif    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPerContext::Close, public
//
//  Synopsis:   Closes the ILockBytes for this context
//
//  History:    09-Apr-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_CPerContext_Close)
#endif

void CPerContext::Close(void)
{
    if (_ulOpenLock && _pgc)
        ReleaseOpen(_plkbOriginal, _pgc->GetOpenLockFlags(), _ulOpenLock);
    _plkbBase->Release();
    _pfstDirty->Release();
    _plkbOriginal->Release();
    _plkbBase = NULL;
    _pfstDirty = NULL;
    _plkbOriginal = NULL;
#ifdef ASYNC
    if (_pfi != NULL)
    {
        _pfi->Release();
        _pfi = NULL;
    }
#endif    
}

#ifdef MULTIHEAP
//+--------------------------------------------------------------
//
//  Method: CSafeMultiHeap::CSafeMultiHeap
//
//  Purpose:    allows restoration of heap with methods calling "delete this"
//
//  History:    29-Nov-95   HenryLee   Created
//
//---------------------------------------------------------------

CSafeMultiHeap::CSafeMultiHeap(CPerContext *ppc)
{
    _pSmAllocator = &g_smAllocator;
    ppc->SetAllocatorState (&_ppcPrev, _pSmAllocator);
}

//+--------------------------------------------------------------
//
//  Method: CSafeMultiHeap::~CSafeMultiHeap
//
//  Purpose:    allows restoration of heap with methods calling "delete this"
//
//  History:    29-Nov-95   HenryLee   Created
//
//---------------------------------------------------------------

CSafeMultiHeap::~CSafeMultiHeap()
{
    if (_ppcPrev != NULL)
        _ppcPrev->SetAllocatorState(NULL, _pSmAllocator);
    else
        _pSmAllocator->SetState(NULL, NULL, 0, NULL, NULL);
}
#endif // MULTIHEAP

#ifdef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CPerContext::InitNotificationEvent, public
//
//  Returns:	Appropriate status code
//
//  History:	17-Apr-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPerContext::InitNotificationEvent(ILockBytes *plkbBase)
{
    SCODE sc;
    TCHAR atcEventName[CONTEXT_MUTEX_NAME_LENGTH];

    olAssert(_pgc != NULL);

    if (_hNotificationEvent != INVALID_HANDLE_VALUE)
    {
        //Already initialized, ok to exit with no error.
        return S_OK;
    }

    if (plkbBase != NULL)
    {
        //We need to check to see if we're _really_ doing async or not.
        IFileLockBytes *pfl;
        if (SUCCEEDED(sc = plkbBase->QueryInterface(IID_IFileLockBytes,
                                                    (void **)&pfl)))
        {
            pfl->Release();
            if (((CFileStream *)plkbBase)->GetContextPointer() == NULL)
            {
                //We aren't doing async, so we don't need a notification event.
                return E_NOINTERFACE;
            }
        }
        else
            return sc;

        _pgc->GetEventName(atcEventName);
        _hNotificationEvent = CreateEventT(NULL, //No security
                                           TRUE,
                                           FALSE,
                                           atcEventName);
        if (_hNotificationEvent == NULL)
        {
            _hNotificationEvent = INVALID_HANDLE_VALUE;
            return Win32ErrorToScode(GetLastError());
        }
    }
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\dfunmfct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dfunmfct.cxx
//
//  Contents:   Implementation of CDocfileUnmarshalFactory
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <dfunmfct.hxx>
#include <marshl.hxx>
#include <logfile.hxx>
#include <expdf.hxx>
#include <expst.hxx>
#if WIN32 >= 300
#include <omarshal.hxx>
#endif

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::new, public
//
//  Synopsis:   Overloaded allocator
//
//  Returns:    Memory block for CDocfileUnmarshalFactory instance
//
//  History:    25-Jun-93       AlexT   Created
//
//  Notes:      We only need one instance of CDocfileUnmarshalFactory.
//              We use a static memory block for that instance (so we
//              can share it).  We don't use a static object because
//              we want to avoid the static construction call when this
//              library is loaded.
//
//---------------------------------------------------------------

BYTE abCDocfileUnmarshalFactory[sizeof(CDocfileUnmarshalFactory)];

inline void *CDocfileUnmarshalFactory::operator new(size_t size)
{
    olAssert(size == sizeof(CDocfileUnmarshalFactory) &&
             aMsg("Class size mismatch"));

    return(abCDocfileUnmarshalFactory);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::delete, public
//
//  Synopsis:   Overloaded deallocator
//
//  History:    25-Jun-93       AlexT   Created
//
//  Notes:      Should never be called
//
//---------------------------------------------------------------

void CDocfileUnmarshalFactory::operator delete(void *pv)
{
    olAssert(!aMsg("CDocfileUnmarshalFactory::operator delete called!"));
}

//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject, public
//
//  Synopsis:   Returns class factory objects for CLSID_DfMarshal
//
//  Arguments:  [clsid] - Class ID of object to get
//              [riid] - IID of interface to get
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    26-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------
#ifdef WIN32
HRESULT Storage32DllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv)
#else
STDAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void FAR* FAR* ppv)
#endif // WIN32
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  DllGetClassObject(clsid, riid, %p)\n", ppv));
    TRY
    {
        olChk(ValidatePtrBuffer(ppv));
        *ppv = NULL;
        olChk(ValidateIid(riid));
#if WIN32 >= 300
        if (IsEqualCLSID(clsid, CLSID_NtHandleMarshal))
        {
            if (!IsEqualIID(riid, IID_IUnknown) &&
                !IsEqualIID(riid, IID_IClassFactory))
                olErr(EH_Err, E_NOINTERFACE);
            *ppv = (IClassFactory *) &sCNtHandleUnmarshalFactory;
        }
        else
#endif
        if (IsEqualCLSID(clsid, CLSID_DfMarshal))
        {
            if (!IsEqualIID(riid, IID_IUnknown) &&
                !IsEqualIID(riid, IID_IClassFactory))
                olErr(EH_Err, E_NOINTERFACE);
            // Multiple inits don't hurt
            *ppv = (IClassFactory *)new CDocfileUnmarshalFactory;
            olAssert(*ppv != NULL && aMsg("new CDocfileUnmarshalFactory failed!"));
        }
        else
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_TRACE, "Out DllGetClassObject => %p\n", *ppv));
 EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CDocfileUnmarshalFactory::AddRef(void)
{
    LONG lRet;

    olLog(("%p::In  CDocfileUnmarshalFactory::AddRef()\n", this));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::AddRef:%p()\n",
                this));
    lRet = _AddRef();
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::AddRef => %ld\n",
                lRet));
    olLog(("%p::Out CDocfileUnmarshalFactory::AddRef().  ret == %ld\n",
           this, lRet));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::Release, public
//
//  Synopsis:   Releases resources
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CDocfileUnmarshalFactory::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CDocfileUnmarshalFactory::Release()\n", this));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::Release:%p()\n",
                this));
    lRet = 0;
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::Release => %ld\n",
                lRet));
    olLog(("%p::Out CDocfileUnmarshalFactory::Release().  ret == %ld\n",
           this, lRet));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::QueryInterface(REFIID riid,
                                                      void **ppv)
{
    SCODE sc;

    olLog(("%p::In  CDocfileUnmarshalFactory::QueryInterface(riid, %p)\n",
           this, ppv));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::QueryInterface:%p("
                "riid, %p)\n", this, ppv));
    TRY
    {
        olChk(Validate());
        olChk(ValidateOutPtrBuffer(ppv));
        *ppv = NULL;
        olChk(ValidateIid(riid));
        if (IsEqualIID(riid, IID_IClassFactory) ||
            IsEqualIID(riid, IID_IUnknown))
        {
            _AddRef();
            *ppv = (IClassFactory *)this;
        }
        else if (IsEqualIID(riid, IID_IMarshal))
        {
            _AddRef();
            *ppv = (IMarshal *)this;
        }
        else
            olErr(EH_Err, E_NOINTERFACE);
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::QueryInterface => "
                "%p\n", *ppv));
EH_Err:
    olLog(("%p::Out CDocfileUnmarshalFactory::QueryInterface().  "
           "*ppv == %p, ret == 0x%lX\n", this, *ppv, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::GetUnmarshalClass(REFIID riid,
                                                         void *pv,
                                                         DWORD dwDestContext,
                                                         LPVOID pvDestContext,
                                                         DWORD mshlflags,
                                                         LPCLSID pcid)
{
    olLog(("%p::INVALID CALL TO CDocfileUnmarshalFactory::GetUnmarshalClass("
           "riid, %p, %lu, %p, %lu, %p)\n", this, pv, dwDestContext,
           pvDestContext, mshlflags, pcid));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [iid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::GetMarshalSizeMax(REFIID iid,
                                                         void *pv,
                                                         DWORD dwDestContext,
                                                         LPVOID pvDestContext,
                                                         DWORD mshlflags,
                                                         LPDWORD pcbSize)
{
    olLog(("%p::INVALID CALL TO CDocfileUnmarshalFactory::GetMarshalSizeMax("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcbSize));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [iid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::MarshalInterface(IStream *pstStm,
                                                        REFIID iid,
                                                        void *pv,
                                                        DWORD dwDestContext,
                                                        LPVOID pvDestContext,
                                                        DWORD mshlflags)
{
    olLog(("%p::INVALID CALL TO CDocfileUnmarshalFactory::MarshalInterface("
           "%p, riid, %p, %lu, %p, %lu).  Context == %lX\n",
           this, pstStm, pv, dwDestContext, pvDestContext, mshlflags,
           (ULONG)GetCurrentContextId()));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::UnmarshalInterface, public
//
//  Synopsis:   Calls through to DfUnmarshalInterface
//
//  Arguments:  [pstStm] - Marshal stream
//              [riid] - IID of object to unmarshal
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    25-Jan-93       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::UnmarshalInterface(IStream *pstStm,
                                                          REFIID iid,
                                                          void **ppv)
{
    return DfUnMarshalInterface(pstStm, iid, TRUE, ppv);
}

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

#ifdef WIN32
STDMETHODIMP CDocfileUnmarshalFactory::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    IID iid;
    DWORD mshlflags;

    olLog(("%p::In  CDocfileUnmarshalFactory::ReleaseMarshalData(%p)\n",
           this, pstStm));

    olChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    if (IsEqualIID(iid, IID_ILockBytes))
    {
        sc = CFileStream::StaticReleaseMarshalData(pstStm, mshlflags);
    }
    else if (IsEqualIID(iid, IID_IStorage))
    {
        sc = CExposedDocFile::StaticReleaseMarshalData(pstStm, mshlflags);
    }
    else if (IsEqualIID(iid, IID_IStream))
    {
        sc = CExposedStream::StaticReleaseMarshalData(pstStm, mshlflags);
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    olLog(("%p::Out CDocfileUnmarshalFactory::ReleaseMarshalData, sc == %lX\n",
           this, sc));
 EH_Err:
    return ResultFromScode(sc);
}
#else
STDMETHODIMP CDocfileUnmarshalFactory::ReleaseMarshalData(IStream *pstStm)
{
    olLog(("%p::Stb CDocfileUnmarshalFactory::ReleaseMarshalData(%p)\n",
           this, pstStm));
    return NOERROR;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::DisconnectObject(DWORD dwReserved)
{
    olLog(("%p::Stb CDocfileUnmarshalFactory::DisconnectObject(%lu)\n",
           this, dwReserved));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::CreateInstance, public
//
//  Synopsis:   Creates an instance of the docfile IMarshal unmarshaller
//
//  Arguments:  [pUnkOuter] -
//              [riid] - IID of object to create
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::CreateInstance(IUnknown *pUnkOuter,
                                                      REFIID riid,
                                                      LPVOID *ppv)
{
    SCODE sc;

    olLog(("%p::In  CDocfileUnmarshalFactory::CreateInstance(%p, riid, %p)\n",
           this, pUnkOuter, ppv));
    olDebugOut((DEB_TRACE, "In  CDocfileUnmarshalFactory::CreateInstance:%p("
                "%p, riid, %p)\n", this, pUnkOuter, ppv));
    TRY
    {
        olChk(Validate());
        olChk(ValidatePtrBuffer(ppv));
        *ppv = NULL;
        olChk(ValidateIid(riid));
        if (pUnkOuter != NULL || !IsEqualIID(riid, IID_IMarshal))
            olErr(EH_Err, STG_E_INVALIDPARAMETER);
        _AddRef();
        *ppv = (IMarshal *)this;
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    olDebugOut((DEB_TRACE, "Out CDocfileUnmarshalFactory::CreateInstance => "
                "%p\n", ppv));
 EH_Err:
    olLog(("%p::Out CDocfileUnmarshalFactory::CreateInstance().  "
           "*ppv == %p, ret == 0x%lX\n", this, *ppv, sc));
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocfileUnmarshalFactory::LockServer, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [fLock] -
//
//  Returns:    Appropriate status code
//
//  History:    25-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CDocfileUnmarshalFactory::LockServer(BOOL fLock)
{
    olLog(("%p::Stb CDocfileUnmarshalFactory::LockServer(%d)\n",
           this, fLock));
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\dllentry.c ===
#include <stdlib.h>
#include <windows.h>

BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

#ifdef HAS_LIBMAIN
BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);
#else
#define LibMain(h, d, l) TRUE
#endif

#if WIN32 == 50
BOOL fWin32s = FALSE;
extern void DfDebug(ULONG, ULONG);
#endif

int __cdecl atexit(void (__cdecl *pfn)(void))
{
    // Do nothing
    return 0;
}

BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRc;
//    char msg[80];
#if WIN32 == 50
    DWORD dwVer;
#endif

    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
//        DebugBreak();
#if DBG == 1 && WIN32 == 50
	dwVer = GetVersion();
	if (dwVer & 0x80000000)
	{
	    ULONG uOLevel;

	    fWin32s = TRUE;
	    uOLevel = (ULONG)GetPrivateProfileIntA("Win32sDbg", "docfile",
			        		   0, "system.ini");
	    DfDebug(uOLevel, uOLevel);
        }
#endif
        break;
    }
    if (fRc = _CRT_INIT(hDll, dwReason, lpReserved))
        fRc = LibMain(hDll, dwReason, lpReserved);
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
//        wsprintfA(msg, "Storag32 returning %d on attach\r\n", fRc);
//        OutputDebugStringA(msg);
        break;
    }
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\docfile.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       docfile.c
//
//  Contents:   DocFile root functions (Stg* functions)
//
//  History:    10-Dec-91       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <rpubdf.hxx>
#include <expdf.hxx>
#include <expst.hxx>
#include <dfentry.hxx>
#include <logfile.hxx>
#include <dirfunc.hxx>
#include <wdocfile.hxx>

#include <ole2sp.h>
#include <ole2com.h>
#include <hkole32.h>

#ifdef COORD
#include <resource.hxx>
#endif

#ifdef _MAC
#include <ole2sp.h>
#endif


HRESULT IsNffAppropriate(const LPCWSTR pwcsName);

//+--------------------------------------------------------------
//
//  Function:   DfFromLB, private
//
//  Synopsis:   Starts a root Docfile on an ILockBytes
//
//  Arguments:  [plst] - LStream to start on
//              [df] - Permissions
//              [dwStartFlags] - Startup flags
//              [snbExclude] - Partial instantiation list
//              [ppdfExp] - DocFile return
//              [pcid] - Class ID return for opens
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfExp]
//              [pcid]
//
//  History:    19-Mar-92       DrewB   Created
//              18-May-93       AlexT   Added pMalloc
//
//  Algorithm:  Create and initialize a root transaction level
//              Create and initialize a public docfile
//              Create and initialize an exposed docfile
//
//---------------------------------------------------------------


#ifdef COORD
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               ITransaction *pTransaction,
               CExposedDocFile **ppdfExp,
               CLSID *pcid)
#else
SCODE DfFromLB(CPerContext *ppc,
               ILockBytes *plst,
               DFLAGS df,
               DWORD dwStartFlags,
               SNBW snbExclude,
               CExposedDocFile **ppdfExp,
               CLSID *pcid)
#endif //COORD
{
    SCODE sc, scConv;
    CRootPubDocFile *prpdf;

#ifdef COORD
    CPubDocFile *ppubdf;
    CPubDocFile *ppubReturn;
    CWrappedDocFile *pwdf;
    CDocfileResource *pdfr = NULL;
#endif

    CDFBasis *pdfb;
    ULONG ulOpenLock;
    IMalloc *pMalloc = ppc->GetMalloc();

    ppc->AddRef();

    olDebugOut((DEB_ITRACE, "In  DfFromLB(%p, %p, %X, %lX, %p, %p, %p)\n",
                pMalloc, plst, df, dwStartFlags, snbExclude, ppdfExp, pcid));

    //Take the mutex in the CPerContext, in case there is an IFillLockBytes
    //  trying to write data while we're trying to open.
    CSafeSem _ss(ppc);
    olChk(_ss.Take());

#ifdef CHECKCID
    ULONG cbRead;
    olChk(plst->ReadAt(CBCLSIDOFFSET, pcid, sizeof(CLSID), &cbRead));
    if (cbRead != sizeof(CLSID))
        olErr(EH_Err, STG_E_INVALIDHEADER);
    if (!REFCLSIDEQ(*pcid, DOCFILE_CLASSID))
        olErr(EH_Err, STG_E_INVALIDHEADER);
#endif

#ifdef COORD

    if (pTransaction != NULL)
    {
        //If we've passed in an ITransaction pointer, it indicates that we
        //   want to open or create this docfile as part of a coordinated
        //   transaction.  First, we need to find out if there's a docfile
        //   resource manager for that transaction currently existing in
        //   this process.
        //First, check if we're opening transacted.  If we aren't, then we're
        //   not going to allow this docfile to participate in the
        //   transaction.

        if (!P_TRANSACTED(df))
        {
            //Is this the right error?
            olErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
        XACTTRANSINFO xti;
        olChk(pTransaction->GetTransactionInfo(&xti));

        EnterCriticalSection(&g_csResourceList);
        CDocfileResource *pdfrTemp = g_dfrHead.GetNext();

        while (pdfrTemp != NULL)
        {
            if (IsEqualBOID(pdfrTemp->GetUOW(), xti.uow))
            {
                //Direct hit.
                pdfr = pdfrTemp;
                break;
            }
            pdfrTemp = pdfrTemp->GetNext();
        }

        if (pdfr == NULL)
        {
            ITransactionCoordinator *ptc;
            //If there isn't, we need to create one.

            olChkTo(EH_cs, pTransaction->QueryInterface(
                IID_ITransactionCoordinator,
                (void **)&ptc));

            pdfr = new CDocfileResource;
            if (pdfr == NULL)
            {
                ptc->Release();
                olErr(EH_cs, STG_E_INSUFFICIENTMEMORY);
            }
            sc = pdfr->Enlist(ptc);
            ptc->Release();
            if (FAILED(sc))
            {
                pdfr->Release();;
                olErr(EH_cs, sc);
            }

            //Add to list.
            pdfr->SetNext(g_dfrHead.GetNext());
            if (g_dfrHead.GetNext() != NULL)
                g_dfrHead.GetNext()->SetPrev(pdfr);
            g_dfrHead.SetNext(pdfr);
            pdfr->SetPrev(&g_dfrHead);
        }
        else
        {
            //We'll release this reference below.
            pdfr->AddRef();
        }
        LeaveCriticalSection(&g_csResourceList);
    }
#endif

    // Make root
    olMem(prpdf = new (pMalloc) CRootPubDocFile(pMalloc));
    olChkTo(EH_prpdf, scConv = prpdf->InitRoot(plst, dwStartFlags, df,
                                               snbExclude, &pdfb,
                                               &ulOpenLock,
                                               ppc->GetGlobal()));

#ifdef COORD
    if (pTransaction != NULL)
    {
        //Set up a fake transaction level at the root.  A pointer to
        //  this will be held by the resource manager.  The storage pointer
        //  that is passed back to the caller will be a pointer to the
        //  transaction level (non-root) below it.  This will allow the
        //  client to write and commit as many times as desired without
        //  the changes ever actually hitting the file.

        CDfName dfnNull;  //  auto-initialized to 0
        WCHAR wcZero = 0;
        dfnNull.Set(2, (BYTE *)&wcZero);

        olMemTo(EH_prpdfInit, pwdf = new (pMalloc) CWrappedDocFile(
                &dfnNull,
                ROOT_LUID,
                (df & ~DF_INDEPENDENT),
                pdfb,
                NULL));

        olChkTo(EH_pwdf, pwdf->Init(prpdf->GetDF()));
        prpdf->GetDF()->AddRef();

        olMemTo(EH_pwdfInit, ppubdf = new (pMalloc) CPubDocFile(
            prpdf,
            pwdf,
            (df | DF_COORD) & ~DF_INDEPENDENT,
            ROOT_LUID,
            pdfb,
            &dfnNull,
            2,
            pdfb->GetBaseMultiStream()));

        olChkTo(EH_ppubdf, pwdf->InitPub(ppubdf));
        ppubdf->AddXSMember(NULL, pwdf, ROOT_LUID);

        ppubReturn = ppubdf;
    }
    else
    {
        ppubReturn = prpdf;
    }
#endif //COORD


    ppc->SetILBInfo(pdfb->GetBase(),
                    pdfb->GetDirty(),
                    pdfb->GetOriginal(),
                    ulOpenLock);
    ppc->SetLockInfo(ulOpenLock != 0, df);
    // Make exposed

#ifdef COORD
    //We don't need to AddRef ppc since it starts with a refcount of 1.
    olMemTo(EH_ppcInit,
            *ppdfExp = new (pMalloc) CExposedDocFile(
                ppubReturn,
                pdfb,
                ppc));

    if (pTransaction != NULL)
    {
        CExposedDocFile *pexpdf;

        olMemTo(EH_ppcInit, pexpdf = new (pMalloc) CExposedDocFile(
            prpdf,
            pdfb,
            ppc));
        ppc->AddRef();

        sc = pdfr->Join(pexpdf);
        if (FAILED(sc))
        {
            pexpdf->Release();
            olErr(EH_ppcInit, sc);
        }
        pdfr->Release();
    }
#else
    olMemTo(EH_ppcInit,
            *ppdfExp = new (pMalloc) CExposedDocFile(
                prpdf,
                pdfb,
                ppc));
#endif //COORD

    olDebugOut((DEB_ITRACE, "Out DfFromLB => %p\n", *ppdfExp));
    return scConv;

 EH_ppcInit:
    // The context will release this but we want to keep it around
    // so take a reference
    pdfb->GetOriginal()->AddRef();
    pdfb->GetBase()->AddRef();
    pdfb->GetDirty()->AddRef();
    if (ulOpenLock > 0 && ppc->GetGlobal() == NULL)
    {
        //  The global context doesn't exist, so we need to release
        //  the open lock explicitly.

        ReleaseOpen(pdfb->GetOriginal(), df, ulOpenLock);
    }

    //  The open lock has now been released (either explicitly or by ppc)
    ulOpenLock = 0;
#ifdef COORD
EH_ppubdf:
    if (pTransaction != NULL)
    {
        ppubdf->vRelease();
    }
EH_pwdfInit:
    if (pTransaction != NULL)
    {
        prpdf->GetDF()->Release();
    }
EH_pwdf:
    if (pTransaction != NULL)
    {
        pwdf->Release();
    }
 EH_prpdfInit:
#endif //COORD
    pdfb->GetDirty()->Release();
    pdfb->GetBase()->Release();
    if (ulOpenLock > 0)
        ReleaseOpen(pdfb->GetOriginal(), df, ulOpenLock);

    pdfb->SetDirty(NULL);
    pdfb->SetBase(NULL);

 EH_prpdf:
    prpdf->ReleaseLocks(plst);
    prpdf->vRelease();
#ifdef COORD
    if ((pTransaction != NULL) && (pdfr != NULL))
    {
        pdfr->Release();
    }
    goto EH_Err;
 EH_cs:
    LeaveCriticalSection(&g_csResourceList);
#endif

 EH_Err:
    ppc->Release();
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   DfFromName, private
//
//  Synopsis:   Starts a root DocFile from a base name
//
//  Arguments:  [pwcsName] - Name
//              [df] - Permissions
//              [dwStartFlags] - Startup flags
//              [snbExclude] - Partial instantiation list
//              [ppdfExp] - Docfile return
//              [pcid] - Class ID return for opens
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfExp]
//              [pcid]
//
//  History:    19-Mar-92       DrewB   Created
//              18-May-93       AlexT   Add per file allocator
//
//  Notes:      [pwcsName] is treated as unsafe memory
//
//---------------------------------------------------------------


// This set of root startup flags is handled by the multistream
// and doesn't need to be set for filestreams
#define RSF_MSF (RSF_CONVERT | RSF_TRUNCATE | RSF_ENCRYPTED)

#ifdef COORD
SCODE DfFromName(WCHAR const *pwcsName,
                 DFLAGS df,
                 DWORD dwStartFlags,
                 SNBW snbExclude,
                 ITransaction *pTransaction,
                 CExposedDocFile **ppdfExp,
                 ULONG *pulSectorSize,
                 CLSID *pcid)
#else
SCODE DfFromName(WCHAR const *pwcsName,
                 DFLAGS df,
                 DWORD dwStartFlags,
                 SNBW snbExclude,
                 CExposedDocFile **ppdfExp,
                 ULONG *pulSectorSize,
                 CLSID *pcid)
#endif
{
    IMalloc *pMalloc;
    CFileStream *plst;
    CPerContext *ppc;
    CFileStream *plst2 = NULL;
    SCODE sc;
    CMSFHeader *phdr = NULL;
    BOOL fCreated;

    olDebugOut((DEB_ITRACE, "In  DfFromName(%ws, %lX, %lX, %p, %p, %p)\n",
                pwcsName, df, dwStartFlags, snbExclude, ppdfExp, pcid));

    olHChk(DfCreateSharedAllocator(&pMalloc, df & DF_LARGE));

    // Start an ILockBytes from the named file
    olMemTo(EH_Malloc, plst = new (pMalloc) CFileStream(pMalloc));
    olChkTo(EH_plst, plst->InitGlobal(dwStartFlags & ~RSF_MSF, df));
    sc = plst->InitFile(pwcsName);
    fCreated = SUCCEEDED(sc) &&
        ((dwStartFlags & RSF_CREATE) || pwcsName == NULL);
    if (sc == STG_E_FILEALREADYEXISTS && (dwStartFlags & RSF_MSF))
    {
        plst->SetStartFlags(dwStartFlags & ~(RSF_MSF | RSF_CREATE));
        sc = plst->InitFile(pwcsName);
    }
    olChkTo(EH_plst, sc);

    if (!(dwStartFlags & RSF_CREATE))
    {
        ULONG cbDiskSector =  (dwStartFlags & RSF_NO_BUFFERING) ?
                               plst->GetSectorSize() : HEADERSIZE;
        olMemTo (EH_plstInit, phdr = (CMSFHeader*) TaskMemAlloc (cbDiskSector));
        ULARGE_INTEGER ulOffset = {0,0};
        ULONG ulRead;

        olChkTo (EH_plstInit, plst->ReadAt(ulOffset,phdr,cbDiskSector,&ulRead));
        if (ulRead < sizeof(CMSFHeaderData))
            olErr (EH_plstInit, STG_E_FILEALREADYEXISTS);
        sc = phdr->Validate();
        if (sc == STG_E_INVALIDHEADER)
            sc = STG_E_FILEALREADYEXISTS;
        olChkTo (EH_plstInit, sc);
        if (phdr->GetSectorShift() > SECTORSHIFT512)
        {
            IMalloc *pMalloc2 = NULL;
            CGlobalFileStream *pgfst = plst->GetGlobal();
#ifdef MULTIHEAP
            CSharedMemoryBlock *psmb;
            BYTE *pbBase;
            ULONG ulHeapName;
#endif

            df |= DF_LARGE;   // reallocate objects from task memory
            dwStartFlags |= (phdr->GetSectorShift() <<12) & RSF_SECTORSIZE_MASK;
            // create and initialize the task allocator
#ifdef MULTIHEAP
            g_smAllocator.GetState (&psmb, &pbBase, &ulHeapName);
#endif
            olChkTo(EH_taskmem, DfCreateSharedAllocator(&pMalloc2, TRUE));
            pMalloc->Release();
            pMalloc = pMalloc2;

            olMemTo(EH_taskmem, plst2 = new (pMalloc2) CFileStream(pMalloc2));
            olChkTo(EH_taskmem, plst2->InitGlobal(dwStartFlags & ~RSF_MSF, df));

            plst2->InitFromFileStream (plst);
            plst2->GetGlobal()->InitFromGlobalFileStream (pgfst);

#ifdef MULTIHEAP
            g_smAllocator.SetState (psmb, pbBase, ulHeapName, NULL, NULL);
            g_smAllocator.Uninit();  // unmap newly created heap
            g_smAllocator.SetState (NULL, NULL, 0, NULL, NULL);
#endif
            plst = plst2;  // CFileStream was destroyed by Uninit

        }
        TaskMemFree ((BYTE*)phdr);
        phdr = NULL;
    }

    //Create the per context
    olMemTo(EH_plstInit, ppc = new (pMalloc) CPerContext(pMalloc));
    olChkTo(EH_ppc, ppc->InitNewContext());

    {
#ifdef MULTIHEAP
        CSafeMultiHeap smh(ppc);
#endif

    // Start up the docfile
#ifdef COORD
        sc = DfFromLB(ppc, plst, df, dwStartFlags,
                      snbExclude, pTransaction,
                      ppdfExp, pcid);
#else
        sc = DfFromLB(ppc, plst, df, dwStartFlags,
                      snbExclude, ppdfExp, pcid);
#endif //COORD

    //Either DfFromLB has AddRef'ed the per context or it has failed.
    //Either way we want to release our reference here.
        LONG lRet;
        lRet = ppc->Release();
#ifdef MULTIHEAP
        olAssert((FAILED(sc)) || (lRet != 0));
#endif
        if (FAILED(sc))
        {
            if (fCreated || ((dwStartFlags & RSF_CREATE) && !P_TRANSACTED(df)))
                plst->Delete();
            plst->Release();
#ifdef MULTIHEAP
            if (lRet == 0)
            {
                g_smAllocator.Uninit();
            }
#endif
        }
        else if (pulSectorSize != NULL)
        {
            *pulSectorSize = (*ppdfExp)->GetPub()->GetBaseMS()->GetSectorSize();
        }
    }
    pMalloc->Release();

    olDebugOut((DEB_ITRACE, "Out DfFromName => %p\n", *ppdfExp));
    return sc;
EH_ppc:
    delete ppc;
EH_taskmem:
    if (plst2) plst2->Release();
EH_plstInit:
    if (fCreated || ((dwStartFlags & RSF_CREATE) && !P_TRANSACTED(df)))
        plst->Delete();
EH_plst:
    plst->Release();
EH_Malloc:
#ifdef MULTIHEAP
    g_smAllocator.Uninit();  // unmap newly created heap
#endif
    pMalloc->Release();
EH_Err:
    if (phdr != NULL)
        TaskMemFree ((BYTE*)phdr);
    return sc;
}


//+--------------------------------------------------------------
//
//  Function:   DfCreateDocfile, public
//
//  Synopsis:   Creates a root Docfile on a file
//
//  Arguments:  [pwcsName] - Filename
//              [grfMode] - Permissions
//              [reserved] - security attributes
//              [grfAttrs] - Win32 CreateFile attributes
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDAPI DfCreateDocfile (WCHAR const *pwcsName,
#ifdef COORD
                        ITransaction *pTransaction,
#else
                        void *pTransaction,
#endif
                        DWORD grfMode,
#if WIN32 == 300
                        LPSECURITY_ATTRIBUTES reserved,
#else
                        LPSTGSECURITY reserved,
#endif
                        ULONG ulSectorSize,
                        DWORD grfAttrs,
                        IStorage **ppstgOpen)
{
    SafeCExposedDocFile pdfExp;
    SCODE sc;
    DFLAGS df;
    DWORD dwSectorFlag = 0;

    OLETRACEIN((API_StgCreateDocfile,
        PARAMFMT("pwcsName= %ws, grfMode= %x, reserved=%p, ppstgOpen= %p"),
                pwcsName, grfMode, reserved, ppstgOpen));

    olLog(("--------::In  StgCreateDocFile(%ws, %lX, %lu, %p)\n",
           pwcsName, grfMode, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgCreateDocfile(%ws, %lX, %lu, %p)\n",
               pwcsName, grfMode, reserved, ppstgOpen));

    olAssert(sizeof(LPSTGSECURITY) == sizeof(DWORD));

    olChkTo(EH_BadPtr, ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    if (pwcsName)
        olChk(ValidateNameW(pwcsName, _MAX_PATH));

    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);

    if (grfMode & STGM_SIMPLE)
    {
        if (pTransaction != NULL)
        {
            olErr(EH_Err, STG_E_INVALIDFLAG);
        }
        if (ulSectorSize > 512)
            olErr (EH_Err, STG_E_INVALIDPARAMETER);

        sc = DfCreateSimpDocfile(pwcsName, grfMode, 0, ppstgOpen);
        goto EH_Err;
    }

    olChk(VerifyPerms(grfMode, TRUE));
    if ((grfMode & STGM_RDWR) == STGM_READ ||
        (grfMode & (STGM_DELETEONRELEASE | STGM_CONVERT)) ==
        (STGM_DELETEONRELEASE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);

    df = ModeToDFlags(grfMode);
    if ((grfMode & (STGM_TRANSACTED | STGM_CONVERT)) ==
        (STGM_TRANSACTED | STGM_CONVERT))
        df |= DF_INDEPENDENT;
    if (ulSectorSize > 512)
    {
        df |= DF_LARGE;
        switch (ulSectorSize)
        {
            case 4096 : dwSectorFlag = RSF_SECTORSIZE4K; break;
            case 8192 : dwSectorFlag = RSF_SECTORSIZE8K; break;
            case 16384 : dwSectorFlag = RSF_SECTORSIZE16K; break;
            case 32768 : dwSectorFlag = RSF_SECTORSIZE32K; break;
            default : olErr (EH_Err, STG_E_INVALIDPARAMETER);
        }
    }
    else if (ulSectorSize != 0 && ulSectorSize != 512)
             olErr (EH_Err, STG_E_INVALIDPARAMETER);

#if WIN32 != 200
    //
    // When we create over NFF files, delete them first.
    // except when we want to preserve encryption information
    //
    if( (STGM_CREATE & grfMode) && !(FILE_ATTRIBUTE_ENCRYPTED & grfAttrs))
    {
        if( SUCCEEDED( IsNffAppropriate( pwcsName ) ) )
        {
            if(FALSE == DeleteFileW( pwcsName ) )
            {
                DWORD dwErr = GetLastError();
                if( dwErr != ERROR_FILE_NOT_FOUND &&
                    dwErr != ERROR_PATH_NOT_FOUND )
                {
                    olErr( EH_Err, Win32ErrorToScode( dwErr ) );
                }
            }
        }
    }
#endif // _CHICAGO_

    DfInitSharedMemBase();
#ifdef COORD
    olChk(sc = DfFromName(pwcsName, df,
                          RSF_CREATE |
                          ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                          ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0) |
                          ((grfMode & STGM_DELETEONRELEASE) ?
                           RSF_DELETEONRELEASE : 0) |
                          (dwSectorFlag) |
                          ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                            RSF_NO_BUFFERING : 0) |
                          ((grfAttrs & FILE_ATTRIBUTE_ENCRYPTED) ?
                            RSF_ENCRYPTED : 0),
                          NULL, pTransaction, &pdfExp, NULL, NULL));
#else
    olChk(sc = DfFromName(pwcsName, df,
                          RSF_CREATE |
                          ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                          ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0) |
                          ((grfMode & STGM_DELETEONRELEASE) ?
                           RSF_DELETEONRELEASE : 0) |
                          (dwSectorFlag) |
                          ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                            RSF_NO_BUFFERING : 0) |
                          ((grfAttrs & FILE_ATTRIBUTE_ENCRYPTED) ?
                            RSF_ENCRYPTED : 0),
                          NULL, &pdfExp, NULL, NULL));
#endif //COORD

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

EH_Err:
    olDebugOut((DEB_TRACE, "Out StgCreateDocfile => %p, ret == %lx\n",
         *ppstgOpen, sc));
    olLog(("--------::Out StgCreateDocFile().  *ppstgOpen == %p, ret == %lx\n",
           *ppstgOpen, sc));

    OLETRACEOUT(( API_StgCreateDocfile, _OLERETURN(sc)));

EH_BadPtr:
    FreeLogFile();
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfile, public
//
//  Synopsis:   Creates a root Docfile on a file
//
//  Arguments:  [pwcsName] - Filename
//              [grfMode] - Permissions
//              [reserved] - security attributes
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgCreateDocfile(WCHAR const *pwcsName,
                        DWORD grfMode,
                        LPSTGSECURITY reserved,
                        IStorage **ppstgOpen)
{
    return DfCreateDocfile(pwcsName, NULL, grfMode, reserved, 0, 0, ppstgOpen);
}

//+--------------------------------------------------------------
//
//  Function:   StgCreateDocfileOnILockBytes, public
//
//  Synopsis:   Creates a root Docfile on an lstream
//
//  Arguments:  [plkbyt] - LStream
//              [grfMode] - Permissions
//              [reserved] - Unused
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDAPI StgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
                                    DWORD grfMode,
                                    DWORD reserved,
                                    IStorage **ppstgOpen)
{
    IMalloc *pMalloc;
    CPerContext *ppc;
    SafeCExposedDocFile pdfExp;
    SCODE sc;
    DFLAGS df;
#ifdef MULTIHEAP
    CPerContext pcSharedMemory (NULL);
#endif

    OLETRACEIN((API_StgCreateDocfileOnILockBytes,
                PARAMFMT("plkbyt= %p, grfMode= %x, reserved= %ud, ppstgOpen= %p"),
                plkbyt, grfMode, reserved, ppstgOpen));

    olLog(("--------::In  StgCreateDocFileOnILockBytes(%p, %lX, %lu, %p)\n",
           plkbyt, grfMode, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgCreateDocfileOnILockBytes("
                "%p, %lX, %lu, %p)\n",
                plkbyt, grfMode, reserved, ppstgOpen));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    olChk(ValidateInterface(plkbyt, IID_ILockBytes));

    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    if ((grfMode & (STGM_CREATE | STGM_CONVERT)) == 0)
        olErr(EH_Err, STG_E_FILEALREADYEXISTS);
    olChk(VerifyPerms(grfMode, TRUE));
    if (grfMode & STGM_DELETEONRELEASE)
        olErr(EH_Err, STG_E_INVALIDFUNCTION);
    df = ModeToDFlags(grfMode);
    if ((grfMode & (STGM_TRANSACTED | STGM_CONVERT)) ==
        (STGM_TRANSACTED | STGM_CONVERT))
        df |= DF_INDEPENDENT;

    DfInitSharedMemBase();
    olHChk(DfCreateSharedAllocator(&pMalloc, TRUE));
#ifdef MULTIHEAP
    // Because a custom ILockbytes can call back into storage code,
    // possibly using another shared heap, we need a temporary
    // owner until the real CPerContext is allocated
    // new stack frame for CSafeMultiHeap constructor/destructor
    {
        pcSharedMemory.GetThreadAllocatorState();
        CSafeMultiHeap smh(&pcSharedMemory);
#endif

    //Create the per context
    olMem(ppc = new (pMalloc) CPerContext(pMalloc));
    olChkTo(EH_ppc, ppc->InitNewContext());

#ifdef COORD
    sc = DfFromLB(ppc, plkbyt, df,
                  RSF_CREATE |
                  ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                  ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0),
                  NULL, NULL, &pdfExp, NULL);
#else
    sc = DfFromLB(ppc, plkbyt, df,
                  RSF_CREATE |
                  ((grfMode & STGM_CREATE) ? RSF_TRUNCATE : 0) |
                  ((grfMode & STGM_CONVERT) ? RSF_CONVERT : 0),
                  NULL, &pdfExp, NULL);
#endif //COORD

    pMalloc->Release();

    //Either DfFromLB has AddRef'ed the per context or it has failed.
    //Either way we want to release our reference here.
    ppc->Release();

    olChkTo(EH_Truncate, sc);

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

    //  Success;  since we hold on to the ILockBytes interface,
    //  we must take a reference to it.
    plkbyt->AddRef();

    olDebugOut((DEB_TRACE, "Out StgCreateDocfileOnILockBytes => %p\n",
                *ppstgOpen));
#ifdef MULTIHEAP
    }
#endif
 EH_Err:
    OLETRACEOUT((API_StgCreateDocfileOnILockBytes, ResultFromScode(sc)));

    olLog(("--------::Out StgCreateDocFileOnILockBytes().  "
           "*ppstgOpen == %p, ret == %lx\n", *ppstgOpen, sc));
    FreeLogFile();
    return ResultFromScode(sc);

 EH_ppc:
    delete ppc;
    goto EH_Err;

 EH_Truncate:
    if ((grfMode & STGM_CREATE) && (grfMode & STGM_TRANSACTED) == 0)
    {
        ULARGE_INTEGER ulSize;

        ULISet32(ulSize, 0);
        olHVerSucc(plkbyt->SetSize(ulSize));
    }
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Function:   DfOpenDocfile, public
//
//  Synopsis:   Instantiates a root Docfile from a file,
//              converting if necessary
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority mode reopen IStorage
//              [grfMode] - Permissions
//              [snbExclude] - Exclusions for priority reopen
//              [reserved] - security attributes
//              [grfAttrs] - Win32 CreateFile attributes
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI DfOpenDocfile(OLECHAR const *pwcsName,
#ifdef COORD
                     ITransaction *pTransaction,
#else
                     void *pTransaction,
#endif
                     IStorage *pstgPriority,
                     DWORD grfMode,
                     SNB snbExclude,
                     LPSTGSECURITY reserved,
                     ULONG *pulSectorSize,
                     DWORD grfAttrs,
                     IStorage **ppstgOpen)
{
    SafeCExposedDocFile pdfExp;
    SCODE sc;
    WCHAR awcName[_MAX_PATH];
    CLSID cid;

    OLETRACEIN((API_StgOpenStorage,
         PARAMFMT("pstgPriority= %p, grfMode= %x, snbExclude= %p, reserved= %p, ppStgOpen= %p"),
         pstgPriority, grfMode,snbExclude, reserved, ppstgOpen));

    olLog(("--------::In  StgOpenStorage(%ws, %p, %lX, %p, %lu, %p)\n",
           pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgOpenStorage("
                "%ws, %p, %lX, %p, %lu, %p)\n", pwcsName, pstgPriority,
                grfMode, snbExclude, reserved, ppstgOpen));

    olAssert(sizeof(LPSTGSECURITY) == sizeof(DWORD));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    if (pstgPriority == NULL)
    {
        olChk(ValidateNameW(pwcsName, _MAX_PATH));
        lstrcpyW(awcName, pwcsName);
    }
    if (pstgPriority)
    {
        STATSTG stat;

        olChk(ValidateInterface(pstgPriority, IID_IStorage));
        olHChk(pstgPriority->Stat(&stat, 0));
        if (lstrlenW (stat.pwcsName) > _MAX_PATH)
            olErr (EH_Err, STG_E_INVALIDNAME);
        lstrcpyW(awcName, stat.pwcsName);
        TaskMemFree(stat.pwcsName);
    }
#if WIN32 != 200
    if (grfMode & STGM_SIMPLE)
    {
        sc = DfOpenSimpDocfile(pwcsName, grfMode, 0, ppstgOpen);
        goto EH_Err;
    }
#endif
    olChk(VerifyPerms(grfMode, TRUE));
    if (grfMode & (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);
    if (snbExclude)
    {
        if ((grfMode & STGM_RDWR) != STGM_READWRITE)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(ValidateSNB(snbExclude));
    }
    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    if (grfMode & STGM_DELETEONRELEASE)
        olErr(EH_Err, STG_E_INVALIDFUNCTION);

    //Otherwise, try it as a docfile
    if (pstgPriority)
        olChk(pstgPriority->Release());

    DfInitSharedMemBase();
#ifdef COORD
    olChk(DfFromName(awcName, ModeToDFlags(grfMode), RSF_OPEN |
                     ((grfMode & STGM_DELETEONRELEASE) ?
                      RSF_DELETEONRELEASE : 0) |
                     ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                      RSF_NO_BUFFERING : 0),
                     snbExclude, pTransaction, &pdfExp, pulSectorSize, &cid));
#else
    olChk(DfFromName(awcName, ModeToDFlags(grfMode), RSF_OPEN |
                     ((grfMode & STGM_DELETEONRELEASE) ?
                      RSF_DELETEONRELEASE : 0) |
                     ((grfAttrs & FILE_FLAG_NO_BUFFERING) ?
                      RSF_NO_BUFFERING : 0),
                     snbExclude, &pdfExp, pulSectorSize, &cid));
#endif //COORD

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

    olDebugOut((DEB_TRACE, "Out StgOpenStorage => %p\n", *ppstgOpen));
EH_Err:
    olLog(("--------::Out StgOpenStorage().  *ppstgOpen == %p, ret == %lx\n",
           *ppstgOpen, sc));
    FreeLogFile();
    OLETRACEOUT((API_StgOpenStorage, sc));

    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   StgOpenStorageOnILockBytes, public
//
//  Synopsis:   Instantiates a root Docfile from an LStream,
//              converting if necessary
//
//  Arguments:  [plkbyt] - Source LStream
//              [pstgPriority] - For priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - For priority reopens
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    14-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgOpenStorageOnILockBytes(ILockBytes *plkbyt,
                                  IStorage *pstgPriority,
                                  DWORD grfMode,
                                  SNB snbExclude,
                                  DWORD reserved,
                                  IStorage **ppstgOpen)
{
    IMalloc *pMalloc;
    CPerContext *ppc;
    SCODE sc;
    SafeCExposedDocFile pdfExp;
#ifdef MULTIHEAP
    CPerContext pcSharedMemory(NULL);
#endif
    CLSID cid;

    OLETRACEIN((API_StgOpenStorageOnILockBytes,
         PARAMFMT("pstgPriority= %p, grfMode= %x, snbExclude= %p, reserved= %ud, ppstgOpen= %p"),
         pstgPriority, grfMode, snbExclude, reserved, ppstgOpen));

    olLog(("--------::In  StgOpenStorageOnILockBytes("
           "%p, %p, %lX, %p, %lu, %p)\n",
           plkbyt, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen));
    olDebugOut((DEB_TRACE, "In  StgOpenStorageOnILockBytes("
                "%p, %p, %lX, %p, %lu, %p)\n", plkbyt, pstgPriority,
                grfMode, snbExclude, reserved, ppstgOpen));

    olChk(ValidatePtrBuffer(ppstgOpen));
    *ppstgOpen = NULL;
    olChk(ValidateInterface(plkbyt, IID_ILockBytes));
    if (pstgPriority)
        olChk(ValidateInterface(pstgPriority, IID_IStorage));
    olChk(VerifyPerms(grfMode, TRUE));
    if (grfMode & (STGM_CREATE | STGM_CONVERT))
        olErr(EH_Err, STG_E_INVALIDFLAG);
    if (grfMode & STGM_DELETEONRELEASE)
        olErr(EH_Err, STG_E_INVALIDFUNCTION);
    if (snbExclude)
    {
        if ((grfMode & STGM_RDWR) != STGM_READWRITE)
            olErr(EH_Err, STG_E_ACCESSDENIED);
        olChk(ValidateSNB(snbExclude));
    }
    if (reserved != 0)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    if (pstgPriority)
        olChk(pstgPriority->Release());

    IFileLockBytes *pfl;
    if (SUCCEEDED(plkbyt->QueryInterface(IID_IFileLockBytes,
                                         (void **)&pfl)) &&
        ((CFileStream *)plkbyt)->GetContextPointer() != NULL)
    {
        //Someone passed us the ILockBytes we gave them from
        //StgGetIFillLockBytesOnFile.  It already contains a
        //context pointer, so reuse that rather than creating
        //a whole new shared heap.
        pfl->Release();
        CFileStream *pfst = (CFileStream *)plkbyt;
        CPerContext *ppc = pfst->GetContextPointer();
#ifdef MULTIHEAP
        CSafeMultiHeap smh(ppc);
#endif
#ifdef COORD
        olChk(DfFromLB(ppc,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         NULL,
                         &pdfExp,
                         NULL));
#else
        olChk(DfFromLB(ppc,
                         pfst,
                         ModeToDFlags(grfMode),
                         pfst->GetStartFlags(),
                         NULL,
                         &pdfExp,
                         NULL));
#endif
    }
    else
    {
        DfInitSharedMemBase();
        olHChk(DfCreateSharedAllocator(&pMalloc, TRUE));
#ifdef MULTIHEAP
    // Because a custom ILockbytes can call back into storage code,
    // possibly using another shared heap, we need a temporary
    // owner until the real CPerContext is allocated
    // new stack frame for CSafeMultiHeap constructor/destructor
        {
            pcSharedMemory.GetThreadAllocatorState();
            CSafeMultiHeap smh(&pcSharedMemory);
#endif

            //Create the per context
            olMem(ppc = new (pMalloc) CPerContext(pMalloc));
            sc = ppc->InitNewContext();
            if (FAILED(sc))
            {
                delete ppc;
                olErr(EH_Err, sc);
            }

#ifdef COORD
            sc = DfFromLB(ppc,
                          plkbyt, ModeToDFlags(grfMode), RSF_OPEN, snbExclude,
                          NULL, &pdfExp, &cid);
#else
            sc = DfFromLB(ppc,
                          plkbyt, ModeToDFlags(grfMode), RSF_OPEN, snbExclude,
                          &pdfExp, &cid);
#endif //COORD

            pMalloc->Release();

            //Either DfFromLB has AddRef'ed the per context or it has failed.
            //Either way we want to release our reference here.
            ppc->Release();
            olChk(sc);
#ifdef MULTIHEAP
        }
#endif
    }

    TRANSFER_INTERFACE(pdfExp, IStorage, ppstgOpen);

    //  Success;  since we hold on to the ILockBytes interface,
    //  we must take a reference to it.
    plkbyt->AddRef();

    olDebugOut((DEB_TRACE, "Out StgOpenStorageOnILockBytes => %p\n",
                *ppstgOpen));

EH_Err:
    olLog(("--------::Out StgOpenStorageOnILockBytes().  "
           "*ppstgOpen == %p, ret == %lx\n", *ppstgOpen, sc));
    FreeLogFile();
    OLETRACEOUT((API_StgOpenStorageOnILockBytes, sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfGetClass, public
//
//  Synopsis:   Retrieves the class ID of the root entry of a docfile
//
//  Arguments:  [hFile] - Docfile file handle
//              [pclsid] - Class ID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pclsid]
//
//  History:    09-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI DfGetClass(HANDLE hFile,
                  CLSID *pclsid)
{
    SCODE sc;
    DWORD dwCb;
    IMalloc *pMalloc;
    CFileStream *pfst;
    ULARGE_INTEGER uliOffset;
    ULONG ulOpenLock, ulAccessLock;
    BYTE bBuffer[sizeof(CMSFHeader)];
    CMSFHeader *pmsh;
    CDirEntry *pde;

    olDebugOut((DEB_ITRACE, "In  DfGetClass(%p, %p)\n", hFile, pclsid));

    olAssert(sizeof(bBuffer) >= sizeof(CMSFHeader));
    pmsh = (CMSFHeader *)bBuffer;

    olAssert(sizeof(bBuffer) >= sizeof(CDirEntry));
    pde = (CDirEntry *)bBuffer;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
    {
        olErr(EH_Err, LAST_STG_SCODE);
    }
    if (!ReadFile(hFile, pmsh->GetData(), sizeof(CMSFHeaderData), &dwCb, NULL))
    {
        olErr(EH_Err, LAST_STG_SCODE);
    }
    if (dwCb != sizeof(CMSFHeaderData))
    {
        olErr(EH_Err, STG_E_INVALIDHEADER);
    }
    sc = pmsh->Validate();
    olChk(sc);

    // Now we know it's a docfile

    DfInitSharedMemBase();
    olHChk(DfCreateSharedAllocator(&pMalloc, FALSE));
    olMemTo(EH_pMalloc, pfst = new (pMalloc) CFileStream(pMalloc));
    olChkTo(EH_pfst, pfst->InitGlobal(0, 0));
    olChkTo(EH_pfst, pfst->InitFromHandle(hFile));

    // Take open and access locks to ensure that we're cooperating
    // with real opens

    olChkTo(EH_pfst, GetOpen(pfst, DF_READ, TRUE, &ulOpenLock));
    olChkTo(EH_open, GetAccess(pfst, DF_READ, &ulAccessLock));

    uliOffset.HighPart = 0;
    uliOffset.LowPart = (pmsh->GetDirStart() << pmsh->GetSectorShift())+
        HEADERSIZE;

    // The root directory entry is always the first directory entry
    // in the first directory sector

    // Ideally, we could read just the class ID directly into
    // pclsid.  In practice, all the important things are declared
    // private or protected so it's easier to read the whole entry

    olChkTo(EH_access, GetScode(pfst->ReadAt(uliOffset, pde,
                                             sizeof(CDirEntry), &dwCb)));
    if (dwCb != sizeof(CDirEntry))
    {
        sc = STG_E_READFAULT;
    }
    else
    {
        sc = S_OK;
    }

    *pclsid = pde->GetClassId();

    olDebugOut((DEB_ITRACE, "Out DfGetClass\n"));
 EH_access:
    ReleaseAccess(pfst, DF_READ, ulAccessLock);
 EH_open:
    ReleaseOpen(pfst, DF_READ, ulOpenLock);
 EH_pfst:
    pfst->Release();
 EH_pMalloc:
    pMalloc->Release();
 EH_Err:
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\expdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       expdf.cxx
//
//  Contents:   Exposed DocFile implementation
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <expdf.hxx>
#include <expst.hxx>
#include <expiter.hxx>
#include <pbstream.hxx>
#include <lock.hxx>
#include <marshl.hxx>
#include <logfile.hxx>
#include <rpubdf.hxx>
#include <expparam.hxx>

#include <olepfn.hxx>

#include <ole2sp.h>
#include <ole2com.h>

#if WIN32 == 300
IMPLEMENT_UNWIND(CSafeAccess);
IMPLEMENT_UNWIND(CSafeSem);
#endif

extern WCHAR const wcsContents[];



//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CExposedDocFile, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pdf] - Public DocFile
//              [pdfb] - DocFile basis
//              [ppc] - Context
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedDocFile::CExposedDocFile(CPubDocFile *pdf,
                                 CDFBasis *pdfb,
                                 CPerContext *ppc)
    : CPropertySetStorage(MAPPED_STREAM_QI),
      _PropertyBagEx( DFlagsToMode( pdf->GetDFlags() ))
{
    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CExposedDocFile("
                "%p, %p, %p)\n", pdf, pdfb, ppc));


    _ppc = ppc;
    _pdf = P_TO_BP(CBasedPubDocFilePtr, pdf);
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _pdfb->vAddRef();
    _cReferences = 1;
    _sig = CEXPOSEDDOCFILE_SIG;
#if WIN32 >= 300
    _pIAC = NULL;
#endif

    // Initialize CPropertySetStorage and CPropertyBagEx

    CPropertySetStorage::Init( static_cast<IStorage*>(this), static_cast<IBlockingLock*>(this),
                               FALSE ); // fControlLifetimes (=> Don't addref)

    _PropertyBagEx.Init( static_cast<IPropertySetStorage*>(this),   // Not addref-ed
                         static_cast<IBlockingLock*>(this) );       // Not addref-ed


    //
    // CoQueryReleaseObject needs to have the address of the exposed docfiles
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CExposedDocFile] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CExposedDocFile] =
            **(DWORD **)((IStorage *)this);
    }

#ifdef COORD
    _ulLock = _cbSizeBase = _cbSizeOrig = 0;
    _sigMSF = 0;
#endif

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CExposedDocFile\n"));
}


SCODE CExposedDocFile::InitMarshal(DWORD dwAsyncFlags,
                                   IDocfileAsyncConnectionPoint *pdacp)
{
    return _cpoint.InitMarshal(this, dwAsyncFlags, pdacp);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::~CExposedDocFile, public
//
//  Synopsis:   Destructor
//
//  History:    23-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedDocFile::~CExposedDocFile(void)
{
    BOOL fClose = FALSE;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::~CExposedDocFile\n"));
    olAssert(_cReferences == 0);

    //In order to call into the tree, we need to take the mutex.
    //The mutex may get deleted in _ppc->Release(), so we can't
    //release it here.  The mutex actually gets released in
    //CPerContext::Release() or in the CPerContext destructor.

    //If _ppc is NULL, we're partially constructed and don't need to
    //worry.
    SCODE sc;

#if WIN32 >= 300
     if (_pIAC != NULL)
     {
        _pIAC->Release();
        _pIAC = NULL;
     }
#endif

#if !defined(MULTIHEAP)
    // TakeSem and ReleaseSem are moved to the Release Method
    // so that the deallocation for this object is protected
    if (_ppc)
    {
        sc = TakeSem();
        SetWriteAccess();
        olAssert(SUCCEEDED(sc));
    }


#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP

    if (_pdf)
    {
        // If we're the last reference on a root object
        // we close the context because all children will become
        // reverted so it is no longer necessary
        if (_pdf->GetRefCount() == 1 && _pdf->IsRoot())
            fClose = TRUE;

        _pdf->CPubDocFile::vRelease();
    }
    if (_pdfb)
        _pdfb->CDFBasis::vRelease();
#if !defined(MULTIHEAP)
    if (_ppc)
    {
        if (fClose)
            _ppc->Close();
        if (_ppc->Release() > 0)
            ReleaseSem(sc);
    }
#ifdef ASYNC
    //Mutex has been released, so we can release the connection point
    //  without fear of deadlock.
    if (pdacp != NULL)
        pdacp->Release();
#endif
#endif // MULTIHEAP

    _sig = CEXPOSEDDOCFILE_SIGDEL;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::~CExposedDocFile\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Release, public
//
//  Synopsis:   Releases resources for a CExposedDocFile
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedDocFile::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedDocFile::Release()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Release()\n"));

    if (FAILED(Validate()))
        return 0;
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        SCODE sc = S_OK;

        sc = _PropertyBagEx.Commit( STGC_DEFAULT );
        olAssert(SUCCEEDED(sc));

        sc = _PropertyBagEx.ShutDown();
        olAssert(SUCCEEDED(sc));

#ifdef MULTIHEAP
        CSafeMultiHeap smh(_ppc);
        CPerContext *ppc = _ppc;

        if (_ppc)
        {
            sc = TakeSem();
            SetWriteAccess();
            olAssert(SUCCEEDED(sc));
        }
#ifdef ASYNC
        IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
        BOOL fClose = (_pdf) && (_pdf->GetRefCount()==1) && _pdf->IsRoot();
#endif //MULTIHEAP
        delete this;
#ifdef MULTIHEAP
        if (ppc)
        {
            if (fClose)
                ppc->Close();
            if (ppc->Release() == 0)
                g_smAllocator.Uninit();
            else
                if (SUCCEEDED(sc)) ppc->UntakeSem(); 
        }
#ifdef ASYNC
        //Mutex has been released, so we can release the connection point
        //  without fear of deadlock.
        if (pdacp != NULL)
            pdacp->Release();
#endif
#endif
    }
    else if (lRet < 0)
        lRet = 0;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Release %p() => %lu\n", 
                this, lRet));
    olLog(("%p::Out CExposedDocFile::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return (ULONG)lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CheckCopyTo, private
//
//  Synopsis:   Checks for CopyTo legality
//
//  Returns:    Appropriate status code
//
//  History:    07-Jul-92       DrewB   Created
//
//---------------------------------------------------------------

inline SCODE CExposedDocFile::CheckCopyTo(void)
{
    return _pdfb->GetCopyBase() != NULL &&
        _pdf->IsAtOrAbove(_pdfb->GetCopyBase()) ?
            STG_E_ACCESSDENIED : S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ConvertInternalStream, private
//
//  Synopsis:   Converts an internal stream to a storage
//
//  Arguments:  [pwcsName] - Name
//              [pdfExp] - Destination docfile
//
//  Returns:    Appropriate status code
//
//  History:    23-Jun-92       DrewB   Created
//
//---------------------------------------------------------------


static WCHAR const wcsIllegalName[] = {'\\', '\0'};

SCODE CExposedDocFile::ConvertInternalStream(CExposedDocFile *pdfExp)
{
    CPubStream *pstFrom, *pstTo;
    SCODE sc;
    CDfName const dfnIllegal(wcsIllegalName);
    CDfName const dfnContents(wcsContents);

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::ConvertInternalStream(%p)\n",
                pdfExp));
    olChk(_pdf->GetStream(&dfnIllegal, DF_READWRITE | DF_DENYALL, &pstFrom));
    olChkTo(EH_pstFrom, pdfExp->GetPub()->CreateStream(&dfnContents,
                                                       DF_WRITE | DF_DENYALL,
                                                       &pstTo));
    olChkTo(EH_pstTo, CopySStreamToSStream(pstFrom->GetSt(),
                                           pstTo->GetSt()));
    olChkTo(EH_pstTo, _pdf->DestroyEntry(&dfnIllegal, FALSE));
    sc = S_OK;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::ConvertInternalStream\n"));
    // Fall through
EH_pstTo:
    pstTo->CPubStream::vRelease();
EH_pstFrom:
    pstFrom->CPubStream::vRelease();
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateEntry, private
//
//  Synopsis:   Creates elements, used in CreateStream, CreateStorage.
//
//  Arguments:  [pdfn] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    18-Dec-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::CreateEntry(CDfName const *pdfn,
                                   DWORD dwType,
                                   DWORD grfMode,
                                   void **ppv)
{
    SCODE sc;
    SEntryBuffer eb;
    BOOL fRenamed = FALSE;
    CPubStream *pst;
    CExposedStream *pstExp;
    CPubDocFile *pdf;
    CExposedDocFile *pdfExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::CreateEntry:%p("
                "%p, %lX, %lX, %p)\n", this, pdfn, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));

    //  3/11/93 - Demand scratch when opening/creating transacted
    if ((grfMode & STGM_TRANSACTED) == STGM_TRANSACTED)
    {
        olChk(_ppc->GetDirty()->InitScratch());
    }

    if (grfMode & (STGM_CREATE | STGM_CONVERT))
    {
        if (FAILED(sc = _pdf->IsEntry(pdfn, &eb)))
        {
            if (sc != STG_E_FILENOTFOUND)
                olErr(EH_Err, sc);
        }
        else if (eb.dwType == dwType && (grfMode & STGM_CREATE))
            olChk(_pdf->DestroyEntry(pdfn, FALSE));
        else if (eb.dwType == STGTY_STREAM && (grfMode & STGM_CONVERT) &&
                 dwType == STGTY_STORAGE)
        {
            CDfName const dfnIllegal(wcsIllegalName);

            olChk(_pdf->RenameEntry(pdfn, &dfnIllegal));
            fRenamed = TRUE;
        }
        else
            olErr(EH_Err, STG_E_FILEALREADYEXISTS);
    }
    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(_pdf->CreateStream(pdfn, ModeToDFlags(grfMode), &pst));
        olMemTo(EH_pst, pstExp =  new (_pdfb->GetMalloc()) CExposedStream);
        olChkTo(EH_pstExp, pstExp->Init(pst, BP_TO_P(CDFBasis *, _pdfb),
                                        _ppc, NULL));
        _ppc->AddRef();
#ifdef ASYNC
        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_connSt, pstExp->InitConnection(&_cpoint));
        }
#endif
        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(_pdf->CreateDocFile(pdfn, ModeToDFlags(grfMode), &pdf));
        olMemTo(EH_pdf, pdfExp = new (_pdfb->GetMalloc())
                CExposedDocFile(pdf, BP_TO_P(CDFBasis *, _pdfb), _ppc));
        _ppc->AddRef();

        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_pdfExpInit, pdfExp->InitConnection(&_cpoint));
        }

        // If we've renamed the original stream for conversion, convert
        if (fRenamed)
        {
            olChkTo(EH_pdfExpInit, ConvertInternalStream(pdfExp));
            sc = STG_S_CONVERTED;
        }

        *ppv = pdfExp;
    }
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::CreateEntry\n"));
    return sc;

 EH_connSt:
    pstExp->Release();
    goto EH_Del;

 EH_pstExp:
    delete pstExp;
 EH_pst:
    pst->CPubStream::vRelease();
    goto EH_Del;

 EH_pdfExpInit:
    pdfExp->Release();
    goto EH_Del;
 EH_pdf:
    pdf->CPubDocFile::vRelease();
    // Fall through
 EH_Del:
    olVerSucc(_pdf->DestroyEntry(pdfn, TRUE));
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenEntry, private
//
//  Synopsis:   Opens elements, used in OpenStream, OpenStorage.
//
//  Arguments:  [pdfn] - Name
//              [dwType] - Entry type
//              [grfMode] - Access mode
//              [ppv] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    18-Dec-92       DrewB   Created
//
//----------------------------------------------------------------------------


SCODE CExposedDocFile::OpenEntry(CDfName const *pdfn,
                                 DWORD dwType,
                                 DWORD grfMode,
                                 void **ppv)
{
    SCODE sc;
    CPubDocFile *pdf;
    CExposedDocFile *pdfExp;
    CPubStream *pst;
    CExposedStream *pstExp;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::OpenEntry:%p("
                "%p, %lX, %lX, %p)\n", this, pdfn, dwType, grfMode, ppv));
    olChk(EnforceSingle(grfMode));

    //  3/11/93 - Demand scratch when opening/creating transacted
    if ((grfMode & STGM_TRANSACTED) == STGM_TRANSACTED)
    {
        olChk(_ppc->GetDirty()->InitScratch());
    }

    if (REAL_STGTY(dwType) == STGTY_STREAM)
    {
        olChk(_pdf->GetStream(pdfn, ModeToDFlags(grfMode), &pst));
        olMemTo(EH_pst, pstExp = new (_pdfb->GetMalloc()) CExposedStream);
        olChkTo(EH_pstExp, pstExp->Init(pst, BP_TO_P(CDFBasis *, _pdfb),
                                        _ppc, NULL));
        _ppc->AddRef();

        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_connSt, pstExp->InitConnection(&_cpoint));
        }

        *ppv = pstExp;
    }
    else
    {
        olAssert(REAL_STGTY(dwType) == STGTY_STORAGE);
        olChk(_pdf->GetDocFile(pdfn, ModeToDFlags(grfMode), &pdf));
        olMemTo(EH_pdf, pdfExp = new (_pdfb->GetMalloc())
                CExposedDocFile(pdf, BP_TO_P(CDFBasis *, _pdfb), _ppc));
        _ppc->AddRef();

        if (_cpoint.IsInitialized())
        {
            olChkTo(EH_connDf, pdfExp->InitConnection(&_cpoint));
        }

        *ppv = pdfExp;
    }

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::OpenEntry\n"));
    return S_OK;
 EH_connSt:
    pstExp->Release();
    return sc;

 EH_pstExp:
    delete pstExp;
    //  Fall through to clean up CPubStream
 EH_pst:
    pst->CPubStream::vRelease();
    return sc;

EH_connDf:
    pdfExp->Release();
    return sc;

 EH_pdf:
    pdf->CPubDocFile::vRelease();
    // Fall through
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::CreateStream(WCHAR const *pwcsName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedStream pestm;
    CDfName dfn;

    olDebugOut((DEB_TRACE, "In  CExposedDocFile::CreateStream("
                "%ws, %lX, %lu, %lu, %p)\n", pwcsName, grfMode, reserved1,
                reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::CreateStream(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstm));

    OL_VALIDATE(CreateStream(pwcsName,
                             grfMode,
                             reserved1,
                             reserved2,
                             ppstm));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(CheckCopyTo());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    dfn.Set(pwcsName);
    sc = CreateEntry(&dfn, STGTY_STREAM, grfMode, (void **)&pestm);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
        TRANSFER_INTERFACE(pestm, IStream, ppstm);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::CreateStream => %p\n",
                *ppstm));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStream().  "
           "*ppstm == %p, ret == %lx\n", this, *ppstm, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedStream pestm;
    CDfName dfn;

    olDebugOut((DEB_TRACE, "In  CExposedDocFile::OpenStream("
                "%ws, %p, %lX, %lu, %p)\n", pwcsName, reserved1,
                grfMode, reserved2, ppstm));
    olLog(("%p::In  CExposedDocFile::OpenStream(%ws, %lu %lX, %lu, %p)\n",
           this, pwcsName, reserved1, grfMode, reserved2, ppstm));

    OL_VALIDATE(OpenStream(pwcsName,
                           reserved1,
                           grfMode,
                           reserved2,
                           ppstm));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    dfn.Set(pwcsName);
    sc = OpenEntry(&dfn, STGTY_STREAM, grfMode, (void **)&pestm);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
        TRANSFER_INTERFACE(pestm, IStream, ppstm);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::OpenStream => %p\n",
                *ppstm));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStream().  "
           "*ppstm == %p, ret == %lx\n", this, *ppstm, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CreateStorage, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstg] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::CreateStorage(
        WCHAR const *pwcsName,
        DWORD grfMode,
        DWORD reserved1,
        LPSTGSECURITY reserved2,
        IStorage **ppstg)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedDocFile pedf;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::CreateStorage(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstg));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::CreateStorage:%p("
                "%ws, %lX, %lu, %lu, %p)\n", this, pwcsName, grfMode,
                reserved1, reserved2, ppstg));

    OL_VALIDATE(CreateStorage(pwcsName,
                              grfMode,
                              reserved1,
                              reserved2,
                              ppstg));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(CheckCopyTo());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    dfn.Set(pwcsName);
    sc = CreateEntry(&dfn, STGTY_STORAGE, grfMode, (void **)&pedf);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
        TRANSFER_INTERFACE(pedf, IStorage, ppstg);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::CreateStorage => %p\n",
                *ppstg));
EH_Err:
    olLog(("%p::Out CExposedDocFile::CreateStorage().  "
           "*ppstg == %p, ret == %lX\n", this, *ppstg, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::OpenStorage, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - Priority reopens
//              [reserved]
//              [ppstg] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::OpenStorage(WCHAR const *pwcsName,
                                           IStorage *pstgPriority,
                                           DWORD grfMode,
                                           SNBW snbExclude,
                                           DWORD reserved,
                                           IStorage **ppstg)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedDocFile pdfExp;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::OpenStorage(%ws, %p, %lX, %p, %lu, %p)\n",
           this, pwcsName, pstgPriority, grfMode, snbExclude, reserved,
           ppstg));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::OpenStorage:%p("
                "%ws, %p, %lX, %p, %lu, %p)\n", this, pwcsName, pstgPriority,
                grfMode, snbExclude, reserved, ppstg));


    OL_VALIDATE(OpenStorage(pwcsName,
                            pstgPriority,
                            grfMode,
                            snbExclude,
                            reserved,
                            ppstg));
    
    olChk(Validate());
    if (snbExclude != NULL)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    dfn.Set(pwcsName);
    sc = OpenEntry(&dfn, STGTY_STORAGE, grfMode, (void **)&pdfExp);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
    {
        TRANSFER_INTERFACE(pdfExp, IStorage, ppstg);
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::OpenStorage => %p\n",
                *ppstg));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::OpenStorage().  "
           "*ppstg == %p, ret == %lX\n", this, *ppstg, sc));
    return _OLERETURN(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::MakeCopyFlags, public
//
//  Synopsis:   Translates IID array into bit fields
//
//  Arguments:  [ciidExclude] - Count of IIDs
//              [rgiidExclude] - IIDs not to copy
//
//  Returns:    Appropriate status code
//
//  History:    23-Dec-92       DrewB   Created
//
//----------------------------------------------------------------------------


DWORD CExposedDocFile::MakeCopyFlags(DWORD ciidExclude,
                                     IID const *rgiidExclude)
{
    DWORD dwCopyFlags;

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::MakeCopyFlags(%lu, %p)\n",
                ciidExclude, rgiidExclude));
    // Copy everything by default
    dwCopyFlags = COPY_ALL;
    for (; ciidExclude > 0; ciidExclude--, rgiidExclude++)
        if (IsEqualIID(*rgiidExclude, IID_IStorage))
            dwCopyFlags &= ~COPY_STORAGES;
        else if (IsEqualIID(*rgiidExclude, IID_IStream))
            dwCopyFlags &= ~COPY_STREAMS;
    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::MakeCopyFlags\n"));
    return dwCopyFlags;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::CopyTo, public
//
//  Synopsis:   Makes a copy of a DocFile
//
//  Arguments:  [ciidExclude] - Length of rgiid array
//              [rgiidExclude] - Array of IIDs to exclude
//              [snbExclude] - Names to exclude
//              [pstgDest] - Parent of copy
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::CopyTo(DWORD ciidExclude,
                                      IID const *rgiidExclude,
                                      SNBW snbExclude,
                                      IStorage *pstgDest)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    SAFE_SEM;
    DWORD i;



    olLog(("%p::In  CExposedDocFile::CopyTo(%lu, %p, %p, %p)\n",
           this, ciidExclude, rgiidExclude, snbExclude, pstgDest));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::CopyTo(%lu, %p, %p, %p)\n",
                ciidExclude, rgiidExclude, snbExclude, pstgDest));

    OL_VALIDATE(CopyTo(ciidExclude,
                       rgiidExclude,
                       snbExclude,
                       pstgDest));
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(_pdf->CheckReverted());

    olAssert(_pdfb->GetCopyBase() == NULL);
    _pdfb->SetCopyBase(BP_TO_P(CPubDocFile *, _pdf));

    // Flush all descendant property set buffers so that their
    // underlying Streams (which are about to be copied) are
    // up to date.

    SetWriteAccess();
    olChkTo(EH_Loop, _pdf->FlushBufferedData(0));
    ClearWriteAccess();

    // Perform the copy.

    sc = CopyDocFileToIStorage(_pdf->GetDF(), pstgDest, snbExclude,
                               MakeCopyFlags(ciidExclude, rgiidExclude));
EH_Loop:
    _pdfb->SetCopyBase(NULL);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::CopyTo\n"));
EH_Err:
    _pdfb->SetCopyBase(NULL);
    olLog(("%p::Out ExposedDocFile::CopyTo().  ret == %lX\n", this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::Commit(DWORD dwFlags)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::Commit(%lX)\n",this, dwFlags));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Commit(%lX)\n", dwFlags));

    OL_VALIDATE(Commit(dwFlags));
    olChk(Validate());

    BEGIN_PENDING_LOOP;

    olChk( _PropertyBagEx.Commit( dwFlags ));
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    if (_pdf->GetTransactedDepth() <= 1) // topmost transacted level or direct
    {
        if (_pdfb->DirectWriterMode() && (*_ppc->GetRecursionCount()) == 0)
            olChk(STG_E_ACCESSDENIED);
    }
#endif

    olChkTo(EH_Loop, _pdf->Commit(dwFlags));

#if WIN32 >= 300
    if (SUCCEEDED(sc) && _pIAC != NULL)
        sc = _pIAC->CommitAccessRights(0);
#endif

EH_Loop:
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Commit().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Revert, public
//
//  Synopsis:   Reverts transacted changes
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::Revert(void)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::Revert()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Revert\n"));

    OL_VALIDATE(Revert());
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

    olChkTo(EH_Loop, _pdf->Revert());

#if WIN32 >= 300
    if (SUCCEEDED(sc) && _pIAC != NULL)
        sc = _pIAC->RevertAccessRights();
#endif
EH_Loop:
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Revert\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Revert().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    SafeCExposedIterator pdiExp;
    CDfName dfnTmp;

    olLog(("%p::In  CExposedDocFile::EnumElements(%lu, %p, %lu, %p)\n",
           this, reserved1, reserved2, reserved3, ppenm));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::EnumElements(%p)\n",
                ppenm));

    OL_VALIDATE(EnumElements(reserved1,
                             reserved2,
                             reserved3,
                             ppenm));

    olChk(Validate());

    //ASYNC Note:  It doesn't appear that there's any way that this
    //  function can fail with STG_E_PENDING, so we don't need a pending
    //  loop here.
    olChk(TakeSafeSem());
    if (!P_READ(_pdf->GetDFlags()))
        olErr(EH_Err, STG_E_ACCESSDENIED);
    olChk(_pdf->CheckReverted());
    SafeReadAccess();

    pdiExp.Attach(new CExposedIterator(BP_TO_P(CPubDocFile *, _pdf),
                                       &dfnTmp,
                                       BP_TO_P(CDFBasis *, _pdfb),
                                       _ppc));
    olMem((CExposedIterator *)pdiExp);
    _ppc->AddRef();
#ifdef ASYNC
    if (_cpoint.IsInitialized())
    {
        olChkTo(EH_Exp, pdiExp->InitConnection(&_cpoint));
    }
#endif
    TRANSFER_INTERFACE(pdiExp, IEnumSTATSTG, ppenm);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::EnumElements => %p\n",
                *ppenm));
EH_Err:
    olLog(("%p::Out CExposedDocFile::EnumElements().  ret == %lx\n",this, sc));
    return ResultFromScode(sc);
EH_Exp:
    pdiExp->Release();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DestroyElement, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pwcsName] - Name of element
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::DestroyElement(WCHAR const *pwcsName)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CDfName dfn;

    olLog(("%p::In  CExposedDocFile::DestroyElement(%ws)\n", this, pwcsName));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::DestroyElement(%ws)\n",
                pwcsName));

    OL_VALIDATE(DestroyElement(pwcsName));
    
    olChk(Validate());
    dfn.Set(pwcsName);

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->DestroyEntry(&dfn, FALSE);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::DestroyElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::DestroyElement().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

_OLESTDMETHODIMP CExposedDocFile::MoveElementTo(WCHAR const *pwcsName,
                                             IStorage *pstgParent,
                                             OLECHAR const *ptcsNewName,
                                             DWORD grfFlags)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    olLog(("%p::In  CExposedDocFile::MoveElementTo("
           "%ws, %p, " OLEFMT ", %lu)\n",
           this, pwcsName, pstgParent, ptcsNewName, grfFlags));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::MoveElementTo("
                "%ws, %p, " OLEFMT ", %lu)\n",
                pwcsName, pstgParent, ptcsNewName, grfFlags));

    OL_VALIDATE(MoveElementTo(pwcsName,
                              pstgParent,
                              ptcsNewName,
                              grfFlags));
    
    olChk(Validate());

#ifdef ASYNC
    //ASYNC Note:  We don't use the normal pending loop macros here because
    //  we have no safe sem and need to pass a NULL.
    do
    {
#endif
        sc = MoveElementWorker(pwcsName,
                               pstgParent,
                               ptcsNewName,
                               grfFlags);
#ifdef ASYNC
        if (!ISPENDINGERROR(sc))
        {
            break;
        }
        else
        {
            SCODE sc2;
            sc2 = _cpoint.Notify(sc,
                                 _ppc->GetBase(),
                                 _ppc,
                                 NULL);
            if (sc2 != S_OK)
            {
                return ResultFromScode(sc2);
            }
        }
    } while (TRUE);
#endif
EH_Err:
    olLog(("%p::Out CExposedDocFile::MoveElementTo().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MoveElementToWorker, public
//
//  Synopsis:   Move an element of a DocFile to an IStorage
//
//  Arguments:  [pwcsName] - Current name
//              [ptcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Open source as storage or stream (whatever works)
//              Create appropriate destination
//              Copy source to destination
//              Set create time of destination equal to create time of source
//              If appropriate, delete source
//
//  History:    10-Nov-92       AlexT   Created
//
//---------------------------------------------------------------


SCODE CExposedDocFile::MoveElementWorker(WCHAR const *pwcsName,
                                         IStorage *pstgParent,
                                         OLECHAR const *ptcsNewName,
                                         DWORD grfFlags)
{
    IUnknown *punksrc = NULL;
    SCODE sc;
    IUnknown *punkdst;
    IStorage *pstgsrc;
    STATSTG statstg;
    BOOL fCreate = TRUE;
    
    // Determine source type
    sc = GetScode(OpenStorage(pwcsName, NULL,
                              STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                              NULL, NULL, &pstgsrc));
    if (SUCCEEDED(sc))
    {
        HRESULT hr;

        //  It's a storage
        punksrc = pstgsrc;

        IStorage *pstgdst;
        olHChkTo(EH_UnkSrc, pstgsrc->Stat(&statstg, STATFLAG_NONAME));

        hr = pstgParent->CreateStorage(ptcsNewName,
                                       STGM_DIRECT | STGM_WRITE |
                                       STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE,
                                       0, 0, &pstgdst);
        if (DfGetScode(hr) == STG_E_FILEALREADYEXISTS &&
            grfFlags == STGMOVE_COPY)
        {
            fCreate = FALSE;
            //If we're opening an existing thing for merging, we need
            //  read and write permissions so we can traverse the tree.
            hr = pstgParent->OpenStorage(ptcsNewName, NULL,
                                         STGM_DIRECT | STGM_READWRITE |
                                         STGM_SHARE_EXCLUSIVE, NULL,
                                         0, &pstgdst);
        }
        olHChkTo(EH_UnkSrc, hr);

        punkdst = pstgdst;

        sc = DfGetScode(pstgsrc->CopyTo(0, NULL, NULL, pstgdst));
    }
    else if (sc == STG_E_FILENOTFOUND)
    {
        //  Try opening it as a stream
        HRESULT hr;
        
        IStream *pstmsrc, *pstmdst;
        olHChk(OpenStream(pwcsName, NULL,
                          STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                          NULL, &pstmsrc));

        //  It's a stream
        punksrc = pstmsrc;

        olHChkTo(EH_UnkSrc, pstmsrc->Stat(&statstg, STATFLAG_NONAME));

        hr = pstgParent->CreateStream(ptcsNewName,
                                      STGM_DIRECT | STGM_WRITE |
                                      STGM_SHARE_EXCLUSIVE |
                                      STGM_FAILIFTHERE,
                                      0, 0, &pstmdst);
        if (DfGetScode(hr) == STG_E_FILEALREADYEXISTS &&
            grfFlags == STGMOVE_COPY)
        {
            ULARGE_INTEGER uli;
            uli.QuadPart = 0;
            
            fCreate = FALSE;
            //Try to open it instead
            //Note:  We do this instead of doing a CreateStream with
            //  STGM_CREATE because CreateStream can open over an already
            //  open stream, which leads to problems when the destination
            //  and the source are the same.
            olHChkTo(EH_UnkSrc, pstgParent->OpenStream(ptcsNewName,
                                                       0,
                                                       STGM_DIRECT |
                                                       STGM_WRITE |
                                                       STGM_SHARE_EXCLUSIVE,
                                                       0,
                                                       &pstmdst));
            sc = pstmdst->SetSize(uli);
            if (FAILED(sc))
            {
                pstmdst->Release();
                olErr(EH_UnkSrc, sc);
            }
        }
        else
            olHChkTo(EH_UnkSrc, hr);

        punkdst = pstmdst;

        ULARGE_INTEGER cb;
        ULISetLow (cb, 0xffffffff);
        ULISetHigh(cb, 0xffffffff);
        sc = DfGetScode(pstmsrc->CopyTo(pstmdst, cb, NULL, NULL));
    }
    else
        olChk(sc);

    punkdst->Release();

    if (SUCCEEDED(sc))
    {
        //  Make destination create time match source create time
        //  Note that we don't really care if this call succeeded.

        pstgParent->SetElementTimes(ptcsNewName, &statstg.ctime,
                                    NULL, NULL);

	//OK to ignore failure from DestroyElement
        if ((grfFlags & STGMOVE_COPY) == STGMOVE_MOVE)
            DestroyElement(pwcsName);
    }
    else
    {
        //  The copy/move failed, so get rid of the partial result.
        //Only do a delete if the object was newly created.
        if (fCreate)
            pstgParent->DestroyElement(ptcsNewName);
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::MoveElementTo\n"));
    // Fall through
EH_UnkSrc:
    if (punksrc)
        punksrc->Release();
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::RenameElement, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pwcsName] - Current name
//              [pwcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    20-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::RenameElement(WCHAR const *pwcsName,
                                             WCHAR const *pwcsNewName)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CDfName dfnOld, dfnNew;

    olLog(("%p::In  CExposedDocFile::RenameElement(%ws, %ws)\n",
           this, pwcsName, pwcsNewName));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::RenameElement(%ws, %ws)\n",
               pwcsName, pwcsNewName));

    OL_VALIDATE(RenameElement(pwcsName,
                              pwcsNewName));
    
    olChk(Validate());
    dfnOld.Set(pwcsName);
    dfnNew.Set(pwcsNewName);

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->RenameEntry(&dfnOld, &dfnNew);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::RenameElement\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::RenameElement().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetElementTimes, public
//
//  Synopsis:   Sets element time stamps
//
//  Arguments:  [pwcsName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::SetElementTimes(WCHAR const *pwcsName,
                                               FILETIME const *pctime,
                                               FILETIME const *patime,
                                               FILETIME const *pmtime)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CDfName dfn;
    CDfName *pdfn = NULL;
    FILETIME ctime, atime, mtime;

    olLog(("%p::In  CExposedDocFile::SetElementTimes(%ws, %p, %p, %p)\n",
           this, pwcsName, pctime, patime, pmtime));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SetElementTimes:%p("
                "%ws, %p, %p, %p)\n", this, pwcsName, pctime, patime, pmtime));

    OL_VALIDATE(SetElementTimes(pwcsName,
                                pctime,
                                patime,
                                pmtime));
    olChk(Validate());
    // Probe arguments and make local copies if necessary
    if (pctime)
    {
        ctime = *pctime;
        pctime = &ctime;
    }
    if (patime)
    {
        atime = *patime;
        patime = &atime;
    }
    if (pmtime)
    {
        mtime = *pmtime;
        pmtime = &mtime;
    }

    if (pwcsName != NULL)
    {
        dfn.Set(pwcsName);
        pdfn = &dfn;
    }

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->SetElementTimes(pdfn, pctime, patime, pmtime);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SetElementTimes\n"));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::SetElementTimes().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::SetClass(REFCLSID rclsid)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    CLSID clsid;

    olLog(("%p::In  CExposedDocFile::SetClass(?)\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SetClass:%p(?)\n", this));

    OL_VALIDATE(SetClass(rclsid));
    olChk(Validate());
    clsid = rclsid;

    BEGIN_PENDING_LOOP;
        olChk(TakeSafeSem());
        SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
        olChk(ValidateWriteAccess());
#endif

        sc = _pdf->SetClass(clsid);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SetClass\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetClass().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::SetStateBits, public
//
//  Synopsis:   Sets state bits
//
//  Arguments:  [grfStateBits] - state bits
//              [grfMask] - state bits mask
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::SetStateBits(%lu, %lu)\n", this,
           grfStateBits, grfMask));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SetStateBits:%p("
                "%lu, %lu)\n", this, grfStateBits, grfMask));

    OL_VALIDATE(SetStateBits(grfStateBits, grfMask));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->SetStateBits(grfStateBits, grfMask);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SetStateBits\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::SetStateBits().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedDocFile::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SAFE_SEM;
    SAFE_ACCESS;
    SCODE sc;
    STATSTGW stat;

    olLog(("%p::In  CExposedDocFile::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::Stat(%p)\n", pstatstg));

    OL_VALIDATE(Stat(pstatstg, grfStatFlag));

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    sc = _pdf->Stat(&stat, grfStatFlag);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
    {
        TRY
        {
            *pstatstg = stat;
            pstatstg->type = STGTY_STORAGE;
            ULISet32(pstatstg->cbSize, 0);
            pstatstg->grfLocksSupported = 0;
            pstatstg->STATSTG_dwStgFmt = 0;
        }
        CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            if (stat.pwcsName)
                TaskMemFree(stat.pwcsName);
        }
        END_CATCH
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::Stat\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::Stat().  *pstatstg == %p  ret == %lx\n",
           this, *pstatstg, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedDocFile::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedDocFile::AddRef()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::AddRef()\n"));

    if (FAILED(Validate()))
        return 0;
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::AddRef %p()=> %lu\n",
                this, _cReferences));
    olLog(("%p::Out CExposedDocFile::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::QueryInterface(?, %p)\n",
                ppvObj));

    OL_VALIDATE(QueryInterface(iid, ppvObj));

    olChk(Validate());
    olChk(_pdf->CheckReverted());

    sc = S_OK;
    if (IsEqualIID(iid, IID_IStorage) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStorage *)this;
        CExposedDocFile::AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        if (P_PRIORITY(_pdf->GetDFlags()) && _pdf->IsRoot())
            olErr(EH_Err, E_NOINTERFACE);

        //If the ILockBytes we'd need to marshal doesn't support IMarshal
        //  then we want to do standard marshalling on the storage, mostly
        //  to prevent deadlock problems but also because you'll get better
        //  performance.  So check, then do the right thing.

        IMarshal *pim;
        ILockBytes *plkb;
        plkb = _ppc->GetOriginal();
        if (plkb == NULL)
        {
            plkb = _ppc->GetBase();
        }

        sc = plkb->QueryInterface(IID_IMarshal, (void **)&pim);
        if (FAILED(sc))
        {
            olErr(EH_Err, E_NOINTERFACE);
        }
        pim->Release();

#ifdef MULTIHEAP
        if (_ppc->GetHeapBase() == NULL)
            olErr (EH_Err, E_NOINTERFACE);
#endif

        *ppvObj = (IMarshal *)this;
        CExposedDocFile::AddRef();
    }
    else if (IsEqualIID(iid, IID_IRootStorage))
    {
#ifdef COORD
        if ((!_pdf->IsRoot()) && (!_pdf->IsCoord()))
#else
        if (!_pdf->IsRoot())
#endif
            olErr(EH_Err, E_NOINTERFACE);
        *ppvObj = (IRootStorage *)this;
        CExposedDocFile::AddRef();
    }
#ifdef NEWPROPS
    else if (IsEqualIID(iid, IID_IPropertySetStorage))
    {
        *ppvObj = (IPropertySetStorage *)this;
        CExposedDocFile::AddRef();
    }

#endif
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IConnectionPointContainer) &&
              _cpoint.IsInitialized())
    {
        *ppvObj = (IConnectionPointContainer *)this;
        CExposedDocFile::AddRef();
    }
#endif
#if WIN32 >= 300
    else if (_pdf->IsRoot() && IsEqualIID(iid, IID_IAccessControl))
    {
        ILockBytes *piLB = _pdf->GetBaseMS()->GetILB();
        olAssert((piLB != NULL));
        SCODE scode = S_OK;
        if (_pIAC == NULL)  // use existing _pIAC if available
            scode = piLB->QueryInterface(IID_IAccessControl,(void **)&_pIAC);
        if (SUCCEEDED(scode))
        {
            *ppvObj = (IAccessControl *)this;
            CExposedDocFile::AddRef();
        }
        else sc = E_NOINTERFACE;
   }
#endif
#ifdef DIRECTWRITERLOCK
    else if (_pdf->IsRoot() && IsEqualIID(iid, IID_IDirectWriterLock) &&
             _pdfb->DirectWriterMode())
    {
        *ppvObj = (IDirectWriterLock *) this;
        CExposedDocFile::AddRef();
    }
#endif // DIRECTWRITERLOCK

    else if( IsEqualIID( iid, IID_IPropertyBagEx ))
    {
        *ppvObj = static_cast<IPropertyBagEx*>(&_PropertyBagEx);
        CExposedDocFile::AddRef();
    }
    else if( IsEqualIID( iid, IID_IPropertyBag ))
    {
        *ppvObj = static_cast<IPropertyBag*>(&_PropertyBagEx);
        CExposedDocFile::AddRef();
    }

    else
        sc = E_NOINTERFACE;

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::QueryInterface => %p\n",
                *ppvObj));
EH_Err:
    olLog(("%p::Out CExposedDocFile::QueryInterface().  "
           "*ppvObj == %p  ret == %lx\n", this, *ppvObj, sc));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopySStreamToIStream, private
//
//  Synopsis:   Copies a PSStream to an IStream
//
//  Arguments:  [psstFrom] - SStream
//              [pstTo] - IStream
//
//  Returns:    Appropriate status code
//
//  History:    07-May-92       DrewB   Created
//              26-Jun-92       AlexT   Moved to CExposedDocFile
//                                      so we can call SetReadAccess
//
//---------------------------------------------------------------


SCODE CExposedDocFile::CopySStreamToIStream(PSStream *psstFrom,
                                            IStream *pstTo)
{
    BYTE *pbBuffer;
    SCODE sc;
#ifdef LARGE_STREAMS
    ULONGLONG cbPos;
    ULONG cbRead, cbWritten;
#else
    ULONG cbRead, cbWritten, cbPos, cbSizeLow;
#endif
    ULONG ulBufferSize;
    ULARGE_INTEGER cbSize;
    cbSize.QuadPart = 0;

    ulBufferSize = (_pdfb->GetOpenFlags() & DF_LARGE) ?
                    LARGESTREAMBUFFERSIZE : STREAMBUFFERSIZE;

    // This is part of CopyTo and therefore we are allowed to
    // fail with out-of-memory
    olChk(GetBuffer(STREAMBUFFERSIZE, ulBufferSize, &pbBuffer, &ulBufferSize));

    // Set destination size for contiguity
    SetReadAccess();
#ifdef LARGE_STREAMS
    psstFrom->GetSize(&cbSize.QuadPart);
#else
    psstFrom->GetSize(&cbSize.LowPart);
    cbSize.HighPart = 0;
#endif
    ClearReadAccess();

    //  Don't need to SetReadAccess here because pstTo is an IStream
    olHChk(pstTo->SetSize(cbSize));
    // Copy between streams
    cbPos = 0;
    for (;;)
    {
        SetReadAccess();
        olChk(psstFrom->ReadAt(cbPos, pbBuffer, ulBufferSize,
                               (ULONG STACKBASED *)&cbRead));
        ClearReadAccess();
        if (cbRead == 0) // EOF
            break;

        //  Don't need to SetReadAccess here because pstTo is an IStream
        olHChk(pstTo->Write(pbBuffer, cbRead, &cbWritten));
        if (cbRead != cbWritten)
            olErr(EH_Err, STG_E_WRITEFAULT);
        cbPos += cbWritten;
    }
    sc = S_OK;

EH_Err:
    DfMemFree(pbBuffer);
    return sc;
}


//+--------------------------------------------------------------
//
//  Method:     CExposedDocFile::CopyDocFileToIStorage, private
//
//  Synopsis:   Copies a docfile's contents to an IStorage
//
//  Arguments:  [pdfFrom] - From
//              [pstgTo] - To
//              [snbExclude] - Names to not copy
//              [dwCopyFlags] - Bitwise flags for types of objects to copy
//
//  Returns:    Appropriate status code
//
//  History:    07-May-92       DrewB   Created
//              26-Jun-92       AlexT   Moved to CExposedDocFile
//                                      so we can call SetReadAccess
//
//---------------------------------------------------------------


// Variables used by CopyDocFileToIStorage that we
// want to allocate dynamically rather than eating stack space
struct SCopyVars : public CLocalAlloc
{
    PSStream *psstFrom;
    IStream *pstTo;
    PDocFile *pdfFromChild;
    IStorage *pstgToChild;
    DWORD grfStateBits;
    CLSID clsid;
    CDfName dfnKey;
    SIterBuffer ib;
    OLECHAR atcName[CWCSTORAGENAME];
};

SCODE CExposedDocFile::CopyDocFileToIStorage(PDocFile *pdfFrom,
                                             IStorage *pstgTo,
                                             SNBW snbExclude,
                                             DWORD dwCopyFlags)
{
    SCODE sc;
    SCopyVars *pcv = NULL;

    olDebugOut((DEB_ITRACE, "In  CopyDocFileToIStorage:%p(%p, %p, %p, %lX)\n",
                this, pdfFrom, pstgTo, snbExclude, dwCopyFlags));

    // Allocate variables dynamically to conserve stack space since
    // this is a recursive call
    olMem(pcv = new SCopyVars);

    SetReadAccess();
    sc = pdfFrom->GetClass(&pcv->clsid);
    ClearReadAccess();
    olChk(sc);

    // Assume STG_E_INVALIDFUNCTION means that the destination storage
    // doesn't support class IDs
    sc = GetScode(pstgTo->SetClass(pcv->clsid));
    if (FAILED(sc) && sc != STG_E_INVALIDFUNCTION)
        olErr(EH_Err, sc);

    SetReadAccess();
    sc = pdfFrom->GetStateBits(&pcv->grfStateBits);
    ClearReadAccess();
    olChk(sc);

    sc = GetScode(pstgTo->SetStateBits(pcv->grfStateBits, 0xffffffff));
    if (FAILED(sc) && sc != STG_E_INVALIDFUNCTION)
        olErr(EH_Err, sc);

    for (;;)
    {
        SetReadAccess();
        sc = pdfFrom->FindGreaterEntry(&pcv->dfnKey, &pcv->ib, NULL);
        ClearReadAccess();

        if (sc == STG_E_NOMOREFILES)
            break;
        else if (FAILED(sc))
            olErr(EH_pdfi, sc);
        pcv->dfnKey.Set(&pcv->ib.dfnName);

        if (snbExclude && NameInSNB(&pcv->ib.dfnName, snbExclude) == S_OK)
            continue;

        if ((pcv->ib.type == STGTY_STORAGE &&
             (dwCopyFlags & COPY_STORAGES) == 0) ||
            (pcv->ib.type == STGTY_STREAM &&
             (dwCopyFlags & COPY_STREAMS) == 0))
            continue;

        switch(pcv->ib.type)
        {
        case STGTY_STORAGE:
            // Embedded DocFile, create destination and recurse

            SetReadAccess();
            sc = pdfFrom->GetDocFile(&pcv->ib.dfnName, DF_READ,
                                     pcv->ib.type, &pcv->pdfFromChild);
            ClearReadAccess();
            olChkTo(EH_pdfi, sc);
            // Not optimally efficient, but reduces #ifdef's
            lstrcpyW(pcv->atcName, (WCHAR *)pcv->ib.dfnName.GetBuffer());

            //  Don't need to SetReadAccess here because pstgTo is an IStorage.

#ifdef MULTIHEAP
            {
                CSafeMultiHeap smh(_ppc);
                // if pstgTo is an IStorage proxy, then returned IStorage
                // can be custom marshaled and allocator state is lost
#endif
            sc = DfGetScode(pstgTo->CreateStorage(pcv->atcName, STGM_WRITE |
                                                  STGM_SHARE_EXCLUSIVE |
                                                  STGM_FAILIFTHERE,
                                                  0, 0, &pcv->pstgToChild));

            if (sc == STG_E_FILEALREADYEXISTS)
                //We need read and write permissions so we can traverse
                //  the destination IStorage
                olHChkTo(EH_Get, pstgTo->OpenStorage(pcv->atcName, NULL,
                                                     STGM_READWRITE |
                                                     STGM_SHARE_EXCLUSIVE,
                                                     NULL, 0,
                                                     &pcv->pstgToChild));
            else if (FAILED(sc))
                olErr(EH_Get, sc);
#ifdef MULTIHEAP
            }
#endif
            olChkTo(EH_Create,
                  CopyDocFileToIStorage(pcv->pdfFromChild, pcv->pstgToChild,
                                        NULL, dwCopyFlags));
            pcv->pdfFromChild->Release();
            pcv->pstgToChild->Release();
            break;

        case STGTY_STREAM:
            SetReadAccess();
            sc = pdfFrom->GetStream(&pcv->ib.dfnName, DF_READ,
                                    pcv->ib.type, &pcv->psstFrom);
            ClearReadAccess();
            olChkTo(EH_pdfi, sc);
            // Not optimally efficient, but reduces #ifdef's
            lstrcpyW(pcv->atcName, (WCHAR *)pcv->ib.dfnName.GetBuffer());

            //  Don't need to SetReadAccess here because pstgTo is an IStorage.

#ifdef MULTIHEAP
            {
                CSafeMultiHeap smh(_ppc);
                // if pstgTo is an IStorage proxy, then returned IStream
                // can be custom marshaled and allocator state is lost
#endif
            olHChkTo(EH_Get,
                     pstgTo->CreateStream(pcv->atcName, STGM_WRITE |
                                          STGM_SHARE_EXCLUSIVE |
                                          STGM_CREATE,
                                          0, 0, &pcv->pstTo));
#ifdef MULTIHEAP
            }
#endif
            olChkTo(EH_Create,
                    CopySStreamToIStream(pcv->psstFrom, pcv->pstTo));
            pcv->psstFrom->Release();
            pcv->pstTo->Release();
            break;

        default:
            olAssert(!aMsg("Unknown type in CopyDocFileToIStorage"));
            break;
        }
    }
    olDebugOut((DEB_ITRACE, "Out CopyDocFileToIStorage\n"));
    sc = S_OK;

 EH_pdfi:
 EH_Err:
    delete pcv;
    return sc;

 EH_Create:
    if (pcv->ib.type == STGTY_STORAGE)
        pcv->pstgToChild->Release();
    else
        pcv->pstTo->Release();
    olVerSucc(pstgTo->DestroyElement(pcv->atcName));
 EH_Get:
    if (pcv->ib.type == STGTY_STORAGE)
        pcv->pdfFromChild->Release();
    else
        pcv->psstFrom->Release();
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::Unmarshal, public
//
//  Synopsis:   Creates a duplicate DocFile from parts
//
//  Arguments:  [pstm] - Marshal stream
//              [ppv] - Object return
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    26-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CExposedDocFile::Unmarshal(IStream *pstm,
                                 void **ppv,
                                 DWORD mshlflags)
{
    SCODE sc;
    CDfMutex mtx;
    CPerContext *ppc;
    CPubDocFile *pdf;
    CGlobalContext *pgc;
    CDFBasis *pdfb;
    CExposedDocFile *pedf;
    IStorage *pstgStd = NULL;
    ULONG_PTR df;
    
#ifdef ASYNC
    DWORD dwAsyncFlags;
    IDocfileAsyncConnectionPoint *pdacp;
#endif
#ifdef POINTER_IDENTITY
    CMarshalList *pml;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::Unmarshal(%p, %p)\n",
                pstm, ppv));

#ifdef MULTIHEAP
    void *pvBaseOld;
    void *pvBaseNew;
    ContextId cntxid;
    CPerContext pcSharedMemory (NULL);          // bootstrap object
#endif

    //First unmarshal the standard marshalled version
    sc = CoUnmarshalInterface(pstm, IID_IStorage, (void**)&pstgStd);
    if (FAILED(sc))
    {
        // assume that entire standard marshaling stream has been read
        olAssert (pstgStd == NULL);
        sc = S_OK;
    }
    
#ifdef MULTIHEAP
    sc = UnmarshalSharedMemory(pstm, mshlflags, &pcSharedMemory, &cntxid);
    if (!SUCCEEDED(sc))
    {
#ifdef POINTER_IDENTITY
        UnmarshalPointer(pstm, (void **) &pedf);
#endif
        UnmarshalPointer(pstm, (void **)&pdf);
        UnmarshalPointer(pstm, (void **)&pdfb);
        UnmarshalPointer(pstm, (void **)&df);
#ifdef ASYNC
        ReleaseContext(pstm, TRUE, P_INDEPENDENT(df) != 0, mshlflags);
        ReleaseConnection(pstm, mshlflags);
#else
        ReleaseContext(pstm, P_INDEPENDENT(df), mshlflags);
#endif
        olChkTo(EH_std, sc);
    }
    pvBaseOld = DFBASEPTR;
#endif
#ifdef POINTER_IDENTITY
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **) &pedf));
#endif
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **)&pdf));
    olChkTo(EH_mem, CPubDocFile::Validate(pdf));
    olChkTo(EH_pdf, UnmarshalPointer(pstm, (void **)&pdfb));
    olChkTo(EH_pdfb, UnmarshalPointer(pstm, (void **) &df));
    olChkTo(EH_pdfb, UnmarshalPointer(pstm, (void **)&pgc));
    olChkTo(EH_pgc, ValidateBuffer(pgc, sizeof(CGlobalContext)));

    //So far, nothing has called into the tree so we don't really need
    //  to be holding the tree mutex.  The UnmarshalContext call does
    //  call into the tree, though, so we need to make sure this is
    //  threadsafe.  We'll do this my getting the mutex name from the
    //  CGlobalContext, then creating a new CDfMutex object.  While
    //  this is obviously not optimal, since it's possible we could
    //  reuse an existing CDfMutex, the reuse strategy isn't threadsafe
    //  since we can't do a lookup without the possibility of the thing
    //  we're looking for being released by another thread.
    TCHAR atcMutexName[CONTEXT_MUTEX_NAME_LENGTH];
    pgc->GetMutexName(atcMutexName);
    olChkTo(EH_pgc, mtx.Init(atcMutexName));
    olChkTo(EH_pgc, mtx.Take(INFINITE));

    //At this point we're holding the mutex.

#ifdef MULTIHEAP
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     cntxid,
                                     pdf->IsRoot()));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     cntxid,
                                     pdf->IsRoot()));
#endif
    if ((pvBaseNew = DFBASEPTR) != pvBaseOld)
    {
        pdf = (CPubDocFile*) ((ULONG_PTR)pdf - (ULONG_PTR)pvBaseOld
                                            + (ULONG_PTR)pvBaseNew);
        pedf = (CExposedDocFile*) ((ULONG_PTR)pedf - (ULONG_PTR)pvBaseOld
                                                  + (ULONG_PTR)pvBaseNew);
        pdfb = (CDFBasis*) ((ULONG_PTR)pdfb - (ULONG_PTR)pvBaseOld
                                           + (ULONG_PTR)pvBaseNew);
    }
#else
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     pdf->IsRoot()));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     P_INDEPENDENT(pdf->GetDFlags()),
                                     pdf->IsRoot()));
#endif //ASYNC
#endif

#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalConnection(pstm,
                                        &dwAsyncFlags,
                                        &pdacp,
                                        mshlflags));
#endif
    // if we use up 1Gig of address space, use standard unmarshaling
    if (gs_iSharedHeaps > (DOCFILE_SM_LIMIT / DOCFILE_SM_SIZE))
        olErr (EH_ppc, STG_E_INSUFFICIENTMEMORY);

#ifdef POINTER_IDENTITY
    olAssert (pedf != NULL);
    pml = (CMarshalList *) pedf;

    // Warning: these checks must remain valid across processes
    if (SUCCEEDED(pedf->Validate()) && pedf->GetPub() == pdf)
    {
        pedf = (CExposedDocFile *) pml->FindMarshal(GetCurrentContextId());
    }
    else
    {
        pml = NULL;
        pedf = NULL;
    }

    // exposed object is not found or has been deleted
    if (pedf == NULL)
    {
#endif
        olMemTo(EH_ppc, pedf = new (pdfb->GetMalloc())
                               CExposedDocFile(pdf, pdfb, ppc));
        olChkTo(EH_exp, pedf->InitMarshal(dwAsyncFlags, pdacp));
        //InitMarshal adds a reference.
        if (pdacp)
            pdacp->Release();

#ifdef POINTER_IDENTITY
        if (pml) pml->AddMarshal(pedf);
        pdf->vAddRef();  // CExposedDocFile ctor does not AddRef
    }
    else
    {
        pdfb->SetAccess(ppc);
        pedf->AddRef();         // reuse this object
        ppc->Release();         // reuse percontext
    }
#else
    pdf->vAddRef();
#endif

    *ppv = (void *)pedf;
#ifdef MULTIHEAP
    if (pvBaseOld != pvBaseNew)
    {
        pcSharedMemory.SetThreadAllocatorState(NULL);
        g_smAllocator.Uninit();           // delete the extra mapping
    }
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

    mtx.Release();

    //We're returning the custom marshalled version, so we don't need
    //the std marshalled one anymore.
    if (pstgStd != NULL)
        pstgStd->Release();

    olDebugOut((DEB_ITRACE, "Out CExposedDocFile::Unmarshal => %p\n", *ppv));
    return S_OK;
 EH_exp:
    pedf->Release();
    goto EH_Err;
 EH_ppc:
    ppc->Release();
 EH_mtx:
    mtx.Release();
    goto EH_Err;
 EH_pgc:
    CoReleaseMarshalData(pstm); // release the ILockBytes
    CoReleaseMarshalData(pstm); // release the ILockBytes
    if (P_INDEPENDENT(pdf->GetDFlags()))
        CoReleaseMarshalData(pstm); // release the ILockBytes
#ifdef ASYNC
    ReleaseConnection(pstm, mshlflags);
#endif

 EH_pdfb:
 EH_pdf:
 EH_mem:
EH_Err:
#ifdef MULTIHEAP
    pcSharedMemory.SetThreadAllocatorState(NULL);
    g_smAllocator.Uninit();   // delete the file mapping in error case
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif
 EH_std:
    if (pstgStd != NULL)
    {
        //We can return the standard marshalled version and still succeed.
        *ppv = pstgStd;
        return S_OK;
    }
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::GetUnmarshalClass(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPCLSID pcid)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::GetUnmarshalClass("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcid));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::GetUnmarshalClass:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this,
                pv, dwDestContext, pvDestContext, mshlflags, pcid));

    UNREFERENCED_PARM(pv);
    UNREFERENCED_PARM(mshlflags);

    olChk(ValidateOutBuffer(pcid, sizeof(CLSID)));
    memset(pcid, 0, sizeof(CLSID));
    olChk(ValidateIid(riid));
    olChk(Validate());
    olChk(_pdf->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetUnmarshalClass(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcid));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(VerifyIid(riid, IID_IStorage));
        *pcid = CLSID_DfMarshal;
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::GetUnmarshalClass\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::GetUnmarshalClass().  ret = %lx\n",
        this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::GetMarshalSizeMax(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPDWORD pcbSize)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    UNREFERENCED_PARM(pv);
    olLog(("%p::In  CExposedDocFile::GetMarshalSizeMax("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcbSize));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::GetMarshalSizeMax:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this,
                pv, dwDestContext, pvDestContext, mshlflags, pcbSize));

    olChk(Validate());
    olChk(_pdf->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcbSize));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        sc = GetStdMarshalSize(riid,
                               IID_IStorage,
                               dwDestContext,
                               pvDestContext,
                               mshlflags, pcbSize,
                               sizeof(CPubDocFile *)+sizeof(CDFBasis *)+
                               sizeof(DFLAGS),
#ifdef ASYNC
                               &_cpoint,
                               TRUE,
#endif
                               _ppc, P_INDEPENDENT(_pdf->GetDFlags()));
        DWORD cbSize = 0;
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  &cbSize));
            pmsh->Release();
            *pcbSize += cbSize;
        }
    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::GetMarshalSizeMax\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::GetMarshalSizeMax()."
           "*pcbSize == %lu, ret == %lx\n", this, *pcbSize, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::MarshalInterface(IStream *pstStm,
                                               REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::MarshalInterface("
           "%p, riid, %p, %lu, %p, %lu).  Context == %lX\n",
           this, pstStm, pv, dwDestContext,
           pvDestContext, mshlflags,(ULONG)GetCurrentContextId()));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::MarshalInterface:%p("
                "%p, riid, %p, %lu, %p, %lu)\n", this, pstStm, pv,
                dwDestContext, pvDestContext, mshlflags));

    UNREFERENCED_PARM(pv);

    olChk(Validate());
    olChk(_pdf->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->MarshalInterface(pstStm, riid, pv,
                                                 dwDestContext, pvDestContext,
                                                 mshlflags));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(StartMarshal(pstStm, riid, IID_IStorage, mshlflags));

        //Always standard marshal, in case we get an error during
        //unmarshalling of the custom stuff.
        {
            IMarshal *pmsh;
            if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                               dwDestContext, pvDestContext,
                                               mshlflags, &pmsh)))
            {
                sc = GetScode(pmsh->MarshalInterface(pstStm, riid, pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags));
                pmsh->Release();
            }
            olChk(sc);
        }
        
#ifdef MULTIHEAP
        olChk(MarshalSharedMemory(pstStm, _ppc));
#endif
#ifdef POINTER_IDENTITY
        olChk(MarshalPointer(pstStm, (CExposedDocFile*) GetNextMarshal()));
#endif
        olChk(MarshalPointer(pstStm, BP_TO_P(CPubDocFile *, _pdf)));
        olChk(MarshalPointer(pstStm, BP_TO_P(CDFBasis *, _pdfb)));
        olChk(MarshalPointer(pstStm, (void *) LongToPtr(_pdf->GetDFlags()) ));
#ifdef ASYNC
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             TRUE,
                             P_INDEPENDENT(_pdf->GetDFlags())));

        sc = MarshalConnection(pstStm,
                                &_cpoint,
                                dwDestContext,
                                pvDestContext,
                                mshlflags);
#else
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             P_INDEPENDENT(_pdf->GetDFlags())));
#endif

    }

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::MarshalInterface\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::MarshalInterface().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::UnmarshalInterface(IStream *pstStm,
                                                 REFIID riid,
                                                 void **ppvObj)
{
    olLog(("%p::INVALID CALL TO CExposedDocFile::UnmarshalInterface()\n",
           this));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::StaticReleaseMarshalData, public static
//
//  Synopsis:   Releases any references held in marshal data
//
//  Arguments:  [pstStm] - Marshal data stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Feb-94       DrewB   Created
//
//  Notes:      Assumes standard marshal header has already been read
//
//---------------------------------------------------------------


SCODE CExposedDocFile::StaticReleaseMarshalData(IStream *pstStm,
                                                DWORD mshlflags)
{
    SCODE sc;
    CPubDocFile *pdf;
    CDFBasis *pdfb;
    ULONG_PTR df;
#ifdef POINTER_IDENTITY
    CExposedDocFile *pedf;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedDocFile::StaticReleaseMarshalData:("
                "%p, %lX)\n", pstStm, mshlflags));

    //First unmarshal the standard marshalled version

    olChk(CoReleaseMarshalData(pstStm));
    // The final release of the exposed object may have shut down the
    // shared memory heap, so do not access shared memory after this point

    //Then do the rest of it.
#ifdef MULTIHEAP
    olChk(SkipSharedMemory(pstStm, mshlflags));
#endif
#ifdef POINTER_IDENTITY
    olChk(UnmarshalPointer(pstStm, (void **) &pedf));
#endif
    olChk(UnmarshalPointer(pstStm, (void **)&pdf));
    olChk(UnmarshalPointer(pstStm, (void **)&pdfb));
    olChk(UnmarshalPointer(pstStm, (void **)&df));
#ifdef ASYNC
    olChk(ReleaseContext(pstStm, TRUE,
                         P_INDEPENDENT(df) != 0,
                         mshlflags));
    olChk(ReleaseConnection(pstStm, mshlflags));
#else
    olChk(ReleaseContext(pstStm, P_INDEPENDENT(df), mshlflags));
#endif

#ifdef MULTIHEAP
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

    olDebugOut((DEB_ITRACE,
                "Out CExposedDocFile::StaticReleaseMarshalData\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    DWORD mshlflags;
    IID iid;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedDocFile::ReleaseMarshalData(%p)\n", this, pstStm));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::ReleaseMarshalData:%p(%p)\n",
                this, pstStm));

    olChk(Validate());
    olChk(_pdf->CheckReverted());
    olChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    olAssert(IsEqualIID(iid, IID_IStorage));
    sc = StaticReleaseMarshalData(pstStm, mshlflags);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::ReleaseMarshalData\n"));
EH_Err:
    olLog(("%p::Out CExposedDocFile::ReleaseMarshalData().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedDocFile::DisconnectObject(DWORD dwReserved)
{
    olLog(("%p::INVALID CALL TO CExposedDocFile::DisconnectObject()\n",
           this));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::SwitchToFile, public
//
//  Synopsis:   Switches the underlying file to another file
//
//  Arguments:  [ptcsFile] - New file name
//
//  Returns:    Appropriate status code
//
//  History:    08-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::SwitchToFile(OLECHAR *ptcsFile)
{

    ULONG ulOpenLock;
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedDocFile::SwitchToFile(" OLEFMT ")\n",
           this, ptcsFile));
    olDebugOut((DEB_TRACE, "In  CExposedDocFile::SwitchToFile:"
                "%p(" OLEFMT ")\n",
                this, ptcsFile));

    olChk(ValidateNameW(ptcsFile, _MAX_PATH));
    olChk(Validate());

    olChk(TakeSafeSem());
    olChk(_pdf->CheckReverted());
#ifdef COORD
    olAssert(_pdf->IsRoot() || _pdf->IsCoord());
#else
    olAssert(_pdf->IsRoot());
#endif

    SafeReadAccess();

    ulOpenLock = _ppc->GetOpenLock();
#ifdef COORD
    sc = _pdf->GetRoot()->SwitchToFile(ptcsFile,
                                       _ppc->GetOriginal(),
                                       &ulOpenLock);
#else
    sc = ((CRootPubDocFile *)(CPubDocFile*)_pdf)->SwitchToFile(ptcsFile,
                                                 _ppc->GetOriginal(),
                                                 &ulOpenLock);
#endif

    _ppc->SetOpenLock(ulOpenLock);

    olDebugOut((DEB_TRACE, "Out CExposedDocFile::SwitchToFile\n"));
 EH_Err:
    olLog(("%p::Out CExposedDocFile::SwitchToFile().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

#if WIN32 >= 300
             // IAccessControl methods
STDMETHODIMP CExposedDocFile::GrantAccessRights(ULONG cCount,
                                ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->GrantAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::SetAccessRights(ULONG cCount,
                              ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->SetAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::ReplaceAllAccessRights(ULONG cCount,
                                     ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->ReplaceAllAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::DenyAccessRights(ULONG cCount,
                              ACCESS_REQUEST pAccessRequestList[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->DenyAccessRights(cCount, pAccessRequestList);
}

STDMETHODIMP CExposedDocFile::RevokeExplicitAccessRights(ULONG cCount,
                                         TRUSTEE pTrustee[])
{
    olAssert((_pIAC != NULL));
    return _pIAC->RevokeExplicitAccessRights(cCount, pTrustee);
}

STDMETHODIMP CExposedDocFile::IsAccessPermitted(TRUSTEE *pTrustee,
                                 DWORD grfAccessPermissions)
{
    olAssert((_pIAC != NULL));
    return _pIAC->IsAccessPermitted(pTrustee, grfAccessPermissions);
}

STDMETHODIMP CExposedDocFile::GetEffectiveAccessRights(TRUSTEE *pTrustee,
                                       DWORD *pgrfAccessPermissions )
{
    olAssert((_pIAC != NULL));
    return _pIAC->GetEffectiveAccessRights(pTrustee, pgrfAccessPermissions);
}

STDMETHODIMP CExposedDocFile::GetExplicitAccessRights(ULONG *pcCount,
                                      PEXPLICIT_ACCESS *pExplicitAccessList)
{
    olAssert((_pIAC != NULL));
    return _pIAC->GetExplicitAccessRights(pcCount, pExplicitAccessList);
}

STDMETHODIMP CExposedDocFile::CommitAccessRights(DWORD grfCommitFlags)
{
    olAssert((_pIAC != NULL));
    return _pIAC->CommitAccessRights(grfCommitFlags);
}

STDMETHODIMP CExposedDocFile::RevertAccessRights()
{
    olAssert((_pIAC != NULL));
    return _pIAC->RevertAccessRights();
}



#endif // if WIN32 >= 300


#ifdef COORD
//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CommitPhase1, public
//
//  Synopsis:   Do phase 1 of an exposed two phase commit
//
//  Arguments:  [grfCommitFlags] -- Commit flags
//
//  Returns:    Appropriate status code
//
//  History:    08-Aug-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CExposedDocFile::CommitPhase1(DWORD grfCommitFlags)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olChk(VerifyCommitFlags(grfCommitFlags));
    olChk(Validate());

    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->CommitPhase1(grfCommitFlags,
                            &_ulLock,
                            &_sigMSF,
                            &_cbSizeBase,
                            &_cbSizeOrig);
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::CommitPhase2, public
//
//  Synopsis:   Do phase 2 of an exposed two phase commit
//
//  Arguments:  [grfCommitFlags] -- Commit flags
//              [fCommit] -- TRUE if transaction is to commit, FALSE if abort
//
//  Returns:    Appropriate status code
//
//  History:    08-Aug-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CExposedDocFile::CommitPhase2(DWORD grfCommitFlags,
                                    BOOL fCommit)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olChk(Validate());

    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif

    sc = _pdf->CommitPhase2(grfCommitFlags,
                            fCommit,
                            _ulLock,
                            _sigMSF,
                            _cbSizeBase,
                            _cbSizeOrig);

    _ulLock = _cbSizeBase = _cbSizeOrig = 0;
    _sigMSF = 0;
EH_Err:
    return sc;
}
#endif //COORD


#ifdef NEWPROPS

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::Lock, IBlockingLock
//
//  Synopsis:   Acquires the semaphore associated with the docfile.
//
//  Notes:      This member is called by CPropertyStorage.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CExposedDocFile::Lock(DWORD dwTimeout)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    TakeSem();
    SetDifferentBasisAccess(_pdfb, _ppc);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::Unlock, public IBlockingLock
//
//  Synopsis:   Releases the semaphore associated with the docfile.
//
//  Notes:      This member is called by CPropertyStorage.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CExposedDocFile::Unlock(VOID)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    ClearBasisAccess(_pdfb);
    ReleaseSem(S_OK);
    return( S_OK );
}
#endif

#ifdef DIRECTWRITERLOCK
//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::WaitForWriteAccess, public IDirectWriterLock
//
//  Synopsis:   tries to obtain exclusive write access in direct mode
//
//  Notes:      Tree mutex must be taken when accessing recursion count
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::WaitForWriteAccess (DWORD dwTimeout)
{
    SAFE_SEM;
    SAFE_ACCESS;
    HRESULT hr = TakeSafeSem();

    if (SUCCEEDED(hr) && *_ppc->GetRecursionCount() == 0)
    {
        SafeReadAccess();
        hr = _pdfb->WaitForWriteAccess (dwTimeout, _ppc->GetGlobal());
    }
    if (SUCCEEDED(hr)) ++(*_ppc->GetRecursionCount());
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::ReleaseWriteAccess, public IDirectWriterLock
//
//  Synopsis:   releases exclusive write access from WaitForWriteAccess
//
//  Notes:      Tree mutex must be taken when accessing recursion count
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::ReleaseWriteAccess ()
{
    SAFE_SEM;
    SAFE_ACCESS;
    HRESULT hr = TakeSafeSem();

    if (SUCCEEDED(hr) && *_ppc->GetRecursionCount() == 1)
    {
        SafeReadAccess();
        hr = _pdf->Commit(STGC_DEFAULT);  // Flush
        if (SUCCEEDED(hr)) hr = _pdfb->ReleaseWriteAccess();
    }
    if (SUCCEEDED(hr)) --(*_ppc->GetRecursionCount());
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CExposedDocFile::HaveWriteAccess, public IDirectWriterLock
//
//  Synopsis:   returns S_OK if write lock is active, S_FALSE if not
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CExposedDocFile::HaveWriteAccess ()
{
    SAFE_SEM;
    HRESULT hr = TakeSafeSem();

    olAssert(_pdfb->DirectWriterMode());
    if (SUCCEEDED(hr))
    {
        hr = (_pdfb->HaveWriteAccess()) ? S_OK : S_FALSE;
    }
    return hr;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedDocFile::ValidateWriteAccess, public
//
//  Synopsis:   returns whether writer currently has write access
//
//  Notes:      tree mutex must be taken
//
//  History:    30-Apr-96    HenryLee     Created
//
//---------------------------------------------------------------
HRESULT CExposedDocFile::ValidateWriteAccess()
{
    if (_pdf->GetTransactedDepth() >= 1)
        return S_OK;

    return (!_pdfb->DirectWriterMode() || (*_ppc->GetRecursionCount()) > 0) ?
            S_OK : STG_E_ACCESSDENIED;
};

#endif // DIRECTWRITERLOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\expst.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       expst.cxx
//
//  Contents:   CExposedStream code
//
//  History:    28-Feb-92   PhilipLa    Created.
//              20-Jun-96   MikeHill    Fixed the PropSet version of
//                                      Lock to check the result of TakeSem.
//              1-Jul-96    MikeHill    - Removed Win32 SEH from PropSet code.
//                                      - Receive NTPROP in propset Open method.
//              11-Feb-97   Danl        - Changed CMappedStream to IMappedStream
//                                      - Added QI support for IMappedStream.
//
//--------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <pbstream.hxx>
#include <expst.hxx>
#include <lock.hxx>
#include <seekptr.hxx>
#include <marshl.hxx>
#include <logfile.hxx>
#include <privguid.h>   // IID_IMappedStream
#include <expparam.hxx>

#ifndef LARGE_STREAMS
// Maximum stream size supported by exposed streams
// This is MAX_ULONG with one subtracted so that
// the seek pointer has a spot to sit even at the
// end of the stream
#define CBMAXSTREAM 0xfffffffeUL
// Maximum seek pointer value
#define CBMAXSEEK (CBMAXSTREAM+1)
#endif

#if DBG
DWORD MyGetLastError()
{
    return GetLastError();
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CExposedStream, public
//
//  Synopsis:   Empty object constructor
//
//  History:    30-Mar-92       DrewB   Created
//
//---------------------------------------------------------------



CExposedStream::CExposedStream(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::CExposedStream()\n"));
    _pdfb = NULL;
    _ppc = NULL;
    _cReferences = 0;
    _psp = NULL;
    _pst = NULL;
    olDebugOut((DEB_ITRACE, "Out CExposedStream::CExposedStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Init, public
//
//  Synopsis:   Base constructor
//
//  Arguments:  [pst] - Public stream
//              [pdfb] - DocFile basis
//              [ppc] - Context
//              [psp] - Seek pointer or NULL for new seek pointer
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CExposedStream::Init(CPubStream *pst,
                           CDFBasis *pdfb,
                           CPerContext *ppc,
                           CSeekPointer *psp)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CExposedStream::Init("
                "%p, %p, %p, %p)\n",
                pst, pdfb, ppc, psp));

    if (psp == NULL)
    {
        CSeekPointer *pspTemp;
        olMem(pspTemp = new (pdfb->GetMalloc()) CSeekPointer(0));
        _psp = P_TO_BP(CBasedSeekPointerPtr, pspTemp);
    }
    else
        _psp = P_TO_BP(CBasedSeekPointerPtr, psp);
    _ppc = ppc;
    _pst = P_TO_BP(CBasedPubStreamPtr, pst);
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _pdfb->vAddRef();
    _cReferences = 1;
    _sig = CEXPOSEDSTREAM_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Init\n"));
    return S_OK;

EH_Err:
    return sc;
}

SCODE CExposedStream::InitMarshal(CPubStream *pst,
                                  CDFBasis *pdfb,
                                  CPerContext *ppc,
                                  DWORD dwAsyncFlags,
                                  IDocfileAsyncConnectionPoint *pdacp,
                                  CSeekPointer *psp)
{
    SCODE sc;
    sc = CExposedStream::Init(pst,
                              pdfb,
                              ppc,
                              psp);
    if (SUCCEEDED(sc))
    {
        sc = _cpoint.InitMarshal(this, dwAsyncFlags, pdacp);
    }
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CExposedStream::~CExposedStream, public
//
//  Synopsis:   Destructor
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


CExposedStream::~CExposedStream(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedStream::~CExposedStream\n"));
    olAssert(_cReferences == 0);
    _sig = CEXPOSEDSTREAM_SIGDEL;

    //In order to call into the tree, we need to take the mutex.
    //The mutex may get deleted in _ppc->Release(), so we can't
    //release it here.  The mutex actually gets released in
    //CPerContext::Release() or in the CPerContext destructor.
    SCODE sc;

#if !defined(MULTIHEAP)
    // TakeSem and ReleaseSem are moved to the Release Method
    // so that the deallocation for this object is protected
    if (_ppc)
    {
        sc = TakeSem();
        SetWriteAccess();
        olAssert(SUCCEEDED(sc));
    }

#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP


    if (_pst)
        _pst->CPubStream::vRelease();
    if (_psp)
        _psp->CSeekPointer::vRelease();
    if (_pdfb)
        _pdfb->CDFBasis::vRelease();
#if !defined(MULTIHEAP)
    if (_ppc)
    {
        if (_ppc->Release() > 0)
            ReleaseSem(sc);
    }
#ifdef ASYNC
    //Mutex has been released, so we can release the connection point
    //  without fear of deadlock.
    if (pdacp != NULL)
        pdacp->Release();
#endif
#endif // MULTIHEAP


    olDebugOut((DEB_ITRACE, "Out CExposedStream::~CExposedStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Read, public
//
//  Synopsis:   Read from a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return number of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::Read(VOID HUGEP *pb, ULONG cb, ULONG *pcbRead)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    ULONG cbRead = 0;

    olLog(("%p::In  CExposedStream::Read(%p, %lu, %p)\n",
           this, pb, cb, pcbRead));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Read %p(%p, %lu, %p)\n",
                this, pb, cb, pcbRead));

    OL_VALIDATE(Read(pb, cb, pcbRead));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();
    sc = _pst->ReadAt(_psp->GetPos(), pb, cb, (ULONG STACKBASED *)&cbRead);
#ifndef LARGE_STREAMS
    olAssert(CBMAXSEEK-_psp->GetPos() >= cbRead);
#endif
    _psp->SetPos(_psp->GetPos()+cbRead);
    pb = (BYTE *)pb + cbRead;
    cb -= cbRead;
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Read => %lu\n", cbRead));

EH_Err:
    if (pcbRead)
    {
        // May fault and leave stream seek pointer changed
        // This is acceptable
        *pcbRead = cbRead;
        olLog(("%p::Out CExposedStream::Read().  *pcbRead == %lu, ret = %lx\n",
               this, *pcbRead, sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Read().  ret == %lx\n", this, sc));
    }

    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Write, public
//
//  Synopsis:   Write to a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Write(
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG *pcbWritten)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    ULONG cbWritten = 0;

    olLog(("%p::In  CExposedStream::Write(%p, %lu, %p)\n",
           this, pb, cb, pcbWritten));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Write %p(%p, %lu, %p)\n",
                this, pb, cb, pcbWritten));

    OL_VALIDATE(Write(pb, cb, pcbWritten));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif
    sc = _pst->WriteAt(_psp->GetPos(), pb, cb,
                       (ULONG STACKBASED *)&cbWritten);
#ifndef LARGE_STREAMS
    olAssert(CBMAXSEEK-_psp->GetPos() >= cbWritten);
#endif
    _psp->SetPos(_psp->GetPos()+cbWritten);
    pb = (BYTE *)pb + cbWritten;
    cb -= cbWritten;
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Write => %lu\n",
                cbWritten));
EH_Err:
    if (pcbWritten)
    {
        // May fault but that's acceptable
        *pcbWritten = cbWritten;
        olLog(("%p::Out CExposedStream::Write().  "
               "*pcbWritten == %lu, ret = %lx\n",
               this, *pcbWritten, sc));
    }
    else
    {
        olLog(("%p::Out CExposedStream::Write().  ret == %lx\n", this, sc));
    }

    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Seek(LARGE_INTEGER dlibMove,
                                  DWORD dwOrigin,
                                  ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
#ifdef LARGE_STREAMS
    LONGLONG lMove;
#else
    LONG lMove;
#endif
    ULARGE_INTEGER ulPos;

    olLog(("%p::In  CExposedStream::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Seek %p(%ld, %lu, %p)\n",
                this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));

    OL_VALIDATE(Seek(dlibMove, dwOrigin, plibNewPosition));
    
    if (dwOrigin == STREAM_SEEK_SET)
    {
#ifdef LARGE_STREAMS
        if (dlibMove.QuadPart < 0)
            olErr (EH_Err, STG_E_INVALIDFUNCTION);
#else
        // Truncate dlibMove to 32 bits
        // Make sure we don't seek too far
        if (LIGetHigh(dlibMove) != 0)
            LISet32(dlibMove, 0xffffffff);
#endif
    }
    else
    {
#ifndef LARGE_STREAMS
        // High dword must be zero for positive values or -1 for
        // negative values
        // Additionally, for negative values, the low dword can't
        // exceed -0x80000000 because the 32nd bit is the sign
        // bit
        if (LIGetHigh(dlibMove) > 0 ||
            (LIGetHigh(dlibMove) == 0 &&
             LIGetLow(dlibMove) >= 0x80000000))
            LISet32(dlibMove, 0x7fffffff);
        else if (LIGetHigh(dlibMove) < -1 ||
                 (LIGetHigh(dlibMove) == -1 &&
                  LIGetLow(dlibMove) <= 0x7fffffff))
            LISet32(dlibMove, 0x80000000);
#endif
    }

#ifdef LARGE_STREAMS
    lMove = dlibMove.QuadPart;
#else
    lMove = (LONG)LIGetLow(dlibMove);
#endif
    olChk(Validate());

    //ASYNC Note:  We probably don't need this pending loop in Seek
    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    olChk(_pst->CheckReverted());
    SafeReadAccess();

#ifdef LARGE_STREAMS
    ulPos.QuadPart = _psp->GetPos();
#else
    ULISet32(ulPos, _psp->GetPos());
#endif
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
#ifdef LARGE_STREAMS
        ulPos.QuadPart = lMove;
#else
        ULISetLow(ulPos, (ULONG)lMove);
#endif
        break;

    case STREAM_SEEK_END:
#ifdef LARGE_STREAMS
        ULONGLONG cbSize;
#else
        ULONG cbSize;
#endif
        olChk(_pst->GetSize(&cbSize));
        if (lMove < 0)
        {
#ifdef LARGE_STREAMS
            if ((ULONGLONG)(-lMove) > cbSize)
#else
            if ((ULONG)(-lMove) > cbSize)
#endif
                olErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
#ifdef LARGE_STREAMS
        ulPos.QuadPart = cbSize+lMove;
#else
        else if ((ULONG)lMove > CBMAXSEEK-cbSize)
            lMove = (LONG)(CBMAXSEEK-cbSize);
        ULISetLow(ulPos, cbSize+lMove);
#endif
        break;

    case STREAM_SEEK_CUR:
        if (lMove < 0)
        {
#ifdef LARGE_STREAMS
            if ((ULONGLONG)(-lMove) > _psp->GetPos())
#else
            if ((ULONG)(-lMove) > _psp->GetPos())
#endif
                olErr(EH_Err, STG_E_INVALIDFUNCTION);
        }
#ifdef LARGE_STREAMS
        ulPos.QuadPart = _psp->GetPos()+lMove;
#else
        else if ((ULONG)lMove > CBMAXSEEK-_psp->GetPos())
            lMove = (LONG)(CBMAXSEEK-_psp->GetPos());
        ULISetLow(ulPos, _psp->GetPos()+lMove);
#endif
        break;
    }
#ifdef LARGE_STREAMS
    _psp->SetPos(ulPos.QuadPart);
#else
    _psp->SetPos(ULIGetLow(ulPos));
#endif

    if (plibNewPosition)
        // May fault but that's acceptable
        *plibNewPosition = ulPos;
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Seek => %lu\n",
                ULIGetLow(ulPos)));
EH_Err:
    olLog(("%p::Out CExposedStream::Seek().  ulPos == %lu,  ret == %lx\n",
           this, ULIGetLow(ulPos), sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::SetSize(ULARGE_INTEGER ulNewSize)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedStream::SetSize(%lu)\n",
           this, ULIGetLow(ulNewSize)));
    olDebugOut((DEB_TRACE, "In  CExposedStream::SetSize %p(%lu)\n",
                this, ULIGetLow(ulNewSize)));

    OL_VALIDATE(SetSize(ulNewSize));
    
#ifndef LARGE_STREAMS
    if (ULIGetHigh(ulNewSize) != 0)
        olErr(EH_Err, STG_E_DOCFILETOOLARGE);
#endif
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();
#ifdef DIRECTWRITERLOCK
    olChk(ValidateWriteAccess());
#endif
#ifdef LARGE_STREAMS
    sc = _pst->SetSize(ulNewSize.QuadPart);
#else
    sc = _pst->SetSize(ULIGetLow(ulNewSize));
#endif
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::SetSize\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::SetSize().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::CopyTo, public
//
//  Synopsis:   Copies information from one stream to another
//
//  Arguments:  [pstm] - Destination
//              [cb] - Number of bytes to copy
//              [pcbRead] - Return number of bytes read
//              [pcbWritten] - Return number of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//              [pcbWritten]
//
//  History:    25-Mar-92       DrewB   Created
//              12-Jan-93       AlexT   Rewritten without recursion
//
//  Notes:      We do our best to handle overlap correctly.  This allows
//              CopyTo to be used to insert and remove space within a
//              stream.
//
//              In the error case, we make no gurantees as to the
//              validity of pcbRead, pcbWritten, or either stream's
//              seek position.
//
//---------------------------------------------------------------

STDMETHODIMP CExposedStream::CopyTo(IStream *pstm,
                                    ULARGE_INTEGER cb,
                                    ULARGE_INTEGER *pcbRead,
                                    ULARGE_INTEGER *pcbWritten)
{
    SCODE sc;
    SAFE_SEM;

    olLog(("%p::In  CExposedStream::CopyTo(%p, %lu, %p, %p)\n",
           this, pstm, ULIGetLow(cb), pcbRead, pcbWritten));
    olDebugOut((DEB_TRACE, "In  CExposedStream::CopyTo("
                "%p, %lu, %p, %p)\n", pstm, ULIGetLow(cb),
                pcbRead, pcbWritten));

    OL_VALIDATE(CopyTo(pstm, cb, pcbRead, pcbWritten));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());

    sc = CopyToWorker(pstm, cb, pcbRead, pcbWritten, &_ss);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::CopyTo => %lu, %lu\n",
                pcbRead ? ULIGetLow(*pcbRead) : 0,
                pcbWritten ? ULIGetLow(*pcbWritten) : 0));
EH_Err:
    return sc;
}

SCODE CExposedStream::CopyToWorker(IStream *pstm,
                                   ULARGE_INTEGER cb,
                                   ULARGE_INTEGER *pcbRead,
                                   ULARGE_INTEGER *pcbWritten,
                                   CSafeSem *pss)
{
    SCODE sc;
#ifdef LARGE_STREAMS
    ULONGLONG ulCopySize;
    ULONGLONG ulSrcSize, ulSrcOrig;
#else
    ULONG ulCopySize;
    ULONG ulSrcSize;
    ULONG ulSrcOrig;
#endif
    ULARGE_INTEGER uliDestOrig;
    LARGE_INTEGER liDestPos;
    BYTE *pb = NULL;
    BOOL fOverlap;
#ifdef LARGE_STREAMS
    ULONGLONG ulBytesCopied = 0;
#else
    ULONG ulBytesCopied = 0;
#endif
    ULONG ulBufferSize;

#ifdef LARGE_STREAMS
    ulCopySize = cb.QuadPart;
#else
    //  Bound the size of the copy
    //  1.  The maximum we can copy is 0xffffffff
    if (ULIGetHigh(cb) == 0)
        ulCopySize = ULIGetLow(cb);
    else
        ulCopySize = 0xffffffff;
#endif

    //  2.  We can only copy what's available in the source stream
    SetReadAccess();
    sc = _pst->GetSize(&ulSrcSize);
    ClearReadAccess();
    olChk(sc);

    ulSrcOrig = _psp->GetPos();
    if (ulSrcSize < ulSrcOrig)
    {
        //  Nothing in source to copy
        ulCopySize = 0;
    }
    else if ((ulSrcSize - ulSrcOrig) < ulCopySize)
    {
        //  Shrink ulCopySize to fit bytes in source
        ulCopySize = ulSrcSize - ulSrcOrig;
    }

    //  3.  We can only copy what will fit in the destination
    LISet32(liDestPos, 0);
    olHChk(pstm->Seek(liDestPos, STREAM_SEEK_CUR, &uliDestOrig));
#ifndef LARGE_STREAMS
    olAssert(ULIGetHigh(uliDestOrig) == 0);

    if (ulCopySize > CBMAXSEEK - ULIGetLow(uliDestOrig))
        ulCopySize = CBMAXSEEK - ULIGetLow(uliDestOrig);
#endif

    ulBufferSize = (_pdfb->GetOpenFlags() & DF_LARGE) ?
                    LARGESTREAMBUFFERSIZE : STREAMBUFFERSIZE;
    //  We are allowed to fail here with out-of-memory
    olChk(GetBuffer(STREAMBUFFERSIZE, ulBufferSize, &pb, &ulBufferSize));

    // Since we have no reliable way to determine if the source and
    // destination represent the same stream, we assume they
    // do and always handle overlap.

#ifdef LARGE_STREAMS
    fOverlap = (uliDestOrig.QuadPart > ulSrcOrig &&
                uliDestOrig.QuadPart < ulSrcOrig + ulCopySize);
#else
    fOverlap = (ULIGetLow(uliDestOrig) > ulSrcOrig &&
                ULIGetLow(uliDestOrig) < ulSrcOrig + ulCopySize);
#endif

#ifdef LARGE_STREAMS
    ULONGLONG ulSrcCopyOffset;
    ULONGLONG ulDstCopyOffset;
#else
    ULONG ulSrcCopyOffset;
    ULONG ulDstCopyOffset;
#endif
    if (fOverlap)
    {
        //  We're going to copy back to front, so determine the
        //  stream end positions
        ulSrcCopyOffset = ulSrcOrig + ulCopySize;

        //  uliDestOrig is the destination starting offset
#ifdef LARGE_STREAMS
        ulDstCopyOffset = uliDestOrig.QuadPart + ulCopySize;
#else
        ulDstCopyOffset = ULIGetLow(uliDestOrig) + ulCopySize;
#endif
    }

    while (ulCopySize > 0)
    {
        //  We can only copy up to ulBufferSize bytes at a time
        ULONG cbPart = (ULONG) min(ulCopySize, ulBufferSize);

        if (fOverlap)
        {
            //  We're copying back to front so we need to seek to
            //  set up the streams correctly

            ulSrcCopyOffset -= cbPart;
            ulDstCopyOffset -= cbPart;

            //  Set source stream position
            _psp->SetPos(ulSrcCopyOffset);

            //  Set destination stream position
            liDestPos.QuadPart = ulDstCopyOffset;
            olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
        }

        ULONG ulRead = 0;
        SetReadAccess();
        sc = _pst->ReadAt(_psp->GetPos(), pb, cbPart, &ulRead);
        ClearReadAccess();
#ifndef LARGE_STREAMS
        olAssert(CBMAXSEEK-_psp->GetPos() >= ulRead);
#endif
        _psp->SetPos(_psp->GetPos()+ulRead);
        olChk(sc);

        if (cbPart != ulRead)
        {
            //  There was no error, but we were unable to read cbPart
            //  bytes.  Something's wrong (the underlying ILockBytes?)
            //  but we can't control it;  just return an error.
            olErr(EH_Err, STG_E_READFAULT);
        }

        // We release the tree mutex before calling out to Write
        // to avoid a deadlock in the async FillAppend method
        ULONG ulWritten;
        SCODE sc2;
        pss->Release();
        sc2 = pstm->Write(pb, cbPart, &ulWritten);
        olChk(pss->Take());
        olChk (sc2);
        if (cbPart != ulWritten)
        {
            //  There was no error, but we were unable to write
            //  ulWritten bytes.  We can't trust the pstm
            //  implementation, so all we can do here is return
            //  an error.
            olErr(EH_Err, STG_E_WRITEFAULT);
        }

        olAssert(ulCopySize >= cbPart);
        ulCopySize -= cbPart;
        ulBytesCopied += cbPart;
    }

    if (fOverlap)
    {
        //  Set the seek pointers to the correct location
        _psp->SetPos(ulSrcOrig + ulBytesCopied);

        liDestPos.QuadPart = uliDestOrig.QuadPart + ulBytesCopied;
        olHChk(pstm->Seek(liDestPos, STREAM_SEEK_SET, NULL));
    }

    // Fall through

EH_Err:
    DfMemFree(pb);

    if (pcbRead)
        pcbRead->QuadPart = ulBytesCopied;
    if (pcbWritten)
        pcbWritten->QuadPart = ulBytesCopied;

    olLog(("%p::Out CExposedStream::CopyTo().  "
           "cbRead == %lu, cbWritten == %lu, ret == %lx\n",
           this, pcbRead ? ULIGetLow(*pcbRead) : 0,
           pcbWritten ? ULIGetLow(*pcbWritten) : 0, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created from pbstream source
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedStream::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CExposedStream::Release()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Release()\n"));

    if (FAILED(Validate()))
        return 0;
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
#ifdef MULTIHEAP
        CSafeMultiHeap smh(_ppc);
        CPerContext *ppc = _ppc;
        SCODE sc = S_OK;
        if (_ppc)
        {
            sc = TakeSem();
            SetWriteAccess();
            olAssert(SUCCEEDED(sc));
        }
#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP
        delete this;
#ifdef MULTIHEAP
        if (ppc)
        {
            if (ppc->Release() == 0)
                g_smAllocator.Uninit();
            else
                if (SUCCEEDED(sc)) ppc->UntakeSem();
        }
#ifdef ASYNC
        //Mutex has been released, so we can release the connection point
        //  without fear of deadlock.
        if (pdacp != NULL)
            pdacp->Release();
#endif
#endif
    }
    else if (lRet < 0)
        lRet = 0;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Release %p()=> %lu\n",
                this, lRet));
    olLog(("%p::Out CExposedStream::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    STATSTGW stat;

    olLog(("%p::In  CExposedStream::Stat(%p)\n", this, pstatstg));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Stat(%p)\n",
                pstatstg));

    OL_VALIDATE(Stat(pstatstg, grfStatFlag));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeReadAccess();

    sc = _pst->Stat(&stat, grfStatFlag);
    END_PENDING_LOOP;

    if (SUCCEEDED(sc))
    {
        TRY
        {
            *pstatstg = stat;
            pstatstg->type = STGTY_STREAM;
            pstatstg->grfLocksSupported = 0;
            pstatstg->STATSTG_dwStgFmt = 0;
            pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwHighDateTime = 0;
            pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwHighDateTime = 0;
            pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        }
        CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            if (stat.pwcsName)
                TaskMemFree(stat.pwcsName);
            sc = STG_E_INVALIDPOINTER;
        }
        END_CATCH
    }
    olDebugOut((DEB_TRACE, "Out CExposedStream::Stat\n"));
    // Fall through

EH_Err:
    olLog(("%p::Out CExposedStream::Stat().  ret == %lx\n",
           this, sc));
    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Clone, public
//
//  Synopsis:   Clones a stream
//
//  Returns:    Appropriate status code
//
//  History:    28-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Clone(IStream **ppstm)
{
    SafeCExposedStream pst;
    CSeekPointer *psp;
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olLog(("%p::In  CExposedStream::Clone(%p)\n", this, ppstm));
    olDebugOut((DEB_TRACE, "In  CExposedStream::Clone(%p)\n", ppstm));

    OL_VALIDATE(Clone(ppstm));
    
    olChk(Validate());
    olChk(TakeSafeSem());
    olChk(_pst->CheckReverted());
    SafeReadAccess();
    olMem(psp = new (_pdfb->GetMalloc()) CSeekPointer(_psp->GetPos()));
    pst.Attach(new (_pdfb->GetMalloc()) CExposedStream);
    olMemTo(EH_psp, (CExposedStream *)pst);
    olChkTo(EH_pst, pst->Init(BP_TO_P(CPubStream *, _pst),
                              BP_TO_P(CDFBasis *, _pdfb),
                              _ppc, psp));

    _ppc->AddRef();
    _pst->vAddRef();
#ifdef ASYNC
    if (_cpoint.IsInitialized())
    {
        olChkTo(EH_pstInit, pst->InitClone(&_cpoint));
    }
#endif
    TRANSFER_INTERFACE(pst, IStream, ppstm);

    olDebugOut((DEB_TRACE, "Out CExposedStream::Clone => %p\n", *ppstm));

 EH_Err:
    olLog(("%p::Out CExposedStream::Clone().  *ppstm == %p, ret == %lx\n",
           this, *ppstm, sc));
    return ResultFromScode(sc);
EH_pstInit:
    pst->Release();
    goto EH_Err;
EH_pst:
    delete pst;
EH_psp:
    psp->vRelease();
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedStream::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CExposedStream::AddRef()\n", this));
    olDebugOut((DEB_TRACE, "In  CExposedStream::AddRef()\n"));

    if (FAILED(Validate()))
        return 0;
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;

    olDebugOut((DEB_TRACE, "Out CExposedStream::AddRef %p() => %lu\n",
                this, _cReferences));
    olLog(("%p::Out CExposedStream::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::LockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    olDebugOut((DEB_TRACE, "In  CExposedStream::LockRegion("
                "%lu, %lu\n", ULIGetLow(cb), dwLockType));
    olDebugOut((DEB_TRACE, "Out CExposedStream::LockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::LockRegion()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::UnlockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    olDebugOut((DEB_TRACE, "In  CExposedStream::UnlockRegion(%lu, %lu)\n",
                ULIGetLow(cb), dwLockType));
    olDebugOut((DEB_TRACE, "Out CExposedStream::UnlockRegion\n"));
    olLog(("%p::INVALID CALL TO CExposedStream::UnlockRegion()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Commit, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Commit(DWORD grfCommitFlags)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;

    olDebugOut((DEB_TRACE, "In  CExposedStream::Commit(%lu)\n",
                grfCommitFlags));
    olLog(("%p::In  CExposedStream::Commit(%lx)\n", this, grfCommitFlags));

    OL_VALIDATE(Commit(grfCommitFlags));
    
    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SafeWriteAccess();

    sc = _pst->Commit(grfCommitFlags);
    END_PENDING_LOOP;

    olDebugOut((DEB_TRACE, "Out CExposedStream::Commit\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::Commit().  ret == %lx\n", this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Revert, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::Revert(void)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedStream::Revert()\n"));

    OL_VALIDATE(Revert());
    
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    //ASYNC Note:  Don't need pending loop here.
    sc = _pst->CheckReverted();
    olDebugOut((DEB_TRACE, "Out CExposedStream::Revert\n"));
    olLog(("%p::In  CExposedStream::Revert()\n", this));
    olLog(("%p::Out CExposedStream::Revert().  ret == %lx", this, sc));

    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::QueryInterface(?, %p)\n",
           this, ppvObj));
    olDebugOut((DEB_TRACE, "In  CExposedStream::QueryInterface(?, %p)\n",
                ppvObj));


    OL_VALIDATE(QueryInterface(iid, ppvObj));

    olChk(Validate());
    olChk(_pst->CheckReverted());

    sc = S_OK;
    if (IsEqualIID(iid, IID_IStream) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStream *)this;
        AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        //If the ILockBytes we'd need to marshal doesn't support IMarshal
        //  then we want to do standard marshalling on the stream, mostly
        //  to prevent deadlock problems but also because you'll get better
        //  performance.  So check, then do the right thing.

        IMarshal *pim;
        ILockBytes *plkb;
        plkb = _ppc->GetOriginal();
        if (plkb == NULL)
        {
            plkb = _ppc->GetBase();
        }

        sc = plkb->QueryInterface(IID_IMarshal, (void **)&pim);
        if (FAILED(sc))
        {
            olErr(EH_Err, E_NOINTERFACE);
        }
        pim->Release();

#ifdef MULTIHEAP
        if (_ppc->GetHeapBase() == NULL)
            olErr (EH_Err, E_NOINTERFACE);
#endif

        *ppvObj = (IMarshal *)this;
        AddRef();
    }
    else if (IsEqualIID(iid, IID_IMappedStream))
    {
        *ppvObj = (IMappedStream *)this;
        AddRef();
    }
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IConnectionPointContainer) &&
              _cpoint.IsInitialized())
    {
        *ppvObj = (IConnectionPointContainer *)this;
        CExposedStream::AddRef();
    }
#endif

    else
        sc = E_NOINTERFACE;

    olDebugOut((DEB_TRACE, "Out CExposedStream::QueryInterface => %p\n",
                *ppvObj));
EH_Err:
    olLog(("%p::Out CExposedStream::QueryInterface().  "
           "*ppvObj == %p, ret == %lx\n", this, *ppvObj, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::Unmarshal, public
//
//  Synopsis:   Creates a duplicate stream from parts
//
//  Arguments:  [pstm] - Marshal stream
//              [ppv] - Object return
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    26-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CExposedStream::Unmarshal(IStream *pstm,
                                void **ppv,
                                DWORD mshlflags)
{
    SCODE sc;
    CDfMutex mtx;
    CPerContext *ppc;
    CPubStream *pst;
    CDFBasis *pdfb;
    CGlobalContext *pgc;
    CExposedStream *pest;
    CSeekPointer *psp;
    IStream *pstmStd = NULL;
#ifdef ASYNC
    DWORD dwAsyncFlags;
    IDocfileAsyncConnectionPoint *pdacp;
#endif
#ifdef POINTER_IDENTITY
    CMarshalList *pml;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedStream::Unmarshal(%p, %p, %lu)\n",
                pstm, ppv, mshlflags));

#ifdef MULTIHEAP
    void *pvBaseOld;
    void *pvBaseNew;
    ContextId cntxid;
    CPerContext pcSharedMemory (NULL);          // bootstrap object
#endif

    //First unmarshal the standard marshalled version
    sc = CoUnmarshalInterface(pstm, IID_IStream, (void **)&pstmStd);
    if (FAILED(sc))
    {
        // assume that entire standard marshaling stream has been read
        olAssert (pstmStd == NULL);
        sc = S_OK;
    }

#ifdef MULTIHEAP
    sc = UnmarshalSharedMemory(pstm, mshlflags, &pcSharedMemory, &cntxid);
    if (!SUCCEEDED(sc))
    {
#ifdef POINTER_IDENTITY
        UnmarshalPointer(pstm, (void **) &pest);
#endif
        UnmarshalPointer(pstm, (void **)&pst);
        UnmarshalPointer(pstm, (void **)&pdfb);
        UnmarshalPointer(pstm, (void **)&psp);
#ifdef ASYNC
        ReleaseContext(pstm, TRUE, FALSE, mshlflags);
        ReleaseConnection(pstm, mshlflags);
#else
        ReleaseContext(pstStm, FALSE, mshlflags);
#endif
        olChkTo(EH_std, sc);
    }
    pvBaseOld = DFBASEPTR;
#endif
#ifdef POINTER_IDENTITY
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **)&pest));
#endif
    olChkTo(EH_mem, UnmarshalPointer(pstm, (void **)&pst));
    olChkTo(EH_mem, ValidateBuffer(pst, sizeof(CPubStream)));
    olChkTo(EH_pst, UnmarshalPointer(pstm, (void **)&pdfb));
    olChkTo(EH_pdfb, UnmarshalPointer(pstm, (void **)&psp));
    olChkTo(EH_psp, UnmarshalPointer(pstm, (void **)&pgc));
    olChkTo(EH_pgc, ValidateBuffer(pgc, sizeof(CGlobalContext)));

    //So far, nothing has called into the tree so we don't really need
    //  to be holding the tree mutex.  The UnmarshalContext call does
    //  call into the tree, though, so we need to make sure this is
    //  threadsafe.  We'll do this my getting the mutex name from the
    //  CGlobalContext, then creating a new CDfMutex object.  While
    //  this is obviously not optimal, since it's possible we could
    //  reuse an existing CDfMutex, the reuse strategy isn't threadsafe
    //  since we can't do a lookup without the possibility of the thing
    //  we're looking for being released by another thread.
    TCHAR atcMutexName[CONTEXT_MUTEX_NAME_LENGTH];
    pgc->GetMutexName(atcMutexName);
    olChkTo(EH_pgc, mtx.Init(atcMutexName));
    olChkTo(EH_pgc, mtx.Take(INFINITE));

    //At this point we're holding the mutex.
#ifdef MULTIHEAP
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     FALSE,
                                     cntxid,
                                     FALSE));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     FALSE,
                                     cntxid,
                                     FALSE));
#endif
    if ((pvBaseNew = DFBASEPTR) != pvBaseOld)
    {
        pst = (CPubStream*) ((ULONG_PTR)pst - (ULONG_PTR)pvBaseOld 
                                           + (ULONG_PTR)pvBaseNew);
        pest = (CExposedStream*) ((ULONG_PTR)pest - (ULONG_PTR)pvBaseOld
                                                 + (ULONG_PTR)pvBaseNew);
        pdfb = (CDFBasis*) ((ULONG_PTR)pdfb - (ULONG_PTR)pvBaseOld
                                           + (ULONG_PTR)pvBaseNew);
        psp = (CSeekPointer*) ((ULONG_PTR)psp - (ULONG_PTR)pvBaseOld 
                                             + (ULONG_PTR)pvBaseNew);
    }
#else
#ifdef ASYNC
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     TRUE,
                                     FALSE,
                                     FALSE));
#else
    olChkTo(EH_mtx, UnmarshalContext(pstm,
                                     pgc,
                                     &ppc,
                                     mshlflags,
                                     FALSE,
                                     FALSE));
#endif //ASYNC
#endif
#ifdef ASYNC
    olChkTo(EH_ppc, UnmarshalConnection(pstm,
                                        &dwAsyncFlags,
                                        &pdacp,
                                        mshlflags));
#endif

    // if we use up 1Gig of address space, use standard unmarshaling
    if (gs_iSharedHeaps > (DOCFILE_SM_LIMIT / DOCFILE_SM_SIZE))
        olErr (EH_ppc, STG_E_INSUFFICIENTMEMORY);

#ifdef POINTER_IDENTITY
    olAssert (pest != NULL);
    pml = (CMarshalList *) pest;

    // Warning: these checks must remain valid across processes
    if (SUCCEEDED(pest->Validate()) && pest->GetPub() == pst)
    {
        pest = (CExposedStream *) pml->FindMarshal(GetCurrentContextId());
    }
    else
    {
        pml = NULL;
        pest = NULL;
    }

    if (pest == NULL)
    {
#endif
        olMemTo(EH_ppc, pest = new (pdfb->GetMalloc()) CExposedStream);
#ifdef ASYNC
        olChkTo(EH_pest, pest->InitMarshal(pst,
                                           pdfb,
                                           ppc,
                                           dwAsyncFlags,
                                           pdacp,
                                           psp));
        //InitMarshal adds a reference on pdacp.
        if (pdacp)
            pdacp->Release();
#else
        olChkTo(EH_pest, pest->Init(pst, pdfb, ppc, psp));
#endif
#ifdef POINTER_IDENTITY
        if (pml) pml->AddMarshal(pest);
        pst->vAddRef();  // CExposedStream::Init does not AddRef
        psp->vAddRef();
    }
    else
    {
        pdfb->SetAccess(ppc);
        pest->AddRef();         // reuse this object
        ppc->Release();         // reuse percontext
    }
#else
    pst->vAddRef();
    psp->vAddRef();
#endif

    *ppv = pest;
#ifdef MULTIHEAP
    if (pvBaseOld != pvBaseNew)
    {
        pcSharedMemory.SetThreadAllocatorState(NULL);
        g_smAllocator.Uninit();           // delete the extra mapping
    }
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

    mtx.Release();

    //We're returning the custom marshalled version, so release the
    //standard marshalled one.
    if (pstmStd != NULL)
        pstmStd->Release();
    
    olDebugOut((DEB_ITRACE, "Out CExposedStream::Unmarshal => %p\n", *ppv));
    return S_OK;

 EH_pest:
    delete pest;
 EH_ppc:
    ppc->Release();
 EH_mtx:
    mtx.Release();
    goto EH_Err;
 EH_pgc:
    CoReleaseMarshalData(pstm); // release the ILockBytes
    CoReleaseMarshalData(pstm); // release the ILockBytes
#ifdef ASYNC
    ReleaseConnection(pstm, mshlflags);
#endif
 EH_psp:
 EH_pdfb:
 EH_pst:
EH_mem:
EH_Err:
#ifdef MULTIHEAP
    pcSharedMemory.SetThreadAllocatorState(NULL);
    g_smAllocator.Uninit();   // delete the file mapping in error case
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif

 EH_std:
    if (pstmStd != NULL)
    {
        //We can return the standard marshalled version instead of an error.
        *ppv = pstmStd;
        return S_OK;
    }
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::GetUnmarshalClass(REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags,
                                               LPCLSID pcid)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::GetUnmarshalClass("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcid));
    olDebugOut((DEB_TRACE, "In  CExposedStream::GetUnmarshalClass:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this, pv, dwDestContext,
                pvDestContext, mshlflags, pcid));

    UNREFERENCED_PARM(pv);
    UNREFERENCED_PARM(mshlflags);

    olChk(ValidateOutBuffer(pcid, sizeof(CLSID)));
    memset(pcid, 0, sizeof(CLSID));
    olChk(ValidateIid(riid));
    olChk(Validate());
    olChk(_pst->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetUnmarshalClass(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcid));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(VerifyIid(riid, IID_IStream));
        *pcid = CLSID_DfMarshal;
    }

    olDebugOut((DEB_TRACE, "Out CExposedStream::GetUnmarshalClass\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::GetUnmarshalClass().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::GetMarshalSizeMax(REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags,
                                               LPDWORD pcbSize)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    UNREFERENCED_PARM(pv);
    olLog(("%p::In  CExposedStream::GetMarshalSizeMax("
           "riid, %p, %lu, %p, %lu, %p)\n",
           this, pv, dwDestContext, pvDestContext, mshlflags, pcbSize));
    olDebugOut((DEB_TRACE, "In  CExposedStream::GetMarshalSizeMax:%p("
                "riid, %p, %lu, %p, %lu, %p)\n", this, pv, dwDestContext,
                pvDestContext, mshlflags, pcbSize));

    olChk(Validate());
    olChk(_pst->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  pcbSize));
            pmsh->Release();
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        sc = GetStdMarshalSize(riid, IID_IStream, dwDestContext, pvDestContext,
                               mshlflags, pcbSize,
                               sizeof(CPubStream *)+sizeof(CDFBasis *)+
                               sizeof(CSeekPointer *),
#ifdef ASYNC
                               &_cpoint,
                               TRUE,
#endif
                               _ppc, FALSE);
        DWORD cbSize = 0;
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                  pvDestContext, mshlflags,
                                                  &cbSize));
            pmsh->Release();
            *pcbSize += cbSize;
        }
    }

    olDebugOut((DEB_TRACE, "Out CExposedStream::GetMarshalSizeMax\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::GetMarshalSizeMax().  *pcbSize == %lu, "
           "ret == %lx\n", this, *pcbSize, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::MarshalInterface(IStream *pstStm,
                                              REFIID riid,
                                              void *pv,
                                              DWORD dwDestContext,
                                              LPVOID pvDestContext,
                                              DWORD mshlflags)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::MarshalInterface("
           "%p, riid, %p, %lu, %p, %lu).  Context == %lX\n",
           this, pstStm, pv, dwDestContext, pvDestContext,
           mshlflags, (ULONG)GetCurrentContextId()));
    olDebugOut((DEB_TRACE, "In  CExposedStream::MarshalInterface:%p("
                "%p, riid, %p, %lu, %p, %lu)\n", this, pstStm, pv,
                dwDestContext, pvDestContext, mshlflags));

    UNREFERENCED_PARM(pv);

    olChk(Validate());
    olChk(_pst->CheckReverted());

    if ((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
    {
        IMarshal *pmsh;

        if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags, &pmsh)))
        {
            sc = GetScode(pmsh->MarshalInterface(pstStm, riid, pv,
                                                 dwDestContext, pvDestContext,
                                                 mshlflags));
            pmsh->Release();
            olChk(sc);
        }
    }
    else if (pvDestContext != NULL)
    {
        sc = STG_E_INVALIDPARAMETER;
    }
    else
    {
        olChk(StartMarshal(pstStm, riid, IID_IStream, mshlflags));

        //Always standard marshal, in case we get an error during
        //unmarshalling of the custom stuff.
        {
            IMarshal *pmsh;
            if (SUCCEEDED(sc = CoGetStandardMarshal(riid, (IUnknown *)pv,
                                               dwDestContext, pvDestContext,
                                               mshlflags, &pmsh)))
            {
                sc = pmsh->MarshalInterface(pstStm, riid, pv,
                                                dwDestContext, pvDestContext,
                                                mshlflags);
                pmsh->Release();
            }
            olChk(sc);
        }
            
#ifdef MULTIHEAP
        olChk(MarshalSharedMemory(pstStm, _ppc));
#endif
#ifdef POINTER_IDENTITY
        olChk(MarshalPointer(pstStm, (CExposedStream*) GetNextMarshal()));
#endif
        olChk(MarshalPointer(pstStm, BP_TO_P(CPubStream *, _pst)));
        olChk(MarshalPointer(pstStm, BP_TO_P(CDFBasis *, _pdfb)));
        olChk(MarshalPointer(pstStm, BP_TO_P(CSeekPointer *, _psp)));
#ifdef ASYNC
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             TRUE,
                             FALSE));
#else
        olChk(MarshalContext(pstStm,
                             _ppc,
                             dwDestContext,
                             pvDestContext,
                             mshlflags,
                             FALSE));
#endif

#ifdef ASYNC
        olChk(MarshalConnection(pstStm,
                                &_cpoint,
                                dwDestContext,
                                pvDestContext,
                                mshlflags));
#endif
    }

    olDebugOut((DEB_TRACE, "Out CExposedStream::MarshalInterface\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::MarshalInterface().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::UnmarshalInterface(IStream *pstStm,
                                                REFIID riid,
                                                void **ppvObj)
{
    olLog(("%p::INVALID CALL TO CExposedStream::UnmarshalInterface()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::StaticReleaseMarshalData, public static
//
//  Synopsis:   Releases any references held in marshal data
//
//  Arguments:  [pstStm] - Marshal data stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Feb-94       DrewB   Created
//
//  Notes:      Assumes standard marshal header has already been read
//
//---------------------------------------------------------------


SCODE CExposedStream::StaticReleaseMarshalData(IStream *pstStm,
                                               DWORD mshlflags)
{
    SCODE sc;
    CPubStream *pst;
    CDFBasis *pdfb;
    CSeekPointer *psp;
#ifdef POINTER_IDENTITY
    CExposedStream *pest;
#endif

    olDebugOut((DEB_ITRACE, "In  CExposedStream::StaticReleaseMarshalData:("
                "%p, %lX)\n", pstStm, mshlflags));

    //First release the standard marshalled stuff
    olChk(CoReleaseMarshalData(pstStm));
    // The final release of the exposed object may have shut down the
    // shared memory heap, so do not access shared memory after this point

    //Then do the rest of it
#ifdef MULTIHEAP
    olChk(SkipSharedMemory(pstStm, mshlflags));
#endif
#ifdef POINTER_IDENTITY
    olChk(UnmarshalPointer(pstStm, (void **) &pest));
#endif
    olChk(UnmarshalPointer(pstStm, (void **)&pst));
    olChk(UnmarshalPointer(pstStm, (void **)&pdfb));
    olChk(UnmarshalPointer(pstStm, (void **)&psp));
#ifdef ASYNC
    olChk(ReleaseContext(pstStm, TRUE, FALSE, mshlflags));
    olChk(ReleaseConnection(pstStm, mshlflags));
#else
    olChk(ReleaseContext(pstStm, FALSE, mshlflags));
#endif

#ifdef MULTIHEAP
    g_smAllocator.SetState(NULL, NULL, 0, NULL, NULL);
#endif
    olDebugOut((DEB_ITRACE,
                "Out CExposedStream::StaticReleaseMarshalData\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] - Stream
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    DWORD mshlflags;
    IID iid;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olLog(("%p::In  CExposedStream::ReleaseMarshalData(%p)\n", this, pstStm));
    olDebugOut((DEB_TRACE, "In  CExposedStream::ReleaseMarshalData:%p(%p)\n",
                this, pstStm));

    olChk(Validate());
    olChk(_pst->CheckReverted());
    olChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    olAssert(IsEqualIID(iid, IID_IStream));
    sc = StaticReleaseMarshalData(pstStm, mshlflags);

    olDebugOut((DEB_TRACE, "Out CExposedStream::ReleaseMarshalData\n"));
EH_Err:
    olLog(("%p::Out CExposedStream::ReleaseMarshalData().  ret == %lx\n",
           this, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedStream::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedStream::DisconnectObject(DWORD dwReserved)
{
    olLog(("%p::INVALID CALL TO CExposedStream::DisconnectObject()\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

#ifdef NEWPROPS
//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Open
//
//  Synopsis:   Opens mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Gets the size of the underlying stream and reads it
//              into memory so that it can be "mapped."
//
//--------------------------------------------------------------------

VOID CExposedStream::Open(IN VOID *powner, LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Open(powner, phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Close
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Does nothing because the object may be mapped in
//              another process.
//
//--------------------------------------------------------------------

VOID CExposedStream::Close(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Close(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::ReOpen
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Combined open and map.
//
//--------------------------------------------------------------------

VOID CExposedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().ReOpen(ppv,phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Quiesce
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Meaningless for docfile mapped stream.
//
//--------------------------------------------------------------------

VOID CExposedStream::Quiesce(VOID)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Quiesce();
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Map
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Return the address of the "mapping" buffer.
//
//--------------------------------------------------------------------

VOID CExposedStream::Map(BOOLEAN fCreate, VOID **ppv)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Map(fCreate, ppv);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Unmap
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:      Unmapping is merely zeroing the pointer.  We don't
//              flush because that's done explicitly by the
//              CPropertyStorage class.
//
//
//--------------------------------------------------------------------

VOID CExposedStream::Unmap(BOOLEAN fFlush, VOID **pv)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Unmap(fFlush, pv);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Flush
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//              Flush the memory property set to disk and commit it.
//
//  Signals:    HRESULT from IStream methods.
//
//  Notes:      Calls the shared memory buffer to do the actual flush
//              because that code path is shared with the "FlushBufferedData"
//              call for IStorage::Commit.
//
//--------------------------------------------------------------------

VOID CExposedStream::Flush(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().Flush(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetSize
//
//  Synopsis:   Returns size of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//--------------------------------------------------------------------

ULONG CExposedStream::GetSize(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return GetMappedStream().GetSize(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetSize
//
//  Synopsis:   Sets size of "map." Called by
//              NtCreatePropertySet et al.
//
//  Arguments:  [cb] -- requested size.
//		[fPersistent] -- FALSE if expanding in-memory read-only image
//              [ppv] -- new mapped address.
//
//  Signals:    Not enough disk space.
//
//  Notes:      In a low memory situation we may not be able to
//              get the requested amount of memory.  In this
//              case we must fall back on disk storage as the
//              actual map.
//
//--------------------------------------------------------------------

VOID  CExposedStream::SetSize(ULONG cb, BOOLEAN fPersistent, VOID **ppv, OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().SetSize(cb, fPersistent, ppv, phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Lock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS CExposedStream::Lock(BOOLEAN fExclusive)
{
    SCODE sc;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    if( SUCCEEDED( sc = TakeSem() ))
    {
        SetDifferentBasisAccess(_pdfb, _ppc);
        return GetMappedStream().Lock(fExclusive);
    }
    else
    {
        olDebugOut((DEB_IERROR, "Couldn't take CExposedStream::Lock(%lx)\n", sc));
        return (STATUS_LOCK_NOT_GRANTED);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::Unlock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS CExposedStream::Unlock(VOID)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    NTSTATUS Status = GetMappedStream().Unlock();
    ClearBasisAccess(_pdfb);
    ReleaseSem(S_OK);
    return Status;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::QueryTimeStamps(STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().QueryTimeStamps(pspss, fNonSimple);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QueryModifyTime
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return(GetMappedStream().QueryModifyTime(pll));
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::QuerySecurity
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::QuerySecurity(OUT ULONG *pul) const
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return(GetMappedStream().QuerySecurity(pul));
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsWriteable
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsWriteable() const
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return GetConstMappedStream().IsWriteable();
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetChangePending
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::SetChangePending(BOOLEAN f)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    return GetMappedStream().SetChangePending(f);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsNtMappedStream
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBGPROP
BOOLEAN CExposedStream::IsNtMappedStream(VOID) const
{
    return FALSE;
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::GetParentHandle
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

HANDLE CExposedStream::GetHandle(VOID) const
{
    return INVALID_HANDLE_VALUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::SetModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CExposedStream::SetModified(OUT LONG *phr)
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    GetMappedStream().SetModified(phr);
}

//+-------------------------------------------------------------------
//
//  Member:     CExposedStream::IsModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CExposedStream::IsModified(VOID) const
{
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    //return ((class CExposedStream*const)this)->GetMappedStream().IsModified();
    return GetConstMappedStream().IsModified();
}

#ifdef DIRECTWRITERLOCK
//+--------------------------------------------------------------
//
//  Member:     CExposedStream::ValidateWriteAccess, public
//
//  Synopsis:   returns whether writer currently has write access
//
//  Notes:      tree mutex must be taken
//
//  History:    30-Apr-96    HenryLee     Created
//
//---------------------------------------------------------------
HRESULT CExposedStream::ValidateWriteAccess()
{
    if (_pst->GetTransactedDepth() >= 1)
        return S_OK;

    return (!_pdfb->DirectWriterMode() || (*_ppc->GetRecursionCount())) ?
            S_OK : STG_E_ACCESSDENIED;
};

#endif // DIRECTWRITERLOCK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\exphead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       exphead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    26-Oct-92 AlexT    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <ole2.h>

#include <propset.h>
#include <propapi.h>
#include <propstm.hxx>
#include <stgprops.hxx>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <safedecl.hxx>
#include <dfexcept.hxx>

#include <docfilep.hxx>

#include <msf.hxx>

#include <publicdf.hxx>
#include <debug.hxx>
#include <dfmem.hxx>
#include <funcs.hxx>
#ifdef ASYNC
#include <async.hxx>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\filest.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       filest.cxx
//
//  Contents:   Generic 16/32 filestream code
//
//  History:    20-Nov-91       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <marshl.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::CFileStream, public
//
//  Synopsis:   Empty object constructor
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------


CFileStream::CFileStream(IMalloc * const pMalloc)
        : _pMalloc(pMalloc)
{
    _cReferences = 1;
    _hFile = INVALID_FH;
    _hReserved = INVALID_FH;
    _hPreDuped = INVALID_FH;
    _pgfst = NULL;
    _grfLocal = 0;
    _sig = CFILESTREAM_SIG;

#ifdef USE_FILEMAPPING
    _hMapObject = NULL;
    _pbBaseAddr = NULL;
    _cbViewSize = 0;
#endif

#ifdef ASYNC
    _ppc = NULL;
#endif
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::InitGlobal, public
//
//  Synopsis:   Constructor for flags only
//
//  Arguments:  [dwStartFlags] - Startup flags
//              [df] - Permissions
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CFileStream::InitGlobal(DWORD dwStartFlags,
                             DFLAGS df)
{
    SCODE sc = S_OK;
    CGlobalFileStream *pgfstTemp;

    fsAssert(_pgfst == NULL);

    fsMem(pgfstTemp = new (_pMalloc) CGlobalFileStream(_pMalloc,
                                     NULL, df, dwStartFlags));
    _pgfst = P_TO_BP(CBasedGlobalFileStreamPtr, pgfstTemp);
    _pgfst->Add(this);
    // Fall through
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::InitFromGlobal, public
//
//  Synopsis:   Initializes a filestream with a global filestream
//
//  Arguments:  [pgfst] - Global object
//
//  History:    26-Oct-92       DrewB   Created
//
//----------------------------------------------------------------------------


void CFileStream::InitFromGlobal(CGlobalFileStream *pgfst)
{
    _pgfst = P_TO_BP(CBasedGlobalFileStreamPtr, pgfst);
    _pgfst->AddRef();
    _pgfst->Add(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::InitFromFileStream public
//
//  Synopsis:   Initializes a filestream with another CFileStream
//
//  Arguments:  [pfst] - Global object
//
//  History:    24-Sep-1998     HenryLee  Created
//
//----------------------------------------------------------------------------

void CFileStream::InitFromFileStream (CFileStream *pfst)
{
    _hFile = pfst->_hFile;
    _hMapObject = pfst->_hMapObject;
    _pbBaseAddr = pfst->_pbBaseAddr;
    _cbViewSize = pfst->_cbViewSize;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGlobalFileStream::InitFromGlobalFileStream public
//
//  Synopsis:   Initializes a global filestream from another global filestream
//
//  Arguments:  [pgfs] - Global object
//
//  History:    24-Sep-1998     HenryLee  Created
//
//----------------------------------------------------------------------------

void CGlobalFileStream::InitFromGlobalFileStream (CGlobalFileStream *pgfs)
{
#ifdef LARGE_DOCFILE
    _ulPos = pgfs->_ulPos;
#else
    _ulLowPos = pgfs->_ulLowPos;
#endif
    _cbMappedFileSize = pgfs->_cbMappedFileSize;
    _cbMappedCommitSize = pgfs->_cbMappedCommitSize;
    _dwMapFlags = pgfs->_dwMapFlags;
    lstrcpy (_awcMapName, pgfs->_awcMapName);
    lstrcpy (_awcPath, pgfs->_awcPath);

#ifdef ASYNC
    _dwTerminate = pgfs->_dwTerminate;
    _ulHighWater = pgfs->_ulHighWater;
    _ulFailurePoint = pgfs->_ulFailurePoint;
#endif // ASYNC
#if DBG == 1
    _ulLastFilePos = pgfs->_ulLastFilePos;
#endif
    _cbSector = pgfs->_cbSector;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::vRelease, public
//
//  Synopsis:   PubList support
//
//  History:    19-Aug-92       DrewB   Created
//
//---------------------------------------------------------------


ULONG CFileStream::vRelease(void)
{
    LONG lRet;
    filestDebug((DEB_ITRACE, "In  CFileStream::vRelease:%p()\n", this));
    fsAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
#ifdef ASYNC
        if (_ppc != NULL)
        {
#ifdef MULTIHEAP
            CSafeMultiHeap smh(_ppc);
#endif
            SCODE sc;
            sc = TakeSem();
            fsAssert(SUCCEEDED(sc));
            CPerContext *ppc = _ppc;

            _ppc = NULL;
            delete this;

            if (ppc->ReleaseSharedMem() == 0)
            {
#ifdef MULTIHEAP
                g_smAllocator.Uninit();
#endif
            }
        }
        else
#endif
            delete this;
    }
    return (ULONG)lRet;
    filestDebug((DEB_ITRACE, "Out CFileStream::vRelease => %d\n",lRet));
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Release, public
//
//  Synopsis:   Releases resources for an LStream
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CFileStream::Release(void)
{
    ULONG ulRet;

    filestDebug((DEB_ITRACE, "In  CFileStream::Release()\n"));

    fsAssert(_cReferences >= 1);

    ulRet = CFileStream::vRelease();

    filestDebug((DEB_ITRACE, "Out CFileStream::Release\n"));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::AddRef, public
//
//  Synopsis:   Increases the ref count
//
//  History:    27-Feb-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CFileStream::AddRef(void)
{
    ULONG ulRet;

    filestDebug((DEB_ITRACE, "In  CFileStream::AddRef()\n"));


    CFileStream::vAddRef();
    ulRet = _cReferences;

    filestDebug((DEB_ITRACE, "Out CFileStream::AddRef, %ld\n", _cReferences));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetName, public
//
//  Synopsis:   Returns the internal path
//
//  Arguments:  [ppwcsName] - Name pointer return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppwcsName]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CFileStream::GetName(WCHAR **ppwcsName)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::GetName(%p)\n",
                ppwcsName));
    fsAssert(_pgfst->HasName());
    fsChk(DfAllocWC(lstrlenW(_pgfst->GetName())+1, ppwcsName));
    lstrcpyW(*ppwcsName, _pgfst->GetName());

    filestDebug((DEB_ITRACE, "Out CFileStream::GetName => %ws\n",
                *ppwcsName));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;
#ifdef ASYNC
    BOOL fIsAsync = (_ppc != NULL);
#else
    const BOOL fIsAsync = FALSE;
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::QueryInterface(?, %p)\n",
                ppvObj));


    sc = S_OK;
    if (IsEqualIID(iid, IID_IFileLockBytes) ||
        IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IFileLockBytes *)this;
        CFileStream::vAddRef();
    }
    else if ((IsEqualIID(iid, IID_ILockBytes)) && !fIsAsync)
    {
        *ppvObj = (ILockBytes *)this;
        CFileStream::vAddRef();
    }
    else if ((IsEqualIID(iid, IID_IMarshal)) && !fIsAsync)
    {
        *ppvObj = (IMarshal *)this;
        CFileStream::vAddRef();
    }
#ifdef ASYNC
    else if (IsEqualIID(iid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFileStream::vAddRef();
    }
    else if (IsEqualIID(iid, IID_IFillInfo))
    {
        *ppvObj = (IFillInfo *)this;
        CFileStream::vAddRef();
    }
#endif
#if WIN32 >= 300
    else if (IsEqualIID(iid, IID_IAccessControl))
    {
        DWORD grfMode = 0;
        if (_pgfst->GetDFlags() & DF_TRANSACTED)
           grfMode |= STGM_TRANSACTED;
        if (_pgfst->GetDFlags() & DF_ACCESSCONTROL)
           grfMode |= STGM_EDIT_ACCESS_RIGHTS;

        // check if underlying file system supports security
        if (SUCCEEDED(sc = InitAccessControl(_hFile, grfMode, TRUE, NULL)))
        {
            *ppvObj = (IAccessControl *) this;
            CFileStream::vAddRef();
        }
        else sc = E_NOINTERFACE;
    }
#endif
    else
    {
        sc = E_NOINTERFACE;
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::QueryInterface => %p\n",
                ppvObj));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::Unmarshal, public
//
//  Synopsis:   Creates a duplicate FileStream
//
//  Arguments:  [ptsm] - Marshal stream
//              [ppv] - New filestream return
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    14-Apr-92       DrewB   Created
//
//---------------------------------------------------------------


SCODE CFileStream::Unmarshal(IStream *pstm,
                             void **ppv,
                             DWORD mshlflags)
{
    SCODE sc;
    WCHAR wcsPath[_MAX_PATH];
    CFileStream *pfst;
    CGlobalFileStream *pgfst;

    filestDebug((DEB_ITRACE, "In  CFileStream::Unmarshal(%p, %p, %lu)\n",
                 pstm, ppv, mshlflags));

    fsChk(UnmarshalPointer(pstm, (void **)&pgfst));
    pfst = pgfst->Find(GetCurrentContextId());

    if (pfst != NULL && !pfst->IsHandleValid())
        pfst = NULL;

    if (pfst)
    {
            pfst->AddRef();

            //
            // Scratch CFileStreams are always marshaled.  If we marshal a
            // direct-mode Base file, then an unopen uninitialized scratch
            // CFileStream is also marshaled (don't call InitUnmarshal here).
            // If a substorage is later opened in transacted mode then the
            // unopen scratch CFileStream is initialized (given a filename
            // and opened).  If the scratch is then marshaled, the reciever
            // must initialize his unopened scratch CFileStream.
            //
            if (pgfst->HasName())
            {
                fsChkTo(EH_pfst, pfst->InitUnmarshal());
            }
    }
    else
    {
            fsMemTo(EH_pgfst,
                    pfst = new (pgfst->GetMalloc())
                    CFileStream(pgfst->GetMalloc()));
            pfst->InitFromGlobal(pgfst);

            if (pgfst->HasName())
            {
                fsChkTo(EH_pfst, pfst->InitUnmarshal());
            }
    }
    *ppv = (void *)pfst;

    filestDebug((DEB_ITRACE, "Out CFileStream::Unmarshal => %p\n", *ppv));

    return S_OK;

 EH_pfst:
    pfst->Release();
 EH_pgfst:
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcid]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::GetUnmarshalClass(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPCLSID pcid)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::GetUnmarshalClass("
                "riid, %p, %lu, %p, %lu, %p)\n", pv, dwDestContext,
                pvDestContext, mshlflags, pcid));

    UNREFERENCED_PARM(pv);
    UNREFERENCED_PARM(mshlflags);


    *pcid = CLSID_DfMarshal;
    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::GetUnmarshalClass\n"));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [iid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::GetMarshalSizeMax(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPDWORD pcbSize)
{
    SCODE sc;

    UNREFERENCED_PARM(pv);
    fsChk(Validate());
    sc = GetStdMarshalSize(riid, IID_ILockBytes, dwDestContext, pvDestContext,
                           mshlflags, pcbSize, sizeof(CFileStream *),
#ifdef ASYNC
                           NULL,
                           FALSE,
                           NULL,
#else
                           NULL,
#endif
                           FALSE);

    fsAssert (_ppc == NULL);   // async lockbytes are standard marshaled
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [iid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::MarshalInterface(IStream *pstStm,
                                           REFIID riid,
                                           void *pv,
                                           DWORD dwDestContext,
                                           LPVOID pvDestContext,
                                           DWORD mshlflags)
{
    SCODE sc;
#ifdef ASYNC
    fsAssert (_ppc == NULL);   // async lockbytes are standard marshaled
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::MarshalInterface("
                "%p, iid, %p, %lu, %p, %lu)\n", pstStm, pv, dwDestContext,
                pvDestContext, mshlflags));

    UNREFERENCED_PARM(pv);

    fsChk(StartMarshal(pstStm, riid, IID_ILockBytes, mshlflags));
    fsChk(MarshalPointer(pstStm, BP_TO_P(CGlobalFileStream *, _pgfst)));

    filestDebug((DEB_ITRACE, "Out CFileStream::MarshalInterface\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [iid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::UnmarshalInterface(IStream *pstStm,
                                             REFIID iid,
                                             void **ppvObj)
{
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::StaticReleaseMarshalData, public static
//
//  Synopsis:   Releases any references held in marshal data
//
//  Arguments:  [pstStm] - Marshal data stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Feb-94       DrewB   Created
//
//  Notes:      Assumes standard marshal header has already been read
//
//---------------------------------------------------------------


SCODE CFileStream::StaticReleaseMarshalData(IStream *pstStm,
                                            DWORD mshlflags)
{
    SCODE sc;
    CGlobalFileStream *pgfst;

    filestDebug((DEB_ITRACE, "In  CFileStream::StaticReleaseMarshalData:("
                "%p, %lX)\n", pstStm, mshlflags));

    fsChk(UnmarshalPointer(pstStm, (void **)&pgfst));

    filestDebug((DEB_ITRACE, "Out CFileStream::StaticReleaseMarshalData\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::ReleaseMarshalData(IStream *pstStm)
{
    SCODE sc;
    DWORD mshlflags;
    IID iid;

    filestDebug((DEB_ITRACE, "In  CFileStream::ReleaseMarshalData:%p(%p)\n",
                this, pstStm));


    fsChk(SkipStdMarshal(pstStm, &iid, &mshlflags));
    fsAssert(IsEqualIID(iid, IID_ILockBytes));
    sc = StaticReleaseMarshalData(pstStm, mshlflags);

    filestDebug((DEB_ITRACE, "Out CFileStream::ReleaseMarshalData\n"));
EH_Err:
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwReserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::DisconnectObject(DWORD dwReserved)
{
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::GetLocksSupported, public
//
//  Synopsis:   Return lock capabilities
//
//  Arguments:  [pdwLockFlags] -- place holder for lock flags
//
//  Returns:    Appropriate status code
//
//  History:    12-Jul-93       AlexT   Created
//
//---------------------------------------------------------------


STDMETHODIMP CFileStream::GetLocksSupported(DWORD *pdwLockFlags)
{
    *pdwLockFlags = LOCK_EXCLUSIVE | LOCK_ONLYONCE;
    return(ResultFromScode(S_OK));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\expiter.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       expiter.cxx
//
//  Contents:   CExposedIterator implementation
//
//  History:    12-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <expiter.hxx>
#include <sstream.hxx>
#include <ptrcache.hxx>
#include <expparam.hxx>

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::CExposedIterator, public
//
//  Synopsis:   Constructor
//
//  Arguments:	[ppdf] - Public docfile
//		[pdfnKey] - Initial key
//		[pdfb] - DocFile basis
//		[ppc] - Context
//
//  History:    12-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedIterator::CExposedIterator(CPubDocFile *ppdf,
        CDfName *pdfnKey,
        CDFBasis *pdfb,
        CPerContext *ppc)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::CExposedIterator("
		"%p, %d:%s, %p, %p)\n", ppdf, pdfnKey->GetLength(),
                pdfnKey->GetBuffer(), pdfb, ppc));
    _ppc = ppc;
    _ppdf = P_TO_BP(CBasedPubDocFilePtr, ppdf);
    _ppdf->vAddRef();
    _dfnKey.Set(pdfnKey);
    _pdfb = P_TO_BP(CBasedDFBasisPtr, pdfb);
    _pdfb->vAddRef();
    _cReferences = 1;
    _sig = CEXPOSEDITER_SIG;
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::~CExposedIterator, public
//
//  Synopsis:   Destructor
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


CExposedIterator::~CExposedIterator(void)
{
    olDebugOut((DEB_ITRACE, "In  CExposedIterator::~CExposedIterator\n"));
    _sig = CEXPOSEDITER_SIGDEL;

    //In order to call into the tree, we need to take the mutex.
    //The mutex may get deleted in _ppc->Release(), so we can't
    //release it here.  The mutex actually gets released in
    //CPerContext::Release() or in the CPerContext destructor.
    SCODE sc;

#if !defined(MULTIHEAP)
    // TakeSem and ReleaseSem are moved to the Release Method
    // so that the deallocation for this object is protected
    if (_ppc)
    {
        sc = TakeSem();
        SetWriteAccess();
        olAssert(SUCCEEDED(sc));
    }
#ifdef ASYNC
    IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP

    olAssert(_cReferences == 0);
    if (_ppdf)
        _ppdf->CPubDocFile::vRelease();
    if (_pdfb)
        _pdfb->CDFBasis::vRelease();
#if !defined(MULTIHEAP)
    if (_ppc)
    {
        if (_ppc->Release() > 0)
            ReleaseSem(sc);
    }
#ifdef ASYNC
    //Mutex has been released, so we can release the connection point
    //  without fear of deadlock.
    if (pdacp != NULL)
        pdacp->Release();
#endif
#endif // MULTIHEAP
    olDebugOut((DEB_ITRACE, "Out CExposedIterator::~CExposedIterator\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Next, public
//
//  Synopsis:   Gets N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//              [rgelt] - Array for element return
//              [pceltFetched] - If non-NULL, contains the number of
//                      elements fetched
//
//  Returns:    Appropriate status code
//
//  Modifies:   [rgelt]
//              [pceltFetched]
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


_OLESTDMETHODIMP CExposedIterator::Next(ULONG celt,
                                     STATSTGW FAR *rgelt,
                                     ULONG *pceltFetched)
{
    SAFE_SEM;
    SAFE_ACCESS;
    SCODE sc;
    STATSTGW *pelt = rgelt;
    ULONG celtDone;
    CDfName dfnInitial;
    CPtrCache pc;
    STATSTGW stat;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Next(%lu, %p, %p)\n",
                celt, rgelt, pceltFetched));

    OL_VALIDATE(Next(celt, rgelt, pceltFetched));

    olChk(Validate());

    BEGIN_PENDING_LOOP;
    olChk(TakeSafeSem());
    SetReadAccess();

    olChk(_ppdf->CheckReverted());

    // Preserve initial key to reset on failure
    dfnInitial.Set(&_dfnKey);

    TRY
    {
        for (; pelt<rgelt+celt; pelt++)
        {
            sc = _ppdf->FindGreaterEntry(&_dfnKey, NULL, &stat, FALSE);
            if (FAILED(sc))
            {
                if (sc == STG_E_NOMOREFILES)
                    sc = S_FALSE;
                break;
            }

            if (FAILED(sc = pc.Add(stat.pwcsName)))
            {
                TaskMemFree(stat.pwcsName);
                break;
            }

            _dfnKey.Set(stat.pwcsName);

            stat.grfMode = 0;
            stat.grfLocksSupported = 0;
            stat.STATSTG_dwStgFmt = 0;

            *pelt = stat;
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    END_PENDING_LOOP;

    // Can't move this down because dfnInitial isn't set for all EH_Err cases
    if (FAILED(sc))
        _dfnKey.Set(&dfnInitial);

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Next => %lX\n", sc));
EH_Err:
    celtDone = (ULONG)(pelt-rgelt);
    if (FAILED(sc))
    {
        void *pv;

        pc.StartEnum();
        while (pc.Next(&pv))
            TaskMemFree(pv);

    }
    else if (pceltFetched)
        // May fault but that's acceptable
        *pceltFetched = celtDone;

    return _OLERETURN(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Skip, public
//
//  Synopsis:   Skips N entries from an iterator
//
//  Arguments:  [celt] - Count of elements
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::Skip(ULONG celt)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Skip(%lu)\n", celt));

    OL_VALIDATE(Skip(celt));
    
    if (SUCCEEDED(sc = Validate()))
        sc = hSkip(celt, FALSE);

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Skip\n"));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Reset, public
//
//  Synopsis:   Rewinds the iterator
//
//  Returns:    Appropriate status code
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::Reset(void)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Reset()\n"));

    OL_VALIDATE(Reset());
    
    if (SUCCEEDED(sc = Validate()))
        sc = hReset();

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Reset\n"));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Clone, public
//
//  Synopsis:   Clones this iterator
//
//  Arguments:  [ppenm] - Clone return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::Clone(IEnumSTATSTG **ppenm)
{
    SCODE sc, scSem = STG_E_INUSE;
    SafeCExposedIterator piExp;
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Clone(%p)\n", ppenm));

    OL_VALIDATE(Clone(ppenm));
    
    olChk(Validate());
    olChk(scSem = TakeSem());
    if (!SUCCEEDED(sc = _ppdf->CheckReverted()))
    {
        ReleaseSem(scSem);
        olChk(sc);
    }
    SetReadAccess();

    piExp.Attach(new CExposedIterator(BP_TO_P(CPubDocFile *, _ppdf),
                                      &_dfnKey,
                                      BP_TO_P(CDFBasis *, _pdfb),
                                      _ppc));
    if ((CExposedIterator *)piExp == NULL)
        sc = STG_E_INSUFFICIENTMEMORY;

    ClearReadAccess();
    ReleaseSem(scSem);

    if (SUCCEEDED(sc))
    {
        _ppc->AddRef();
        TRANSFER_INTERFACE(piExp, IEnumSTATSTG, ppenm);
    }

    if (_cpoint.IsInitialized())
    {
        olChkTo(EH_init, piExp->InitClone(&_cpoint));
    }

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Clone => %p\n",
                *ppenm));
    // Fall through
EH_Err:
    return ResultFromScode(sc);
EH_init:
    piExp->Release();
    goto EH_Err;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::Release, public
//
//  Synopsis:   Releases resources for the iterator
//
//  Returns:    Appropriate status code
//
//  History:    22-Jan-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedIterator::Release(void)
{
    LONG lRet;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::Release()\n"));

#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
    CPerContext *ppc = _ppc;
    SCODE sc = S_OK;
#endif
    if (FAILED(Validate()))
        return 0;
    if ((lRet = hRelease()) == 0)
#ifdef MULTIHEAP
    {
        if (_ppc)
        {
            sc = TakeSem();
            SetWriteAccess();
            olAssert(SUCCEEDED(sc));
        }
#ifdef ASYNC
        IDocfileAsyncConnectionPoint *pdacp = _cpoint.GetMarshalPoint();
#endif
#endif //MULTIHEAP
        delete this;
#ifdef MULTIHEAP
        if (ppc)
        {
            if (ppc->Release() == 0)
                g_smAllocator.Uninit();
            else
                if (SUCCEEDED(sc)) ppc->UntakeSem();
        }
#ifdef ASYNC
        //Mutex has been released, so we can release the connection point
        //  without fear of deadlock.
        if (pdacp != NULL)
            pdacp->Release();
#endif
    }
#endif

    olDebugOut((DEB_TRACE, "Out CExposedIterator::Release\n"));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP_(ULONG) CExposedIterator::AddRef(void)
{
    ULONG ulRet;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::AddRef()\n"));

    if (FAILED(Validate()))
        return 0;
    ulRet = hAddRef();

    olDebugOut((DEB_TRACE, "Out CExposedIterator::AddRef\n"));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CExposedIterator::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------


STDMETHODIMP CExposedIterator::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olDebugOut((DEB_TRACE, "In  CExposedIterator::QueryInterface(?, %p)\n",
                ppvObj));

    if (SUCCEEDED(sc = Validate()))
        sc = hQueryInterface(iid,
                             IID_IEnumSTATSTG,
                             (IEnumSTATSTG *)this,
                             ppvObj);
#ifdef ASYNC
    if (FAILED(sc) &&
        IsEqualIID(iid, IID_IConnectionPointContainer) &&
        _cpoint.IsInitialized())
    {
        *ppvObj = (IConnectionPointContainer *)this;
        CExposedIterator::AddRef();
    }
#endif

    olDebugOut((DEB_TRACE, "Out CExposedIterator::QueryInterface => %p\n",
                ppvObj));
    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\marshl.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       marshl.cxx
//
//  Contents:   Marshal/Unmarshal implementation
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <expdf.hxx>
#include <expst.hxx>
#include <pbstream.hxx>
#include <marshl.hxx>
#include <logfile.hxx>

// Standard marshal data is an IID plus a DWORD
#define CBSTDMARSHALSIZE (sizeof(IID)+sizeof(DWORD))

SCODE VerifyIid(REFIID iid, REFIID iidObj)
{
    if ((IsEqualIID(iid, IID_IUnknown) || (IsEqualIID(iid, iidObj))))
    {
        return S_OK;
    }
        
    if (IsEqualIID(iidObj, IID_ILockBytes))
    {
        if (IsEqualIID(iid, IID_IFillLockBytes))
        {
            return S_OK;
        }
    }

    if (IsEqualIID(iidObj, IID_IStorage))
    {
        if (   IsEqualIID(iid, IID_IPropertySetStorage)
            || IsEqualIID(iid, IID_IPropertyBagEx) )
        {
            return S_OK;
        }
    }

    return STG_E_INVALIDPARAMETER;
}

//+--------------------------------------------------------------
//
//  Function:   DfUnMarshalInterface, public
//
//  Synopsis:   Unmarshals marshaled data
//
//  Arguments:  [pstStm] - Stream to read data from
//              [iid] - Interface to unmarshal
//              [fFirst] - First time unmarshalling
//              [ppvObj] - Interface return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI DfUnMarshalInterface(IStream *pstStm,
                            REFIID iid,
                            BOOL fFirst,
                            void **ppvObj)
{
    SCODE sc;
    ULONG cbRead;
    IID iidSt;
    DWORD mshlflags;
    SafeIUnknown punk;

    olLog(("--------::In  DfUnMarshalInterface(%p, iid, %d, %p).  "
        "Context == %lX\n", pstStm, fFirst, ppvObj,
        (ULONG)GetCurrentContextId()));
    olDebugOut((DEB_TRACE, "In  DfUnMarshalInterface("
                "%p, ?, %d, %p)\n", pstStm, fFirst, ppvObj));

    olChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;
    olChk(ValidateInterface(pstStm, IID_IStream));
    olChk(ValidateIid(iid));
    if (!fFirst)
        olErr(EH_Err, STG_E_INVALIDPARAMETER);
    
    olHChk(pstStm->Read(&iidSt, sizeof(iidSt), &cbRead));
    if (cbRead != sizeof(iidSt))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstStm->Read(&mshlflags, sizeof(mshlflags), &cbRead));
    if (cbRead != sizeof(mshlflags))
        olErr(EH_Err, STG_E_READFAULT);
    olChk(VerifyIid(iid, iidSt));

#if !defined(MULTIHEAP)
    olChk(DfSyncSharedMemory());
    DfInitSharedMemBase();
#endif
    if (IsEqualIID(iidSt, IID_ILockBytes))
        sc = CFileStream::Unmarshal(pstStm, (void **)&punk, mshlflags);
    else if (IsEqualIID(iidSt, IID_IStream))
        sc = CExposedStream::Unmarshal(pstStm, (void **)&punk, mshlflags);
    else if (IsEqualIID(iidSt, IID_IStorage))
        sc = CExposedDocFile::Unmarshal(pstStm, (void **)&punk, mshlflags);
    else
        sc = E_NOINTERFACE;

    if (SUCCEEDED(sc))
    {
        if (!IsEqualIID(iid, iidSt))
        {
            sc = punk->QueryInterface(iid, ppvObj);
        }
        else
        {
            TRANSFER_INTERFACE(punk, IUnknown, ppvObj);
#if DBG == 1
        void *pvCheck;
        HRESULT scCheck = ((IUnknown*)*ppvObj)->QueryInterface(iidSt, &pvCheck);
        olAssert (scCheck == S_OK || scCheck == STG_E_REVERTED);
        if (SUCCEEDED(scCheck))
        {
            olAssert( pvCheck == *ppvObj );
            ((IUnknown*)pvCheck)->Release();
        }
#endif
        }
    }

    olDebugOut((DEB_TRACE, "Out DfUnMarshalInterface => %p\n",
                *ppvObj));
EH_Err:
    olLog(("--------::Out DfUnMarshalInterface().  "
        "*ppvObj == %p, ret == %lX\n", *ppvObj, sc));
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Function:	GetCoMarshalSize, private
//
//  Synopsis:	Gets the marshal size for an interface marshalled using
//              CoMarshalInterface
//
//  Arguments:	[riid] - Interface id
//              [punk] - Interface pointer
//              [pv] - Context info
//              [dwDestContext] - Destination context
//              [pvDestContext] - Destination context
//              [mshlflags] - Marshal flags
//              [pcb] - Size return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pcb]
//
//  Algorithm:  CoMarshalInterface is guaranteed to add no more than
//              MARSHALINTERFACE_MIN bytes of overhead to a marshal
//              Also, the standard marshaller takes no more than that
//              So if the given object supports IMarshal, the return
//              is IMarshal::GetMarshalSizeMax+MARSHALINTERFACE_MIN,
//              otherwise it is just MARSHALINTERFACE_MIN
//
//  History:	03-Aug-93	DrewB	Created
//
//  Notes:	On 32-bit platforms, we can use CoGetMarshalSizeMax
//
//----------------------------------------------------------------------------

#ifndef WIN32
static SCODE GetCoMarshalSize(REFIID riid,
                              IUnknown *punk,
                              void *pv,
                              DWORD dwDestContext,
                              void *pvDestContext,
                              DWORD mshlflags,
                              DWORD *pcb)
{
    IMarshal *pmsh;
    SCODE sc;
    DWORD cb;
    
    olDebugOut((DEB_ITRACE, "In  GetCoMarshalSize("
                "riid, %p, %p, %lu, %p, %lu, %p)\n", pv, punk, dwDestContext,
                pvDestContext, mshlflags, pcb));

    sc = DfGetScode(punk->QueryInterface(IID_IMarshal, (void **)&pmsh));
    if (sc == E_NOINTERFACE)
    {
        *pcb = MARSHALINTERFACE_MIN;
        sc = S_OK;
    }
    else if (SUCCEEDED(sc))
    {        
        sc = DfGetScode(pmsh->GetMarshalSizeMax(riid, pv, dwDestContext,
                                                pvDestContext, mshlflags,
                                                &cb));
        if (SUCCEEDED(sc))
            *pcb = MARSHALINTERFACE_MIN+cb;
        pmsh->Release();
    }
    
    olDebugOut((DEB_ITRACE, "Out GetCoMarshalSize => %lu, 0x%lX\n",
                *pcb, sc));
    return sc;
}
#else
#define GetCoMarshalSize(riid, punk, pv, dwDestContext, pvDestContext,\
                         mshlflags, pcb) \
    GetScode(CoGetMarshalSizeMax(pcb, riid, punk, dwDestContext, \
                                 pvDestContext, mshlflags))
#endif

//+--------------------------------------------------------------
//
//  Function:   GetStdMarshalSize, public
//
//  Synopsis:   Returns the size needed for a standard marshal buffer
//
//  Arguments:  [iid] - Requested marshal IID
//              [iidObj] - IID of object being marshalled
//              [dwDestContext] - Destination context
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [pcbSize] - Size return
//              [cbSize] - Object private size
//              [ppc] - Context to marshal or NULL
//              [fMarshalOriginal] - Marshal original in context
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetStdMarshalSize(REFIID iid,
                        REFIID iidObj,
                        DWORD dwDestContext,
                        LPVOID pvDestContext,
                        DWORD mshlflags,
                        DWORD *pcbSize,
                        DWORD cbSize,
#ifdef ASYNC                        
                        CAsyncConnection *pcpoint,
                        BOOL fMarshalILBs,
#endif                        
                        CPerContext *ppc,
                        BOOL const fMarshalOriginal)
{
    DWORD cbLBSize;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  GetStdMarshalSize("
                "iid, iidObj, %lu, %p, %lu, %p, %lu, %p, %d)\n",
                dwDestContext, pvDestContext, mshlflags, pcbSize, cbSize, ppc,
                fMarshalOriginal));

    olChk(ValidateOutBuffer(pcbSize, sizeof(DWORD)));
    *pcbSize = 0;
    olChk(ValidateIid(iid));
    olChk(VerifyIid(iid, iidObj));
    
    if (((dwDestContext != MSHCTX_LOCAL) && (dwDestContext != MSHCTX_INPROC))
        || pvDestContext != NULL)
        olErr(EH_Err, STG_E_INVALIDFLAG);
    
    *pcbSize = CBSTDMARSHALSIZE+cbSize;
#ifdef MULTIHEAP
    *pcbSize += sizeof(ULONG)+sizeof(ContextId)+sizeof(CPerContext*);
#endif
#ifdef POINTER_IDENTITY
    *pcbSize += sizeof(CMarshalList*);
#endif
#ifdef ASYNC    
    if ((ppc) && fMarshalILBs)
#else
    if (ppc)
#endif        
    {
        *pcbSize += sizeof(CGlobalContext *);
        olChk(GetCoMarshalSize(IID_ILockBytes,
                               (ILockBytes *)ppc->GetBase(),
                               NULL, dwDestContext, pvDestContext,
                               mshlflags, &cbLBSize));
        *pcbSize += cbLBSize;
        olChk(GetCoMarshalSize(IID_ILockBytes,
                               (ILockBytes *)ppc->GetDirty(),
                               NULL, dwDestContext, pvDestContext,
                               mshlflags, &cbLBSize));
        *pcbSize += cbLBSize;
        if (fMarshalOriginal)
        {
            olChk(GetCoMarshalSize(IID_ILockBytes,
                                   (ILockBytes *)ppc->GetOriginal(),
                                   NULL, dwDestContext, pvDestContext,
                                   mshlflags, &cbLBSize));
            *pcbSize += cbLBSize;
        }
    }
#ifdef ASYNC
    //BOOL determines whether we have a connection to marshal or not
    *pcbSize += sizeof(BOOL);
    if ((pcpoint) && (pcpoint->GetMarshalPoint() != NULL))
    {
        ULONG cbConnectSize;
        //Async flags
        *pcbSize += sizeof(DWORD);
        olChk(GetCoMarshalSize(IID_IDocfileAsyncConnectionPoint,
                               pcpoint->GetMarshalPoint(),
                               NULL, dwDestContext, pvDestContext,
                               mshlflags, &cbConnectSize));
        *pcbSize += cbConnectSize;
    }
#endif

    olDebugOut((DEB_ITRACE, "Out GetStdMarshalSize\n"));
 EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     StartMarshal, public
//
//  Synopsis:   Writes standard marshal header
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [iid] - Interface to marshal
//              [iidObj] - Object being marshalled
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    04-May-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE StartMarshal(IStream *pstStm,
                   REFIID iid,
                   REFIID iidObj,
                   DWORD mshlflags)
{
    SCODE sc;
    ULONG cbWritten;

    olDebugOut((DEB_ITRACE, "In  StartMarshal(%p, iid, iidObj, %lu)\n",
                pstStm, mshlflags));
    
    olChk(ValidateInterface(pstStm, IID_IStream));
    olChk(ValidateIid(iid));
    olChk(VerifyIid(iid, iidObj));
    olHChk(pstStm->Write((void *)&iidObj, sizeof(iidObj), &cbWritten));
    if (cbWritten != sizeof(iidObj))
        olErr(EH_Err, STG_E_WRITEFAULT);
#if defined(_WIN64)
    mshlflags |= MSHLFLAGS_STG_WIN64;
#endif
    olHChk(pstStm->Write((void *)&mshlflags, sizeof(mshlflags), &cbWritten));
    if (cbWritten != sizeof(mshlflags))
        olErr(EH_Err, STG_E_WRITEFAULT);

    olDebugOut((DEB_ITRACE, "Out StartMarshal\n"));
EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   SkipStdMarshal, public
//
//  Synopsis:   Skips over the standard marshal data
//
//  Arguments:  [pstm] - Marshal stream
//              [piid] - IID return
//              [pmshlflags] - Return marshal flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [piid]
//              [pmshlflags]
//
//  History:    20-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef WIN32
SCODE SkipStdMarshal(IStream *pstm, IID *piid, DWORD *pmshlflags)
{
    SCODE sc;
    ULONG cbRead;

    olDebugOut((DEB_ITRACE, "In  SkipStdMarshal(%p, %p, %p)\n", pstm,
                piid, pmshlflags));
    
    olHChk(pstm->Read(piid, sizeof(IID), &cbRead));
    if (cbRead != sizeof(IID))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstm->Read(pmshlflags, sizeof(DWORD), &cbRead));
    if (cbRead != sizeof(DWORD))
        olErr(EH_Err, STG_E_READFAULT);
    
    olDebugOut((DEB_ITRACE, "Out SkipStdMarshal => %lX\n", sc));
 EH_Err:
    return sc;
}
#endif

//+--------------------------------------------------------------
//
//  Function:   MarshalPointer, public
//
//  Synopsis:   Marshals a pointer
//
//  Arguments:  [pstm] - Marshal stream
//              [pv] - Pointer
//
//  Returns:    Appropriate status code
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE MarshalPointer(IStream *pstm, void *pv)
{
    SCODE sc;
    ULONG cbWritten;

    olDebugOut((DEB_ITRACE, "In  MarshalPointer(%p, %p)\n", pstm, pv));
    
#ifdef USEBASED
    ULONG ul = (ULONG)((ULONG_PTR)pv - (ULONG_PTR)DFBASEPTR);
#endif
    
    sc = DfGetScode(pstm->Write(&ul, sizeof(ul), &cbWritten));
    if (SUCCEEDED(sc) && cbWritten != sizeof(ul))
        sc = STG_E_WRITEFAULT;
    
    olDebugOut((DEB_ITRACE, "Out MarshalPointer\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   MarshalContext, public
//
//  Synopsis:   Marshals a context
//
//  Arguments:  [pstm] - Marshal stream
//              [ppc] - Context
//              [dwDestContext] - Destination context
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Marshal flags
//              [fMarshalOriginal] - Marshal original or not
//
//  Returns:    Appropriate status code
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE MarshalContext(IStream *pstm,
                     CPerContext *ppc,
                     DWORD dwDestContext,
                     LPVOID pvDestContext,
                     DWORD mshlflags,
#ifdef ASYNC                     
                     BOOL const fMarshalILBs,
#endif                     
                     BOOL const fMarshalOriginal)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  MarshalContext(%p, %p, %lu, %p, %lu, %d)\n",
                pstm, ppc, dwDestContext, pvDestContext, mshlflags,
                fMarshalOriginal));
    
    olChk(MarshalPointer(pstm, ppc->GetGlobal()));

#ifdef ASYNC    
    if (fMarshalILBs)
#endif        
    {
        olHChk(CoMarshalInterface(pstm, IID_ILockBytes, ppc->GetBase(),
                                  dwDestContext, pvDestContext, mshlflags));
        olHChk(CoMarshalInterface(pstm, IID_ILockBytes,
                                  (ILockBytes *)ppc->GetDirty(),
                                  dwDestContext, pvDestContext, mshlflags));
        if (fMarshalOriginal)
            olHChk(CoMarshalInterface(pstm, IID_ILockBytes, ppc->GetOriginal(),
                                      dwDestContext, pvDestContext, mshlflags));
    }
    
    olDebugOut((DEB_ITRACE, "Out MarshalContext\n"));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   UnmarshalPointer, public
//
//  Synopsis:   Unmarshals a pointer
//
//  Arguments:  [pstm] - Marshal stream
//              [ppv] - Pointer return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppv]
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE UnmarshalPointer(IStream *pstm,
                       void **ppv)
{
    SCODE sc;
    ULONG cbRead;
    ULONG ul;

    olDebugOut((DEB_ITRACE, "In  UnmarshalPointer(%p, %p)\n", pstm, ppv));
    
    sc = DfGetScode(pstm->Read(&ul, sizeof(ul), &cbRead));
    if (SUCCEEDED(sc) && cbRead != sizeof(ul))
        sc = STG_E_READFAULT;
    
#ifdef USEBASED
    *ppv = (void *)(ul + (BYTE*)DFBASEPTR);
#endif
    
    olDebugOut((DEB_ITRACE, "Out UnmarshalPointer => %p\n", *ppv));
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   UnmarshalContext, public
//
//  Synopsis:   Unmarshals a context
//
//  Arguments:  [pstm] - Marshal stream
//              [pppc] - Context return
//              [fUnmarshalOriginal] - Marshalled original exists or not
//              [fIsRoot] - Root unmarshal or not
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pppc]
//
//  History:    20-Aug-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE UnmarshalContext(IStream *pstm,
                       CGlobalContext *pgc,
                       CPerContext **pppc,
                       DWORD mshlflags,
#ifdef ASYNC                       
                       BOOL const fUnmarshalILBs,
#endif                       
                       BOOL const fUnmarshalOriginal,
#ifdef MULTIHEAP
                       ContextId cntxid,
#endif
                       BOOL const fIsRoot)
{
    BOOL fNewContext;
    ILockBytes *plkbBase = NULL;
    CFileStream *pfstDirty = NULL;
    ILockBytes *plkbOriginal = NULL;
    SCODE sc, sc2;
    CPerContext *ppc;
    ULONG ulOpenLock = 0;

    olDebugOut((DEB_ITRACE, "In  UnmarshalContext(%p, %p, %lu, %d, %d)\n",
                pstm, pppc, mshlflags, fUnmarshalOriginal, fIsRoot));

    ppc = pgc->Find(GetCurrentContextId());

    // ignore leaked contexts from processes that died and their ID got reused
    if (ppc != NULL && !ppc->IsHandleValid())
        ppc = NULL;

    fNewContext = (ppc == NULL);
    
#ifdef MULTIHEAP
    // when marshaling to the same process, use the same heap
    // when marshaling to a different process, check the context list
    // if there is a matching percontext, use that heap

    if (GetCurrentContextId() != cntxid && ppc != NULL)
    {
        ppc->SetThreadAllocatorState(NULL);       // set new base

        // Whenever we unmarshal into a different process, we create 
        // a new mapping (of the same heap),
        // even if a mapping of the same heap may already exist in 
        // the same process.  For pointer identity, it is essential 
        // that we find and use the existing heap.
        //  process A ---marshal--->  process B ---marshal---->  process A
        // The "final" unmarshaled exposed object in process A should 
        // match the original pointer used when the exposed object 
        // was originally marshaled.  To do this, we check the global
        // context list, and if there's a percontext match, we use 
        // its allocator and heap mapping (and don't create a new one).
        // However, to actually search the global context list (it
        // lives in shared memory), we need a temporary mapping until 
        // a matching percontext can be found and reused.
        // If not, then a new percontext is allocated and the temporary
        // mapping becomes "permanent" for the lifetime of the new percontext.
    }
#endif
    if (fNewContext)
    {
        olMemTo(EH_Open,
                ppc = new (pgc->GetMalloc()) CPerContext(pgc->GetMalloc()));
        olChkTo(EH_ppc, ppc->InitFromGlobal(pgc));
    }
    
#ifdef MULTIHEAP
    // take the ownership of the heap away from the temporary
    ppc->SetAllocatorState (NULL, &g_smAllocator);

    //ppc from above may have used incorrect base (base of temporary heap).
    //  Since we're returning and storing an unbased pointer, we need to get
    //  the real absolute pointer here.  At this point, ppc will always be in
    //  the context list, so we don't need to worry about a NULL return.
    ppc = pgc->Find(GetCurrentContextId());

    olAssert(ppc != NULL);
#endif
    
#ifdef ASYNC    
    if (fUnmarshalILBs)
    {
#endif        

    // attempt to unmarshal all the interfaces first. this makes cleanup
    // easier.
    sc	= CoUnmarshalInterface(pstm, IID_ILockBytes, (void **)&plkbBase);
    sc2 = CoUnmarshalInterface(pstm, IID_ILockBytes, (void **)&pfstDirty);

    sc = (SUCCEEDED(sc)) ? sc2 : sc;	// sc = first failure code (if any)

    if (fUnmarshalOriginal)
    {
	sc2 = CoUnmarshalInterface(pstm, IID_ILockBytes,
					 (void **)&plkbOriginal);
	sc = (SUCCEEDED(sc)) ? sc2 : sc; // sc = first failure code (if any)
    }

    // cleanup if any failure so far
    olChkTo(EH_plkbOriginal, sc);

    if (ppc->GetBase() != NULL)
    {
        // already have context, just release the things we unmarshaled.
        plkbBase->Release();
        plkbBase = NULL;
    }

    if (ppc->GetDirty() != NULL)
    {
        pfstDirty->Release();
        pfstDirty = NULL;
    }

    if ((plkbOriginal) && (ppc->GetOriginal() != NULL))
    {
        plkbOriginal->Release();
        plkbOriginal = NULL;
    }
    else if ((NULL == plkbOriginal) && plkbBase)
    {
        plkbBase->AddRef();
        plkbOriginal = plkbBase;
    }
    olAssert (plkbOriginal != NULL || ppc->GetOriginal() != NULL);

    // Make sure there is a reserved handle if this is a root
    // file-based lockbytes
    if (fIsRoot)
    {
        IFileLockBytes *pflkb;

        if (SUCCEEDED(DfGetScode((plkbOriginal ? plkbOriginal :
                                  ppc->GetOriginal())->
                                 QueryInterface(IID_IFileLockBytes,
                                                (void **)&pflkb))))
        {
            sc = DfGetScode(pflkb->ReserveHandle());
            pflkb->Release();
	    olChkTo(EH_plkbOriginal, sc);
        }
    }
#ifdef ASYNC
    }
#endif
    
    if (fNewContext)
    {
        olAssert(plkbOriginal != NULL);
        
        // Take open locks if necessary
        if (fIsRoot && pgc->TakeLock())
        {
	    olChkTo(EH_plkbOriginal,
		    GetOpen(plkbOriginal, pgc->GetOpenLockFlags(),
                            FALSE, &ulOpenLock));
        }
        
        ppc->SetILBInfo(plkbBase, pfstDirty, plkbOriginal, ulOpenLock);
    }
    else 
    {
        if (ppc->GetBase() == NULL)
        {
            //Fill in the ILB fields
            ppc->SetILBInfo(plkbBase, pfstDirty, plkbOriginal, ulOpenLock);
        }
	ppc->AddRef();
        
    }

    *pppc = ppc;
    
    olDebugOut((DEB_ITRACE, "Out UnmarshalContext => %p\n", *pppc));
    return S_OK;

 EH_ppc:
    // Preserve plkbOriginal so the lock is released even after the
    // context releases things;
    plkbOriginal->AddRef();
    ppc->Release();
    pfstDirty = NULL;
    plkbBase = NULL;
 EH_Open:
    if (ulOpenLock != 0)
    {
        olAssert(plkbOriginal != NULL);
        ReleaseOpen(plkbOriginal, pgc->GetOpenLockFlags(), ulOpenLock);
    }
 EH_plkbOriginal:
    if (plkbOriginal)
    	plkbOriginal->Release();

    if (pfstDirty)
    	pfstDirty->Release();
    if (plkbBase)
    	plkbBase->Release();

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseContext, public
//
//  Synopsis:   Releases references for a context's marshal data
//
//  Arguments:  [pstm] - Marshal stream
//              [fHasOriginal] - Original is marshalled
//              [mshlflags] - Marshal flags
//
//  Returns:    Appropriate status code
//
//  History:    20-Nov-92       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef WIN32
SCODE ReleaseContext(IStream *pstm,
#ifdef ASYNC
                     BOOL const fUnmarshalILBs,
#endif                     
                     BOOL const fHasOriginal,
                     DWORD mshlflags)
{
    CGlobalContext *pgc;
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  ReleaseContext(%p, %d, %lu)\n", pstm,
                fHasOriginal, mshlflags));
    
    olChk(UnmarshalPointer(pstm, (void **)&pgc));
    if (fUnmarshalILBs)
    {
        olHChk(CoReleaseMarshalData(pstm));
        olHChk(CoReleaseMarshalData(pstm));
        if (fHasOriginal)
            olHChk(CoReleaseMarshalData(pstm));
    }
    
    olDebugOut((DEB_ITRACE, "Out ReleaseContext\n"));
 EH_Err:
    return sc;
}
#endif

#ifdef MULTIHEAP
//+---------------------------------------------------------------------------
//
//  Function:   MarshalSharedMemory, public
//
//  Synopsis:   marshals the shared memory context
//
//  Arguments:  [pstm] - Marshal stream
//              [ppc] - per context structure
//
//  Returns:    Appropriate status code
//
//  History:    02-Dec-95   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE MarshalSharedMemory (IStream *pstStm, CPerContext *ppc)
{
    SCODE sc = S_OK;
    ULONG cbWritten;
    ULONG ulHeapName;
    ContextId  cntxid = GetCurrentContextId();
    ULONGLONG ulppc = (ULONGLONG) ppc;

    ulHeapName = g_smAllocator.GetHeapName();
    olHChk(pstStm->Write((void*) &ulHeapName, sizeof(ulHeapName), &cbWritten));
    if (cbWritten != sizeof(ulHeapName))
        olErr(EH_Err, STG_E_WRITEFAULT);
    olHChk(pstStm->Write((void*) &cntxid, sizeof(cntxid), &cbWritten));
    if (cbWritten != sizeof(cntxid))
        olErr(EH_Err, STG_E_WRITEFAULT);
    olHChk(pstStm->Write((void*) &ulppc, sizeof(ulppc), &cbWritten));
    if (cbWritten != sizeof(ulppc))
        olErr(EH_Err, STG_E_WRITEFAULT);

EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   SkipSharedMemory, public
//
//  Synopsis:   Cleanup marshaling packet during CoReleaseMarshalData
//
//  Arguments:  [pstm] - Marshal stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Dec-95   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE SkipSharedMemory (IStream *pstStm, DWORD mshlflags)
{
    SCODE sc = S_OK;
    ULONG cbRead;
    ULONG ulHeapName;
    ContextId cntxid;
    ULONGLONG ulppc;

    olChk(pstStm->Read(&ulHeapName, sizeof(ulHeapName), &cbRead));
    if (cbRead != sizeof(ulHeapName))
        olErr(EH_Err, STG_E_READFAULT);
    olChk(pstStm->Read(&cntxid, sizeof(cntxid), &cbRead));
    if (cbRead != sizeof(cntxid))
        olErr(EH_Err, STG_E_READFAULT);
    olChk(pstStm->Read(&ulppc, sizeof(ulppc), &cbRead));
    if (cbRead != sizeof(ulppc))
        olErr(EH_Err, STG_E_READFAULT);

EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnMarshalSharedMemory, public
//
//  Synopsis:   Unmarshals the shared memory context
//
//  Arguments:  [pstm] - Marshal stream
//
//  Returns:    Appropriate status code
//
//  History:    02-Dec-95   HenryLee    Created
//
//----------------------------------------------------------------------------

SCODE UnmarshalSharedMemory (IStream *pstStm, DWORD mshlflags,
                             CPerContext *ppcOwner, ContextId *pcntxid)
{
    SCODE sc = S_OK;
    ULONG cbRead;
    ULONG ulHeapName;
    ContextId cntxid;
    CPerContext *ppc;
    ULONGLONG ulppc;

    olHChk(pstStm->Read(&ulHeapName, sizeof(ulHeapName), &cbRead));
    if (cbRead != sizeof(ulHeapName))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstStm->Read(&cntxid, sizeof(cntxid), &cbRead));
    if (cbRead != sizeof(cntxid))
        olErr(EH_Err, STG_E_READFAULT);
    olHChk(pstStm->Read(&ulppc, sizeof(ulppc), &cbRead));
    if (cbRead != sizeof(ulppc))
        olErr(EH_Err, STG_E_READFAULT);
    
    ppc = (CPerContext *) ulppc;

#if defined(_WIN64)
    if ((mshlflags & MSHLFLAGS_STG_WIN64) == 0)
        olErr (EH_Err, STG_E_INVALIDFUNCTION);
#else
    if ((mshlflags & MSHLFLAGS_STG_WIN64) != 0)
        olErr (EH_Err, STG_E_INVALIDFUNCTION);
#endif

    *pcntxid = cntxid;
    if (GetCurrentContextId() == cntxid)
    {
        // marshaling to the same process, reuse the per context and heap
        // in the case of marshaling to another thread
        // the per context takes ownership of the thread's allocator
        ppc->SetThreadAllocatorState(NULL);
    }
    else
    {
        // marshaling to another process on the same machine
        // if the name of heap is different that current one, open it
        if (g_smAllocator.GetHeapName() != ulHeapName)
        {
            DfInitSharedMemBase();
            olChk(DfSyncSharedMemory(ulHeapName));
        }

        // Because the unmarshaling code calls IStream::Read,
        // possibly using another shared heap, we need a temporary
        // owner until the real CPerContext is unmarshaled
        ppcOwner->GetThreadAllocatorState(); 
        ppcOwner->SetThreadAllocatorState(NULL); 
    }
EH_Err:
    return sc;
}
#endif


#ifdef ASYNC
SCODE MarshalConnection(IStream *pstm,
                        CAsyncConnection *pcpoint,
                        DWORD dwDestContext,
                        LPVOID pvDestContext,
                        DWORD mshlflags)
{
    SCODE sc;
    ULONG cbWritten;
    IDocfileAsyncConnectionPoint *pdacp = pcpoint->GetMarshalPoint();
    BOOL fIsInitialized = (pdacp != NULL);

    //Write out the pointer.
    olHChk(pstm->Write(&fIsInitialized,
                       sizeof(BOOL),
                       &cbWritten));
    if (cbWritten != sizeof(BOOL))
    {
        olErr(EH_Err, STG_E_READFAULT);
    }
    
    if (fIsInitialized)
    {
        //If the pointer was NULL, we don't need to worry about actually
        //marshalling anything, and we can detect this in the unmarshal
        //path.  If it wasn't NULL, we need to store some additional
        //information:  The async flags and the actual connection point,
        //which will be standard marshalled.
        DWORD dwAsyncFlags = pcpoint->GetAsyncFlags();

        olChk(pstm->Write(&dwAsyncFlags, sizeof(DWORD), &cbWritten));
        if (cbWritten != sizeof(DWORD))
        {
            olErr(EH_Err, STG_E_WRITEFAULT);
        }

        //Finally, standard marshal the connection point itself.
        olHChk(CoMarshalInterface(pstm,
                                  IID_IDocfileAsyncConnectionPoint,
                                  pdacp,
                                  dwDestContext,
                                  pvDestContext,
                                  mshlflags));
    }
EH_Err:
    return sc;
}

SCODE UnmarshalConnection(IStream *pstm,
                          DWORD *pdwAsyncFlags,
                          IDocfileAsyncConnectionPoint **ppdacp,
                          DWORD mshlflags)
{
    SCODE sc;
    BOOL fIsInitialized;
    ULONG cbRead;

    *ppdacp = NULL;
    *pdwAsyncFlags = 0;

    olHChk(pstm->Read(&fIsInitialized, sizeof(BOOL), &cbRead));
    if (cbRead != sizeof(BOOL))
    {
        olErr(EH_Err, STG_E_READFAULT);
    }

    if (fIsInitialized)
    {
        olChk(pstm->Read(pdwAsyncFlags, sizeof(DWORD), &cbRead));
        if (cbRead != sizeof(DWORD))
        {
            olErr(EH_Err, STG_E_READFAULT);
        }
        sc = CoUnmarshalInterface(pstm,
                                  IID_IDocfileAsyncConnectionPoint,
                                  (void **)ppdacp);
    }
EH_Err:
    return sc;
}

SCODE ReleaseConnection(IStream *pstm, DWORD mshlflags)
{
    SCODE sc;
    ULONG cbRead;
    BOOL fIsInitialized;
    DWORD dwAsyncFlags;
    
    olHChk(pstm->Read(&fIsInitialized, sizeof(BOOL), &cbRead));
    if (cbRead != sizeof(BOOL))
    {
        olErr(EH_Err, STG_E_READFAULT);
    }
    if (fIsInitialized)
    {
        olChk(pstm->Read(&dwAsyncFlags, sizeof(DWORD), &cbRead));
        if (cbRead != sizeof(DWORD))
        {
            olErr(EH_Err, STG_E_READFAULT);
        }
        olHChk(CoReleaseMarshalData(pstm));
    }

 EH_Err:
    return sc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\filest32.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       filest32.cxx
//
//  Contents:   Win32 LStream implementation
//
//  History:    12-May-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <time.h>
#include <marshl.hxx>
#include <df32.hxx>
#include <logfile.hxx>
#include <dfdeb.hxx>
#include <lock.hxx>

#if WIN32 != 200
#define USE_OVERLAPPED
#endif

DECLARE_INFOLEVEL(filest);

HRESULT GetNtHandleSectorSize (HANDLE Handle, ULONG * pulSectorSize);
HRESULT NtStatusToScode(NTSTATUS nts);

#if DBG == 1
//+--------------------------------------------------------------
//
//  Member:     CFileStream::PossibleDiskFull, private
//
//  Synopsis:   In debug builds it can simulate a disk full error
//
//  Returns:    STG_E_MEDIUMFULL when it wants to simulate an error.
//
//  History:    25-Nov-96       BChapman   Created
//
//---------------------------------------------------------------

#ifdef LARGE_DOCFILE
SCODE CFileStream::PossibleDiskFull(ULONGLONG ulOffset)
#else
SCODE CFileStream::PossibleDiskFull(ULONG iOffset)
#endif
{
#ifdef LARGE_DOCFILE
    ULARGE_INTEGER ulCurrentSize;

    ulCurrentSize.LowPart = GetFileSize(_hFile, &ulCurrentSize.HighPart);
    if (ulOffset > ulCurrentSize.QuadPart)
#else
    ULONG ulCurrentSize;

    ulCurrentSize = GetFileSize(_hFile, NULL);
    if ((iOffset) > ulCurrentSize)
#endif
    {
        if (SimulateFailure(DBF_DISKFULL))
        {
            return STG_E_MEDIUMFULL;
        }
    }
    return S_OK;
}

void CFileStream::CheckSeekPointer(void)
{
#ifdef LARGE_DOCFILE
    LARGE_INTEGER ulChk;
    ulChk.QuadPart = 0;
#else
    LONG lHighChk;
    ULONG ulLowChk;
    lHighChk = 0;
#endif

    if (_hFile != INVALID_FH)
    {
#ifdef LARGE_DOCFILE
        ulChk.LowPart = SetFilePointer(_hFile, 0, &ulChk.HighPart,FILE_CURRENT);
        if (ulChk.LowPart == MAX_ULONG && GetLastError() != NOERROR)
#else
        ulLowChk = SetFilePointer(_hFile, 0, &lHighChk, FILE_CURRENT);

        if (ulLowChk == 0xFFFFFFFF)
#endif
        {
            //An error of some sort occurred.
            filestDebug((DEB_ERROR, "SetFilePointer call failed with %x\n",
                        GetLastError()));
            return;
        }
        if (_pgfst != NULL)
        {
#ifdef LARGE_DOCFILE
        _pgfst->CheckSeekPointer(ulChk.QuadPart);
#else
        _pgfst->CheckSeekPointer(ulLowChk);
#endif
        }
    }
}
#endif  // DBG == 1

#if DBG == 1
#ifdef LARGE_DOCFILE
inline void CGlobalFileStream::CheckSeekPointer(ULONGLONG ulChk)
{
    if(ulChk != _ulPos && MAX_ULONGLONG != _ulPos)
    {
        filestDebug((DEB_ERROR,"Seek pointer mismatch."
                    "  Cached = 0x%Lx, Real = 0x%Lx, Last Checked = 0x%Lx"
                    " %ws\n",
                    _ulPos,
                    ulChk,
                    _ulLastFilePos,
                    GetName()));
        fsAssert(aMsg("Cached FilePointer incorrect!!\n"));
    }
    _ulLastFilePos = ulChk;
}
#else
inline void CGlobalFileStream::CheckSeekPointer(DWORD ulLowChk)
{
    if(ulLowChk != _ulLowPos && 0xFFFFFFFF != _ulLowPos)
    {
        filestDebug((DEB_ERROR,"Seek pointer mismatch."
                    "  Cached = 0x%06x, Real = 0x%06x, Last Checked = 0x%06x"
                    " %ws\n",
                    _ulLowPos,
                    ulLowChk,
                    _ulLastFilePos,
                    GetName()));
        fsAssert(aMsg("Cached FilePointer incorrect!!\n"));
    }
    _ulLastFilePos = ulLowChk;
}
#endif // LARGE_DOCFILE
#endif

//+--------------------------------------------------------------
//
//  Member:     CFileStream::InitWorker, private
//
//  Synopsis:   Constructor
//
//  Arguments:  [pwcsPath] -- Path
//              [dwFSInit] -- Reason why we are initing.
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92   DrewB       Created
//              20-Feb-97   BChapman    Rewrote.
//
//  Notes:  [pwcsPath] may be unsafe memory so we must be careful
//              not to propagate faults
//          The PathName will always be OLECHAR (WIDECHAR) so most of the
//              code is Unicode using WideWrap to talk to Win95.  Except
//              when creating a TempFile name.  To avoid lots of unnecessary
//              converting we work in TCHAR, and convert only the result.
//---------------------------------------------------------------

SCODE CFileStream::InitWorker(WCHAR const *pwcsPath, DWORD dwFSInit)
{
    WCHAR awcPath[_MAX_PATH+1];
    TCHAR atcPath[_MAX_PATH+1];
    TCHAR atcTempDirPath[_MAX_PATH+1];
    SCODE sc;
    DWORD DFlags = _pgfst->GetDFlags();

    filestDebug((DEB_ITRACE, "IN  CFileStream::InitWorker(%ws, 0x%x)\n",
                                pwcsPath, dwFSInit));

    // If we've already been constructed, leave

    if (INVALID_FH != _hFile)
    {
        filestDebug((DEB_ITRACE, "OUT CFileStream::Init returning %x\n", S_OK));
        return S_OK;
    }

    // Get file name from:
    //      1) the global object on Unmarshals (stored in Unicode).
    //      2) the passed parameter on Opens (OLE standard Unicode).
    //      3) MakeTmpName() when making Scratch or SnapShot files.
    //
    if (!_pgfst->HasName())
    {
        //
        // The Global object does not have a name so this CAN'T be an
        // unmarshal.   It is possible for scratch files to be marshaled
        // with no name because they have not yet been "demanded" but
        // Unmarshal() doesn't calls us if there is no name.
        //
//        fsAssert(!(dwFSInit & FSINIT_UNMARSHAL));

        // If we were passed a name, copy it.
        // Watch out for a possible bad pointer from the user.
        if (pwcsPath != NULL)
        {
            TRY
            {
                wcsncpy(awcPath, pwcsPath, _MAX_PATH+1);
                awcPath[MAX_PATH] = L'\0';
            }
            CATCH(CException, e)
            {
                UNREFERENCED_PARM(e);
                fsErr(EH_Err, STG_E_INVALIDPOINTER);
            }
            END_CATCH
        }
        else    // If we weren't given a name then make one up.
        {
            // We use native "TCHAR" when finding a temp name.
            //
            fsChk(Init_GetTempName(atcPath, atcTempDirPath));
            dwFSInit |= FSINIT_MADEUPNAME;
#ifndef UNICODE
            AnsiToUnicodeOem(awcPath, atcPath, _MAX_PATH+1);
#else
            wcsncpy(awcPath, atcPath, _MAX_PATH+1);
            awcPath[MAX_PATH] = L'\0';
#endif
        }

        fsChk(Init_OpenOrCreate(awcPath,        // filename: given or created
                          atcTempDirPath,       // path to temp directory
                          dwFSInit));           // various state information
    }
    else
    {   // Name is in the global file object.  This is unmarshaling.
        // Or we could be in the 2nd init of a scratch file that was
        // "demanded" after it was marshaled.
        fsAssert( (dwFSInit & FSINIT_UNMARSHAL)
                        || (GetStartFlags() & RSF_SCRATCH) );

        fsChk(Init_DupFileHandle(dwFSInit));
    }

    //
    // If this is the first open of the file then we need to store
    // the name into the global object.
    // Set name to fully qualified path to avoid current-directory
    // dependencies.
    // Always store the path as Unicode.  We are using "WideWrap" here.
    //
    if (!_pgfst->HasName())
    {
        WCHAR awcFullPath[_MAX_PATH+1];
        WCHAR *pwcBaseName;

        if(0 == GetFullPathName(awcPath, _MAX_PATH, awcFullPath, &pwcBaseName))
        {
            fsErr(EH_File, LAST_STG_SCODE);
        }
        _pgfst->SetName(awcFullPath);

        //
        // If this is the first open of a SCRATCH then dup the file handle
        // to any other marshaled instances.  This covers the case of a
        // late "demand" scratch.
        //
        if(GetStartFlags() & RSF_SCRATCH)
            DupFileHandleToOthers();
    }

    CheckSeekPointer();
    filestDebug((DEB_INFO,
                "File=%2x Initialize this=%p thread %lX path %ws\n",
                _hFile, this, GetCurrentThreadId(), _pgfst->GetName()));

    //
    // When a file is mapped we can't shorten the real filesize except by
    // truncating when we close.
    //
    // If More than one context has the file mapped we can't truncate the
    // file when we close.
    //
    // If multiple writers having a file mapped data can be destroyed when
    // they close and truncate a file that the other guy may have written.
    // There is also a problem with readers holding the file mapped that
    // prevents the writer from truncating the file when he closes.
    //
    // So... the cases Where we want to allow mapping:
    //  - Direct,     Read
    //  - Transacted, Read  w/ Deny-Write
    //  - AnyMode,    Write w/ Deny-Write
    //  - Tempfiles (scratch and snapshot)
    //
    if(    (P_DIRECT(DFlags)     && P_READ(DFlags))
        || (P_TRANSACTED(DFlags) && P_READ(DFlags) && P_DENYWRITE(DFlags))
        || (P_WRITE(DFlags)      && P_DENYWRITE(DFlags))
        || (RSF_TEMPFILE & GetStartFlags()) )
    {
        Init_MemoryMap(dwFSInit);
    }
    else
    {
        filestDebug((DEB_MAP, "File=%2x Not creating a memory map for %ws.\n",
                                    _hFile, _pgfst->GetName()));
    }

    filestDebug((DEB_ITRACE, "OUT CFileStream::Init returning %x\n", S_OK));

    return S_OK;

EH_File:
    fsVerify(CloseHandle(_hFile));
    _hFile = INVALID_FH;
    if(RSF_CREATE & _pgfst->GetStartFlags())
        DeleteTheFile(awcPath);

EH_Err:
    filestDebug((DEB_ITRACE, "OUT CFileStream::Init returning %x\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_GetTempName, private
//
//  Synopsis:   Make up a temp filename.
//
//  Arguments: [ptcPath] -- [out] Tmp filename path
//          [ptcTmpPath] -- [out] Tmp directory path
//
//  Returns:    S_OK
//
//  History:    13-Jan-97       BChapman   Clean up InitWorker.
//
//  Note:  TCHAR issue.  We do as much as we can "native" and the
//      caller converts the result.  (If necessary)
//
//---------------------------------------------------------------
SCODE CFileStream::Init_GetTempName(TCHAR *ptcPath, TCHAR *ptcTmpPath)
{
    BOOL fWinDir = FALSE;
    SCODE sc;
    LUID luid;

    // Can't truncate since for temporary files we will
    // always be creating
    fsAssert(0 == (_pgfst->GetStartFlags() & RSF_TRUNCATE));

    // Create the Temp Name with native TCHAR.
    //
    if(0 == GetTempPath(_MAX_PATH, ptcTmpPath))
    {
        if(0 == GetWindowsDirectory(ptcTmpPath, _MAX_PATH))
            fsErr(EH_Err, LAST_STG_SCODE);

        fWinDir = TRUE;
    }

    if (AllocateLocallyUniqueId (&luid) == FALSE)
        fsErr (EH_Err, LAST_STG_SCODE);

    if(0 == GetTempFileName(ptcTmpPath, TEMPFILE_PREFIX, luid.LowPart, ptcPath))
    {
        if (fWinDir)
            fsErr(EH_Err, LAST_STG_SCODE);

        if (0 == GetWindowsDirectory(ptcTmpPath, _MAX_PATH))
            fsErr(EH_Err, LAST_STG_SCODE);

        if (0 == GetTempFileName(ptcTmpPath, TEMPFILE_PREFIX,
                                    luid.LowPart, ptcPath))
        {
            fsErr(EH_Err, LAST_STG_SCODE);
        }
    }
    return S_OK;

EH_Err:
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_GetNtOpenFlags, private
//
//  Synopsis:   Convert Docfile flags into NT Open flags.
//
//  Arguments:   [pdwAccess] -- [out] NT flags
//                [pdwShare] -- [out] NT flags
//             [pdwCreation] -- [out] NT Flags
//             [pdwFlagAttr] -- [out] NT Flags
//
//  Returns:    S_OK
//
//  Notes:      Uses _pgfst->GetDFlags() and _pgfst->GetStartFlags().
//
//  History:    6-Nov-96       BChapman   Clean up InitWorker.
//
//---------------------------------------------------------------
SCODE CFileStream::Init_GetNtOpenFlags(
        LPDWORD pdwAccess,
        LPDWORD pdwShare,
        LPDWORD pdwCreation,
        LPDWORD pdwFlagAttr)
{
    DWORD dwStartFlags = _pgfst->GetStartFlags();

    *pdwAccess = 0;
    *pdwShare = 0;
    *pdwCreation = 0;
    *pdwFlagAttr = 0;

    if (_pgfst->HasName())
    {
        dwStartFlags &= ~RSF_CREATEFLAGS;
        dwStartFlags |= RSF_OPEN;
    }

    if (dwStartFlags & RSF_OPENCREATE)
    {
        //  This is used for our internal logging
        *pdwCreation = OPEN_ALWAYS;
    }
    else if (dwStartFlags & RSF_CREATE)
    {
        if (dwStartFlags & RSF_TRUNCATE)
            *pdwCreation = CREATE_ALWAYS;
        else
            *pdwCreation = CREATE_NEW;
    }
    else
    {
        if (dwStartFlags & RSF_TRUNCATE)
            *pdwCreation = TRUNCATE_EXISTING;
        else
            *pdwCreation = OPEN_EXISTING;
    }

    DWORD dwDFlags = _pgfst->GetDFlags();
    if (!P_WRITE(dwDFlags))
        *pdwAccess = GENERIC_READ;
    else
        *pdwAccess = GENERIC_READ | GENERIC_WRITE;
    if (P_DENYWRITE(dwDFlags) && !P_WRITE(dwDFlags))
        *pdwShare = FILE_SHARE_READ;
    else
        *pdwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
#if WIN32 == 300
    if (dwDFlags & DF_ACCESSCONTROL)
        *pdwAccess |= WRITE_DAC | READ_CONTROL;
#endif

    // Make sure we're not attempting to create/truncate a read-only thing
    fsAssert(*pdwAccess != GENERIC_READ ||
             !(dwStartFlags & (RSF_CREATE | RSF_TRUNCATE)));

    switch(RSF_TEMPFILE & dwStartFlags)
    {
    case RSF_SCRATCH:
        *pdwFlagAttr = FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_RANDOM_ACCESS;
        break;

    case RSF_SNAPSHOT:
        *pdwFlagAttr = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;
        break;

    case 0:     // Normal "original" file
        *pdwFlagAttr = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;
        break;

    default:
        // if we get here something is rotten in the header files
        fsAssert(RSF_TEMPFILE == (RSF_SCRATCH | RSF_SNAPSHOT));
        break;
    }

    if(RSF_DELETEONRELEASE & dwStartFlags && RSF_TEMPFILE & dwStartFlags)
    {
        *pdwFlagAttr |= FILE_FLAG_DELETE_ON_CLOSE;
        *pdwShare |= FILE_SHARE_DELETE;
    }

    if (RSF_NO_BUFFERING & dwStartFlags)
    {
        *pdwFlagAttr |= FILE_FLAG_NO_BUFFERING;
    }

    if (RSF_ENCRYPTED & dwStartFlags)
    {
         *pdwFlagAttr |= FILE_ATTRIBUTE_ENCRYPTED;
    }

    return S_OK;
}



//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_OpenOrCreate, private
//
//  Synopsis:   Actually Open the NT file.
//
//  Arguments:   [pwcPath] -- Name of File to open.         OLECHAR
//            [ptcTmpPath] -- Path to the Temp Directory.   TCHAR
//              [dwFSInit] -- Flags.
//
//  Returns:    S_OK
//
//  History:    6-Nov-96       BChapman   InitWorker was too big.
//
//  Notes:  We pass the Temp directory path as a TCHAR because if we
//          need to construct a new temp file name we want to work
//          "native" as much as possible.
//
//---------------------------------------------------------------
SCODE CFileStream::Init_OpenOrCreate(
        WCHAR *pwcPath,
        TCHAR *ptcTmpPath,
        DWORD dwFSInit)
{
    SCODE sc;
    TCHAR atcPath[_MAX_PATH+1];
    DWORD dwAccess, dwShare, dwCreation, dwFlagAttr;
    DWORD dwDFlags = _pgfst->GetDFlags();

    Init_GetNtOpenFlags(&dwAccess, &dwShare, &dwCreation, &dwFlagAttr);

    //If we're opening with deny-read, we need to let the
    //   file system tell us if there are any other readers, to
    //   avoid our no-lock trick for the read-only deny-write case.
    //Yes, this is ugly.
    //Yes, it also has a race condition in which two people can
    //   get read access while specifying SHARE_DENY_READ.
    //
    if (!(dwFSInit & FSINIT_UNMARSHAL) &&
                !P_WRITE(dwDFlags) && P_DENYREAD(dwDFlags))
    {
        // We open read-only, share exclusive(ie == 0).  If this
        // fails, there is already another accessor, so we bail.
        //
        // If we are unmarshalling, we don't do this check because we
        // know there is already another reader, i.e. the original open.
        //
        //  Using WideWrap to handle the !UNICODE case.
        //
        _hFile = CreateFile(pwcPath, GENERIC_READ, 0, NULL,
                             dwCreation, dwFlagAttr, NULL);

        if (INVALID_FH == _hFile)
        {
            filestDebug((DEB_INFO, "Can open file %ws in the test open "
                                "read-only deny read case\n", pwcPath));
            if (GetLastError() == ERROR_ALREADY_EXISTS)
                fsErr(EH_Err, STG_E_FILEALREADYEXISTS)
            else
                fsErr(EH_Err, LAST_STG_SCODE);
        }

        CloseHandle(_hFile);
    }

    //
    // Open the File.  We use OLE WideWrap to handle !UNICODE
    //
    _hFile = CreateFile(pwcPath, dwAccess, dwShare, NULL,
                         dwCreation, dwFlagAttr, NULL);

    //
    //  If the Open failed w/ error = FILE_EXISTS and this is a temp file
    // then make up a new temp file name and keep tring until we succeed
    // or fail with a different error.
    //
    if (INVALID_FH == _hFile)
    {
        DWORD dwLastError = GetLastError();

        if (dwLastError != ERROR_ALREADY_EXISTS &&
            dwLastError != ERROR_FILE_EXISTS)
        {
            filestDebug((DEB_INFO, "File %ws Open Failed. err=%x\n",
                                        pwcPath, dwLastError));
            fsErr(EH_Err, STG_SCODE(dwLastError));
        }

        //
        // If we didn't make this name (ie. tempfile) then it is
        // time to error out.  Otherwise if we did make this name then
        // we can continue to try other names.
        //
        if(!(FSINIT_MADEUPNAME & dwFSInit))
        {
            filestDebug((DEB_INFO, "File Open Failed. File %ws Exists\n",
                                        pwcPath));
            fsErr(EH_Err, STG_E_FILEALREADYEXISTS);
        }

        LUID luid;

        while (1)
        {
            if (AllocateLocallyUniqueId (&luid) == FALSE)
                fsErr (EH_Err, LAST_STG_SCODE);

            filestDebug((DEB_INFO,
                    "CreateFile failed %x tring a new tempfile name.\n",
                    dwLastError));

            if (GetTempFileName(ptcTmpPath, TEMPFILE_PREFIX,
                                luid.LowPart, atcPath) == 0)
            {
                fsErr(EH_Err, LAST_STG_SCODE);
            }
#ifndef UNICODE
            AnsiToUnicodeOem(pwcPath, atcPath, _MAX_PATH+1);
#else
            wcsncpy(pwcPath, atcPath, _MAX_PATH+1);
#endif
            filestDebug((DEB_INFO,
                    "Tempfile CreateFile(%ws, %x, %x, NULL, %x, NORMAL|RANDOM, NULL)\n",
                    pwcPath, dwAccess, dwShare, dwCreation));

            //
            // Using WideWrap to handle the !UNICODE case
            //
            _hFile = CreateFile(
                        pwcPath,
                        dwAccess,
                        dwShare,
                        NULL,
                        dwCreation,
                        dwFlagAttr,
                        NULL);
            if (INVALID_FH != _hFile)
                break;

            dwLastError = GetLastError();
            if (dwLastError != ERROR_ALREADY_EXISTS &&
                dwLastError != ERROR_FILE_EXISTS)
            {
                fsErr(EH_Err, STG_SCODE(dwLastError));
            }
        }
    }

#if WIN32 == 100
    if (_pgfst->GetStartFlags() & RSF_NO_BUFFERING)
    {
        ULONG cbSector;
        fsChk (GetNtHandleSectorSize (_hFile, &cbSector));
        if ((cbSector % HEADERSIZE) == 0)  // only support sector sizes n*512
            _pgfst->SetSectorSize(cbSector);
    }
#endif

    filestDebug((DEB_INFO,
                "File=%2x CreateFile(%ws, %x, %x, NULL, %x, %x, NULL)\n",
                            _hFile, pwcPath, dwAccess, dwShare,
                            dwCreation, dwFlagAttr));

    //At this point the file handle is valid, so let's look at the
    //seek pointer and see what it is.
    CheckSeekPointer();

    return S_OK;

EH_Err:
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Init_DupFileHandle, private
//
//  Synopsis:   Dup any existing File Handle into _hFile.
//
//  Returns:    S_OK, System Error
//              or STG_E_INVALIDHANDLE if it can't file a file to Dup.
//
//  History:    15-Apr-96       BChapman    Created
//
//  Notes:  This is called from unmarshal.  So we can assert that there
//          MUST be another instance of an open handle in the list.
//
//---------------------------------------------------------------

SCODE CFileStream::Init_DupFileHandle(DWORD dwFSINIT)
{
    CFileStream *pfst;
    SCODE sc=E_FAIL;
    HANDLE hprocSrc;
    HANDLE hFileSrc;

    fsAssert(INVALID_FH == _hFile);

    //
    // Another context may have already Dup'ed the File Handle
    // to us.  (This is only in the marshaled-undemanded-scratch case)
    //
    if(INVALID_FH != _hPreDuped)
    {
        _hFile = _hPreDuped;
        _hPreDuped = INVALID_FH;
        return S_OK;
    }

    //
    // Search the list of contexts for someone we can Dup from.
    //
    pfst = _pgfst->GetFirstContext();
    fsAssert(NULL != pfst);

    while (pfst != NULL)
    {
        if (INVALID_FH == pfst->_hFile && INVALID_FH == pfst->_hPreDuped)
        {
            pfst = pfst->GetNext();
            continue;
        }
        
        //
        // Found someone with the file open.  Now Dup it.
        //
        hFileSrc = (INVALID_FH == pfst->_hFile) ?
            pfst->_hPreDuped :
            pfst->_hFile;

        hprocSrc = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pfst->GetContext());
        if(NULL == hprocSrc)
        {
            sc = LAST_STG_SCODE;
            pfst = pfst->GetNext();
            continue;
        }

        if(DuplicateHandle(hprocSrc,               // Src Process
                            hFileSrc,               // Src Handle
                            GetCurrentProcess(),    // Dest Process
                            &_hFile,                // Dest Handle
                            0, FALSE,
                            DUPLICATE_SAME_ACCESS))
        {
            sc = S_OK;
            break;
        }
        
        sc = LAST_STG_SCODE;
        CloseHandle(hprocSrc);
        pfst = pfst->GetNext();
    }
    if (NULL == pfst)
        fsErr(EH_Err, STG_E_INVALIDHANDLE);
        

    CloseHandle(hprocSrc);
    return S_OK;

EH_Err:
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::DupFileHandleToOthers, private
//
//  Synopsis:   Dup your file handle into everyone else.
//
//  Returns:    S_OK, or system faliure code.
//
//  History:    17-Apr-96       BChapman    Created
//
//  Notes:  This is used when demanding a marshaled undemanded scratch.
//      We put the Dup'ed handle in "_hPreDuped".  The "Init_DupHandle()"
//      routine will find it an move it into _hFile.
//---------------------------------------------------------------

SCODE CFileStream::DupFileHandleToOthers()
{
    SCODE scAny = S_OK;
    CFileStream *pfst;
    HANDLE hprocDest;

    pfst = _pgfst->GetFirstContext();
    fsAssert(NULL != pfst);

    //
    //  Walk the list of contexts and Dup the file handle into all
    // contexts that don't already have it open.  If any of them fail,
    // keep going.  Hold onto the last error code and return it.
    //
    while(NULL != pfst)
    {
        if(INVALID_FH == pfst->_hFile && INVALID_FH == pfst->_hPreDuped)
        {
            //
            // Found someone that needs the file handle.
            //
            hprocDest = OpenProcess(PROCESS_DUP_HANDLE,
                                    FALSE,
                                    pfst->GetContext());
            if(NULL == hprocDest)
            {
                scAny = LAST_STG_SCODE;
            }
            else
            {
                if(!DuplicateHandle(GetCurrentProcess(),    // Src Process
                                    _hFile,                 // Src Handle
                                    hprocDest,              // Dest Process
                                    &pfst->_hPreDuped,      // Dest Handle
                                    0, FALSE,
                                    DUPLICATE_SAME_ACCESS))
                {
                    scAny = LAST_STG_SCODE;
                }
                CloseHandle(hprocDest);
            }
        }
        pfst = pfst->GetNext();
    }

    return scAny;
}


#ifdef USE_FILEMAPPING

//+--------------------------------------------------------
// The following are Memory mapped file support for NT
//      Init_MemoryMap
//      TurnOffMapping
//      MakeFileMapAddressValid
//+--------------------------------------------------------

//
//  This size will need to be revisited in the future.  Right now this is
// a balance between not consuming too much of a 32 address space, and big
// enough for most files without need to grow.
// In Nov 1996 (at the time of this writing) most documents are between
// 80-800K.  Some huge spreadsheets like the perf group reportare 18-20Mb.
//
#define MINIMUM_MAPPING_SIZE (512*1024)

BOOL DfIsRemoteFile (HANDLE hFile)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;

    DeviceInformation.Characteristics = 0;
    Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatus,
                &DeviceInformation,
                sizeof(DeviceInformation),
                FileFsDeviceInformation
                );

    if ( NT_SUCCESS(Status) &&
         (DeviceInformation.Characteristics & FILE_REMOTE_DEVICE) ) {

        return TRUE;

    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::IsEncryptedFile, private
//
//  Synopsis:   queries the file handle to see if it's encrypted
//
//  Arguments:  [dwFSInit] -- Flags.   Possible values:
//                      FSINIT_UNMARSHAL - This is an unmarshal.
//
//  Returns:      TRUE - if the file is encrypted on NTFS
//              FALSE  - if we can't tell
//
//  History:    05-Apr-2000    HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL CFileStream::IsEncryptedFile ()
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationFile(
                _hFile,
                &IoStatus,
                &BasicInformation,
                sizeof(BasicInformation),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) && 
         (BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) )
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::Init_MemoryMap, private
//
//  Synopsis:   Creates and Views a memory map for the current file.
//              Used by First open and Unmarshal.
//
//  Arguments:  [dwFSInit] -- Flags.   Possible values:
//                      FSINIT_UNMARSHAL - This is an unmarshal.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//              E_FAIL - When the global object says not to map the file.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  Private Effect:     Sets _hMapObject
//                      Sets _pbBaseAddr
//
//  Note:   The field _pbBaseAddr is check before each use of the memory map.
//
//  History:    19-Oct-96       BChapman   Created
//
//----------------------------------------------------------------------------

SCODE CFileStream::Init_MemoryMap(DWORD dwFSInit)
{
    LUID luid;
    WCHAR pwcMapName[MAPNAME_MAXLEN];
    DWORD dwPageFlags, dwMapFlags;
    ULONG cbFileSize;
    ULONG cbFileSizeHigh;
    ULONG cbViewSize;
    ULONG cbCommitedSize;
    SCODE sc;
    HANDLE hfile;
    BOOL fMakeStub = FALSE;

    filestDebug((DEB_ITRACE, "In  Init_MemoryMap(0x%x)\n", dwFSInit));

    if (_pgfst->GetStartFlags() & RSF_NO_BUFFERING)
        fsErr (EH_Err, STG_E_INVALIDFUNCTION);

    cbFileSize = GetFileSize(_hFile, &cbFileSizeHigh);
    if (cbFileSize == MAX_ULONG && NO_ERROR != GetLastError())
            fsErr(EH_Err, LAST_STG_SCODE)

    if (cbFileSizeHigh > 0)
        fsErr (EH_Err, STG_E_DOCFILETOOLARGE);

    // disallow remote opens except for read, deny-write for NT4 compatiblity
    if ((P_WRITE(_pgfst->GetDFlags()) || !P_DENYWRITE(_pgfst->GetDFlags())) &&
        DfIsRemoteFile (_hFile))
        fsErr (EH_Err, STG_E_INVALIDFUNCTION);

    filestDebug((DEB_MAP, "File=%2x Init_MemoryMap filesize = %x\n",
                        _hFile, cbFileSize));

#if DBG==1
    //
    // DEBUG ASSERT
    // If the file is a temp file it must be delete on release.
    // The performance of mapped temp files that are not DELETE_ON_CLOSE
    // is very slow on FAT.
    //
    if(RSF_TEMPFILE & GetStartFlags())
        fsAssert(RSF_DELETEONRELEASE & GetStartFlags());
#endif

//
// This routine makes two kinds of mapping.
//  1) Writeable mappings over filesystem files that grow.
//  2) Readonly mappings over filesystem files that are fixed size.
//
    //
    // If we are opening for writing then grow the mapping upto
    // some limit so there is room for writes to extend the file.
    // If we are opening for reading then the mapping is the same
    // size as the original file.
    //
    if(_pgfst->GetDFlags() & DF_WRITE)
    {
        dwPageFlags = PAGE_READWRITE;
        dwMapFlags = FILE_MAP_WRITE;
        //
        // Nt can't Memory map a zero length file, so if the file is
        // zero length and we are open for writing then grow the file
        // to one sector before we create the memory map.  But don't set
        // the MappedFileSize or MappedCommitSize because the docfile
        // code uses filesize==0 to determine if this is a create or an
        // open.  So it is important to not expose the fact that we grew
        // the file.
        //
        if (0 == cbFileSize)
        {
            //Grow the file to 512 bytes in the create path - in the
            //open path we don't want to change the file size.
            //For the open path, don't map it - we'll fail later with
            //STG_E_INVALIDHEADER.
            if ((GetStartFlags() & RSF_CREATE) ||
                (GetStartFlags() & RSF_TEMPFILE))
            {
                if (SUCCEEDED(MakeFileStub()))
                    fMakeStub = TRUE;
            }
            else
                fsErr(EH_Err, E_OUTOFMEMORY);
        }
        
        if(cbFileSize < MINIMUM_MAPPING_SIZE/2)
            cbViewSize = MINIMUM_MAPPING_SIZE;
        else
            cbViewSize = cbFileSize * 2;
    }
    else
    {
        dwPageFlags = PAGE_READONLY;
        dwMapFlags = FILE_MAP_READ;
        cbViewSize = cbFileSize;
    }

    //
    // Get the mapping object.  Either open the existing one for this
    // file.   Or if this is the first open for this "DF context" then
    // create a new one.
    //
    if(NULL == _pgfst->GetMappingName())
    {
        //
        // If this is a first open for this "context" then we won't have
        // a name and the Unmarshaling flag should be FALSE.
        //
        //fsAssert(!(dwFSInit & FSINIT_UNMARSHAL));

        //
        // Create a new unique name for the Mapping.
        //
        AllocateLocallyUniqueId(&luid);
        wsprintfW(pwcMapName, MAPNAME_FORMAT, luid.HighPart, luid.LowPart);
        _pgfst->SetMappingName(pwcMapName);

        //
        //  Do not map very large files since they can consume
        //  too much virtual memory
        //
        MEMORYSTATUS memstatus;
        GlobalMemoryStatus (&memstatus);
        if (cbFileSize > memstatus.dwTotalPhys / 2 ||
            memstatus.dwAvailVirtual < DOCFILE_SM_LIMIT / 2)
            fsErr(EH_Err, E_OUTOFMEMORY);

        filestDebug((DEB_MAP,
                    "File=%2x New MappingName='%ws' FileName='%ws'\n",
                            _hFile, pwcMapName, _pgfst->GetName() ));

        hfile = _hFile;

        //
        // Create the Mapping.  This only covers the orignal file size.
        //      RESERVED uncommitted extensions are done in MapView.
        //
        //  Note: Using a WideWrap routine to handle the !UNICODE case.
        //
        _hMapObject = CreateFileMapping(hfile,
                            NULL,           // Security Descriptor.
                            dwPageFlags,
                            0, 0,  // Creation size of 0 means The Entire File.
                            _pgfst->GetMappingName()
        );

        //
        // This mapping is new and did not exist previously.
        //
        fsAssert(ERROR_ALREADY_EXISTS != GetLastError());

        //
        // Record the size of the file (also the commited region of the map)
        // We waited to record the size until after the mapping is created.
        // A seperate open could have shortened the file in the time between
        // the top of this routine and here.  But SetEndOfFile is disallowed
        // once a file mapping is active.
        // Note: Watch out for the case where the file is logically zero size
        // but we grew it a little so we could memory map it.
        //
        if(0 != cbFileSize)
        {
            cbFileSize = GetFileSize(_hFile, &cbFileSizeHigh);
            if (cbFileSize == MAX_ULONG && NO_ERROR != GetLastError())
            {
                sc = LAST_STG_SCODE;
                if (_hMapObject != NULL)
                    CloseHandle (_hMapObject);
                fsErr(EH_Err, sc)
            }
            fsAssert (cbFileSizeHigh == 0);
            _pgfst->SetMappedFileSize(cbFileSize);
            _pgfst->SetMappedCommitSize(cbFileSize);
        }

    }
    else
    {
        //
        // If the global object already has a mapping name then this must
        // be an unmarshal.   Or we could be in the 2nd init of a scratch
        // file that is "demanded" after it was first marshaled.
        //
        fsAssert( (dwFSInit & FSINIT_UNMARSHAL)
                                || (GetStartFlags() & RSF_SCRATCH) );

        filestDebug((DEB_MAP,
                    "File=%2x UnMarshal MappingName='%ws' FileName='%ws'\n",
                            _hFile, _pgfst->GetMappingName(),
                            _pgfst->GetName() ));

        // If the global object says the mapping is off,
        // then some other instance of this FileStream has declared
        // the mapping unuseable and no other instance should map it either.
        //
        if( ! _pgfst->TestMapState(FSTSTATE_MAPPED))
        {
            filestDebug((DEB_MAP, "Global Flag says Don't Map.\n"));
            filestDebug((DEB_ITRACE, "Out Init_MemoryMap() => %lx\n", E_FAIL));
            return E_FAIL;
        }

        _hMapObject = OpenFileMapping(dwMapFlags,
                            FALSE,          // Don't Inherit
                            _pgfst->GetMappingName()
        );
    }

    if (NULL == _hMapObject)
    {
        filestDebug((DEB_IWARN|DEB_MAP,
                        "File=%2x Create FileMapping '%ws' for "
                        "filename '%ws' failed, error=0x%x\n",
                        _hFile,
                        _pgfst->GetMappingName(),
                        _pgfst->GetName(),
                        GetLastError()));
        fsErr(EH_Err, E_OUTOFMEMORY);
    }

    filestDebug((DEB_MAP,
                "File=%2x Map=%2x filesize=0x%06x, commitsize=0x%06x\n",
                        _hFile, _hMapObject,
                        _pgfst->GetMappedFileSize(),
                        _pgfst->GetMappedCommitSize()));

    //
    // Add the file map to the process' address space.
    //
    if(FAILED(MapView(cbViewSize, dwPageFlags, dwFSInit)))
    {
        TurnOffAllMappings();
        fsErr(EH_Err, E_OUTOFMEMORY);
    }
    return S_OK;

EH_Err:
    //
    // If we can't get a mapping then set a flag so no other marshal's
    // of this context should try either.
    //
    _pgfst->ResetMapState(FSTSTATE_MAPPED);

    if (fMakeStub) // try to reset the filesize back to 0
    {
        SetFilePointer(_hFile, 0, NULL, FILE_BEGIN);
        SetEndOfFile(_hFile);
    }

    filestDebug((DEB_ITRACE, "Out Init_MemoryMap() => %lx\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::MakeFileStub, private
//
//  Synopsis:	Takes a zero length file and makes it 512 bytes.  This is
//              needed to support NT file mapping.  The important effects
//              are that it does NOT set the saved file size.
//
//  History:	09-Mar-96   Bchapman       Created
//
//---------------------------------------------------------------

HRESULT CFileStream::MakeFileStub()
{
    SCODE sc=S_OK;
#if DBG == 1
    ULONG cbFileSizeHigh;
#endif
    

    fsAssert(0 == GetFilePointer());
#if DBG == 1
    fsAssert(0 == GetFileSize(_hFile, &cbFileSizeHigh));
    fsAssert(0 == cbFileSizeHigh);
#endif

    SetFilePointer(_hFile, 512, NULL, FILE_BEGIN);

    if(FALSE == SetEndOfFile(_hFile))
        sc = LAST_STG_SCODE; 

    SetFilePointer(_hFile, 0, NULL, FILE_BEGIN);

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::MapView, private
//
//  Synopsis:	Maps a view of an existing File Mapping.
//
//  Arguments:  Size of the mapping, including extra space for RESERVED
//              pages that can be added with VIrtualAlloc.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  Private Effect:     Sets _pbBaseAddr
//                      Sets _cbViewSize
//
//  Note:
//
//  History:	25-Nov-96   Bchapman       Created
//
//---------------------------------------------------------------

HRESULT CFileStream::MapView(
            SIZE_T cbViewSize,
            DWORD dwPageFlags,
            DWORD dwFSInit)
{
    filestDebug((DEB_ITRACE, "In  MapView(0x%06x, 0x%x)\n",
                                cbViewSize, dwPageFlags));

    PVOID pvBase=NULL;
    LARGE_INTEGER SectionOffset;
    NTSTATUS Status;
    DWORD dwAllocationType = 0;

    LISet32(SectionOffset, 0);

    // confirm that we are mapping the whole file.
    fsAssert(cbViewSize >= _pgfst->GetMappedFileSize());

    if((PAGE_READWRITE & dwPageFlags))
        dwAllocationType = MEM_RESERVE;     // RESERVE uncommited pages.

    Status = NtMapViewOfSection(
                _hMapObject,
                GetCurrentProcess(),
                &pvBase,        // returned pointer to base of map.  If the
                                // initial value is non-Zero it is a "Hint".
                0L,             // ZeroBits: see ntos\mm\mapview.c
                0L,             // Commit: amount to initially Commit.
                &SectionOffset, // Offset in file for base of Map.
                &cbViewSize,    // Size of VirtAddr chunk to reserve.
                ViewShare,
                dwAllocationType,
                dwPageFlags);
    if(NT_ERROR(Status))
    {
        filestDebug((DEB_WARN|DEB_MAP,
                    "File=%2x NtMapViewOfSection Failed, viewsize=0x%06x, "
                    "dwPageFlags=%x, status=0x%x\n",
                    _hFile, _cbViewSize, dwPageFlags, Status));
        return E_OUTOFMEMORY;
    }

    _pgfst->SetMapState(FSTSTATE_MAPPED);
    _pbBaseAddr = (LPBYTE)pvBase;
    _cbViewSize = (ULONG)cbViewSize;

    filestDebug((DEB_MAP,
                "File=%2x Attaching Map: address=0x%07x, viewsz=0x%06x, "
                "commitsz=0x%06x\n",
                        _hFile, _pbBaseAddr, _cbViewSize,
                        _pgfst->GetMappedCommitSize()));

    filestDebug((DEB_ITRACE, "Out MapView => %lx\n", S_OK));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:	CFileStream::TurnOffMapping, private
//
//  Synopsis:	Turns off the use of file mapping
//
//  Private Effect:     Clears _pbBaseAddr
//                      Clears _hMapObject
//
//  History:	31-Aug-96   DrewB       Created
//              22-Oct-96   BChapman    Trim the End of File.
//                 Nov-96   BChapman    Rewrote
//
//---------------------------------------------------------------

SCODE CFileStream::TurnOffMapping(BOOL fFlush)
{
    filestDebug((DEB_ITRACE, "In  TurnOffMapping(%d)\n", fFlush));

    //
    //  We want to be make sure the file mapping was in use.  Otherwise
    // the "MappedFileSize" may not be valid when we truncate the file
    // below.  Which destroys data.
    //
    // Checking for the map object is better than checking the base pointer
    // because this routine can be called when remapping the view.
    // Then the base pointer will be NULL but we still have a map object.
    //
    if(NULL == _hMapObject)
        return S_OK;

    //
    // Release the view of the map.  And release the Map Object.
    //  Don't exit on errors.  Do as much as we can.
    //
    if(NULL != _pbBaseAddr)
    {
        filestDebug((DEB_MAP, "File=%2x Detaching Map 0x%07x\n",
                                    _hFile, _pbBaseAddr));
        // the redirector cannot handle a dirty file mapping followed by
        // ReadFile calls; local filesystems have a single coherent cache
        // fortunately, we no longer map docfiles over the redirector
        if (fFlush)
            fsVerify(FlushViewOfFile(_pbBaseAddr, 0));
        fsVerify(UnmapViewOfFile(_pbBaseAddr));
        _pbBaseAddr = NULL;
    }

    if(NULL != _hMapObject)
    {
        fsVerify(CloseHandle(_hMapObject));
        _hMapObject = NULL;
    }

    filestDebug((DEB_MAP, "File=%2x TurnOffMapping RefCount=%x\n",
                        _hFile, _pgfst->CountContexts()));

    //
    // If file was open for writing, and this is the last/only instance
    // of this "DF context" then truncate the file to the proper size.
    // We do this when the file may have grown by commiting pages on
    // the end of the memory map, the system will grow the file in
    // whole MMU page units, so we may need to trim the extra off.
    //
    // Don't do this in the case of multiple 'seperate' writers.  Last
    // close wins on the file size and that is not good.
    //
    // Don't fail on errors.  We are only trimming the EOF.
    //
    // Bugfix Feb '98 BChapman
    //  Don't Set EOF unless the map was written to or SetSize was called.
    //  Many people were opening READ/WRITE, not writing, and expecting the
    //  Mod. time to remain unchanged.
    //
    if( (_pgfst->CountContexts() == 1)
          && (_pgfst->GetDFlags() & DF_WRITE)
          && (_pgfst->TestMapState(FSTSTATE_DIRTY) ) )
    {
#ifdef LARGE_DOCFILE
        ULONGLONG ret;
#else
        ULONG ret;
#endif
        ULONG cbFileSize = _pgfst->GetMappedFileSize();

        ret = SeekTo( cbFileSize );

#ifdef LARGE_DOCFILE
        if (ret == MAX_ULONGLONG)  // 0xFFFFFFFFFFFFFFFF
#else
        if (ret == 0xFFFFFFFF)
#endif
        {
            filestDebug((DEB_ERROR,
                        "File Seek in TurnOffMapping failed err=0x%x\n",
                        GetLastError()));
            return S_OK;
        }

        filestDebug((DEB_MAP,
                    "File=%2x TurnOffMapping->SetEndOfFile 0x%06x\n",
                            _hFile, cbFileSize));

        if(FALSE == SetEndOfFile(_hFile))
        {
            filestDebug((DEB_WARN,
                        "File=%2x SetEndOfFile in TurnOffMapping Failed. "
                        "file may still be open 'seperately'\n",
                                _hFile));
        }
    }

    filestDebug((DEB_ITRACE, "Out TurnOffMapping => S_OK\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::ExtendMapView, private
//
//  Synopsis:	Unmaps the Map object and creates a bigger View based
//              on the new request size.   The cbRequest is the requested
//              real size.  So we make a view larger than that to leave room.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  History:	20-Feb-97   BChapman    Created.
//
//---------------------------------------------------------------

#define MAX_MAPVIEW_GROWTH  (5*1024*1024)

SCODE CFileStream::ExtendMapView(ULONG cbRequest)
{
    ULONG dwPageFlag;
    ULONG cbNewView;

    //
    // Confirm that we were not needlessly called.
    //
    fsAssert(cbRequest > _cbViewSize);

    //
    //  If the mapping is small, then grow it by doubling.
    //  If the mapping is big add a fixed amount.
    //
    if(cbRequest < MAX_MAPVIEW_GROWTH)
        cbNewView = cbRequest * 2;
    else
        cbNewView = cbRequest + MAX_MAPVIEW_GROWTH;

    //
    // Someone else may have grown the mapping a huge amount.
    // If that is the case then increase the New View to include the
    // entire existing file.
    //
    if(cbNewView < _pgfst->GetMappedFileSize())
        cbNewView = _pgfst->GetMappedFileSize();

    filestDebug((DEB_MAP,
            "File=%2x Mapping view is being grown from 0x%06x to 0x%06x\n",
            _hFile, _cbViewSize, cbNewView));

    //
    //  Unmap the View and re-map it at more than the currenly needed size.
    //
    filestDebug((DEB_MAP, "File=%2x Detaching Map 0x%07x to grow it.\n",
                                                _hFile, _pbBaseAddr));
    fsVerify(UnmapViewOfFile(_pbBaseAddr));
    _pbBaseAddr = NULL;

    //
    // We know the mode must be read/write because we are growing.
    //
    if(FAILED(MapView(cbNewView, PAGE_READWRITE, 0)))
    {
        TurnOffAllMappings();
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+--------------------------------------------------------------
//  Helper routine to round up memory request in a consistant manner.
//+--------------------------------------------------------------

ULONG BlockUpCommit(ULONG x) {
    return((x+COMMIT_BLOCK-1) & (~(COMMIT_BLOCK-1)));
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::MakeFileMapAddressValidWorker, private
//
//  Synopsis:	Commits reserved pages that extend a writable
//              Memory Mapped file.  Used by WriteAt and SetSize.
//
//  Returns:      S_OK - When the mapping is added to the address space.
//       E_OUTOFMEMORY - When the attempt to map the file failed.
//
//  History:	31-Oct-96   BChapman    Created.
//
//---------------------------------------------------------------

SCODE CFileStream::MakeFileMapAddressValidWorker(
            ULONG cbRequested,
            ULONG cbCommitedSize)
{
    ULONG cbNeeded;
    ULONG iStart, cbGrown;
    SCODE sc;

    filestDebug((DEB_ITRACE|DEB_MAP,
                    "File=%2x MakeFileMappingAddressValidWorker(0x%06x)\n",
                    _hFile, cbRequested));

    // Assert we are not completely confused.
    fsAssert(IsFileMapped());
    fsAssert(cbCommitedSize >= _pgfst->GetMappedFileSize());

    // Assert we were called correctly.
    fsAssert(cbCommitedSize == _pgfst->GetMappedCommitSize());
    fsAssert(cbRequested > cbCommitedSize);

    //
    // We allocate pages in clumps to cut down on little VirtualAlloc calls.
    //
    cbNeeded = BlockUpCommit(cbRequested);

    //
    //  If the needed commit size is bigger than the view window, then
    // make the view size bigger first.
    //
    if(FAILED(CheckMapView(cbNeeded)))
        return E_OUTOFMEMORY;

    //
    // Now commit the new pages.
    //
    iStart = cbCommitedSize;
    cbGrown = cbNeeded - cbCommitedSize;

    filestDebug((DEB_MAP,
            "File=%2x VirtualAlloc map=0x%07x[0x%06x] + 0x%06x(0x%06x)\n",
                    _hFile, _pbBaseAddr,
                    iStart, cbGrown, cbNeeded));

    if(NULL==VirtualAlloc(
                (void*)&_pbBaseAddr[iStart],
                cbGrown,
                MEM_COMMIT,
                PAGE_READWRITE))
    {
        // Ran out of Virtual Memory or Filesystem disk space.
        filestDebug((DEB_ERROR|DEB_MAP,
                    "File=%2x VirtualAlloc(%x + %x) 1st Failure=%x.\n",
                    _hFile,
                    &_pbBaseAddr[iStart],
                    cbGrown,
                    GetLastError()));

        //
        // If the VirutalAlloc failed we try again.  The original
        // request was rounded up to some large block size so there
        // is a slim hope that we might get just what we need.
        //
        cbNeeded = cbRequested;
        cbGrown = cbNeeded - cbCommitedSize;

        filestDebug((DEB_MAP,
                "File=%2x Retry VirtualAlloc map=0x%07x[0x%06x] + 0x%06x(0x%06x)\n",
                        _hFile, _pbBaseAddr,
                        iStart, cbGrown, cbNeeded));

        if(NULL==VirtualAlloc(
                    (void*)&_pbBaseAddr[iStart],
                    cbGrown,
                    MEM_COMMIT,
                    PAGE_READWRITE))
        {
            // Ran out of Virtual Memory or Filesystem disk space.
            filestDebug((DEB_ERROR|DEB_MAP,
                        "File=%2x VirtualAlloc(%x + %x) 2nd Failure=%x.\n",
                                _hFile,
                                &_pbBaseAddr[iStart],
                                cbGrown,
                                GetLastError()));

            TurnOffMapping(TRUE);
            if (_pgfst != NULL)
                _pgfst->ResetMapState(FSTSTATE_MAPPED);
            return E_OUTOFMEMORY;
        }
    }

    _pgfst->SetMappedCommitSize(cbNeeded);

    return S_OK;
}

#endif      // Memory Mapped File Support

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::InitFromHandle, public
//
//  Synopsis:   Creates a filestream by duping an existing handle
//
//  Arguments:  [h] - Handle
//
//  Returns:    Appropriate status code
//
//  History:    09-Feb-94       DrewB   Created
//
//  Notes:      Intended only for creating a temporary ILockBytes on a file;
//              does not create a true CFileStream; there is no
//              global filestream, no access flags, etc.
//
//----------------------------------------------------------------------------

SCODE CFileStream::InitFromHandle(HANDLE h)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::InitFromHandle:%p(%p)\n",
                 this, h));

    if (!DuplicateHandle(GetCurrentProcess(), h, GetCurrentProcess(), &_hFile,
                         0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        sc = LAST_STG_SCODE;
    }
    else
    {
        sc = S_OK;
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::InitFromHandle\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::~CFileStream, public
//
//  Synopsis:   Destructor
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------
CFileStream::~CFileStream(void)
{
    filestDebug((DEB_ITRACE, "In  CFileStream::~CFileStream()\n"));
    fsAssert(_cReferences == 0);
    _sig = CFILESTREAM_SIGDEL;

    CheckSeekPointer();

    if (INVALID_FH != _hPreDuped)
        fsVerify(CloseHandle(_hPreDuped));

    if (INVALID_FH != _hFile)
    {
        filestDebug((DEB_INFO, "~CFileStream %p handle %p thread %lX\n",
                    this, _hFile, GetCurrentThreadId()));

        //
        // A CFileStream normally _always_ had a global object connected
        // to it.  But due to the abuses of the Debug Logger we need to
        // check this here.  Also see "CFileStream::InitFromHandle"
        //
        if(_pgfst)
            TurnOffMapping(FALSE);

        fsVerify(CloseHandle(_hFile));
#ifdef ASYNC
        if ((_pgfst) &&
            (_pgfst->GetTerminationStatus() == TERMINATED_ABNORMAL))
        {
            WCHAR *pwcsName;
            SCODE sc = GetName(&pwcsName);
            if (SUCCEEDED(sc))
            {
                DeleteTheFile(pwcsName);
                TaskMemFree(pwcsName);
            }
        }
#endif //ASYNC
    }
    if (_hReserved != INVALID_FH)
    {
        filestDebug((DEB_INFO, "~CFileStream reserved %p "
                    "handle %p thread %lX\n",
                    this, _hReserved, GetCurrentThreadId()));
        fsVerify(CloseHandle(_hReserved));
        _hReserved = INVALID_FH;
    }

    if (_pgfst)
    {
        _pgfst->Remove(this);
        if (_pgfst->HasName())
        {
            if (0 == _pgfst->CountContexts())
            {
                // Delete zero length files also.  A zero length file
                // is not a valid docfile so don't leave them around
                if (_pgfst->GetStartFlags() & RSF_DELETEONRELEASE)
                {
                    // This is allowed to fail if somebody
                    // else has the file open
                    DeleteTheFile(_pgfst->GetName());
                }
            }
        }
        _pgfst->Release();
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::~CFileStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReadAt, public
//
//  Synopsis:   Reads bytes at a specific point in a stream
//
//  Arguments:  [ulPosition] - Offset in file to read at
//              [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::ReadAt(ULARGE_INTEGER ulPosition,
                                 VOID *pb,
                                 ULONG cb,
                                 ULONG *pcbRead)
{
    SCODE sc;
    LONG lHigh = ULIGetHigh(ulPosition);
    ULONG uLow = ULIGetLow(ulPosition);

#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif
    fsAssert((!IsFileMapped() || lHigh == 0) &&
             aMsg("High dword other than zero passed to filestream."));

    filestDebug((DEB_ITRACE, "In  CFileStream::ReadAt("
                 "%x:%x, %p, %x, %p)\n", ULIGetHigh(ulPosition),
                 ULIGetLow(ulPosition), pb, cb, pcbRead));

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);
    *pcbRead = 0;

#ifdef ASYNC
    DWORD dwTerminate;
    dwTerminate = _pgfst->GetTerminationStatus();
    if (dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((dwTerminate != TERMINATED_NORMAL) &&
#ifdef LARGE_DOCFILE
             (ulPosition.QuadPart + cb > _pgfst->GetHighWaterMark()))
#else
             (uLow + cb > _pgfst->GetHighWaterMark()))
#endif
    {
        *pcbRead = 0;
#ifdef LARGE_DOCFILE
        _pgfst->SetFailurePoint(cb + ulPosition.QuadPart);
#else
        _pgfst->SetFailurePoint(cb + uLow);
#endif
        sc = E_PENDING;
    }
    else
    {
#endif
        if(!IsFileMapped())
        {                           // Read w/ ReadFile()
#ifdef LARGE_DOCFILE
            sc = ReadAt_FromFile(ulPosition.QuadPart, pb, cb, pcbRead);
#else
            sc = ReadAt_FromFile(uLow, pb, cb, pcbRead);
#endif
        }
        else
        {                           // Read from Map
            sc = ReadAt_FromMap(uLow, pb, cb, pcbRead);
            if (!SUCCEEDED(sc))
#ifdef LARGE_DOCFILE
               sc = ReadAt_FromFile(ulPosition.QuadPart, pb, cb, pcbRead);
#else
               sc = ReadAt_FromFile(uLow, pb, cb, pcbRead);
#endif
        }

#ifdef ASYNC
    }
#endif

    olLowLog(("STGIO - Read : %8x at %8x, %8d, %8d <--\n", _hFile, uLow, cb, *pcbRead));

    filestDebug((DEB_ITRACE, "Out CFileStream::ReadAt => %x\n", sc));
    
    CheckSeekPointer();
    return sc;
}


#ifdef USE_FILEMAPPING

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReadAt_FromMap, private
//
//  Synopsis:   Reads bytes at a specific point from the file mapping
//
//  Arguments:  [iPosition] - Offset in file
//              [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    16-Jan-97       BChapman   Created
//
//---------------------------------------------------------------
SCODE CFileStream::ReadAt_FromMap(
            ULONG iPosition,
            VOID  *pb,
            ULONG cb,
            ULONG *pcbRead)
{
    SCODE sc = S_OK;
    ULONG cbRead=0;
    ULONG cbFileSize = _pgfst->GetMappedFileSize();
    //
    // If any of the read is before the End of File then
    // we can read something.  Reads at EOF
    //
    *pcbRead = 0;
    if (iPosition < cbFileSize)
    {
        ULONG cbTail;

        filestDebug((DEB_MAPIO,
                    "File=%2x Read MapFile @ 0x%06x, 0x%04x, bytes\n",
                            _hFile, iPosition, cb));

        //
        // Possibly shorted the read request to fit inside
        // the logical End of File.
        //
        cbTail = cbFileSize - iPosition;

        if (cb < cbTail)
            cbRead = cb;
        else
            cbRead = cbTail;

        if(cb != cbRead)
        {
            filestDebug((DEB_MAPIO,
                        "File=%2x\t\t(Short Read 0x%04x bytes)\n",
                                _hFile, cbRead));
        }

        sc = CheckMapView(iPosition+cbRead);
        if (SUCCEEDED(sc))
        {
            __try
            {
                memcpy (pb, _pbBaseAddr+iPosition, cbRead);
                *pcbRead = cbRead;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                filestDebug((DEB_WARN|DEB_MAP,
                    "File=%2x Mapfile READFAULT Xfer 0x%x bytes @ 0x%x %x\n",
                    _hFile, cbRead, iPosition, GetExceptionCode()));
                sc = STG_E_READFAULT;
            }
        }
        else // lost the file mapping
            sc = ReadAt_FromFile(iPosition, pb, cb, pcbRead);
    }
    else
    {
        if(cbFileSize < iPosition)
        {
            filestDebug((DEB_WARN|DEB_MAP,
                "File=%2x Read MapFile @ 0x%x, 0x%x bytes is entirely "
                "off the end @ 0x%x\n",
                        _hFile, iPosition, cb, cbFileSize));

            fsAssert(cbFileSize > iPosition);
        }
    }
    filestDebug((DEB_ITRACE, "Out CFileStream::ReadAt => %x\n", sc));
    return sc;
}

#endif // USE_FILEMAPPING

//+--------------------------------------------------------------
//
//  Member:     CFileStream::ReadAt_FromFile, private
//
//  Synopsis:   Reads bytes at a specific point from the file mapping
//
//  Arguments:  [iPosition] - Offset in file
//              [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    16-Jan-97       BChapman   Created
//
//---------------------------------------------------------------
SCODE CFileStream::ReadAt_FromFile(
#ifdef LARGE_DOCFILE
            ULONGLONG iPosition,
#else
            ULONG iPosition,
#endif
            VOID  *pb,
            ULONG cb,
            ULONG *pcbRead)
{
    SCODE sc = S_OK;

    if(0 == cb)
    {
        *pcbRead = 0;
        return S_OK;
    }

#ifndef USE_OVERLAPPED
    negChk(SeekTo(iPosition));

    filestDebug((DEB_FILEIO,
                "File=%2x ReadFile (old code) @ 0x%06x, 0x%04x bytes\n",
                _hFile, iPosition, cb));
    boolChk(ReadFile(_hFile, pb, cb, pcbRead, NULL));

    if(cb != *pcbRead)
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x\t\t(Short read 0x%x bytes)\n",
                            _hFile, *pcbRead));
    }

#else // ifndef USE_OVERLAPPED
    if (!FilePointerEqual(iPosition))
    {
        OVERLAPPED Overlapped;
#ifdef LARGE_DOCFILE
        LARGE_INTEGER ulPosition;
        ulPosition.QuadPart = iPosition;

        Overlapped.Offset = ulPosition.LowPart;
        Overlapped.OffsetHigh = ulPosition.HighPart;
#else
        Overlapped.Offset = iPosition;
        Overlapped.OffsetHigh = 0;
#endif
        Overlapped.hEvent = NULL;

        filestDebug((DEB_FILEIO,
                    "File=%2x ReadFile (w/seek) @ 0x%06x, 0x%04x bytes\n",
                    _hFile, (ULONG)iPosition, cb));
        if (!ReadFile(_hFile, pb, cb, pcbRead, &Overlapped))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
                fsErr(EH_Err, LAST_STG_SCODE);
        }
    }
    else
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x ReadFile @ 0x%Lx, 0x%04x bytes\n",
                    _hFile, iPosition, cb));
        boolChk(ReadFile(_hFile, pb, cb, pcbRead, NULL));
    }

    if(cb != *pcbRead)
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x\t\t(Short read 0x%04x bytes)\n",
                            _hFile, *pcbRead));
    }
#endif // USE_OVERLAPPED

    // if 0 bytes were read, the seek pointer has not changed
    if (*pcbRead > 0)
        SetCachedFilePointer(iPosition + *pcbRead);

    return S_OK;

EH_Err:
    filestDebug((DEB_ERROR|DEB_FILEIO, "ReadAt_FromFile Error = %x\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::WriteAt, public
//
//  Synopsis:   Writes bytes at a specific point in a stream
//
//  Arguments:  [ulPosition] - Offset in file
//              [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------
STDMETHODIMP CFileStream::WriteAt(ULARGE_INTEGER ulPosition,
                                  VOID const *pb,
                                  ULONG cb,
                                  ULONG *pcbWritten)
{
    SCODE sc;
    LONG lHigh = ULIGetHigh(ulPosition);
    ULONG uLow = ULIGetLow(ulPosition);

#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif
#ifndef LARGE_DOCFILE
    fsAssert(lHigh == 0 && 
             aMsg("High dword other than zero passed to filestream."));
#endif


    filestDebug((DEB_ITRACE, "In  CFileStream::WriteAt:%p("
                 "%x:%x, %p, %x, %p)\n", this, ULIGetHigh(ulPosition),
                 ULIGetLow(ulPosition), pb, cb, pcbWritten));

#ifdef ASYNC
    DWORD dwTerminate;
    dwTerminate = _pgfst->GetTerminationStatus();
    if (dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((dwTerminate == TERMINATED_NORMAL) ||
             (uLow + cb <= _pgfst->GetHighWaterMark()))
    {
#endif
#ifdef LARGE_DOCFILE
        sc = WriteAtWorker(ulPosition, pb, cb, pcbWritten);
#else
        sc = WriteAtWorker(uLow, pb, cb, pcbWritten);
#endif
#ifdef ASYNC
    }
    else
    {
        *pcbWritten = 0;
#ifdef LARGE_DOCFILE
        _pgfst->SetFailurePoint(cb + ulPosition.QuadPart);
#else
        _pgfst->SetFailurePoint(cb + uLow);
#endif
        sc = E_PENDING;
    }

#endif

    filestDebug((DEB_ITRACE, "Out CFileStream::WriteAt => %x\n", sc));
    return sc;
}


#ifdef LARGE_DOCFILE
SCODE CFileStream::WriteAtWorker(ULARGE_INTEGER ulPosition,
#else
SCODE CFileStream::WriteAtWorker(ULONG uLow,
#endif
                                 VOID const *pb,
                                 ULONG cb,
                                 ULONG *pcbWritten)
{
    SCODE sc;
#ifdef LARGE_DOCFILE
    ULONG uLow = ulPosition.LowPart;
#endif

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);
    *pcbWritten = 0;

#ifdef LARGE_DOCFILE
    fsChk(PossibleDiskFull(ulPosition.QuadPart + cb));
#else
    fsChk(PossibleDiskFull(uLow + cb));
#endif

#ifdef USE_FILEMAPPING
#ifdef LARGE_DOCFILE
    if (ulPosition.QuadPart + cb < MAX_ULONG/2)
        MakeFileMapAddressValid(uLow + cb);
    else
        TurnOffMapping(TRUE);
#else
    MakeFileMapAddressValid(uLow + cb);
#endif

    if (IsFileMapped())
    {
        filestDebug((DEB_MAPIO,
                        "File=%2x Write Mapfile @ 0x%06x, 0x%04x bytes\n",
                        _hFile, uLow, cb));

        __try
            {
                memcpy (_pbBaseAddr+uLow, pb, cb);
            }
        __except (EXCEPTION_EXECUTE_HANDLER)
            {
                filestDebug((DEB_WARN|DEB_MAP,
                    "File=%2x Mapfile WRITEFAULT Xfer 0x%x bytes @ 0x%x %x\n",
                    _hFile, cb, uLow, GetExceptionCode()));
                return STG_E_WRITEFAULT;
            }
        *pcbWritten = cb;

        _pgfst->SetMapState(FSTSTATE_DIRTY);

        if(_pgfst->GetMappedFileSize() < uLow + cb)
            _pgfst->SetMappedFileSize(uLow + cb);
        return S_OK;
    }
#endif

#ifndef USE_OVERLAPPED
#ifdef LARGE_DOCFILE
    negChk(SeekTo(ulPosition.QuadPart));
#else
    negChk(SeekTo(uLow));
#endif

    filestDebug((DEB_FILEIO,
                "File=%2x WriteFile (old code) @ 0x%06x, 0x%04x bytes\n",
                _hFile, uLow, cb));
    boolChk(WriteFile(_hFile, pb, cb, pcbWritten, NULL));
#else // ifndef USE_OVERLAPPED
#ifdef LARGE_DOCFILE
    if (!FilePointerEqual(ulPosition.QuadPart))
#else
    if (!FilePointerEqual(uLow))
#endif
    {
        OVERLAPPED Overlapped;
#ifdef LARGE_DOCFILE
        Overlapped.Offset = ulPosition.LowPart;
        Overlapped.OffsetHigh = ulPosition.HighPart;
#else
        Overlapped.Offset = uLow;
        Overlapped.OffsetHigh = 0;
#endif
        Overlapped.hEvent = NULL;
        filestDebug((DEB_FILEIO,
                    "File=%2x WriteFile (w/seek) @ 0x%06x, 0x%04x bytes\n",
                    _hFile, uLow, cb));
        boolChk(WriteFile(_hFile, pb, cb, pcbWritten,&Overlapped));
    }
    else
    {
        filestDebug((DEB_FILEIO,
                    "File=%2x WriteFile @ 0x%06x, 0x%04x bytes\n",
                    _hFile, uLow, cb));
        boolChk(WriteFile(_hFile, pb, cb, pcbWritten, NULL));
    }
#endif
#ifdef LARGE_DOCFILE
    SetCachedFilePointer(ulPosition.QuadPart + *pcbWritten);
#else
    SetCachedFilePointer(uLow + *pcbWritten);
#endif
    if(_pgfst->GetMappedFileSize() < uLow + cb)
       _pgfst->SetMappedFileSize(uLow + cb);

    olLowLog(("STGIO - Write: %8x at %8x, %8d, %8d -->\n", _hFile, uLow, cb, *pcbWritten));

    sc = S_OK;

EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::Flush, public
//
//  Synopsis:   Flushes buffers
//
//  Returns:    Appropriate status code
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::Flush(void)
{
    CheckSeekPointer();

#if WIN32 == 200
    SCODE sc = S_OK;

    if (_hReserved == INVALID_FH)
    {
        if (!DuplicateHandle(GetCurrentProcess(), _hFile, GetCurrentProcess(),
                             &_hReserved, 0, FALSE, DUPLICATE_SAME_ACCESS))
        {
            //We couldn't get a handle, so flush everything just to be
            //safe.
            sc = FlushCache();
        }
        else
        {
            fsAssert(_hReserved != INVALID_FH);
            fsVerify(CloseHandle(_hReserved));
            _hReserved = INVALID_FH;
        }
    }
    else
    {
        //In this case, we already have a duplicate of the file handle
        //  reserved, so close it, then reopen it again.
        fsVerify(CloseHandle(_hReserved));
        _hReserved = INVALID_FH;
    }

    if ((_hReserved == INVALID_FH) && (_grfLocal & LFF_RESERVE_HANDLE))
    {
        //Reacquire reserved handle.
        //If this fails there isn't anything we can do about it.  We'll
        //  try to reacquire the handle later when we really need it.
        DuplicateHandle(GetCurrentProcess(), _hFile, GetCurrentProcess(),
                        &_hReserved, 0, FALSE, DUPLICATE_SAME_ACCESS);
    }

    return ResultFromScode(sc);
#else

    // Otherwise on NT, the file system does the right thing, we think.
    return S_OK;
#endif
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::FlushCache, public
//
//  Synopsis:   Flushes buffers
//
//  Returns:    Appropriate status code
//
//  History:    12-Feb-93       AlexT   Created
//
//  Notes:
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::FlushCache(void)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::Flush()\n"));
    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    boolChk(FlushFileBuffers(_hFile));
    if (IsFileMapped())
        boolChk(FlushViewOfFile(_pbBaseAddr, 0));
    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::Flush\n"));
EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::SetSize, public
//
//  Synopsis:   Sets the size of the LStream
//
//  Arguments:  [ulSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::SetSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif

#ifndef LARGE_DOCFILE
    ULONG uLow = ULIGetLow(ulSize);
    LONG lHigh = ULIGetHigh(ulSize);
    fsAssert(lHigh == 0 &&
             aMsg("High dword other than zero passed to filestream."));
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::SetSize:%p(%Lx)\n",
                 this, ulSize.QuadPart));

#ifdef ASYNC
    DWORD dwTerminate;
    dwTerminate = _pgfst->GetTerminationStatus();
    if (dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((dwTerminate == TERMINATED_NORMAL) ||
#ifdef LARGE_DOCFILE
             (ulSize.QuadPart <= _pgfst->GetHighWaterMark()))
#else
             (uLow <= _pgfst->GetHighWaterMark()))
#endif
    {
#endif
#ifdef LARGE_DOCFILE
        sc = SetSizeWorker(ulSize.QuadPart);
#else
        sc = SetSizeWorker(uLow);
#endif
#ifdef ASYNC
    }
    else
    {
#ifdef LARGE_DOCFILE
        _pgfst->SetFailurePoint(ulSize.QuadPart);
#else
        _pgfst->SetFailurePoint(uLow);
#endif
        sc = E_PENDING;
    }
#endif
    return sc;
}


//+--------------------------------------------------------------
//
//  Member:     CFileStream::SetSizeWorker, Private
//
//  Synopsis:   Sets the size of the File
//
//  Arguments:  [ulSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//              16-Jan-97       BChapman Added Support for File Mapping
//              08-Mar-97       BChapman Fixes for File Mapping
//
//  Note:  If the file is mapped then we grow the file with VirtualAlloc
//      and shrink it at unmap time with SetEndOfFile() and the intended
//      size recorded in the _pgfst.
//      If we are NOT mapped then we use normal File I/O. But things can
//      get tricky if we are switching from mapped to unmapped and all the
//      other marshalled opens have not yet unmapped.  If anyone has the
//      file mapped then SetEndOfFile doesn't work.
//      To avoid this we grow with WriteFile() and we try to shrink with
//      SetEndOfFile().  But we also always put the intended size in _pgfst,
//      so if the other guy has the file mapped he will shrink the file
//      when he unmaps.
//---------------------------------------------------------------

#ifdef LARGE_DOCFILE
SCODE CFileStream::SetSizeWorker(ULONGLONG ulSize)
#else
SCODE CFileStream::SetSizeWorker(ULONG uLow)
#endif
{
    SCODE sc;

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

#ifdef LARGE_DOCFILE
    fsChk(PossibleDiskFull(ulSize));

    if (ulSize < MAX_ULONG/2)
        MakeFileMapAddressValid((ULONG)ulSize);
    else
        TurnOffMapping(TRUE);
#else
    fsChk(PossibleDiskFull(uLow));

    MakeFileMapAddressValid(uLow);
#endif


    // Always record the intended size, because the mapped size is stored
    // globaly.  You might not be mapped but other marshalled opens could
    // be (they will fall back as soon as they run).
#ifdef USE_FILEMAPPING
#ifdef LARGE_DOCFILE
    // A memory mapped file can never be greater than 2G, even for 64-bit
    // platforms, because of the range locks at offset 2G in the file.
    _pgfst->SetMappedFileSize(ulSize > MAX_ULONG ? MAX_ULONG : (ULONG) ulSize);
#else
    _pgfst->SetMappedFileSize(uLow);
#endif
    _pgfst->SetMapState(FSTSTATE_DIRTY);
#endif // USE_FILEMAPPING

    if(!IsFileMapped())
    {
        ULARGE_INTEGER uliFileSize;
        ULONG ulZero=0;
        DWORD cbWritten;

        fsChk(GetSize(&uliFileSize));

#ifdef LARGE_DOCFILE
        if(uliFileSize.QuadPart == ulSize)
#else
        Assert (0 == uliFileSize.HighPart);

        if(uliFileSize.LowPart == uLow)
#endif
        {
#ifdef LARGE_DOCFILE
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%Lx)"
                                    " size didn't change\n",
                                    _hFile, ulSize));
#else
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%06x)"
                                    " size didn't change\n",
                                    _hFile, uLow));
#endif
            return S_OK;
        }


        // Grow the file.
        //
#ifdef LARGE_DOCFILE
        if(uliFileSize.QuadPart < ulSize &&
           !(_pgfst->GetDFlags() & DF_LARGE))
        {
            ULARGE_INTEGER uli;
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%Lx)"
                                    " increasing from 0x%Lx\n",
                                    _hFile, ulSize, uliFileSize));
            uli.QuadPart = ulSize - 1;
            fsChk(WriteAtWorker(uli, (LPCVOID)&ulZero, 1, &cbWritten));
        }
#else
        if(uliFileSize.LowPart < uLow)
        {
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%06x)"
                                    " increasing from 0x%06x\n",
                                    _hFile, uLow, uliFileSize.LowPart));
            fsChk(WriteAtWorker(uLow-1, (LPCVOID)&ulZero, 1, &cbWritten));
        }
#endif
        // Shrink the file or large sector docfile
        //
        else
        {
#ifdef LARGE_DOCFILE
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%Lx)"
                                    " reducing from 0x%Lx\n",
                                    _hFile, ulSize, uliFileSize));
            negChk(SeekTo(ulSize));
#else
            filestDebug((DEB_FILEIO, "File=%2x SetSizeWorker(0x%06x)"
                                    " reducing from 0x%06x\n",
                                    _hFile, uLow, uliFileSize.LowPart));
            negChk(SeekTo(uLow));
#endif
            if(FALSE == SetEndOfFile(_hFile))
            {
                sc = LAST_STG_SCODE;
                // If a seperate marshaling still has the file mapped then
                // this will fail.  But this particular error is OK.
                //
                if(WIN32_SCODE(ERROR_USER_MAPPED_FILE) == sc)
                {
                    sc = S_OK;
                }
                fsChk (sc);
            }
        }
    }

    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::SetSize\n"));

EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SeekTo, private
//              CFileStream::GetFilePointer, private
//
//  Synopsis:	Wrap calls to SetFilePointer to make the usage more clear.
//              Esp. in the GetFilePointer case.
//
//  History:	07-Nov-96    BChapman Created
//
//----------------------------------------------------------------------------

#ifdef LARGE_DOCFILE
ULONGLONG CFileStream::SeekTo(ULONGLONG ulPos)
{
    LARGE_INTEGER uliPos;

    if(FilePointerEqual(ulPos))
    {
        filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%Lx) (cache hit)\n",
                                _hFile, ulPos));
        return ulPos;
    }

    uliPos.QuadPart = ulPos;
    uliPos.LowPart = 
        SetFilePointer(_hFile, uliPos.LowPart, &uliPos.HighPart, FILE_BEGIN);

    if (uliPos.LowPart == MAX_ULONG && GetLastError() != NO_ERROR)
        return MAX_ULONGLONG;  // 0xFFFFFFFFFFFFFFFF

    SetCachedFilePointer(uliPos.QuadPart);

    filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%Lx)\n", _hFile, ulPos));
    olLowLog(("STGIO - Seek : %8x at %Lx\n", _hFile, ulPos));

    return uliPos.QuadPart;
}

ULONGLONG CFileStream::GetFilePointer()
{
    LARGE_INTEGER ulPos = {0,0};

    ulPos.LowPart = SetFilePointer(_hFile, 0, &ulPos.HighPart, FILE_CURRENT);
    filestDebug((DEB_SEEK, "File=%2x GetFilePointer() => 0x%Lx\n",
                            _hFile, ulPos));
    return ulPos.QuadPart;
}
#else
DWORD CFileStream::SeekTo(ULONG Low)
{
    DWORD dwPos;

    if(FilePointerEqual(Low))
    {
        filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%06x) (cache hit)\n",
                                _hFile, Low));
        return Low;
    }

    if(0xFFFFFFFF == (dwPos = SetFilePointer(_hFile, Low, NULL, FILE_BEGIN)))
        return dwPos;

    SetCachedFilePointer(dwPos);

    filestDebug((DEB_SEEK, "File=%2x SeekTo(0x%06x)\n", _hFile, Low));
    olLowLog(("STGIO - Seek : %8x at %8x\n", _hFile, Low));

    return dwPos;
}

DWORD CFileStream::GetFilePointer()
{
    DWORD dwPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);
    filestDebug((DEB_SEEK, "File=%2x GetFilePointer() => 0x%06x\n",
                            _hFile, dwPos));
    return dwPos;
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CFileStream::LockRegion, public
//
//  Synopsis:   Gets a lock on a portion of the LStream
//
//  Arguments:  [ulStartOffset] - Lock start
//              [cbLockLength] - Length
//              [dwLockType] - Exclusive/Read only
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::LockRegion(ULARGE_INTEGER ulStartOffset,
                                     ULARGE_INTEGER cbLockLength,
                                     DWORD dwLockType)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::LockRegion("
                 "%x:%x, %x:%x, %x)\n", ULIGetHigh(ulStartOffset),
                 ULIGetLow(ulStartOffset), ULIGetHigh(cbLockLength),
                 ULIGetLow(cbLockLength), dwLockType));
    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    filestDebug((DEB_LOCK, "File=%2x LockRegion   %1x:%x bytes @ %1x:%x\n",
                        ULIGetLow(cbLockLength), ULIGetHigh(cbLockLength),
                        ULIGetLow(ulStartOffset), ULIGetHigh(ulStartOffset)));

    boolChk(LockFile(_hFile, ULIGetLow(ulStartOffset),
                     ULIGetHigh(ulStartOffset), ULIGetLow(cbLockLength),
                     ULIGetHigh(cbLockLength)));

    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::LockRegion\n"));
EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Member:     CFileStream::UnlockRegion, public
//
//  Synopsis:   Releases an existing lock
//
//  Arguments:  [ulStartOffset] - Lock start
//              [cbLockLength] - Length
//              [dwLockType] - Lock type
//
//  Returns:    Appropriate status code
//
//  History:    20-Feb-92       DrewB   Created
//
//  Notes:      Must match an existing lock exactly
//
//---------------------------------------------------------------

STDMETHODIMP CFileStream::UnlockRegion(ULARGE_INTEGER ulStartOffset,
                                       ULARGE_INTEGER cbLockLength,
                                       DWORD dwLockType)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::UnlockRegion("
                 "%x:%x, %x:%x, %x)\n", ULIGetHigh(ulStartOffset),
                 ULIGetLow(ulStartOffset), ULIGetHigh(cbLockLength),
                 ULIGetLow(cbLockLength), dwLockType));

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    filestDebug((DEB_LOCK, "File=%2x UnlockRegion %1x:%x bytes @ %1x:%x\n",
                            ULIGetLow(cbLockLength), ULIGetHigh(cbLockLength),
                            ULIGetLow(ulStartOffset), ULIGetHigh(ulStartOffset)));

    boolChk(UnlockFile(_hFile, ULIGetLow(ulStartOffset),
                       ULIGetHigh(ulStartOffset),
                       ULIGetLow(cbLockLength),
                       ULIGetHigh(cbLockLength)));

    sc = S_OK;

    filestDebug((DEB_ITRACE, "Out CFileStream::UnlockRegion\n"));
EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Function:   FileTimeToTimeT, private
//
//  Synopsis:   Converts a FILETIME to a TIME_T
//
//  Arguments:  [pft] - FILETIME
//
//  Returns:    TIME_T
//
//  History:    12-May-92       DrewB   Created
//
//+--------------------------------------------------------------

#ifdef NOFILETIME
TIME_T FileTimeToTimeT(LPFILETIME pft)
{
    WORD dt, tm;
    struct tm tmFile;

    fsVerify(FileTimeToDosDateTime(pft, &dt, &tm));
    tmFile.tm_sec = (tm&31)*2;
    tmFile.tm_min = (tm>>5)&63;
    tmFile.tm_hour = (tm>>11)&31;
    tmFile.tm_mday = dt&31;
    tmFile.tm_mon = ((dt>>5)&15)-1;
    tmFile.tm_year = (dt>>9)+80;
    return (TIME_T)mktime(&tmFile);
}
#endif

//+--------------------------------------------------------------
//
//  Member:     CFileStream::Stat, public
//
//  Synopsis:   Fills in a stat buffer for this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    25-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CFileStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::Stat(%p)\n", pstatstg));

    CheckSeekPointer();
    fsAssert(_hFile != INVALID_FH);

    fsChk(GetSize(&pstatstg->cbSize));
#ifdef NOFILETIME
    FILETIME ftCreation, ftAccess, ftWrite;
    boolChk(GetFileTime(_hFile, &ftCreation, &ftAccess, &ftWrite));
    if (ftCreation.dwLowDateTime == 0 && ftCreation.dwHighDateTime == 0)
        ftCreation = ftWrite;
    if (ftAccess.dwLowDateTime == 0 && ftAccess.dwHighDateTime == 0)
        ftAccess = ftWrite;
    pstatstg->ctime = FileTimeToTimeT(&ftCreation);
    pstatstg->atime = FileTimeToTimeT(&ftAccess);
    pstatstg->mtime = FileTimeToTimeT(&ftWrite);
#else
    boolChk(GetFileTime(_hFile, &pstatstg->ctime, &pstatstg->atime,
                        &pstatstg->mtime));
#endif
    fsHVerSucc(GetLocksSupported(&pstatstg->grfLocksSupported));
    pstatstg->type = STGTY_LOCKBYTES;
    pstatstg->grfMode = DFlagsToMode(_pgfst->GetDFlags());
    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        fsChk(GetName(&pstatstg->pwcsName));
    }
    sc = S_OK;
    CheckSeekPointer();

    filestDebug((DEB_ITRACE, "Out CFileStream::Stat\n"));
    return NOERROR;

EH_Err:
    CheckSeekPointer();
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SwitchToFile, public
//
//  Synopsis:   Changes the file this filestream uses
//
//  Arguments:  [ptcsFile] - File name
//              [ulCommitSize] -- Size needed to do overwrite commit
//              [cbBuffer] - Buffer size
//              [pvBuffer] - Buffer for file copying
//
//  Returns:    Appropriate status code
//
//  History:    08-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::SwitchToFile(OLECHAR const *ptcsFile,
#ifdef LARGE_DOCFILE
                                       ULONGLONG ulCommitSize,
#else
                                       ULONG ulCommitSize,
#endif
                                       ULONG cbBuffer,
                                       void *pvBuffer)
{
    SCODE sc;
    DWORD cbRead, cbWritten;
    FILEH hOldFile;
    WCHAR awcOldName[_MAX_PATH];
    WCHAR wcsFile[_MAX_PATH];
    DWORD dwOldStartFlags;
    ULARGE_INTEGER ulPos;
    ULONG cbBufferSave;

#ifdef ASYNC
    fsAssert((_ppc == NULL) || (_ppc->HaveMutex()));
#endif

    filestDebug((DEB_ITRACE, "In  CFileStream::SwitchToFile:%p(%s, %x, %p)\n",
                 this, ptcsFile, cbBuffer, pvBuffer));

    // Check for marshals
    //      This must be the only instance of this "context".  Other
    //      seperate opens are possible though.
    //
    if (_pgfst->CountContexts() != 1)
        fsErr(EH_Err, STG_E_EXTANTMARSHALLINGS);

    CheckSeekPointer();

    //
    //  We are about to switch physical files for this CFileStream.  So
    // turn off the mapping so we can switch to the new file.
    //
    fsChk(TurnOffMapping(TRUE));

    // Seek to beginning
    negChk(SeekTo(0));

    // Preserve old file information
    lstrcpyW(awcOldName, _pgfst->GetName());
    hOldFile = _hFile;
    dwOldStartFlags = _pgfst->GetStartFlags();

    // Set file information to prepare for new Init
    _pgfst->SetName(NULL);
    _pgfst->SetMappingName(NULL);
    _pgfst->SetMappedFileSize(0);
    _pgfst->SetMappedCommitSize(0);
    _pgfst->ResetMapState(~0UL);     // Clear All State Flags.
    _hFile = INVALID_FH;
    _pgfst->SetStartFlags((dwOldStartFlags & ~(RSF_CREATEFLAGS |
                                               RSF_CONVERT |
                                               RSF_DELETEONRELEASE |
                                               RSF_OPEN)) |
                                               RSF_CREATE);

    // Release reserved file handle so it can be consumed
    if (_hReserved != INVALID_FH)
    {
        fsVerify(CloseHandle(_hReserved));
        _hReserved = INVALID_FH;
    }

    // Attempt to create new file
    TRY
        {
            lstrcpyW(wcsFile, ptcsFile);
        }
    CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            fsErr(EH_ReplaceOld, STG_E_INVALIDPOINTER);
        }
    END_CATCH
        fsChkTo(EH_ReplaceOld, InitFile(wcsFile));

    ULARGE_INTEGER ulNewSize;
    ulNewSize.QuadPart = ulCommitSize;

    // SetSize to minimum commit size
    fsHChkTo(EH_NewFile, SetSize(ulNewSize));

    // SetSize changes the file pointer, so move it back to the beginning
    negChkTo(EH_NewFile, SeekTo(0));

    // Copy file contents
    ulPos.QuadPart = 0;
    for (;;)
    {
        BOOL fRangeLocks = IsInRangeLocks (ulPos.QuadPart, cbBuffer);
        if (fRangeLocks)
        {
            ULONG ulRangeLocksBegin = OLOCKREGIONEND_SECTORALIGNED;
            // The end of the range locks is within this cbBuffer block
            // For unbuffered I/O, make sure we skip a whole sector
            cbBufferSave = cbBuffer;
            ulRangeLocksBegin -= (_pgfst->GetDFlags() & DF_LARGE) ? 4096 : 512;
            cbBuffer = ulRangeLocksBegin - ulPos.LowPart;
        }

        if (cbBuffer > 0)
        {
            boolChkTo(EH_NewFile,
                  ReadFile(hOldFile, pvBuffer, (UINT)cbBuffer, &cbRead, NULL));
            if (cbRead == 0)
                break;      // EOF

            fsChkTo(EH_NewFile, WriteAt(ulPos, pvBuffer, cbRead, &cbWritten));
            if (cbWritten != cbRead)
                fsErr(EH_NewFile, STG_E_WRITEFAULT);
        }

        if (fRangeLocks)
        {
            cbBuffer = cbBufferSave;
            cbWritten = cbBuffer;
        }
        ulPos.QuadPart += cbWritten;
        if (fRangeLocks)
        {
            // If we've skipped the range locks, move past them
            if (SetFilePointer(hOldFile, ulPos.LowPart, (LONG*)&ulPos.HighPart,
                 FILE_BEGIN) == MAX_ULONG)
                fsChkTo(EH_NewFile, STG_SCODE(GetLastError()));
        }
    }

    fsVerify(CloseHandle(hOldFile));
    if (dwOldStartFlags & RSF_DELETEONRELEASE)
    {
        // This is allowed to fail if somebody else has
        // the file open
        DeleteTheFile(awcOldName);
    }


    filestDebug((DEB_ITRACE, "Out CFileStream::SwitchToFile\n"));
    SetCachedFilePointer(GetFilePointer());
    return S_OK;

EH_NewFile:
    TurnOffMapping(FALSE);
    fsVerify(CloseHandle(_hFile));
    fsVerify(DeleteTheFile(_pgfst->GetName()));
EH_ReplaceOld:
    _hFile = hOldFile;
    if (_pgfst != NULL)
    {
        _pgfst->SetName(awcOldName);
        _pgfst->SetStartFlags(dwOldStartFlags);
    }

EH_Err:
    SetCachedFilePointer(GetFilePointer());
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::Delete, public
//
//  Synopsis:   Closes and deletes the file, errors ignored
//
//  Returns:    Appropriate status code
//
//  History:    09-Feb-93       DrewB   Created
//
//----------------------------------------------------------------------------

void CFileStream::Delete(void)
{
    filestDebug((DEB_ITRACE, "In  CFileStream::Delete:%p()\n", this));

    TurnOffAllMappings();

    if (_hFile != INVALID_FH)
        CloseHandle(_hFile);
    _hFile = INVALID_FH;

    if (_hReserved != INVALID_FH)
        CloseHandle(_hReserved);
    _hReserved = INVALID_FH;

    DeleteTheFile(_pgfst->GetName());

    filestDebug((DEB_ITRACE, "Out CFileStream::Delete\n"));
}

//+--------------------------------------------------------------
//
//  Member:	CFileStream::DeleteTheFile, public
//
//  Synopsis:	Delete the file (using WideWrap DeleteFile), but don't
//              if we don't think the system as already done so.
//
//  History:	21-Jan-97	BChapman	Created
//
//---------------------------------------------------------------

BOOL CFileStream::DeleteTheFile(const WCHAR *pwcName)
{
#ifndef MAC
    //
    // If the file is a "TEMPFILE" then it is DELETE_ON_CLOSE
    // and the system already deleted it.
    //
    if(RSF_TEMPFILE & GetStartFlags())
        return S_OK;
#endif
    return DeleteFile(_pgfst->GetName());
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::ReserveHandle, public
//
//  Synopsis:   Reserves a backup file handle for handle-required operations
//
//  Returns:    Appropriate status code
//
//  History:    01-Jul-93       DrewB   Created
//
//  Notes:      May be called with a handle already reserved
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::ReserveHandle(void)
{
    SCODE sc;

    filestDebug((DEB_ITRACE, "In  CFileStream::ReserveHandle:%p()\n", this));
    if (_hReserved == INVALID_FH &&
        !DuplicateHandle(GetCurrentProcess(), _hFile, GetCurrentProcess(),
                         &_hReserved, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        sc = LAST_STG_SCODE;
    }
    else
    {
        filestDebug((DEB_INFO, "CFileStream reserved %p "
                    "handle %p thread %lX\n",
                    this, _hReserved, GetCurrentThreadId()));
        sc = S_OK;
        _grfLocal |= LFF_RESERVE_HANDLE;
    }
    filestDebug((DEB_ITRACE, "Out CFileStream::ReserveHandle => %lX\n", sc));
    return ResultFromScode(sc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::GetSize, public
//
//  Synopsis:   Return the size of the stream
//
//  Returns:    Appropriate status code
//
//  History:    12-Jul-93   AlexT   Created
//
//  Notes:      This is a separate method from Stat as an optimization
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::GetSize(ULARGE_INTEGER *puliSize)
{
    SCODE sc = S_OK;
    CheckSeekPointer();

    if(IsFileMapped())
    {
        puliSize->LowPart = _pgfst->GetMappedFileSize();
        puliSize->HighPart = 0;
    }
    else
#ifdef LARGE_DOCFILE
    {
        puliSize->LowPart = GetFileSize(_hFile, &puliSize->HighPart);
        if (puliSize->LowPart == MAX_ULONG && NO_ERROR != GetLastError())
            fsErr(EH_Err, LAST_STG_SCODE)
    }
#else
        negChk(puliSize->LowPart = GetFileSize(_hFile, &puliSize->HighPart));
#endif

EH_Err:
    CheckSeekPointer();
    return(ResultFromScode(sc));
}


//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SetTime, public
//
//  Synopsis:   Set the times on the ILockbytes
//
//  Arguments:  [tt] -- Which time to set
//              [nt] -- New time stamp
//
//  Returns:    Appropriate status code
//
//  History:    24-Mar-95       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CFileStream::SetTime(WHICHTIME tt,
                           TIME_T nt)
{
    filestDebug((DEB_ITRACE, "In CFileStream::SetTime()\n"));

    SCODE sc = S_OK;

    FILETIME *pctime = NULL, *patime = NULL, *pmtime = NULL;
    CheckSeekPointer();

    if (tt == WT_CREATION)
    {
        pctime = &nt;
    }
    else if (tt == WT_MODIFICATION)
    {
        pmtime = &nt;
    }
    else
    {
        patime = &nt;
    }

    boolChk(SetFileTime(_hFile,
                        pctime,
                        patime,
                        pmtime));

EH_Err:
    filestDebug((DEB_ITRACE, "Out CFileStream::SetTime() => %lx\n", sc));
    CheckSeekPointer();
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileStream::SetAllTimes, public
//
//  Synopsis:   Set the times on the ILockbytes
//
//  Arguments:  [atm] Access time
//              [mtm] Modification time
//              [ctm] Creation time
//
//  Returns:    Appropriate status code
//
//  History:    24-Nov-95       SusiA   Created
//
//----------------------------------------------------------------------------

SCODE CFileStream::SetAllTimes( TIME_T atm,
                                TIME_T mtm,
                                TIME_T ctm)
{
    filestDebug((DEB_ITRACE, "In CFileStream::SetAllTimes()\n"));

    SCODE sc = S_OK;

    CheckSeekPointer();

    boolChk(SetFileTime(_hFile, &ctm, &atm,  &mtm));

EH_Err:
    filestDebug((DEB_ITRACE, "Out CFileStream::SetAllTimes() => %lx\n", sc));
    CheckSeekPointer();
    return sc;
}


#ifdef ASYNC
//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::FillAppend, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::FillAppend(void const *pv,
                                     ULONG cb,
                                     ULONG *pcbWritten)
{
    SCODE sc;
    SAFE_SEM;
    HANDLE hEvent;

    filestDebug((DEB_ITRACE, "In  CFileStream::FillAppend:%p()\n", this));
    fsChk(TakeSafeSem());
    if (_pgfst->GetTerminationStatus() != UNTERMINATED)
    {
        sc = STG_E_TERMINATED;
    }
    else
    {
        ULONG cbWritten;
#ifdef LARGE_DOCFILE
        ULARGE_INTEGER ulHighWater;
        ulHighWater.QuadPart = _pgfst->GetHighWaterMark();
#else
        ULONG ulHighWater = _pgfst->GetHighWaterMark();
#endif

        sc = CFileStream::WriteAtWorker(ulHighWater, pv, cb, &cbWritten);
#ifdef LARGE_DOCFILE
        _pgfst->SetHighWaterMark(ulHighWater.QuadPart + cbWritten);
#else
        _pgfst->SetHighWaterMark(ulHighWater + cbWritten);
#endif
        if (pcbWritten != NULL)
        {
            *pcbWritten = cbWritten;
        }

        hEvent = _ppc->GetNotificationEvent();
        if (!PulseEvent(hEvent))
        {
            sc = Win32ErrorToScode(GetLastError());
        }
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::FillAppend\n"));
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::FillAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::FillAt(ULARGE_INTEGER ulOffset,
                                 void const *pv,
                                 ULONG cb,
                                 ULONG *pcbWritten)
{
    filestDebug((DEB_ITRACE, "In  CFileStream::FillAt:%p()\n", this));
    filestDebug((DEB_ITRACE, "Out CFileStream::FillAt\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::SetFillSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::SetFillSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
    SAFE_SEM;

    filestDebug((DEB_ITRACE,
                 "In  CFileStream::SetFillSize:%p()\n", this));

    fsChk(TakeSafeSem());
    if (_pgfst->GetTerminationStatus() == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
#ifndef LARGE_DOCFILE
        ULONG uLow = ULIGetLow(ulSize);
        LONG lHigh = ULIGetHigh(ulSize);
        fsAssert(lHigh == 0 &&
                 aMsg("High dword other than zero passed to filestream."));
#endif

#ifdef LARGE_DOCFILE
        sc = SetSizeWorker(ulSize.QuadPart);
#else
        sc = SetSizeWorker(uLow);
#endif
    }
    filestDebug((DEB_ITRACE, "Out CFileStream::SetFillSize\n"));
EH_Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileStream::Terminate, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileStream::Terminate(BOOL bCanceled)
{
    SCODE sc;
    SAFE_SEM;
    HANDLE hEvent;

    filestDebug((DEB_ITRACE, "In  CFileStream::Terminate:%p()\n", this));

    fsChk(TakeSafeSem());
    _pgfst->SetTerminationStatus((bCanceled) ?
                                 TERMINATED_ABNORMAL :
                                 TERMINATED_NORMAL);

    hEvent = _ppc->GetNotificationEvent();

    if ((hEvent != INVALID_HANDLE_VALUE) && (!SetEvent(hEvent)))
    {
        return Win32ErrorToScode(GetLastError());
    }

    filestDebug((DEB_ITRACE, "Out CFileStream::Terminate\n"));
EH_Err:
    return sc;
}

void CFileStream::StartAsyncMode(void)
{
    //Note:  No semaphore here - this must be called before the ILockBytes
    //  is returned to an app.
    _pgfst->SetTerminationStatus(UNTERMINATED);
}

STDMETHODIMP CFileStream::GetFailureInfo(ULONG *pulWaterMark,
                                         ULONG *pulFailurePoint)
{
    //We don't take a semaphore here because we don't need it.  This call
    //  is either made when we're already holding the semaphore, or is made
    //  when we don't care about the absolute accuracy of the results.
    //However, we do need a shared heap to access _pgfst
    CSafeMultiHeap smh(_ppc);
#ifdef LARGE_DOCFILE
    // This method, used by IProgressNotify, cannot handle large integers
    // If the high water mark is too big to fit, return an error
    ULONGLONG ulWaterMark = _pgfst->GetHighWaterMark();
    if (ulWaterMark < MAX_ULONG)
    {
        *pulWaterMark = (ULONG) ulWaterMark;
        *pulFailurePoint = (ULONG) _pgfst->GetFailurePoint();
        return S_OK;
    }
    else return STG_E_INVALIDFUNCTION;  // file is too big
#else
    *pulWaterMark = _pgfst->GetHighWaterMark();
    *pulFailurePoint = _pgfst->GetFailurePoint();
    return S_OK;
#endif
}

STDMETHODIMP CFileStream::GetTerminationStatus(DWORD *pdwFlags)
{
    SAFE_SEM;
    TakeSafeSem();
    *pdwFlags = _pgfst->GetTerminationStatus();
    return S_OK;
}

#endif //ASYNC

//+---------------------------------------------------------------------------
//
//  Function:   GetNtHandleSectorSize
//
//  Synopsis:   Find a volume's physical sector size
//
//  Arguments:  [Handle] -- file handle
//              [pulSectorSize] -- number of bytes per physical sector
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

HRESULT GetNtHandleSectorSize (HANDLE Handle, ULONG * pulSectorSize)
{
    FILE_FS_SIZE_INFORMATION SizeInfo;
    IO_STATUS_BLOCK iosb;

    NTSTATUS nts = NtQueryVolumeInformationFile( Handle, &iosb,
                &SizeInfo, sizeof(SizeInfo), FileFsSizeInformation );

    if (NT_SUCCESS(nts))
    {
        *pulSectorSize = SizeInfo.BytesPerSector;
        return S_OK;
    }

    return NtStatusToScode(nts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\lock.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       lock.cxx
//
//  Contents:   Remote exclusion stuff for docfile
//
//  Functions:  GetAccess
//              ReleaseAccess
//              GetOpen
//              ReleaseOpen
//
//  History:    09-Mar-92   PhilipLa    Created.
//              20-Jul-93   DrewB       Added dual locking for Mac
//                                      compatibility
//
//--------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <header.hxx>
#include <lock.hxx>

// Offset to next lock group from a particular group
#define OLOCKGROUP 1

// The docfile originally locked at 0xffffff00
// It turned out that the Mac can only lock to 0x7fffffff,
// so for compatibility reasons it was decided that the
// docfile would lock at both places.  Thus, we have one routine
// that locks with a mask for the offset so that we can
// selectively suppress the high bit
// Since lock indices fit easily within 16 bits, the two
// lock indices are now combined into the existing ULONG
// value to preserve compatibility with other code.  This
// implies that lock indices from these routines must be
// handled opaquely since they are no longer simple numbers

// 09/23/1993 - Further change:
// To avoid a Netware 2.2 problem we are offsetting the lock regions
// so that they differ by more than just the high bit.  The high
// lock region was moved to 0xffffff80, moving the low region to
// 0x7fffff80.  The 0x80 was then taken out of the high mask so that
// the net is no change for high locks and the low locks moved up by 0x80

// Masks for separate lock locations
// moved to lock.hxx

//In a specific open case (Read-only, deny-write), we don't need to
//take locks.
#define P_NOLOCK(df) (!P_WRITE(df) && P_READ(df) && \
                      P_DENYWRITE(df) && !P_DENYREAD(df))

//+--------------------------------------------------------------
//
//  Function:   GetAccessWithMask, private
//
//  Synopsis:   Takes appropriate access locks on an LStream,
//              masking the offset with the given mask
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions needed
//              [ulMask] - Mask
//              [poReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [poReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetAccessWithMask(ILockBytes *plst,
                               DFLAGS df,
                               ULONG ulMask,
                               ULONG *poReturn)
{
    SCODE sc;
    ULARGE_INTEGER ulOffset, cbLength;

    olDebugOut((DEB_ITRACE, "In  GetAccessWithMask(%p, %X, %lX, %p)\n",
                plst, df, ulMask, poReturn));
    olAssert((df & ~(DF_READ | DF_WRITE)) == 0 && P_READ(df) != P_WRITE(df));
    *poReturn = NOLOCK;
    ULISet32(ulOffset, OACCESS & ulMask);
    if (P_READ(df))
    {
        ULISet32(cbLength, 1);
        olHChk(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        for (USHORT i = 0; i < CREADLOCKS; i++)
        {
            ULISetLow(ulOffset, (OREADLOCK+i) & ulMask);
            sc = DfGetScode(plst->LockRegion(ulOffset, cbLength,
                                             LOCK_ONLYONCE));
            if (SUCCEEDED(sc))
            {
                *poReturn = i+1;
                break;
            }
        }
        ULISetLow(ulOffset, OACCESS & ulMask);
        olHVerSucc(sc = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        if (i == CREADLOCKS)
            olErr(EH_Err, STG_E_TOOMANYOPENFILES);
    }
    else
    {
        olAssert((OACCESS + 1 == OREADLOCK) && aMsg("Bad lock dependency"));
        ULISet32(cbLength, 1 + CREADLOCKS);
        olChk(DfGetScode(plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE)));
        *poReturn = 0xFFFF;
    }
    olDebugOut((DEB_ITRACE, "Out GetAccessWithMask => %lu\n", *poReturn));
    olAssert(*poReturn != NOLOCK);
    return S_OK;
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseAccessWithMask, private
//
//  Synopsis:   Releases an access lock at the given offset
//
//  Arguments:  [plst] - LStream that is locked
//              [df] - Permission to release
//              [offset] - Offset of locks taken
//              [ulMask] - Mask
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseAccessWithMask(ILockBytes *plst,
                                  DFLAGS df,
                                  ULONG offset,
                                  ULONG ulMask)
{
    ULARGE_INTEGER ulOffset, cbLength;
    SCODE scTemp;

    olDebugOut((DEB_ITRACE, "In  ReleaseAccessWithMask(%p, %lX, %lu, %lX)\n",
                plst, df, offset, ulMask));
    olAssert((df & ~(DF_READ | DF_WRITE)) == 0 && P_READ(df) != P_WRITE(df));
    if (offset == NOLOCK)
        return;
    if (P_READ(df))
    {
        ULISet32(ulOffset, (offset+OREADLOCK-1) & ulMask);
        ULISet32(cbLength, 1);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE); 
    }
    else
    {
        olAssert((OACCESS + 1 == OREADLOCK) && aMsg("Bad lock dependency"));
        ULISet32(ulOffset, OACCESS & ulMask);
        ULISet32(cbLength, 1 + CREADLOCKS);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
    olDebugOut((DEB_ITRACE, "Out ReleaseAccessWithMask\n"));
}

//+--------------------------------------------------------------
//
//  Function:   GetAccess, public
//
//  Synopsis:   Takes appropriate access locks on an LStream
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions needed
//              [poReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [poReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetAccess(ILockBytes *plst,
                DFLAGS df,
                ULONG *poReturn)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  GetAccess(%p, %X, %p)\n",
                plst, df, poReturn));

    // Make sure our lock region hasn't overflowed 32 bits
    olAssert(OLOCKREGIONEND > OACCESS);

    olChk(GetAccessWithMask(plst, df, 0xFFFFFFFF, poReturn));
    olAssert(*poReturn < 0x10000);

    olDebugOut((DEB_ITRACE, "Out GetAccess => %lu\n", *poReturn));
    return S_OK;

 EH_Err:
    *poReturn = NOLOCK;
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseAccess, public
//
//  Synopsis:   Releases access locks
//
//  Arguments:  [plst] - LStream that is locked
//              [df] - Permission to release
//              [offset] - Offset of locks taken
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseAccess(ILockBytes *plst, DFLAGS df, ULONG offset)
{
    olDebugOut((DEB_ITRACE, "In  ReleaseAccess(%p, %lX, %lu)\n",
                plst, df, offset));

    ReleaseAccessWithMask(plst, df, offset & 0xffff, 0xFFFFFFFF);

    olDebugOut((DEB_ITRACE, "Out ReleaseAccess\n"));
}

//+--------------------------------------------------------------
//
//  Function:   GetOpenWithMask, private
//
//  Synopsis:   Gets locks on an LStream during opening, masking the offset
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions to take
//              [fCheck] - Whether to check for existing locks or not
//              [ulMask] - Mask
//              [puReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [puReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

#define WAITUPDATE_INITIAL 100
#define WAITUPDATE_TIMEOUT 10000

SCODE GetOpenWithMask(ILockBytes *plst,
                             DFLAGS df,
                             BOOL fCheck,
                             ULONG ulMask,
                             ULONG *puReturn)
{
    SCODE sc;
    ULONG i;
    ULARGE_INTEGER ulOffset, cbLength;
#ifdef DIRECTWRITERLOCK
    BOOL fDirectWriterMode = P_READWRITE(df) && !P_TRANSACTED(df) &&
                            !P_DENYREAD(df) && P_DENYWRITE(df);
    BOOL fDirectReaderMode = P_READ(df) && !P_WRITE(df) && !P_TRANSACTED(df) &&
                            !P_DENYREAD(df) && !P_DENYWRITE(df);
#endif

    olDebugOut((DEB_ITRACE, "In  GetOpenWithMask(%p, %lX, %d, %lX, %p)\n",
                plst, df, fCheck, ulMask, puReturn));
    *puReturn = NOLOCK;

    ULISet32(ulOffset, OUPDATE & ulMask);
    ULISet32(cbLength, 1);

    //Do a graceful fallback.
    DWORD dwWait = WAITUPDATE_INITIAL;
    for (;;)
    {
        sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
        if (sc != STG_E_LOCKVIOLATION ||
            dwWait >= WAITUPDATE_TIMEOUT)
            break;
        Sleep(dwWait);
        dwWait *= (GetTickCount() & 1) ? 1 : 2;
    }
    olChk(sc);

    if (fCheck)
    {
        ULISetLow(cbLength, COPENLOCKS);
        if (P_DENYREAD(df))
        {
            ULISetLow(ulOffset, OOPENREADLOCK & ulMask);
            olHChkTo(EH_UnlockUpdate, plst->LockRegion(ulOffset, cbLength,
                                                       LOCK_ONLYONCE));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        }
#ifndef USE_NOSNAPSHOT
        if (P_DENYWRITE(df))
#else            
        if (P_DENYWRITE(df) || P_NOSNAPSHOT(df))
#endif            
        {
            ULISetLow(ulOffset, OOPENWRITELOCK & ulMask);
            sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
            if (SUCCEEDED(sc))
            {
                olHVerSucc(plst->UnlockRegion(ulOffset,
                                              cbLength,
                                              LOCK_ONLYONCE));
            }
#ifdef USE_NOSNAPSHOT            
            else if (P_NOSNAPSHOT(df))
            {
                //There is an existing writer.  In order for this
                //open to succeed, there must also be a lock in the
                //no-snapshot region.  Otherwise we have a case where
                //a normal open proceeded a no-snapshot open attempt,
                //and mixing modes is not allowed.
                ULISetLow(ulOffset, OOPENNOSNAPSHOTLOCK & ulMask);
                sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
                if (SUCCEEDED(sc))
                {
                    //There was no no-snapshot lock.  No mixing modes,
                    //so fail here.
                    olHVerSucc(plst->UnlockRegion(ulOffset,
                                                  cbLength,
                                                  LOCK_ONLYONCE));
                    olErr(EH_UnlockUpdate, STG_E_LOCKVIOLATION);
                }
            }
#endif            
            else
            {
                olErr(EH_UnlockUpdate, sc);
            }
        }
        if (P_READ(df))
        {
            ULISetLow(ulOffset, OOPENDENYREADLOCK & ulMask);
            olHChkTo(EH_UnlockUpdate, plst->LockRegion(ulOffset, cbLength,
                                                       LOCK_ONLYONCE));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        }
        if (P_WRITE(df))
        {
            ULISetLow(ulOffset, OOPENDENYWRITELOCK & ulMask);
#ifndef USE_NOSNAPSHOT            
            olHChkTo(EH_UnlockUpdate, plst->LockRegion(ulOffset, cbLength,
                                                       LOCK_ONLYONCE));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
#else
            sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
            if (P_NOSNAPSHOT(df) && (sc == STG_E_LOCKVIOLATION))
            {
                //The deny-write lock may be the fake holder we use for
                //no-snapshot mode.  Check then no-snapshot region - if
                //there is a lock there too, then this succeeds, otherwise
                //the deny-write lock is real and we must fail the call.
                ULISetLow(ulOffset, OOPENNOSNAPSHOTLOCK & ulMask);
                sc = plst->LockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
                if (sc != STG_E_LOCKVIOLATION)
                {
                    if (SUCCEEDED(sc))
                    {
                        olHVerSucc(plst->UnlockRegion(ulOffset,
                                                      cbLength,
                                                      LOCK_ONLYONCE));
                        olErr(EH_UnlockUpdate, STG_E_LOCKVIOLATION);
                    }
                    else
                    {
                        olErr(EH_UnlockUpdate, sc);
                    }
                }
            }
            else
            {
                olHChkTo(EH_UnlockUpdate, sc);
                olHVerSucc(plst->UnlockRegion(ulOffset,
                                              cbLength,
                                              LOCK_ONLYONCE));
            }
#endif            
        }
    }
    
    //If we are read-only and deny-write, and we are on our
    //  ILockBytes, we don't need to lock and can rely on the FS
    //  to handle the access control.
    if (P_NOLOCK(df))
    {
        //QueryInterface to see if this ILockBytes is ours

        IFileLockBytes *pfl;
        if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes,
                                          (void **) &pfl)))
        {
            pfl->Release();
            
            ULISetLow(ulOffset, OUPDATE & ulMask);
            ULISetLow(cbLength, 1);
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
            
            *puReturn = NOLOCK;
            return S_OK;
        }
    }
    

    ULISetLow(cbLength, 1);
    for (i = 0; i < COPENLOCKS; i = i + OLOCKGROUP)
    {
        ULISetLow(ulOffset, (OOPENREADLOCK+i) & ulMask);
        olHChkTo(EH_Loop, plst->LockRegion(ulOffset, cbLength,
                                          LOCK_ONLYONCE));
        ULISetLow(ulOffset, (OOPENWRITELOCK+i) & ulMask);
        olHChkTo(EH_UnlockR, plst->LockRegion(ulOffset, cbLength,
                                             LOCK_ONLYONCE));
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+i) & ulMask);
#ifdef DIRECTWRITERLOCK
        if (fCheck == TRUE || fDirectWriterMode == FALSE)
#endif
        olHChkTo(EH_UnlockW, plst->LockRegion(ulOffset, cbLength,
                                             LOCK_ONLYONCE));
        ULISetLow(ulOffset, (OOPENDENYWRITELOCK+i) & ulMask);
#ifdef USE_NOSNAPSHOT
        olHChkTo(EH_UnlockDR, plst->LockRegion(ulOffset, cbLength,
                                               LOCK_ONLYONCE));
        if (P_NOSNAPSHOT(df))
        {
            //Note that in the non no-snapshot case we don't need to
            //grab this lock, unlike the others where we must grab all
            //four to make sure we have a valid slot.  This is because
            //a no-snapshot open will always have a corresponding
            //deny-write lock in the same slot.
            ULISetLow(ulOffset, (OOPENNOSNAPSHOTLOCK+i) & ulMask);
            if (SUCCEEDED(DfGetScode(plst->LockRegion(ulOffset, cbLength,
                                                      LOCK_ONLYONCE))))
            {
                break;
            }
            //Unlock the deny-write lock, then all the rest.
            ULISetLow(ulOffset, (OOPENDENYWRITELOCK + i));
            olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
        }
        else
        {
            //We're not no-snapshot, and we've gotten all our locks
            //  successfully, so bail.
#ifdef DIRECTWRITERLOCK
            if (fDirectReaderMode)
            {
                ULISetLow(ulOffset, (ODIRECTWRITERLOCK+i) & ulMask);
                if(SUCCEEDED(plst->LockRegion(ulOffset,cbLength,LOCK_ONLYONCE)))
                    break;
            }
            else
#endif
            break;
        }
    EH_UnlockDR:
#else
        if (SUCCEEDED(DfGetScode(plst->LockRegion(ulOffset, cbLength,
                                                  LOCK_ONLYONCE))))
#ifdef DIRECTWRITERLOCK
            if (fDirectReaderMode)
            {
                ULISetLow(ulOffset, (ODIRECTWRITERLOCK+i) & ulMask);
                if(SUCCEEDED(plst->LockRegion(ulOffset,cbLength,LOCK_ONLYONCE)))
                    break;
            }
            else
#endif
            break;
#endif //USE_NOSNAPSHOT
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+i) & ulMask);
#ifdef DIRECTWRITERLOCK
        if (fCheck == TRUE || fDirectWriterMode == FALSE)
#endif
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    EH_UnlockW:
        ULISetLow(ulOffset, (OOPENWRITELOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    EH_UnlockR:
        ULISetLow(ulOffset, (OOPENREADLOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    EH_Loop:
        ;
    }
    if (i >= COPENLOCKS)
        olErr(EH_UnlockUpdate, STG_E_TOOMANYOPENFILES);
    if (!P_READ(df))
    {
        ULISetLow(ulOffset, (OOPENREADLOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
    if (!P_WRITE(df))
    {
        ULISetLow(ulOffset, (OOPENWRITELOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
    if (!P_DENYREAD(df))
    {
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+i) & ulMask);
#ifdef DIRECTWRITERLOCK
        if (fCheck == TRUE || fDirectWriterMode == FALSE)
#endif
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
#ifdef USE_NOSNAPSHOT    
    if (!P_DENYWRITE(df) && !P_NOSNAPSHOT(df))
#else
    if (!P_DENYWRITE(df))
#endif        
    {
        ULISetLow(ulOffset, (OOPENDENYWRITELOCK+i) & ulMask);
        olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
    }
    ULISetLow(ulOffset, OUPDATE & ulMask);
    olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));

    //  0 <= i < COPENLOCKS, but 0 is the invalid value, so increment
    //  on the way out
    *puReturn = i + 1;
    olAssert(*puReturn != NOLOCK);

    olDebugOut((DEB_ITRACE, "Out GetOpenWithMask => %lu\n", *puReturn));
    return S_OK;
EH_UnlockUpdate:
    ULISetLow(ulOffset, OUPDATE & ulMask);
    ULISetLow(cbLength, 1);
    olHVerSucc(plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE));
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseOpenWithMask, private
//
//  Synopsis:   Releases opening locks with offset masking
//
//  Arguments:  [plst] - LStream
//              [df] - Locks taken
//              [offset] - Index of locks
//              [ulMask] - Mask
//
//  Requires:   offset != NOLOCK
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseOpenWithMask(ILockBytes *plst,
                                DFLAGS df,
                                ULONG offset,
                                ULONG ulMask)
{
    ULARGE_INTEGER ulOffset, cbLength;
    SCODE scTemp;

    olDebugOut((DEB_ITRACE, "In  ReleaseOpenWithMask(%p, %lX, %lu, %lX)\n",
                plst, df, offset, ulMask));

    olAssert(offset != NOLOCK);

    //  we incremented at the end of GetOpen, so we decrement here
    //  to restore the proper lock index
    offset--;

    ULISetHigh(ulOffset, 0);
    ULISet32(cbLength, 1);
    if (P_READ(df))
    {
        ULISetLow(ulOffset, (OOPENREADLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
    if (P_WRITE(df))
    {
        ULISetLow(ulOffset, (OOPENWRITELOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
    if (P_DENYREAD(df))
    {
        ULISetLow(ulOffset, (OOPENDENYREADLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#ifdef USE_NOSNAPSHOT    
    if (P_DENYWRITE(df) || P_NOSNAPSHOT(df))
#else
    if (P_DENYWRITE(df))
#endif            
    {
        ULISetLow(ulOffset, (OOPENDENYWRITELOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#ifdef USE_NOSNAPSHOT    
    if (P_NOSNAPSHOT(df))
    {
        ULISetLow(ulOffset, (OOPENNOSNAPSHOTLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#endif
#ifdef DIRECTWRITERLOCK
    BOOL fDirectReaderMode = P_READ(df) && !P_WRITE(df) && !P_TRANSACTED(df) &&
                            !P_DENYREAD(df) && !P_DENYWRITE(df);
    if (fDirectReaderMode)
    {
        ULISetLow(ulOffset, (ODIRECTWRITERLOCK+offset) & ulMask);
        scTemp = plst->UnlockRegion(ulOffset, cbLength, LOCK_ONLYONCE);
    }
#endif
    
    olDebugOut((DEB_ITRACE, "Out ReleaseOpenWithMask\n"));
}

//+--------------------------------------------------------------
//
//  Function:   GetOpen, public
//
//  Synopsis:   Gets locks on an LStream during opening
//
//  Arguments:  [plst] - LStream
//              [df] - Permissions to take
//              [fCheck] - Whether to check for existing locks or not
//              [puReturn] - Index of lock taken
//
//  Returns:    Appropriate status code
//
//  Modifies:   [puReturn]
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE GetOpen(ILockBytes *plst,
              DFLAGS df,
              BOOL fCheck,
              ULONG *puReturn)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  GetOpen(%p, %lX, %d, %p)\n",
                plst, df, fCheck, puReturn));

    // Make sure our lock region hasn't overflowed 32 bits
    olAssert(OLOCKREGIONEND > OACCESS);

    olChk(GetOpenWithMask(plst, df, fCheck, 0xFFFFFFFF, puReturn));
    olAssert(*puReturn < 0x10000);

    olDebugOut((DEB_ITRACE, "Out GetOpen => %lu\n", *puReturn));
    return S_OK;

 EH_Err:
    *puReturn = NOLOCK;
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   ReleaseOpen, public
//
//  Synopsis:   Releases opening locks
//
//  Arguments:  [plst] - LStream
//              [df] - Locks taken
//              [offset] - Index of locks
//
//  Requires:   offset != NOLOCK
//
//  History:    08-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void ReleaseOpen(ILockBytes *plst, DFLAGS df, ULONG offset)
{
    olDebugOut((DEB_ITRACE, "In  ReleaseOpen(%p, %lX, %lu)\n",
                plst, df, offset));

    if (offset != NOLOCK)
    {
        ReleaseOpenWithMask(plst, df, offset & 0xffff, 0xFFFFFFFF);
    }
    olDebugOut((DEB_ITRACE, "Out ReleaseOpen\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:	WaitForAccess, public, 32-bit only
//
//  Synopsis:	Attempts to get access locks, retrying if necessary
//              using exponential backoff
//
//  Arguments:	[plst] - ILockBytes
//              [df] - Access desired
//              [poReturn] - Lock index return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[poReturn]
//
//  History:	23-Sep-93	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef WIN32
#define WAITACCESS_INITIAL 100
#define WAITACCESS_TIMEOUT 100000

SCODE WaitForAccess(ILockBytes *plst,
                    DFLAGS df,
                    ULONG *poReturn)
{
    SCODE sc;
    DWORD dwWait;

    olDebugOut((DEB_ITRACE, "In  WaitForAccess(%p, %X, %p)\n",
                plst, df, poReturn));

    dwWait = WAITACCESS_INITIAL;
    for (;;)
    {
        sc = GetAccess(plst, df, poReturn);
        if (sc != STG_E_LOCKVIOLATION ||
            dwWait >= WAITACCESS_TIMEOUT
            )
            break;

        Sleep(dwWait);
        dwWait *= (GetTickCount() & 1) ? 1 : 2;
    }

    olDebugOut((DEB_ITRACE, "Out WaitForAccess => 0x%lX, %lu\n",
                sc, poReturn));
    return sc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\peiter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       peiter.cxx
//
//  Contents:   Implementation of PExposedIterator
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <peiter.hxx>
#include <expparam.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     PExposedIterator::hSkip, public
//
//  Synopsis:   Enumerator skip helper function
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_PExposedIterator_hSkip)
#endif

SCODE PExposedIterator::hSkip(ULONG celt, BOOL fProps)
{
    SCODE sc;
#ifndef REF
    SAFE_SEM;
    SAFE_ACCESS;
#endif //!REF
    SIterBuffer ib;

    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hSkip:%p(%lu, %d)\n",
                this, celt, fProps));
#ifndef REF
    olChk(TakeSafeSem());
    olChk(_ppdf->CheckReverted());
    SafeReadAccess();
#endif //!REF
    for (; celt>0; celt--)
    {
        sc = _ppdf->FindGreaterEntry(&_dfnKey, &ib, NULL, fProps);
        if (FAILED(sc))
        {
            if (sc == STG_E_NOMOREFILES)
                sc = S_FALSE;
            break;
        }
        _dfnKey.Set(&ib.dfnName);
    }
    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hSkip\n"));
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     PExposedIterator::hRelease, public
//
//  Synopsis:   Release helper
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_PExposedIterator_hRelease)
#endif

LONG PExposedIterator::hRelease(void)
{
    LONG lRet;

    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hRelease:%p()\n", this));

    olAssert(_cReferences > 0);

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet < 0)
    {
        lRet = 0;
    }

    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hRelease => %lu\n", lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     PExposedIterator::hQueryInterface, public
//
//  Synopsis:   QueryInterface helper
//
//  History:    18-Jan-93       DrewB   Created
//
//----------------------------------------------------------------------------

#ifdef CODESEGMENTS
#pragma code_seg(SEG_PExposedIterator_hQueryInterface)
#endif

SCODE PExposedIterator::hQueryInterface(REFIID iid,
                                        REFIID riidSelf,
                                        IUnknown *punkSelf,
                                        void **ppv)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hQueryInterface:%p("
                "riid, riidSelf, %p, %p)\n", this, punkSelf, ppv));

    OL_VALIDATE(QueryInterface(iid, ppv));
    
#ifdef MULTIHEAP
    CSafeMultiHeap smh(_ppc);
#endif
    olChk(_ppdf->CheckReverted());

    if (IsEqualIID(iid, riidSelf) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = punkSelf;
        hAddRef();
        sc = S_OK;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hQueryInterface\n"));
 EH_Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	PExposedIterator::hReset, public
//
//  Synopsis:	Reset help
//
//  History:	18-Jan-93	DrewB	Created
//
//----------------------------------------------------------------------------

SCODE PExposedIterator::hReset(void)
{
    SCODE sc;
    SAFE_SEM;
    SAFE_ACCESS;
    
    olDebugOut((DEB_ITRACE, "In  PExposedIterator::hReset:%p()\n", this));

    olChk(TakeSafeSem());
    SafeReadAccess();
    
    _dfnKey.Set((WORD)0, (BYTE *)NULL);
    sc = _ppdf->CheckReverted();
    olDebugOut((DEB_ITRACE, "Out PExposedIterator::hReset\n"));
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\seekptr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       seekptr.cxx
//
//  Contents:   Seek pointer non-inline implementation
//
//  History:    11-Aug-92       PhilipLa        Created.
//
//--------------------------------------------------------------------------
#include <exphead.cxx>
#pragma hdrstop

#include <seekptr.hxx>

//+--------------------------------------------------------------
//
//  Member:     CSeekPointer::Release, public
//
//  Synopsis:   Decrements _cReferences and delete's on noref
//
//  History:    30-Apr-92       DrewB   Created
//
//---------------------------------------------------------------

void CSeekPointer::vRelease(void)
{
    LONG lRet;
    
    olDebugOut((DEB_ITRACE, "In  CSeekPointer::Release()\n"));
    olAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
        delete this;
    olDebugOut((DEB_ITRACE, "Out CSeekPointer::Release()\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\ptrcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	ptrcache.cxx
//
//  Contents:	CPtrCache implementation
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "exphead.cxx"
#pragma hdrstop

#include <ptrcache.hxx>

//+---------------------------------------------------------------------------
//
//  Member:	CPtrCache::~CPtrCache, public
//
//  Synopsis:	Destructor
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

CPtrCache::~CPtrCache(void)
{
    CPtrBlock *pb;

    Win4Assert(_pbHead != NULL);
    while (_pbHead != &_pbFirst)
    {
        pb = _pbHead->Next();
        delete _pbHead;
        _pbHead = pb;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CPtrCache::Add, public
//
//  Synopsis:	Adds a pointer to the cache
//
//  Arguments:	[pv] - Pointer
//
//  Returns:	Appropriate status code
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

SCODE CPtrCache::Add(void *pv)
{
    CPtrBlock *pb;
    
    Win4Assert(_pbHead != NULL);
    if (_pbHead->Full())
    {
        pb = new CPtrBlock(_pbHead);
        if (pb == NULL)
            return E_OUTOFMEMORY;
        _pbHead = pb;
    }
    _pbHead->Add(pv);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CPtrCache::Next, public
//
//  Synopsis:	Returns the next element in the enumeration
//
//  Arguments:	[ppv] - Pointer return
//
//  Returns:	TRUE/FALSE
//
//  History:	26-Jul-93	DrewB	Created
//
//----------------------------------------------------------------------------

BOOL CPtrCache::Next(void **ppv)
{
    if (_pbEnum && _iEnum >= _pbEnum->Count())
        _pbEnum = _pbEnum->Next();
    if (_pbEnum == NULL)
        return FALSE;
    *ppv = _pbEnum->Nth(_iEnum++);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\mrshlist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       mrshlist.cxx
//
//  Contents:   CMarshalList implementation
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <mrshlist.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CMarshalList::FindMarshal, public
//
//  Synopsis:   Looks through the list for a matching context
//
//  Arguments:  [ctxid] - Context to look for
//
//  Returns:    Pointer to object or NULL
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

CMarshalList *CMarshalList::FindMarshal (ContextId ctxid) const
{
    CMarshalList *pmlResult = NULL;

    olDebugOut((DEB_ITRACE, "In  CMarshalList::Find:%p(%lu)Marshal\n", this, 
                                                                (ULONG)ctxid));
    olAssert (ctxid != INVALID_CONTEXT_ID);
    if (GetContextId() == ctxid)
        pmlResult = (CMarshalList *) this;  // cast away const
    else
    {
        CMarshalList *pml;
        for (pml = GetNextMarshal(); pml != this; pml = pml->GetNextMarshal())
        {
            olAssert (pml != NULL);
            if (pml->GetContextId() != INVALID_CONTEXT_ID &&
                pml->GetContextId() == ctxid)
            {
                pmlResult = pml;
                break;
            }
        }
    }

    olDebugOut((DEB_ITRACE, "Out CMarshalList::FindMarshal %p\n", pmlResult));
    return pmlResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarshalList::AddMarshal, public
//
//  Synopsis:   Adds a context to the list
//
//  Arguments:  [pml] - another marshaling of the same storage/stream
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

void CMarshalList::AddMarshal (CMarshalList *pml)
{
    olDebugOut((DEB_ITRACE, "In  CMarshalList::AddMarshal:%p(%p)\n",this,pml));
    olAssert (pml != NULL);
    olAssert (GetNextMarshal() != NULL);
    pml->SetNextMarshal(GetNextMarshal());
    SetNextMarshal(pml);
    olDebugOut((DEB_ITRACE, "Out CMarshalList::AddMarshal\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarshalList::RemoveMarshal, public
//
//  Synopsis:   Removes a context from the list
//
//  Arguments:  [pctx] - Context
//
//  History:    16-Mar-96       HenryLee   Created
//
//----------------------------------------------------------------------------

void CMarshalList::RemoveMarshal(CMarshalList *pml)
{
    olDebugOut((DEB_ITRACE, "In  CMarshalList::RemoveMarshal:%p(%p)\n",
                            this,pml));
    if (GetNextMarshal() != NULL && GetNextMarshal() != this)
    {
        CMarshalList *pmlNext;
#if DBG == 1
        BOOL fFound = FALSE;
#endif
        for (pmlNext = GetNextMarshal(); pmlNext != this; 
             pmlNext = pmlNext->GetNextMarshal())
            if (pmlNext->GetNextMarshal() == pml)
            {
#if DBG == 1
                fFound = TRUE;
#endif
                pmlNext->SetNextMarshal(pml->GetNextMarshal());
                pml->SetNextMarshal(NULL);
                break;
            }
        olAssert(fFound == TRUE);
    }
    olDebugOut((DEB_ITRACE, "Out CMarshalList::RemoveMarshal\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\h\dfver.h ===
#define rmj		3
#define rmm		62
#define rup		0
#define rmjlarge 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\time32.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Time32.CXX, 32-bit only
//
//  Contents:   time routine
//
//  Functions:  DfGetTOD
//
//  History:    13-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------
#include <exphead.cxx>
#pragma hdrstop

SCODE DfGetTOD(TIME_T *pft)
{
    SCODE sc;

    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    olAssert(sizeof(TIME_T) == sizeof(FILETIME));
    BOOL b = SystemTimeToFileTime(&SystemTime, pft);

    if (b)
    {
        sc = S_OK;
    }
    else
    {
        olAssert(!aMsg("Unable to convert time"));
        sc = E_FAIL;
    }

    return(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\h\storagep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       storagep.h
//
//  Contents:   Internal storage information
//
//  History:    09-Oct-92	DrewB	Created
//
//--------------------------------------------------------------------------

#ifndef __STORAGEP_H__
#define __STORAGEP_H__

STDAPI StgIsStorageFileHandle( HANDLE hFile, LPOVERLAPPED povlp );

// The byte combination that identifies that a file is a storage of
// some kind

const BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
const BYTE CBSIGSTG = sizeof(SIGSTG);

// The first portion of a storage file
struct SStorageFile
{
    BYTE	abSig[CBSIGSTG];		//  Signature
    CLSID	_clid;				//  Class Id
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME= exp
TARGETPATH= obj
TARGETTYPE= LIBRARY

INCLUDES    =..\..\..\ih;..\..\..\common\$(DEST_TREE);..\..\h
INCLUDES    = $(INCLUDES);..;..\..\props;..\..\..\com\inc
INCLUDES    = $(INCLUDES);..\..\async\docfile
INCLUDES    = $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES    = $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES    = $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES    = $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES= \
                $(C_DEFINES)            \

SOURCES= \
        ..\dfguid.cxx           \
        ..\docfile.cxx          \
        ..\filest.cxx           \
        ..\filest32.cxx         \
        ..\time32.cxx           \
        ..\context.cxx          \
        ..\cntxlist.cxx         \
        ..\lock.cxx             \
        ..\marshl.cxx           \
        ..\dfunmfct.cxx         \
        ..\seekptr.cxx          \
        ..\expst.cxx            \
        ..\peiter.cxx           \
        ..\expiter.cxx          \
        ..\expdf.cxx            \
        ..\ptrcache.cxx         \
        ..\storage.cxx          \
        ..\mrshlist.cxx         \
        ..\astgconn.cxx

PRECOMPILED_INCLUDE= ..\exphead.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\cache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cache.cxx
//
//  Contents:	Stream cache code
//
//  Classes:	
//
//  Functions:	
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <sstream.hxx>
#include <cache.hxx>
#include <mread.hxx>

#if DBG == 1
static ULONG csTotalWalked = 0;
static ULONG csSeqWalked = 0;
static ULONG csRealWalked = 0;
static ULONG cTotalCalls = 0;
#endif


inline SECT CacheStart(SCacheEntry cache)
{
    return cache.sect;
}

inline SECT CacheEnd(SCacheEntry cache)
{
    return cache.sect + cache.ulRunLength - 1;
}

inline ULONG CacheLength(SCacheEntry cache)
{
    return cache.ulRunLength;
}

inline ULONG CacheStartOffset(SCacheEntry cache)
{
    return cache.ulOffset;
}

inline ULONG CacheEndOffset(SCacheEntry cache)
{
    return cache.ulOffset + cache.ulRunLength - 1;
}


        
//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::CheckSegment, private
//
//  Synopsis:	Given a bunch of information, determine if there is
//              a cache hit on a given segment and set return variables
//              to represent best hit.
//
//  Arguments:	[ulOffset] -- Offset being sought.
//              [sce] -- Stream cache entry being checked
//              [pulCount] -- Pointer to count of best hit so far
//              [psectCache] -- Pointer to sect of best hit so far
//              [pulCacheOffset] -- Pointer to offset of best hit so far
//
//  Returns:	TRUE if this is the best hit, FALSE otherwise.
//
//  History:	11-Jul-94	PhilipLa	Created
//
//  Notes:	This function has mega side effects.  Think of it as
//              a typesafe #define.
//
//----------------------------------------------------------------------------

inline BOOL CStreamCache::CheckSegment(ULONG ulOffset,
                         SCacheEntry sce,
                         ULONG *pulCount,
                         SECT *psectCache,
                         ULONG *pulCacheOffset)
{
    if (CacheStartOffset(sce) <= ulOffset)
    {
        //We have a potential cache hit.  Check the runlength to
        //  get the best fit.
        if (ulOffset <= CacheEndOffset(sce))
        {
            //Direct hit.
            *pulCount = 0;
            *pulCacheOffset = ulOffset;
            *psectCache = CacheStart(sce) + (ulOffset - CacheStartOffset(sce));
        }
        else
        {
            if (*pulCount > ulOffset - CacheEndOffset(sce))
            {
                //The requested sector is past the end of the cached
                //  segment.  Use the endpoint as the closest hit.
                *pulCount = ulOffset - CacheEndOffset(sce);
                *psectCache = CacheEnd(sce);
                *pulCacheOffset = CacheEndOffset(sce);
            }
            else
            {
                return FALSE;
            }
        }
        msfAssert(*pulCacheOffset <= ulOffset);
        return TRUE;
    }
    return FALSE;
}


inline CDirectory * CStreamCache::GetDir(void)
{
    return _pmsParent->GetDir();
}

inline CFat * CStreamCache::GetFat(void)
{
    return _pmsParent->GetFat();
}

inline CFat * CStreamCache::GetMiniFat(void)
{
    return _pmsParent->GetMiniFat();
}

#ifdef LARGE_STREAMS
inline ULONGLONG CStreamCache::GetSize(void)
#else
inline ULONG CStreamCache::GetSize(void)
#endif
{
#ifdef LARGE_STREAMS
    ULONGLONG ulSize = 0;
#else
    ULONG ulSize = 0;
#endif
    if (_pds != NULL)
    {
        _pds->CDirectStream::GetSize(&ulSize);
    }
    else
    {
        _pmsParent->GetSize(_sid, &ulSize);
    }
    
    return ulSize;
}

inline SID CStreamCache::GetSid(void)
{
    return _sid;
}



//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::SelectFat, private
//
//  Synopsis:	Returns the appropriate CFat object for the cache.
//              If we are a control structure, then the real fat is
//              always the right one.  Otherwise (we are a real stream)
//              key off of size to determine whether the minifat or
//              the real fat is appropriate.
//
//  Arguments:	None.
//
//  Returns:	Appropriate CFat pointer
//
//  History:	16-Jun-94	PhilipLa	Created
//----------------------------------------------------------------------------

inline CFat * CStreamCache::SelectFat(void)
{
    return ((_pds == NULL) || (GetSize() >= MINISTREAMSIZE) ||
            (GetSid() == SIDMINISTREAM)) ? GetFat() : GetMiniFat();
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::CacheSegment, private
//
//  Synopsis:	Store a segment in the cache.
//
//  Arguments:	[pseg] -- Pointer to segment to store
//
//  Returns:	void
//
//  History:	19-Oct-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CStreamCache::CacheSegment(SSegment *pseg)
{
    USHORT iCache;
    
    if (_uNextCacheIndex >= CACHESIZE)
    {
        _uNextCacheIndex = 0;
    }

    iCache = _uNextCacheIndex;
    _ase[iCache].ulOffset = SegStartOffset(*pseg);
    _ase[iCache].ulRunLength = SegLength(*pseg);
    _ase[iCache].sect = SegStart(*pseg);
    
    _uNextCacheIndex++;
    
    _uHighCacheIndex = max(_uHighCacheIndex, iCache + 1);

    //_uCacheState can be used to determine if the cache has changed.
    _uCacheState++;
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::GetStart, private
//
//  Synopsis:	Get start sector for this chain
//
//  Arguments:	[psectStart] -- Return location
//
//  Returns:	Appropriate status code
//
//  History:	01-Jun-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::GetStart(SECT *psectStart)
{
    SCODE sc = S_OK;

    if (_pds != NULL)
    {
        //We're a normal stream, so get the start sect from the
        //   directory.
        sc = GetDir()->GetStart(_sid, psectStart);
    }
    else
    {
        //We're a control stream, so get the start sect from the
        //   multistream.
        *psectStart = _pmsParent->GetStart(_sid);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::CStreamCache, public
//
//  Synopsis:	CStreamCache constructor
//
//  History:	14-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

CStreamCache::CStreamCache()
{
    _sid = NOSTREAM;
    _pmsParent = NULL;
    _pds = NULL;
    _uHighCacheIndex = 0;
    _uNextCacheIndex = 0;
    _uCacheState = 0;
}

CStreamCache::~CStreamCache()
{
#if DBG == 1
    msfDebugOut((DEB_ITRACE,
    "Cache stats: Total = %lu     Seq = %lu     Real = %lu    Calls = %lu\n",
            csTotalWalked, csSeqWalked, csRealWalked, cTotalCalls));
#endif
}

void CStreamCache::Init(CMStream *pmsParent, SID sid, CDirectStream *pds)
{
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    _sid = sid;
    _pds = P_TO_BP(CBasedDirectStreamPtr, pds);
    Empty();
}

void CStreamCache::Empty(void)
{
    for (USHORT uIndex = 0; uIndex < CACHESIZE; uIndex++)
    {
        _ase[uIndex].ulOffset = MAX_ULONG;
        _ase[uIndex].sect = ENDOFCHAIN;
        _ase[uIndex].ulRunLength = 0;
    }

    _uHighCacheIndex = 0;
    _uNextCacheIndex = 0;
    _uCacheState++;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::GetSect, public
//
//  Synopsis:	Retrieve a SECT from the cache given an offset
//
//  Arguments:	[ulOffset] -- Offset to look up.
//              [psect] -- Location for return value
//
//  Returns:	Appropriate status code
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::GetSect(ULONG ulOffset, SECT *psect)
{
    SCODE sc = S_OK;
    CFat *pfat;
    USHORT iCache = 0;
    ULONG ulCount = MAX_ULONG;
    SECT sectCache = ENDOFCHAIN;
    ULONG ulCacheOffset = MAX_ULONG;

    *psect = ENDOFCHAIN;

    pfat = SelectFat();

    for (USHORT iCacheLoop = 0; iCacheLoop < _uHighCacheIndex; iCacheLoop++)
    {
        if (CheckSegment(ulOffset,
                         _ase[iCacheLoop],
                         &ulCount,
                         &sectCache,
                         &ulCacheOffset))
        {
            //Cache hit.
        }
    }

    //We now have the best hit from the cache.  If it is exact, return
    //   now.
    if (ulCount == 0)
    {
        *psect = sectCache;
        return S_OK;
    }

    if (ulCacheOffset == MAX_ULONG)
    {
        //No cache hit.
        msfChk(GetStart(&sectCache));
        ulCacheOffset = 0;
    }

    //Otherwise, go to the fat and get the real thing.
#if DBG == 1 && defined(CHECKLENGTH)
    SECT sectStart;
    ULONG ulLengthOld, ulLengthNew;
    GetStart(&sectStart);
    pfat->GetLength(sectStart, &ulLengthOld);
#endif
    
    SSegment segtab[CSEG + 1];
    ULONG ulSegCount;
    
    while (TRUE)
    {
        msfChk(pfat->Contig(
                segtab,
                FALSE,
                sectCache,
                ulOffset - ulCacheOffset + 1,
                &ulSegCount));

        if (ulSegCount <= CSEG)
        {
            //We're done.
            break;
        }

        //We need to call Contig again.  Update ulCacheOffset and
        //sectCache to be the last sector in the current table.

        ulCacheOffset = ulCacheOffset + SegEndOffset(segtab[CSEG - 1]);
        sectCache = SegEnd(segtab[CSEG - 1]);
    }

    //Last segment is in segtab[ulSegCount - 1].

    //ulSegOffset is the absolute offset within the stream of the first
    //sector in the last segment.
    ULONG ulSegOffset;
    ulSegOffset = ulCacheOffset + SegStartOffset(segtab[ulSegCount - 1]);

    msfAssert(ulSegOffset <= ulOffset);

    msfAssert(ulOffset < ulSegOffset + SegLength(segtab[ulSegCount - 1]));
    
    *psect = SegStart(segtab[ulSegCount - 1]) + (ulOffset - ulSegOffset);

    //Now, stick the last segment into our cache.  We need to update
    //  the ulOffset field to be the absolute offset (i.e. ulSegOffset)
    //  before calling CacheSegment().

    segtab[ulSegCount - 1].ulOffset = ulSegOffset;
    CacheSegment(&(segtab[ulSegCount - 1]));
    
#if DBG == 1 && defined(CHECKLENGTH)
    //Confirm that the chain hasn't grown.
    pfat->GetLength(sectStart, &ulLengthNew);
    msfAssert(ulLengthOld == ulLengthNew);
    
    //Confirm that we're getting the right sector.
    SECT sectCheck;
        
    pfat->GetSect(sectStart, ulOffset, &sectCheck);

    msfAssert(*psect == sectCheck);
#endif
    
 Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::GetESect, public
//
//  Synopsis:	Retrieve a SECT from the cache given an offset, extending
//              the stream if necessary.
//
//  Arguments:	[ulOffset] -- Offset to look up.
//              [psect] -- Location for return value
//
//  Returns:	Appropriate status code
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::GetESect(ULONG ulOffset, SECT *psect)
{
    SCODE sc = S_OK;
    CFat *pfat;
    USHORT iCache = 0;
    ULONG ulCount = MAX_ULONG;
    SECT sectCache = ENDOFCHAIN;
    ULONG ulCacheOffset = MAX_ULONG;
    USHORT uCacheHit = CACHESIZE + 1;
    
    *psect = ENDOFCHAIN;

    pfat = SelectFat();

    for (USHORT iCacheLoop = 0; iCacheLoop < _uHighCacheIndex; iCacheLoop++)
    {
        if (CheckSegment(ulOffset,
                         _ase[iCacheLoop],
                         &ulCount,
                         &sectCache,
                         &ulCacheOffset))
        {
            uCacheHit = iCacheLoop;
            //Cache hit.
        }
    }

    //We now have the best hit from the cache.  If it is exact, return
    //   now.
    if (ulCount == 0)
    {
        *psect = sectCache;
        return S_OK;
    }

    if (ulCacheOffset == MAX_ULONG)
    {
        //No cache hit.
        msfChk(GetStart(&sectCache));
        ulCacheOffset = 0;
    }
    
    //Otherwise, go to the fat and get the real thing.

    SSegment segtab[CSEG + 1];
    ULONG ulSegCount;
    
    while (TRUE)
    {
        msfChk(pfat->Contig(
                segtab,
                TRUE,
                sectCache,
                ulOffset - ulCacheOffset + 1,
                &ulSegCount));

        if (ulSegCount <= CSEG)
        {
            //We're done.
            break;
        }

        //We need to call Contig again.  Update ulCacheOffset and
        //sectCache to be the last sector in the current table.

        ulCacheOffset = ulCacheOffset + SegEndOffset(segtab[CSEG - 1]);
        sectCache = SegEnd(segtab[CSEG - 1]);
    }

    //Last segment is in segtab[ulSegCount - 1].

    //ulSegOffset is the absolute offset within the stream of the first
    //sector in the last segment.
    ULONG ulSegOffset;
    ulSegOffset = ulCacheOffset + SegStartOffset(segtab[ulSegCount - 1]);

    msfAssert(ulSegOffset <= ulOffset);

    msfAssert(ulOffset < ulSegOffset + SegLength(segtab[ulSegCount - 1]));
    
    *psect = SegStart(segtab[ulSegCount - 1]) + (ulOffset - ulSegOffset);
    segtab[ulSegCount - 1].ulOffset = ulSegOffset;
    
    //If we grew the chain with this call, we may need to merge the
    //   new segment with the previous best-hit in our cache.
    //   Otherwise, we end up with excessive fragmentation.

    if ((uCacheHit != CACHESIZE + 1) &&
        (SegStart(segtab[ulSegCount - 1]) <= CacheEnd(_ase[uCacheHit]) + 1) &&
        (SegStart(segtab[ulSegCount - 1]) > CacheStart(_ase[uCacheHit])) &&
        (SegStartOffset(segtab[ulSegCount - 1]) <=
         CacheEndOffset(_ase[uCacheHit]) + 1))
    {
        //We can merge the two.
        _ase[uCacheHit].ulRunLength += (SegLength(segtab[ulSegCount - 1]) -
            (CacheEnd(_ase[uCacheHit]) + 1 -
             SegStart(segtab[ulSegCount - 1])));

        _uCacheState++;
    }
    else
    {        
        //Now, stick the last segment into our cache.  We need to update
        //  the ulOffset field to be the absolute offset (i.e. ulSegOffset)
        //  before calling CacheSegment().
        CacheSegment(&(segtab[ulSegCount - 1]));
    }
    
#if DBG == 1
    //Confirm that we're getting the right sector.
    SECT sectCheck;
    SECT sectStart;
        
    msfChk(GetStart(&sectStart));

    pfat->GetESect(sectStart, ulOffset, &sectCheck);

    msfAssert(*psect == sectCheck);
#endif

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::EmptyRegion, public
//
//  Synopsis:	Invalidate cached values for a segment that has been
//              remapped
//
//  Arguments:	[oStart] -- Offset marking first remapped sector
//              [oEnd] -- Offset marking last remapped sector
//
//  Returns:	Appropriate status code
//
//  History:	26-May-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::EmptyRegion(ULONG oStart, ULONG oEnd)
{
    for (USHORT i = 0; i < CACHESIZE; i ++)
    {
        ULONG ulStart = CacheStartOffset(_ase[i]);
        ULONG ulEnd = CacheEndOffset(_ase[i]);
        
        if ((ulStart <= oEnd) && (ulEnd >= oStart))
        {
            //There are 3 possible cases:
            //  1)  The cache entry is completely contained in the
            //        region being invalidated.
            //  2)  The front part of the cache entry is contained in
            //        the region being invalidated.
            //  3)  The tail part of the cache entry is contained in
            //        the region being validated.

            if ((oStart <= ulStart) && (oEnd >= ulEnd))
            {
                //Invalidate the entire thing.
                _ase[i].ulOffset = MAX_ULONG;
                _ase[i].sect = ENDOFCHAIN;
                _ase[i].ulRunLength = 0;
            }
            else if (oStart <= ulStart)
            {
#if DBG == 1
                ULONG ulCacheStart = _ase[i].ulOffset;
                SECT sectCache = _ase[i].sect;
                ULONG ulCacheLength = _ase[i].ulRunLength;
#endif
                //Invalidate the front of the cache entry
                ULONG ulInvalid;
                
                ulInvalid = oEnd - ulStart + 1;

                _ase[i].ulOffset += ulInvalid;
                
                msfAssert(_ase[i].ulRunLength > ulInvalid);
                _ase[i].sect += ulInvalid;
                
                _ase[i].ulRunLength -= ulInvalid;
#if DBG == 1
                //Make sure our cache is still within the old valid range.
                msfAssert((_ase[i].ulOffset >= ulCacheStart) &&
                          (_ase[i].ulOffset <=
                           ulCacheStart + ulCacheLength - 1));
                msfAssert(_ase[i].ulRunLength <= ulCacheLength);
                msfAssert(_ase[i].ulRunLength > 0);
                msfAssert((_ase[i].sect >= sectCache) &&
                          (_ase[i].sect <= sectCache + ulCacheLength - 1));
#endif
            }
            else
            {
#if DBG == 1
                ULONG ulCacheStart = _ase[i].ulOffset;
                SECT sectCache = _ase[i].sect;
                ULONG ulCacheLength = _ase[i].ulRunLength;
#endif
                //Invalidate the tail of the cache entry
                ULONG ulInvalid;
                ulInvalid = ulEnd - oStart + 1;
                msfAssert(_ase[i].ulRunLength > ulInvalid);
                _ase[i].ulRunLength -= ulInvalid;
#if DBG == 1
                //Make sure our cache is still within the old valid range.
                msfAssert((_ase[i].ulOffset >= ulCacheStart) &&
                          (_ase[i].ulOffset <=
                           ulCacheStart + ulCacheLength - 1));
                msfAssert(_ase[i].ulRunLength <= ulCacheLength);
                msfAssert(_ase[i].ulRunLength > 0);
                msfAssert((_ase[i].sect >= sectCache) &&
                          (_ase[i].sect <= sectCache + ulCacheLength - 1));
#endif
            }
            _uCacheState++;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::Contig, public
//
//  Synopsis:	Return a contig table from a given offset and runlength
//
//  Arguments:	[ulOffset] -- Offset to begin contiguity check at
//              [fWrite] -- TRUE if segment is to be written to.
//              [aseg] -- Pointer to SSegment array
//              [ulLength] -- Run length of sectors to return table for
//
//  Returns:	Appropriate status code
//
//  History:	21-Apr-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::Contig(
        ULONG ulOffset,
        BOOL fWrite,
        SSegment STACKBASED *aseg,
        ULONG ulLength,
        ULONG *pcSeg)
{
    SCODE sc;
    msfDebugOut((DEB_ITRACE, "In  CStreamCache::Contig:%p()\n", this));
    SECT sect;
    USHORT uCacheState;
    
    CFat *pfat;

    for (USHORT iCache = 0; iCache < _uHighCacheIndex; iCache++)
    {
        //Look for direct hit.
        if ((ulOffset >= _ase[iCache].ulOffset) &&
            (ulOffset < _ase[iCache].ulOffset + _ase[iCache].ulRunLength))
        {
            //Direct hit.  Return this segment.
            ULONG ulCacheOffset = ulOffset - _ase[iCache].ulOffset;
            
            aseg[0].ulOffset = ulOffset;
            aseg[0].sectStart = _ase[iCache].sect + ulCacheOffset;
            aseg[0].cSect = _ase[iCache].ulRunLength - ulCacheOffset;
            *pcSeg = 1;
            return S_OK;
        }
    }

    uCacheState = _uCacheState;
    if (fWrite)
    {
        //This can grow the chain, so get the whole thing at once
        //  instead of one sector at a time.  Chances are good that
        //  the second GetESect call will be fed from the cache, so
        //  this won't be too expensive in the common case.
        //Ideally, we'd like to make this first call only when we
        //  know the stream is growing.  There isn't a convenient
        //  way to detect that here, though.
        msfChk(GetESect(ulOffset + ulLength - 1, &sect));
        msfChk(GetESect(ulOffset, &sect));
    }
    else
    {
        msfChk(GetSect(ulOffset, &sect));
    }

    //The GetSect() or GetESect() call may have actually snagged the
    //  segment we need, so check the cache again.  If _uCacheState
    //  changed in the duration of the call, we know that something
    //  new is in the cache, so we go look again.
    if (uCacheState != _uCacheState)
    {
        for (USHORT iCache = 0; iCache < _uHighCacheIndex; iCache++)
        {
            //Look for direct hit.
            if ((ulOffset >= _ase[iCache].ulOffset) &&
                (ulOffset < _ase[iCache].ulOffset + _ase[iCache].ulRunLength))
            {
                //Direct hit.  Return this segment.
                ULONG ulCacheOffset = ulOffset - _ase[iCache].ulOffset;
            
                aseg[0].ulOffset = ulOffset;
                aseg[0].sectStart = _ase[iCache].sect + ulCacheOffset;
                aseg[0].cSect = _ase[iCache].ulRunLength - ulCacheOffset;
                *pcSeg = 1;
                return S_OK;
            }
        }
    }

    pfat = SelectFat();
    msfChk(pfat->Contig(aseg, fWrite, sect, ulLength, pcSeg));

    //At this point, we can peek at the contig table and pick out
    //  the choice entries to put in the cache.
    
    //For the first pass, we just grab the last thing in the Contig
    //table and cache it.
    aseg[*pcSeg - 1].ulOffset += ulOffset;
    CacheSegment(&(aseg[*pcSeg - 1]));
    
 Err:    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CStreamCache::Allocate, public
//
//  Synopsis:	Allocate a new chain for a stream, returning the start
//              sector and caching the appropriate amount of contig
//              information.
//
//  Arguments:	[pfat] -- Pointer to fat to allocate in
//              [cSect] -- Number of sectors to allocate
//              [psectStart] -- Returns starts sector for chain
//
//  Returns:	Appropriate status code
//
//  History:	19-Oct-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CStreamCache::Allocate(CFat *pfat, ULONG cSect, SECT *psectStart)
{
    SCODE sc;

    msfAssert((_uHighCacheIndex == 0) &&
              aMsg("Called Allocate with non-empty buffer"));

#ifndef CACHE_ALLOCATE_OPTIMIZATION
    //This will allocate the complete requested chain.  We'll then
    //  walk over that chain again in the Contig() call, which isn't
    //  optimal.  Ideally, we'd like GetFree() to return us the
    //  contiguity information, but that's a fairly major change.
    //  Consider it for future optimization work.
    msfChk(pfat->GetFree(cSect, psectStart, GF_WRITE));
#else
    //Get the first sector (to simplify Contig code)

    //First reserve enough free sectors for the whole thing.
    msfChk(pfat->ReserveSects(cSect));
    msfChk(pfat->GetFree(1, psectStart, GF_WRITE));
#endif    

    SSegment segtab[CSEG + 1];
    ULONG ulSegCount;
    ULONG ulSegStart;
    SECT sectSegStart;

    sectSegStart = *psectStart;
    ulSegStart = 0;
    
    while (TRUE)
    {
        msfChk(pfat->Contig(
                segtab,
                TRUE,
                sectSegStart,
                cSect - ulSegStart,
                &ulSegCount));

        if (ulSegCount <= CSEG)
        {
            //We're done.
            break;
        }

        //We need to call Contig again.  Update ulSegStart and
        //sectSegStart to be the last sector in the current table.

        ulSegStart = ulSegStart + SegEndOffset(segtab[CSEG - 1]);
        sectSegStart = SegEnd(segtab[CSEG - 1]);
    }

    //Last segment is in segtab[ulSegCount - 1].

    //ulSegOffset is the absolute offset within the stream of the first
    //sector in the last segment.
    ULONG ulSegOffset;
    ulSegOffset = ulSegStart + SegStartOffset(segtab[ulSegCount - 1]);

    //Now, stick the last segment into our cache.  We need to update
    //  the ulOffset field to be the absolute offset (i.e. ulSegOffset)
    //  before calling CacheSegment().

    segtab[ulSegCount - 1].ulOffset = ulSegOffset;
    CacheSegment(&(segtab[ulSegCount - 1]));

#if DBG == 1 && defined(CHECKLENGTH)
    ULONG ulLength;

    pfat->GetLength(*psectStart, &ulLength);
    msfAssert(ulLength == cSect);
#endif
 Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\h\w4wchar.h ===
//+---------------------------------------------------------------------------
//
// File:        WChar.h
//
// Contents:    Defines wide character equivalents for standard functions
//              usually in strings.h and ctypes.h
//
// History:     11-Sep-91       KyleP    Created
//              20-Sep-91       ChrisMay Added several functions
//              25-Sep-91       ChrisMay Added wcsncmp and wcsncpy
//              04-Oct-91       ChrisMay Added wcslwr, wcsupr, wcscoll
//              07-Oct-91       ChrisMay Added BOM and padding macro
//              18-Oct-91       vich	 added w4*sprintf routines
//		04-Mar-92	ChrisMay added wscatoi, wcsitoa, wcsatol, etc.
//----------------------------------------------------------------------------

#ifndef __WCHAR_H__
#define __WCHAR_H__

#include <stdlib.h>

#if WIN32 != 300
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

// Unicode Byte Order Mark (BOM) for Unicode text files
#define BOM 0xFEFF

// Padding constant and macro for localized buffer allocation
#define INTL_PADDING_VALUE 3
#define INTL_PADDING(cb) (INTL_PADDING_VALUE * (cb))


#if 0
long      __cdecl wcsatol(const wchar_t *wsz);
int	      __cdecl wcsatoi(const wchar_t *wsz);
wchar_t * __cdecl wcscat(wchar_t *wsz1, const wchar_t *wsz2);
wchar_t * __cdecl wcschr(const wchar_t *wsz1, wchar_t character);
int       __cdecl wcscmp(const wchar_t *wsz1, const wchar_t *wsz2);
int       __cdecl wcsicmp(const wchar_t *wsz1, const wchar_t *wsz2);
int       __cdecl wcscoll(const wchar_t * wsz1, const wchar_t * wsz2);
wchar_t * __cdecl wcscpy(wchar_t *wsz1, wchar_t const *wsz2);
wchar_t * __cdecl wcsitoa(int ival, wchar_t *wsz, int radix);
size_t    __cdecl wcslen(wchar_t const *wsz);
wchar_t * __cdecl wcsltoa(long lval, wchar_t *wsz, int radix);
wchar_t * __cdecl wcslwr(wchar_t *wsz);
int       __cdecl wcsncmp(const wchar_t *wsz1, const wchar_t *wsz2, size_t count);
int       __cdecl wcsnicmp(const wchar_t *wsz1, const wchar_t *wsz2, size_t count);
wchar_t * __cdecl wcsncpy(wchar_t *wsz1, const wchar_t *wsz2, size_t count);
wchar_t * __cdecl wcsrchr(const wchar_t * wcs, wchar_t wc);
wchar_t * __cdecl wcsupr(wchar_t *wsz);
wchar_t * __cdecl wcswcs(const wchar_t *wsz1, const wchar_t *wsz2);
#endif

//  sprintf support now included in misc.lib

extern int __cdecl w4sprintf(char *pszout, const char *pszfmt, ...);
extern int __cdecl w4vsprintf(char *pszout, const char *pszfmt, va_list arglist);
extern int __cdecl w4wcsprintf(wchar_t *pwzout, const char *pszfmt, ...);
extern int __cdecl w4vwcsprintf(wchar_t *pwzout, const char *pszfmt, va_list arglist);

#ifdef __cplusplus
}
#endif

#endif // !Cairo

#endif  /* __WCHAR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\exp\storage.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       storage.cxx
//
//  Contents:   Contains generic storage APIs
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------

#include <exphead.cxx>
#pragma hdrstop

#include <dfentry.hxx>
#include <storagep.h>
#include <logfile.hxx>
#include <df32.hxx>
#ifdef COORD
#include <oledb.h>
#endif //COORD

#include <trace.hxx>

#include <ole2sp.h>
#include <ole2com.h>


//+--------------------------------------------------------------
//
//  Function:   StgOpenStorage, public
//
//  Synopsis:   Instantiates a root storage from a file
//              by binding to the appropriate implementation
//              and starting things up
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority mode reopen IStorage
//              [grfMode] - Permissions
//              [snbExclude] - Exclusions for priority reopen
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgOpenStorage(OLECHAR const *pwcsName,
                      IStorage *pstgPriority,
                      DWORD grfMode,
                      SNB snbExclude,
                      LPSTGSECURITY reserved,
                      IStorage **ppstgOpen)
{
    return DfOpenDocfile(pwcsName, NULL, pstgPriority, grfMode,
                         snbExclude, reserved, NULL, 0, ppstgOpen);
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckSignature, private
//
//  Synopsis:   Checks the given memory against known signatures
//
//  Arguments:  [pb] - Pointer to memory to check
//
//  Returns:    S_OK - Current signature
//              S_FALSE - Beta 2 signature, but still successful
//              Appropriate status code
//
//  History:    23-Jul-93       DrewB   Created from header.cxx code
//
//----------------------------------------------------------------------------

//Identifier for first bytes of Beta 1 Docfiles
const BYTE SIGSTG_B1[] = {0xd0, 0xcf, 0x11, 0xe0, 0x0e, 0x11, 0xfc, 0x0d};
const USHORT CBSIGSTG_B1 = sizeof(SIGSTG_B1);

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

SCODE CheckSignature(BYTE *pb)
{
    SCODE sc;

    olDebugOut((DEB_ITRACE, "In  CheckSignature(%p)\n", pb));

    // Check for ship Docfile signature first
    if (memcmp(pb, SIGSTG, CBSIGSTG) == 0)
        sc = S_OK;

    // Check for Beta 2 Docfile signature
    else if (memcmp(pb, SIGSTG_B2, CBSIGSTG_B2) == 0)
        sc = S_FALSE;

    // Check for Beta 1 Docfile signature
    else if (memcmp(pb, SIGSTG_B1, CBSIGSTG_B1) == 0)
        sc = STG_E_OLDFORMAT;
    else
        sc = STG_E_INVALIDHEADER;

    olDebugOut((DEB_ITRACE, "Out CheckSignature => %lX\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFileHandle, private
//
//  Synopsis:   Determines whether a handle is open on a storage file.
//              Spun off from StgIsStorageFile.  Internaly we use this
//
//  Arguments:  [hf] - Open File Handle (caller must seek it to 0)
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    07-May-98   MikeHill   Created
//              05-June-98  BChapman   Return Errors not just S_FALSE.
//                                     Add optional Overlapped pointer.
//
//---------------------------------------------------------------


STDAPI StgIsStorageFileHandle( HANDLE hf, LPOVERLAPPED povlp )
{
    DWORD cbRead;
    BYTE stgHeader[sizeof(SStorageFile)];
    SCODE sc;
    LONG status;
    OVERLAPPED ovlp;

    FillMemory( stgHeader, sizeof(SStorageFile), 0xDE );

    if (povlp == NULL)
    {
    ovlp.Offset = 0;
    ovlp.OffsetHigh = 0;
    ovlp.hEvent = NULL;
    }

    if( !ReadFile( hf,
           &stgHeader,
           sizeof( stgHeader ),
           &cbRead,
           (povlp == NULL) ? &ovlp : povlp ) )
    {
        if( NULL != povlp )
        {
            status = GetLastError();
            if( ERROR_IO_PENDING == status)
            {
                status = ERROR_SUCCESS;
                if( !GetOverlappedResult( hf, povlp, &cbRead, TRUE ) )
                    status = GetLastError();
            }
            if(ERROR_SUCCESS != status && ERROR_HANDLE_EOF != status)
                olChk( HRESULT_FROM_WIN32( status ) );
        }
        else
            olErr( EH_Err, S_FALSE );
    }

    // Don't worry about short reads.  If the read is short then
    // the signature checks will fail.

    sc = CheckSignature( ((SStorageFile*)stgHeader)->abSig );
    if(S_OK == sc)
        goto EH_Err;    // Done, return "Yes"

    olChk(sc);

    // It didn't error.  sc != S_OK then it
    // Must be S_FALSE.
    olAssert(S_FALSE == sc);

EH_Err:
    if( (STG_E_OLDFORMAT == sc) || (STG_E_INVALIDHEADER == sc) )
        sc = S_FALSE;

    return sc;
}


//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFile, public
//
//  Synopsis:   Determines whether the named file is a storage or not
//
//  Arguments:  [pwcsName] - Filename
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------


STDAPI StgIsStorageFile(OLECHAR const *pwcsName)
{
    HANDLE hf;
    SCODE sc;

    olLog(("--------::In  StgIsStorageFile(" OLEFMT ")\n", pwcsName));

    TRY
    {
#ifndef OLEWIDECHAR
        if (FAILED(sc = ValidateNameA(pwcsName, _MAX_PATH)))
#else
        if (FAILED(sc = ValidateNameW(pwcsName, _MAX_PATH)))
#endif
            return ResultFromScode(sc);

#if !defined(UNICODE)

    // Chicago - call ANSI CreateFile

    char szName[_MAX_PATH + 1];

    if (!WideCharToMultiByte(
            AreFileApisANSI() ? CP_ACP : CP_OEMCP,
            0,
            pwcsName,
            -1,
            szName,
            _MAX_PATH + 1,
            NULL,
            NULL))
        return ResultFromScode(STG_E_INVALIDNAME);

    hf = CreateFileA (
            szName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

#else

        hf = CreateFile (
            pwcsName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
#endif // !defined(UNICODE)

        if (hf == INVALID_HANDLE_VALUE)
            return ResultFromScode(STG_SCODE(GetLastError()));

        sc = StgIsStorageFileHandle( hf, NULL );
        CloseHandle (hf);

    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    olLog(("--------::Out StgIsStorageFile().  ret == %lx\n", sc));

    return(ResultFromScode(sc));
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageILockBytes, public
//
//  Synopsis:   Determines whether the ILockBytes is a storage or not
//
//  Arguments:  [plkbyt] - The ILockBytes
//
//  Returns:    S_OK, S_FALSE or error codes
//
//  History:    05-Oct-92       DrewB   Created
//
//---------------------------------------------------------------

STDAPI StgIsStorageILockBytes(ILockBytes *plkbyt)
{
    OLETRACEIN((API_StgIsStorageILockBytes, PARAMFMT("plkbyt= %p"), plkbyt));

    HRESULT hr;
    SCODE sc;
    SStorageFile stgfile;
    ULONG cbRead;
    ULARGE_INTEGER ulOffset;

    TRY
    {
        if (FAILED(sc = ValidateInterface(plkbyt, IID_ILockBytes)))
        {
            hr = ResultFromScode(sc);
            goto errRtn;
        }
        ULISet32(ulOffset, 0);
        hr = plkbyt->ReadAt(ulOffset, &stgfile, sizeof(stgfile), &cbRead);
        if (FAILED(GetScode(hr)))
        {
            goto errRtn;
        }
    }
    CATCH(CException, e)
    {
        hr = ResultFromScode(e.GetErrorCode());
        goto errRtn;
    }
    END_CATCH

    if (cbRead == sizeof(stgfile))
    {
        if ((memcmp((void *)stgfile.abSig, SIGSTG, CBSIGSTG) == 0) ||
            (memcmp((void *)stgfile.abSig, SIGSTG_B2, CBSIGSTG_B2) == 0))
        {
            hr = ResultFromScode(S_OK);
            goto errRtn;
        }
    }

    hr = ResultFromScode(S_FALSE);

errRtn:
    OLETRACEOUT((API_StgIsStorageILockBytes, hr));

    return hr;
}

//+--------------------------------------------------------------
//
//  Function:   StgSetTimes
//
//  Synopsis:   Sets file time stamps
//
//  Arguments:  [lpszName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//  History:    05-Oct-92       AlexT   Created
//
//---------------------------------------------------------------

STDAPI StgSetTimes(OLECHAR const *lpszName,
                   FILETIME const *pctime,
                   FILETIME const *patime,
                   FILETIME const *pmtime)
{
    SCODE sc;
    HANDLE hFile;

    TRY
    {
#ifndef OLEWIDECHAR
        sc = ValidateNameA(lpszName, _MAX_PATH);
#else
        sc = ValidateNameW(lpszName, _MAX_PATH);
#endif
        if (SUCCEEDED(sc))
        {
#if !defined(UNICODE) && defined(OLEWIDECHAR)
            //Chicago - call ANSI CreateFile
            char szName[_MAX_PATH];

            if (!WideCharToMultiByte(
                    AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                    0,
                    lpszName,
                    -1,
                    szName,
                    _MAX_PATH,
                    NULL,
                    NULL))
                return ResultFromScode(STG_E_INVALIDNAME);
            hFile = CreateFileA(szName, GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               NULL);
#else
            hFile = CreateFile(lpszName, GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
#endif
            if (hFile == INVALID_HANDLE_VALUE)
                sc = LAST_STG_SCODE;
            else
            {
                if (!SetFileTime(hFile, (FILETIME *)pctime, (FILETIME *)patime,
                                 (FILETIME *)pmtime))
                    sc = LAST_STG_SCODE;
                CloseHandle(hFile);
            }
        }
    }
    CATCH(CException, e)
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    return ResultFromScode(sc);
}


#if DBG==1
extern "C" unsigned long filestInfoLevel; //  File I/O layer of Docfile
extern "C" unsigned long nffInfoLevel;    //  NTFS Flat File

void
StgDebugInit()
{
    GetInfoLevel("filest", &filestInfoLevel, "0x0003");
    GetInfoLevel(   "nff", &nffInfoLevel,    "0x0003");
}

#endif // DBG==1


//+---------------------------------------------------------------------------
//
//  Function:   NormalDllGetClassObject, public
//
//  Synopsis:   Registers any normal Inproc Dll server.
//
//  Arguments:  [refCLSID]           Class ID of object to register
//              [pwszDescription]    Description to put in the CLSID Key
//              [pwszDllName]        Dll where the object's code lives
//              [pwszThreadingModel] Threading Model (i.e. L"both")
//
//  Returns:    Appropriate status code
//
//  History:    15-jan-98       BChapman   Created
//
//----------------------------------------------------------------------------

#define STRBUFSZ    64

STDAPI NormalDllRegisterServer(
        REFCLSID    refCLSID,
        WCHAR *     pwszDescription,
        WCHAR *     pwszDllName,
        WCHAR *     pwszThreadingModel)
{

    HKEY hkeyCLSID=NULL;
    HKEY hkeyInproc32=NULL;
    DWORD dwDisp=0;
    LONG rc;
    HRESULT sc=S_OK;

    WCHAR wszCLSID[STRBUFSZ];
    WCHAR wszCLSKey[STRBUFSZ];

//--------------------------------------
// Construct and Open the Class ID key.
//
    if(0 == StringFromGUID2(refCLSID, wszCLSID, STRBUFSZ))
        olErr( EH_Err, E_UNEXPECTED );

    wcscpy(wszCLSKey, L"CLSID\\");
    wcscat(wszCLSKey, wszCLSID);

    rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, wszCLSKey,
                        0, _T(""), REG_OPTION_NON_VOLATILE,
                        KEY_WRITE, NULL,
                        &hkeyCLSID, &dwDisp);
    if(ERROR_SUCCESS != rc)
        olErr( EH_Err, REGDB_E_WRITEREGDB );

//-----------------------------------------------------
// Set the description string on the Class ID Key
//
    rc = RegSetValueEx(hkeyCLSID, _T(""), 0,
                       REG_SZ, (BYTE*) pwszDescription,
                       sizeof(WCHAR)*(1+wcslen(pwszDescription)) );
    if(ERROR_SUCCESS != rc)
        olErr( EH_Err, REGDB_E_WRITEREGDB );

//---------------------------
// Open the Inproc32 Sub-key.
//
    rc = RegCreateKeyEx(hkeyCLSID, _T("InprocServer32"),
                      0, _T(""), REG_OPTION_NON_VOLATILE,
                      KEY_WRITE, NULL,
                      &hkeyInproc32, &dwDisp);
    if(ERROR_SUCCESS != rc)
        olErr( EH_Err, REGDB_E_WRITEREGDB );

//-----------------------------------------
// Set the DLL name on the Inproc32 Sub-Key
//
    rc = RegSetValueEx(hkeyInproc32, _T(""), 0,
                       REG_SZ, (BYTE*) pwszDllName,
                       sizeof(WCHAR)*(1+wcslen(pwszDllName)));
    if(ERROR_SUCCESS != rc)
        olErr( EH_Err, REGDB_E_WRITEREGDB );

//------------------------
// Set the Threading Model
//
    rc = RegSetValueEx(hkeyInproc32, _T("ThreadingModel"), 0,
                       REG_SZ, (BYTE*) pwszThreadingModel,
                       sizeof(WCHAR)*(1+wcslen(pwszThreadingModel)));
    if(ERROR_SUCCESS != rc)
        olErr( EH_Err, REGDB_E_WRITEREGDB );

EH_Err:
    if(NULL != hkeyCLSID)
        RegCloseKey(hkeyCLSID);
    if(NULL != hkeyInproc32)
        RegCloseKey(hkeyInproc32);

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddCLSIDToMultiSz, public
//
//  Synopsis:   Add the string form of a Class ID to a MultiSZ registry value.
//
//  Arguments:  [refCLSID]      Class ID to register
//              [hkeyStart]     An open registry key.
//              [wcszKey]       Path to the key reletive to hkeyStart.
//              [wcszValue]     Name of the Value under wcszKey.
//
//  Returns:    Appropriate status code
//
//  History:    18-jan-98       BChapman   Created
//
//----------------------------------------------------------------------------

STDAPI AddCLSIDToMultiSz(
        REFCLSID refCLSID,
        HKEY hkeyStart,
        WCHAR* wcszKey,
        WCHAR* wcszValue)
{
    WCHAR wszCLSID[STRBUFSZ];
    int ccCLSIDstr;
    LONG rc;
    HRESULT sc=S_OK;
    HKEY hkeyKey=NULL;

    BYTE* p_bytes=NULL;
    WCHAR* p_wsz=NULL;
    DWORD cbData, cbDataNew;
    DWORD dwType;

    ccCLSIDstr = StringFromGUID2( refCLSID, wszCLSID, STRBUFSZ );
    if( 0 == ccCLSIDstr )
        olErr( EH_Err, E_UNEXPECTED );
    ccCLSIDstr += 1;   // +1 for the NULL

    // Open the Key
    //
    rc = RegOpenKeyEx(hkeyStart,
                      wcszKey,
                      0,
                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                      &hkeyKey);
    if( ERROR_SUCCESS != rc )
        olErr( EH_Err, REGDB_E_KEYMISSING );

    // Size The Buffer,
    // Allocate the buffer,
    // And Read the data.
    //
    cbData = 0;
    cbDataNew = 0;
    rc = RegQueryValueEx( hkeyKey,
                          wcszValue,
                          0,
                          &dwType,
                          NULL,
                          &cbData );
    if( ERROR_SUCCESS != rc )
    {
        //
        // The value may not exist.  In that case we make a new entry.
        // Rather than depend on an exact error code, lets take the "new"
        // path on all failures.  We will hit real problems in the "write"
        // phase
        cbData = 1*sizeof(WCHAR); // +1 for the terminating second Null.
        cbDataNew = (ccCLSIDstr + 1) * sizeof(WCHAR);
        olMem( p_bytes = new BYTE[ cbDataNew ] );
        memset( p_bytes, 0, cbDataNew );
    }
    else
    {
        if( REG_MULTI_SZ != dwType )
            olErr( EH_Err, REGDB_E_INVALIDVALUE );

        // cbData is in units of bytes
        //
        cbDataNew = cbData + ( ccCLSIDstr * sizeof(WCHAR) );
        olMem( p_bytes = new BYTE[ cbDataNew ] );
        memset( p_bytes, 0, cbDataNew );
        rc = RegQueryValueEx( hkeyKey,
                              wcszValue,
                              0,
                              &dwType,
                              p_bytes,
                              &cbData );
        if( ERROR_SUCCESS != rc )
            olErr( EH_Err, LAST_SCODE );
    }

    // Check if the Class Id is already present
    //
    p_wsz = (WCHAR*)p_bytes;
    while( L'\0' != *p_wsz)
    {
        if( 0 == wcscmp( p_wsz, wszCLSID ) )
            break;

        // Advance to the end of the String.
        while( L'\0' != *p_wsz)
            ++p_wsz;

        // Advance to the start of the next String.
        // Or the terminating second null.
        ++p_wsz;
    }


    // If the Class Id is not already present,
    // Add the Class Id to the list
    // And write it into the Registry
    //
    if( L'\0' == *p_wsz )
    {
        wcscpy( p_wsz, wszCLSID );
        p_wsz[ ccCLSIDstr ] = L'\0';      // Add the Second Null.

        rc = RegSetValueEx( hkeyKey,
                           wcszValue,
                           0,
                           REG_MULTI_SZ,
                           p_bytes,
                           cbDataNew );
        if( ERROR_SUCCESS != rc )
            olErr( EH_Err, REGDB_E_WRITEREGDB );
    }

EH_Err:
    if( NULL != hkeyKey )
        RegCloseKey( hkeyKey );

    if( NULL != p_bytes )
        delete[] p_bytes;

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer, public
//
//  Returns:    Appropriate status code
//
//  History:    15-jan-98       BChpaman   Created
//
//----------------------------------------------------------------------------

STDAPI Storage32DllRegisterServer(void)
{
    HRESULT hrAccum=S_OK;

    return hrAccum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\difat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       difat.cxx
//
//  Contents:   Double Indirected Fat Code
//
//  Classes:    None.
//
//  Functions:
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include <msfhead.cxx>

#pragma hdrstop

#include <difat.hxx>
#include <mread.hxx>

#ifdef DIFAT_OPTIMIZATIONS
#define OPTIMIZE_LOOKUP
#define OPTIMIZE_FIXUP
#endif


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::CDIFat, public
//
//  Synopsis:   CDIFat copy constructor
//
//  Arguments:  [fatOld] -- reference to CDIFat to be copied.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

CDIFat::CDIFat(CDIFat *pfatOld)
        :   _pmsParent(NULL),
            _fv(SIDDIF)
{
#ifdef DIFAT_LOOKUP_ARRAY
    _cUnmarked = 0;
    _fDoingFixup = FALSE;
#endif    
}

//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::CDIFat, public
//
//  Synopsis:   CDIFat constructor
//
//  Arguments:  [pmsParent] -- Pointer to parent CMStream
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

CDIFat::CDIFat()
:   _pmsParent(NULL),
    _fv(SIDDIF)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat constructor\n"));
    _cfsTable = 0;
#ifdef DIFAT_LOOKUP_ARRAY
    _cUnmarked = 0;
    _fDoingFixup = FALSE;
#endif    
    msfDebugOut((DEB_ITRACE,"Out CDIFat constructor\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CDIFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _cfsTable = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CIDFat::Flush, private
//
//  Synopsis:   Flush a sector to disk
//
//  Arguments:  [oSect] -- Indicated which sector to flush
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Write sector up to parent mstream.
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Flush(void)
{
    return _fv.Flush();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, return the sector
//              value for that FatSect.
//
//  Arguments:  [oSect] -- offset in Fat chain
//
//  Returns:    Sector value of FatSect.
//
//  Algorithm:  If sector is stored in the header, retrieve it from
//                  there.
//              If not, retrieve it from the FatVector.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetFatSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;
    SECT sectReturn;

    msfDebugOut((DEB_ITRACE,"In CDIFat::GetFatSect(%lu)\n",oSect));
    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Getting sect from header\n"));
        sectReturn = _pmsParent->GetHeader()->GetFatSect(oSect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);

        msfAssert(ipfs < _cfsTable);

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
        sectReturn = pfs->GetSect(isect);
        _fv.ReleaseTable(ipfs);
    }

    msfDebugOut((DEB_ITRACE,"Out CDIFat::GetFatSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::SetFatSect, public
//
//  Synopsis:   Given an offset into the Fat chain, set the sector
//              value.
//
//  Arguments:  [oSect] -- Offset into fat chain
//              [sect] -- New sector value for that offset.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  If the sector is stored in the header, set it and
//                  flush the header.
//              Otherwise, if the sector will not fit in the current
//                  CFatVector, resize it.
//              Set the sector in the FatVector and flush it.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::SetFatSect(const FSINDEX oSect, const SECT sect)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    SCODE sc = S_OK;

    if (oSect < CSECTFAT)
    {
        msfDebugOut((DEB_ITRACE,"Setting sect in header: %lu, %lu\n",oSect,sect));
        _pmsParent->GetHeader()->SetFatSect(oSect, sect);
    }
    else
    {
        FSINDEX ipfs;
        FSOFFSET isect;

        SectToPair(oSect,&ipfs,&isect);
        if (ipfs >= _cfsTable)
        {
            msfChk(Resize(_cfsTable + 1));
        }

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

        pfs->SetSect(isect, sect);
        _fv.ReleaseTable(ipfs);

        msfDebugOut((DEB_ITRACE,"In CDIFat::SetFatSect(%lu,%lu)\n",oSect,sect));
    }

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::GetSect, public
//
//  Synopsis:   Given an offset into the DIFat chain, return the
//              sector value
//
//  Arguments:  [oSect] -- Offset into DIFat chain.
//
//  Returns:    Sector value for given offset.
//
//  Algorithm:  Retrieve the information from the NextFat fields of
//                  the CFatVector
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::GetSect(const FSINDEX oSect, SECT *psect)
{
    SCODE sc = S_OK;

    SECT sectReturn;

    msfDebugOut((DEB_ITRACE,"In CDIFat::GetSect(%lu)\n",oSect));
    msfAssert(oSect < _cfsTable);

    sectReturn = _pmsParent->GetHeader()->GetDifStart();

    //Possible optimization here:  Do some sort of check to
    //find the last page that's actually cached in the vector,
    //then start the loop from there.  Probably not a terribly
    //important optimization, but it is possible.
    for (FSINDEX oCurrent = 0; oCurrent < oSect; oCurrent++)
    {
        msfAssert(sectReturn != ENDOFCHAIN);
        
        CFatSect *pfs;
        msfChk(_fv.GetTableWithSect(oCurrent,
                                    FB_NONE,
                                    sectReturn,
                                    (void **)&pfs));
        
        sectReturn = pfs->GetNextFat(_fv.GetSectTable());
        _fv.ReleaseTable(oCurrent);
    }

    msfDebugOut((DEB_ITRACE,"Out CDIFat::GetSect(%lu)=>%lu\n",oSect,sectReturn));
    *psect = sectReturn;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Init, public
//
//  Synopsis:   Init function for previously stored DIFat.
//
//  Arguments:  [cFatSect] -- Length of DIFat in sectors
//
//  Returns:    S_OK if call completed properly.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::Init(CMStream * pmsParent, const FSINDEX cFatSect)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::Init(%lu)\n",cFatSect));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    ULONG cbSector = pmsParent->GetSectorSize();
    _fv.InitCommon(
            (FSOFFSET)(cbSector / sizeof(SECT)),
            (FSOFFSET)((cbSector / sizeof(SECT)) - 1));

    msfChk(_fv.Init(pmsParent, cFatSect));

    _cfsTable = cFatSect;

    msfDebugOut((DEB_ITRACE,"Out CDIFat::Init(%lu)\n",cFatSect));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::InitNew, public
//
//  Synopsis:   Init function for new DIFat
//
//  Arguments:  [pmsParent] -- Pointer to parent multistream
//
//  Returns:    S_OK if call completed successfully.
//
//  History:    11-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDIFat::InitNew(CMStream *pmsParent)
{
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    ULONG cbSector = pmsParent->GetSectorSize();
    _fv.InitCommon(
            (FSOFFSET)(cbSector / sizeof(SECT)),
            (FSOFFSET)((cbSector / sizeof(SECT)) - 1));
    _fv.Init(pmsParent, 0);
    _cfsTable = 0;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::InitConvert, public
//
//  Synopsis:   Init function for conversion
//
//  Arguments:  [sectMax] -- Last used sector in existing file
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    02-Jun-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::InitConvert(CMStream *pmsParent, SECT sectMax)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::InitConvert(%lu)\n",sectMax));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    USHORT cbSector = pmsParent->GetSectorSize();
    FSOFFSET csectPer = cbSector / sizeof(SECT);

    cbSector = pmsParent->GetSectorSize();
    _fv.InitCommon(cbSector / sizeof(SECT), (cbSector / sizeof(SECT)) - 1);

    FSINDEX csectFat = 0;
    FSINDEX csectFatLast;

    FSINDEX csectDif = 0;
    FSINDEX csectDifLast;
    do
    {
        //Number of fat sectors needed to represent:
        //    Number of Data Sectors (sectMax) +
        //    Number of Fat Sectors (csectFat) +
        //    Number of DIF sectors (csectDif) +
        //    Number of Directory Sectors (1)

        //We must use a loop here, since the fat must be large
        //    enough to represent itself and the DIFat.  See
        //    CFat::InitConvert for a more lengthy discussion of
        //    this method.

        csectFatLast = csectFat;

        csectFat = (sectMax + csectFatLast + csectDif + 1 + csectPer - 1) /
            csectPer;

        csectDifLast = csectDif;

        if (csectFat < CSECTFAT)
        {
            csectDif = 0;
        }
        else
        {
            FSOFFSET ciSect;

            SectToPair(csectFat, &csectDif, &ciSect);
            csectDif++;
        }
    }
    while ((csectDif != csectDifLast) || (csectFat != csectFatLast));


    _cfsTable = csectDif;

    msfChk(_fv.Init(pmsParent, _cfsTable));

    pmsParent->GetHeader()->SetDifLength(_cfsTable);

    if (_cfsTable > 0)
    {
        pmsParent->GetHeader()->SetDifStart(sectMax);

        FSINDEX i;
        for (i = 0; i < _cfsTable; i++)
        {
            CFatSect *pfs;

            msfChk(_fv.GetTable(i, FB_NEW, &pfs));
            _fv.SetSect(i, sectMax);

            sectMax++;
            pfs->SetNextFat(_fv.GetSectTable(),sectMax);
            _fv.ReleaseTable(i);
        }
    }

    msfDebugOut((DEB_ITRACE,"Out CDIFat::InitConvert()\n"));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Remap, public
//
//  Synopsis:   Remap a Fat sector for copy-on-write
//
//  Arguments:  [oSect] -- Offset into fat chain to be remapped.
//              [psectReturn] -- pointer to return value
//
//  Returns:    S_OK if call was successful.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Remap(const FSINDEX oSect, SECT * psectReturn)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::Remap(%lu)\n",oSect));
    SCODE sc = S_OK;

    SECT sectNew;
    SECT sectTemp;
    msfChk(GetFatSect(oSect, &sectTemp));

    msfChk(_pmsParent->GetFat()->QueryRemapped(sectTemp));

    if (sc == S_FALSE)
    {
        msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew, GF_READONLY));
#ifdef DIFAT_LOOKUP_ARRAY
        CacheUnmarkedSect(sectNew, FATSECT, sectTemp);
#endif        

        msfDebugOut((DEB_ITRACE,"Remapping fat sector %lu from %lu to %lu\n",oSect,sectTemp,sectNew));

        msfChk(SetFatSect(oSect, sectNew));
    }
    else
    {
        sectNew = ENDOFCHAIN;
    }
    msfDebugOut((DEB_ITRACE,"In CDIFat::Remap(%lu)=>%lu\n",oSect,sectNew));
    *psectReturn = sectNew;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::RemapSelf, public
//
//  Synopsis:   Remap the entire DIFat for copy-on-write.
//
//  Arguments:  None.
//
//  Returns:    S_OK if DIFat was remapped successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::RemapSelf(VOID)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::RemapSelf()\n"));
    SECT sectNew, sect;
    SCODE sc = S_OK;
    CFatSect *pfs;
    FSINDEX i = 0;

    if (_cfsTable > 0)
    {
        sect = _pmsParent->GetHeader()->GetDifStart();

        msfChk(_fv.GetTable(0, FB_DIRTY, &pfs));
        msfChkTo(Err_Rel0, _pmsParent->GetFat()->GetFree(1, &sectNew, GF_READONLY));

#ifdef DIFAT_LOOKUP_ARRAY
        SECT sectOld;
        sectOld = _pmsParent->GetHeader()->GetDifStart();
        CacheUnmarkedSect(sectNew, DIFSECT, sectOld);
#endif        
        _pmsParent->GetHeader()->SetDifStart(sectNew);

        _fv.SetSect(0, sectNew);

        _fv.ReleaseTable(0);
    }


    for (i = 1; i < _cfsTable; i++)
    {
        CFatSect *pfs2;

        msfChk(_fv.GetTable(i - 1, FB_DIRTY, &pfs));
        msfChkTo(Err_Rel1, _fv.GetTable(i, FB_DIRTY, &pfs2));

        msfChkTo(Err_Rel, _pmsParent->GetFat()->GetFree(
            1,
            &sectNew,
            GF_READONLY));
#ifdef DIFAT_LOOKUP_ARRAY
        SECT sectOld;
        sectOld = pfs->GetNextFat(_fv.GetSectTable());
        CacheUnmarkedSect(sectNew, DIFSECT, sectOld);
#endif        

        pfs->SetNextFat(_fv.GetSectTable(), sectNew);
        _fv.SetSect(i, sectNew);

        _fv.ReleaseTable(i - 1);
        _fv.ReleaseTable(i);
    }
    msfDebugOut((DEB_ITRACE,"In CDIFat::RemapSelf()\n"));

Err:
    return sc;

Err_Rel0:
    _fv.ReleaseTable(0);
    return sc;
Err_Rel:
    _fv.ReleaseTable(i);
Err_Rel1:
    _fv.ReleaseTable(i - 1);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDIFat::Resize, private
//
//  Synopsis:   Resize an existing DIFat.
//
//  Arguments:  [fsiSize] -- New size for object
//
//  Returns:    Nothing right now.
//
//  Algorithm:  *Finish This*
//
//  History:    11-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDIFat::Resize(FSINDEX fsiSize)
{
    msfDebugOut((DEB_ITRACE,"In CDIFat::Resize(%lu)\n",fsiSize));
    msfAssert(fsiSize == _cfsTable + 1);

    SCODE sc;

    msfChk(_fv.Resize(fsiSize));
    ULONG ipfs;
    ipfs = fsiSize - 1;

    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));

    FSINDEX csect;
    csect = _cfsTable;
    _cfsTable = fsiSize;

    SECT sectNew;

#ifdef USE_NOSCRATCH    
    //If we're in no-scratch mode, passing GF_WRITE to the fat here can
    //   cause a nasty loop on Resize().  Do a read-only GetFree in that
    //   case, and don't try to update the fat.

    if ((_pmsParent->HasNoScratch()
#ifdef USE_NOSNAPSHOT         
         ||
         (_pmsParent->GetFat()->GetNoSnapshotFree() != ENDOFCHAIN)
#endif        
        ))
    {
        msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew, GF_READONLY));
#ifdef DIFAT_LOOKUP_ARRAY
        CacheUnmarkedSect(sectNew, DIFSECT, ENDOFCHAIN);
#endif        
    }
    else
    {
#endif        
        msfChk(_pmsParent->GetFat()->GetFree(1, &sectNew, GF_WRITE));
        msfChk(_pmsParent->GetFat()->SetNext(sectNew, DIFSECT));
#ifdef USE_NOSCRATCH        
    }
#endif
    
#if DBG == 1
    STATSTG stat;

    msfHChk(_pmsParent->GetILB()->Stat(&stat, STATFLAG_NONAME));
#ifdef LARGE_DOCFILE
    //msfAssert(
    //        ConvertSectOffset(sectNew + 1, 0, _pmsParent->GetSectorShift()) <=
    //        stat.cbSize.QuadPart);
#else
    //msfAssert(
    //        ConvertSectOffset(sectNew + 1, 0, _pmsParent->GetSectorShift()) <=
    //        ULIGetLow(stat.cbSize));
#endif
#endif

    _fv.SetSect(ipfs, sectNew);
    _fv.ReleaseTable(ipfs);

    if (csect == 0)
    {
        _pmsParent->GetHeader()->SetDifStart(sectNew);
    }
    else
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(csect - 1, FB_DIRTY, &pfs));

        pfs->SetNextFat(_fv.GetSectTable(),sectNew);
        _fv.ReleaseTable(csect - 1);
    }

    _pmsParent->GetHeader()->SetDifLength(_cfsTable);

    msfDebugOut((DEB_ITRACE,"Out CDIFat::Resize(%lu)\n",fsiSize));

Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Lookup, public
//
//  Synopsis:	Lookup a sector and see if it is in the DIFat.  If it
//              is, return FATSECT if it is allocated to a fat sector
//              or DIFSECT if it is allocated to the DIF.
//
//  Arguments:	[sect] -- Sector to look up
//              [psectRet] -- Location for return value
//              [fReadOnly] -- If FALSE, decrement the dirty count
//                              after returning the page.
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	23-Feb-93	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CDIFat::Lookup(const SECT sect, SECT *psectRet)
{
    SCODE sc = S_OK;

    *psectRet = FREESECT;
#ifdef DIFAT_LOOKUP_ARRAY

    if (_cUnmarked <= DIFAT_ARRAY_SIZE)
    {
        for (USHORT iArray = 0; iArray < _cUnmarked; iArray++)
        {
            if (_sectUnmarked[iArray] == sect)
            {
                *psectRet = _sectMarkTo[iArray];
                return S_OK;
            }
        }
        return S_OK;
    }
#endif    

    for (FSINDEX i = 0; i < _pmsParent->GetHeader()->GetDifLength(); i++)
    {
        SECT sectDif;

        msfChk(GetSect(i, &sectDif));
        if (sectDif == sect)
        {
            *psectRet = DIFSECT;
            return S_OK;
        }
    }
#ifdef OPTIMIZE_LOOKUP
    CFatSect *pfs;
    pfs = NULL;
    FSINDEX ipfsLast;
    ipfsLast = (FSOFFSET) -1;
    FSINDEX ipfs;
    FSOFFSET isect;
#endif    
    for (i = 0; i < _pmsParent->GetHeader()->GetFatLength(); i++)
    {
#ifndef OPTIMIZE_LOOKUP
        SECT sectFat;

        msfChk(GetFatSect(i, &sectFat));        
        if (sectFat == sect)
        {
            *psectRet = FATSECT;
            return S_OK;
        }
#else
        SECT sectFat;
        if (i < CSECTFAT)
        {
            sectFat = _pmsParent->GetHeader()->GetFatSect(i);
        }
        else 
        {
            SectToPair(i, &ipfs, &isect);
            if (ipfs != ipfsLast)
            {
                if (pfs != NULL)
                {
                    _fv.ReleaseTable(ipfsLast);
                }
                msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
            }
            sectFat = pfs->GetSect(isect);
            ipfsLast = ipfs;
        }
        if (sect == sectFat)
        {
            if (pfs != NULL)
            {
                _fv.ReleaseTable(ipfs);
            }
            *psectRet = FATSECT;
            return S_OK;
        }
#endif        
    }

#ifdef OPTIMIZE_LOOKUP    
    if (pfs != NULL)
    {
        _fv.ReleaseTable(ipfs);
    }
#endif    
Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDIFat::Fixup, public
//
//  Synopsis:	Fixup the Fat after a copy-on-write commit.
//
//  Arguments:	[pmsShadow] -- Pointer to shadow multistream
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	23-Feb-93	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CDIFat::Fixup(CMStream *pmsShadow)
{
    SCODE sc = S_OK;

    BOOL fChanged;

    CFat *pfat = _pmsParent->GetFat();
#if DBG == 1    
    pfat->CheckFreeCount();
#endif
    
#ifdef DIFAT_LOOKUP_ARRAY
    if (_fDoingFixup)
        return S_OK;

    _fDoingFixup = TRUE;

    if (_cUnmarked <= DIFAT_ARRAY_SIZE)
    {
        for (USHORT iArray = 0;
             (iArray < _cUnmarked) && (_cUnmarked <= DIFAT_ARRAY_SIZE);
             iArray++)
        {
            //sectNew may be out of the range of the current fat.
            //Check and resize if necessary.  This is needed for
            //no-scratch mode.
            FSINDEX ipfs;
            FSOFFSET isect;
            pfat->SectToPair(_sectUnmarked[iArray], &ipfs, &isect);
            if (ipfs >= pfat->GetFatVectorLength())
            {
                msfChk(pfat->Resize(ipfs + 1));
            }

            msfChk(pfat->SetNext(_sectUnmarked[iArray],
                                 _sectMarkTo[iArray]));
            if (_sectFree[iArray] != ENDOFCHAIN)
            {
                msfChk(pfat->SetNext(_sectFree[iArray], FREESECT));
            }
        }
    }

    if (_cUnmarked <= DIFAT_ARRAY_SIZE)
    {
        _cUnmarked = 0;
        pfat->ResetUnmarkedSects();
        _fDoingFixup = FALSE;
        return S_OK;
    }
#endif
    
#ifdef USE_NOSCRATCH    
    if (pmsShadow != NULL)
    {
#endif        
        CDIFat *pdifOld = pmsShadow->GetDIFat();
        FSINDEX cFatOld = pmsShadow->GetHeader()->GetFatLength();
        FSINDEX cDifOld = pmsShadow->GetHeader()->GetDifLength();

        for (FSINDEX i = 0; i < _pmsParent->GetHeader()->GetDifLength(); i++)
        {
            SECT sectNew;
            SECT sectOld = ENDOFCHAIN;
            SECT sectCurrent;

            msfChk(GetSect(i, &sectNew));

            if (i < cDifOld)
                msfChk(pdifOld->GetSect(i, &sectOld));

            if ((sectNew != sectOld) || (sectOld == ENDOFCHAIN))
            {
#ifdef USE_NOSCRATCH                
                //sectNew may be out of the range of the current fat.
                //Check and resize if necessary.
                FSINDEX ipfs;
                FSOFFSET isect;
                pfat->SectToPair(sectNew, &ipfs, &isect);
                if (ipfs >= pfat->GetFatVectorLength())
                {
                    msfChk(pfat->Resize(ipfs + 1));
                }
#endif
                
                msfChk(pfat->GetNext(sectNew, &sectCurrent));
                if (sectCurrent != DIFSECT)
                {
                    msfChk(pfat->SetNext(sectNew, DIFSECT));
                }

                if (sectOld != ENDOFCHAIN)
                {
                    //sectOld should always be within the range of the
                    //fat, so we don't need to check and resize here.
                    msfChk(pfat->GetNext(sectOld, &sectCurrent));
                    if (sectCurrent != FREESECT)
                    {
                        msfChk(pfat->SetNext(sectOld, FREESECT));
                    }
                }
            }
        }


        do
        {
            fChanged = FALSE;
#ifdef OPTIMIZE_FIXUP
            CFatSect *pfs;
            pfs = NULL;
            FSINDEX ipfsLast;
            ipfsLast = (FSOFFSET) - 1;
            FSINDEX ipfs;
            FSOFFSET isect;

            CFatSect *pfsShadow;
            pfsShadow = NULL;
            FSINDEX ipfsLastShadow;
            ipfsLastShadow = (FSOFFSET) - 1;
            FSINDEX ipfsShadow;
            FSOFFSET isectShadow;
            
#endif            
            for (i = 0; i < _pmsParent->GetHeader()->GetFatLength(); i++)
            {
                SECT sectNew;
                SECT sectCurrent;
                SECT sectOld = ENDOFCHAIN;

#ifndef OPTIMIZE_FIXUP                
                msfChk(GetFatSect(i, &sectNew));
#else
                if (i < CSECTFAT)
                {
                    sectNew = _pmsParent->GetHeader()->GetFatSect(i);
                }
                else
                {
                    SectToPair(i, &ipfs, &isect);
                    if (ipfs != ipfsLast)
                    {
                        if (pfs != NULL)
                        {
                            _fv.ReleaseTable(ipfsLast);
                        }
                        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
                    }
                    sectNew = pfs->GetSect(isect);
                    ipfsLast = ipfs;
                }
#endif                

#ifndef OPTIMIZE_FIXUP                
                if (i < cFatOld)
                    msfChk(pdifOld->GetFatSect(i, &sectOld));
#else
                if (i < cFatOld)
                {
                    if (i < CSECTFAT)
                    {
                        sectOld = pmsShadow->GetHeader()->GetFatSect(i);
                    }
                    else
                    {
                        SectToPair(i, &ipfsShadow, &isectShadow);
                        if (ipfsShadow != ipfsLastShadow)
                        {
                            if (pfsShadow != NULL)
                            {
                                pdifOld->_fv.ReleaseTable(ipfsLastShadow);
                            }
                            msfChk(pdifOld->_fv.GetTable(ipfsShadow,
                                                         FB_NONE,
                                                         &pfsShadow));
                        }
                        sectOld = pfsShadow->GetSect(isectShadow);
                        ipfsLastShadow = ipfsShadow;
                    }
                }
#endif                

                if ((sectNew != sectOld) || (sectOld == ENDOFCHAIN))
                {
                    //Sector has been remapped.

#ifdef USE_NOSCRATCH                    
                    //sectNew may be outside the range of the current
                    //fat.  Check and resize if necessary.
                    //If we resize, set fChanged, since we may need to
                    //go through again.

                    FSINDEX ipfs;
                    FSOFFSET isect;
                    pfat->SectToPair(sectNew, &ipfs, &isect);
                    if (ipfs >= pfat->GetFatVectorLength())
                    {
                        msfChk(pfat->Resize(ipfs + 1));
                        fChanged = TRUE;
                    }
#endif
                    
                    msfChk(pfat->GetNext(sectNew, &sectCurrent));

                    if (sectCurrent != FATSECT)
                    {
                        msfChk(pfat->SetNext(sectNew, FATSECT));
                        fChanged = TRUE;
                    }

                    if (sectOld != ENDOFCHAIN)
                    {
                        //sectOld is always inside the existing fat,
                        //so we don't need to check and resize.
                        msfChk(pfat->GetNext(sectOld, &sectCurrent));
                        if (sectCurrent != FREESECT)
                        {
                            msfChk(pfat->SetNext(sectOld, FREESECT));
                            fChanged = TRUE;
                        }
                    }
                }
            }
#ifdef OPTIMIZE_FIXUP
            if (pfs != NULL)
                _fv.ReleaseTable(ipfsLast);
            if (pfsShadow != NULL)
                pdifOld->_fv.ReleaseTable(ipfsLastShadow);
#endif            
        }
        while (fChanged);
#ifdef USE_NOSCRATCH        
    }
    else
    {
        //This is for fixing the fat while in overwrite mode with
        //  no-scratch.
        do
        {
            fChanged = FALSE;
            for (FSINDEX i = 0;
                 i < _pmsParent->GetHeader()->GetFatLength();
                 i++)
            {
                SECT sectNew;
                SECT sectCurrent;

                msfChk(GetFatSect(i, &sectNew));
                
                //sectNew may be outside the range of the current fat.  If
                //so, resize the fat.
                FSINDEX ipfs;
                FSOFFSET isect;
                pfat->SectToPair(sectNew, &ipfs, &isect);
                if (ipfs >= pfat->GetFatVectorLength())
                {
                    msfChk(pfat->Resize(ipfs + 1));
                    fChanged = TRUE;
                }
                
                msfChk(pfat->GetNext(sectNew, &sectCurrent));
                if (sectCurrent != FATSECT)
                {
                    msfChk(pfat->SetNext(sectNew, FATSECT));
                    fChanged = TRUE;
                }
            }
        }
        while (fChanged);
    }
#endif        
    pfat->ResetUnmarkedSects();
#ifdef DIFAT_LOOKUP_ARRAY
    _cUnmarked = 0;
#endif    
Err:
#ifdef DIFAT_LOOKUP_ARRAY    
    _fDoingFixup = FALSE;
#endif
#if DBG == 1    
    pfat->CheckFreeCount();
#endif    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\fat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       fat.cxx
//
//  Contents:   Allocation functions for MStream
//
//  Classes:    None. (defined in fat.hxx)
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <difat.hxx>
#include <sstream.hxx>
#include <mread.hxx>

#define USE_NOSCRATCHINMARKSECT

//#define SECURETEST
//+---------------------------------------------------------------------------
//
//  Member:	CFat::IsFree, private
//
//  Synopsis:	Check and see if a given sector is really free, given all
//              the permutations of ways a sector can be assigned.
//
//  Arguments:	[sect] -- Sector to check
//
//  Returns:	S_OK if sector is really free.
//              S_FALSE if sector is really allocated.
//              Appropriate error in error case.
//
//  Modifies:	
//
//  History:	30-Mar-95	PhilipLa	Created
//              15-Mar-97       BChapman        Calls IsSectType()
//
//----------------------------------------------------------------------------

inline SCODE CFat::IsFree(SECT sect)
{
    return IsSectType(sect, FREESECT);
}

//
//+---------------------------------------------------------------------------
//
//  Member:	CFat::IsSectType, private
//
//  Synopsis:	Check and see if a given sector is really of a given type,
//              given all the permutations of ways a sector can be assigned.
//              If we are looking for FREESECT there are extra checks.
//
//  Arguments:	[sect]     -- Sector to check
//              [sectType] -- Sector type to check against FREE, FAT, DIF.
//
//  Returns:	S_OK if sector is really free.
//              S_FALSE if sector is really allocated.
//              Appropriate error in error case.
//
//  Modifies:	
//
//  History:	18-Feb-97	BChapman	Created
//
//----------------------------------------------------------------------------

inline SCODE CFat::IsSectType(SECT sect, SECT sectType)
{
    SCODE sc = S_OK;
    SECT sectCurrent = sectType;

#ifdef DEBUG_ISSECTTYPE
    msfDebugOut((DEB_ITRACE, "In  CFat::IsSectType:%p(%x, %x)\n",
                                    this, sect, sectType));
#endif

    if((FREESECT == sectType))
    {
        if (sect < _sectNoSnapshot)
        {
            return S_FALSE;
        }
        if ((_sectNoSnapshotFree != ENDOFCHAIN)
                        && (sect < _sectNoSnapshotFree))
        {
            return S_FALSE;
        }
    }

    if (_pfatNoScratch != NULL)
    {
        msfAssert((!_pmsParent->IsScratch()) &&
                  aMsg("Scratch MS in Noscratch mode"));

        FSINDEX ipfs;
        FSOFFSET isect;

        _pfatNoScratch->SectToPair(sect, &ipfs, &isect);

        if (ipfs < _pfatNoScratch->_cfsTable)
        {
            //We need to check the NoScratch fat to make sure
            //that this sector isn't already allocated into
            //scratch space for a stream.

            msfChk(_pfatNoScratch->GetNext(
                sect,
                &sectCurrent));
        }
    }
    //Since the no-scratch fat will have a complete copy of everything
    //  in the shadow fat, we don't need to check both.  So only do this
    //  when we're not in no-scratch mode.
    //The no-scratch fat also has a copy of the read-only GetFree()
    //  returned stuff, so we only need to do that check when not in
    //  no-scratch.
    else
    {
        if (_cUnmarkedSects > 0)
        {
            //We are in copy-on-write mode.  Lookup this
            //sector in the DIF and make sure that it is
            //actually free.
            msfAssert((_sectLastUsed > 0) &&
                      aMsg("Doing DIFat check when not in COW."));

            msfChk(_pmsParent->GetDIFat()->Lookup(
                sect,
                &sectCurrent));
        }

        if (FREESECT == sectType)
        {
            if ((sect < _sectLastUsed) && (sectCurrent == FREESECT))
            {
                //We're in copy-on-write mode, so
                //   this sector may not be really free.
                msfAssert(_sid != SIDMINIFAT &&
                          aMsg("Minifat in Copy-on-Write mode"));
                msfAssert(_pfatReal != NULL &&
                          aMsg("Copy-On-Write mode without fat copy"));
                msfAssert(_pfatReal->_cfsTable != 0 &&
                          aMsg("Copy-on-Write mode with empty fat copy"));
                msfAssert(_pfatReal->_pmsParent->IsShadow() &&
                          aMsg("Copy-on-Write mode with non-shadow fat copy"));

                msfChk(_pfatReal->GetNext(sect, &sectCurrent));
            }
        }
    }

    if (sectCurrent != sectType)
    {
        sc = S_FALSE;
    }

#ifdef DEBUG_ISSECTTYPE
    msfDebugOut((DEB_ITRACE, "Out CFat::IsSectType\n"));
#endif

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::Init, public
//
//  Synopsis:   CFatSect initialization function
//
//  Effects:    [uEntries] -- Number of entries in sector
//
//  Algorithm:  Allocate an array of SECT with size uEntries from
//              the heap.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Dec-91   PhilipLa    Converted to dynamic allocation
//
//--------------------------------------------------------------------------


SCODE CFatSect::Init(FSOFFSET uEntries)
{
    msfDebugOut((DEB_FAT,"In CFatSect constructor\n"));

    //This assumes that FREESECT is always 0xFFFFFFFF
    memset(_asectEntry, 0xFF, uEntries * sizeof(SECT));

    msfDebugOut((DEB_FAT,"Out CFatSect constructor\n"));
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFatSect::InitCopy, public
//
//  Synopsis:   Initialization function for copying FatSects
//
//  Arguments:  [fsOld] -- Reference to FatSect to be copies
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Allocate a new array of SECT and copy old
//                  information in.
//
//  History:    06-Feb-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CFatSect::InitCopy(USHORT uSize, CFatSect *pfsOld)
{
    msfDebugOut((DEB_FAT,"In CFatSect copy constructor\n"));
    msfDebugOut((DEB_FAT,"This = %p,  fsOld = %p\n",this, pfsOld));

    msfDebugOut((DEB_FAT,"Sector size is %u sectors\n", uSize));

    memcpy(_asectEntry, &pfsOld->_asectEntry, sizeof(SECT)*uSize);
    msfDebugOut((DEB_FAT,"Out CFatSect copy constructor\n"));
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::CFat, public
//
//  Synopsis:   CFat constructor.
//
//  Arguments:  [pmsParent] -- Pointer to parent multistream.
//
//  Algorithm:  Set uFatEntries to match parent MS header info.
//              Initialize all member variables.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Dec-91   PhilipLa    Converted to use FatVector
//              30-Dec-91   PhilipLa    Converted to use variable size sect.
//
//  Notes:
//
//--------------------------------------------------------------------------


CFat::CFat(SID sid)
: _fv(sid),
  _pfatReal(NULL),
  _pfatNoScratch(NULL),
  _sectNoSnapshot(0),
  _sectNoSnapshotFree(ENDOFCHAIN),
  _sid(sid),
  _pmsParent(NULL),
  _sectFirstFree(0),
  _sectLastUsed(0),
  _sectMax(ENDOFCHAIN)
{
    _cUnmarkedSects = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::CFat, public
//
//  Synopsis:   CFat copy constructor
//
//  Arguments:  [fatOld] -- Fat to be copied.
//
//  Algorithm:  Set member variables to match fat being copied.
//
//  History:    27-Dec-91   PhilipLa    Created.
//
//  Notes:      This is for use in transactioning.  It is the only proper
//              way to create a Shadow Fat.
//
//--------------------------------------------------------------------------


CFat::CFat(CFat *pfatOld)
  :    _pmsParent(pfatOld->_pmsParent),
       _fv(pfatOld->_sid),
       _pfatReal(NULL),
       _sid(pfatOld->_sid),
       _sectFirstFree(0),
       _sectLastUsed(0),
       _sectMax(ENDOFCHAIN),
       _sectNoSnapshot(pfatOld->_sectNoSnapshot)
{
    _cUnmarkedSects = 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFat::InitCopy, public
//
//  Synopsis:   Init function for CFat copying
//
//  Arguments:  [fatOld] -- reference to CFat to be copied
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


void CFat::InitCopy(CFat *pfatOld)
{
    msfDebugOut((DEB_FAT,"In CFat Copy Constructor\n"));

    _pmsParent = pfatOld->_pmsParent;

    _uFatShift = pfatOld->_uFatShift;
    _uFatMask = pfatOld->_uFatMask;

    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);

    _cfsTable = pfatOld->_cfsTable;

    _fv.InitCopy(&pfatOld->_fv);

    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = pfatOld->_sectFirstFree;
    _sectLastUsed = pfatOld->_sectLastUsed;
    _sectMax = pfatOld->_sectMax;
    _ipfsRangeLocks = pfatOld->_ipfsRangeLocks;
    _isectRangeLocks = pfatOld->_isectRangeLocks;

    msfDebugOut((DEB_FAT,"Out CFat Copy Constructor\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CFat::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CFat::Empty(void)
{
    _fv.Empty();
    _pmsParent = NULL;
    _pfatReal = NULL;
    _cfsTable = 0;
    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = 0;
    _sectLastUsed = 0;
    _sectMax = ENDOFCHAIN;
    _cUnmarkedSects = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::~CFat, public
//
//  Synopsis:   CFat Destructor
//
//  Algorithm:  delete dynamically allocated storage
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Jul-91   PhilipLa    Converted to use FatVect.
//
//  Notes:
//
//--------------------------------------------------------------------------


CFat::~CFat()
{
    msfDebugOut((DEB_FAT,"In CFat destructor.  Size of fat is %lu\n",_cfsTable));

    msfDebugOut((DEB_FAT,"Exiting CFat destructor\n"));
}

struct SGetFreeStruct
{
    CVectBits *pfb;

    SECT sect;
    CFatSect *pfs;
    FSOFFSET isect;
    FSINDEX ipfs;

    SECT sectLast;
    FSINDEX ipfsLast;
    FSOFFSET isectLast;

#ifdef USE_NOSCRATCHINMARKSECT
    CFatSect *pfsNoScratch;
    FSINDEX ipfsNoScratch;
#endif
};



//+---------------------------------------------------------------------------
//
//  Member:	CFat::InitGetFreeStruct, private
//
//  Synopsis:	Initialize an SGetFreeStruct
//
//  Arguments:	[pgf] -- Pointer to structure to initialize
//
//  History:	03-Nov-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CFat::InitGetFreeStruct(SGetFreeStruct *pgf)
{
    pgf->sectLast = ENDOFCHAIN;
    pgf->pfs = NULL;
#ifdef USE_NOSCRATCHINMARKSECT
    pgf->pfsNoScratch = NULL;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:	CFat::ReleaseGetFreeStruct, private
//
//  Synopsis:	Release an SGetFreeStruct
//
//  Arguments:	[pgf] -- Pointer to structure to release
//
//  History:	03-Nov-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CFat::ReleaseGetFreeStruct(SGetFreeStruct *pgf)
{
    if (pgf->pfs != NULL)
    {
        _fv.ReleaseTable(pgf->ipfs);
    }
#ifdef USE_NOSCRATCHINMARKSECT
    if (pgf->pfsNoScratch != NULL)
    {
        _pfatNoScratch->_fv.ReleaseTable(pgf->ipfsNoScratch);
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:	CFat::MarkSect, private
//
//  Synopsis:	Mark a sector as used, for use from GetFree and GetFreeContig
//
//  Arguments:	[pgf] -- Pointer to SGetFreeStruct with information about
//                       which sector to mark.  This structure also returns
//                       information to the caller, so that state can be
//                       preserved across multiple calls for optimization.
//
//  Returns:	Appropriate status code
//
//  History:	27-Oct-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

inline SCODE CFat::MarkSect(SGetFreeStruct *pgf)
{
    msfAssert(_ulFreeSects != MAX_ULONG &&
              aMsg("Free sect count not set"));

    SCODE sc = S_OK;

    _ulFreeSects--;

    CVectBits * &pfb = pgf->pfb;

    SECT &sect = pgf->sect;
    FSOFFSET &isect = pgf->isect;
    FSINDEX &ipfs = pgf->ipfs;
    CFatSect * &pfs = pgf->pfs;
#ifdef USE_NOSCRATCHINMARKSECT
    CFatSect * &pfsNoScratch = pgf->pfsNoScratch;
    FSINDEX &ipfsNoScratch = pgf->ipfsNoScratch;
#endif

    SECT &sectLast = pgf->sectLast;
    FSINDEX &ipfsLast = pgf->ipfsLast;
    FSOFFSET &isectLast = pgf->isectLast;

    //If we're tracking the first free sector, we know it must be
    //  after this one, so set firstfree.
    if (pfb != NULL)
    {
        pfb->firstfree = isect + 1;
    }

    //Update _sectFirstFree, since the first free sector must be after then
    //  current one.
    msfAssert(sect >= _sectFirstFree &&
              aMsg("Found free sector before _sectFirstFree"));
    _sectFirstFree = sect + 1;

    //Mark the current sector as ENDOFCHAIN in the fat.
    pfs->SetSect(isect, ENDOFCHAIN);

    if (_pfatNoScratch != NULL)
    {
#ifdef USE_NOSCRATCHINMARKSECT
        //In no-scratch, update the no-scratch fat
        //as well.
        FSINDEX  ipfsNoScratchChk;
        FSOFFSET isectNoScratchChk;
        _pfatNoScratch->SectToPair(sect,
                                   &ipfsNoScratchChk,
                                   &isectNoScratchChk);

        if ((pfsNoScratch != NULL) && (ipfsNoScratch != ipfsNoScratchChk))
        {
            _pfatNoScratch->_fv.ReleaseTable(ipfsNoScratch);
            pfsNoScratch = NULL;
        }

        if (pfsNoScratch == NULL)
        {
            //SetNext call will grow the no-scratch fat if necessary.
            msfChk(_pfatNoScratch->SetNext(sect, ENDOFCHAIN));
            msfChk(_pfatNoScratch->_fv.GetTable(ipfsNoScratchChk,
                                                FB_DIRTY,
                                                &pfsNoScratch));
            ipfsNoScratch = ipfsNoScratchChk;
        }
        else
        {
            pfsNoScratch->SetSect(isectNoScratchChk, ENDOFCHAIN);
            _pfatNoScratch->_ulFreeSects--;
        }
#else
        msfChk(_pfatNoScratch->SetNext(sect, ENDOFCHAIN)); // slow, unoptimized
#endif
    }

    //Dirty the current page.
    if ((sectLast == ENDOFCHAIN) || (ipfs != ipfsLast))
    {
        //We only need to make this call if we're touching a new
        //  page for the first time.
        msfChk(_fv.SetDirty(ipfs));
    }

    //If we're building a chain, we want to update it here.
    if (sectLast != ENDOFCHAIN)
    {
        if (_pfatNoScratch != NULL)
        {
#ifdef USE_NOSCRATCHINMARKSECT
            FSINDEX ipfsNoScratchChk;
            FSOFFSET isectNoScratchChk;
            _pfatNoScratch->SectToPair(sectLast,
                                       &ipfsNoScratchChk,
                                       &isectNoScratchChk);

            if (ipfsNoScratchChk == ipfsNoScratch)
            {
                msfAssert(pfsNoScratch != NULL);
                pfsNoScratch->SetSect(isectNoScratchChk, sect);
            }
            else
            {
                msfChk(_pfatNoScratch->SetNext(sectLast, sect));
            }
#else
            msfChk(_pfatNoScratch->SetNext(sectLast, sect)); //slow,unoptimized
#endif
        }
        //If we're in the same page, we can do this cheaply.
        if (ipfsLast == ipfs)
        {
            pfs->SetSect(isectLast, sect);
        }
        else
        {
            //If we're NOT on the same page, we have to go grab the
            //  old one again, which can be expensive if the page table is full
            CFatSect *pfsLast;

            //Since we may only have one available page for the scratch MS,
            //  we need to release the current one before proceeding.
            //  
            if (_pmsParent->IsScratch())
            {
                _fv.ReleaseTable(ipfs);
            }

            msfChk(_fv.GetTable(ipfsLast,
                                FB_DIRTY,
                                &pfsLast));

            pfsLast->SetSect(isectLast, sect);
            _fv.ReleaseTable(ipfsLast);

            //Reacquire the current page if we're in the scratch.
            if (_pmsParent->IsScratch())
            {
                msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));
            }
        }
    }

    return S_OK;
Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetFree, private
//
//  Synposis:   Locate and return a free sector in the FAT
//
//  Effects:    May modify full bit on full sectors
//
//  Arguments:  [psectRet] -- Pointer to return value
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  Do a linear search of all tables until a free sector is
//              found.  If all tables are full, extend the FAT by one
//              sector.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              22-Jul-91   PhilipLa    Added FAT extension.
//              17-Aug-91   PhilipLa    Added full bits optimization
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetFree(ULONG ulCount, SECT *psectRet, BOOL fReadOnly)
{
    SGetFreeStruct gf;

    SECT &sect = gf.sect;
    CVectBits * &pfb = gf.pfb;
    FSOFFSET &isect = gf.isect;
    FSINDEX &ipfs = gf.ipfs;
    CFatSect * &pfs = gf.pfs;
    SECT &sectLast = gf.sectLast;
    FSINDEX &ipfsLast = gf.ipfsLast;
    FSOFFSET &isectLast = gf.isectLast;

    InitGetFreeStruct(&gf);

    SCODE sc;

    *psectRet = ENDOFCHAIN;

    msfAssert((!_pmsParent->IsShadow()) &&
              aMsg("Modifying shadow fat."));

    msfAssert(((!fReadOnly) || (ulCount == 1)) &&
              aMsg("Read-only GetFree called with ulCount != 1"));
    if (_sectNoSnapshotFree != ENDOFCHAIN)
    {
        //We're resizing our control structures to prepare for
        //  no-snapshot commit.
        msfAssert((ulCount == 1) &&
                  aMsg("No-snapshot GetFree called with ulCount != 1"));
        msfAssert(fReadOnly &&
                  aMsg("No-snapshot GetFree called without fReadOnly"));
        *psectRet = _sectNoSnapshotFree++;
        _cUnmarkedSects++;
        if ((_ulFreeSects != 0) && (_ulFreeSects != MAX_ULONG))
        {
            _ulFreeSects--;
        }
        if (*psectRet >= _sectMax)
        {
            _sectMax = *psectRet + 1;
        }
        return S_OK;
    }

    if ((fReadOnly) && (_pfatNoScratch != NULL))
    {
        //As an optimization, and to prevent loops, we can dispatch
        //this call directly to the no-scratch fat, since it has a
        //complete picture of everything allocated in this fat.

        //Note that we don't need to pass the read-only flag to the
        //no-scratch, since it's perfectly OK to scribble on it
        //as much as we want.

        //Further note that if fReadOnly is true, then ulCount must be
        //  1, so we can just work with the constant.
        msfChk(_pfatNoScratch->GetFree(1, psectRet, GF_WRITE));
        if (_ulFreeSects != MAX_ULONG)
        {
            _ulFreeSects--;
        }

        _cUnmarkedSects++;
        if (*psectRet >= _sectMax)
        {
            _sectMax = *psectRet + 1;
        }
        return S_OK;
    }

    while (TRUE)
    {
        //Make sure there are enough free sectors to hold the whole chain
        //  we're trying to allocate.
        if (_ulFreeSects == MAX_ULONG)
        {
            msfChk(CountFree(&_ulFreeSects));
        }
#if DBG == 1
        else
        {
            CheckFreeCount();
        }
#endif

        while (ulCount > _ulFreeSects)
        {
#if DBG == 1 && !defined(USE_NOSCRATCH)
            ULONG ulFree = _ulFreeSects;
#endif
            msfChk(Resize(_cfsTable +
                          ((ulCount - _ulFreeSects + _fv.GetSectTable() - 1) >>
                           _uFatShift)));
#if DBG == 1 && !defined(USE_NOSCRATCH)
            msfAssert(_ulFreeSects > ulFree &&
                      aMsg("Number of free sectors didn't increase after Resize."));
#endif

        }

        //Starting at the first known free sector, loop until we find
        //  enough sectors to complete the chain.
        FSOFFSET isectStart;
        FSINDEX ipfsStart;

        SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

        for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
        {
            //Only check a page if it is not known to be full.
            pfb = _fv.GetBits(ipfs);

            if ((pfb == NULL) || (!pfb->full))
            {
                msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

                //Eliminate part of the search based on the first-known
                //  free entry for the page
                if (pfb != NULL)
                {
                    isectStart = pfb->firstfree;
                }

                for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
                {
                    SECT sectCurrent = pfs->GetSect(isect);
                    sect = PairToSect(ipfs, isect);

                    //If the sector is marked FREESECT, it still may not
                    //  really be free.  The IsFree function will return
                    //  S_OK if it is OK to allocate.
                    if ((sectCurrent == FREESECT) &&
                        ((sc = IsFree(sect)) == S_OK))
                    {
                        //If fReadOnly is TRUE (meaning we're being called
                        //  by the DIFat), then we don't want to actually
                        //  mark anything in the current fat.  We'll return
                        //  the current sector and then be done with it.
                        if (fReadOnly)
                        {
                            _cUnmarkedSects++;
                            _ulFreeSects--;
                        }
                        else
                        {
                            //Mark the sector as free and return it.
                            msfChkTo(Err_Rel, MarkSect(&gf));
                        }

                        if (*psectRet == ENDOFCHAIN)
                        {
                            *psectRet = sect;
                        }

                        ulCount--;

                        if (ulCount == 0)
                        {
                            //If we're done, release the current table,
                            //  update _sectMax, and return.

                            if (sect >= _sectMax)
                            {
                                _sectMax = sect + 1;
                            }

                            ReleaseGetFreeStruct(&gf);
                            return S_OK;
                        }
                        else
                        {
                            //Otherwise update the internal counters and
                            //  keep going.
                            sectLast = sect;
                            ipfsLast = ipfs;
                            isectLast = isect;
                        }
                    }
                    else
                    {
                        msfChkTo(Err_Rel, sc);
                    }

                }
                _fv.ReleaseTable(ipfs);
                //If we are keeping a full bit, we can set it here, since
                //  we know we've allocated everything out of the current
                //  page.
                // the vectbits pointer may have changed due to a resize
                pfb = _fv.GetBits(ipfs);
                if (pfb != NULL)
                {
                    pfb->full = TRUE;
                }
            }
            isectStart = 0;
        }

        //Keep _sectMax up to date for SetSize purposes.
        if (sectLast >= _sectMax)
        {
            _sectMax = sectLast + 1;
        }
    }
    msfAssert(0 &&
              aMsg("GetFree exited improperly."));
    sc = STG_E_ABNORMALAPIEXIT;

Err:
    ReleaseGetFreeStruct(&gf);
    return sc;

Err_Rel:
    ReleaseGetFreeStruct(&gf);
    return sc;
}






//+---------------------------------------------------------------------------
//
//  Member:	CFat::GetFreeContig, public
//
//  Synopsis:	Return a chain of free sectors, including contiguity
//              information about the chain.
//
//  Arguments:	[ulCount] -- Number of sectors to allocate
//              [aseg] -- Contig table to fill in
//              [cSeg] -- Index of last used segment in contig table.
//              [pcSegReturned] -- Pointer to return location for total
//                                 number of segments returned.
//
//  Returns:	Appropriate status code
//
//  History:	27-Oct-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::GetFreeContig(ULONG ulCount,
                                    SSegment STACKBASED *aseg,
                                    ULONG cSeg,
                                    ULONG *pcSegReturned)
{
    SGetFreeStruct gf;

    SECT &sect = gf.sect;
    CVectBits * &pfb = gf.pfb;
    FSOFFSET &isect = gf.isect;
    FSINDEX &ipfs = gf.ipfs;
    CFatSect * &pfs = gf.pfs;
    SECT &sectLast = gf.sectLast;
    FSINDEX &ipfsLast = gf.ipfsLast;
    FSOFFSET &isectLast = gf.isectLast;

    InitGetFreeStruct(&gf);

    FSINDEX ipfsFirstDirty;

    SCODE sc;

    //Variables used for tracking contiguity.
    //cSegCurrent is the current segment being processed.
    ULONG cSegCurrent = cSeg;

    //sectLast is the last sector returned.  We start this with the
    //  last thing in the current contig table, and the MarkSect
    //  function will patch up the chain for us.
    sectLast = aseg[cSeg].sectStart + aseg[cSeg].cSect - 1;
    SectToPair(sectLast, &ipfsLast, &isectLast);
    ipfsFirstDirty = ipfsLast;
#if DBG == 1
    SECT sectTest;
    GetNext(sectLast, &sectTest);
    msfAssert(sectTest == ENDOFCHAIN);
#endif

    msfAssert((!_pmsParent->IsShadow()) &&
              aMsg("Modifying shadow fat."));

    while (TRUE)
    {
        //Make sure there are enough free sectors to hold the whole chain
        //  we're trying to allocate.
        if (_ulFreeSects == MAX_ULONG)
        {
            msfChk(CountFree(&_ulFreeSects));
        }
#if DBG == 1
        else
        {
            CheckFreeCount();
        }
#endif

        while (ulCount > _ulFreeSects)
        {
#if DBG == 1 && !defined(USE_NOSCRATCH)
            ULONG ulFree = _ulFreeSects;
#endif
            msfChk(Resize(_cfsTable +
                          ((ulCount - _ulFreeSects + _fv.GetSectTable() - 1) >>
                           _uFatShift)));
#if DBG == 1 && !defined(USE_NOSCRATCH)
            msfAssert(_ulFreeSects > ulFree &&
                      aMsg("Number of free sectors didn't increase after Resize."));
#endif

        }

        //Starting at the first known free sector, loop until we find
        //  enough sectors to complete the chain.
        FSOFFSET isectStart;
        FSINDEX ipfsStart;

        SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

        for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
        {
            //Only check a page if it is not known to be full.
            pfb = _fv.GetBits(ipfs);

            if ((pfb == NULL) || (!pfb->full))
            {
                //This little contortion is necessary because the
                //  page containing the first sector may not get marked
                //  as dirty by MarkSect.
                if (ipfs == ipfsFirstDirty)
                {
                    msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));
                }
                else
                {
                    msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
                }

                //Eliminate part of the search based on the first-known
                //  free entry for the page
                if (pfb != NULL)
                {
                    isectStart = pfb->firstfree;
                }

                for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
                {
                    SECT sectCurrent = pfs->GetSect(isect);
                    sect = PairToSect(ipfs, isect);

                    //If the sector is marked FREESECT, it still may not
                    //  really be free.  The IsFree function will return
                    //  TRUE if it is OK to allocate.
                    if ((sectCurrent == FREESECT) &&
                        ((sc = IsFree(sect)) == S_OK))
                    {
                        //Mark the sector as free and return it.
                        msfChkTo(Err_Rel, MarkSect(&gf));

                        ulCount--;

                        //Update the contig table with this new information.

                        if (cSegCurrent < CSEG)
                        {
                            if (sect != sectLast + 1)
                            {
                                //Use a new entry in the contig table.
                                cSegCurrent++;
                                if (cSegCurrent < CSEG)
                                {
                                    aseg[cSegCurrent].ulOffset =
                                        aseg[cSegCurrent - 1].ulOffset +
                                        aseg[cSegCurrent - 1].cSect;
                                    aseg[cSegCurrent].sectStart = sect;
                                    aseg[cSegCurrent].cSect = 1;
                                }
                            }
                            else
                            {
                                //Grow the current segment
                                aseg[cSegCurrent].cSect++;
                            }
                        }

                        if (ulCount == 0)
                        {
                            //If we're done, release the current table,
                            //  update _sectMax, and return.

                            if (sect >= _sectMax)
                            {
                                _sectMax = sect + 1;
                            }

                            *pcSegReturned = cSegCurrent;
                            ReleaseGetFreeStruct(&gf);
#if DBG == 1
                            _fv.ResetBits();
                            CheckFreeCount();
#endif

                            return S_OK;
                        }
                        else
                        {
                            //Otherwise update the internal counters and
                            //  keep going.
                            sectLast = sect;
                            ipfsLast = ipfs;
                            isectLast = isect;
                        }
                    }
                    else
                    {
                        msfChkTo(Err_Rel, sc);
                    }

                }

                _fv.ReleaseTable(ipfs);
                //If we are keeping a full bit, we can set it here, since
                //  we know we've allocated everything out of the current
                //  page.
                // the vectbits pointer may have changed due to a resize
                pfb = _fv.GetBits(ipfs);
                if (pfb != NULL)
                {
                    pfb->full = TRUE;
                }
            }
            isectStart = 0;
        }

        //Keep _sectMax up to date for SetSize purposes.
        if (sectLast >= _sectMax)
        {
            _sectMax = sectLast + 1;
        }
    }
    msfAssert(0 &&
              aMsg("GetFree exited improperly."));
    sc = STG_E_ABNORMALAPIEXIT;

Err:
    ReleaseGetFreeStruct(&gf);
    return sc;

Err_Rel:
    ReleaseGetFreeStruct(&gf);
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::Contig, public
//
//  Synposis:   Create contiguous sector table
//
//  Effects:    Return contiguity information about a chain.
//
//  Arguments:  [aseg] -- Segment table to return data in
//              [sect] -- Starting sector for table to begin
//              [ulength] -- Runlength in sectors of table to produce
//              [pcSeg] -- Returns count of segments in table
//
//  Returns:    Appropriate status code.
//
//  Algorithm:  Perform calls to CFat::GetNext().  Any call that is
//              1 higher than the previous represents contiguous blocks.
//              Construct the Segment table on that basis.
//
//  History:    16-Aug-91   PhilipLa    Created.
//              20-May-92   AlexT       Moved to CFat
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE  CFat::Contig(
    SSegment STACKBASED *aseg,
    BOOL fWrite,
    SECT sectStart,
    ULONG ulLengthStart,
    ULONG *pcSeg)
{
    msfDebugOut((DEB_ITRACE,"In CFat::Contig(%lu,%lu)\n",sectStart,ulLengthStart));
    SCODE sc = S_OK;

    ULONG ulLength = ulLengthStart;
    SECT sect = sectStart;
    SECT stemp = sect;
    ULONG ulCount = 1;
    USHORT iseg = 0;
    FSINDEX ipfs = (FSINDEX) -1;
    FSINDEX ipfsOld = ipfs;
    FSOFFSET isect;
    CFatSect *pfs = NULL;

    msfAssert(sect != ENDOFCHAIN &&
              aMsg("Called Contig with ENDOFCHAIN start"));

    msfAssert((ulLength > 0) && aMsg("Bad length passed to Contig()"));
    aseg[iseg].sectStart = sect;
    aseg[iseg].cSect = 1;
    aseg[iseg].ulOffset = 0;
    ulLength--;

    while (TRUE)
    {
        msfAssert(sect != ENDOFCHAIN &&
                  aMsg("Contig found premature ENDOFCHAIN"));

        SectToPair(sect, &ipfs, &isect);

        if (ipfs != ipfsOld)
        {
            if (ipfsOld != (FSINDEX) -1)
            {
                _fv.ReleaseTable(ipfsOld);
            }
            msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));
            ipfsOld = ipfs;
        }

        if (pfs != NULL)
            sect = pfs->GetSect(isect);

        if (sect == ENDOFCHAIN)
        {
            if ((ulLength < 1) || !fWrite)
                break;

            //Allocate new sectors.
#if 0
            SECT sectNew;
            msfChk(GetFree(ulLength, &sectNew, GF_WRITE));
            msfChk(SetNext(stemp, sectNew));
            sect = sectNew;
#else
            //GetFreeContig will allocate new sectors and fill up
            //  our contig table.  After this call, the chain will
            //  be the proper length and the contig table will either
            //  contain the entire chain, or will be full.  Either
            //  way we can exit immediately.

            if (ipfs != (FSINDEX) - 1)
            {
                _fv.ReleaseTable(ipfs);
            }

            ULONG isegRet = 0;
            aseg[iseg].cSect = ulCount;
            msfChk(GetFreeContig(ulLength, aseg, iseg, &isegRet));
            if (isegRet == CSEG)
            {
                aseg[isegRet].ulOffset = 0;
                aseg[isegRet].cSect = 0;
                aseg[isegRet].sectStart = FREESECT;
            }
            else
            {
                aseg[isegRet + 1].sectStart = ENDOFCHAIN;
            }
            *pcSeg = isegRet + 1;
#if DBG == 1
            SSegment segtab[CSEG + 1];
            ULONG cSeg;
            Contig(segtab, FALSE, sectStart, ulLengthStart, &cSeg);
            msfAssert(cSeg == *pcSeg);
            for (USHORT i = 0; i < cSeg; i++)
            {
                msfAssert(segtab[i].sectStart == aseg[i].sectStart);
                msfAssert(segtab[i].ulOffset == aseg[i].ulOffset);
                msfAssert(segtab[i].cSect == aseg[i].cSect);
            }
#endif
            return S_OK;
#endif
        }

        if (sect != (stemp + 1))
        {
            if (ulLength < 1)
                break;

            aseg[iseg].cSect = ulCount;
            iseg++;
            aseg[iseg].ulOffset = aseg[iseg - 1].ulOffset + ulCount;
            aseg[iseg].sectStart = sect;
            ulCount = 1;
            stemp = sect;
        }
        else
        {
            ulCount++;
            stemp = sect;
        }
        if (ulLength > 0)
            ulLength--;

        if (iseg >= CSEG)
            break;
    }
    if (ipfs != (FSINDEX) -1)
    {
        _fv.ReleaseTable(ipfs);
    }

    if (iseg < CSEG)
    {
        aseg[iseg].cSect = ulCount;
        aseg[iseg + 1].sectStart = ENDOFCHAIN;
    }
    else
    {
        aseg[iseg].ulOffset = 0;
        aseg[iseg].cSect = 0;
        aseg[iseg].sectStart = FREESECT;
    }

    *pcSeg = iseg + 1;
    msfDebugOut((DEB_ITRACE,"Exiting Contig()\n"));

Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CFat::ReserveSects, public
//
//  Synopsis:	Make sure the fat has at least a given number of free
//              sectors in it.
//
//  Arguments:	[cSect] -- Number of sectors to reserve.
//
//  Returns:	Appropriate status code
//
//  History:	18-Sep-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::ReserveSects(ULONG cSect)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CFat::ReserveSects:%p()\n", this));

    //Make sure there are enough free sectors to hold the whole chain
    //  we're trying to allocate.
    if (_ulFreeSects == MAX_ULONG)
    {
        msfChk(CountFree(&_ulFreeSects));
    }
#if DBG == 1
    else
    {
        CheckFreeCount();
    }
#endif

    while (cSect > _ulFreeSects)
    {
#if DBG == 1 && !defined(USE_NOSCRATCH)
        ULONG ulFree = _ulFreeSects;
#endif
        msfChk(Resize(_cfsTable +
                      ((cSect - _ulFreeSects + _fv.GetSectTable() - 1) >>
                       _uFatShift)));
#if DBG == 1 && !defined(USE_NOSCRATCH)
        msfAssert(_ulFreeSects > ulFree &&
                  aMsg("Number of free sectors didn't increase after Resize."));
#endif

    }

    msfDebugOut((DEB_ITRACE, "Out CFat::ReserveSects\n"));
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetLength, public
//
//  Synposis:   Return the length of a fat chain.
//
//  Arguments:  [sect] -- Sector to begin count at.
//
//  Returns:    Length of the chain, in sectors
//
//  Algorithm:  Traverse the chain until ENDOFCHAIN is reached.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetLength(SECT sect, ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::GetLength(%lu)\n",sect));
    SCODE sc = S_OK;
    ULONG csect = 0;
    const ULONG csectMax = PairToSect(_cfsTable+1,0);

    while (sect != ENDOFCHAIN)
    {
        msfChk(GetNext(sect, &sect));
        csect++;
        if (csect > csectMax)            // infinite loop in the chain
            msfErr (Err, STG_E_DOCFILECORRUPT);
    }

    msfDebugOut((DEB_FAT,"FAT: GetLength returned %u\n",csect));
    *pulRet =  csect;
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::Init, public
//
//  Synposis:   Sets up a FAT, reading data from an existing stream
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Read size from first FAT in stream.
//              Resize array to necessary size.
//              Read in FAT sectors sequentially.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::Init(CMStream *pmsParent,
                           FSINDEX cFatSect,
                           BOOL fConvert)
{
    SCODE sc;

    msfDebugOut((DEB_FAT,"CFat::setup thinks the FAT is size %lu\n",cFatSect));

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    _uFatShift = pmsParent->GetSectorShift() - 2;
    _uFatMask = (pmsParent->GetSectorSize() >> 2) - 1;
    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);

    msfChk(_fv.Init(pmsParent, cFatSect));

    _cfsTable = cFatSect;

    USHORT cbSectorSize;
    cbSectorSize = pmsParent->GetSectorSize();
    InitRangeLocksSector();

    _ulFreeSects = MAX_ULONG;

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::InitConvert, public
//
//  Synopsis:   Init function used for conversion
//
//  Arguments:  [sectData] -- number of sectors used by file
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    28-May-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CFat::InitConvert(CMStream *pmsParent,
                                  SECT sectData)
{
    SCODE sc;
    msfDebugOut((DEB_FAT,"Doing conversion\n"));
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    msfAssert((sectData != 0) &&
            aMsg("Attempt to convert zero length file."));

    SECT sectMax = 0;
    FSINDEX csectFat = 0;
    FSINDEX csectLast;

    _uFatShift = pmsParent->GetSectorShift() - 2;
    _uFatMask = (pmsParent->GetSectorSize() >> 2) - 1;
    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);
    InitRangeLocksSector ();

    if (_sid == SIDFAT)
    {
        SECT sectTotal;

        //Since the fat needs to represent itself, we can't determine
        //   the actual number of sectors needed in one pass.  We
        //   therefore loop, factoring in the number of fat sectors
        //   at each iteration, until we reach a stable state.
        //
        //As an example, consider the case where each fat sector represents
        //   128 sectors and the file being converted is 128 sectors long.
        //   There will be no DIFat - therefore, we have 128 sectors needed
        //   on the first pass, which will require 1 fat sector to
        //   represent them.  On the second pass, we discover that we
        //   actually need 2 fat sectors, since we now have 129 total
        //   sectors to allocate space for.  The third pass will result
        //   in a stable state.
        do
        {
            csectLast = csectFat;
            sectTotal = sectData + pmsParent->GetHeader()->GetDifLength() +
                csectFat + 1;
            csectFat = (sectTotal + _fv.GetSectTable() - 1) >> _uFatShift;
        }
        while (csectLast != csectFat);
        sectMax = sectData + pmsParent->GetHeader()->GetDifLength();
    }
    else
    {
        //The minifat doesn't need to represent itself, so we can
        //  compute the number of sectors needed in one pass.
        sectMax = sectData;
        csectFat = (sectMax + _fv.GetSectTable() -1) >> _uFatShift;
    }

    msfChk(_fv.Init(pmsParent, csectFat));

    FSINDEX i;

    if (_sid == SIDMINIFAT)
    {
        SECT sectFirst;
        msfChk(pmsParent->GetFat()->Allocate(csectFat, &sectFirst));

        pmsParent->GetHeader()->SetMiniFatStart(sectFirst);

        pmsParent->GetHeader()->SetMiniFatLength(csectFat);
    }


    for (i = 0; i < csectFat; i++)
    {
        CFatSect *pfs;

        msfChk(_fv.GetTable(i, FB_NEW, &pfs));
        if (_sid == SIDFAT)
        {
            _fv.SetSect(i, sectMax + i);
            pmsParent->GetDIFat()->SetFatSect(i, sectMax + i);
        }
        else
        {
            msfAssert(_pfatNoScratch == NULL);
            SECT sect;
            msfChk(pmsParent->GetESect(_sid, i, &sect));
            _fv.SetSect(i, sect);
        }

        _fv.ReleaseTable(i);
    }


    _cfsTable = csectFat;

    if (_sid != SIDMINIFAT)
    {

        pmsParent->GetHeader()->SetFatLength(_cfsTable);

        SECT sect;

        if (sectData > 1)
        {
            for (sect = 0; sect < sectData - 2; sect++)
            {
                msfChk(SetNext(sect, sect + 1));
            }

            msfChk(SetNext(sectData - 2, ENDOFCHAIN));
            msfChk(SetNext(sectData - 1, 0));
        }
        else
        {
            //In the event that the file to be converted is less
            //  than one sector long, we don't need to create a
            //  real chain, just a single terminated sector.
            msfChk(SetNext(0, ENDOFCHAIN));
        }


        for (sect = sectData; sect < sectMax; sect++)
        {
            msfChk(SetNext(sect, DIFSECT));
        }

        for (USHORT i2 = 0; i2 < csectFat; i2++)
        {
            msfChk(SetNext(sectMax + i2, FATSECT));
        }

        //Set up directory chain.
        msfChk(SetNext(sectMax + i, ENDOFCHAIN));

        pmsParent->GetHeader()->SetDirStart(sectMax + i);

        _ulFreeSects = (_cfsTable << _uFatShift) - (sectMax + csectFat + 1);
    }
    else
    {
        for (SECT sect = 0; sect < sectData -1; sect++)
        {
            msfChk(SetNext(sect, sect + 1));
        }
        msfChk(SetNext(sectData - 1, ENDOFCHAIN));
        _ulFreeSects = (_cfsTable << _uFatShift) - sectData;
    }

    if (!pmsParent->IsScratch())
    {
        msfChk(pmsParent->SetSize());
    }

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFat::InitNew, public
//
//  Synposis:   Sets up a FAT for a newly created multi-strean
//
//  Effects:    Changes all _apfsTable entries, _cfsTable, and all
//              flags fields
//
//  Arguments:  [pmsparent] -- pointer to parent Mstream
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Set parent pointer.
//              Allocate 1 sector for FAT and 1 for Directory.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              17-Aug-91   PhilipLa    Added dirty bits optimization (Dump)
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::InitNew(CMStream *pmsParent)
{
    msfDebugOut((DEB_FAT,"In CFat::InitNew()\n"));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    _uFatShift = pmsParent->GetSectorShift() - 2;
    _uFatMask = (pmsParent->GetSectorSize() >> 2) - 1;
    _fv.InitCommon(1 << _uFatShift, 1 << _uFatShift);

    FSINDEX count;
    if (SIDMINIFAT == _sid)
        count = pmsParent->GetHeader()->GetMiniFatLength();
    else
        count = pmsParent->GetHeader()->GetFatLength();

    msfDebugOut((DEB_FAT,"Setting up Fat of size %lu\n",count));

    msfChk(_fv.Init(pmsParent, count));

    _cfsTable = count;

    InitRangeLocksSector();
    if (SIDFAT == _sid)
    {
        FSINDEX ipfs;
        FSOFFSET isect;
        CFatSect *pfs;

        SectToPair(pmsParent->GetHeader()->GetFatStart(), &ipfs, &isect);
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _fv.SetSect(ipfs, pmsParent->GetHeader()->GetFatStart());
        _fv.ReleaseTable(ipfs);

        msfChk(SetNext(pmsParent->GetHeader()->GetFatStart(), FATSECT));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (FAT) to ENDOFCHAIN\n",pmsParent->GetHeader()->GetFatStart()));

        msfChk(SetNext(pmsParent->GetHeader()->GetDirStart(), ENDOFCHAIN));
        msfDebugOut((DEB_ITRACE,"Set sector %lu (DIR) to ENDOFCHAIN\n",pmsParent->GetHeader()->GetDirStart()));
        _ulFreeSects = (count << _uFatShift) - 2;
    }
    else
    {
        _ulFreeSects = 0;
    }

    if (!pmsParent->IsScratch())
    {
        msfChk(pmsParent->SetSize());
    }

    msfDebugOut((DEB_FAT,"Exiting CFat::setupnew()\n"));

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::Resize, private
//
//  Synposis:   Resize FAT, both in memory and in the file
//
//  Effects:    Modifies _cfsTable, _apfsTable, and all flags fields
//
//  Arguments:  [ulSize] -- New size (in # of tables) for FAT
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Allocate new array of new size.
//              Copy over all old pointers.
//              Allocate new tables for any necessary.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              18-Aug-91   PhilipLa    Added dirty bits optimization
//
//  Notes:      This routine currently cannot reduce the size of a fat.
//
//---------------------------------------------------------------------------


SCODE CFat::Resize(ULONG ulSize)
{
    msfDebugOut((DEB_FAT,"In CFat::Resize(%lu)\n",ulSize));
    SCODE sc;

    if (ulSize == _cfsTable)
    {
        return S_OK;
    }

    ULONG csect = _cfsTable;

    msfAssert(ulSize > _cfsTable &&
            aMsg("Attempted to shrink Fat"));

    // 512byte sector docfiles are restricted to 2G for now
    if (_pmsParent->GetSectorShift() == SECTORSHIFT512 &&
        ulSize > _ipfsRangeLocks)
        return STG_E_DOCFILETOOLARGE;

    ULONG ipfs;
    SECT sectNew;

    CFat *pfat = _pmsParent->GetFat();


    if ((!_pmsParent->IsScratch()) && (_sid == SIDFAT))
    {

        //Make sure we have enough space for all of the sectors
        //  to be allocated.

        ULONG csectFat = ulSize - _cfsTable;
        ULONG csectPerDif = (1 << _uFatShift) - 1;
        ULONG csectDif = (csectFat + csectPerDif - 1) / csectPerDif;


        //Assuming all the free sectors are at the end of the file,
        //   we need a file csectNew sectors long to hold them.

        ULONG csectOld, csectNew;

        msfChk(FindMaxSect(&csectOld));

        // Every new sector added can conceivably cause a remap of
        //   another sector while in COW mode.
        csectNew = csectOld +
            ((csectFat + csectDif) * ((_sectLastUsed > 0) ? 2 : 1));

        ULARGE_INTEGER cbSize;

#ifdef LARGE_DOCFILE
        cbSize.QuadPart = ConvertSectOffset(
                csectNew,
                0,
                _pmsParent->GetSectorShift());
#else
        ULISet32(cbSize, ConvertSectOffset(
                csectNew,
                0,
                _pmsParent->GetSectorShift()));
#endif

#ifdef LARGE_DOCFILE
        if (cbSize.QuadPart > _pmsParent->GetParentSize())
#else
        if (ULIGetLow(cbSize) > _pmsParent->GetParentSize())
#endif
        {
            msfHChk(_pmsParent->GetILB()->SetSize(cbSize));
        }

        //If we are the fat, we have enough space in the file for
        //  ourselves at this point.
    }
    else if (_sid != SIDFAT)
    {
        if (_cfsTable == 0)
        {
            msfChk(pfat->Allocate(ulSize, &sectNew));
            _pmsParent->GetHeader()->SetMiniFatStart(sectNew);
        }
        else
        {
            sectNew = _pmsParent->GetHeader()->GetMiniFatStart();

            SECT sectLast;
            msfChk(pfat->GetESect(sectNew, ulSize - 1, &sectLast));

        }

        if (!_pmsParent->IsScratch())
        {
            msfChk(_pmsParent->SetSize());
        }


        msfChk(pfat->GetSect(sectNew, csect, &sectNew));

        //If we are the Minifat, we have enough space in the underlying
        //  file for ourselves at this point.
    }


    _fv.Resize(ulSize);


    for (ipfs = csect; ipfs < ulSize; ipfs++)
    {
        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NEW, &pfs));
        _cfsTable = ipfs + 1;


        if (_sid == SIDFAT)
        {
            if (ipfs == _ipfsRangeLocks)
            {
                CVectBits *pfb;
                pfs->SetSect(_isectRangeLocks, ENDOFCHAIN);

                pfb = _fv.GetBits(_ipfsRangeLocks);
                if (pfb != NULL && pfb->full == FALSE &&
                    _isectRangeLocks == pfb->firstfree)
                {
                    pfb->firstfree = _isectRangeLocks + 1;
                }

                _ulFreeSects--;
            }

            if (_sectNoSnapshotFree != ENDOFCHAIN)
            {
                SECT sectStart, sectEnd;

                _pmsParent->GetHeader()->SetFatLength(_cfsTable);

                msfChk(GetFree(1, &sectNew, GF_READONLY));
                _pmsParent->GetDIFat()->CacheUnmarkedSect(sectNew,
                                                          FATSECT,
                                                          ENDOFCHAIN);
                msfChk(_pmsParent->GetDIFat()->SetFatSect(ipfs, sectNew));

                msfAssert((_ulFreeSects != MAX_ULONG) &&
                          aMsg("Free count not set in no-snapshot"));

                //We don't need to look at anything less than
                //_sectNoSnapshotFree, since those are all by definition
                //not free.
                sectStart = max(PairToSect(ipfs, 0), _sectNoSnapshotFree);
                sectEnd = PairToSect(ipfs, 0) + _fv.GetSectTable();

                for (SECT sectChk = sectStart;
                     sectChk < sectEnd;
                     sectChk++)
                {
                    if (IsFree(sectChk) == S_OK)
                    {
                        _ulFreeSects++;
                    }
                }
                CheckFreeCount();
            }
            else
            {
                if (_pfatNoScratch != NULL)
                {
                    SECT sectStart, sectEnd;

                    msfChk(GetFree(1, &sectNew, GF_READONLY));
                    _pmsParent->GetDIFat()->CacheUnmarkedSect(sectNew,
                                                              FATSECT,
                                                              ENDOFCHAIN);
                    if (_ulFreeSects != MAX_ULONG)
                    {
                        sectStart = PairToSect(ipfs, 0);
                        sectEnd = sectStart + _fv.GetSectTable();

                        for (SECT sectChk = sectStart;
                             sectChk < sectEnd;
                             sectChk++)
                        {
                            if (IsFree(sectChk) == S_OK)
                            {
                                _ulFreeSects++;
                            }
                        }
                        CheckFreeCount();
                    }
                }
                else
                {
                    _ulFreeSects += (1 << _uFatShift);
                    msfChk(pfat->GetFree(1, &sectNew, GF_WRITE));
                    msfChk(pfat->SetNext(sectNew, FATSECT));
                }
                msfChk(_pmsParent->GetDIFat()->SetFatSect(ipfs, sectNew));
            }
        }

        msfAssert(sectNew != ENDOFCHAIN &&
                  aMsg("Bad sector returned for fatsect."));

        _fv.SetSect(ipfs, sectNew);
        _fv.ReleaseTable(ipfs);

        if (_sid == SIDMINIFAT)
        {
            _ulFreeSects += (1 << _uFatShift);
            msfChk(pfat->GetNext(sectNew, &sectNew));
        }
    }

    CheckFreeCount();

    msfDebugOut((DEB_FAT,"CFat::Resize() - all new objects allocated\n"));

    if (SIDMINIFAT == _sid)
    {
        _pmsParent->GetHeader()->SetMiniFatLength(_cfsTable);
    }
    else
        _pmsParent->GetHeader()->SetFatLength(_cfsTable);

    //This setsize should only shrink the file.
#if DBG == 1
    STATSTG stat;

    msfHChk(_pmsParent->GetILB()->Stat(&stat, STATFLAG_NONAME));
#endif

    if (!_pmsParent->IsScratch())
    {
        msfChk(_pmsParent->SetSize());
    }

    if ((_pfatNoScratch != NULL) && (_ulFreeSects == MAX_ULONG))
    {
        msfChk(CountFree(&_ulFreeSects));
    }

#if DBG == 1
    STATSTG statNew;

    msfHChk(_pmsParent->GetILB()->Stat(&statNew, STATFLAG_NONAME));

#ifdef LARGE_DOCFILE
    if (ulSize < _ipfsRangeLocks && !(_pmsParent->IsInCOW()))
        msfAssert(statNew.cbSize.QuadPart <= stat.cbSize.QuadPart);
#else
    if (!(_pmsParent->IsInCOW())
        msfAssert(ULIGetLow(statNew.cbSize) <= ULIGetLow(stat.cbSize));
#endif
#endif

    msfDebugOut((DEB_FAT,"Out CFat::Resize(%lu)\n",ulSize));

Err:
    msfAssert((_ulFreeSects != MAX_ULONG) &&
              aMsg("Free sect count not set after Resize()."));
    return sc;
}






//+-------------------------------------------------------------------------
//
//  Member:     CFat::Extend, private
//
//  Synposis:   Increase the size of an existing chain
//
//  Effects:    Modifies ulSize sectors within the fat.  Causes one or
//              more sector writes.
//
//  Arguments:  [sect] -- Sector ID of last sector in chain to be extended
//              [ulSize] -- Number of sectors to add to chain
//
//  Requires:   sect must be at the end of a chain.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Use calls to GetFree to allocate chain.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              17-Aug-91   PhilipLa    Added dirty bits opt (Dump)
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::Extend(SECT sect, ULONG ulSize)
{
    SCODE sc;

    msfDebugOut((DEB_FAT,"In CFat::Extend(%lu,%lu)\n",sect,ulSize));
    SECT sectTemp;

    msfChk(GetFree(ulSize, &sectTemp, GF_WRITE));

    //If this SetSize fails, clean up the new space and don't do anything
    //  to the original chain.
    if (!_pmsParent->IsScratch())
    {
        msfChkTo(EH_OOD, _pmsParent->SetSize());
    }

    //If this SetNext fail calls, we're in trouble.  Return the error but
    //  don't attempt to cleanup.
    msfChk(SetNext(sect, sectTemp));

    msfDebugOut((DEB_FAT,"Out CFat::Extend()\n"));

Err:
    return sc;
EH_OOD:
    SetChainLength(sectTemp, 0);
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetNext, public
//
//  Synposis:   Returns the next sector in a chain, given a sector
//
//  Arguments:  [sect] -- Sector ID of any sector in a chain.
//
//  Returns:    Sector ID of next sector in chain, ENDOFCHAIN if at end
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetNext(const SECT sect, SECT * psRet)
{
    SCODE sc;

    FSINDEX ipfs;
    FSOFFSET isect;

    msfAssert(sect <= MAXREGSECT &&
            aMsg("Called GetNext() on invalid sector"));

    SectToPair(sect, &ipfs, &isect);
    CFatSect *pfs;
    msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

    *psRet = pfs->GetSect(isect);

    _fv.ReleaseTable(ipfs);

    if (sect == *psRet)
    {
        msfAssert(sect != *psRet &&
                  aMsg("Detected loop in fat chain."));
        return STG_E_ABNORMALAPIEXIT;
    }
    return S_OK;

Err:
    return sc;
}




//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetNext, private
//
//  Synposis:   Set the next sector in a chain
//
//  Effects:    Modifies a single entry within the fat.
//
//  Arguments:  [sectFirst] -- Sector ID of first sector
//              [sectNext] -- Sector ID of next sector
//
//  Returns:    void
//
//  History:    18-Jul-91   PhilipLa    Created.
//              17-Aug-91   PhilipLa    Added dirty bits optimization
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::SetNext(SECT sectFirst, SECT sectNext)
{
    FSINDEX ipfs;
    FSOFFSET isect;
    SCODE sc;

    msfAssert((!_pmsParent->IsShadow()) &&
            aMsg("Modifying shadow fat."));

    //  creating infinite loops is a no-no
    msfAssert(sectFirst != sectNext &&
            aMsg("Attempted to create loop in Fat chain"));
    msfAssert(sectFirst <= MAXREGSECT &&
            aMsg("Called SetNext on invalid sector"));

    SectToPair(sectFirst, &ipfs, &isect);

    CFatSect *pfs;
    SECT sectCurrent;

    if (ipfs >= _cfsTable)
    {
        msfChk(Resize(ipfs + 1));
    }

    msfAssert(ipfs <= _cfsTable);

    msfChk(_fv.GetTable(ipfs, FB_DIRTY, &pfs));

    sectCurrent = pfs->GetSect(isect);

    pfs->SetSect(isect,sectNext);

    _fv.ReleaseTable(ipfs);

    if (sectNext == FREESECT)
    {
        CVectBits *pfb;
        pfb = _fv.GetBits(ipfs);

        if ((pfb != NULL) &&
            ((pfb->full == TRUE) || (isect < pfb->firstfree)))
        {
            pfb->full = FALSE;
            pfb->firstfree = isect;
        }

        if (sectFirst == _sectMax - 1)
        {
            _sectMax = ENDOFCHAIN;
        }
        if (sectFirst < _sectFirstFree)
        {
            _sectFirstFree = sectFirst;
        }

        if (_ulFreeSects != MAX_ULONG)
        {
            SECT sectOld = FREESECT;

            msfChk(IsFree(sectFirst));

            if (sc != S_FALSE)
            {
                _ulFreeSects++;
            }
            sc = S_OK;  // Don't return S_FALSE.
        }
    }
    else if (_pfatNoScratch != NULL)
    {
        //We need to update the noscratch fat as well.
        msfChk(_pfatNoScratch->SetNext(sectFirst, sectNext));
    }
    else if (sectFirst >= _sectMax)
    {
        _sectMax = sectFirst + 1;
#if DBG == 1
        SECT sectLast;
        msfChk(FindLast(&sectLast));
        msfAssert(((_sectMax == sectLast) || (_sectMax == _sectLastUsed)) &&
                aMsg("_sectMax doesn't match actual last sector"));
#endif
    }

    //If we're the no-scratch fat, then we may be marking a free sector
    //as allocated due to the real fat allocating it.  In this case, we
    //need to update our free sector count.
    if ((_sid == SIDMINIFAT) && (_pmsParent->IsScratch()) &&
        (sectCurrent == FREESECT) && (sectNext != FREESECT) &&
        (_ulFreeSects != MAX_ULONG))
    {
        _ulFreeSects--;
    }

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::CountFree, private
//
//  Synposis:   Count and return the number of free sectors in the Fat
//
//  Arguments:  void.
//
//  Returns:    void.
//
//  Algorithm:  Do a linear search of the Fat, counting free sectors.
//              If a FatSect has its full bit set, it is not necessary
//              to search that FatSect.
//
//  History:    11-Sep-91   PhilipLa    Created.
//
//  Notes:  This includes all the FREESECT's in the tail of the last FAT
//          block (past the last allocated sector) as free.  So it is possible
//          That CountFree() could be greater than FindLast()!
//---------------------------------------------------------------------------


SCODE CFat::CountFree(ULONG * pulRet)
{
    msfDebugOut((DEB_FAT,"In CFat::CountFree()\n"));
    SCODE sc = S_OK;

    FSINDEX ipfs;
    ULONG csectFree=0;
    FSOFFSET isectStart;
    FSINDEX ipfsStart;

    SectToPair(_sectFirstFree, &ipfsStart, &isectStart);

    for (ipfs = ipfsStart; ipfs < _cfsTable; ipfs++)
    {
        CVectBits *pfb = _fv.GetBits(ipfs);

        if ((pfb == NULL) || (!pfb->full))
        {
            msfDebugOut((DEB_FAT,"Checking table %lu\n",ipfs));
            CFatSect *pfs;
            msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

            if (pfb != NULL)
            {
                isectStart = pfb->firstfree;
            }

            FSOFFSET isect;
            for (isect = isectStart; isect < _fv.GetSectTable(); isect++)
            {
                SECT sectCurrent = pfs->GetSect(isect);
                SECT sectNew = PairToSect(ipfs, isect);

                if (sectCurrent == FREESECT)
                {
                    msfChkTo(Err_Rel, IsFree(sectNew));

                    if (sc == S_FALSE)
                    {
                        sectCurrent = ENDOFCHAIN;
                    }
                }


                if (sectCurrent == FREESECT)
                {
                    csectFree++;
                }
            }
            _fv.ReleaseTable(ipfs);
        }
        isectStart = 0;
    }
    msfDebugOut((DEB_FAT,"Countfree returned %lu\n",csectFree));
    *pulRet = csectFree;

Err:
    return sc;

Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::CountSectType, private
//
//  Synposis:   Count and return the number of sectors of a given
//              type in the Fat
//
//  Arguments:  [out]   count       The returned count of sectors.
//              [in]    sectStart   The first sector of the range to examine.
//              [in]    sectEnd     The last sector of the range to examine.
//              [in]    sectType    The type of sector looked for.
//
//  Returns:    SCODE.
//
//  Algorithm:  Do a linear search of the Fat, counting sectors of the given
//              type in the given range.
//
//  History:    18-Feb-97   BChapman    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::CountSectType(
        ULONG * pulRet,
        SECT sectStart,
        SECT sectEnd,
        SECT sectType)
{
    msfDebugOut((DEB_FAT,"In CFat::CountSect(0x%x, 0x%x, 0x%x)\n",
                                        sectStart, sectEnd, sectType));
    SCODE sc = S_OK;

    FSINDEX ipfs;
    ULONG csectType=0;
    FSOFFSET isectStart;        // starting index into the current FAT
    FSOFFSET isectEnd;          // ending   index into the current FAT
    FSOFFSET isectFirstStart;   // starting index into the first FAT
    FSOFFSET isectLastEnd;      // ending   index into the last FAT
    FSINDEX ipfsStart;          // Starting FAT block number
    FSINDEX ipfsEnd;            // Ending FAT block number

    SectToPair(sectStart, &ipfsStart, &isectFirstStart);
    SectToPair(sectEnd, &ipfsEnd, &isectLastEnd);

    for (ipfs = ipfsStart; ipfs <= ipfsEnd; ipfs++)
    {
        //
        // If we are counting FREESECTS and this FAT blocks is
        // known to be full then just skip it.
        //
        if(FREESECT == sectType)
        {
            CVectBits *pfb = _fv.GetBits(ipfs);

            if ((pfb != NULL) && pfb->full)
                continue;
        }

        msfDebugOut((DEB_FAT,"Checking table %lu\n",ipfs));
        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

        //
        // If this is the first FAT block in the given range use the given
        // starting offset-index.  Otherwise start at the beginning.
        //
        if(ipfs == ipfsStart)
            isectStart = isectFirstStart;
        else
            isectStart = 0;

        //
        // If this is the last FAT block in the given range use the given
        // ending fooset-index, otherwise scan to the end of the block.
        //
        if(ipfs == ipfsEnd)
            isectEnd = isectLastEnd;
        else
            isectEnd = _fv.GetSectTable();

        FSOFFSET isect;
        for (isect = isectStart; isect < isectEnd; isect++)
        {
            SECT sectCurrent = pfs->GetSect(isect);
            SECT sectNew = PairToSect(ipfs, isect);

            if (sectCurrent == sectType)
            {
                msfChkTo(Err_Rel, IsSectType(sectNew, sectType));
                if (sc != S_FALSE)
                {
                    csectType++;
                }
            }
        }
        _fv.ReleaseTable(ipfs);
        isectStart = 0;
    }
    msfDebugOut((DEB_FAT,"CountSectType returned %lu\n",csectType));
    *pulRet = csectType;

Err:
    return sc;

Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetSect, public
//
//  Synposis:   Return the nth sector in a chain
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [uNum] -- indicator of which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK.
//
//  Algorithm:  Linearly traverse chain until numth sector
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetSect(SECT sect, ULONG ulNum, SECT * psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetSect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    if (ulNum == 0)
    {
        msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));
    }
    else if ((SIDFAT == _sid) &&
             (_pmsParent->GetHeader()->GetFatStart() == sect))
    {
        msfChk(_pmsParent->GetDIFat()->GetFatSect(ulNum, &sect));
    }
    else for (ULONG i = 0; i < ulNum; i++)
    {
        msfChk(GetNext(sect, &sect));
        if (sect > MAXREGSECT)
        {
            //The stream isn't long enough, so stop.
            msfAssert(sect == ENDOFCHAIN &&
                    aMsg("Found invalid sector in fat chain."));
            break;
        }
    }

    *psectReturn = sect;
    msfDebugOut((DEB_FAT,"Out CFat::GetSect()=>%lu\n",sect));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFat::GetESect
//
//  Synposis:   Return the nth sector in a chain, extending the chain
//              if necessary.
//
//  Effects:    Modifies fat (via Extend) if necessary
//
//  Arguments:  [sect] -- Sector ID of beginning of chain
//              [ulNum] -- Indicates which sector is to be returned
//              [psectReturn] -- Pointer to storage for return value
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Linearly search chain until numth sector is found.  If
//              the chain terminates early, extend it as necessary.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::GetESect(SECT sect, ULONG ulNum, SECT *psectReturn)
{
    msfDebugOut((DEB_FAT,"In CFat::GetESect(%lu,%lu)\n",sect,ulNum));

    SCODE sc = S_OK;

    ULONG i = 0;
    while (i < ulNum)
    {
        SECT temp;
        msfChk(GetNext(sect, &temp));

        msfAssert(temp != FREESECT &&
                aMsg("FREESECT found in chain."));

        if (temp == ENDOFCHAIN)
        {

            //The stream isn't long enough, so extend it somehow.
            ULONG need = ulNum - i;

            msfAssert((SIDMINIFAT == _sid ||
                    sect != _pmsParent->GetHeader()->GetFatStart()) &&
                    aMsg("Called GetESect on Fat chain"));
            msfChk(Extend(sect,need));
        }
        else
        {
            sect = temp;
            i++;
        }
    }

    msfDebugOut((DEB_FAT,"Exiting GetESect with result %lu\n",sect));
    *psectReturn = sect;

Err:
    return sc;
}



#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Member:     CFat::checksanity, private
//
//  Synposis:   Print out a FAT chain.  Used for debugging only.
//
//  Arguments:  [sectStart] -- sector to begin run at.
//
//  Returns:    void
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CFat::checksanity(SECT sectStart)
{
    msfDebugOut((DEB_FAT,"Sanity Check (%i)\n\t",sectStart));
    SCODE sc = S_OK;

    while (sectStart != ENDOFCHAIN)
    {
        msfDebugOut((DEB_FAT | DEB_NOCOMPNAME,"%lu, ",sectStart));
        msfChk(GetNext(sectStart, &sectStart));
    }
    msfDebugOut((DEB_FAT | DEB_NOCOMPNAME,"ENDOFCHAIN\n"));
Err:
    return sc;
}

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CFat::SetChainLength, private
//
//  Synposis:   Set the length of a fat chain.  This is used to reduce
//              the length of the chain only.  To extend a chain, use
//              Extend or GetESect
//
//  Effects:    Modifies the fat
//
//  Arguments:  [sectStart] -- Sector to begin at (head of chain)
//              [uLength] -- New length for chain
//
//  Returns:    void.
//
//  Algorithm:  Traverse chain until uLength is reached or the chain
//              terminates.  If it terminates prematurely, return with
//              no other action.  Otherwise, deallocate all remaining
//              sectors in the chain.
//
//  History:    14-Aug-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CFat::SetChainLength(SECT sectStart, ULONG ulLength)
{
    msfDebugOut((DEB_FAT,"In CFat::SetChainLength(%lu,%lu)\n",sectStart,ulLength));
    SCODE sc;

    if (sectStart == ENDOFCHAIN) return S_OK;

    for (ULONG ui = 1; ui < ulLength; ui++)
    {
        msfChk(GetNext(sectStart, &sectStart));
        if (sectStart == ENDOFCHAIN) return S_OK;
    }

    msfAssert(sectStart != ENDOFCHAIN &&
            aMsg("Called SetChainLength is ENDOFCHAIN start"));

    SECT sectEnd;
    sectEnd = sectStart;

    msfChk(GetNext(sectStart, &sectStart));

    if (ulLength != 0)
    {
        msfChk(SetNext(sectEnd, ENDOFCHAIN));
    }
    else
    {
        msfChk(SetNext(sectEnd, FREESECT));
    }

    while (sectStart != ENDOFCHAIN)
    {
        SECT sectTemp;
        msfChk(GetNext(sectStart, &sectTemp));
        msfChk(SetNext(sectStart, FREESECT));
        sectStart = sectTemp;
    }

    msfDebugOut((DEB_FAT,"Out CFat::SetChainLength()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::DirtyAll, public
//
//  Synopsis:   Dirty every sector in the FAT.  This had the effect in
//              consolidation of copying the whole FAT down lower in the
//              file.
//
//  Returns:    SCODE success or failure code.
//
//  Algorithm:  Load each FAT sector into the cache "for-writing".
//
//  History:    24-Feb-1997   BChapman    Created.
//
//  Notes:      For use
//
//--------------------------------------------------------------------------


SCODE CFat::DirtyAll()
{
    SCODE sc = S_OK;
    CFatSect *pfs;
    FSINDEX i;

    for(i=0; i<_cfsTable; i++)
    {
        msfChk(_fv.GetTable(i, FB_DIRTY, &pfs));
        _fv.ReleaseTable(i);
    }
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindLast, private
//
//  Synopsis:   Find last used sector in a fat
//
//  Returns:    Location of last used sector
//
//  Algorithm:  Perform a backward linear search until a non-free
//              sector is found.
//
//  History:    18-Dec-91   PhilipLa    Created.
//
//  Notes:      Used for shadow fats only.
//
//--------------------------------------------------------------------------


SCODE CFat::FindLast(SECT * psectRet)
{
    SCODE sc = S_OK;
    FSINDEX ipfs = _cfsTable;
    SECT sect = 0;

    while (ipfs > 0)
    {
        ipfs--;

        FSOFFSET isect = _fv.GetSectTable();

        CFatSect *pfs;
        msfChk(_fv.GetTable(ipfs, FB_NONE, &pfs));

        while (isect > 0)
        {
            isect--;

            SECT sectCurrent = pfs->GetSect(isect);
            SECT sectNew = PairToSect(ipfs, isect);
            if (sectCurrent == FREESECT)
            {
                msfChkTo(Err_Rel, IsFree(sectNew));
                if (sc == S_FALSE)
                    sectCurrent = ENDOFCHAIN;
            }

            if (ipfs == _ipfsRangeLocks && isect == _isectRangeLocks)
                sectCurrent = FREESECT;

            if (sectCurrent != FREESECT)
            {
                msfDebugOut((DEB_FAT,"FindLast returns %lu\n",PairToSect(ipfs,isect)));
                sect = sectNew + 1;
                break;
            }
        }

        _fv.ReleaseTable(ipfs);
        if (sect != 0)
            break;
    }

    //We need additional checks here since in some cases there aren't
    //enough pages in the fat to hold _sectNoSnapshot (or _sectNoSnapshotFree).
    //Returning too small a value could result in SetSizing the file to too
    //small a size, which is data loss.
    if (sect < _sectNoSnapshot)
    {
        sect = _sectNoSnapshot;
    }
    if ((_sectNoSnapshotFree != ENDOFCHAIN) && (sect < _sectNoSnapshotFree))
    {
        sect = _sectNoSnapshotFree;
    }

    *psectRet = sect;
Err:
    return sc;
Err_Rel:
    _fv.ReleaseTable(ipfs);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CFat::Remap, public
//
//  Synopsis:   Remap a portion of a chain for copy-on-write
//
//  Effects:
//
//  Arguments:  [sectStart] -- Sector marking the first sector in the chain
//              [oStart] -- Offset in sectors at which to begin the remap
//              [ulRunLength] -- Number of sectors to remap
//              [psectOldStart] -- Returns old location of first remapped
//                                      sector.
//              [psectNewStart] -- Returns new location of first sector
//              [psectOldEnd] -- Returns old location of last sector
//              [psectNewEnd] -- Returns new location of last sector
//
//  Returns:    Appropriate status code.
//              S_FALSE if everything succeeded but no sectors were
//                  remapped.
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CFat::Remap(
        SECT sectStart,
        ULONG oStart,
        ULONG ulRunLength,
        SECT *psectOldStart,
        SECT *psectNewStart,
        SECT *psectOldEnd,
        SECT *psectNewEnd)
{
    msfDebugOut((DEB_FAT,"In CFat::Remap(%lu, %lu, %lu)\n",sectStart,oStart,ulRunLength));

    msfAssert(SIDMINIFAT != _sid &&
            aMsg("Called Remap on Minifat"));
    msfAssert(ulRunLength != 0 &&
            aMsg("Called Remap with 0 runlength"));
    msfAssert(!_pmsParent->IsScratch() &&
            aMsg("Called Remap on scratch."));

    BOOL fRemapped = FALSE;
    SCODE sc = S_OK;
    SECT sectPrev = ENDOFCHAIN;
    SECT sect;
    ULONG uCount = 0;


    *psectNewStart = ENDOFCHAIN;
    *psectNewEnd = ENDOFCHAIN;
#if DBG == 1
    *psectOldStart = ENDOFCHAIN;
    *psectOldEnd = ENDOFCHAIN;
#endif

    if (oStart == 0)
    {
        sectPrev = ENDOFCHAIN;
        sect = sectStart;
    }
    else
    {
        msfChk(GetESect(sectStart, oStart - 1, &sectPrev));
        msfChk(GetNext(sectPrev, &sect));
    }

    *psectOldStart = sect;

    while ((uCount < ulRunLength) && (sect != ENDOFCHAIN))
    {
        if (uCount == ulRunLength - 1)
        {
            *psectOldEnd = sect;
        }

        msfChk(QueryRemapped(sect));
        if (sc == S_FALSE)
        {
            SECT sectNew;

            msfChk(GetFree(1, &sectNew, GF_WRITE));

            msfDebugOut((DEB_ITRACE,"Remapping sector %lu to %lu\n",sect,sectNew));
            if (sectPrev != ENDOFCHAIN)
            {
                msfChk(SetNext(sectPrev, sectNew));

                if (_pfatNoScratch != NULL)
                {
                    msfChk(_pfatNoScratch->SetNext(sectPrev, sectNew));
                }
            }

            msfAssert((sect != ENDOFCHAIN) &&
                    aMsg("Remap precondition failed."));

            SECT sectTemp;
            msfChk(GetNext(sect, &sectTemp));
            msfChk(SetNext(sectNew, sectTemp));

            if (_pfatNoScratch != NULL)
            {
                msfChk(_pfatNoScratch->SetNext(sectNew, sectTemp));
            }

            msfChk(SetNext(sect, FREESECT));


            fRemapped = TRUE;

            if (uCount == 0)
            {
                *psectNewStart = sectNew;
            }

            if (uCount == ulRunLength - 1)
            {
                *psectNewEnd = sectNew;
            }

            sect = sectNew;
        }
        sectPrev = sect;
        msfChk(GetNext(sect, &sect));
        uCount++;
    }

    if ((*psectNewStart != ENDOFCHAIN) && (oStart == 0))
    {
        if (sectStart == _pmsParent->GetHeader()->GetDirStart())
            _pmsParent->GetHeader()->SetDirStart(*psectNewStart);

        if (sectStart == _pmsParent->GetHeader()->GetMiniFatStart())
            _pmsParent->GetHeader()->SetMiniFatStart(*psectNewStart);
    }

    msfDebugOut((DEB_FAT,"Out CFat::Remap()=>%lu\n",*psectNewStart));

Err:
    if ((sc == S_OK) && !fRemapped)
        sc = S_FALSE;
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CFat::FindMaxSect, private
//
//  Synopsis:   Return last used sector in current Fat.
//
//  Arguments:  None.
//
//  Returns:    Last used sector in current Fat
//
//  History:    15-Dec-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CFat::FindMaxSect(SECT *psectRet)
{
    SCODE sc = S_OK;

    if (_pfatNoScratch != NULL)
    {
        return _pfatNoScratch->FindMaxSect(psectRet);
    }

    if (_sectMax == ENDOFCHAIN)
    {
        msfChk(FindLast(psectRet));
    }
    else
    {
#if DBG == 1
        SECT sectLast;
        msfChk(FindLast(&sectLast));
        msfAssert(((_sectMax == sectLast) || (_sectMax == _sectLastUsed)) &&
                  aMsg("_sectMax doesn't match actual last sector"));
#endif
        *psectRet = _sectMax;
    }

    if (*psectRet < _sectLastUsed)
    {
        *psectRet = _sectLastUsed;
    }
Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CFat::InitScratch, public
//
//  Synopsis:	Initialize the fat based on another fat.  This is used
//              for NOSCRATCH mode.  The fats may have different sector
//              sizes.
//
//  Arguments:	[pfat] -- Pointer to fat to copy.
//              [fNew] -- TRUE if this is being called on an empty fat.
//
//  Returns:	Appropriate status code
//
//  History:	20-Mar-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::InitScratch(CFat *pfat, BOOL fNew)
{
    SCODE sc;

    msfAssert((_sid == SIDMINIFAT) && (_pmsParent->IsScratch()) &&
              aMsg("Called InitScratch on the wrong thing."));

    USHORT cbSectorOriginal = pfat->_pmsParent->GetSectorSize();

    USHORT cSectPerRealSect = _pmsParent->GetSectorSize() /
        cbSectorOriginal;

    //This routine copies the fat from the multistream passed in into
    //  the _minifat_ of the current multistream.

    ULONG cfatOriginal = pfat->_cfsTable;

    //Our minifat must be large enough to hold all of the necessary
    //sectors.  Set the size appropriately.
    ULONG cMiniFatSize = (cfatOriginal + cSectPerRealSect - 1) /
        cSectPerRealSect;

    msfAssert(((!fNew) || (_cfsTable == 0)) &&
              aMsg("fNew TRUE when fat non-empty."));

    msfAssert(((fNew) || (_pfatReal == pfat)) &&
              aMsg("Fat pointer changed between calls to InitScratch"));

    _pfatReal = P_TO_BP(CBasedFatPtr, pfat);

    if (cMiniFatSize > _cfsTable)
    {
        msfChk(Resize(cMiniFatSize));
    }

    ULONG ifs;
    for (ifs = 0; ifs < cfatOriginal; ifs++)
    {
        CFatSect *pfs;
        CFatSect *pfsCurrent;

        //Get the sector from the original fat

        msfChk(pfat->_fv.GetTable(ifs, FB_NONE, &pfs));
        msfAssert(pfs != NULL);

        //Write the sector into the appropriate place in this fat.
        ULONG ifsCurrent;
        ifsCurrent = ifs / cSectPerRealSect;

        OFFSET off;
        off = (USHORT)((ifs % cSectPerRealSect) * cbSectorOriginal);

        msfChk(_fv.GetTable(ifsCurrent, FB_DIRTY, &pfsCurrent));

        if (fNew)
        {
            memcpy((BYTE *)pfsCurrent + off, pfs, cbSectorOriginal);
        }
        else
        {
            //Merge the table into the current one.
            for (USHORT i = 0; i < cbSectorOriginal / sizeof(SECT); i++)
            {
                SECT sectCurrent;
                OFFSET offCurrent;
                offCurrent = i + (off / sizeof(SECT));

                sectCurrent = pfsCurrent->GetSect(offCurrent);

                if (sectCurrent != STREAMSECT)
                {
                    pfsCurrent->SetSect(offCurrent, pfs->GetSect(i));
                }
            }
        }

        _fv.ReleaseTable(ifsCurrent);
        pfat->_fv.ReleaseTable(ifs);
    }

    msfAssert((pfat->_cUnmarkedSects == 0) &&
              aMsg("Fat being copied has changes in DIF"));

    _fv.ResetBits();
    _ulFreeSects = MAX_ULONG;
    _sectFirstFree = 0;
    _sectLastUsed = 0;
    _sectMax = ENDOFCHAIN;
Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CFat::ResizeNoSnapshot, public
//
//  Synopsis:	Resize the fat to handle a no-snapshot commit.  In
//              no-snapshot mode it is possible that another commit has
//              grown the file to the point where it cannot be contained in
//              the existing fat in this open, so we need to grow it before
//              we can continue with anything else.
//
//  Arguments:	None.
//
//  Returns:	Appropriate SCODE.
//
//  History:	19-Jun-96	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CFat::ResizeNoSnapshot(void)
{
    SCODE sc = S_OK;
    FSINDEX ipfs;
    FSOFFSET isect;

    //If we need to grow the fat to handle the previous commits (which is
    //  possible if other opens are doing a lot of writing), we do it here,
    //  since we know for certain that the first available sector is at
    //  _sectNoSnapshot.
    SectToPair(_sectNoSnapshot, &ipfs, &isect);
    if (ipfs >= _cfsTable)
    {
        //We know we have no free sectors, so we can set this here and
        //  Resize will end up with the correct value.
        _ulFreeSects = 0;

        //This Resize will also cause a resize in the DIFat if necessary.
        sc = Resize(ipfs + 1);
        CheckFreeCount();
    }
    return sc;
}

#if DBG == 1
void CFat::CheckFreeCount(void)
{
    SCODE sc;   // check is disabled if fat grows above >1G
    if ((_ulFreeSects != MAX_ULONG) && (_cfsTable < _ipfsRangeLocks/2))
    {
        ULONG ulFree;
        msfChk(CountFree(&ulFree));
        if (ulFree != _ulFreeSects)
        {
            msfDebugOut((DEB_ERROR,
                         "Free count mismatch.  Cached: %lu, Real: %lu."
                         "   Difference: %li\n",
                         _ulFreeSects,
                         ulFree,
                         ulFree - _ulFreeSects));
        }
        msfAssert((ulFree == _ulFreeSects) &&
                      aMsg("Free count doesn't match cached value."));
    }
Err:
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\dl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       dl.cxx
//
//  Contents:   Delta list code for streams
//
//  Classes:    Defined in dl.hxx
//
//  History:    28-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <mread.hxx>
#include <dl.hxx>
#include <tstream.hxx>

#ifndef _MAC
inline
#endif
void *SDeltaBlock::operator new(size_t size, IMalloc * const pMalloc)
{
    return pMalloc->Alloc(size);
}

//+-------------------------------------------------------------------------
//
//  Method:     SDeltaBlock::SDeltaBlock, public
//
//  Synopsis:   SDeltaBlock constructor
//
//  History:    10-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


#ifndef _MAC
inline
#endif
SDeltaBlock::SDeltaBlock()
{
    for (USHORT i = 0; i < CSECTPERBLOCK; i++)
    {
        _sect[i] = ENDOFCHAIN;
    }
    for (i = 0; i < CSECTPERBLOCK / CBITPERUSHORT; i++)
    {
        _fOwn[i] = 0;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::CDeltaList, public
//
//  Synopsis:   CDeltaList constructor
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


CDeltaList::CDeltaList(CMStream *pms, CMStream *pmsScratch)
{
    _pms = P_TO_BP(CBasedMStreamPtr, pms);
    _pmsScratch = P_TO_BP(CBasedMStreamPtr, pmsScratch);
    _apdb = NULL;
    _sectStart = ENDOFCHAIN;
    _ulSize = 0;
    _ptsParent = NULL;
}


inline CBasedDeltaBlockPtr * CDeltaList::GetNewDeltaArray(ULONG ulSize)
{
//    return NULL;
    msfAssert(ulSize > 0);
    if (ulSize > (_HEAP_MAXREQ / sizeof(SDeltaBlock *)))
    {
        return NULL;
    }
    return (CBasedDeltaBlockPtr *) _pmsScratch->GetMalloc()->
        Alloc(sizeof(SDeltaBlock *) * ulSize);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::Init, public
//
//  Synopsis:   Init function for CDeltaList
//
//  Arguments:  [ulSize] -- Size of delta list to be initialized
//              [ptsParent] -- Pointer to transacted stream that contains
//                      this delta list.
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE CDeltaList::Init(ULONGLONG ulSize, CTransactedStream *ptsParent)
#else
SCODE CDeltaList::Init(ULONG ulSize, CTransactedStream *ptsParent)
#endif
{
    SCODE sc = S_OK;
    ULONG ulNewSize;
    CBasedDeltaBlockPtr *apdbTemp = NULL;

    msfAssert(IsEmpty() &&
            aMsg("Init called on non-empty delta list."));

    ULONG cbSector = GetDataSectorSize();

    ULONG csect = (ULONG)((ulSize + cbSector - 1) / cbSector);


    ulNewSize = (csect + CSECTPERBLOCK - 1) / CSECTPERBLOCK;

    _ulSize = ulNewSize;
    _ptsParent = P_TO_BP(CBasedTransactedStreamPtr, ptsParent);

    CDeltaList *pdlParent = NULL;

    if (_ptsParent->GetBase() != NULL)
    {
        pdlParent = _ptsParent->GetBase()->GetDeltaList();
    }

    msfAssert(_ulSize > 0);
    msfAssert(IsEmpty());

    //  if the parent is InStream, we stay in low-memory mode
    if ((pdlParent == NULL) || (pdlParent->IsInMemory()))
    {
        //Try to copy it down.  If it doesn't work, put it in a stream
        //instead.
        msfMem(apdbTemp = GetNewDeltaArray(_ulSize));

        MAXINDEXTYPE i;
        for (i = 0; i < _ulSize; i++)
        {
            apdbTemp[i] = NULL;
        }

        if (pdlParent != NULL)
        {
            for (i = 0; i < _ulSize; i++)
            {
                if ((i < pdlParent->_ulSize) && (pdlParent->_apdb[i] != NULL))
                {
                    SDeltaBlock *pdbTemp;
                    msfMemTo(Err_Alloc, pdbTemp =
                             new(_pmsScratch->GetMalloc()) SDeltaBlock);

                    apdbTemp[i] = P_TO_BP(CBasedDeltaBlockPtr, pdbTemp);

                    for (USHORT j = 0; j < CSECTPERBLOCK; j++)
                    {
                        pdbTemp->_sect[j] = pdlParent->_apdb[i]->_sect[j];
                    }
                }
            }
        }
        _apdb = P_TO_BP(CBasedDeltaBlockPtrPtr, apdbTemp);

        return S_OK;

 Err_Alloc:
        for (i = 0; i < _ulSize; i++)
        {
            _pmsScratch->GetMalloc()->Free(BP_TO_P(SDeltaBlock *, apdbTemp[i]));
            apdbTemp[i] = NULL;
        }
    }


 Err:
    _apdb = NULL;

    //We'll end up here if we get an error allocating memory for
    //  the InMemory case above or if the parent is InStream.  We
    //  must allocate a new stream and copy down the parent.
    if (pdlParent == NULL)
    {
        for (ULONG i = 0; i < _ulSize; i++)
        {
            msfChkTo(Err_Init, InitStreamBlock(i));
        }
    }
    else
    {
        //Copy the parent into a stream representation.

        for (ULONG i = 0;
             i < min(_ulSize, pdlParent->_ulSize) * CSECTPERBLOCK;
             i++)
        {
            SECT sectOld;
            msfChkTo(Err_Init, pdlParent->GetMap(i, DL_READ, &sectOld));
            msfChkTo(Err_Init, WriteMap(&_sectStart, i, sectOld));
        }
        for (i = pdlParent->_ulSize; i < _ulSize; i++)
        {
            msfChkTo(Err_Init, InitStreamBlock(i));
        }
    }


 Err_Init:
    return sc;

}


//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::InitResize, public
//
//  Synopsis:   Resize initializer for deltalists
//
//  Arguments:  [ulSize] -- Size of new deltalist
//              [pdlOld] -- Pointer to deltalist to be resized
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


#ifdef LARGE_STREAMS
SCODE CDeltaList::InitResize(ULONGLONG ulSize)
#else
SCODE CDeltaList::InitResize(ULONG ulSize)
#endif
{
    msfDebugOut((DEB_ITRACE,"In CDeltaList copy constructor\n"));
    SCODE sc = S_OK;
    CBasedDeltaBlockPtr *temp = NULL;
    CBasedDeltaBlockPtr *apdbTemp = NULL;

    ULONG cbSector = GetDataSectorSize();

    ULONG csect = (ULONG)((ulSize + cbSector - 1) / cbSector);

    ULONG ulNewSize = (csect + CSECTPERBLOCK - 1) / CSECTPERBLOCK;

    msfAssert(ulNewSize > 0);

    if (ulNewSize == _ulSize)
    {
        return S_OK;
    }

    if (IsInStream())
    {
        //We have already copied the delta list contents out to the
        //  stream, and will not attempt to read them back in.
        //
        //All we need to do is adjust the size and return.
        if (ulNewSize > _ulSize)
        {
            for (ULONG i = _ulSize; i < ulNewSize; i++)
            {
                msfChk(InitStreamBlock(i));
            }
        }

        _ulSize = ulNewSize;
        return S_OK;
    }


    if (ulNewSize > (_HEAP_MAXREQ / sizeof(SDeltaBlock *)))
    {
        //This is not an error.  Write the current delta information
        //  to the stream and use that.

        msfChk(DumpList());
        if (ulNewSize > _ulSize)
        {
            for (ULONG i = _ulSize; i < ulNewSize; i++)
            {
                msfChk(InitStreamBlock(i));
            }
        }

        _ulSize = ulNewSize;
        return S_OK;
    }


    msfMemTo(ErrMem, temp = GetNewDeltaArray(ulNewSize));

    //apdbTemp is an unbased version of _apdb, for efficiency.
    apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);

    ULONG i;

    if (apdbTemp != NULL)
    {
        for (i = 0; i < min(_ulSize, ulNewSize); i++)
        {
            temp[i] = apdbTemp[i];
            apdbTemp[i] = NULL;
        }
    }

    for (i = _ulSize; i < ulNewSize; i++)
    {
        temp[i] = NULL;
    }

    for (i = ulNewSize; i < _ulSize; i++)
    {
        ReleaseBlock(i);
    }

    _ulSize = ulNewSize;
    _pmsScratch->GetMalloc()->Free(apdbTemp);
    _apdb = P_TO_BP(CBasedDeltaBlockPtrPtr, temp);
    return S_OK;

 ErrMem:
    //The only error that can get us here is an error allocating temp.
    //If this happens, dump the current vector to a stream and use
    //   the stream for all future delta list operations.
    msfChk(DumpList());
    if (ulNewSize > _ulSize)
    {
        for (ULONG i = _ulSize; i < ulNewSize; i++)
        {
            msfChk(InitStreamBlock(i));
        }
    }

    _ulSize = ulNewSize;
    return S_OK;

 Err:
    //We only get here if we error out on the DumpList() or
    //InitStreamBlock calls (i.e. Disk Error)
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::InitStreamBlock, private
//
//  Synopsis:	Initialize a new block in a stream
//
//  Arguments:	[ulBlock] -- Block to initialize
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------


SCODE CDeltaList::InitStreamBlock(ULONG ulBlock)
{
    SCODE sc = S_OK;

    ULONG cSectOld = ulBlock * CSECTPERBLOCK;
    ULONG cSectNew = (ulBlock + 1) * CSECTPERBLOCK;

    //NOTE: This can potentially be optimized to avoid the loop.
    for (ULONG i = cSectOld; i < cSectNew; i++)
    {
        msfChk(WriteMap(&_sectStart, i, ENDOFCHAIN));
    }
 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::ReleaseBlock, private
//
//  Synopsis:   Release an SDeltaBlock, freeing its storage in the
//                  scratch MS.
//
//  Arguments:  [oBlock] -- Offset of block to release.
//
//  Returns:    void.
//
//  History:    10-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


void CDeltaList::ReleaseBlock(ULONG oBlock)
{
    CFat *pfat = GetDataFat();

    msfAssert(IsInMemory());

    SDeltaBlock *temp = BP_TO_P(SDeltaBlock *, _apdb[(MAXINDEXTYPE)oBlock]);

    if (temp != NULL)
    {
        for (USHORT i = 0; i < CSECTPERBLOCK; i++)
        {
            if ((temp->_sect[i] != ENDOFCHAIN) && temp->IsOwned(i))
            {
                SECT sectCurrent = FREESECT;

                pfat->GetNext(temp->_sect[i], &sectCurrent);
                if (sectCurrent == STREAMSECT)
                    pfat->SetNext(temp->_sect[i], FREESECT);
            }
        }
        _pmsScratch->GetMalloc()->Free(temp);
        _apdb[(MAXINDEXTYPE)oBlock] = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::~CDeltaList, public
//
//  Synopsis:   CDeltaList destructor
//
//  History:    21-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


CDeltaList::~CDeltaList()
{
    Empty();
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::GetMap, public
//
//  Synopsis:   Get mapping information for a sector
//
//  Arguments:  [sectOld] -- Sector to get mapping information for
//              [dwFlags] -- DL_GET or DL_CREATE
//              [psectRet] -- Location for return value
//              [pfIsOwner] -- Returns TRUE if the returned sector
//                      is owned by this delta list, FALSE if it
//                      if owned by an ancestor.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  If DL_READ is specified, return the current existing
//                  mapping for the sector.  It is not required that
//                  the delta list own the sector.  Return ENDOFCHAIN
//                  if no mapping exists.
//              If DL_GET is specified, return the current existing
//                  mapping for the sector if it is owned by this delta
//                  list.  If none exists, return ENDOFCHAIN.
//              If DL_CREATE, check the existing mapping.  If none
//                  exists, or one exists but is not owned, get a free
//                  sector from the fat and set the mapping.  Return
//                  the new mapping (or the existing one if it had
//                  previously been mapped).
//
//  History:    21-Jan-92   PhilipLa    Created.
//              10-Jul-92   PhilipLa    Changed for copy reductions.
//
//--------------------------------------------------------------------------


SCODE CDeltaList::GetMap(SECT sectOld, const DWORD dwFlags, SECT *psectRet)
{
    msfDebugOut((DEB_ITRACE,"In CDeltaList::GetMap()\n"));
    SCODE sc = S_OK;

    msfAssert(!IsEmpty());
    msfAssert((dwFlags == DL_GET) || (dwFlags == DL_CREATE) ||
            (dwFlags == DL_READ));

    MAXINDEXTYPE odb = (MAXINDEXTYPE)(sectOld / CSECTPERBLOCK);
    USHORT os = (USHORT)(sectOld % CSECTPERBLOCK);

    msfAssert(odb < _ulSize);

    if (IsInStream())
    {
        BOOL fOwn = TRUE;
        msfChk(ReadMap(&_sectStart, sectOld, psectRet));

        if (dwFlags == DL_READ)
        {
            return S_OK;
        }

        CDeltaList *pdlParent = NULL;
        if (_ptsParent->GetBase() != NULL)
            pdlParent = _ptsParent->GetBase()->GetDeltaList();

        if (pdlParent != NULL)
        {
            msfChk(pdlParent->IsOwned(sectOld, *psectRet, &fOwn));
        }

        if (fOwn == FALSE)
            *psectRet = ENDOFCHAIN;

        if ((dwFlags == DL_CREATE) && (*psectRet == ENDOFCHAIN))
        {
            msfChk(GetDataFat()->GetFree(1, psectRet, GF_WRITE));
            msfChk(GetDataFat()->SetNext(*psectRet, STREAMSECT));

            if(!IsNoScratch())
                msfChk(_pmsScratch->SetSize());
            else
                msfChk(_pms->SetSize());

            msfChk(WriteMap(&_sectStart, sectOld, *psectRet));
        }

        return S_OK;
    }

    msfAssert(odb < _ulSize);

    // If _apdb[odb] == NULL, there is no existing mapping so we
    //   don't need to check ownership.
    if (_apdb[odb] == NULL)
    {
        if (dwFlags & DL_CREATE)
        {
            SDeltaBlock * pdbTemp = new(_pmsScratch->GetMalloc()) SDeltaBlock;
            _apdb[odb] = P_TO_BP(CBasedDeltaBlockPtr, pdbTemp);

            if (_apdb[odb] == NULL)
            {
                msfChk(DumpList());
                msfAssert(IsInStream());
                return GetMap(sectOld, dwFlags, psectRet);
            }
        }
        else
        {
            *psectRet = ENDOFCHAIN;
            return S_OK;
        }
    }

    SECT sectTemp;
    sectTemp = _apdb[odb]->_sect[os];

    if (dwFlags != DL_READ)
    {
        BOOL fOwn = _apdb[odb]->IsOwned(os);
        if (fOwn == FALSE)
            sectTemp = ENDOFCHAIN;

        if ((dwFlags == DL_CREATE) && (sectTemp == ENDOFCHAIN))
        {
            //
            // Don't grow the file (w/ SetSize) here.  As an optimzation
            // it is the responsibility of the caller to grow the file after
            // possibly multiple calls to GetMap(DL_CREATE).
            //
            msfChk(GetDataFat()->GetFree(1, &sectTemp, GF_WRITE));
            msfChk(GetDataFat()->SetNext(sectTemp, STREAMSECT));

            _apdb[odb]->_sect[os] = sectTemp;
            _apdb[odb]->MakeOwn(os);
        }
    }

    *psectRet = sectTemp;
    msfDebugOut((DEB_ITRACE,"Out CDeltaList::GetMap()\n"));
 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::ReleaseInvalidSects, public
//
//  Synopsis:   Release sectors allocated in the FAT that are not in the
//              MStream.
//
//  Arguments:  [sectMaxValid] -- Release all SECTS greater than this one.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    26-Mar-97   BChapman    Created.
//
//--------------------------------------------------------------------------

SCODE CDeltaList::ReleaseInvalidSects(SECT sectMaxValid)
{
    msfDebugOut((DEB_ITRACE,"In CDeltaList::ReleaseInvalidSects(%x)\n",
                                                        sectMaxValid));

    msfAssert(!IsEmpty());

    CBasedDeltaBlockPtr *apdbTemp;      // Real Ptr to array of Based Pointers
    SDeltaBlock *pdbTemp;

    CFat *pfat = GetDataFat();

    if (IsInStream())
    {
        // We don't need to do this if we are InStream.
        return S_OK;
    }

    apdbTemp = _apdb;   // Convert the array BasedPtr to a Ptr.

    //
    //   Walk the entire Delta List looking for SECTS in the FAT that are
    // greater than sectMaxValid, and free them.
    //   If all the entries in any block are freed, then free the block.
    //
    for (MAXINDEXTYPE i = 0; i < _ulSize; i++)
    {
        pdbTemp = _apdb[i];  // Convert BasedPtr to Ptr

        if (pdbTemp != NULL)
        {
            BOOL fFreeAll = TRUE;

            for (USHORT k=0; k < CSECTPERBLOCK; k++)
            {
                SECT sectType=FREESECT;
                SECT sectEntryK = pdbTemp->_sect[k];

                if(sectEntryK != ENDOFCHAIN)
                {
                    if(pdbTemp->IsOwned(k) && (sectEntryK > sectMaxValid))
                    {
                        //
                        // This routins is already in the error path.  So we
                        // don't check for errors.  Just keep pluggin away.
                        // BTW.  There shouldn't be any errors because we just
                        // allocated all this stuff and we are only tring to
                        // give it back.
                        //
                        pfat->GetNext(sectEntryK, &sectType);
                        if (sectType == STREAMSECT)
                        {
                            pfat->SetNext(sectEntryK, FREESECT);
                            pdbTemp->DisOwn(k);
                            pdbTemp->_sect[k] = ENDOFCHAIN;
                        }
                    }
                    else
                    {
                        // don't free this DeltaBlock if any non-ENDOFCHAIN
                        // entries are not owned or are valid (<= MaxValid)
                        fFreeAll = FALSE;
                    }
                }
            }
            if(fFreeAll)
            {
                _pmsScratch->GetMalloc()->Free(pdbTemp);
                _apdb[i] = NULL;
            }
        }
    }
    msfDebugOut((DEB_ITRACE,"Out CDeltaList::ReleaseInvalidSects()\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::BeginCommit, public
//
//  Synopsis:	Begin the commit of a delta list
//
//  Arguments:	[ptsParent] -- Pointer to containing Tstream.
//
//  Returns:	Appropriate status code
//
//  History:	19-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CDeltaList::BeginCommit(CTransactedStream *ptsParent)
{
    _ptsParent = P_TO_BP(CBasedTransactedStreamPtr, ptsParent);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDeltaList::EndCommit, public
//
//  Synopsis:   Take the new delta list passed up and release the old.
//              Free any sectors used and owned in the old list but not
//              in the new.
//
//  Arguments:  [pdlNew] -- Pointer to new delta list to take
//
//  Returns:    void.
//
//  History:    10-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


void CDeltaList::EndCommit(CDeltaList *pdlNew, DFLAGS df)
{
    msfAssert(pdlNew != NULL);

    if (pdlNew->IsEmpty()) return;

    ULONG ulMaxSize = min(_ulSize, pdlNew->_ulSize);

    if (P_COMMIT(df))
    {
#if DBG == 1
        msfDebugOut((DEB_ITRACE, "Beginning commit process:\n"));
        PrintList();

        msfDebugOut((DEB_ITRACE, "New list is:\n"));
        pdlNew->PrintList();
#endif

        ULONG iMax = ulMaxSize * CSECTPERBLOCK;

        for (ULONG i = 0; i < iMax; i++)
        {
            SECT sectOld = ENDOFCHAIN, sectNew = ENDOFCHAIN;

            GetMap(i, DL_GET, &sectOld);
            pdlNew->GetMap(i, DL_GET, &sectNew);

            if ((sectOld != sectNew) && (sectOld != ENDOFCHAIN) &&
                (sectNew != ENDOFCHAIN))
            {
                CFat *pfat = GetDataFat();
                SECT sectChk;

                pfat->GetNext(sectOld, &sectChk);
                if (sectChk == STREAMSECT)
                    pfat->SetNext(sectOld, FREESECT);
            }
        }


        //At this point, all the sectors in the current delta list
        //   that are not used in the new delta list have been freed.
        //   We still need to clean up the actual representation of
        //   the delta list, and merge the ownership bitvectors if
        //   we are InMemory.

        if (IsInMemory())
        {
            for (i = pdlNew->_ulSize; i < _ulSize; i++)
            {
                ReleaseBlock(i);
            }

            CBasedDeltaBlockPtr * apdbTemp;
            apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);

            for (MAXINDEXTYPE i = 0; i < ulMaxSize; i++)
            {
                if ((apdbTemp[i] != NULL) && (pdlNew->IsInMemory()))
                {
                    msfAssert(pdlNew->_apdb[i] != NULL);
                    for (USHORT j = 0; j < CSECTPERBLOCK / CBITPERUSHORT; j++)
                    {
                        pdlNew->_apdb[i]->_fOwn[j] |= apdbTemp[i]->_fOwn[j];
                    }
                }
                _pmsScratch->GetMalloc()->Free(BP_TO_P(SDeltaBlock *, apdbTemp[i]));
            }
            _pmsScratch->GetMalloc()->Free(apdbTemp);
        }
        else if (IsInStream())
        {
            for (i = pdlNew->_ulSize * CSECTPERBLOCK;
                 i < _ulSize * CSECTPERBLOCK;
                 i++)
            {
                SECT sectOld = ENDOFCHAIN;
                GetMap(i, DL_GET, &sectOld);
                if (sectOld != ENDOFCHAIN)
                {
                    CFat *pfat = GetDataFat();
#if DBG == 1
                    SECT sectChk;
                    pfat->GetNext(sectOld, &sectChk);
                    msfAssert((sectChk == STREAMSECT) &&
                              aMsg("Freeing non-dirty stream sector"));
#endif
                    pfat->SetNext(sectOld, FREESECT);
                }
            }

            GetControlFat()->SetChainLength(_sectStart, 0);
        }

        _apdb = pdlNew->_apdb;
        _ulSize = pdlNew->_ulSize;
        _sectStart = pdlNew->_sectStart;

        pdlNew->_apdb = NULL;
        pdlNew->_ulSize = 0;
        pdlNew->_sectStart = ENDOFCHAIN;
        pdlNew->_ptsParent = NULL;
#if DBG == 1
        msfDebugOut((DEB_ITRACE, "Completed commit process:\n"));
        PrintList();
#endif
    }

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::Empty, public
//
//  Synopsis:	Empty the delta list
//
//  Arguments:	None.
//
//  History:	18-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CDeltaList::Empty(void)
{
    if (IsInMemory())
    {
        msfAssert(_sectStart == ENDOFCHAIN);

        CBasedDeltaBlockPtr * apdbTemp;
        apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);

        for (ULONG i = 0; i < _ulSize; i++)
        {
            if (apdbTemp[i] != NULL)
            {
                ReleaseBlock(i);
            }
        }
        _pmsScratch->GetMalloc()->Free(apdbTemp);
        _apdb = NULL;
    }
    else if (IsInStream())
    {
        msfAssert(_apdb == NULL);

        if (_sectStart != ENDOFCHAIN)
        {
            FreeStream(_sectStart, _ulSize);
        }
        _sectStart = ENDOFCHAIN;
    }

    _ptsParent = NULL;
    _ulSize = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::DumpList, public
//
//  Synopsis:	Dump a delta list out to a stream, then release its
//                      in memory representation.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::DumpList(void)
{
    SCODE sc = S_OK;

    ULONG cSect = _ulSize * CSECTPERBLOCK;

    msfAssert(IsInMemory());
    for (ULONG i = 0; i < cSect; i++)
    {
        SECT sectNew;
        msfChk(GetMap(i, DL_GET, &sectNew));
        msfChk(WriteMap(&_sectStart, i, sectNew));
    }

    CBasedDeltaBlockPtr * apdbTemp;
    apdbTemp = BP_TO_P(CBasedDeltaBlockPtr *, _apdb);
    if (apdbTemp != NULL)
    {
        for (i = 0; i < _ulSize; i++)
        {
            SDeltaBlock *temp = BP_TO_P(SDeltaBlock *, apdbTemp[i]);
            if (temp != NULL)
            {
                _pmsScratch->GetMalloc()->Free(temp);
            }
        }
        _pmsScratch->GetMalloc()->Free(apdbTemp);
        _apdb = NULL;
    }

    msfAssert(IsInStream());
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::FindOffset, private
//
//  Synopsis:	Compute the correct offset from which to read a mapping
//
//  Arguments:  [psectStart] -- Pointer to start sector
//              [sect] -- Sector to find mapping for
//              [pulRet] -- Pointer to return location
//              [fWrite] -- TRUE if the sector will be written to
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::FindOffset(
        SECT *psectStart,
        SECT sect,
        ULARGE_INTEGER *pulRet,
        BOOL fWrite)
{
    SCODE sc;

    ULONG ulOffset = sect * sizeof(SECT);

    ULONG cbSector = GetControlSectorSize();
    msfAssert(cbSector == SCRATCHSECTORSIZE);

    SECT sectChain = ulOffset / cbSector;

    SECT sectReal;

    CFat *pfat = GetControlFat();

    if (fWrite)
    {
        if (*psectStart == ENDOFCHAIN)
        {
            msfChk(pfat->Allocate(1, psectStart));
        }
        msfChk(pfat->GetESect(*psectStart, sectChain, &sectReal));
    }
    else
    {
        msfChk(pfat->GetSect(*psectStart, sectChain, &sectReal));
    }

    msfAssert(sectReal != ENDOFCHAIN);

    ULARGE_INTEGER ul;
#ifdef LARGE_DOCFILE
    ul.QuadPart = ConvertSectOffset(sectReal,
            (OFFSET)(ulOffset % cbSector),
            _pmsScratch->GetSectorShift());
#else
    ULISet32(ul, ConvertSectOffset(sectReal,
            (OFFSET)(ulOffset % cbSector),
            _pmsScratch->GetSectorShift()));
#endif

    *pulRet = ul;

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::ReadMap, private
//
//  Synopsis:	Read a mapping from a stream representation.
//
//  Arguments:	[sect] -- Sector to read mapping for
//              [psectRet] -- Location to return mapping in.
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::ReadMap(SECT *psectStart, SECT sect, SECT *psectRet)
{
    SCODE sc;

    if (_sectStart == ENDOFCHAIN)
    {
        //We haven't written anything yet, so the sector must be
        //  unmapped.
        *psectRet = ENDOFCHAIN;
        return S_OK;
    }

    ULARGE_INTEGER ul;
    ULONG ulRetval;

    msfChk(FindOffset(psectStart, sect, &ul, FALSE));

    msfHChk(GetControlILB()->ReadAt(ul, psectRet, sizeof(SECT),
            &ulRetval));

    if (ulRetval != sizeof(SECT))
    {
        //The ILB isn't long enough to contain that mapping,
        *psectRet = ENDOFCHAIN;
    }
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::WriteMap, private
//
//  Synopsis:	Write a mapping to a stream representation
//
//  Arguments:	[sect] -- Sect to write mapping for
//              [sectMap] -- Mapping of sect
//
//  Returns:	Appropriate status code
//
//  History:	20-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::WriteMap(SECT *psectStart, SECT sect, SECT sectMap)
{
    SCODE sc;

    ULARGE_INTEGER ul;
    ULONG ulRetval;

    SECT sectOld = *psectStart;

    msfAssert(_pmsScratch->IsScratch());

    msfChk(FindOffset(psectStart, sect, &ul, TRUE));

    msfHChk(GetControlILB()->WriteAt(ul, &sectMap, sizeof(SECT),
            &ulRetval));

    if (ulRetval != sizeof(SECT))
    {
        msfErr(Err, STG_E_WRITEFAULT);
    }

    return S_OK;

Err:
    //If we failed, we may have allocated sectors for storage that
    //   cannot be written to - we should ignore these sectors.  This
    //   can leave some wasted space in the fat, but we don't really
    //   care since this is the scratch.

    *psectStart = sectOld;
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::FreeStream, private
//
//  Synopsis:	Free the scratch sectors associated with a stream
//              representation of a delta list.
//
//  Arguments:	[sectStart] -- Start sector of representation to
//                              free.
//
//  Returns:	void.
//
//  History:	23-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CDeltaList::FreeStream(SECT sectStart, ULONG ulSize)
{
    ULONG cSect = ulSize * CSECTPERBLOCK;

    SECT sectOld = ENDOFCHAIN;
    BOOL fOwn = TRUE;

    CDeltaList *pdlParent = NULL;
    if (_ptsParent->GetBase() != NULL)
        pdlParent = _ptsParent->GetBase()->GetDeltaList();

    for (ULONG i = 0; i < cSect; i++)
    {
        ReadMap(&sectStart, i, &sectOld);

        if (pdlParent != NULL)
        {
            pdlParent->IsOwned(i, sectOld, &fOwn);
        }

        if ((sectOld != ENDOFCHAIN) && fOwn)
        {
            CFat *pfat = GetDataFat();
            SECT sectChk = FREESECT;
            pfat->GetNext(sectOld, &sectChk);
            if (sectChk == STREAMSECT)
                pfat->SetNext(sectOld, FREESECT);
        }
    }
    GetControlFat()->SetChainLength(sectStart, 0);
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:	CDeltaList::IsOwned, public
//
//  Synopsis:	Return TRUE if the caller owns the sector given,
//              FALSE otherwise.
//
//  Arguments:	[sect] -- Sector for mapping given
//              [sectMap] -- Sector mapping
//              [fOwn] -- Return value
//
//  Returns:	Appropriate status code
//
//  History:	30-Jul-93	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CDeltaList::IsOwned(SECT sect, SECT sectMap, BOOL *fOwn)
{
    SCODE sc = S_OK;
    //To determine ownership of a sector:
    //    1)  If the sector mapping does not exist at the current level,
    //          then the caller must own it.
    //    2)  If the sector mapping does exist at the current level, then
    //          the caller cannot own it.
    SECT sectOld;

    if (sect < _ulSize * CSECTPERBLOCK)
    {
        if (IsInMemory())
        {
            MAXINDEXTYPE odb = (MAXINDEXTYPE)(sect / CSECTPERBLOCK);
            USHORT os = (USHORT)(sect % CSECTPERBLOCK);

            sectOld = _apdb[odb]->_sect[os];
        }
        else
        {
            msfChk(GetMap(sect, DL_READ, &sectOld));
        }

        *fOwn = (sectOld != sectMap);
    }
    else
    {
        *fOwn = TRUE;
    }

Err:
    return sc;
}


#if DBG == 1
void CDeltaList::PrintList(void)
{
    if (!IsEmpty())
    {
        for (ULONG i = 0; i < _ulSize * CSECTPERBLOCK; i++)
        {
            SECT sect;
            GetMap(i, DL_READ, &sect);

            msfDebugOut((DEB_NOCOMPNAME|DEB_ITRACE, "%lx ",sect));
        }
        msfDebugOut((DEB_NOCOMPNAME|DEB_ITRACE,"\n"));
    }
    else
    {
        msfDebugOut((DEB_NOCOMPNAME|DEB_ITRACE,"List is empty\n"));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\dir.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dir.cxx
//
//  Contents:   Directory Functions
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//---------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dirfunc.hxx>
#include <mread.hxx>

#define DEB_DIR (DEB_ITRACE | 0x00040000)

//+-------------------------------------------------------------------------
//
//  Member:     CMStream::KillStream, public
//
//  Synopsis:   Eliminate a given chain
//
//  Arguments:  [sectStart] -- Beginning of chain to eliminate
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    14-Sep-92       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef LARGE_STREAMS
inline SCODE CMStream::KillStream(SECT sectStart, ULONGLONG ulSize)
#else
inline SCODE MSTREAM_CLASS CMStream::KillStream(SECT sectStart, ULONG ulSize)
#endif
{
    CFat *pfat;

#ifndef REF
    pfat = ((!_fIsScratch) && (ulSize < MINISTREAMSIZE)) ? &_fatMini: &_fat;
#else
    pfat = (ulSize < MINISTREAMSIZE) ?&_fatMini: &_fat;
#endif //!REF

    return pfat->SetChainLength(sectStart, 0);
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirEntry::CDirEntry, public
//
//  Synopsis:   Constructor for CDirEntry class
//
//  Effects:
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirEntry::CDirEntry()
{
    msfAssert(sizeof(CDirEntry) == DIRENTRYSIZE);
    Init(STGTY_INVALID);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirSect::Init, public
//
//  Synopsis:   Initializer for directory sectors
//
//  Arguments:  [cdeEntries] -- Number of DirEntries in the sector
//
//  Returns:    S_OK if call completed OK.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              27-Dec-91   PhilipLa    Converted from const to var size
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirSect::Init(USHORT cbSector)
{
    msfDebugOut((DEB_DIR,"Allocating sector with size %u\n",cbSector));

#if WIN32 == 200
    //Make sure to zero out the memory, since Win95 doesn't do it for
    //  you.  NT does, so we don't need to do this there.
    memset(_adeEntry, 0, cbSector);
#endif
    
    DIROFFSET cdeEntries = cbSector / sizeof(CDirEntry);

    for (ULONG i = 0; i < cdeEntries; i++)
    {
        _adeEntry[i].Init(STGTY_INVALID);
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirSect::InitCopy, public
//
//  Synopsis:   CDirSect initializer for copying
//
//  Arguments:  [dsOld] -- Const reference to dir to be copied
//
//  Returns:    S_OK if call completed successfully.
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirSect::InitCopy(USHORT cbSector,
                                   const CDirSect *pdsOld)
{
    msfDebugOut((DEB_DIR,"In CDirSect copy constructor\n"));

    memcpy(_adeEntry, pdsOld->_adeEntry, cbSector);

    msfDebugOut((DEB_DIR,"Out CDirSect copy constructor\n"));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CDirectory
//
//  Synopsis:   Default constructor
//
//  History:    22-Apr-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectory::CDirectory() 
        : _pmsParent(NULL)
{
    _cdsTable = _cdeEntries = 0;
    _sidFirstFree = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectory::Empty, public
//
//  Synopsis:	Empty all the control structures of this instance
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CDirectory::Empty(void)
{
    _dv.Empty();
    _pmsParent = NULL;
    _cdsTable = 0;
    _cdeEntries = 0;
    _sidFirstFree = 0;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::InitCopy, public
//
//  Synopsis:   Init function for copying.
//
//  Arguments:  [dirOld] -- Const reference to dir object to be copied
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDirectory::InitCopy(CDirectory *pdirOld)
{
    msfDebugOut((DEB_DIR,"In CDirectory copy constructor\n"));

    _pmsParent = pdirOld->_pmsParent;

    _cdeEntries = pdirOld->_cdeEntries;

    _dv.InitCommon(_pmsParent->GetSectorSize());
    _dv.InitCopy(&pdirOld->_dv);
    _cdsTable = pdirOld->_cdsTable;
    _sidFirstFree = pdirOld->_sidFirstFree;

    msfDebugOut((DEB_DIR,"Out CDirectory copy constructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetFree, public
//
//  Synposis:   Locates a free directory entry
//
//  Arguments:  None.
//
//  Returns:    Stream ID of free directory entry
//
//  Algorithm:  Do a linear search of all available directories.
//              If no free spot is found, resize the directory and
//              perform the search again.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::GetFree(SID * psid)
{
    msfDebugOut((DEB_DIR,"In CDirectory::GetFree()\n"));

    SCODE sc = S_OK;
    SID sidRet = NOSTREAM;
    CDirSect * pds;

    DIRINDEX ipdsStart;
    DIROFFSET ideStart;

    SidToPair(_sidFirstFree, &ipdsStart, &ideStart);
    while (TRUE)
    {
        for (DIRINDEX ipds = ipdsStart; ipds < _cdsTable; ipds++)
        {
            msfChk(_dv.GetTable(ipds, FB_NONE, &pds));
            for (DIROFFSET ide = ideStart; ide < _cdeEntries; ide++)
            {
                if (pds->GetEntry(ide)->IsFree())
                {
                    msfDebugOut((DEB_ITRACE,"GetFree found sid %lu\n",
                            PairToSid(ipds,ide)));

                    *psid = PairToSid(ipds, ide);
                    _sidFirstFree = *psid + 1;
                    _dv.ReleaseTable(ipds);
                    return S_OK;
                }
            }
            _dv.ReleaseTable(ipds);
            ideStart = 0;
        }
        ipdsStart = ipds;
        msfChk(Resize(_cdsTable+1));
    }

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindGreaterEntry
//
//  Synopsis:   finds next entry (for iteration)
//
//  Arguments:  [sidStart]   -- child sid to start looking
//		[pdfn]       -- previous entry name
//		[psidResult] -- place holder for returned sid
//
//  Requires:   sidStart != NOSTREAM
//
//  Returns:    S_OK, STG_E_NOMOREFILES, or other error
//
//  Modifies:   psidResult
//
//  Algorithm:  Iterate by returning the sid that has a name larger
//		than the given name.
//
//  History:    16-Oct-92 AlexT     Created
//
//  Notes:      This method is called recursively
//              When sc != S_OK, *psidReturn contains the recursion count
//              The caller must initialize *psidResult to 0 or SIDROOT
//
//--------------------------------------------------------------------------

SCODE CDirectory::FindGreaterEntry(SID sidStart,
                                   CDfName const *pdfn,
                                   SID *psidResult)
{
    SCODE sc;
    CDirEntry *pde;
    msfAssert(sidStart != NOSTREAM);
    const SID sidMax = (_cdsTable+1) * _cdeEntries;

    if ((*psidResult)++ > sidMax)
        msfErr (Err, STG_E_DOCFILECORRUPT);  // prevent infinite recursion

    msfChk(GetDirEntry(sidStart, FB_NONE, &pde));

    int iCmp;
    iCmp = NameCompare(pdfn, pde->GetName());

    if (iCmp < 0)
    {
        //  Since the last name returned is less than this name,
        //  the sid to return must either be to our left or this sid

        SID sidLeft = pde->GetLeftSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)
        
        ReleaseEntry(sidStart);
        if (sidLeft == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }

        if ((sidLeft == NOSTREAM) ||
            (sc = FindGreaterEntry(sidLeft, pdfn, psidResult)) == STG_E_NOMOREFILES)
        {
            //  There was no left child with a name greater than pdfn, so
            //  we return ourself

            *psidResult = sidStart;
            sc = S_OK;
        }
    }
    else
    {
        //  The last name returned is greater than this one, so we've already
        //  returned this sidStart.  Look in the right subtree.

        SID sidRight = pde->GetRightSib();

        //  We can't hold onto sidStart as we recurse, (because we'll ask for
        //  a page each time we recurse)

        ReleaseEntry(sidStart);

        if (sidRight == sidStart)
        {
            //Corrupt docfile - return error.
            return STG_E_DOCFILECORRUPT;
        }
        
        if (sidRight == NOSTREAM)
            sc = STG_E_NOMOREFILES;
        else
            sc = FindGreaterEntry(sidRight, pdfn, psidResult);
    }
Err:
    return(sc);
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetStart, public
//
//  Synopsis:   Set starting sector for a dir entry
//
//  Arguments:  [sid] -- SID of entry to be modified
//              [sect] -- New starting sector for entry
//
//  Returns:    SID of modified entry
//
//  History:    18-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::SetStart(const SID sid, const SECT sect)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetStart(sect);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetChild, public
//
//  Synposis:   Set the child SID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [sidChild] -- SID of first child of this stream
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change child field on entry, then write to stream.
//
//  History:    24-Sep-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetChild(const SID sid, const SID sidChild)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetChild(sidChild);
    ReleaseEntry(sid);

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetSize, public
//
//  Synposis:   Set the size of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cbSize] -- Size
//
//  Returns:    SID of modified entry
//
//  Algorithm:  Change size field on entry, then write to stream.
//
//  History:    24-Sep-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE CDirectory::SetSize(const SID sid, const ULONGLONG cbSize)
#else
SCODE CDirectory::SetSize(const SID sid, const ULONG cbSize)
#endif
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetSize(cbSize);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetTime, public
//
//  Synposis:   Set the time of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [tt] - WT_*
//              [nt] - New time
//
//  Returns:    Apropriate status code
//
//  Algorithm:  Change time field on entry, then write to stream.
//
//  History:    24-Sep-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetTime(const SID sid, WHICHTIME tt, TIME_T nt)
{
    SCODE sc;

    CDirEntry *pde;

    // We don't support ACCESS times, so just ignore sets
    if (tt == WT_ACCESS)
        return S_OK;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetTime(tt, nt);
    ReleaseEntry(sid);

 Err:
    return sc;
}
//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetAllTimes, public
//
//  Synposis:   Set the times of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [atm] - ACCESS time
//              [mtm] - MODIFICATION time
//				[ctm] - Creation Time
//
//  Returns:    Appropriate Status Code
//
//  Algorithm:  Change time fields on entry, then write to stream.
//
//  History:    24-Nov-95   SusiA    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetAllTimes(const SID sid, 
										TIME_T atm,
										TIME_T mtm,
										TIME_T ctm)
{
    SCODE sc;

    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetAllTimes(atm, mtm, ctm);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetFlags, public
//
//  Synposis:   Set the flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [mse] - New flags
//
//  Returns:    Status code
//
//  Algorithm:  Change Luid field on entry, then write to stream.
//
//  History:    08-Oct-92	PhilipLa	Created
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetFlags(const SID sid, const MSENTRYFLAGS mse)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetFlags(mse);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetClassId, public
//
//  Synposis:   Set the class ID of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [cls] - Class ID
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92   DrewB    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetClassId(const SID sid, const GUID cls)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetClassId(cls);
    ReleaseEntry(sid);
 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SetUserFlags, public
//
//  Synposis:   Set the user flags of an entry
//
//  Effects:    Modifies a single directory entry.  Causes a one sector
//              stream write.
//
//  Arguments:  [sid] -- Stream ID of entry to be set
//              [dwUserFlags] - Flags
//              [dwMask] - Mask
//
//  Returns:    Appropriate status code
//
//  History:    11-Nov-92   DrewB    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::SetUserFlags(SID const sid,
                                        DWORD dwUserFlags,
                                        DWORD dwMask)
{
    SCODE sc;
    CDirEntry *pde;

    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));
    pde->SetUserFlags(dwUserFlags, dwMask);
    ReleaseEntry(sid);

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::resize, private
//
//  Synposis:   Resize a directory.
//
//  Effects:    Reallocates space for directory table, copying over
//              old pointers as necessary.  Any new tables needed are
//              created here.
//
//  Arguments:  [uNewsize] -- New size for Directory
//
//  Returns:    void
//
//  Algorithm:  Allocate a new array of pointers of the necessary size.
//              Then, copy over all pointers from old array and allocate
//              new CDirSects for all new tables.
//
//  History:    20-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::Resize(DIRINDEX uNewsize)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Resize(%i)\n",uNewsize));
    SCODE sc;

    if (uNewsize == _cdsTable) return S_OK;

    SECT sect;
    //GetESect call will make sure we have enough Fat space.
    msfChk(_pmsParent->GetESect(SIDDIR, uNewsize - 1, &sect));

    msfChk(_dv.Resize(uNewsize));

    ULONG ipds;
    for (ipds = _cdsTable; ipds < uNewsize; ipds++)
    {
        CDirSect *pds;
        msfChk(_dv.GetTable(ipds, FB_NEW, &pds));

        SECT sect;
        msfChk(_pmsParent->GetESect(SIDDIR, ipds, &sect));
        _cdsTable = ipds + 1;
        _dv.SetSect(ipds, sect);
        _dv.ReleaseTable(ipds);
    }

    msfChk(_pmsParent->GetHeader()->SetDirLength (_cdsTable));
 Err:
#if DBG == 1
    ULONG cbSect;
    SECT sectStart;

    sectStart = _pmsParent->GetHeader()->GetDirStart();
    _pmsParent->GetFat()->GetLength(sectStart, &cbSect);

    msfAssert((cbSect == _cdsTable) &&
              aMsg("Directory length in FAT does not match cached size."));
#endif    
    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::Init, public
//
//  Synposis:   Sets up a Directory instance and reads in all tables
//              from the stream
//
//  Arguments:  [cSect] -- Number of sectors in directory
//
//  Returns:    S_OK if call completed OK.
//              STG_E_READFAULT if not enough bytes were read for
//                                  a DirSector
//              Error code of read if read returned an error.
//
//  Algorithm:  Create array to hold appropriate number of tables.
//              Read in each table from disk.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//---------------------------------------------------------------------------

SCODE CDirectory::Init(
        CMStream *pmsParent,
        DIRINDEX cSect)
{
    msfDebugOut((DEB_DIR,"In CDirectory::Init(%lu)\n",cSect));
    SCODE sc;

    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    _cdeEntries = pmsParent->GetSectorSize() / sizeof(CDirEntry);

    _dv.InitCommon(pmsParent->GetSectorSize());
    msfChk(_dv.Init(pmsParent, cSect));

    _cdsTable = cSect;

    msfDebugOut((DEB_DIR,"Out CDirectory::Init()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InitNew, public
//
//  Synposis:   Sets up a new Directory instance for a new Mstream
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//              STG_E_WRITEFAULT if not enough bytes were written.
//              Error code of write if write failed.
//
//  Algorithm:  Write initial DirSector to disk.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::InitNew(CMStream *pmsParent)
{
    SCODE sc;
    CDfName const dfnRoot(wcsRootEntry);

    msfDebugOut((DEB_DIR,"In CDirectory::setupnew()\n"));
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    _cdeEntries = pmsParent->GetSectorSize() / sizeof(CDirEntry);

    _dv.InitCommon(pmsParent->GetSectorSize());
    msfChk(_dv.Init(pmsParent, 1));

    CDirSect *pds;

    msfChk(_dv.GetTable(0, FB_NEW, &pds));
    _dv.SetSect(0, pmsParent->GetHeader()->GetDirStart());
    _dv.ReleaseTable(0);

    _cdsTable = 1;

    SID sidRoot;

    msfChk(GetFree(&sidRoot));
    CDirEntry *pdeTemp;

    msfChk(GetDirEntry(sidRoot, FB_DIRTY, &pdeTemp));
    pdeTemp->Init(STGTY_ROOT);

    msfAssert(sidRoot == SIDROOT);

    pdeTemp->SetName(&dfnRoot);

    ReleaseEntry(sidRoot);

    msfDebugOut((DEB_DIR,"Exiting CDirectory::setupnew()\n"));

 Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::CreateEntry, public
//
//  Synopsis:   Create a new directory entry
//
//  Arguments:  [sidParent] -- SID of parent for new entry
//		[pwcsName] -- Name of new entry
//		[mef] -- Flags for new entry
//		[psidNew] -- Return location for new SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Allocate new entry.
//              Try to insert.
//              If unsuccessful, return new entry to free pool.
//
//  History:    19-Aug-92 	PhilipLa	Created.
//              20-Jul-93   AlexT       Optimized (skip initial search)
//
//--------------------------------------------------------------------------

SCODE CDirectory::CreateEntry(
	SID sidParent,
	CDfName const *pdfn,
	MSENTRYFLAGS mef,
	SID *psidNew)
{
    SCODE sc;
    SID sidNew;
    CDirEntry *pdeNew;

    //  Allocate new sid

    msfChk(GetFree(psidNew));
    sidNew = *psidNew;

    msfChk(GetDirEntry(sidNew, FB_DIRTY, &pdeNew));

    //  Initialize new entry

    pdeNew->Init(mef);

    TIME_T timetemp;
    if (STORAGELIKE(mef))
    {
        if (FAILED(sc = DfGetTOD(&timetemp)))
        {
            ReleaseEntry(sidNew);
            msfErr(Err, sc);
        }
    }
    else
    {
        timetemp.dwLowDateTime = timetemp.dwHighDateTime = 0;
    }

    pdeNew->SetTime(WT_CREATION, timetemp);
    pdeNew->SetTime(WT_MODIFICATION, timetemp);
    pdeNew->SetName(pdfn);

    ReleaseEntry(sidNew);

    //  Insert new entry into the tree

    msfChkTo(EH_Sid, InsertEntry(sidParent, sidNew, pdfn));
    return(sc);

EH_Sid:
    //  We were unable to insert the new entry (most likely because of a
    //  name conflict).  Here we try to return the entry to the free list.
    //  If we can't, the only consequence is that we leak a dir entry on
    //  disk (128 bytes of disk space).

    if (SUCCEEDED(GetDirEntry(sidNew, FB_DIRTY, &pdeNew)))
    {
        pdeNew->SetFlags(STGTY_INVALID);
        ReleaseEntry(sidNew);

        if (sidNew < _sidFirstFree)
        {
            _sidFirstFree = sidNew;
        }
    }

Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RenameEntry, public
//
//  Synopsis:   Rename an entry
//
//  Arguments:  [sidParent] -- Sid of parent of entry to be renamed
//              [pwcsName] -- Old name of entry to be renamed
//              [pwcsName] -- New name
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Remove old entry
//		Rename entry
//		Insert as new entry
//
//  History:    10-Sep-92    PhilipLa    Created.
//		16-Nov-92    AlexT	 Binary tree structure
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::RenameEntry(SID const sidParent,
        CDfName const *pdfn,
        CDfName const *pdfnNew)
{
    //  Make sure new name doesn't already exist
    SCODE sc;
    SEntryBuffer eb;

    sc = IsEntry(sidParent, pdfnNew, &eb);
    if (sc != STG_E_FILENOTFOUND)
    {
        if (SUCCEEDED(sc))
        {
            //  Entry did exist - fail this call
            sc = STG_E_ACCESSDENIED;
        }

        return(sc);
    }

    //  We can't just rename in place (because the tree is ordered)

    CDirEntry *pdeRename;
    SEntryBuffer ebRename;

    msfChk(FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebRename));

    sc = GetDirEntry(ebRename.sid, FB_DIRTY, &pdeRename);

    msfAssert(SUCCEEDED(sc) && aMsg("Could get dir entry to rename"));

    msfChk(sc);

    pdeRename->SetName(pdfnNew);

    ReleaseEntry(ebRename.sid);

    //  If this InsertEntry fails, we've potentially lost the entry. This
    //  doesn't matter becase:
    //  a)  The only way we could fail is if we couldn't read or write
    //      the disk (hard error)
    //  b)  No one's going to call RenameEntry anyways
    //  c)  If we're transacted, the whole operation is made robust by
    //      CopyOnWrite mode
    //  d)  If we're direct, we already know we can fail in ways that leave
    //      the Docfile corrupt.

    sc = InsertEntry(sidParent, ebRename.sid, pdfnNew);

    msfAssert(SUCCEEDED(sc) && aMsg("Couldn't reinsert renamed dir entry"));

    msfChk(sc);

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyAllChildren
//
//  Synopsis:   destroy all child entries
//
//  Effects:    destroys child tree
//
//  Arguments:  [sidParent] -- storage entry
//
//  Returns:    S_OK or error code
//
//  Modifies:   sidParent's entry
//
//  Algorithm:  While there's a child
//		  destroy it
//
//  History:    16-Nov-92 AlexT     Created
//
//  Notes:	We may want to consider a more efficient implementation
//
//--------------------------------------------------------------------------

SCODE CDirectory::DestroyAllChildren(
	SID const sidParent,
    ULONG ulDepth)
{
    SCODE sc;
    CDirEntry *pdeParent, *pdeChild;
    SID sidChild;
    CDfName dfnChild;
    ULONG ulCount = 0;
    const ULONG ulMax = _cdsTable * _cdeEntries;

    for (;;)
    {
        CDfName dfnChild;

        if (ulCount > ulMax || ulDepth > ulMax)
            msfErr (Err, STG_E_DOCFILECORRUPT);

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));
        sidChild = pdeParent->GetChild();
        ReleaseEntry(sidParent);

        if (sidChild == NOSTREAM)
            break;

        msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

        dfnChild.Set(pdeChild->GetName());
        ReleaseEntry(sidChild);

        msfChk(DestroyChild(sidParent, &dfnChild, ulDepth + 1));

        ulCount++;
    }

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::DestroyChild
//
//  Synopsis:   destroy a named child
//
//  Effects:    destroys named child's entry
//
//  Arguments:  [sidParent] -- storage entry
//		[pdfn]      -- child name
//
//  Returns:    S_OK, STG_E_FILENOTFOUND, or other error code
//
//  Modifies:   child's entry
//
//  Algorithm:  Find and remove child
//		Free child entry
//
//  History:    16-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

SCODE CDirectory::DestroyChild(
	SID const sidParent,
    CDfName const *pdfn,
    ULONG ulDepth)
{
    SCODE sc;
    SEntryBuffer ebChild;

    msfAssert(pdfn != NULL);

    //  Find the entry

    msfChk(FindEntry(sidParent, pdfn, DEOP_FIND, &ebChild));

    msfAssert(ebChild.sid != NOSTREAM);

    //  Before we remove this entry, we need to destroy it (including all
    //  its children).  Note that we can't hold onto the entry because it
    //  might have children which get destroyed, which have children which
    //  get destroyed, etc.

    if (STORAGELIKE(ebChild.dwType))
    {
        msfChk(DestroyAllChildren(ebChild.sid, ulDepth));
    }

    CDirEntry *pdeChild;
    msfChk(GetDirEntry(ebChild.sid, FB_DIRTY, &pdeChild));

    if (STREAMLIKE(ebChild.dwType))
    {
        //  Deallocate any used streams
        SECT sectStart = pdeChild->GetStart();
        pdeChild->SetStart(ENDOFCHAIN);
#ifdef LARGE_STREAMS
        msfChkTo(EH_Rel, _pmsParent->KillStream(sectStart,
				                pdeChild->GetSize(IsLargeSector())));
#else
        msfChkTo(EH_Rel, _pmsParent->KillStream(sectStart,
                                pdeChild->GetSize()));
#endif
    }

    //  remove the entry from the tree

    msfChkTo(EH_Rel, FindEntry(sidParent, pdfn, DEOP_REMOVE, &ebChild));

    pdeChild->SetFlags(STGTY_INVALID);
    if (ebChild.sid < _sidFirstFree)
    {
        _sidFirstFree = ebChild.sid;
    }

EH_Rel:
    ReleaseEntry(ebChild.sid);

Err:
    return(sc);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::StatEntry
//
//  Synopsis:   For a given handle, fill in the Multistream specific
//                  information of a STATSTG.
//
//  Arguments:  [sid] -- SID that information is requested on.
//              [pib] -- Fast iterator buffer to fill in.
//              [pstatstg] -- STATSTG to fill in.
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Fill in information
//
//  History:    25-Mar-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

SCODE CDirectory::StatEntry(SID const sid,
                                     SIterBuffer *pib,
                                     STATSTGW *pstat)
{
    SCODE sc;
    CDirEntry *pde;

    msfAssert(pib == NULL || pstat == NULL);

    msfChk(GetDirEntry(sid, FB_NONE, &pde));

    if (pib)
    {
        pib->dfnName.Set(pde->GetName());
        pib->type = pde->GetFlags();
        if ((pib->type != STGTY_STORAGE) && (pib->type != STGTY_STREAM))
            msfErr(EH_Rel, STG_E_DOCFILECORRUPT);
    }
    else
    {
        pstat->type = pde->GetFlags();

        if (pde->GetName()->GetLength() > CBSTORAGENAME)
            olChkTo (EH_Rel, STG_E_DOCFILECORRUPT);

        msfMemTo(EH_Rel, pstat->pwcsName =
               (WCHAR *)TaskMemAlloc(pde->GetName()->GetLength()));
        memcpy(pstat->pwcsName, pde->GetName()->GetBuffer(),
               pde->GetName()->GetLength());

        pstat->ctime = pde->GetTime(WT_CREATION);
        pstat->mtime = pde->GetTime(WT_MODIFICATION);
        // Don't currently keep access times
        pstat->atime = pstat->mtime;

        if (pstat->type == STGTY_STORAGE)
        {
            ULISet32(pstat->cbSize, 0);
            pstat->clsid = pde->GetClassId();
            pstat->grfStateBits = pde->GetUserFlags();
        }
        else if (pstat->type == STGTY_STREAM)
        {
#ifdef LARGE_STREAMS
            pstat->cbSize.QuadPart = pde->GetSize(IsLargeSector());
#else
            ULISet32(pstat->cbSize, pde->GetSize());
#endif
            pstat->clsid = CLSID_NULL;
            pstat->grfStateBits = 0;
        }
        else
        {
            msfErr(EH_Rel, STG_E_DOCFILECORRUPT);
        }
    }

EH_Rel:    
    ReleaseEntry(sid);
    
Err:
    return sc;
}

#ifdef CHKDSK
//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InitCorrupted, public
//
//  Synposis:   Sets up a Directory instance and reads in all tables
//              from a corrupted stream.
//
//  Arguments:  [pmsParent] -- Pointer to parent Mstream
//
//  Returns:    S_OK.
//
//  Algorithm:  Determine number of tables needed by querying FAT.
//              Resize array to hold appropriate number of tables.
//              Read in each table from disk.
//              Set parent pointer.
//
//  History:    18-Jul-91   PhilipLa    Created.
//		24-Aug-92   t-chrisy	copied from Init routine
//				force corrupted dir object to instantiate.
//
//  Notes:
//
//---------------------------------------------------------------------------

SCODE CDirectory::InitCorrupted(DIRINDEX cSect)
{
    msfDebugOut((DEB_DIR,"In CDirectory::setup(%lu)\n",cSect));
    SCODE sc;

    _cdeEntries = _pmsParent->GetSectorSize() / sizeof(CDirEntry);

    _dv.InitCommon(_pmsParent->GetSectorSize());
    sc = _dv.Init(_pmsParent, 1));

    if (FAILED(sc))
        msfDebugOut((DEB_DIR,"Error in CDirVector::Init. Cannot recover\n"));

    _cdsTable = cSect;

    DIRINDEX i;
    for (i = 0; i < cSect; i++)
    {
        ULONG ulRetval;
        CDirEntry *pds;
        msfChk(_dv.GetBlock(i, &pds));
        sc = _pmsParent->ReadSect(SIDDIR,i,pds,ulRetval);
        if (!FAILED(sc))
        {
            if (ulRetval != _pmsParent->GetSectorSize())
                msfDebugOut((DEB_DIR, "STG_E_READFAULT\n"));
        }
    }
    msfDebugOut((DEB_DIR,"Out CDirectory::setup()\n"));
    sc = S_OK;

 Err:
    return sc;
}
#endif

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::GetDirEntry
//
//  Synopsis:   Get a directory entry with given permissions
//
//  Arguments:  [sid]     -- SID
//              [dwFlags] -- permissions
//              [ppde]    -- placeholder for directory entry
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    ??-???-??    PhilipLa    Created.
//              19-Jan-93    AlexT       Made non-inline for code savings
//
//--------------------------------------------------------------------------

SCODE CDirectory::GetDirEntry(
	const SID sid,
	const DWORD dwFlags,
	CDirEntry **ppde)
{
    SCODE sc;
    CDirSect *pds;
    DIRINDEX id;

    id = sid / _cdeEntries;

    msfChk(_dv.GetTable(id, dwFlags, &pds));

    *ppde = pds->GetEntry((DIROFFSET)(sid % _cdeEntries));

 Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::ReleaseEntry
//
//  Synopsis:   Releases a directory entry
//
//  Arguments:  [sid]     -- SID
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    ??-???-??    PhilipLa    Created.
//              19-Jan-93    AlexT       Made non-inline for code savings
//
//--------------------------------------------------------------------------

void CDirectory::ReleaseEntry(SID sid)
{
    _dv.ReleaseTable(sid / _cdeEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\dirp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	DirP.CXX
//
//  Contents:	Private CDirectory child tree methods
//
//  History:    17-Nov-92 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"
#pragma hdrstop


#include <dirfunc.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::InsertEntry, private
//
//  Synopsis:   insert entry into child tree
//
//  Arguments:  [sidTree] -- storage entry in which to insert entry
//		[sidNew]  -- new entry
//		[pdfnNew] -- new entry name
//
//  Returns:	S_OK, STG_E_FILEALREADYEXISTS, or other error
//
//  Modifies:	sidParent's child tree
//
//  Algorithm:	Search down the binary tree to find the leaf node to which
//		to add the new entry (failing if we find the name already
//		exists).  Along the way we split nodes where needed to keep
//		the tree balanced.
//
//  History:    16-Nov-92 AlexT     Created
//		18-Nov-92 AlexT	    Balanced tree
//
//--------------------------------------------------------------------------

SCODE CDirectory::InsertEntry(
	SID sidTree,
        SID sidNew,
        CDfName const *pdfnNew)
{
    SCODE sc = S_OK;
    SID sidCount = 0;
    const SID sidMax = (_cdsTable+1) * _cdeEntries;

    //  To insert the key and keep the tree balanced, we need to know
    //  the parent, grandparent, and greatgrandparent of the node we're
    //  inserting.

    SID sidChild, sidParent, sidGrandParent, sidGreatGrandParent;
    CDirEntry *pdeParent;
    int iCmp;

    //  When we're ready to insert, sidParent will be the entry to which we
    //  attach sidNew

    sidParent = sidGrandParent = sidGreatGrandParent = sidTree;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeParent));
    sidChild = pdeParent->GetChild();

    //  Search down the child tree to find the correct leaf entry

    while (sidChild != NOSTREAM)
    {
        //  The sidParent entry has a child along the search path, so we
        //  move down the tree (letting go of sidParent and taking hold of
        //  its child)

        ReleaseEntry(sidParent);

        //  Check to see if we need to split this node (nothing is held)

        do
        {
            SID sidLeft, sidRight;
            BOOL fRed;

            if (++sidCount > sidMax)
                msfChkTo (Err, STG_E_DOCFILECORRUPT);

            {
                CDirEntry *pdeChild;

                msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));

                msfAssert(((sidTree != sidParent) ||
                           (pdeChild->GetColor() == DE_BLACK)) &&
                           aMsg("Dir tree corrupt - root child not black!"));

                sidLeft = pdeChild->GetLeftSib();
                sidRight = pdeChild->GetRightSib();

                ReleaseEntry(sidChild);
            }

            if (sidLeft == NOSTREAM || sidRight == NOSTREAM)
                break;

	        {
                CDirEntry *pdeLeft;

                msfChk(GetDirEntry(sidLeft, FB_NONE, &pdeLeft));
                fRed = (pdeLeft->GetColor() == DE_RED);
                ReleaseEntry(sidLeft);
            }

            if (!fRed)
                break;

            {
                CDirEntry *pdeRight;

		msfChk(GetDirEntry(sidRight, FB_NONE, &pdeRight));
		fRed = (pdeRight->GetColor() == DE_RED);
		ReleaseEntry(sidRight);
            }

            if (fRed)
                msfChk(SplitEntry(pdfnNew, sidTree, sidGreatGrandParent,
			          sidGrandParent, sidParent, sidChild,
                                  &sidChild));
        }
        while (FALSE);

        //

        msfAssert(sidChild != NOSTREAM);

        //  Advance the search

        sidGreatGrandParent = sidGrandParent;
        sidGrandParent = sidParent;
        sidParent = sidChild;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        iCmp = NameCompare(pdfnNew, pdeParent->GetName());

        if (iCmp == 0)
        {
            //  The new name exactly matched an existing name.  Fail.
            msfChkTo(EH_RelParent, STG_E_FILEALREADYEXISTS);
        }

        //  Move down the tree, left or right depending on the comparison

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    msfAssert(sidChild == NOSTREAM);

    //  We've found the position to insert the new entry.

    //  We're going to dirty sidParent, so we need to change our holding flags
    ReleaseEntry(sidParent);
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        //  sidParent never made it past sidTree - we must be inserting the
        //  first child into sidTree

        msfAssert(pdeParent->GetChild() == NOSTREAM);

        //  The SplitInsert call below will make sidNew black.
        pdeParent->SetChild(sidNew);
    }
    else
    {
        msfAssert(iCmp != 0);

        //  Use the comparison to determine which side to insert the new entry

        if (iCmp < 0)
        {
            msfAssert(pdeParent->GetLeftSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) < 0);

            pdeParent->SetLeftSib(sidNew);
        }
        else
        {
            msfAssert(pdeParent->GetRightSib() == NOSTREAM);
            msfAssert(NameCompare(pdfnNew, pdeParent->GetName()) > 0);

            pdeParent->SetRightSib(sidNew);
        }
    }

EH_RelParent:
    ReleaseEntry(sidParent);

    if (SUCCEEDED(sc))
    {
        SID sidTemp;
        sc = SplitEntry(pdfnNew, sidTree, sidGreatGrandParent, sidGrandParent,
		        sidParent, sidNew, &sidTemp);
    }
Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::SplitEntry, private
//
//  Synopsis:   Split 4-node
//
//  Effects:    Passes up red link to parent
//
//  Arguments:  [pdfn]      -- search key
//		[sidTree]   -- child tree sid
//		[sidGreat]  -- greatgrandparent of child to split
//		[sidGrand]  -- grandparent of child to split
//		[sidParent] -- parent of child to split
//		[sidChild]  -- child to split
//		[psid]      -- place holder for tree position
//
//  Returns:	S_OK, or error
//
//  Modifies:	psid, tree
//
//  Algorithm:
//
//  History:    18-Nov-92 AlexT     Created
//
//  Notes:	
//
//--------------------------------------------------------------------------

SCODE CDirectory::SplitEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidGreat,
        SID sidGrand,
        SID sidParent,
        SID sidChild,
        SID *psid)
{
    SCODE sc;
    CDirEntry *pdeChild;
    SID sidLeft, sidRight;

    //  pn is a 4-node;  start split by moving red link up

    //  pn->GetLeft()->SetColor(BLACK);

    msfChk(GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    sidLeft = pdeChild->GetLeftSib();
    sidRight = pdeChild->GetRightSib();

    //  The root must always be black;  new non-root children are red
    pdeChild->SetColor((sidParent == sidTree) ? DE_BLACK : DE_RED);

    ReleaseEntry(sidChild);

    if (sidLeft != NOSTREAM)
    {
        msfChk(SetColorBlack(sidLeft));
    }

    //  pn->GetRight()->SetColor(BLACK);

    if (sidRight != NOSTREAM)
    {
        msfChk(SetColorBlack(sidRight));
    }

    if (sidParent != sidTree)
    {
        CDirEntry *pdeParent;
        BOOL fRedParent;
        int iCmpParent;

        msfChk(GetDirEntry(sidParent, FB_NONE, &pdeParent));

        fRedParent = (pdeParent->GetColor() == DE_RED);

        if (fRedParent)
            iCmpParent = NameCompare(pdfn, pdeParent->GetName());

        ReleaseEntry(sidParent);

        //  if (pnp->IsRed())

        if (fRedParent)
        {
            int iCmpGrand;

            //  parent is red - adjacent red links are not allowed

            //  Note - grandparent may be sidTree

            if (sidGrand == sidTree)
            {
                iCmpGrand = 1;
            }
            else
            {
                CDirEntry *pdeGrand;
                msfChk(GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

                iCmpGrand = NameCompare(pdfn, pdeGrand->GetName());

                //  png->SetColor(RED);
                pdeGrand->SetColor(DE_RED);

                ReleaseEntry(sidGrand);
            }

            //  if ((ikey < png->GetKey()) != (ikey < pnp->GetKey()))

            if ((iCmpGrand < 0) != (iCmpParent < 0))
            {
                /*  two cases:
                //
                //    | |
                //    g g
                //   /   \
                //  p     p
                //   \   /
                //    x x
                //
                //  the red links are oriented differently
                */

                //  pn = Rotate(ikey, png);
                msfChk(RotateEntry(pdfn, sidTree, sidGrand, &sidChild));

                /*
                //      | |
                //      g g
                //     /   \
                //    x     x
                //   /       \
                //  p         p
                */
            }

            //  the red links are now oriented the same - we balance the tree
            //  by rotating

            //  pn = Rotate(ikey, pngg);
            msfChk(RotateEntry(pdfn, sidTree, sidGreat, &sidChild));

            //  pn->SetColor(BLACK);
            msfAssert(sidChild != sidTree);
            msfChk(SetColorBlack(sidChild));
        }
    }

    //  return(pn);
    *psid = sidChild;

    //  The first node's link must always be black.
#if DBG == 1
    CDirEntry *pdeTree;
    msfChk(GetDirEntry(sidTree, FB_NONE, &pdeTree));
    sidChild = pdeTree->GetChild();
    ReleaseEntry(sidTree);

    msfChk(GetDirEntry(sidChild, FB_NONE, &pdeChild));
    msfAssert(pdeChild->GetColor() == DE_BLACK);
    ReleaseEntry(sidChild);
#endif

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::RotateEntry
//
//  Synopsis:   rotation for balancing
//
//  Effects:    rotates localized portion of child tree
//
//  Arguments:  [pdfn] -- search key
//		[sidTree] -- child tree sid
//		[sidParent] -- root of rotation
//		[psid]      -- placeholder for root after rotation
//
//  Returns:    S_OK, or error
//
//  Modifies:   child tree
//
//  Algorithm:
//
//  History:    17-Nov-92 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectory::RotateEntry(
	CDfName const *pdfn,
        SID sidTree,
        SID sidParent,
        SID *psid)
{
    SCODE sc;
    int iCmp;
    //  PNODE pnc, pngc;
    SID sidChild, sidGrand;

    //  find the child

    CDirEntry *pdeParent, *pdeChild, *pdeGrand;
    msfChk(GetDirEntry(sidParent, FB_DIRTY, &pdeParent));

    if (sidParent == sidTree)
    {
        sidChild = pdeParent->GetChild();
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
            sidChild = pdeParent->GetLeftSib();
        else
            sidChild = pdeParent->GetRightSib();
    }

    //  find the grandchild

    msfChkTo(EH_RelParent, GetDirEntry(sidChild, FB_DIRTY, &pdeChild));
    msfAssert(sidChild != sidTree);

    iCmp = NameCompare(pdfn, pdeChild->GetName());

    if (iCmp < 0)
    {
        //  pngc = pnc->GetLeft();
        sidGrand = pdeChild->GetLeftSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        /*
        //     |
        //     c
        //    / \
        //   /   \
        //  g     X
        //   \
        //    Y
        */

        //  pnc->SetLeft(pngc->GetRight());
        pdeChild->SetLeftSib(pdeGrand->GetRightSib());

        /*
        //     |
        //     c
        //    / \
        //    |  \
        //  g |   X
        //   \|
        //    Y
        */

        //  pngc->SetRight(pnc);
        pdeGrand->SetRightSib(sidChild);

        /*
        //  g
        //   \
        //    \|
        //     c
        //    / \
        //    |  \
        //    |   X
        //    |
        //    Y
        */
    }
    else
    {
        //  pngc = pnc->GetRight();
        sidGrand = pdeChild->GetRightSib();

        msfChkTo(EH_RelChild, GetDirEntry(sidGrand, FB_DIRTY, &pdeGrand));

        // pnc->SetRight(pngc->GetLeft());
        pdeChild->SetRightSib(pdeGrand->GetLeftSib());

        // pngc->SetLeft(pnc);
        pdeGrand->SetLeftSib(sidChild);
    }


    //  update parent

    if (sidParent == sidTree)
    {
        //  The root must always be black
        pdeGrand->SetColor(DE_BLACK);
        pdeParent->SetChild(sidGrand);
    }
    else
    {
        iCmp = NameCompare(pdfn, pdeParent->GetName());

        if (iCmp < 0)
        {
            //  pnp->SetLeft(pngc);
            pdeParent->SetLeftSib(sidGrand);
        }
        else
        {
            //  pnp->SetRight(pngc);
            pdeParent->SetRightSib(sidGrand);
        }
    }

    ReleaseEntry(sidGrand);

    /*
    //  |
    //  g
    //   \
    //    \
    //     c
    //    / \
    //    |  \
    //    |   X
    //    |
    //    Y
    */

    //  return(pngc);
    *psid = sidGrand;

EH_RelChild:
    ReleaseEntry(sidChild);

EH_RelParent:
    ReleaseEntry(sidParent);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::FindEntry, private
//
//  Synopsis:	find entry info based on name (optionally removing it)
//
//  Effects:	find - none, remove - takes entry out of child list
//
//  Arguments:	[sidParent] -- sid of parent entry to search
//		[pdfn]      -- name to search for
//		[deop]      -- entry operation (find or remove)
//		[peb]       -- entry information buffer
//
//  Returns:	S_OK, STG_E_FILENOTFOUND, or other error
//
//  Modifies:	peb
//
//  Algorithm:	To find the entry we search down the binary tree.
//		To remove the entry, we need to patch the tree to keep it
//		as a valid binary tree.
//
//  History:    16-Nov-92 AlexT     Created
//
//--------------------------------------------------------------------------

SCODE CDirectory::FindEntry(
	SID sidParent,
        CDfName const *pdfn,
        DIRENTRYOP deop,
        SEntryBuffer *peb)
{
    SCODE sc;
    SID sidPrev, sidFind;
    CDirEntry *pdePrev, *pdeFind;
    int iCmp;
    SID sidCount = 0;
    const SID sidMax = (_cdsTable+1) * _cdeEntries;

    //  Once we've found the right child, sidPrev will be that entry's parent
    //  in the child tree

    sidPrev = sidParent;

    //  Begin the search with the root of the child tree

    msfChk(GetDirEntry(sidPrev, FB_NONE, &pdePrev));
    sidFind = pdePrev->GetChild();

    //  sidPrev is held

    for(;;)
    {
        if (++sidCount > sidMax)
            msfChkTo (EH_RelPrev, STG_E_DOCFILECORRUPT);

        if (sidFind == NOSTREAM)
        {
            //  we didn't find the child.  fail.
            sc = STG_E_FILENOTFOUND;
            goto EH_RelPrev;
// Removed this line to supress the debug error print.
//	    msfChkTo(EH_RelPrev, STG_E_FILENOTFOUND);
        }

        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_NONE, &pdeFind));

        //  sidPrev and sidFind are held

        int tmpCmp = NameCompare(pdfn, pdeFind->GetName());

        if (tmpCmp == 0)
        {
            //  We found the entry that matches our search name
            break;
        }

        //  The names did not match.  Advance the search down the tree.
        ReleaseEntry(sidPrev);
        pdePrev = pdeFind;
        sidPrev = sidFind;

        //  sidPrev is held

        //  remember the comparison with sidPrev so we can use it to insert
        //  an entry when we patch the tree

        iCmp = tmpCmp;

        if (iCmp < 0)
            sidFind = pdePrev->GetLeftSib();
        else
            sidFind = pdePrev->GetRightSib();
    }

    msfAssert(sidFind != NOSTREAM);

    //  sidFind is held
    //  sidPrev is held

    msfAssert(NameCompare(pdfn, pdeFind->GetName()) == 0);

    //  fill in entry information

    peb->sid = sidFind;
    peb->dwType = pdeFind->GetFlags();
    peb->luid = DF_NOLUID;

    if (deop == DEOP_REMOVE)
    {
        ReleaseEntry(sidFind);
        ReleaseEntry(sidPrev);

        msfChk(GetDirEntry(sidPrev, FB_DIRTY, &pdePrev));
        msfChkTo(EH_RelPrev, GetDirEntry(sidFind, FB_DIRTY, &pdeFind));

        //  Remove the found child from tree (carefully!).  We remove it by
        //  finding another entry in the tree with which to replace it.
        //    sidFind is the node we're removing
        //    sidPrev is the parent of sidFind in the child tree
        //    sidInsert is the entry which will replace sidFind

        SID sidInsert = pdeFind->GetRightSib();

        if (sidInsert == NOSTREAM)
        {
            //  sidFind has no right child, so we can patch the tree by
            //  replacing sidFind with the sidFind's left child

            sidInsert = pdeFind->GetLeftSib();

            //  set the inserted to the right color
            if (sidInsert != NOSTREAM)
            {
                //  we always set the inserted node to black (since the
                //  parent may not exist (we could be inserting at the
                //  root)
                msfChkTo(EH_RelPrev, SetColorBlack(sidInsert));
            }
        }
        else
        {
            CDirEntry *pdeInsert;

            //  The node we're removing has a right child

            msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_NONE, &pdeInsert));

            //  sidPrev, sidFind, and sidInsert are all held

            if (pdeInsert->GetLeftSib() != NOSTREAM)
            {
                //  sidFind's right child has a left child.
                //  sidInsert will be the leftmost child of sidFind's right
                //    child (which will keep the tree ordered)

                //  sidPreInsert will be the leftmost child's parent int the
                //    child tree

                SID sidPreInsert = sidInsert;
                CDirEntry *pdePreInsert = pdeInsert;

                //  we wait to assign sidInsert so we can clean up
                msfChkTo(EH_RelIns, GetDirEntry(pdePreInsert->GetLeftSib(),
						FB_NONE, &pdeInsert));

                sidInsert = pdePreInsert->GetLeftSib();

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  find the leftmost child of sidFind's right child

                SID sidLeft;
                while ((sidLeft = pdeInsert->GetLeftSib()) != NOSTREAM)
                {
                    ReleaseEntry(sidPreInsert);

                    //  sidPrev, sidFind, sidInsert are held

                    sidPreInsert = sidInsert;
                    pdePreInsert = pdeInsert;

                    //  we wait to assign sidInsert to we can clean up
                    msfChkTo(EH_RelIns, GetDirEntry(sidLeft,
						    FB_NONE, &pdeInsert));

                    sidInsert = sidLeft;
                }

                msfAssert(pdeInsert->GetLeftSib() == NOSTREAM);

                //  sidPrev, sidFind, sidPreInsert, sidInsert are held

                //  Remove sidInsert so we can reinsert it in place of sidFind.
                //  We remove sidInsert (which has no left child) by making
                //  sidPreInsert's left child point to sidInsert's right child

                ReleaseEntry(sidPreInsert);
                msfChkTo(EH_RelIns, GetDirEntry(sidPreInsert, FB_DIRTY,
				                &pdePreInsert));

                pdePreInsert->SetLeftSib(pdeInsert->GetRightSib());
                ReleaseEntry(sidPreInsert);

                //  sidPrev, sidFind, sidInsert is held

                //  Begin to replace sidFind with sidInsert by setting the
                //  right child of sidInsert to be the right child of sidFind

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
						 &pdeInsert));
                pdeInsert->SetRightSib(pdeFind->GetRightSib());
            }
            else
            {
                //  sidFind's right child has no left child, so we can patch
		//  the tree by making sidFind's right child's left child
                //  point to sidFind's left child, and then replacing sidFind
                //  with sidFind's right child.

                ReleaseEntry(sidInsert);
                msfChkTo(EH_RelFind, GetDirEntry(sidInsert, FB_DIRTY,
				                 &pdeInsert));

                //  fall through to do the work
            }

            pdeInsert->SetColor(DE_BLACK);

            //  Complete sidInsert's patching by setting its left child to be
            //  the left child of sidFind

            pdeInsert->SetLeftSib(pdeFind->GetLeftSib());

EH_RelIns:
            ReleaseEntry(sidInsert);
        }

        if (SUCCEEDED(sc))
        {
            if (sidPrev == sidParent)
            {
                //  We're removing the first child;  update sidParent.
                //  We made sure sidInsert is black (above).
                pdePrev->SetChild(sidInsert);
            }
            else if (iCmp < 0)
            {
                pdePrev->SetLeftSib(sidInsert);
            }
            else
                pdePrev->SetRightSib(sidInsert);

            //  make sure sidFind is clean

            pdeFind->SetLeftSib(NOSTREAM);
            pdeFind->SetRightSib(NOSTREAM);
        }
    }

EH_RelFind:
    ReleaseEntry(sidFind);

EH_RelPrev:
    ReleaseEntry(sidPrev);

Err:
    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectory::NameCompare, private static
//
//  Synopsis:   name ordering function for child tree
//
//  Arguments:  [pdfn1] - name 1
//              [pdfn2] - name 2
//
//  Requires:   One but not both names cannot may have zero length.
//
//  Returns:    <0 if name 1 < name 2
//               0 if name 1 = name 2
//              >0 if name 1 > name 2
//
//  Algorithm:  To speed the comparision (and to allow zero length names),
//              we first compare the name lengths.  (Shorter names are "less"
//              than longer names).  If the lengths are equal we compare the
//              strings.
//
//  History:    16-Nov-92 AlexT     Created
//
//
//--------------------------------------------------------------------------

int CDirectory::NameCompare(CDfName const *pdfn1, CDfName const *pdfn2)
{
    int iCmp = pdfn1->GetLength() - pdfn2->GetLength();

    if (iCmp == 0)
    {
	msfAssert(pdfn1->GetLength() != 0);
#ifndef FLAT
#ifdef CASE_SENSITIVE
	iCmp = memcmp(pdfn1->GetBuffer(), pdfn2->GetBuffer(), pdfn1->GetLength());
#else
	iCmp = dfwcsnicmp((WCHAR *)pdfn1->GetBuffer(),
	    (WCHAR *)pdfn2->GetBuffer(), pdfn1->GetLength());
#endif
#else
        iCmp = dfwcsnicmp((WCHAR *)pdfn1->GetBuffer(),
                          (WCHAR *)pdfn2->GetBuffer(), pdfn1->GetLength());
#endif
    }

    return(iCmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectory::SetColorBlack, private
//
//  Synopsis:   Sets a directory entry to black
//
//  Arguments:  [sid] -- SID of entry to be modified
//
//  Returns:    S_OK or error
//
//  History:    19-Jan-93   AlexT       Created.
//
//  Notes:      Added to reduce code size
//
//--------------------------------------------------------------------------

SCODE CDirectory::SetColorBlack(const SID sid)
{
    SCODE sc;

    CDirEntry *pde;
    msfChk(GetDirEntry(sid, FB_DIRTY, &pde));

    pde->SetColor(DE_BLACK);
    ReleaseEntry(sid);

 Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\msfhead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:   msfhead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    23-Oct-92 AlexT    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}

#include <ole2.h>

#include <propset.h>
#include <propapi.h>
#include <propstm.hxx>

#include <dfexcept.hxx>
#include <msf.hxx>
#include <header.hxx>
#include <vect.hxx>
#include <page.hxx>
#include <vectfunc.hxx>
#include <fat.hxx>
#include <dir.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\header.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       header.cxx
//
//  Contents:   Code to manage MSF header
//
//  Classes:    Defined in header.hxx
//
//  History:    11-Dec-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dfver.h>

CMSFHeaderData::CMSFHeaderData(USHORT uSectorShift)
{
    msfAssert((CSECTFATREAL != CSECTFAT) || (sizeof(CMSFHeaderData) == HEADERSIZE));
    _uSectorShift = uSectorShift;
    _uMiniSectorShift = MINISECTORSHIFT;
    _ulMiniSectorCutoff = MINISTREAMSIZE;

    _clid = IID_NULL;

    _uByteOrder = 0xFFFE;

    _uMinorVersion = rmm;
    _uDllVersion = uSectorShift > SECTORSHIFT512 ? rmjlarge : rmj;

    for (SECT sect = 0; sect < CSECTFAT; sect ++)
    {
        _sectFat[sect] = FREESECT;
    }

    _csectDif = 0;
    _sectDifStart = ENDOFCHAIN;

    _csectFat = 1;
    _sectFat[0] = SECTFAT;
    _sectDirStart = SECTDIR;

    _csectMiniFat = 0;
    _sectMiniFatStart = ENDOFCHAIN;

    _signature = 0;
    _usReserved = 0;
    _ulReserved1 = 0;
    _csectDir = (uSectorShift > SECTORSHIFT512) ? 1 : 0;

    //  Write DocFile signature
    memcpy(abSig, SIGSTG, CBSIGSTG);
}


CMSFHeader::CMSFHeader(USHORT uSectorShift)
        :_hdr(uSectorShift)
{
    //We set this to dirty here.  There are three cases in which a header
    //  can be initialized:
    //1)  Creating a new docfile.
    //2)  Converting a flat file to a docfile.
    //3)  Opening an existing file.
    //
    //We have a separate CMStream::Init* function for each of these cases.
    //
    //We set the header dirty, then explicitly set it clean in case 3
    //   above.  For the other cases, it is constructed dirty and we
    //   want it that way.
    
    _fDirty = TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMSFHeader::Validate, public
//
//  Synopsis:   Validate a header.
//
//  Returns:    S_OK if header is valid.
//
//  History:    21-Aug-92 	PhilipLa	Created.
//              27-Jan-93       AlexT           Changed to final signature
//
//--------------------------------------------------------------------------

SCODE CMSFHeader::Validate(VOID) const
{
    SCODE sc;
    USHORT uShift;

    sc = CheckSignature((BYTE *)_hdr.abSig);
    if (sc == S_OK)
    {
        uShift = GetSectorShift();

        // Check file format verson number
        if (GetDllVersion() > rmjlarge)
            return STG_E_OLDDLL;
	
        // check for unreasonably large or zero SectorShift
        if ((uShift > MAXSECTORSHIFT) ||
            (uShift == 0))	   
        {    	
            return STG_E_DOCFILECORRUPT;
        }
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\msf.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       msf.cxx
//
//  Contents:   Entry points for MSF DLL
//
//  Classes:    None.
//
//  Functions:  DllMuliStreamFromStream
//              DllConvertStreamToMultiStream
//              DllReleaseMultiStream
//              DllGetScratchMultiStream
//              DllIsMultiStream
//
//  History:    17-Aug-91   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <handle.hxx>
#include <filelkb.hxx>
#include <ole.hxx>
#include <entry.hxx>
#include <smalloc.hxx>

//+-------------------------------------------------------------------------
//
//  Function:   DllMultiStreamFromStream
//
//  Synopsis:   Create a new multistream instance from an existing stream.
//              This is used to reopen a stored multi-stream.
//
//  Effects:    Creates a new CMStream instance
//
//  Arguments:  [ppms] -- Pointer to storage for return of multistream
//              [pplstStream] -- Stream to be used by multi-stream for
//                           reads and writes
//		[dwFlags] - Startup flags
//
//  Returns:    STG_E_INVALIDHEADER if signature on pStream does not
//                  match.
//              STG_E_UNKNOWN if there was a problem in setup.
//              S_OK if call completed OK.
//
//  Algorithm:  Check the signature on the pStream and on the contents
//              of the pStream.  If either is a mismatch, return
//              STG_E_INVALIDHEADER.
//              Create a new CMStream instance and run the setup function.
//              If the setup function fails, return STG_E_UNKNOWN.
//              Otherwise, return S_OK.
//
//  History:    17-Aug-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllMultiStreamFromStream(IMalloc *pMalloc,
                               CMStream **ppms,
			       ILockBytes **pplstStream,
			       DWORD dwStartFlags,
                               DFLAGS df)
{
    SCODE sc;
    CMStream *temp;


    BOOL fConvert = ((dwStartFlags & RSF_CONVERT) != 0);
    BOOL fDelay = ((dwStartFlags & RSF_DELAY) != 0);
    BOOL fTruncate = ((dwStartFlags & RSF_TRUNCATE) != 0);
    BOOL fCreate = ((dwStartFlags & RSF_CREATE) != 0);


    msfDebugOut((DEB_ITRACE,"In DllMultiStreamFromStream\n"));

#ifdef USE_NOSCRATCH
    msfMem(temp = new (pMalloc)
           CMStream(pMalloc, pplstStream,
                    FALSE,
                    (df & ~DF_NOSCRATCH),
                    (dwStartFlags & RSF_SECTORSIZE_MASK) ?
                         (USHORT)((dwStartFlags & RSF_SECTORSIZE_MASK) >> 12) :
                         SECTORSHIFT512));
#else
    msfMem(temp = new (pMalloc)
           CMStream(pMalloc, pplstStream,
                    FALSE,
                    (dwStartFlags & RSF_SECTORSIZE_MASK) ?
                         (USHORT)((dwStartFlags & RSF_SECTORSIZE_MASK) >> 12) :
                         SECTORSHIFT512));
#endif //USE_NOSCRATCH    

    STATSTG stat;
    HRESULT hr;
    IFileLockBytes *pfl;

    //  ILockBytes::Stat is an expensive operation;  for our own file
    //  stream we call our faster GetSize method.

    if (SUCCEEDED((*pplstStream)->QueryInterface(IID_IFileLockBytes,
                                                    (void**) &pfl)))
    {
        msfAssert(pfl != NULL &&
               aMsg("ILockBytes::QueryInterface succeeded but returned NULL"));
        hr = pfl->GetSize(&stat.cbSize);
        pfl->Release();
    }
    else
        hr = (*pplstStream)->Stat(&stat, STATFLAG_NONAME);
    msfHChk(hr);

    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",ULIGetLow(stat.cbSize)));

    do
    {
        if ((stat.cbSize.QuadPart != 0) && (fConvert))
        {
            msfChk(temp->InitConvert(fDelay));
            break;
        }

        if ((stat.cbSize.QuadPart == 0 && fCreate) || (fTruncate))
        {
            msfChk(temp->InitNew(fDelay, stat.cbSize));
            break;
        }
        msfChk(temp->Init());
    }
    while (FALSE);

    *ppms = temp;

    msfDebugOut((DEB_ITRACE,"Leaving DllMultiStreamFromStream\n"));

    if (fConvert && (stat.cbSize.QuadPart != 0) && !fDelay)
    {
        return STG_S_CONVERTED;
    }

    return S_OK;

Err:
#if !defined(MULTIHEAP)
     //take the mutex here instead of in the allocator.
     g_smAllocator.GetMutex()->Take(DFM_TIMEOUT); 
#endif
     delete temp;
#if !defined(MULTIHEAP)
     g_smAllocator.GetMutex()->Release();
#endif
     return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllReleaseMultiStream
//
//  Synopsis:   Release a CMStream instance
//
//  Effects:    Deletes a multi-stream instance
//
//  Arguments:  [pms] -- pointer to object to be deleted
//
//  Returns:    S_OK.
//
//  Modifies:   Deletes the object pointed to by pMultiStream
//
//  Algorithm:  Delete the passed in pointer.
//
//  History:    17-Aug-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void DllReleaseMultiStream(CMStream *pms)
{
    msfDebugOut((DEB_ITRACE,"In DllReleaseMultiStream(%p)\n",pms));
#if !defined(MULTIHEAP)
    //take the mutex here instead of in the allocator.
    g_smAllocator.GetMutex()->Take(DFM_TIMEOUT); 
#endif
    delete pms;
#if !defined(MULTIHEAP)
    g_smAllocator.GetMutex()->Release();
#endif
   
    msfDebugOut((DEB_ITRACE,"Out DllReleaseMultiStream()\n"));
}



//+-------------------------------------------------------------------------
//
//  Function:   DllGetScratchMultiStream
//
//  Synopsis:   Get a scratch multistream for a given LStream
//
//  Effects:    Creates new MStream instance and new handle
//
//  Arguments:  [ppms] -- pointer to location in which root
//                   	  handle is to be returned.
//              [pplstStream] -- pointer to LStream object to be used
//              [pmsMaster] - Multistream to pattern scratch after
//
//  Returns:    S_OK if call completed OK.
//              STG_E_UNKNOWN if there was a problem in setup.
//
//  Algorithm:  *Finish This*
//
//  History:    08-Jan-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllGetScratchMultiStream(CMStream **ppms,
#ifdef USE_NOSCRATCH                               
                               BOOL fIsNoScratch,
#endif                               
                               ILockBytes **pplstStream,
                               CMStream *pmsMaster)
{
    msfDebugOut((DEB_ITRACE,"In DllGetScratchMultiStream(%p,%p,%p)\n",ppms,pplstStream,pmsMaster));
    SCODE sc;
    ULARGE_INTEGER uliZero;

    CMStream *temp = NULL;

#ifdef USE_NOSCRATCH                               
    msfMem(temp = new (pmsMaster->GetMalloc())
                      CMStream(pmsMaster->GetMalloc(), pplstStream,
                               TRUE,
                               (fIsNoScratch) ? DF_NOSCRATCH : 0,
                               SCRATCHSECTORSHIFT));
#else
    msfMem(temp = new (pmsMaster->GetMalloc())
                      CMStream(pmsMaster->GetMalloc(), pplstStream,
                               TRUE,
                               SCRATCHSECTORSHIFT));
#endif                               

    ULISetHigh(uliZero, 0);
    ULISetLow(uliZero, 0);
    msfChk(temp->InitNew(FALSE, uliZero));
    *ppms = temp;

    msfDebugOut((DEB_ITRACE,"Out DllGetScratchMultiStream()\n"));
    return S_OK;

Err:
#if !defined(MULTIHEAP)
    //take the mutex here instead of in the allocator
    g_smAllocator.GetMutex()->Take(DFM_TIMEOUT);
#endif
    delete temp;
#if !defined(MULTIHEAP)
    g_smAllocator.GetMutex()->Release();
#endif
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllIsMultiStream
//
//  Synopsis:   Check a given Lstream to determine if it is a valid
//              multistream.
//
//  Arguments:  [plst] -- Pointer to lstream to check
//
//  Returns:    S_OK if lstream is a valid multistream
//              STG_E_UNKNOWN otherwise
//
//  History:    20-Feb-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllIsMultiStream(ILockBytes *plst)
{
    SCODE sc;
    CMSFHeader *phdr;
    ULONG ul;
    ULONG ulSectorSize = HEADERSIZE;

    IFileLockBytes *pfl;
    if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes, (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }

    // CMSFHeader can be larger than a sector due to its dirty flag
    ul = ulSectorSize < sizeof(CMSFHeader) ? sizeof(CMSFHeader) : ulSectorSize;
    GetSafeBuffer(ul, ul, (BYTE **) &phdr, &ul);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(
            ulOffset,
            phdr->GetData(),
            ulSectorSize,
            &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err, STG_E_UNKNOWN);
    }

    msfChk(phdr->Validate());

Err:
    FreeBuffer((BYTE *) phdr);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllSetCommitSig
//
//  Synopsis:   Set the commit signature on a given lstream, for use
//              in OnlyIfCurrent support
//
//  Arguments:  [plst] -- Pointer to the LStream to modify.
//              [sig] -- New signature
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    22-Apr-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllSetCommitSig(ILockBytes *plst, DFSIGNATURE sig)
{
    SCODE sc;
    CMSFHeader *phdr;
    ULONG ul;
    ULONG ulSectorSize = HEADERSIZE;

    IFileLockBytes *pfl;
    if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes, (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }
    // CMSFHeader can be larger than a sector due to its dirty flag
    ul = ulSectorSize < sizeof(CMSFHeader) ? sizeof(CMSFHeader) : ulSectorSize;
    GetSafeBuffer(ul, ul, (BYTE **) &phdr, &ul);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(
            ulOffset,
            phdr->GetData(),
            ulSectorSize,
            &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err, STG_E_UNKNOWN);
    }

    msfChk(phdr->Validate());

    phdr->SetCommitSig(sig);

    msfHChk(plst->WriteAt(ulOffset,
                          phdr->GetData(),
                          ulSectorSize,
                          &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err,STG_E_UNKNOWN);
    }

Err:
    FreeBuffer((BYTE *) phdr);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:   DllGetCommitSig
//
//  Synopsis:   Get the commit signature from an lstream
//
//  Arguments:  [plst] -- Pointer to lstream to be operated on
//              [psig] -- Storage place for signature return
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:
//
//  History:    22-Apr-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE DllGetCommitSig(ILockBytes *plst, DFSIGNATURE *psig)
{
    CMSFHeader *phdr;
    SCODE sc;
    ULONG ul;
    ULONG ulSectorSize = HEADERSIZE;

    IFileLockBytes *pfl;
    if (SUCCEEDED(plst->QueryInterface(IID_IFileLockBytes, (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }

    // CMSFHeader can be larger than a sector due to its dirty flag
    ul = ulSectorSize < sizeof(CMSFHeader) ? sizeof(CMSFHeader) : ulSectorSize;
    GetSafeBuffer(ul, ul, (BYTE **) &phdr, &ul);

    ULONG ulTemp;

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    msfHChk(plst->ReadAt(
            ulOffset,
            phdr->GetData(),
            ulSectorSize,
            &ulTemp));

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err, STG_E_UNKNOWN);
    }
    msfChk(phdr->Validate());
    *psig = phdr->GetCommitSig();

Err:
    FreeBuffer((BYTE *) phdr);
    return sc;
}


#if DBG == 1

//The following is a private function so I can set the debug level easily.
VOID SetInfoLevel(ULONG x)
{

#if DBG == 1
    msfInfoLevel=x;
    _SetWin4InfoLevel(0xFFFFFFFF);
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\coguid.h ===
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\pbstream.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       pbstream.cxx
//
//  Contents:   CPubStream code
//
//  Classes:
//
//  Functions:
//
//  History:    16-Jan-92   PhilipLa    Created.
//              12-Jun-96   MikeHill    Renamed FlushNoException to Write,
//                                      and removed the Commit.
//              21-Jun-96   MikeHill    Fixed an Assert.
//              01-Jul-96   MikeHill    - Removed Win32 SEH from PropSet code.
//                                      - Added propset byte-swapping support.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <sstream.hxx>
#include <publicdf.hxx>
#include <pbstream.hxx>
#include <tstream.hxx>
#include <docfilep.hxx>
#include <reserved.hxx>
#include <propdbg.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::CPubStream, public
//
//  Synopsis:   Constructor
//
//  History:    16-Jan-92       PhilipLa        Created
//
//----------------------------------------------------------------------------

CPubStream::CPubStream(CPubDocFile *ppdf,
                       DFLAGS df,
                       CDfName const *pdfn)
#pragma warning(disable: 4355)
    : _PubMappedStream(this)
#pragma warning(default: 4355)
{
    _psParent = NULL;
    _df = df;
    _ppdfParent = P_TO_BP(CBasedPubDocFilePtr, ppdf);
    _cReferences = 1;
    _dfn.Set(pdfn->GetLength(), pdfn->GetBuffer());
    _ppdfParent->AddChild(this);
    _fDirty = FALSE;
    _sig = CPUBSTREAM_SIG;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::Init, public
//
//  Synopsis:   Init function
//
//  Arguments:  [psParent] - Stream in transaction set
//              [dlLUID] - LUID
//
//  History:    16-Jan-92       PhilipLa        Created
//
//----------------------------------------------------------------------------

void CPubStream::Init(PSStream *psParent,
                      DFLUID dlLUID)
{
    _psParent = P_TO_BP(CBasedSStreamPtr, psParent);
    _luid = dlLUID;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::~CPubStream, public
//
//  Synopsis:   Destructor
//
//  History:    16-Jan-92       PhilipLa        Created
//
//----------------------------------------------------------------------------

CPubStream::~CPubStream()
{
    msfAssert(_cReferences == 0);
    _sig = CPUBSTREAM_SIGDEL;

    if (SUCCEEDED(CheckReverted()))
    {
        if (_ppdfParent != NULL)
            _ppdfParent->ReleaseChild(this);
        if (_psParent)
        {
            _psParent->Release();
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPubStream::Release, public
//
//  Synopsis:   Release a pubstream object
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Delete 'this' - all real work done by destructor.
//
//  History:    24-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CPubStream::vRelease(VOID)
{
    LONG lRet;
    
    msfDebugOut((DEB_ITRACE,"In CPubStream::Release()\n"));
    msfAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);

    msfAssert(!P_TRANSACTED(_df));

    if (lRet == 0)
    {
        _PubMappedStream.Cleanup();
        delete this;
    }
    msfDebugOut((DEB_ITRACE,"Out CPubStream::Release()\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CPubStream::Stat, public
//
//  Synopsis:   Fills in a stat buffer
//
//  Arguments:  [pstatstg] - Buffer
//              [grfStatFlag] - stat flags
//
//  Returns:    S_OK or error code
//
//  Modifies:   [pstatstg]
//
//  History:    24-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

SCODE CPubStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CPubStream::Stat(%p)\n", pstatstg));
    msfChk(CheckReverted());

    msfAssert(_ppdfParent != NULL);
    pstatstg->grfMode = DFlagsToMode(_df);

    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;

    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        msfMem(pstatstg->pwcsName = (WCHAR *)TaskMemAlloc(_dfn.GetLength()));
        memcpy(pstatstg->pwcsName, _dfn.GetBuffer(), _dfn.GetLength());
    }

#ifdef LARGE_STREAMS
    ULONGLONG cbSize;
#else
    ULONG cbSize;
#endif
    _psParent->GetSize(&cbSize);
    pstatstg->cbSize.QuadPart = cbSize;

    msfDebugOut((DEB_ITRACE, "Out CPubStream::Stat\n"));

Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CPubStream::RevertFromAbove, public
//
//  Synopsis:   Parent has asked for reversion
//
//  History:    29-Jan-92       DrewB   Created
//
//---------------------------------------------------------------

void CPubStream::RevertFromAbove(void)
{
    msfDebugOut((DEB_ITRACE, "In  CPubStream::RevertFromAbove:%p()\n", this));
    _df |= DF_REVERTED;
    _psParent->Release();
#if DBG == 1
    _psParent = NULL;
#endif
    msfDebugOut((DEB_ITRACE, "Out CPubStream::RevertFromAbove\n"));
}

//+--------------------------------------------------------------
//
//  Member:         CPubStream::FlushBufferedData, public
//
//  Synopsis:   Flush out the property buffers.
//
//  History:    5-May-1995      BillMo Created
//
//---------------------------------------------------------------

SCODE CPubStream::FlushBufferedData(int recursionlevel)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CPubStream::FlushBufferedData:%p()\n", this));

    _PubMappedStream.Flush(&sc);

    msfDebugOut((DEB_ITRACE, "Out CPubStream::FlushBufferedData\n"));

    propDbg((DEB_ITRACE, "CPubStream(%08X):FlushBufferedData returns %08X\n",
        this, sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPubStream::Commit, public
//
//  Synopsis:   Flush stream changes to disk in the direct case.
//
//  Arguments:  None
//
//  Returns:    Appropriate status code
//
//  History:    12-Jan-93       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CPubStream::Commit(DWORD dwFlags)
{
    SCODE sc = S_OK;
    msfDebugOut((DEB_ITRACE, "In  CPubStream::Commit:%p()\n", this));

    msfAssert(!P_TRANSACTED(_df));
    if (SUCCEEDED(sc = CheckReverted()))
    {
        if (P_WRITE(_df))
        {
            if (_ppdfParent->GetTransactedDepth() == 0)
            {
                //Parent is direct, so call commit on it and return.
                sc = _ppdfParent->GetBaseMS()->Flush(FLUSH_CACHE(dwFlags));
            }
            SetClean();
        }
    }
    msfDebugOut((DEB_ITRACE, "Out CPubStream::Commit\n"));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Open
//
//  Synopsis:   Opens mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Gets the size of the underlying stream and reads it
//              into memory so that it can be "mapped." 
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Open(IN VOID *powner, OUT LONG *phr)
{
    *phr = S_OK;
    olAssert(!_fLowMem);

    // If given a pointer to the owner of this mapped stream,
    // save it.  This could be NULL (i.e., when called from
    // ReOpen).

    if( NULL != powner  )
        _powner = P_TO_BP( CBasedBytePtr, ((BYTE*) powner) );

    if (_pb == NULL)
    {
        VOID *pv;
#ifdef LARGE_STREAMS
        ULONGLONG ulSize;
#else
        ULONG ulSize;
#endif

        _cbUsed = 0;

        *phr = _pst->GetSize(&ulSize);
        if (*phr != S_OK)
            goto Throw;

        if (ulSize > CBMAXPROPSETSTREAM)
        {
            *phr = STG_E_INVALIDHEADER;
            goto Throw;
        }

        _cbOriginalStreamSize = (ULONG) ulSize;
        _cbUsed = _cbOriginalStreamSize;

        pv = GetMalloc()->Alloc(_cbOriginalStreamSize);

        if (pv == NULL)
        {
            pv = g_ReservedMemory.LockMemory();
            if( NULL == pv )
            {
                *phr = E_OUTOFMEMORY;
                goto Throw;
            }

            _fLowMem = TRUE;
        }
        _pb = P_TO_BP(CBasedBytePtr, ((BYTE*)pv));
        *phr = _pst->ReadAt(0, 
                      pv, 
                      _cbOriginalStreamSize, 
                      &_cbUsed);

#if BIGENDIAN==1
        // Notify our owner that we've read in new data.
        if (*phr == S_OK && _powner != NULL && 0 != _cbUsed)
        {
            *phr = RtlOnMappedStreamEvent( BP_TO_P(VOID*, _powner), pv, _cbUsed );
        }
#endif

        if (*phr != S_OK)
        {
            if (_fLowMem)
                g_ReservedMemory.UnlockMemory();
            else
                GetMalloc()->Free(pv);

            _pb = NULL;
            _cbUsed = 0;
            _fLowMem = FALSE;
            goto Throw;
        }

    }

    propDbg((DEB_ITRACE, "CPubStream(%08X):Open returns normally\n", this));
    return;

Throw:

    propDbg((DEB_ERROR, "CPubStream(%08X):Open exception returns %08X\n", this, *phr));

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Flush
//
//  Synopsis:   Flush the mapped Stream to the underlying Stream,
//              and Commit that Stream.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Flush(OUT LONG *phr)
{
    // Write out any data we have cached to the Stream.
    *phr = Write();

    // Commite the Stream.
    if( SUCCEEDED(*phr) )
    {
        *phr = _pst->Commit(STGC_DEFAULT);
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Close
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Does nothing because the object may be mapped in
//              another process.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Close(OUT LONG *phr)
{
    // Write the changes.  We don't need to Commit them,
    // they will be implicitely committed when the 
    // Stream is Released.

    *phr = Write();

    if( FAILED(*phr) )
    {
        propDbg((DEB_ERROR, "CPubStream(%08X)::Close exception returns %08X\n", this, *phr));
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::ReOpen
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Combined open and map.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::ReOpen(IN OUT VOID **ppv, OUT LONG *phr)
{
    *ppv = NULL;

    Open(NULL,  // Unspecified owner.
         phr);

    if( SUCCEEDED(*phr) )
        *ppv = BP_TO_P(VOID*, _pb); 

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Quiesce
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Meaningless for docfile mapped stream.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Quiesce(VOID)
{
    olAssert(_pb != NULL); 
    DfpdbgCheckUnusedMemory();
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Map
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Return the address of the "mapping" buffer.
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Map(BOOLEAN fCreate, VOID **ppv) 
{ 
    olAssert(_pb != NULL); 
    DfpdbgCheckUnusedMemory();
    *ppv = BP_TO_P(VOID*, _pb); 
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Unmap
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:      Unmapping is merely zeroing the pointer.  We don't
//              flush because that's done explicitly by the 
//              CPropertyStorage class.
//              
//
//--------------------------------------------------------------------

VOID CPubMappedStream::Unmap(BOOLEAN fFlush, VOID **pv)
{
    DfpdbgCheckUnusedMemory();
    *pv = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Write
//
//  Synopsis:   Writes a mapped view of an exposed Stream to the
//              underlying Stream.  Used by RtlCreatePropertySet et al.
//
//  Notes:      The Stream is not commited.  To commit the Stream, in
//              addition to writing it, the Flush method should be used.
//              The Commit is omitted so that it can be skipped in
//              the Property Set Close path, thus eliminating a
//              performance penalty.
//
//--------------------------------------------------------------------

HRESULT CPubMappedStream::Write ()
{
    HRESULT hr;
    ULONG cbWritten;

    if (!_fDirty)
    {
        propDbg((DEB_ITRACE, "CPubStream(%08X):Flush returns with not-dirty\n", this));

        return S_FALSE;  // flushing a stream which isn't a property stream
                         // this could be optimized by propagating a 'no property streams'
                         // flag up the storage hierachy such that FlushBufferedData is
                         // not even called for non-property streams.
    }

    olAssert( _pst != NULL );
    olAssert( _pb != NULL );
    olAssert( _powner != NULL );

#if BIGENDIAN==1
    // Notify our owner that we're about to perform a Write.
    hr = RtlOnMappedStreamEvent( BP_TO_P(VOID*, _powner), BP_TO_P(VOID *, _pb), _cbUsed );
    if( S_OK != hr ) goto Exit;
#endif

    hr = _pst->WriteAt(0, BP_TO_P(VOID *, _pb), _cbUsed, &cbWritten);
    if( S_OK != hr ) goto Exit;

#if BIGENDIAN==1
    // Notify our owner that we're done with the Write.
    hr = RtlOnMappedStreamEvent( BP_TO_P(VOID*, _powner), BP_TO_P(VOID *, _pb), _cbUsed );
    if( S_OK != hr ) goto Exit;
#endif

    if (_cbUsed < _cbOriginalStreamSize)
    {
        // if the stream is shrinking, this is a good time to do it.
        hr = _pst->SetSize(_cbUsed);
        if( S_OK != hr ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    if (hr == S_OK || hr == STG_E_REVERTED)
    {
        _fDirty = FALSE;
    }

    propDbg((DEB_ITRACE, "CPubStream(%08X):Flush %s returns hr=%08X\n",
        this, hr != S_OK ? "exception" : "", hr));

    return hr;

}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::GetSize
//
//  Synopsis:   Returns size of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//--------------------------------------------------------------------

ULONG CPubMappedStream::GetSize(OUT LONG *phr)
{
    *phr = S_OK;

    if (_pb == NULL)
        Open(NULL,  // Unspecified owner
             phr);

    if( SUCCEEDED(*phr) )
    {
        olAssert(_pb != NULL); 
        DfpdbgCheckUnusedMemory();
    }
    
    return _cbUsed;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::SetSize
//
//  Synopsis:   Sets size of "map." Called by 
//              NtCreatePropertySet et al.
//
//  Arguments:  [cb] -- requested size.
//		[fPersistent] -- FALSE if expanding in-memory read-only image
//              [ppv] -- new mapped address.
//
//  Signals:    Not enough disk space.
//
//  Notes:      In a low memory situation we may not be able to
//              get the requested amount of memory.  In this
//              case we must fall back on disk storage as the
//              actual map.
//
//--------------------------------------------------------------------

VOID
CPubMappedStream::SetSize(ULONG cb, IN BOOLEAN fPersistent, VOID **ppv, OUT LONG *phr)
{
    VOID *pv;

    *phr = S_OK;
    olAssert(cb != 0);    
    
    DfpdbgCheckUnusedMemory();

    //
    // if we are growing the data, we should grow the stream
    //

    if (fPersistent && cb > _cbUsed)
    {
        *phr = _pst->SetSize(cb);
        if (*phr != S_OK)
            goto Throw;
    }
    
    if (!_fLowMem)
    {
        pv = GetMalloc()->Realloc(BP_TO_P(VOID*, _pb), cb);
        
        if (pv == NULL)
        {
            // allocation failed: we need to try using a backup mechanism for
            // more memory.
            // copy the data to the global reserved chunk... we will wait until
            // someone else has released it.  it will be released on the way out
            // of the property code.

            pv = g_ReservedMemory.LockMemory();
            if( NULL == pv )
            {
                *phr = E_OUTOFMEMORY;
                goto Throw;
            }

            _fLowMem = TRUE;

            if (NULL != BP_TO_P(BYTE*, _pb))
	    {
                memcpy(pv, BP_TO_P(VOID*, _pb), _cbUsed);
	    }
            GetMalloc()->Free(BP_TO_P(VOID*, _pb));
        }
	_pb = P_TO_BP(CBasedBytePtr, ((BYTE*)pv));
	*ppv = pv;
    }
    else
    {
        *ppv = BP_TO_P(VOID*, _pb);
    }       
            
    _cbUsed = cb;
    DfpdbgFillUnusedMemory();

Throw:

    propDbg((DEB_ITRACE, "CPubStream(%08X):SetSize %s returns hr=%08X\n",
        this, *phr != S_OK ? "exception" : "", *phr));

}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Lock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//              the exposed stream has enforced the locking.
//
//              we use the lock to indicate whether the object is
//              dirty
//
//--------------------------------------------------------------------

NTSTATUS CPubMappedStream::Lock(BOOLEAN fExclusive)
{
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::Unlock
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS CPubMappedStream::Unlock(VOID)
{
    // if at the end of the properties set/get call we have the low
    // memory region locked, we flush to disk.
    HRESULT hr = S_OK;

    if (_fLowMem)
    {
        Flush(&hr);

        g_ReservedMemory.UnlockMemory();
        _pb = NULL;
        _cbUsed = 0;
        _fLowMem = FALSE;
        propDbg((DEB_ITRACE, "CPubStream(%08X):Unlock low-mem returns NTSTATUS=%08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CPubMappedStream::QueryTimeStamps(STATPROPSETSTG *pspss, BOOLEAN fNonSimple) const
{
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QueryModifyTime
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::QueryModifyTime(OUT LONGLONG *pll) const
{
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QuerySecurity
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::QuerySecurity(OUT ULONG *pul) const
{
    return(FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::QueryTimeStamps
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::IsWriteable() const
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::SetChangePending
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBG == 1
BOOLEAN CPubMappedStream::SetChangePending(BOOLEAN f)
{
    BOOLEAN fOld = _fChangePending;
    _fChangePending = f;
    return(_fChangePending);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::IsNtMappedStream
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

#if DBG == 1
BOOLEAN CPubMappedStream::IsNtMappedStream(VOID) const
{
    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::GetHandle
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

HANDLE CPubMappedStream::GetHandle(VOID) const
{
    return(INVALID_HANDLE_VALUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::SetModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

VOID CPubMappedStream::SetModified(OUT LONG *phr)
{
    _fDirty = TRUE;
    *phr = S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::IsModified
//
//  Synopsis:   Operates on mapped view of exposed stream. Called by 
//              NtCreatePropertySet et al.
//
//  Notes:
//
//--------------------------------------------------------------------

BOOLEAN CPubMappedStream::IsModified(VOID) const
{
    return _fDirty;
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::DfpdbgFillUnusedMemory
//
//--------------------------------------------------------------------

#if DBG == 1
VOID CPubMappedStream::DfpdbgFillUnusedMemory(VOID)
{

    if (_pb == NULL)
        return;

    BYTE * pbEndPlusOne = BP_TO_P(BYTE*, _pb) + BytesCommitted();

    for (BYTE *pbUnused = BP_TO_P(BYTE*, _pb) + _cbUsed;
         pbUnused < pbEndPlusOne;
         pbUnused++)
    {
        *pbUnused = (BYTE)(ULONG_PTR)pbUnused;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPubMappedStream::DfpdbgCheckUnusedMemory
//
//--------------------------------------------------------------------

VOID CPubMappedStream::DfpdbgCheckUnusedMemory(VOID)
{

    if (_pb == NULL)
        return;

    if (_cbUsed == 0)
        return;

    BYTE * pbEndPlusOne = BP_TO_P(BYTE*, _pb) + BytesCommitted();

    for (BYTE *pbUnused = BP_TO_P(BYTE*, _pb + _cbUsed) ;
         pbUnused < pbEndPlusOne;
         pbUnused ++)
    {
        olAssert(*pbUnused == (BYTE)(ULONG_PTR)pbUnused);
    }
}

#endif    // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\sstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           sstream.cxx
//
//  Contents:       Stream operations for Mstream project
//
//  Classes:        None. (defined in sstream.hxx)
//
//  History:        18-Jul-91   PhilipLa    Created.
//                  24-Apr-92   AlexT       Small object support
//
//--------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dirfunc.hxx>
#include <sstream.hxx>
#include <dl.hxx>
#include <tstream.hxx>
#include <time.h>
#include <mread.hxx>

#define DEB_STREAM (DEB_ITRACE | 0x00020000)




//+--------------------------------------------------------------
//
//  Member:	CDirectStream::CDirectStream, public
//
//  Synopsis:	Empty object constructor
//
//  Arguments:  [dl] - LUID
//
//  History:	25-Aug-92	DrewB	Created
//
//---------------------------------------------------------------

CDirectStream::CDirectStream(DFLUID dl)
: PSStream(dl)
{
    _pdlHolder = NULL;
    _cReferences = 0;
#ifdef SECURE_STREAMS
    _ulSize = 0;
    _ulHighWater = 0;
#endif    
    _sig = CDIRECTSTREAM_SIG;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::~CDirectStream, public
//
//  Synopsis:   CDirectStream destructor
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectStream::~CDirectStream()
{
    msfAssert(_cReferences == 0);
    _sig = CDIRECTSTREAM_SIGDEL;
#ifdef SECURE_STREAMS
    if (_ulSize > _ulHighWater)
    {
        ClearSects(_ulHighWater, _ulSize);
    }
#endif    
}


//+--------------------------------------------------------------
//
//  Member:	CDirectStream::InitSystem, public
//
//  Synopsis:	Initializes special system streams like the ministream
//
//  Arguments:	[pms] - Multistream
//		[sid] - SID
//		[cbSize] - size
//
//  History:	25-Aug-92	DrewB	Created
//
//---------------------------------------------------------------

void CDirectStream::InitSystem(CMStream *pms,
			       SID sid,
#ifdef LARGE_STREAMS
			       ULONGLONG cbSize)
#else
			       ULONG cbSize)
#endif
{
    _stmh.Init(pms, sid);
    _ulSize = _ulOldSize = cbSize;

    _stmc.Init(pms, sid, this);

#ifdef SECURE_STREAMS
#ifndef SECURE_BUFFER
    //If SECURE_BUFFER is defined, we've already zeroed this in the
    //  multistream.
    memset(s_bufSecure, SECURECHAR, MINISTREAMSIZE);
#endif    
    _ulHighWater = cbSize;
#endif
    
    AddRef();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::Init, public
//
//  Synopsis:   CDirectStream constructor
//
//  Arguments:  [pstgh] - Parent
//		[pdfn] - Name of entry
//		[fCreate] - Create or get
//
//  Returns:	Appropriate status code
//
//  History:    18-Jul-91   PhilipLa    Created.
//              02-Jan-92   PhilipLa    Converted to use handle.
//		25-Aug-92   DrewB	Converted to use StgHandle
//
//--------------------------------------------------------------------------

SCODE CDirectStream::Init(
        CStgHandle *pstgh,
        CDfName const *pdfn,
        BOOL const fCreate)
{
    SCODE sc;

    if (fCreate)
        sc = pstgh->CreateEntry(pdfn, STGTY_STREAM, &_stmh);
    else
        sc = pstgh->GetEntry(pdfn, STGTY_STREAM, &_stmh);

    if (SUCCEEDED(sc))
    {
	sc = _stmh.GetSize(&_ulSize);
	_ulOldSize = _ulSize;
#ifdef SECURE_STREAMS
        _ulHighWater = (fCreate) ? 0 : _ulSize;
#endif
        
#if DBG == 1
        if (SUCCEEDED(sc))
        {
            //Make sure that the stream is sane.
            SCODE sc2;
            CFat *pfat;
            ULONG cbSector;
            ULONG cSect;
            ULONG cSectReal;
            SECT sectStart;
        
            if (_ulSize < MINISTREAMSIZE)
            {
                cbSector = MINISECTORSIZE;
                pfat = _stmh.GetMS()->GetMiniFat();
            }
            else
            {
                cbSector = _stmh.GetMS()->GetSectorSize();
                pfat = _stmh.GetMS()->GetFat();
            }
        
            cSect = (ULONG)((_ulSize + cbSector - 1) / cbSector);
            sc2 = _stmh.GetMS()->GetDir()->GetStart(
                _stmh.GetSid(),
                &sectStart);
            if (SUCCEEDED(sc2))
            {
                sc2 = pfat->GetLength(sectStart, &cSectReal);
                if (SUCCEEDED(sc2))
                {
                    msfAssert((cSect == cSectReal) &&
                              aMsg("Chain length incorrect at init."));
                }
            }
        }
#endif        
        
        if (SUCCEEDED(sc))
            AddRef();
        _stmc.Init(_stmh.GetMS(), _stmh.GetSid(), this);
    }
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::ReadAt, public
//
//  Synposis:   Reads binary data from a linear single stream
//
//  Arguments:  [ulOffset] -- Position to be read from
//
//              [pBuffer] -- Pointer to the area into which the data
//                           will be read.
//              [ulCount] --  Indicates the number of bytes to be read
//              [pulRetval] -- Area into which return value will be stored
//
//  Returns:    Error Code of parent MStream call
//
//  Algorithm:  Calculate start and end sectors and offsets, then
//              pass call up to parent MStream.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              16-Aug-91   PhilipLa    Converted to use multi-sect read
//              23-Aug-91   PhilipLa    Brought into compliance with protocol
//              11-Sep-91   PhilipLa    Moved most functionality up
//                                      to MStream level.
//              24-Apr-92   AlexT       Move everything to MStream::MRead
//              09-Jun-92   PhilipLa    Added fUnconverted support
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------

SCODE CDirectStream::ReadAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::ReadAt(%lu,%p,%lu)\n",
                           ulOffset,pBuffer,ulCount));

    SCODE sc = S_OK;

    CMStream *pms = _stmh.GetMS();

    *pulRetval = 0;

    if (NULL == pms)
        return STG_E_UNKNOWN;

    //  Check for offset beyond stream size and zero count

    if ((ulOffset >= _ulSize) || (0 == ulCount))
    {
        return S_OK;
    }

    if (ulOffset + ulCount > _ulSize)
    {
        msfDebugOut((DEB_ITRACE,"Truncating Read: ulOffset = %lu, ulCount = %lu, _ulSize = %lu\n",
                                ulOffset,ulCount,_ulSize));
        ulCount = (ULONG)(_ulSize - ulOffset);
    }

#ifdef DELAYCONVERT
    if (pms->IsUnconverted())
    {
	ULARGE_INTEGER ulTmp;
	ULISet32(ulTmp, ulOffset);
        return DfGetScode(pms->GetILB()->ReadAt(ulTmp, pBuffer, ulCount,
                                                pulRetval));
    }
#else
    msfAssert(!pms->IsUnconverted());
#endif

    //  Stream is stored in ministream if size < MINISTREAMSIZE
    //  and this is not a scratch stream.

#ifdef SECURE_STREAMS
    if (ulOffset + ulCount > _ulHighWater)
    {
        if (ulOffset > _ulHighWater)
        {
            //Zero the whole buffer and return.
            memset(pBuffer, SECURECHAR, ulCount);
            *pulRetval = ulCount;
            return S_OK;
        }

        //Need to read into part of the buffer, then zero fill the
        //  rest.
        if (FAILED(sc = ReadAt(ulOffset,
                               pBuffer,
                               _ulHighWater - ulOffset,
                               pulRetval)) ||
            (*pulRetval != _ulHighWater - ulOffset))
        {
            return sc;
        }
        memset((BYTE *)pBuffer + *pulRetval,
               SECURECHAR,
               ulCount - (_ulHighWater - ulOffset));
        
        *pulRetval = ulCount;
        return S_OK;
    }
#endif    
            

    SID sid = _stmh.GetSid();
    CFat *pfat = pms->GetFat();
    USHORT cbSector = pms->GetSectorSize();
    USHORT uShift = pms->GetSectorShift();
    USHORT uMask = pms->GetSectorMask();



    if ((_ulSize < MINISTREAMSIZE) &&
        (!pms->IsScratch()) &&
        (sid != SIDMINISTREAM))
    {
        msfAssert(sid <= MAXREGSID);

        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        uMask = cbSector - 1;
        pfat = pms->GetMiniFat();
    }

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    ULONG total = 0;

    ULONG cSect = end - start + 1;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        ULONG cSeg;
        SSegment segtab[CSEG + 1];

        msfChk(_stmc.Contig(start,
                            FALSE,
                            (SSegment STACKBASED *) segtab,
                            cSect,
                            &cSeg));
        msfAssert(cSeg <= CSEG);
        
        USHORT oend = cbSector - 1;
        for (USHORT iseg = 0; iseg < cSeg;)
        {
            msfDebugOut((DEB_ITRACE,"Segment:  (%lu,%lu)\n",segtab[iseg].sectStart,segtab[iseg].cSect));
            SECT sectStart = segtab[iseg].sectStart;
            ULONG i = segtab[iseg].cSect;
            if (i > cSect)
                i = cSect;
            
            cSect -= i;
            start += i;

            iseg++;
            if (cSect == 0)
                oend = oEnd;

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            ULONG bytecount;
            SCODE sc;

            if (pms->GetMiniFat() == pfat)
            {
                sc = pms->GetMiniStream()->CDirectStream::ReadAt(
                                            (sectStart << uShift) + offset,
                                             pBuffer, ulSize,
					    (ULONG STACKBASED *)&bytecount);
            }
            else
            {
                ULARGE_INTEGER ulOffset;
#ifdef LARGE_DOCFILE
                ulOffset.QuadPart = ConvertSectOffset(sectStart,offset,uShift);
#else
                ULISet32(ulOffset, ConvertSectOffset(sectStart,offset,uShift));
#endif
                sc = DfGetScode(pms->GetILB()->ReadAt(ulOffset,
                                                      (BYTE *)pBuffer, ulSize,
                                                      &bytecount));
            }

            total += bytecount;
            if ((0 == cSect) || (FAILED(sc)))
            {
                *pulRetval = total;
                msfDebugOut((DEB_ITRACE,
                    "Leaving CDirectStream::ReadAt()=>%lu, ret is %lu\n",
                     sc,*pulRetval));
                return sc;
            }

            pBuffer = (BYTE HUGEP *)pBuffer + bytecount;
            offset = 0;
        }
    }

    msfDebugOut((DEB_ERROR,"In CDirectStream::ReadAt - reached end of function\n"));
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::Write, public
//
//  Synposis:   Writes binary data from a linear single stream
//
//  Effects:    Modifies _ulSeekPos.  May cause modification in parent
//                  MStream.
//
//  Arguments:  [pBuffer] -- Pointer to the area from which the data
//                           will be written.
//              [ulCount] --  Indicates the number of bytes to be written
//              [pulRetval] -- Pointer to area in which number of bytes
//                              will be returned
//
//  Returns:    Error code of MStream call.
//
//  Algorithm:  Calculate sector and offset for beginning and end of
//              write, then pass call up to MStream.
//
//
//  History:    18-Jul-91   PhilipLa    Created.
//              16-Aug-91   PhilipLa    Converted to use multi-sect write
//              23-Aug-91   PhilipLa    Brought into compliance with protocol
//              11-Sep-91   PhilipLa    Moved most functionality up
//                                      to MStream level.
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------

SCODE CDirectStream::WriteAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID const HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::WriteAt(%lu,%p,%lu)\n",ulOffset,pBuffer,ulCount));

    *pulRetval = 0;

    if (0 == ulCount)
        return S_OK;

    SCODE sc;

    CMStream *pms;
    pms = _stmh.GetMS();

    if (NULL == pms)
        return STG_E_UNKNOWN;

    if (ulOffset + ulCount > _ulSize)
    {
        if (_ulSize > MINISTREAMSIZE)
        {
        }
        else
        {
            msfChk(SetSize(ulOffset + ulCount));
        }
    }

    //  This should be an inline call to MWrite

#ifdef SECURE_STREAMS    
    if (ulOffset > _ulHighWater)
    {
        ClearSects(_ulHighWater, ulOffset);
    }
#endif
    
    msfChk(pms->MWrite(
            _stmh.GetSid(),
            (_ulSize < MINISTREAMSIZE),
            ulOffset,
            pBuffer,
            ulCount,
            &_stmc,
            pulRetval));

    msfDebugOut((DEB_ITRACE,"Leaving CDirectStream::WriteAt()==>%lu, ret is %lu\n",sc,*pulRetval));

Err:
#ifdef SECURE_STREAMS
    if ((*pulRetval > 0 ) &&
        (ulOffset + *pulRetval > _ulHighWater))
    {
        _ulHighWater = ulOffset + *pulRetval;
    }
#endif
    
    if (*pulRetval > 0 &&
        ulOffset + *pulRetval > _ulSize)
    {
        SCODE scSet;

        _ulSize = ulOffset + *pulRetval;

        scSet = pms->GetDir()->SetSize(_stmh.GetSid(), _ulSize);
        if (SUCCEEDED(sc) && FAILED(scSet))
        {
            sc = scSet;
        }
    }
#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif
    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::SetSize, public
//
//  Synposis:   Set the size of a linear stream
//
//  Effects:    Modifies _ulSize.  May cause change in parent MStream.
//
//  Arguments:  [ulNewSize] -- New size for stream
//
//  Returns:    Error code returned by MStream call.
//
//  Algorithm:  Pass call up to parent.
//
//  History:    29-Jul-91   PhilipLa    Created.
//              14-May-92   AlexT       Add small object support
//
//  Notes:      When changing the size of a stream, we need to be concerned
//              with the cases where each stream is either zero length,
//  stored in the ministream, or stored in a regular stream.  The following
//  grid shows the actions that we must perform in each case:
//
//                      New Sector Count (Cn)
//
//                      0               S               L
//      O       ------------------------------------------------
//      l       | same size     | allocate Cn   | allocate Cn
//      d   0   |  (fast out)   | small sectors | large sectors
//              ------------------------------------------------
//      S       | small         | Co > Cn:      | cbCopy = cbOld
//      e   S   |  setchain(Cn) |  small        | large allocate Cn
//      c       |               |   setchain(Cn)| copy bytes
//      t       |               | Cn > Co:      | small setchain(0)
//      o       |               |  extend small | copy data
//      r       ------------------------------------------------
//          L   | large         | cbCopy = cbNew| Co > Cn:
//      C       |  setchain(Cn) | small         |  large setchain(Cn)
//      o       |               |  allocate Cn  | Cn > Co:
//      u       |               | copy bytes    |  extend large
//      n       |               | large         |
//      t       |               |  setchain(0)  |
//              |               | copy data     |
//     (Co)     ------------------------------------------------
//
//  where S indicates small sectors, L indicates large sectors, and Cx
//  represents count of sectors.  For example, the middle box represents
//  doing a setsize on a stream which is currently stored in a small
//  stream in Co small sectors and which will end up in a large stream
//  with Cn sectors.
//
//---------------------------------------------------------------------------

#ifdef LARGE_STREAMS
SCODE CDirectStream::SetSize(ULONGLONG cbNewSize)
#else
SCODE CDirectStream::SetSize(ULONG cbNewSize)
#endif
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::SetSize(%lu)\n",cbNewSize));

    SCODE sc = S_OK;
    BYTE *pBuf = NULL;
    SID sid = _stmh.GetSid();
    CMStream *pms = _stmh.GetMS();
    msfAssert(sid <= MAXREGSID);

    if (NULL == pms)
        return STG_E_UNKNOWN;

    CDirectory *pdir = pms->GetDir();

    if (_ulSize == cbNewSize)
    {
        return S_OK;
    }

#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif

    USHORT cbpsOld = pms->GetSectorSize();
                                        //  Count of Bytes Per Sector
    USHORT cbpsNew = cbpsOld;
    CFat *pfatOld = pms->GetFat();
    CFat *pfatNew = pfatOld;

    if ((!pms->IsScratch()) && (SIDMINISTREAM != sid))
    {
        //  This is not a scratch DocFile, nor is this stream the ministream;
        //  check if this stream is and/or will be stored in the ministream.

        if (cbNewSize < MINISTREAMSIZE)
        {
            cbpsNew = MINISECTORSIZE;
            pfatNew = pms->GetMiniFat();
        }

        if (_ulSize < MINISTREAMSIZE)
        {
            cbpsOld = MINISECTORSIZE;
            pfatOld = pms->GetMiniFat();
        }
    }

    ULONG csectOld = (ULONG)((_ulSize + cbpsOld - 1) / cbpsOld);
    ULONG csectNew = (ULONG)((cbNewSize + cbpsNew - 1) / cbpsNew);

    msfAssert(sid <= MAXREGSID);
    SECT sectstart, sectOldStart;
    msfChk(pdir->GetStart(sid, &sectstart));

    //Save start sector so we can free it later.
    sectOldStart = sectstart;

    msfDebugOut((DEB_ITRACE,"pdbOld size is %lu\n\tSid is %lu\n\tStart is %lu\n",
                _ulSize,sid,sectstart));
    msfDebugOut((DEB_ITRACE,"CMStream::SetSize() needs %lu %u byte sectors\n",
                 csectNew, cbpsNew));
    msfDebugOut((DEB_ITRACE,"SetSize() currently has %lu %u byte sectors\n",
                 csectOld, cbpsOld));

    ULONG cbCopy;
    cbCopy = 0;
    if (cbpsOld != cbpsNew)
    {
        //  Sector sizes are different, so we'll copy the data
        msfAssert((cbNewSize > _ulSize ? _ulSize : cbNewSize) < 0x10000);
        cbCopy = (ULONG)(cbNewSize > _ulSize ? _ulSize : cbNewSize);
    }


    if (cbCopy > 0)
    {
        msfDebugOut((DEB_ITRACE,"Copying between fat and minifat\n"));
        GetSafeBuffer(cbCopy, cbCopy, &pBuf, &cbCopy);
        msfAssert((pBuf != NULL) && aMsg("Couldn't get scratch buffer"));

        ULONG ulRetVal;
        sc = ReadAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal);
#ifdef SECURE_STREAMS
        //Part of the buffer may have gunk in it, so clear it out.
        if (_ulHighWater < cbCopy)
        {
            memset(pBuf + _ulHighWater, SECURECHAR, cbCopy - _ulHighWater);
        }
#endif
        
        if ((FAILED(sc)) ||
            ((ulRetVal != cbCopy) ? (sc = STG_E_UNKNOWN) : 0))
        {
            msfErr(Err, sc);
        }
#ifdef SECURE_STREAMS
        ClearSects(_ulHighWater, _ulSize);
        _ulHighWater = cbNewSize;
#endif

        //The cache is no longer valid, so empty it.
        _stmc.Empty();

        msfChk(_stmc.Allocate(pfatNew, csectNew, &sectstart));
    }
    else
    {
        SECT dummy;

        if ((csectOld > csectNew))
        {
#ifdef SECURE_STREAMS
            ClearSects(_ulHighWater, _ulSize);
            _ulHighWater = cbNewSize;
#endif
            if (0 == csectNew)
            {
                //Note:  We need to set the start sect in the directory
                //  first in case the SetChainLength call fails part way
                //  through, which would leave this directory entry pointing
                //  to a FREESECT.
                SECT sectOldStart = sectstart;
                msfChk(pdir->SetStart(sid, ENDOFCHAIN));
                sectstart = ENDOFCHAIN;
                msfChk(pfatOld->SetChainLength(sectOldStart, 0));
            }
            else
            {
                msfChk(pfatOld->SetChainLength(sectstart, csectNew));
            }

            //If this turns out to be a common case, we can
            //   sometimes keep the cache valid here.
            _stmc.Empty();
        }
        else if (0 == csectOld)
        {
            msfChk(_stmc.Allocate(pfatNew, csectNew, &sectstart));
        }
        else if (csectNew > csectOld)
        {
            ULONG start = csectNew - 1;
            msfChk(_stmc.GetESect(start, &dummy));
        }
    }


    //  Resize the ministream, if necessary
    if (((MINISECTORSIZE == cbpsOld) && (csectOld > 0)) ||
        ((MINISECTORSIZE == cbpsNew) && (csectNew > 0)))
    {
        msfChk(pms->SetMiniSize());
    }

    msfChk(pms->SetSize());

    //If we fail on either of these operations and cbCopy != 0,
    //   we will have data loss.  Ick.

    //  Optimization - we only set the start sector if it has changed.

    if (sectstart != sectOldStart)
    {
        msfChk(pdir->SetStart(sid, sectstart));
    }

    //If we fail here, we're in big trouble.
    msfChk(pdir->SetSize(sid, cbNewSize));

    _ulSize = cbNewSize;
#ifdef SECURE_STREAMS
    if (_ulHighWater > _ulSize)
    {
        _ulHighWater = _ulSize;
    }
#endif    

    if (cbCopy > 0)
    {
        //  now copy the data
        ULONG ulRetVal;

        msfAssert(cbCopy <= _ulSize);
        msfChk(WriteAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal));

        if (ulRetVal != cbCopy)
        {
            msfErr(Err, STG_E_UNKNOWN);
        }

        msfChk(pfatOld->SetChainLength(sectOldStart, 0));
        msfChk(pms->SetMiniSize());
        msfChk(pms->SetSize());
    }

#ifdef SECURE
    if (((csectNew > csectOld) || (cbCopy > 0)) &&
        ((cbNewSize & (cbpsNew - 1)) != 0))
    {
        SECT sectLast;
        msfChk(_stmc.GetSect(csectNew - 1, &sectLast));

        msfVerify(SUCCEEDED(pms->SecureSect(
                sectLast,
                cbNewSize,
                (cbNewSize < MINISTREAMSIZE) && (sid != SIDMINISTREAM))));
    }
#endif //SECURE
#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif
Err:
#ifdef SECURE_STREAMS
    if (_ulHighWater > _ulSize)
    {
        _ulHighWater = _ulSize;
    }
#endif    
    //  Optimization - avoid calling FreeBuffer (which will end up calling
    //  out to CompObj.DLL) when pBuf is NULL (common case).
    if (pBuf != NULL)
        FreeBuffer(pBuf);

    if (FAILED(sc))
        _stmc.Empty();

    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::BeginCommitFromChild, public
//
//  Synopsis:   Begin a commit from a child stream
//
//  Arguments:  [ulSize] -- Size of child stream
//              [pDelta] -- Pointer to delta list
//              [pstChild] - Child
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CDirectStream::BeginCommitFromChild(
#ifdef LARGE_STREAMS
        ULONGLONG ulSize,
#else
        ULONG ulSize,
#endif
        CDeltaList *pDelta,
        CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::BeginCommitFromChild:%p("
                 "%lu, %p, %p)\n", this, ulSize, pDelta, pstChild));

//    msfDebugOut((DEB_ITRACE,"MultiStrean is %p\nStream name is: %ws\n",_stmh.GetMS(),((_stmh.GetMS()))->GetName(_stmh.GetSid())));

    SCODE sc = S_OK;
    ULONG temp;
    BYTE *pb = NULL;

    _pdlHolder = P_TO_BP(CBasedDeltaListPtr, pDelta);

    // Copy-on-write will back out these changes if we fail

#ifdef USE_NOSCRATCH    
    //For no-scratch mode, we commit very differently than we do regularly,
    //   unless this commit is somehow involving the minifat.

    if ((pDelta->IsNoScratch()) &&
        (ulSize >= MINISTREAMSIZE) &&
        ((_ulSize >= MINISTREAMSIZE) || (_ulSize == 0)) &&
        (!pDelta->IsEmpty()))
    {
        USHORT cbSector = pDelta->GetDataSectorSize();
        SECT sectEnd = (SECT)((ulSize + cbSector - 1) / cbSector);
        SECT sectLast = ENDOFCHAIN;
        
        //We update our size and directory first so the stream cache
        //  code knows which fat to get to.
        _ulOldSize = _ulSize;
        _ulSize = ulSize;
        msfChk(_stmh.GetMS()->GetDir()->SetSize(_stmh.GetSid(), ulSize));

        if (_ulOldSize > _ulSize)
        {
            //We need to truncate the chain.
            SECT sectStart;
            _stmh.GetMS()->GetDir()->GetStart(_stmh.GetSid(), &sectStart);
            _stmh.GetMS()->GetFat()->SetChainLength(sectStart, sectEnd);
            _stmc.Empty();
        }
        
        for (ULONG i = 0; i < sectEnd; i++)
        {
            SECT sectDirty;
            SECT sectOld;
            SECT sectNext;
            
            //For each sector, chain the old sector with the
            //existing new one.
            msfChk(pDelta->GetMap(i, DL_READ, &sectDirty));
            if (sectDirty != ENDOFCHAIN)
            {
                if (i > 0)
                {
                    CFat *pfat = _stmh.GetMS()->GetFat();
                    
                    msfChk(_stmc.GetSect(i - 1, &sectLast));
                    msfAssert(sectLast != ENDOFCHAIN);

                    msfChk(pfat->GetNext(sectLast, &sectOld));
                    msfChk(pfat->SetNext(sectLast, sectDirty));
                    if (sectOld != ENDOFCHAIN)
                    {
                        msfChk(pfat->GetNext(sectOld, &sectNext));
                        msfChk(pfat->SetNext(sectOld, FREESECT));
                    }
                    else
                    {
                        sectNext = ENDOFCHAIN;
                    }
                    msfChk(pfat->SetNext(sectDirty, sectNext));
                    msfChk(_stmc.EmptyRegion(i, i));
                }
                else
                {
                    CFat *pfat = _stmh.GetMS()->GetFat();
                    CDirectory *pdir = _stmh.GetMS()->GetDir();
                    
                    sectNext = ENDOFCHAIN;
                    
                    msfChk(pdir->GetStart(_stmh.GetSid(), &sectLast));
                    if (sectLast != ENDOFCHAIN)
                    {
                        msfChk(pfat->GetNext(sectLast, &sectNext));
                        msfChk(pfat->SetNext(sectLast, FREESECT));
                    }
                    msfChk(pfat->SetNext(sectDirty, sectNext));
                    msfChk(pdir->SetStart(_stmh.GetSid(), sectDirty));
                    msfChk(_stmc.EmptyRegion(i, i));
                }
            }
        }
#ifdef SECURE_STREAMS
        _ulHighWater = _ulSize;
#endif
        
#if DBG == 1
        //Make sure that the stream is sane.
#ifdef LARGE_STREAMS
        ULONGLONG ulDirSize;
#else
        ULONG ulDirSize;
#endif
        ULONG cSect;
        ULONG cSectReal;
        SECT sectStart;

        _stmh.GetMS()->GetDir()->GetSize(_stmh.GetSid(), &ulDirSize);
        cSect = (ULONG)((ulDirSize + cbSector - 1) / cbSector);
        _stmh.GetMS()->GetDir()->GetStart(_stmh.GetSid(), &sectStart);
        _stmh.GetMS()->GetFat()->GetLength(sectStart, &cSectReal);
        msfAssert((cSect == cSectReal) &&
                  aMsg("Chain length incorrect after commit."));
#endif        
    }

    else
    {
#endif //USE_NOSCRATCH
        
        //  Note:  It's critical that we do this SetSize first (since we
        //  use our scratch buffer below and SetSize can potentially also
        //  use the scratch buffer.

        msfChk(SetSize(ulSize));
        _ulOldSize = _ulSize;

        msfAssert(pDelta != NULL);

        if (!pDelta->IsEmpty())
        {
            USHORT cbSector = pDelta->GetDataSectorSize();
            USHORT uSectorShift = pDelta->GetDataSectorShift();
            
            ULONG cbActualSize = 0;
            ULONG cbMaxSects = 15;

		    GetSafeBuffer(cbSector, cbSector * cbMaxSects, &pb, &cbActualSize);

            BYTE *pbcurrent = pb;
	    
	    	msfAssert((pb != NULL) && aMsg("Couldn't get scratch buffer"));
            cbMaxSects = cbActualSize / cbSector;

            OFFSET oEnd;
            oEnd = (OFFSET)((_ulSize - 1) % cbSector) + 1;	   

            SECT sectEnd;
            sectEnd = (SECT)((_ulSize + cbSector - 1) / cbSector);

            ULONG ulOffset;
            ILockBytes *pilbDirty;
	    
	    	SECT sectBeginRead  = ENDOFCHAIN;  //the first sector to read	
	    	SECT sectBeginWrite = ENDOFCHAIN;  //the offset of the first place to write 
	    	SECT sectDirty      = ENDOFCHAIN;  //the sector at this offset
	    	
	    	USHORT uReadCount = 0; 	   
	    
            ULARGE_INTEGER ulTmp;
            pilbDirty = pDelta->GetDataILB();
	 

            for (ulOffset = 0; ulOffset < sectEnd; ulOffset++)
            {
               
            	if (sectDirty == ENDOFCHAIN) 
		{   
			sectBeginWrite = ulOffset;
		}

            	msfChk(pDelta->GetMap(ulOffset, DL_READ, &sectDirty));

				
     		// Read will happen when we have determined there is something to read
		// and either
		// we have reached an ENDOFCHAIN
		// we have reached a non-adjacent sector
		// or we have reached the maximun amount that can be read
		if (  (uReadCount) && 
		    ( (sectDirty == ENDOFCHAIN)   		    ||
		      (sectDirty != sectBeginRead + uReadCount)     ||
		      (ulOffset - sectBeginWrite == cbMaxSects)       ))
                {	
		       msfDebugOut((DEB_ITRACE,"Reading %u sectors from sect %lu\n",
                                 uReadCount,
                                 sectBeginRead));

#ifdef LARGE_DOCFILE
                    	ulTmp.QuadPart = ConvertSectOffset(sectBeginRead, 0,
                                        uSectorShift);
#else
                        ULISet32(ulTmp, ConvertSectOffset(sectBeginRead, 0,
                                        uSectorShift));
#endif
		    			msfHChk(pilbDirty->ReadAt(
                            		ulTmp,
                            		pbcurrent,
                            		cbSector * uReadCount,
                            		(ULONG STACKBASED *)&temp));
		    
		    	pbcurrent += cbSector * uReadCount;
		    	sectBeginRead = sectDirty;
		    
		    	//reset the ReadCount now that we are done reading
		    	if (sectDirty == ENDOFCHAIN)
				uReadCount = 0;
		    	else
				uReadCount = 1;
		
		} 	

		// increment the read count
		else if (sectDirty != ENDOFCHAIN)
                {
			if (sectBeginRead == ENDOFCHAIN)
			{   
				sectBeginRead = sectDirty;
                	        uReadCount=1;
		    	}
		    	else if (sectDirty == sectBeginRead + uReadCount)
		    	{
				uReadCount++;
		    	}	
                }
		
		// Write occurs when we have something to write
		// and we have reached an ENDOFCHAIN
		// or the write buffer is full 
		if (((sectDirty == ENDOFCHAIN) &&
		     (sectBeginWrite != ulOffset)      ) ||
		     (ulOffset - sectBeginWrite == cbMaxSects) )
                {

			msfDebugOut((DEB_ITRACE,"Writing %u sectors from sect %lu\n",
                        		ulOffset - sectBeginWrite,
                            		sectBeginWrite));
			
			msfChk(WriteAt(sectBeginWrite * cbSector,
                        	        pb,
                                	cbSector * (ulOffset - sectBeginWrite),
                                   	(ULONG STACKBASED *)&temp));
				   	pbcurrent = pb;
					sectBeginWrite = ulOffset;
		}



            }
	    
	    // After loop, do last read and write
	    if (uReadCount)
	    {
#ifdef LARGE_DOCFILE
  		    ulTmp.QuadPart = ConvertSectOffset(sectBeginRead, 0, uSectorShift);
#else
            ULISet32(ulTmp, ConvertSectOffset(sectBeginRead, 0,
                                                      uSectorShift));
#endif

	        msfDebugOut((DEB_ITRACE,"END::Reading %u sectors from sect %lu\n",
                                 uReadCount,
                                 sectBeginRead));
        
		msfHChk(pilbDirty->ReadAt(
                            ulTmp,
                            pbcurrent,
                            cbSector * uReadCount,
                            (ULONG STACKBASED *)&temp));
	    
		msfDebugOut((DEB_ITRACE,"END::Writing %u sectors from sect %lu\n",
                                 ulOffset - sectBeginWrite,
                                 sectBeginWrite));

		msfChk(WriteAt(sectBeginWrite * cbSector,
                            pb,
			   // all sectors except the last one
                           (cbSector * ((ulOffset-1) -  sectBeginWrite) 
			   // last sector fragment
			   + oEnd  ),
                           (ULONG STACKBASED *)&temp));
	    }        
            
          
	}
#ifdef USE_NOSCRATCH        
    }
#endif    
    msfDebugOut((DEB_ITRACE,"Out CDirectStream::BeginCommitFromChild()\n"));

 Err:
#ifdef SECURE_STREAMS
    msfAssert(_ulHighWater <= _ulSize);
#endif
    FreeBuffer(pb);
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::EndCommitFromChild
//
//  Synopsis:   End a commit sequence from a child stream
//
//  Arguments:  [df] -- Indicates whether to commit or abort
//              [pstChild] - Child
//
//  Returns:    S_OK if call completed successfully.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CDirectStream::EndCommitFromChild(DFLAGS df,
                                       CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CDirectStream::EndCommitFromChild:%p("
                 "%lu, %p)\n", this, df, pstChild));
    if (!P_COMMIT(df))
    {
        _ulSize = _ulOldSize;
#ifdef SECURE_STREAMS
        _ulHighWater = _ulSize;
#endif        

        //Stream cache is no longer valid, so nuke it.
        _stmc.Empty();
    }

    _pdlHolder = NULL;
    msfDebugOut((DEB_ITRACE,"Out CDirectStream::EndCommitFromChild()\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::GetSize, public
//
//  Synopsis:	Gets the size of the stream
//
//  Arguments:	[pulSize] - Size return
//
//  Modifies:	[pulSize]
//
//  History:	08-May-92	DrewB	Created
//
//----------------------------------------------------------------------------

#ifdef LARGE_STREAMS
void CDirectStream::GetSize(ULONGLONG *pulSize)
#else
void CDirectStream::GetSize(ULONG *pulSize)
#endif
{
    *pulSize = _ulSize;
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::GetDeltaList, public
//
//  Synopsis:	Returns NULL, since a direct stream can never have
//              a delta list.
//
//  Arguments:	None.
//
//  Returns:	NULL
//
//  History:	30-Jul-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

CDeltaList * CDirectStream::GetDeltaList(void)
{
    return NULL;
}

#ifdef SECURE_STREAMS
//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::ClearSects, private
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	void
//
//  History:	10-Oct-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CDirectStream::ClearSects(ULONG ulStartOffset, ULONG ulEndOffset)
{
    ULONG cbBytesToWrite = ulEndOffset - ulStartOffset;
    ULONG ulOffset = ulStartOffset;
    msfAssert(ulEndOffset >= ulStartOffset);
    //Start offset must be less than high water mark, or the WriteAt
    //  will recurse.
    msfAssert(ulStartOffset <= _ulHighWater);
    
    while (cbBytesToWrite > 0)
    {
        ULONG cbWritten;
        if (FAILED(WriteAt(ulOffset,
                           s_bufSecure,
                           min(MINISTREAMSIZE, cbBytesToWrite),
                           &cbWritten)))
        {
            break;
        }
        ulOffset += cbWritten;
        cbBytesToWrite -= cbWritten;
    }
                
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\page.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	page.cxx
//
//  Contents:	Paging code for MSF
//
//  Classes:	Defined in page.hxx
//
//  Functions:	
//
//  History:	20-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop


#include <mread.hxx>
#include <filest.hxx>


#define FLUSH_MULTIPLE

//+---------------------------------------------------------------------------
//
//  Member:     CMSFPage::SetSect, public
//
//  Synopsis:   Sets the SECT for this page
//
//  History:    20-Oct-92       PhilipLa        Created
//
//----------------------------------------------------------------------------
#ifdef SORTPAGETABLE    
inline void CMSFPage::SetSect(const SECT sect)
{
    msfAssert(_pmpNext != NULL && _pmpPrev != NULL);
    
    msfAssert((_pmpPrev->_sect >= _pmpNext->_sect) || //Edge
              ((_sect >= _pmpPrev->_sect) && (_sect <= _pmpNext->_sect)));
    _sect = sect;
}
#endif    


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::IsSorted, public
//
//  Synopsis:	Return TRUE if the specified page is in the right place
//                in the list.
//
//  Arguments:	[pmp] -- Page to check
//
//  History:	13-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

inline BOOL CMSFPageTable::IsSorted(CMSFPage *pmp)
{
    //There are three cases:
    //1)  Page is first in the list.
    //2)  Page is last in the list.
    //3)  Page is in the middle of the list.

    SECT sect = pmp->GetSect();
    CMSFPage *pmpStart = BP_TO_P(CMSFPage *, _pmpStart);
    CMSFPage *pmpNext = pmp->GetNext();

    if (pmp == pmpStart)
    {
        return (sect <= pmpNext->GetSect());
    }
    if (pmpNext == pmpStart)
    {
        return (sect >= pmp->GetPrev()->GetSect());
    }
    return ((sect <= pmpNext->GetSect()) &&
            (sect >= pmp->GetPrev()->GetSect()));
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::SetSect, public
//
//  Synopsis:	Set the sector stamp on a page, and sort the list if
//              necessary.
//
//  Arguments:	[pmp] -- Pointer to page to stamp
//              [sect] -- SECT to stamp it with
//
//  Returns:	void
//
//  History:	12-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CMSFPageTable::SetSect(CMSFPage *pmp, SECT sect)
{
    msfDebugOut((DEB_ITRACE, "In  CMSFPageTable::SetSect:%p(%p, %lX)\n",
                 this,
                pmp,
                sect));
    pmp->SetSect(sect);

    //Resort list if necessary.
    if (!IsSorted(pmp))
    {
        CMSFPage *pmpTemp, *pmpStart;
        pmpStart = BP_TO_P(CMSFPage *, _pmpStart);

        if (pmpStart == pmp)
        {
            pmpStart = pmp->GetNext();
            _pmpStart = P_TO_BP(CBasedMSFPagePtr , pmpStart);
        }
        pmp->Remove();
    
        pmpTemp = pmpStart;
        while (sect > pmpTemp->GetSect())
        {
            pmpTemp = pmpTemp->GetNext();
            if (pmpTemp == pmpStart)
            {
                break;
            }
        }
        //Insert node before pmpTemp.
        pmpTemp->GetPrev()->SetNext(pmp);
        pmp->SetChain(pmpTemp->GetPrev(), pmpTemp);
        pmpTemp->SetPrev(pmp);

        if (sect <= pmpStart->GetSect())
        {
            _pmpStart = P_TO_BP(CBasedMSFPagePtr, pmp);
        }
    }
    msfAssert(IsSorted(pmp));
    
    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::SetSect\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable constructor.
//
//  Arguments:	[pmsParent] -- Pointer to multistream for this page table.
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

CMSFPageTable::CMSFPageTable(
        CMStream *const pmsParent,
        const ULONG cMinPages,
        const ULONG cMaxPages)
        : _cbSector(pmsParent->GetSectorSize()),
          _cMinPages(cMinPages), _cMaxPages(cMaxPages)
{
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);
    _cActivePages = 0;
    _cPages = 0;
    _pmpCurrent = NULL;
#ifdef SORTPAGETABLE
    _pmpStart = NULL;
#endif    
    _cReferences = 1;
#if DBG == 1
    _cCurrentPageRef = 0;
    _cMaxPageRef = 0;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPage::CMSFPage, public
//
//  Synopsis:	CMSFPage default constructor
//
//  History:	20-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
CMSFPage::CMSFPage(CMSFPage *pmp, CMSFPageTable *pmpt)
#else
CMSFPage::CMSFPage(CMSFPage *pmp)
#endif
{
    if (pmp == NULL)
    {
        SetChain(this, this);
    }
    else
    {
        SetChain(pmp->GetPrev(), pmp);
        GetPrev()->SetNext(this);
        GetNext()->SetPrev(this);
    }

#if DBG == 1
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmpt);
#endif

    SetSid(NOSTREAM);
    SetOffset(0);
//    SetSect(ENDOFCHAIN);
    //SetSect() contains assertions to verify sortedness of the list,
    //which we don't want here.
    _sect = ENDOFCHAIN;
    SetFlags(0);
    SetVector(NULL);
    _cReferences = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetNewPage, private
//
//  Synopsis:	Insert a new page into the list and return a pointer to it.
//
//  Arguments:	None.
//
//  Returns:	Pointer to new page.  Null if there was an allocation error.
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

inline CMSFPage * CMSFPageTable::GetNewPage(void)
{
#ifndef SORTPAGETABLE    
#if DBG == 1
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpCurrent), this);
#else
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpCurrent));
#endif
#else
#if DBG == 1
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpStart), this);
#else
    return new (_pmsParent->GetMalloc(), (size_t)_cbSector)
               CMSFPage(BP_TO_P(CMSFPage *, _pmpStart));
#endif
#endif //SORTPAGETABLE    
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::~CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable destructor
//
//  History:	26-Oct-92	PhilipLa	Created
//		21-Jul-95	SusiA		Modified to delete the object without
//						obtaining the mutex.  Calling functions
//						should have locked the mutex first.
//
//----------------------------------------------------------------------------

CMSFPageTable::~CMSFPageTable()
{
    if (_pmpCurrent != NULL)
    {
        CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);
        CMSFPage *pmpNext;

        while (pmp != pmp->GetNext())
        {
            pmpNext = pmp->GetNext();
            msfAssert(pmpNext != NULL &&
                      aMsg("NULL found in page table circular list."));
#if DBG == 1
            msfAssert(!pmp->IsInUse() &&
                    aMsg("Active page left at page table destruct time."));

            if (!_pmsParent->IsScratch())
            {
                //Dirty paged can be thrown away if we are unconverted or
                //   in a commit.
                if ((!_pmsParent->IsUnconverted()) &&
                    (_pmsParent->GetParentSize() == 0))
                {
                    msfAssert(!pmp->IsDirty() &&
                        aMsg("Dirty page left at page table destruct time."));
                }
            }
#endif
            pmp->~CMSFPage();
	    pmp->deleteNoMutex(pmp);
            	    
	    pmp = pmpNext;
        }
        pmp->~CMSFPage();
        pmp->deleteNoMutex(pmp);
	
	
    }
#if DBG == 1
    msfDebugOut((DEB_ITRACE,
            "Page Table Max Page Count for %s: %lu\n",
            (_pmsParent->IsScratch()) ? "Scratch" : "Base",
            _cMaxPageRef));
#endif

}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Init, public
//
//  Synopsis:	Initialize a CMSFPageTable
//
//  Arguments:	[cPages] -- Number of pages to preallocate.
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Init(void)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CMSFPageTable::Init:%p()\n", this));

    for (ULONG i = 0; i < _cMinPages; i++)
    {
        CMSFPage *pmp;

        msfMem(pmp = GetNewPage());
#ifndef SORTPAGETABLE        
        _pmpCurrent = P_TO_BP(CBasedMSFPagePtr, pmp);
#else
        _pmpStart = P_TO_BP(CBasedMSFPagePtr, pmp);
#endif        
    }
    _cPages = _cMinPages;
    _cActivePages = 0;
#ifdef SORTPAGETABLE
    _pmpCurrent = _pmpStart;
#endif

    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::Init\n"));

 Err:

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FlushPage, public
//
//  Synopsis:	Flush a page
//
//  Arguments:	[pmp] -- Pointer to page to flush
//
//  Returns:	Appropriate status code
//
//  History:	09-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FlushPage(CMSFPage *pmp)
{
    SCODE sc = S_OK;

    pmp->AddRef();

    CMStream *pms;
    pms = pmp->GetVector()->GetParent();

    //Flush the page, reset the dirty bit.

    msfAssert((pmp->GetSect() != ENDOFCHAIN) &&
            aMsg("Page location not set - don't know where to flush to."));
    msfAssert (pms != NULL);

    ULONG ulRet;

    ILockBytes *pilb;
#if DBG == 1
    if ((pmp->GetSid() == SIDFAT) && (pms->IsInCOW()))
    {
        msfDebugOut((DEB_ITRACE, "** Fat sect %lu written to %lX\n",
                pmp->GetOffset(), pmp->GetSect()));
    }
    if ((pmp->GetSid() == SIDDIF) && (pms->IsInCOW()))
    {
        msfDebugOut((DEB_ITRACE, "** DIF sect %lu written to %lX\n",
                pmp->GetOffset(), pmp->GetSect()));
    }

#endif
    ULARGE_INTEGER ul;
#ifdef LARGE_DOCFILE
    ul.QuadPart = ConvertSectOffset(
            pmp->GetSect(),
            0,
            pms->GetSectorShift());
#else
    ULISet32(ul, ConvertSectOffset(
            pmp->GetSect(),
            0,
            pms->GetSectorShift()));
#endif

    pilb = pms->GetILB();

    msfAssert(!pms->IsUnconverted() &&
            aMsg("Tried to flush page to unconverted base."));

    sc = GetScode(pilb->WriteAt(ul,
                                (BYTE *)(pmp->GetData()),
                                _cbSector,
                                &ulRet));
    if (sc == E_PENDING)
    {
        sc = STG_E_PENDINGCONTROL;
    }
    msfChk(sc);

    pmp->ResetDirty();

 Err:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetFreePage, public
//
//  Synopsis:	Return a pointer to a free page.
//
//  Arguments:	[ppmp] -- Pointer to storage for return pointer
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetFreePage(CMSFPage **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;
    if (_cPages > _cActivePages)
    {
        //We have some unused page already allocated.  Find and return it.
        pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

        do
        {
            pmp = pmp->GetNext();
        }
        while ((pmp != _pmpCurrent) && (pmp->GetSid() != NOSTREAM));

        msfAssert((pmp->GetSid() == NOSTREAM) &&
                aMsg("Expected empty page, none found."));

        *ppmp = pmp;
        _cActivePages++;
    }
    else if (_cPages == _cMaxPages)
    {
        msfMem(pmp = FindSwapPage());
        msfDebugOut((DEB_ITRACE, "Got swap page %p\n",pmp));

        msfAssert((pmp->GetVector() != NULL) &&
                aMsg("FindSwapPage returned unowned page."));

        msfDebugOut((DEB_ITRACE, "Freeing page %lu from vector %p\n",
                pmp->GetOffset(), pmp->GetVector()));


        if (pmp->IsDirty())
        {
            msfChk(FlushPage(pmp));
            msfAssert(!pmp->IsDirty() &&
                    aMsg("Page remained dirty after flush call"));
        }

        pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
        pmp->SetVector(NULL);
#endif
        *ppmp = pmp;
    }
    else
    {
        //Create a new page and return it.
        pmp = GetNewPage();
        if (pmp != NULL)
        {
            *ppmp = pmp;
            _cActivePages++;
            _cPages++;
        }
        else
        {
            msfMem(pmp = FindSwapPage());
            if (pmp->IsDirty())
            {
                msfChk(FlushPage(pmp));
                msfAssert(!pmp->IsDirty() &&
                        aMsg("Page remained dirty after flush call"));
            }
            pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
            pmp->SetVector(NULL);
#endif
            *ppmp = pmp;
        }
    }

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:  [ppv] -- Pointer to vector of page to return
//              [sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FindPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        CMSFPage **ppmp)
{
    SCODE sc;
    CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

    do
    {
        if ((pmp->GetVector() == ppv) && (pmp->GetOffset() == ulOffset))
        {
            //Bingo!

            *ppmp = pmp;
            return STG_S_FOUND;
        }

        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

    //The page isn't currently in memory.  Get a free page and
    //bring it into memory.

    msfChk(GetFreePage(&pmp));

    msfAssert((pmp->GetVector() == NULL) &&
            aMsg("Attempting to reassign owned page."));
    pmp->SetVector(ppv);
    pmp->SetSid(sid);
    pmp->SetOffset(ulOffset);
#ifdef SORTPAGETABLE
    SetSect(pmp, ENDOFCHAIN);
#else    
    pmp->SetSect(ENDOFCHAIN);
#endif
    
    *ppmp = pmp;

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:	[sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  History:	22-Oct-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        SECT sectKnown,
        CMSFPage **ppmp)
{
    SCODE sc;

    *ppmp = NULL;
    msfChk(FindPage(ppv, sid, ulOffset, ppmp));

    (*ppmp)->AddRef();

    if (sc != STG_S_FOUND)
    {
        ULONG ulRet;
        SECT sect;

        if (sectKnown != ENDOFCHAIN)
        {
            sect = sectKnown;
        }
        else
        {
            msfChk(ppv->GetParent()->GetSect(sid, ulOffset, &sect));
        }
#ifdef SORTPAGETABLE
        SetSect(*ppmp, sect);
#else        
        (*ppmp)->SetSect(sect);
#endif        

        CMStream *pms = (*ppmp)->GetVector()->GetParent();
#if DBG == 1
        if ((sid == SIDFAT) && (pms->IsInCOW()))
        {
            msfDebugOut((DEB_ITRACE, "Fat sect %lu read from %lX\n",
                    ulOffset, sect));
        }
        if ((sid == SIDDIF) && (pms->IsInCOW()))
        {
            msfDebugOut((DEB_ITRACE, "DIF sect %lu read from %lX\n",
                    ulOffset, sect));
        }

#endif

        ULARGE_INTEGER ul;
#ifdef LARGE_DOCFILE
        ul.QuadPart = ConvertSectOffset(
                (*ppmp)->GetSect(),
                0,
                pms->GetSectorShift());
#else
        ULISet32(ul, ConvertSectOffset(
                (*ppmp)->GetSect(),
                0,
                pms->GetSectorShift()));
#endif

        msfAssert(pms->GetILB() != NULL &&
                  aMsg("NULL ILockBytes - missing SetAccess?"));

        sc = GetScode(pms->GetILB()->ReadAt(ul,
                                            (BYTE *)((*ppmp)->GetData()),
                                            _cbSector,
                                            &ulRet));
        if (sc == E_PENDING)
        {
            sc = STG_E_PENDINGCONTROL;
        }
        msfChk(sc);
        
        if (ulRet != _cbSector)
        {
                //  09/23/93 - No error, but insufficient bytes read
                sc = STG_E_READFAULT;
        }
    }

Err:
    if (*ppmp != NULL)
    {
        if (FAILED(sc))
        {
            //  09/19/93 - Reset page so that we don't accidentally use it

            (*ppmp)->SetSid(NOSTREAM);
            (*ppmp)->SetOffset(0);
#ifdef SORTPAGETABLE
            SetSect(*ppmp, ENDOFCHAIN);
#else
            (*ppmp)->SetSect(ENDOFCHAIN);
#endif            
            (*ppmp)->SetFlags(0);
            (*ppmp)->SetVector(NULL);
            _cActivePages--;
        }
        (*ppmp)->Release();
    }

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::ReleasePage, public
//
//  Synopsis:	Release a given page
//
//  Arguments:	[sid] -- SID of page to release
//              [ulOffset] -- Offset of page to release
//
//  History:	28-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CMSFPageTable::ReleasePage(CPagedVector *ppv,
                                SID sid, ULONG ulOffset)
{
    SCODE sc;
    CMSFPage *pmp;

    sc = FindPage(ppv, sid, ulOffset, &pmp);

    if (SUCCEEDED(sc))
    {
        pmp->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Flush, public
//
//  Synopsis:	Flush dirty pages to disk
//
//  Returns:	Appropriate status code
//
//  History:	02-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Flush(void)
{
#ifndef SORTPAGETABLE
    SCODE sc = S_OK;

    CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

    //We use pmpLast in case FlushPage changes _pmpCurrent.
    CMSFPage *pmpLast = pmp;

    do
    {
        if ((pmp->IsDirty()) && !(pmp->IsInUse()) &&
            !(pmp->GetVector()->GetParent()->IsScratch()))
        {
            msfChk(FlushPage(pmp));
        }

        pmp = pmp->GetNext();

    }
    while (pmp != pmpLast);

 Err:
    return sc;
#else
    SCODE sc = S_OK;
    msfDebugOut((DEB_ITRACE, "In CMSFPageTable::Flush()\n"));

    CMSFPage *pmp;
    CMSFPage *pmpStart;
    BYTE *pb = NULL;
    ULONG ulBufferSize = 0;

    pmpStart = BP_TO_P(CMSFPage *, _pmpStart);
    pmp = pmpStart;
    do
    {
        CMSFPage *pmpFirst;
        CMSFPage *pmpLast;

        //Find first page that needs to be flushed.
        while (!pmp->IsFlushable())
        {
            pmp = pmp->GetNext();
            if (pmp == pmpStart)
                break;
        }

        //If we haven't hit the end of the list, then find a contiguous
        //   range of pages to flush.
        if (pmp->IsFlushable())
        {
            pmpFirst = pmp;
            //Store pointer to last page in range in pmpLast.
            while (pmp->IsFlushable())
            {
                pmpLast = pmp;
                pmp = pmp->GetNext();
                if (pmp->GetSect() != pmpLast->GetSect() + 1)
                {
                    break;
                }
            }
            //At this point, we can flush everything from pmpFirst to
            //  pmpLast, and they are all contiguous.  pmp points to the
            //  next sector after the current range.

            if (pmpFirst == pmpLast)
            {
                msfDebugOut((DEB_ITRACE,
                             "Flushing page to %lx\n",
                             pmpFirst->GetSect()));
                
                //Only one page:  Call FlushPage.
                msfChk(FlushPage(pmpFirst));
            }
            else
            {
                ULONG ulWriteSize;
                ULONG cSect;
                CMSFPage *pmpTemp;
                ULONG i;

                msfDebugOut((DEB_ITRACE,
                             "Flushing pages from %lx to %lx\n",
                             pmpFirst->GetSect(),
                             pmpLast->GetSect()));
                
                cSect = pmpLast->GetSect() - pmpFirst->GetSect() + 1;
                ulWriteSize = cSect * _cbSector;
                
                if (ulWriteSize > ulBufferSize)
                {
                    delete pb;
                    pb = new BYTE[ulWriteSize];
                    ulBufferSize = ulWriteSize;
                }

                pmpTemp = pmpFirst;
                if (pb == NULL)
                {
                    ulBufferSize = 0;
                    
                    //Low memory case - write out pages one at a time
                    for (i = 0; i < cSect; i++)
                    {
                        msfChk(FlushPage(pmpTemp));
                        pmpTemp = pmpTemp->GetNext();
                    }
                }
                else
                {
                    for (i = 0; i < cSect; i++)
                    {
                        memcpy(pb + (i * _cbSector),
                               pmpTemp->GetData(),
                               _cbSector);
                        pmpTemp = pmpTemp->GetNext();
                    }
                    //The buffer is loaded up - now write it out.
                    ULARGE_INTEGER ul;
                    ULONG cbWritten;
                    ULONG cbTotal = 0;
                    BYTE *pbCurrent = pb;
#ifdef LARGE_DOCFILE
                    ul.QuadPart = ConvertSectOffset(pmpFirst->GetSect(),
                                                  0,
                                                 _pmsParent->GetSectorShift());
#else
                    ULISet32(ul, ConvertSectOffset(pmpFirst->GetSect(),
                                                  0,
                                                 _pmsParent->GetSectorShift()));
#endif
                    while (cbTotal < ulWriteSize)
                    {
                        sc = _pmsParent->GetILB()->WriteAt(ul,
                                                       pbCurrent,
                                                       ulWriteSize - cbTotal,
                                                       &cbWritten);
                        if (sc == E_PENDING)
                        {
                            sc = STG_E_PENDINGCONTROL;
                        }
                        msfChk(sc);
                        if (cbWritten == 0)
                        {
                            msfErr(Err, STG_E_WRITEFAULT);
                        }
                        cbTotal += cbWritten;
                        pbCurrent += cbWritten;
                        ul.QuadPart += cbWritten;
                    }
                
                    //Mark all the pages as clean.
                    pmpTemp = pmpFirst;
                    for (i = 0; i < cSect; i++)
                    {
                        pmpTemp->ResetDirty();
                        pmpTemp = pmpTemp->GetNext();
                    }
                }
            }            
        }
        else
        {
            //We've hit the end of the list, do nothing.
        }
    }
    while (pmp != pmpStart);
    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::Flush() => %lX\n", sc));
Err:
    if (pb != NULL)
    {
        delete pb;
    }
    return sc;
#endif //SORTPAGETABLE    
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FreePages, public
//
//  Synopsis:	Free all the pages associated with a vector.
//
//  Arguments:	[ppv] -- Pointer to vector to free pages for.
//
//  History:	09-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CMSFPageTable::FreePages(CPagedVector *ppv)
{
    CMSFPage *pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

    do
    {
        if (pmp->GetVector() == ppv)
        {
            pmp->SetSid(NOSTREAM);
            pmp->SetVector(NULL);
            pmp->ResetDirty();
            _cActivePages--;
        }
        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindSwapPage, private
//
//  Synopsis:	Find a page to swap out.
//
//  Arguments:	None.
//
//  Returns:	Pointer to page to swap out.
//
//  History:	22-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

CMSFPage * CMSFPageTable::FindSwapPage(void)
{
#if DBG == 1
    ULONG cpInUse = 0;
#endif

    while (TRUE)
    {
        if (!_pmpCurrent->IsInUse())
        {
            DWORD dwFlags;

            dwFlags = _pmpCurrent->GetFlags();
            _pmpCurrent->SetFlags(dwFlags & ~FB_TOUCHED);
            
            CMSFPage *pmpTemp = _pmpCurrent->GetNext();
            _pmpCurrent = P_TO_BP(CBasedMSFPagePtr, pmpTemp);

            if (!(dwFlags & FB_TOUCHED))
            {
                return _pmpCurrent->GetPrev();
            }
        }
        else
        {
            CMSFPage *pmpTemp = _pmpCurrent->GetNext();
            _pmpCurrent = P_TO_BP(CBasedMSFPagePtr, pmpTemp);
        }
#if DBG == 1
        cpInUse++;
        msfAssert((cpInUse < 3 * _cPages) &&
                aMsg("No swappable pages."));
#endif

    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::CopyPage, public
//
//  Synopsis:	Copy a page in memory, returning NULL if there is
//              insufficient space for a new page without swapping.
//
//  Arguments:	[ppv] -- Pointer to vector that will own the copy.
//              [pmpOld] -- Pointer to page to copy.
//              [ppmp] -- Pointer to return value
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	04-Dec-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::CopyPage(
        CPagedVector *ppv,
        CMSFPage *pmpOld,
        CBasedMSFPagePtr *ppmp)
{
    CMSFPage *pmp;

    pmp = NULL;

    if (pmpOld != NULL)
    {
        msfAssert(!pmpOld->IsDirty() &&
                aMsg("Copying dirty page."));

        if (_cPages > _cActivePages)
        {

            //We have some unused page already allocated.  Find and return it.
            pmp = BP_TO_P(CMSFPage *, _pmpCurrent);

            do
            {
                pmp = pmp->GetNext();
            }
            while ((pmp != _pmpCurrent) && (pmp->GetSid() != NOSTREAM));


            msfAssert((pmp->GetSid() == NOSTREAM) &&
                    aMsg("Expected empty page, none found."));
            _cActivePages++;

        }
        else if (_cPages < _cMaxPages)
        {
            //Create a new page and return it.
            pmp = GetNewPage();
            if (pmp != NULL)
            {
                _cActivePages++;
                _cPages++;
            }
        }

        if (pmp != NULL)
        {
            msfAssert((pmp->GetVector() == NULL) &&
                    aMsg("Attempting to reassign owned page."));
            pmp->SetVector(ppv);
            pmp->SetSid(pmpOld->GetSid());
            pmp->SetOffset(pmpOld->GetOffset());
#ifdef SORTPAGETABLE
            SetSect(pmp, pmpOld->GetSect());
#else            
            pmp->SetSect(pmpOld->GetSect());
#endif            

            memcpy(pmp->GetData(), pmpOld->GetData(), (USHORT)_cbSector);
        }
    }

    *ppmp = P_TO_BP(CBasedMSFPagePtr, pmp);

    return S_OK;
}


#if DBG == 1

void CMSFPageTable::AddPageRef(void)
{
    msfAssert((LONG) _cCurrentPageRef >= 0);
    _cCurrentPageRef++;
    if (_cCurrentPageRef > _cMaxPageRef)
    {
        _cMaxPageRef = _cCurrentPageRef;
    }
}

void CMSFPageTable::ReleasePageRef(void)
{
    _cCurrentPageRef--;
    msfAssert((LONG) _cCurrentPageRef >= 0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\vect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	vect.cxx
//
//  Contents:	Vector common code.
//
//  Classes:	
//
//  Functions:	
//
//  History:	27-Oct-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"
#pragma hdrstop

#include <msffunc.hxx>
#include <vect.hxx>
#include <ole.hxx>
#include <entry.hxx>
#include <smalloc.hxx>


inline CVectBits * CPagedVector::GetNewVectBits(ULONG ulSize)
{
    msfAssert(ulSize > 0);
    CVectBits *pfb = NULL;

    if (ulSize <= (_HEAP_MAXREQ / sizeof(CVectBits)))
    {
        pfb = (CVectBits *) _pmsParent->GetMalloc()->Alloc(ulSize *
                                                           sizeof(CVectBits));
        if (pfb)
        {
            memset(pfb, 0, (ulSize * sizeof(CVectBits)));
        }
    }
    return pfb;
}

inline CBasedMSFPagePtr* VECT_CLASS
    CPagedVector::GetNewPageArray(ULONG ulSize)
{
    msfAssert(ulSize > 0);
    if (ulSize > (_HEAP_MAXREQ / sizeof(CMSFPage *)))
    {
        return NULL;
    }

    return (CBasedMSFPagePtr *)
        _pmsParent->GetMalloc()->Alloc(ulSize * sizeof(CMSFPage *));
}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Init, public
//
//  Synopsis:   CPagedVector initialization function
//
//  Arguments:  [ulSize] -- size of vector
//              [uFatEntries] -- number of entries in each table
//
//  Algorithm:  Allocate an array of pointer of size ulSize
//              For each cell in the array, allocate a CFatSect
//
//  History:    27-Dec-91   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE VECT_CLASS CPagedVector::Init(CMStream *pmsParent,
                                    ULONG ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));
    SCODE sc = S_OK;
    _pmsParent = P_TO_BP(CBasedMStreamPtr, pmsParent);

    CMSFPageTable *pmptTemp = _pmsParent->GetPageTable();
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmptTemp);

    msfAssert(_pmpt != NULL);

    ULONG i;

    //  We don't bother allocating more than necessary here
    _ulAllocSize = _ulSize = ulSize;

    if (_ulSize > 0)
    {
        CBasedMSFPagePtr *ampTemp;
        msfMem(ampTemp = GetNewPageArray(ulSize));
        for (i = 0; i < _ulSize; i++)
        {
            ampTemp[i] = NULL;
        }
        _amp = P_TO_BP(CBasedMSFPagePtrPtr, ampTemp);

        CVectBits *avbTemp;
        msfMem(avbTemp = GetNewVectBits(ulSize));
        _avb = P_TO_BP(CBasedVectBitsPtr, avbTemp);
    }

    msfDebugOut((DEB_ITRACE,"Out CPagedVector::CPagedVector()\n"));
    return S_OK;

Err:
    //In the error case, discard whatever vectors we were able to allocate
    //   and return S_OK.
    _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr *, _amp));
    _amp = NULL;

    _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *,_avb));
    _avb = NULL;

    return S_OK;

}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::~CPagedVector, public
//
//  Synopsis:   CPagedVector constructor
//
//  Algorithm:  Delete the pointer array.
//
//  History:    27-Oct-92   PhilipLa    Created.
//		20-Jul-95   SusiA	Changed Free to FreeNoMutex
//
//  Notes:   This function freed the SmAllocator object without first obtaining 
//	     the mutex.  Callling functions should already have the DFMutex locked.
//
//--------------------------------------------------------------------------

VECT_CLASS CPagedVector::~CPagedVector()
{
    if (_pmsParent != NULL)
    {
#ifdef MULTIHEAP
        // Free is the same as FreeNoMutex now
        _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr*, _amp));
        _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *,_avb));
#else
        g_smAllocator.FreeNoMutex(BP_TO_P(CBasedMSFPagePtr*, _amp));
        g_smAllocator.FreeNoMutex(BP_TO_P(CVectBits *, _avb));
#endif
    
    }
    else
        msfAssert(_amp == NULL && _avb == NULL &&
                  aMsg("Can't free arrays without allocator"));
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Empty, public
//
//  Synopsis:	Discard the storage associated with this vector.
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

void CPagedVector::Empty(void)
{
    if (_pmpt != NULL)
    {
        _pmpt->FreePages(this);
    }

    msfAssert(((_pmsParent != NULL) || ((_amp == NULL) && (_avb == NULL))) &&
            aMsg("Can't get to IMalloc for vector memory."));
    
    if (_pmsParent != NULL)
    {
        _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr*, _amp));
        _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *, _avb));
    }
    
    _amp = NULL;
    _avb = NULL;
    _pmpt = NULL;
    _ulAllocSize = _ulSize = 0;
    _pmsParent = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Flush, public
//
//  Synopsis:	Flush the dirty pages for this vector
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	02-Nov-92	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CPagedVector::Flush(void)
{
#ifndef SORTPAGETABLE    
    SCODE sc;
    SCODE scRet = S_OK;

    if (_ulSize > 0)
    {
        if (_amp != NULL)
        {
            for (ULONG i = 0; i < _ulSize; i++)
            {
                if ((_amp[i] != NULL) && (_amp[i]->IsDirty()))
                {
                    sc = _pmpt->FlushPage(BP_TO_P(CMSFPage *, _amp[i]));
                    if ((FAILED(sc)) && (SUCCEEDED(scRet)))
                    {
                        scRet = sc;
                    }
                }
            }
        }
        else
        {
            scRet = _pmpt->Flush();
        }
    }

    return scRet;
#else
    return S_OK;
#endif    
}


//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::GetTable, public
//
//  Synopsis:   Return a pointer to a page for the given index
//              into the vector.
//
//  Arguments:  [iTable] -- index into vector
//              [ppmp] -- Pointer to return location
//
//  Returns:    S_OK if call completed OK.
//
//  History:    27-Oct-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE VECT_CLASS CPagedVector::GetTableWithSect(
        const FSINDEX iTable,
        DWORD dwFlags,
        SECT sectKnown,
        void **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    msfAssert((_pmsParent->GetILB() != NULL) &&
            aMsg("Null ILB found on GetTable - need SetAccess call?"));

    // docfile is corrupted with an invalid iTable size
    if (iTable >= _ulSize)
    {
	msfErr(Err, STG_E_DOCFILECORRUPT);
 
    } 

    if ((_amp == NULL) || (_amp[iTable] == NULL))
    {
        if (dwFlags & FB_NEW)
        {
            //We know that the page isn't in the page table,
            //  so we can just get a free page an allocate it
            //  ourselves.

            msfChk(_pmpt->GetFreePage(&pmp));

            pmp->SetVector(this);
            pmp->SetSid(_sid);
            pmp->SetOffset(iTable);
#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, ENDOFCHAIN);
#else            
            pmp->SetSect(ENDOFCHAIN);
#endif            

            sc = STG_S_NEWPAGE;
            dwFlags = (dwFlags & ~FB_NEW) | FB_DIRTY;
        }
        else
        {
            msfChk(_pmpt->GetPage(this,
                                  _sid, iTable, sectKnown, &pmp));
            msfAssert((pmp->GetVector() == this) &&
                    aMsg("GetPage returned wrong page."));
        }


        if (_amp != NULL)
        {
            _amp[iTable] = P_TO_BP(CBasedMSFPagePtr, pmp);
        }

    }
    else
    {
        pmp = BP_TO_P(CMSFPage *, _amp[iTable]);
        msfAssert((pmp->GetVector() == this) &&
                aMsg("Cached page has wrong vector pointer"));
    }

    pmp->AddRef();

    if (((dwFlags & FB_DIRTY) && !(pmp->IsDirty())) &&
        (sc != STG_S_NEWPAGE))
    {
        //If we are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //
        //Newly created pages have to have their sect set manually
        //  _before_ being released.  This is very important.

        msfAssert(!_pmsParent->IsShadow() &&
                aMsg("Dirtying page in shadow multistream."));

        msfChkTo(Err_Rel, _pmsParent->GetFat()->QueryRemapped(pmp->GetSect()));

        if (sc == S_FALSE)
        {
#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, ENDOFCHAIN);
#else            
            pmp->SetSect(ENDOFCHAIN);
#endif            

            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, sect);
#else            
            pmp->SetSect(sect);
#endif            
        }
    }
#if DBG == 1
    else if ((pmp->IsDirty()) && (!pmp->IsInUse()) && (sc != STG_S_NEWPAGE))
    {
        msfAssert((_pmsParent->GetFat()->QueryRemapped(pmp->GetSect()) ==
                S_OK) &&
                aMsg("Found unremapped dirty page."));
    }
#endif

    pmp->SetFlags(pmp->GetFlags() | dwFlags | FB_TOUCHED);
    msfAssert((pmp->GetVector() == this) &&
            aMsg("GetTable returned wrong page."));
    *ppmp = pmp->GetData();

Err:
    return sc;

Err_Rel:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::SetDirty, public
//
//  Synopsis:	Set the dirty bit on the specified page
//
//  Arguments:	[iTable] -- Table to set bit on
//
//  History:	28-Oct-92	PhilipLa	Created
//
//  Notes:  This function is always called on a page with an
//              open reference.  Therefore, the page is
//              guaranteed to be in the page table, and that
//              FindPage call should never return an error.
//
//----------------------------------------------------------------------------

SCODE CPagedVector::SetDirty(ULONG iTable)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    msfAssert((!_pmsParent->IsShadow()) &&
            aMsg("Dirtying page in shadow."));

    if (_amp == NULL)
    {

        msfChk(_pmpt->FindPage(this, _sid, iTable, &pmp));
        msfAssert(sc == STG_S_FOUND);
        msfAssert(pmp->IsInUse() &&
                aMsg("Called SetDirty on page not in use."));
    }
    else
    {
        msfAssert(_amp != NULL);
        msfAssert(_amp[iTable] != NULL);
        pmp = BP_TO_P(CMSFPage *, _amp[iTable]);
    }

    if (!pmp->IsDirty())
    {
        //We are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //

        msfAssert(!_pmsParent->IsShadow() &&
                aMsg("Dirtying page in shadow multistream."));
        pmp->AddRef();

        msfChkTo(Err_Rel, _pmsParent->GetFat()->QueryRemapped(pmp->GetSect()));

        if (sc == S_FALSE)
        {
#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, ENDOFCHAIN);
#else            
            pmp->SetSect(ENDOFCHAIN);
#endif            

            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

#ifdef SORTPAGETABLE
            _pmpt->SetSect(pmp, sect);
#else
            pmp->SetSect(sect);
#endif            
        }

        pmp->Release();
    }
#if DBG == 1
    else
    {
        pmp->AddRef();
        sc = _pmsParent->GetFat()->QueryRemapped(pmp->GetSect());
        msfAssert((SUCCEEDED(sc)) &&
                aMsg("QueryRemapped returned error"));
        msfAssert((sc == S_OK) &&
                aMsg("QueryRemapped returned non-TRUE value."));
        pmp->Release();
    }
#endif

    pmp->SetDirty();

 Err:
    return sc;

 Err_Rel:
    pmp->Release();
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Resize, public
//
//  Synopsis:   Resize a CPagedVector
//
//  Arguments:  [ulSize] -- Size of new vector
//
//  Algorithm:  Create new pointer array of size ulSize.
//              For each entry in old array, copy the pointer over.
//
//  History:    27-Oct-92   PhilipLa    Created.
//              08-Feb-93   AlexT       Add LARGETHRESHOLD support
//
//  Notes:
//
//--------------------------------------------------------------------------

#define LARGETHRESHOLD  1024
#define VECTORBLOCK     1024    //  Must be power of 2

SCODE VECT_CLASS CPagedVector::Resize(FSINDEX ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));

    msfAssert(ulSize >= _ulSize);
    msfAssert(_ulSize <= _ulAllocSize);
    msfAssert(((VECTORBLOCK & (VECTORBLOCK - 1)) == 0) &&
              aMsg("VECTORBLOCK must be power of 2"));

    msfAssert(!((_amp == NULL) && (_avb != NULL)) &&
            aMsg("Resize precondition failed."));

    if (ulSize > _ulAllocSize)
    {
        //  We don't have room in the existing vector;  grow it
        ULONG ulNewAllocSize = ulSize;

        if (ulNewAllocSize > LARGETHRESHOLD)
        {
            //  We're dealing with a large vector;  grow it a VECTORBLOCK
            //  at a time
            ulNewAllocSize = (ulNewAllocSize + VECTORBLOCK - 1) &
                             ~(VECTORBLOCK - 1);
        }

        CBasedMSFPagePtr *amp = GetNewPageArray(ulNewAllocSize);
        CVectBits *avb = GetNewVectBits(ulNewAllocSize);

        //  Can't fail after this point

        _ulAllocSize = ulNewAllocSize;

        //  Copy over the old entries


        if ((amp != NULL) && (avb != NULL))
        {
            if ((_amp != NULL) && (_avb != NULL))
            {
                //  Both allocations succeeded
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                    avb[iamp] = _avb[iamp];
                }
            }
            else if (_amp != NULL)
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                }
            }
            else
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = NULL;
                }
            }
        }
        else
        {
            //  At least one of the allocations failed
            _pmsParent->GetMalloc()->Free(avb);
            avb = NULL;

            _pmsParent->GetMalloc()->Free(amp);
            amp = NULL;
        }

        //  Delete the old vector and put in the new one (if any).
        //  In the error case, throw away the vectors we are currently
        //  holding (since they are of insufficient size) and return S_OK.

        _pmsParent->GetMalloc()->Free(BP_TO_P(CBasedMSFPagePtr*, _amp));
        _amp = P_TO_BP(CBasedMSFPagePtrPtr, amp);

        _pmsParent->GetMalloc()->Free(BP_TO_P(CVectBits *, _avb));
        _avb = P_TO_BP(CBasedVectBitsPtr, avb);
    }

    if (_amp != NULL)
    {
        //  Initialize the new elements in the vector

        for (ULONG iamp = _ulSize; iamp < ulSize; iamp++)
            _amp[iamp] = NULL;
    }

    _ulSize = ulSize;

    msfDebugOut((DEB_ITRACE,"Out CPagedVector resize constructor\n"));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::InitCopy, public
//
//  Synopsis:   CPagedVector Init function for copying
//
//  Arguments:  [vectOld] -- Reference to vector to be copied.
//
//  Algorithm:  *Finish This*
//
//  History:    27-Oct-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

void VECT_CLASS CPagedVector::InitCopy(CPagedVector *pvectOld)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector copy constructor\n"));
    SCODE sc;
    ULONG i;

    _pmsParent = pvectOld->_pmsParent;

    CMSFPageTable *pmpt;
    pmpt = _pmsParent->GetPageTable();
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmpt);

    _ulAllocSize = _ulSize = pvectOld->_ulSize;

    if (_ulSize > 0)
    {
        CBasedMSFPagePtr* amp;
        msfMem(amp = GetNewPageArray(_ulSize));
        for (i = 0; i < _ulSize; i++)
        {
            amp[i] = NULL;
            if (pvectOld->_amp != NULL)
            {
                _pmpt->CopyPage(this,
                                BP_TO_P(CMSFPage *, pvectOld->_amp[i]),
                                &(amp[i]));
            }
        }
        _amp = P_TO_BP(CBasedMSFPagePtrPtr, amp);

        CVectBits *avb;
        msfMem(avb = GetNewVectBits(_ulSize));
        if (pvectOld->_avb != NULL)
        {
            for (i = 0; i < _ulSize; i++)
            {
                avb[i] = ((CPagedVector *)pvectOld)->_avb[i];
            }
        }
        _avb = P_TO_BP(CBasedVectBitsPtr, avb);
    }

    msfDebugOut((DEB_ITRACE,"Out CPagedVector copy constructor\n"));

    //In the error case, keep whatever vectors we managed to allocate
    //  and return.
Err:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\tstream.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       tstream.cxx
//
//  Contents:   Transacted stream functions
//
//  Classes:
//
//  Functions:
//
//  History:    23-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include "tstream.hxx"
#include "dl.hxx"
#include "mread.hxx"
#include <handle.hxx>
#include <memory.h>
#include <dfdeb.hxx>

#define DEB_TSTREAM (DEB_ITRACE | 0x00200000)

//+--------------------------------------------------------------
//
//  Member:	CTransactedStream::CTransactedStream, public
//
//  Synopsis:	Empty object ctor
//
//  Arguments:  [pdfn] - Name
//              [dl] - LUID
//              [df] -- Permissions flags
//              [dwType] - Entry type
//              [pmsScratch] -- Scratch multistream
//
//  History:	31-Jul-92	DrewB	Created
//
//---------------------------------------------------------------


CTransactedStream::CTransactedStream(CDfName const *pdfn,
                                     DFLUID dl,
                                     DFLAGS df,
                                     CMStream *pms,
                                     CMStream *pmsScratch)
        : PTSetMember(pdfn, STGTY_STREAM),
          PSStream(dl),
          _dl(pms, pmsScratch)
{
    msfDebugOut((DEB_ITRACE, "In  CTransactedStream::CTransactedStream:%p("
		 "%lu)\n", this, dl));

    _pssBase = NULL;
    _pdlOld = NULL;
    _df = df;
    _cReferences = 0;
    _fDirty = 0;
    _fBeginCommit = FALSE;
    PBasicEntry::_sig = CTRANSACTEDSTREAM_SIG;
    PTSetMember::_sig = CTRANSACTEDSTREAM_SIG;
    msfDebugOut((DEB_ITRACE, "Out CTransactedStream::CTransactedStream\n"));
}

//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::Init, public
//
//  Synopsis:   CTransactedStream constructor
//
//  Arguments:  [pssBase] -- Pointer to base stream
//
//  Returns:	Appropriate status code
//
//  History:    23-Jan-92   PhilipLa    Created.
//		31-Jul-92	DrewB	Converted to Init from ctor
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::Init(PSStream *pssBase)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In %p:CTransactedStream constructor(%p)\n",
                 this, pssBase));

    msfChk(SetInitialState(pssBase));

    _pssBase = P_TO_BP(CBasedSStreamPtr, pssBase);

    _sectLastUsed = 0;

    AddRef();
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream constructor\n"));
    // Fall through
Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::~CTransactedStream, public
//
//  Synopsis:   CTransactedStream destructor
//
//  History:    23-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


CTransactedStream::~CTransactedStream()
{

    msfDebugOut((DEB_ITRACE,"In CTransactedStream Destructor\n"));
    msfAssert(_cReferences == 0);

    PBasicEntry::_sig = CTRANSACTEDSTREAM_SIGDEL;
    PTSetMember::_sig = CTRANSACTEDSTREAM_SIGDEL;
    _dl.Empty();

    if (_pssBase)
    {
        _pssBase->Release();
    }


    msfDebugOut((DEB_ITRACE,"Out CTransactedStream Destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CTransactedStream::ReadAt, public
//
//  Synposis:   Reads binary data from a transacted stream
//
//  Arguments:  [ulOffset] -- Position to be read from
//
//              [pBuffer] -- Pointer to the area into which the data
//                           will be read.
//              [ulCount] --  Indicates the number of bytes to be read
//              [pulRetval] -- Area into which return value will be stored
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------


SCODE CTransactedStream::ReadAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{

    msfDebugOut((DEB_ITRACE,"In %p:CTransactedStream::ReadAt(%lu,%p,%lu)\n",this,ulOffset,pBuffer,ulCount));
    SCODE sc;

    if (ulOffset + ulCount > _ulSize)
    {
#ifdef LARGE_STREAMS
        if (_ulSize - ulOffset > ULONG_MAX)  // too far past the end
            ulCount = 0;
        else
#endif
        ulCount = (ULONG)(_ulSize - ulOffset);
    }

    if ((ulCount == 0) || (ulOffset > _ulSize))
    {
        *pulRetval = 0;
        return S_OK;
    }

    msfAssert(P_TRANSACTED(_df));


    if (_dl.IsEmpty())
    {
        //If we have an empty delta list, either our size is 0 (in which
        //  case we'll never get to this line), or we have a parent.

        msfAssert(_pssBase != NULL);
        msfDebugOut((DEB_ITRACE,"Calling up to _pssBase\n"));
        sc = _pssBase->ReadAt(ulOffset,pBuffer,ulCount,pulRetval);
        msfDebugOut((DEB_ITRACE,
                "Out CTransactedStream::ReadAt()=>%lu, ret is %lu\n",
                sc, *pulRetval));

        return sc;
    }

    ILockBytes *pilbDirty = _dl.GetDataILB();
    USHORT cbSector = _dl.GetDataSectorSize();
    USHORT uSectorShift = _dl.GetDataSectorShift();

    ULONG temp = 0;
    ULONG cb = 0;



    SECT snow =(SECT)(ulOffset / cbSector);
    OFFSET off = (OFFSET)(ulOffset % cbSector);

    SECT send = (SECT)((ulOffset + ulCount - 1) / cbSector);
    OFFSET offEnd = (OFFSET)((ulOffset + ulCount - 1) % cbSector);

    USHORT csect = 0;
    SECT sectNext;
    SECT sectCurrent = snow;
    BYTE HUGEP *pb = (BYTE HUGEP *)pBuffer;
    USHORT oStart = off;
    USHORT oEnd = 0;


    SECT sectLast = ENDOFCHAIN;
    SECT sectFirst = ENDOFCHAIN;

    const USHORT ISDIRTY = 0;
    const USHORT ISBASE = 1;

    USHORT uLast;

    msfChk(_dl.GetMap(sectCurrent, DL_READ, &sectNext));
    if (sectNext != ENDOFCHAIN)
    {
        uLast = ISDIRTY;
        sectLast = sectFirst = sectNext;
    }
    else
    {
        uLast = ISBASE;
        sectLast = sectFirst = sectCurrent;
    }

    sectCurrent++;

    while (sectCurrent <= send)
    {
        SECT sectNext;
        msfChk(_dl.GetMap(sectCurrent, DL_READ, &sectNext));

        //If any of the following occur, read the current segment:
        //  1)  Sector has mapping and current segment is in base
        //  2)  Sector has mapping and is not contiguous with
        //          current segment.
        //  3)  Sector has no mapping and current segment is in dirty.

        if (((sectNext != ENDOFCHAIN) && (uLast == ISBASE)) ||
            ((sectNext != ENDOFCHAIN) && (sectNext != sectLast + 1)) ||
            ((sectNext == ENDOFCHAIN) && (uLast == ISDIRTY)))

        {
            msfDebugOut((DEB_ITRACE,"Reading block from pssLast\n"));

            if (uLast == ISDIRTY)
            {
                ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
                ulTmp.QuadPart = ConvertSectOffset(
                                sectFirst,
                                oStart,
                                uSectorShift);
#else
                ULISet32(ulTmp, ConvertSectOffset(
                                sectFirst,
                                oStart,
                                uSectorShift));
#endif
                msfHChk(pilbDirty->ReadAt(
			            ulTmp,
                        pb,
                        (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
                        &temp));
            }
            else
            {
                msfChk(_pssBase->ReadAt(
                        sectFirst * cbSector + oStart,
                        pb,
                        (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
                        (ULONG STACKBASED *)&temp));
            }

           pb += temp;
           cb += temp;
           oStart = 0;

           if (sectNext == ENDOFCHAIN)
           {
               sectFirst = sectCurrent;
               uLast = ISBASE;
           }
           else
           {
               sectFirst = sectNext;
               uLast = ISDIRTY;
           }
       }

       sectLast = (sectNext == ENDOFCHAIN) ? sectCurrent : sectNext;
       sectCurrent++;

   }

   oEnd = (cbSector - 1) - offEnd;
   msfDebugOut((DEB_ITRACE,"Reading last sector block\n"));
   if (uLast == ISDIRTY)
   {
       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
       ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
       ULISet32(ulTmp,
	            ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
       msfHChk(pilbDirty->ReadAt(
	       ulTmp,
               pb,
               (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
               &temp));
   }
   else
   {
       msfChk(_pssBase->ReadAt(
               sectFirst * cbSector + oStart,
               pb,
               (sectLast - sectFirst + 1) * cbSector - oStart - oEnd,
               (ULONG STACKBASED *)&temp));
   }

   pb += temp;
   cb += temp;
   oStart = 0;

    *pulRetval = cb;
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::ReadAt()=>%lu, ret is %lu\n",(ULONG)S_OK,*pulRetval));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CTransactedStream::WriteAt, public
//
//  Synposis:   Writes binary data to a linear single stream
//
//  Effects:    Modifies _ulSeekPos.  May cause modification in parent
//                  MStream.
//
//  Arguments:  [pBuffer] -- Pointer to the area from which the data
//                           will be written.
//              [ulCount] --  Indicates the number of bytes to be written
//              [pulRetval] -- Pointer to area in which number of bytes
//                              will be returned
//
//  Returns:    Error code of MStream call.
//
//  Algorithm:  Calculate sector and offset for beginning and end of
//              write, then pass call up to MStream.
//
//
//  History:    18-Jul-91   PhilipLa    Created.
//              16-Aug-91   PhilipLa    Converted to use multi-sect write
//              23-Aug-91   PhilipLa    Brought into compliance with protocol
//              11-Sep-91   PhilipLa    Moved most functionality up
//                                      to MStream level.
//
//  Notes:      [pBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------


SCODE CTransactedStream::WriteAt(
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID const HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{

    msfDebugOut((DEB_ITRACE,"In CTransactedStream::WriteAt(%lu,%p,%lu)\n",ulOffset,pBuffer,ulCount));
    SCODE sc = S_OK;

    msfAssert(P_TRANSACTED(_df));

    USHORT cbSector = _dl.GetDataSectorSize();
    USHORT uSectorShift = _dl.GetDataSectorShift();

    BYTE *pbDirty;
    pbDirty = NULL;
    ULONG temp;
    temp = 0;

    if (ulCount == 0)
    {
        msfDebugOut((DEB_ITRACE,"ulCount==0.  Returning.\n"));
        *pulRetval = 0;
        return S_OK;
    }

    //If size after the write will be greater than the current
    //size, we may need a new delta list.
    if (ulOffset + ulCount > _ulSize)
    {
        msfChk(SetSize(ulOffset + ulCount));
    }


    if (_dl.IsEmpty())
    {
        msfChk(_dl.Init(_ulSize, this));
    }

    ILockBytes *pilbDirty;
    pilbDirty = _dl.GetDataILB();

    SECT sectStart;
    sectStart = (SECT)(ulOffset / cbSector);
    OFFSET oStart;
    oStart = (OFFSET)(ulOffset % cbSector);

    SECT send;
    send = (SECT)((ulOffset + ulCount - 1) / cbSector);
    OFFSET offEnd;
    offEnd = (OFFSET)((ulOffset + ulCount - 1) % cbSector) + 1;
    OFFSET oEnd;
    oEnd = 0;


    BYTE const HUGEP *pb;
    pb = (BYTE const HUGEP *)pBuffer;

    ULONG cb;
    cb = 0;
    USHORT cbBlock;
    cbBlock = 0;

    SECT sectMap;
    SECT sectFirst,sectLast;

    if (sectStart == send)
    {
        oEnd = cbSector - offEnd;
    }


    SECT sectBlockStart;
    msfChk(_dl.GetMap(sectStart, DL_GET, &sectBlockStart));

    //This handles partial first sector and
    //   one sector only writes.
    while ((oStart) || (sectStart == send))
    {

        cbBlock = cbSector - oStart - oEnd;
        if (sectBlockStart == ENDOFCHAIN)
        {
            msfDebugOut((DEB_ITRACE,"Unmapped partial first sector\n"));
            msfChk(_dl.GetMap(sectStart, DL_CREATE, &sectMap));
            msfChk(PartialWrite(
                        sectStart,
                        sectMap,
                        pb,
                        oStart,
                        cbBlock));
        }
        else
        {
            sectMap = sectBlockStart;

            ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
	        ulTmp.QuadPart = ConvertSectOffset(sectMap, oStart, uSectorShift);
#else
            ULISet32 (ulTmp,
                      ConvertSectOffset(sectMap, oStart, uSectorShift));
#endif
            msfHChk(pilbDirty->WriteAt(
		              ulTmp,
                      pb,
				      cbBlock,
                      &temp));
        }

        pb += cbBlock;
        cb += cbBlock;

        //If it was one-sector only, we can return here.
        if (sectStart == send)
        {
            *pulRetval = cb;
            return S_OK;
        }

        sectStart++;

        oStart = 0;
        msfChk(_dl.GetMap(sectStart, DL_GET, &sectBlockStart));
        if (sectStart == send)
        {
            oEnd = cbSector - offEnd;
        }
    }


    if (sectBlockStart == ENDOFCHAIN)
    {
        msfChk(_dl.GetMap(sectStart, DL_CREATE, &sectMap));
    }

    sectLast = sectFirst = (sectBlockStart == ENDOFCHAIN) ? sectMap
                                                          : sectBlockStart;

    SECT sectCurrent;
    sectCurrent = sectStart + 1;

    while (sectCurrent < send)
    {
        msfDebugOut((DEB_ITRACE,"In main loop:  sectCurrent = %lu\n",sectCurrent));
        msfChk(_dl.GetMap(sectCurrent, DL_CREATE, &sectMap));

        if (sectMap != sectLast + 1)
        {
	        ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
	        ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
            ULISet32 (ulTmp,
                      ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
            msfHChk(pilbDirty->WriteAt(
		            ulTmp,
                    pb,
                    (sectLast - sectFirst + 1) * cbSector - oStart,
                    &temp));
            pb += temp;
            cb += temp;
            oStart = 0;

            sectFirst = sectMap;
        }

       sectLast = sectMap;
       sectCurrent++;
   }

   msfAssert(oStart == 0);

   msfChk(_dl.GetMap(sectCurrent, DL_GET, &sectMap));

   oEnd = cbSector - offEnd;

   BOOL fIsMapped;

   if (sectMap == ENDOFCHAIN)
   {
       fIsMapped = FALSE;
       msfChk(_dl.GetMap(sectCurrent,DL_CREATE, &sectMap));
   }
   else
   {
       fIsMapped = TRUE;
   }

   if ((sectMap != sectLast + 1) || (oEnd != 0))
   {
       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
       ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
       ULISet32 (ulTmp,
                 ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
       msfHChk(pilbDirty->WriteAt(
		           ulTmp,
                   pb,
                   (sectLast - sectFirst + 1) * cbSector - oStart,
                   &temp));
       pb += temp;
       cb += temp;
       oStart = 0;

       sectFirst = sectMap;
   }

   if (oEnd == 0)
   {
       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
       ulTmp.QuadPart = ConvertSectOffset(sectFirst, oStart, uSectorShift);
#else
       ULISet32 (ulTmp,
                 ConvertSectOffset(sectFirst, oStart, uSectorShift));
#endif
       msfHChk(pilbDirty->WriteAt(
		           ulTmp,
                   pb,
                   (sectMap - sectFirst + 1) * cbSector - oStart - oEnd,
                   &temp));
       pb += temp;
       cb += temp;
       oStart = 0;
   }
   else
   {
       cbBlock = cbSector - oEnd;

       if (!fIsMapped)
       {
           msfChk(PartialWrite(
                       sectCurrent,
                       sectMap,
                       pb,
                       0,
                       cbBlock));
       }
       else
       {
	       ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
           ulTmp.QuadPart = ConvertSectOffset(sectMap, oStart, uSectorShift);
#else
           ULISet32 (ulTmp,
	                 ConvertSectOffset(sectMap, oStart, uSectorShift));
#endif
           msfHChk(pilbDirty->WriteAt(
		           ulTmp,
                   pb,
                   cbBlock,
				   &temp));
       }

       pb += cbBlock;
       cb += cbBlock;
   }

    *pulRetval = cb;

    msfDebugOut((DEB_ITRACE,"Leaving CTransactedStream::WriteAt()==>%lu, ret is %lu\n",(ULONG)S_OK,*pulRetval));
Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CTransactedStream::SetSize, public
//
//  Synposis:   Set the size of a linear stream
//
//  Effects:    Modifies _ulSize.  May cause change in parent MStream.
//
//  Arguments:  [ulNewSize] -- New size for stream
//
//  Returns:    Error code returned by MStream call.
//
//  Algorithm:  Pass call up to parent.
//
//  History:    29-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


#ifdef LARGE_STREAMS
SCODE CTransactedStream::SetSize(ULONGLONG ulNewSize)
#else
SCODE CTransactedStream::SetSize(ULONG ulNewSize)
#endif
{
    SCODE sc = S_OK;
    BYTE *pb = NULL;
    SECT sectMaxValid;

    msfDebugOut((DEB_ITRACE,"In CTransactedStream::SetSize(%lu)\n",ulNewSize));
    msfAssert(P_TRANSACTED(_df));

    if (ulNewSize == 0)
    {
        _dl.Empty();
    }
    else if (!_dl.IsEmpty())
    {
        msfChk(_dl.InitResize(ulNewSize));
    }
    else
    {
        msfChk(_dl.Init(ulNewSize, this));
    }

    if (ulNewSize > _ulSize)
    {
        USHORT cbSector = _dl.GetDataSectorSize();
        USHORT uSectorShift = _dl.GetDataSectorShift();

        SECT sectStart, sectEnd, sect, sectNew;

        if (_ulSize == 0)
        {
            sectStart = 0;
        }
        else
        {
            sectStart = (SECT)((_ulSize - 1) / cbSector);
        }

        sectEnd = (SECT)((ulNewSize - 1 ) / cbSector);


        //First, make sure the first sector is copied over OK if necessary.
        msfChk(_dl.GetMap(sectStart, DL_GET, &sectNew));


        if ((sectNew == ENDOFCHAIN) && (_pssBase != NULL) &&
            (_ulSize != 0))
        {
            ULONG cbNull;
            GetSafeBuffer(cbSector, cbSector, &pb, &cbNull);
	    msfAssert((pb != NULL) && aMsg("Couldn't get scratch buffer"));
            ULONG dummy;

            msfChk(_pssBase->ReadAt(
                    sectStart << uSectorShift,
                    pb,
                    cbSector,
                    (ULONG STACKBASED *)&dummy));

            msfChk(_dl.GetMap(sectStart, DL_CREATE, &sectNew));

            ULARGE_INTEGER ulTmp;

#ifdef LARGE_DOCFILE
            ulTmp.QuadPart = ConvertSectOffset(sectNew, 0, uSectorShift);
#else
            ULISet32 (ulTmp, ConvertSectOffset(sectNew, 0, uSectorShift));
#endif

            msfHChk(_dl.GetDataILB()->WriteAt(
                    ulTmp,
                    pb,
                    cbSector,
                    &dummy));
            sectStart++;
        }

        //
        // Get the current last valid sector in case there is an error
        // allocating the delta list or MStream space.
        // Warning: FindMaxSect() returns the Max Allocated Sect, Plus One.
        //
        msfChk(_dl.GetDataFat()->FindMaxSect(&sectMaxValid));
        --sectMaxValid;

        //
        // Allocate new sectors one at a time.
        // GetMap() in DL_CREATE mode does not actually grow the MStream.
        // It allocates FAT entries.
        //
        for (sect = sectStart; sect <= sectEnd; sect ++)
        {
            if(FAILED(sc = _dl.GetMap(sect, DL_CREATE, &sectNew)))
                break;
        }

        //
        // Grow the MStream (which in turn grows the ILB) to include
        // any newly allocated SECTs.  If that fails then release entries
        // in the FAT that couldn't be allocated in the ILB.
        // ie. Beyond the previous recorded Max SECT of the MStream.
        //
        if(FAILED(sc) || FAILED(_dl.GetMStream()->SetSize()))
        {
            _dl.ReleaseInvalidSects(sectMaxValid);
            goto Err;
        }
    }
    _ulSize = ulNewSize;

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::SetSize()\n"));

 Err:
    FreeBuffer(pb);
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::BeginCommitFromChild, public
//
//  Synopsis:   Begin a commit from a child TStream
//
//  Arguments:  [ulSize] - New size
//              [pDelta] - Delta list
//              [pstChild] - Child
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::BeginCommitFromChild(
#ifdef LARGE_STREAMS
        ULONGLONG ulSize,
#else
        ULONG ulSize,
#endif
        CDeltaList *pDelta,
        CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::BeginCommitFromChild:%p("
                 "%lu, %p, %p)\n", this, ulSize, pDelta, pstChild));

    msfAssert(P_TRANSACTED(_df));
    _dl.BeginCommit(this);
    _pdlOld = P_TO_BP(CBasedDeltaListPtr, pDelta);
    _ulOldSize = _ulSize;
    _ulSize = ulSize;

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::BeginCommitFromChild()\n"));
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::EndCommitFromChild, public
//
//  Synopsis:   End a commit from child.
//
//  Arguments:  [df] -- Flags to determine whether to commit or revert
//              [pstChild] - Child
//
//  Returns:    Void.  This can't fail.
//
//  Algorithm:  *Finish This*
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


void CTransactedStream::EndCommitFromChild(DFLAGS df,
                                           CTransactedStream *pstChild)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::EndCommitFromChild:%p("
                 "%lu, %p)\n", this, df, pstChild));

    msfAssert(P_TRANSACTED(_df));

    _dl.EndCommit(BP_TO_P(CDeltaList *, _pdlOld), df);

    //NOTE: Possible cleanup:  Move _pdlOld into the delta list itself.
    _pdlOld = NULL;

    if (P_COMMIT(df))
    {
        _ulOldSize = 0;
    }
    else
    {
        _ulSize = _ulOldSize;
    }
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::EndCommitFromChild()\n"));
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::BeginCommit, public
//
//  Synopsis:   Begin a commit of a transacted stream object
//
//  Arguments:  [dwFlags] -- Currently not used (future expansion)
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Call BeginCommitFromChild on base
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:      This is only called by the Transaction Level object.
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::BeginCommit(DWORD const dwFlags)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE,"In CTransactedStream::BeginCommit(%lu)\n",
                 dwFlags));

    msfAssert(_pssBase != NULL);
    msfAssert(P_TRANSACTED(_df));

#if DBG == 1
    if (!HaveResource(DBR_XSCOMMITS, 1))
        msfErr(Err, STG_E_ABNORMALAPIEXIT);
#endif

    _fBeginCommit = TRUE;
    msfChk(_pssBase->BeginCommitFromChild(_ulSize, &_dl, this));

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::BeginCommit()\n"));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::EndCommit, public
//
//  Synopsis:   End a commit on a transacted stream object
//
//  Arguments:  [df] -- Indicator of whether to commit or revert
//
//  Returns:    void.  This can't fail.
//
//  Algorithm:  Call EndCommitFromChild on base.
//              If committing, NULL out all previously passed up
//                  dirty information.
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:
//
//--------------------------------------------------------------------------


void CTransactedStream::EndCommit(DFLAGS const df)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::EndCommit(%lu)\n",df));

    msfAssert(P_TRANSACTED(_df));
    msfAssert((_pssBase != NULL) || (P_ABORT(df)));

    if (!_fBeginCommit)
	return;
    _fBeginCommit = FALSE;

#if DBG == 1
    if (P_COMMIT(df))
        ModifyResLimit(DBR_XSCOMMITS, 1);
#endif

    if (_pssBase != NULL)
    {
        _pssBase->EndCommitFromChild(df, this);
    }

    if (P_COMMIT(df))
    {
        _dl.Empty();
        SetClean();
    }

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::EndCommit()\n"));
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::Revert, public
//
//  Synopsis:   Revert a transacted stream instance.
//
//  Algorithm:  Destroy dirty stream and delta list.
//              Retrieve size from base.
//              Mark object as Invalid if specified in the flags.
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//  Notes:      This is only called from the Transaction Level.
//
//--------------------------------------------------------------------------


void CTransactedStream::Revert(void)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::Revert(%lu):  This == %p\n",this));

    _dl.Empty();
    msfVerify(SUCCEEDED(SetInitialState(BP_TO_P(PSStream *, _pssBase))));
    _sectLastUsed = 0;
    SetClean();

    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::Revert()\n"));
}

//+--------------------------------------------------------------
//
//  Member:	CTransactedStream::SetBase, public
//
//  Synopsis:	Sets a new base
//
//  Arguments:	[psst] - New base
//
//  Returns:    Appropriate status code
//
//  History:	31-Jul-92	DrewB	Created
//
//---------------------------------------------------------------


SCODE CTransactedStream::SetBase(PSStream *psst)
{
    msfAssert(_pssBase == NULL || psst == NULL);
    if (_pssBase)
        _pssBase->Release();
    _pssBase = P_TO_BP(CBasedSStreamPtr, psst);
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::PartialWrite, private
//
//  Synopsis:   Do a write of a partial sector
//
//  Arguments:  [sectBase] -- Sector in base to copy
//              [sectDirty] -- Sector in dirty to write to
//              [pb] -- Buffer containing data to be writte
//              [offset] -- Offset into buffer to begin copy
//              [uLen] -- Number of bytes to copy
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    30-Jun-92   PhilipLa    Created.
//
//  Notes:      [pb] may be unsafe memory
//
//--------------------------------------------------------------------------


SCODE CTransactedStream::PartialWrite(
        SECT sectBase,
        SECT sectDirty,
        BYTE const HUGEP *pb,
        USHORT offset,
        USHORT uLen)
{
    msfDebugOut((DEB_ITRACE,"In CTransactedStream::PartialWrite()\n"));
    BYTE *pbMem = NULL;
    SCODE sc;
    ULONG temp;

    USHORT cbSector = _dl.GetDataSectorSize();
    USHORT uSectorShift = _dl.GetDataSectorShift();

    if (uLen != cbSector)
    {
        ULONG cbNull;
        GetSafeBuffer(cbSector, cbSector, &pbMem, &cbNull);
	msfAssert((pbMem != NULL) && aMsg("Couldn't get scratch buffer"));

	if (_pssBase != NULL)
	{
	    msfChk(_pssBase->ReadAt(
	        sectBase << uSectorShift,
                pbMem,
                cbSector,
                (ULONG STACKBASED *)&temp));
	}

        TRY
        {
            memcpy(pbMem + offset, pb, uLen);
        }
        CATCH(CException, e)
        {
            UNREFERENCED_PARM(e);
            msfErr(Err, STG_E_INVALIDPOINTER);
        }
        END_CATCH

        pb = pbMem;
    }

    ULARGE_INTEGER ulTmp;
#ifdef LARGE_DOCFILE
    ulTmp.QuadPart = ConvertSectOffset(sectDirty, 0, uSectorShift);
#else
    ULISet32 (ulTmp,
              ConvertSectOffset(sectDirty, 0, uSectorShift));
#endif

    sc = DfGetScode((_dl.GetDataILB())->WriteAt(
                ulTmp,
                pb,
                cbSector,
                &temp));

Err:
    FreeBuffer(pbMem);
    msfDebugOut((DEB_ITRACE,"Out CTransactedStream::PartialWrite()\n"));
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::GetCommitInfo, public
//
//  Synopsis:   Return the current size of the stream and the size of
//              its base.
//
//  Arguments:  [pulRet1] -- Pointer to return location for old size
//              [pulRet2] -- Pointer to return location for current size
//
//  History:    08-Jul-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


#ifdef LARGE_STREAMS
void CTransactedStream::GetCommitInfo(ULONGLONG *pulRet1, ULONGLONG *pulRet2)
#else
void CTransactedStream::GetCommitInfo(ULONG *pulRet1, ULONG *pulRet2)
#endif
{
    if (_pssBase != NULL)
	_pssBase->GetSize(pulRet1);
    else
	*pulRet1 = 0;
    *pulRet2 = _ulSize;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTransactedStream::GetSize, public
//
//  Synopsis:   Returns the size of the stream.
//
//  Arguments:  [pulSize] -- Pointer to return location for size.
//
//  Returns:    S_OK
//
//  History:    22-Jan-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------

#ifdef LARGE_STREAMS
void CTransactedStream::GetSize(ULONGLONG *pulSize)
#else
void CTransactedStream::GetSize(ULONG *pulSize)
#endif
{
    msfAssert(P_TRANSACTED(_df));

    *pulSize = _ulSize;

    msfDebugOut((DEB_ITRACE,"CTransactedStream::GetSize()==>%lu\n",*pulSize));
}

//+---------------------------------------------------------------------------
//
//  Member:	CTransactedStream::SetInitialState, public
//
//  Synopsis:	Sets the initial state from a base or defaults
//
//  Arguments:	[pssBase] - Base or NULL
//
//  Returns:	Appropriate status code
//
//  History:	11-Nov-92	DrewB	Created
//
//----------------------------------------------------------------------------


SCODE CTransactedStream::SetInitialState(PSStream *pssBase)
{
    olDebugOut((DEB_ITRACE, "In  CTransactedStream::SetInitialState:%p(%p)\n",
                this, pssBase));
    if (pssBase == NULL)
    {
        _ulSize = 0;
    }
    else
    {
        pssBase->GetSize(&_ulSize);
    }
    olDebugOut((DEB_ITRACE, "Out CTransactedStream::SetInitialState\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CTransactedStream::GetDeltaList, public
//
//  Synopsis:	Return a pointer to the delta list if it is not empty.
//              If it is empty, call GetDeltaList on the parent and
//              return that.
//
//  Arguments:	None.
//
//  Returns:	Pointer as above.
//
//  History:	30-Jul-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

CDeltaList * CTransactedStream::GetDeltaList(void)
{
    if (_dl.IsEmpty())
    {
        if (_pssBase != NULL)
        {
            return _pssBase->GetDeltaList();
        }
        else
        {
            //This case will only be hit if someone creates a new
            //  stream, then commits it to its parent without writing
            //  anything to it.  The parent then has an empty delta
            //  list with no parent set on it.
            msfAssert(_ulSize == 0);
            return NULL;
        }
    }
    else
        return &_dl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\msf\mstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           mstream.cxx
//
//  Contents:       Mstream operations
//
//  Classes:        None. (defined in mstream.hxx)
//
//  History:        18-Jul-91   Philipla    Created.
//
//--------------------------------------------------------------------

#include "msfhead.cxx"

#pragma hdrstop

#include <dirfunc.hxx>
#include <sstream.hxx>
#include <difat.hxx>
#include <time.h>
#include <mread.hxx>
#include <docfilep.hxx>
#include <df32.hxx>
#include <smalloc.hxx>
#include <filelkb.hxx>


#if DBG == 1
DECLARE_INFOLEVEL(msf)
#endif

#define MINPAGES 6 
#define MAXPAGES 128

#define MINPAGESSCRATCH 2
#define MAXPAGESSCRATCH 16

//#define SECURETEST

const WCHAR wcsContents[] = L"CONTENTS";  //Name of contents stream for
                                         // conversion
const WCHAR wcsRootEntry[] = L"Root Entry";  //Name of root directory
                                            // entry

SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache);

//+---------------------------------------------------------------------------
//
//  Function:	GetBuffer, public
//
//  Synopsis:	Gets a chunk of memory to use as a buffer
//
//  Arguments:	[cbMin] - Minimum size for buffer
//              [cbMax] - Maximum size for buffer
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//  Algorithm:  Attempt to dynamically allocate [cbMax] bytes
//              If that fails, halve allocation size and retry
//              If allocation size falls below [cbMin], fail
//
//  History:	04-Mar-93	DrewB	Created
//
//  Notes:	Buffer should be released with FreeBuffer
//
//----------------------------------------------------------------------------


SCODE GetBuffer(ULONG cbMin, ULONG cbMax, BYTE **ppb, ULONG *pcbActual)
{
    ULONG cbSize;
    BYTE *pb;

    msfDebugOut((DEB_ITRACE, "In  GetBuffer(%u, %u, %p, %p)\n",
                 cbMin, cbMax, ppb, pcbActual));
    msfAssert(cbMin > 0);
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);
    msfAssert(pcbActual != NULL);

    cbSize = cbMax;
    for (;;)
    {
        pb = (BYTE *) DfMemAlloc(cbSize);
        if (pb == NULL)
        {
            cbSize >>= 1;
            if (cbSize < cbMin)
                break;
        }
        else
        {
            *pcbActual = cbSize;
            break;
        }
    }

    *ppb = pb;

    msfDebugOut((DEB_ITRACE, "Out GetBuffer => %p, %u\n", *ppb, *pcbActual));
    return pb == NULL ? STG_E_INSUFFICIENTMEMORY : S_OK;
}

// Define the safe buffer size
//#define SCRATCHBUFFERSIZE SCRATCHSECTORSIZE
BYTE s_bufSafe[SCRATCHBUFFERSIZE];
LONG s_bufSafeRef = 0;



// Critical Section will be initiqalized in the shared memory allocator
// constructor and deleted in the SmAllocator destructor
CRITICAL_SECTION g_csScratchBuffer;

//+---------------------------------------------------------------------------
//
//  Function:	GetSafeBuffer, public
//
//  Synopsis:	Gets a buffer by first trying GetBuffer and if that fails,
//              returning a pointer to statically allocated storage.
//              Guaranteed to return a pointer to some storage.
//
//  Arguments:	[cbMin] - Minimum buffer size
//              [cbMax] - Maximum buffer size
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//  History:	04-Mar-93	DrewB	Created
//
//----------------------------------------------------------------------------


void GetSafeBuffer(ULONG cbMin, ULONG cbMax, BYTE **ppb, ULONG *pcbActual)
{
    msfAssert(cbMin > 0);
    msfAssert(cbMin <= SCRATCHBUFFERSIZE &&
              aMsg("Minimum too large for GetSafeBuffer"));
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);

    // We want to minimize contention for the
    // static buffer so we always try dynamic allocation, regardless
    // of the size
    if (
        FAILED(GetBuffer(cbMin, cbMax, ppb, pcbActual)))
    {

		EnterCriticalSection(&g_csScratchBuffer);
        msfAssert(s_bufSafeRef == 0 &&
                  aMsg("Tried to use scratch buffer twice"));
        s_bufSafeRef = 1;
        *ppb = s_bufSafe;
        *pcbActual = min(cbMax, SCRATCHBUFFERSIZE);
    }
    msfAssert(*ppb != NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:	FreeBuffer, public
//
//  Synopsis:	Releases a buffer allocated by GetBuffer or GetSafeBuffer
//
//  Arguments:	[pb] - Buffer
//
//  History:	04-Mar-93	DrewB	Created
//
//----------------------------------------------------------------------------


void FreeBuffer(BYTE *pb)
{
    if (pb == s_bufSafe)
    {
        msfAssert((s_bufSafeRef == 1) && aMsg("Bad safe buffer ref count"));
        s_bufSafeRef = 0;
        LeaveCriticalSection(&g_csScratchBuffer);
    }
    else
        DfMemFree(pb);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::CMStream, public
//
//  Synopsis:   CMStream constructor
//
//  Arguments:  [pplstParent] -- Pointer to ILockBytes pointer of parent
//              [plGen] -- Pointer to LUID Generator to use.
//                         Note:  May be NULL, in which case a new
//              [uSectorShift] -- Sector shift for this MStream
//
//  History:    18-Jul-91   PhilipLa    Created.
//              05-Sep-95   MikeHill    Initialize '_fMaintainFLBModifyTimestamp'.
//              26-Apr-99   RogerCh     Removed _fMaintainFLBModifyTimestamp
//
//--------------------------------------------------------------------------



CMStream::CMStream(
        IMalloc *pMalloc,
        ILockBytes **pplstParent,
	BOOL fIsScratch,
#if defined(USE_NOSCRATCH) || defined(USE_NOSNAPSHOT)
        DFLAGS df,
#endif
        USHORT uSectorShift)
:_uSectorShift(uSectorShift),
 _uSectorSize(1 << uSectorShift),
 _uSectorMask(_uSectorSize - 1),
 _pplstParent(P_TO_BP(CBasedILockBytesPtrPtr, pplstParent)),
 _fIsScratch(fIsScratch),
 _fIsNoScratch(P_NOSCRATCH(df)),
 _pmsScratch(NULL),
 _fIsNoSnapshot(P_NOSNAPSHOT(df)),
 _hdr(uSectorShift),
 _fat(SIDFAT),
 _fatMini(SIDMINIFAT),
 _pMalloc(pMalloc)
{
    _pmsShadow = NULL;
    _pCopySectBuf = NULL;
#if DBG == 1
    _uBufferRef = 0;
#endif
    _fIsShadow = FALSE;

    _ulParentSize = 0;

    _pdsministream = NULL;
    _pmpt = NULL;
    _fBlockWrite = _fTruncate = _fBlockHeader = _fNewConvert = FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::CMStream, public
//
//  Synopsis:   CMStream copy constructor
//
//  Arguments:  [ms] -- MStream to copy
//
//  History:    04-Nov-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


CMStream::CMStream(const CMStream *pms)
:_uSectorShift(pms->_uSectorShift),
 _uSectorSize(pms->_uSectorSize),
 _uSectorMask(pms->_uSectorMask),
 _pplstParent(pms->_pplstParent),
 _fIsScratch(pms->_fIsScratch),
 _hdr(*(CMSFHeader *)&pms->_hdr),
 _dir(*(CDirectory *)pms->GetDir()),
 _fat(pms->GetFat()),
 _fatMini(pms->GetMiniFat()),
 _fatDif(pms->GetDIFat()),
 _pdsministream(pms->_pdsministream),
 _pmpt(pms->_pmpt),
 _fBlockWrite(pms->_fBlockWrite),
 _fTruncate(pms->_fTruncate),
 _fBlockHeader(pms->_fBlockHeader),
 _fNewConvert(pms->_fNewConvert),
 _pmsShadow(NULL),
 _fIsShadow(TRUE),
 _pMalloc(pms->_pMalloc)
{
    _pCopySectBuf = pms->_pCopySectBuf;
#if DBG == 1
    _uBufferRef = pms->_uBufferRef;
#endif
    _dir.SetParent(this);
    _fat.SetParent(this);
    _fatMini.SetParent(this);
    _fatDif.SetParent(this);

    _ulParentSize = 0;
    _pmpt->AddRef();
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitCommon, private
//
//  Synopsis:   Common code for initialization routines.
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    20-May-92   PhilipLa    Created.
//
//--------------------------------------------------------------------------


SCODE CMStream::InitCommon(VOID)
{
    msfDebugOut((DEB_ITRACE,"In CMStream InitCommon()\n"));
    SCODE sc = S_OK;

#ifdef SECURE_BUFFER
    memset(s_bufSecure, SECURECHAR, MINISTREAMSIZE);
#endif

    CMSFPageTable *pmpt;
    msfMem(pmpt = new (GetMalloc()) CMSFPageTable(
            this,
            (_fIsScratch) ? MINPAGESSCRATCH: MINPAGES,
            (_fIsScratch) ? MAXPAGESSCRATCH: MAXPAGES));
    _pmpt = P_TO_BP(CBasedMSFPageTablePtr, pmpt);

    msfChk(pmpt->Init());
    if (!_fIsScratch)
    {
        CMStream *pms;
        msfMem(pms = (CMStream *) new (GetMalloc()) CMStream(this));
        _pmsShadow = P_TO_BP(CBasedMStreamPtr, pms);
    }

    _stmcDir.Init(this, SIDDIR, NULL);
    _stmcMiniFat.Init(this, SIDMINIFAT, NULL);

    msfDebugOut((DEB_ITRACE,"Leaving CMStream InitCommon()\n"));

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::InitCopy, public
//
//  Synopsis:	Copy the structures from one multistream to yourself
//
//  Arguments:	[pms] -- Pointer to multistream to copy.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------


void CMStream::InitCopy(CMStream *pms)
{
    _stmcDir.Init(this, SIDDIR, NULL);
    _stmcMiniFat.Init(this, SIDMINIFAT, NULL);

    _fat.InitCopy(pms->GetFat());
    _fatMini.InitCopy(pms->GetMiniFat());
    _fatDif.InitCopy(pms->GetDIFat());
    _dir.InitCopy(pms->GetDir());

    _dir.SetParent(this);
    _fat.SetParent(this);
    _fatMini.SetParent(this);
    _fatDif.SetParent(this);

    memcpy(&_hdr, pms->GetHeader(), sizeof(CMSFHeader));
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Empty, public
//
//  Synopsis:	Empty all of the control structures of this CMStream
//
//  Arguments:	None.
//
//  Returns:	void.
//
//  History:	04-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


void CMStream::Empty(void)
{
    _fat.Empty();
    _fatMini.Empty();
    _fatDif.Empty();
    _dir.Empty();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::~CMStream, public
//
//  Synopsis:   CMStream destructor
//
//  History:    18-Jul-91   PhilipLa    Created.
//		20-Jul-95   SusiA	Modified to eliminate mutex in allocator
//					Caller must already have the mutex.
//
//--------------------------------------------------------------------------


CMStream::~CMStream()
{

    msfDebugOut((DEB_ITRACE,"In CMStream destructor\n"));



    if (_pmsShadow != NULL)
    {
	_pmsShadow->~CMStream();
        _pmsShadow->deleteNoMutex (BP_TO_P(CMStream *, _pmsShadow));
    }	

#if DBG == 1
    msfAssert((_uBufferRef == 0) &&
            aMsg("CopySect buffer left with positive refcount."));
#endif
      g_smAllocator.FreeNoMutex(BP_TO_P(BYTE *, _pCopySectBuf));


    if ((!_fIsShadow) && (_pdsministream != NULL))
    {
            _pdsministream->Release();
    }

    if (_pmpt != NULL)
    {
        _pmpt->Release();
    }

    msfDebugOut((DEB_ITRACE,"Leaving CMStream destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CMStream::Init, public
//
//  Synposis:   Set up an mstream instance from an existing stream
//
//  Effects:    Modifies Fat and Directory
//
//  Arguments:  void.
//
//  Returns:    S_OK if call completed OK.
//              Error of Fat or Dir setup otherwise.
//
//  History:    18-Jul-91   PhilipLa    Created.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CMStream::Init(VOID)
{
    ULONG ulTemp;
    SCODE sc;
    ULARGE_INTEGER ulOffset;


    msfDebugOut((DEB_ITRACE,"In CMStream::Init()\n"));

    msfAssert(!_fIsScratch &&
            aMsg("Called Init() on scratch multistream."));

    ULONG ulSectorSize = HEADERSIZE;
    IFileLockBytes *pfl;
    if (SUCCEEDED((*_pplstParent)->QueryInterface(IID_IFileLockBytes, 
                                                 (void**) &pfl)))
    {
        ulSectorSize = pfl->GetSectorSize();
        pfl->Release();
    }

    ULISet32(ulOffset, 0);
    if (ulSectorSize == sizeof(CMSFHeaderData)) 
    {
        sc = (*_pplstParent)->ReadAt(ulOffset, (BYTE *)_hdr.GetData(),
                                    sizeof(CMSFHeaderData), &ulTemp);
    }
    else
    {
        void *pvBuf = TaskMemAlloc(ulSectorSize);
        sc = (*_pplstParent)->ReadAt(ulOffset, pvBuf, ulSectorSize, &ulTemp);
        if (SUCCEEDED(sc))
            memcpy (_hdr.GetData(), pvBuf, sizeof(CMSFHeaderData));
        TaskMemFree (pvBuf);
    }
    if (sc == E_PENDING)
    {
        sc = STG_E_PENDINGCONTROL;
    }
    msfChk(sc);

    //We need to mark the header as not dirty, since the constructor
    //   defaults it to the dirty state.  This needs to happen before
    //   any possible failures, otherwise we can end up writing a
    //   brand new header over an existing file.
    _hdr.ResetDirty();

    _uSectorShift = _hdr.GetSectorShift();
    _uSectorSize = 1 << _uSectorShift;
    _uSectorMask = _uSectorSize - 1;

    if (ulTemp != ulSectorSize)
    {
        msfErr(Err,STG_E_INVALIDHEADER);
    }

    msfChk(_hdr.Validate());

    msfChk(InitCommon());

    msfChk(_fatDif.Init(this, _hdr.GetDifLength()));
    msfChk(_fat.Init(this, _hdr.GetFatLength(), 0));

    FSINDEX fsiLen;
    if (_uSectorShift > SECTORSHIFT512)
        fsiLen = _hdr.GetDirLength ();
    else
        msfChk(_fat.GetLength(_hdr.GetDirStart(), &fsiLen));
    msfChk(_dir.Init(this, fsiLen));

    msfChk(_fatMini.Init(this, _hdr.GetMiniFatLength(), 0));

    BYTE *pbBuf;

    msfMem(pbBuf = (BYTE *) GetMalloc()->Alloc(GetSectorSize()));
    _pCopySectBuf = P_TO_BP(CBasedBytePtr, pbBuf);

#ifdef LARGE_STREAMS
    ULONGLONG ulSize;
#else
    ULONG ulSize;
#endif
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));
    CDirectStream *pdsTemp;

    msfMem(pdsTemp = new(GetMalloc()) CDirectStream(MINISTREAM_LUID));
    _pdsministream = P_TO_BP(CBasedDirectStreamPtr, pdsTemp);
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);

    msfDebugOut((DEB_ITRACE,"Out CMStream::Init()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMStream::InitNew, public
//
//  Synposis:   Set up a brand new mstream instance
//
//  Effects:    Modifies FAT and Directory
//
//  Arguments:  [fDelay] -- If TRUE, then the parent LStream
//                  will be truncated at the time of first
//                  entrance to COW, and no writes to the
//                  LStream will happen before then.
//
//  Returns:    S_OK if call completed OK.
//
//  History:    18-Jul-91   PhilipLa    Created.
//              12-Jun-92   PhilipLa    Added fDelay.
//
//---------------------------------------------------------------------------


SCODE CMStream::InitNew(BOOL fDelay, ULARGE_INTEGER uliSize)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In CMStream::InitNew()\n"));

#ifdef LARGE_DOCFILE
    ULONGLONG ulParentSize = 0;
#else
    ULONG ulParentSize = 0;
#endif

    msfChk(InitCommon());

    if (!_fIsScratch)
    {
#ifdef LARGE_DOCFILE
        ulParentSize = uliSize.QuadPart;
#else
        msfAssert (ULIGetHigh(uliSize) == 0);
        ulParentSize = ULIGetLow(uliSize);
#endif

        if (!fDelay && ulParentSize > 0)
        {
            ULARGE_INTEGER ulTmp;

            ULISet32(ulTmp, 0);
            (*_pplstParent)->SetSize(ulTmp);
        }
    }

    _fBlockWrite = (ulParentSize == 0) ? FALSE : fDelay;

    msfChk(_fatDif.InitNew(this));
    msfChk(_fat.InitNew(this));

    if (!_fIsScratch || _fIsNoScratch)
    {
        msfChk(_fatMini.InitNew(this));
    }

    if (!_fIsScratch)
    {

        msfChk(_dir.InitNew(this));

        BYTE *pbBuf;

        msfMem(pbBuf = (BYTE *) GetMalloc()->Alloc(GetSectorSize()));
        _pCopySectBuf = P_TO_BP(CBasedBytePtr, pbBuf);

#ifdef LARGE_STREAMS
        ULONGLONG ulSize;
#else
        ULONG ulSize;
#endif
        msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));

        CDirectStream *pdsTemp;

        msfMem(pdsTemp = new(GetMalloc()) CDirectStream(MINISTREAM_LUID));
        _pdsministream = P_TO_BP(CBasedDirectStreamPtr, pdsTemp);
	_pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);
    }

    //If we have a zero length original file, this will create an
    //   empty Docfile on the disk.  If the original file was
    //   not zero length, then the Flush operations will be skipped
    //   by _fBlockWrite and the file will be unmodified.
    if (!_fBlockWrite)
    {
        msfChk(Flush(0));

    }

    _fTruncate = (ulParentSize != 0);
    _fBlockWrite = fDelay;


    msfDebugOut((DEB_ITRACE,"Out CMStream::InitNew()\n"));
    return S_OK;

Err:
    Empty();

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::ConvertILB, private
//
//  Synopsis:	Copy the first sector of the underlying ILockBytes
//                      out to the end.
//
//  Arguments:	[sectMax] -- Total number of sectors in the ILockBytes
//
//  Returns:	Appropriate status code
//
//  History:	03-Feb-93	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CMStream::ConvertILB(SECT sectMax)
{
    SCODE sc;
    BYTE *pb;
    ULONG cbNull;

    GetSafeBuffer(GetSectorSize(), GetSectorSize(), &pb, &cbNull);

    ULONG ulTemp;

    ULARGE_INTEGER ulTmp;
    ULISet32(ulTmp, 0);

    msfHChk((*_pplstParent)->ReadAt(ulTmp, pb, GetSectorSize(), &ulTemp));

    ULARGE_INTEGER ulNewPos;
#ifdef LARGE_DOCFILE
    ulNewPos.QuadPart = sectMax << GetSectorShift();
#else
    ULISet32(ulNewPos, sectMax << GetSectorShift());
#endif

    msfDebugOut((DEB_ITRACE,"Copying first sector out to %lu\n",
            ULIGetLow(ulNewPos)));

    msfHChk((*_pplstParent)->WriteAt(
            ulNewPos,
            pb,
            GetSectorSize(),
            &ulTemp));

Err:
    FreeBuffer(pb);
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitConvert, public
//
//  Synopsis:   Init function used in conversion of files to multi
//              streams.
//
//  Arguments:  [fDelayConvert] -- If true, the actual file is not
//                                 touched until a BeginCopyOnWrite()
//
//  Returns:    S_OK if everything completed OK.
//
//  Algorithm:  *Finish This*
//
//  History:    28-May-92   Philipla    Created.
//
//  Notes:	We are allowed to fail here in low memory
//
//--------------------------------------------------------------------------


SCODE CMStream::InitConvert(BOOL fDelayConvert)
{
    SCODE sc;
    SECT sectMax;
    CDfName const dfnContents(wcsContents);

    msfAssert(!_fIsScratch &&
            aMsg("Called InitConvert on scratch multistream"));

    _fBlockWrite = fDelayConvert;

    msfAssert(!_fBlockWrite &&
            aMsg("Delayed conversion not supported in this release."));

    msfChk(InitCommon());

    STATSTG stat;
    (*_pplstParent)->Stat(&stat, STATFLAG_NONAME);

#ifndef LARGE_DOCFILE
    msfAssert (ULIGetHigh(stat.cbSize) == 0);
#endif
    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",ULIGetLow(stat.cbSize)));


#ifdef LARGE_DOCFILE
    sectMax = (SECT) ((stat.cbSize.QuadPart + GetSectorSize() - 1) >>
        GetSectorShift());
#else
    sectMax = (ULIGetLow(stat.cbSize) + GetSectorSize() - 1) >>
        GetSectorShift();
#endif

    SECT sectMaxMini;
    BOOL fIsMini;
    fIsMini = FALSE;

    //If the CONTENTS stream will be in the Minifat, compute
    //  the number of Minifat sectors needed.
#ifdef LARGE_DOCFILE
    if (stat.cbSize.QuadPart < MINISTREAMSIZE)
#else
    if (ULIGetLow(stat.cbSize) < MINISTREAMSIZE)
#endif
    {
        sectMaxMini = (ULIGetLow(stat.cbSize) + MINISECTORSIZE - 1) >>
            MINISECTORSHIFT;
        fIsMini = TRUE;
    }

    BYTE *pbBuf;

    msfMem(pbBuf = (BYTE *) GetMalloc()->Alloc(GetSectorSize()));
    _pCopySectBuf = P_TO_BP(CBasedBytePtr, pbBuf);

    msfChk(_fatDif.InitConvert(this, sectMax));
    msfChk(_fat.InitConvert(this, sectMax));
    msfChk(_dir.InitNew(this));
    msfChk(fIsMini ? _fatMini.InitConvert(this, sectMaxMini)
                   : _fatMini.InitNew(this));

    SID sid;

    msfChk(CreateEntry(SIDROOT, &dfnContents, STGTY_STREAM, &sid));
#ifdef LARGE_STREAMS
    msfChk(_dir.SetSize(sid, stat.cbSize.QuadPart));
#else
    msfChk(_dir.SetSize(sid, ULIGetLow(stat.cbSize)));
#endif

    if (!fIsMini)
        msfChk(_dir.SetStart(sid, sectMax - 1));
    else
    {
        msfChk(_dir.SetStart(sid, 0));
        msfChk(_dir.SetStart(SIDMINISTREAM, sectMax - 1));
#ifdef LARGE_STREAMS
        msfChk(_dir.SetSize(SIDMINISTREAM, stat.cbSize.QuadPart));
#else
        msfChk(_dir.SetSize(SIDMINISTREAM, ULIGetLow(stat.cbSize)));
#endif
    }

#ifdef LARGE_STREAMS
    ULONGLONG ulMiniSize;
#else
    ULONG ulMiniSize;
#endif
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulMiniSize));

    CDirectStream *pdsTemp;

    msfMem(pdsTemp = new(GetMalloc()) CDirectStream(MINISTREAM_LUID));
    _pdsministream = P_TO_BP(CBasedDirectStreamPtr, pdsTemp);

    _pdsministream->InitSystem(this, SIDMINISTREAM, ulMiniSize);

    if (!_fBlockWrite)
    {
        msfChk(ConvertILB(sectMax));

        msfChk(Flush(0));
    }

    return S_OK;

Err:
    Empty();

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::FlushHeader, public
//
//  Synopsis:   Flush the header to the LStream.
//
//  Arguments:  [uForce] -- Flag to determine if header should be
//                          flushed while in copy on write mode.
//
//  Returns:    S_OK if call completed OK.
//              S_OK if the MStream is in copy on write mode or
//                  is Unconverted and the header was not flushed.
//
//  Algorithm:  Write the complete header out to the 0th position of
//              the LStream.
//
//  History:    11-Dec-91   PhilipLa    Created.
//              18-Feb-92   PhilipLa    Added copy on write support.
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CMStream::FlushHeader(USHORT uForce)
{
    ULONG ulTemp;
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In CMStream::FlushHeader()\n"));

    if (_fIsScratch || _fBlockWrite ||
	((_fBlockHeader) && (!(uForce & HDR_FORCE))))
    {
        return S_OK;
    }


    //If the header isn't dirty, we don't flush it unless forced to.
    if (!(uForce & HDR_FORCE) && !(_hdr.IsDirty()))
    {
        return S_OK;
    }

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);

    USHORT usSectorSize = GetSectorSize();
    if (usSectorSize == HEADERSIZE || _fIsScratch)
    {
        sc = (*_pplstParent)->WriteAt(ulOffset, (BYTE *)_hdr.GetData(),
                                             sizeof(CMSFHeaderData), &ulTemp);
    }
    else
    {
        msfAssert (_pCopySectBuf != NULL);
        memset (_pCopySectBuf, 0, usSectorSize);
        memcpy (_pCopySectBuf, _hdr.GetData(), sizeof(CMSFHeaderData));
        sc = (*_pplstParent)->WriteAt(ulOffset, _pCopySectBuf, 
                                      usSectorSize, &ulTemp);
    }

    if (sc == E_PENDING)
    {
        sc = STG_E_PENDINGCONTROL;
    }

    msfDebugOut((DEB_ITRACE,"Out CMStream::FlushHeader()\n"));
    if (SUCCEEDED(sc))
    {
        _hdr.ResetDirty();
    }
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::BeginCopyOnWrite, public
//
//  Synopsis:   Switch the multistream into copy on write mode
//
//  Effects:    Creates new in-core copies of the Fat, Directory, and
//              header.
//
//  Arguments:  None.
//
//  Requires:   The multistream cannot already be in copy on write
//              mode.
//
//  Returns:    S_OK if the call completed OK.
//              STG_E_ACCESSDENIED if multistream was already in COW mode
//
//  Algorithm:  Retrieve and store size of parent LStream.
//              If _fUnconverted & _fTruncate, call SetSize(0)
//                  on the parent LStream.
//              If _fUnconverted, then flush all control structures.
//              Copy all control structures, and switch in the shadow
//                  copies for current use.
//              Return S_OK.
//
//  History:    18-Feb-92   PhilipLa    Created.
//              09-Jun-92   PhilipLa    Added support for fUnconverted
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CMStream::BeginCopyOnWrite(DWORD const dwFlags)
{
    msfDebugOut((DEB_ITRACE,"In CMStream::BeginCopyOnWrite()\n"));

    SCODE sc;

    msfAssert(!_fBlockHeader &&
            aMsg("Tried to reenter Copy-on-Write mode."));

    msfAssert(!_fIsScratch &&
            aMsg("Tried to enter Copy-on-Write mode in scratch."));

    msfAssert(!_fIsNoScratch &&
              aMsg("Copy-on-Write started for NoScratch."));

    //_fBlockWrite is true if we have a delayed conversion or
    //          truncation.
    if (_fBlockWrite)
    {

        //In the overwrite case, we don't want to release any
        //  disk space, so we skip this step.
        if ((_fTruncate) && !(dwFlags & STGC_OVERWRITE) &&
            (_pmsScratch == NULL))
        {
	        ULARGE_INTEGER ulTmp;
            ULISet32(ulTmp, 0);
            msfHChk((*_pplstParent)->SetSize(ulTmp));
        }


        if (!(dwFlags & STGC_OVERWRITE))
        {
            _fBlockHeader = TRUE;
        }

        _fBlockWrite = FALSE;
        msfChk(Flush(0));

        _fBlockHeader = FALSE;
        _fTruncate = FALSE;
    }

    STATSTG stat;
    msfHChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));
#ifdef LARGE_DOCFILE
    _ulParentSize = stat.cbSize.QuadPart;
    msfDebugOut((DEB_ITRACE,"Parent size at begin is %Lu\n",_ulParentSize));
#else
    msfAssert(ULIGetHigh(stat.cbSize) == 0);
    _ulParentSize = ULIGetLow(stat.cbSize);

    msfDebugOut((DEB_ITRACE,"Parent size at begin is %lu\n",_ulParentSize));
#endif

    if (_fIsNoSnapshot)
    {
        SECT sectNoSnapshot;
#ifdef LARGE_DOCFILE
        sectNoSnapshot = (SECT) ((_ulParentSize - GetSectorSize() + 
#else
        sectNoSnapshot = (SECT) ((_ulParentSize - HEADERSIZE + 
#endif
                                 GetSectorSize() - 1) / GetSectorSize());

        _fat.SetNoSnapshot(sectNoSnapshot);
    }

    //We flush out all of our current dirty pages - after this point,
    //   we know that any dirty pages should be remapped before being
    //   written out, assuming we aren't in overwrite mode.
    msfChk(Flush(0));

    if (!(dwFlags & STGC_OVERWRITE))
    {
        SECT sectTemp;

        if (_pmsScratch == NULL)
        {
            msfChk(_fat.FindMaxSect(&sectTemp));
        }
        else
        {
            msfChk(_fat.FindLast(&sectTemp));
        }

        _pmsShadow->InitCopy(this);

        _pmsShadow->_pdsministream = NULL;

        _fat.SetCopyOnWrite(_pmsShadow->GetFat(), sectTemp);

        _fBlockHeader = TRUE;
        msfChk(_fatDif.RemapSelf());

        if (_fIsNoSnapshot)
            msfChk(_fat.ResizeNoSnapshot());

        msfChk(_fatDif.Fixup(BP_TO_P(CMStream *, _pmsShadow)));

        if (_fIsNoSnapshot)
            _fat.ResetNoSnapshotFree();
#if DBG == 1
        _fat.CheckFreeCount();
#endif
    }
    else
    {
        _fat.SetCopyOnWrite(NULL, 0);
    }

    msfDebugOut((DEB_ITRACE,"Out CMStream::BeginCopyOnWrite()\n"));

    return S_OK;

Err:
    _fBlockHeader = FALSE;

    _pmsShadow->Empty();
    _fat.ResetCopyOnWrite();

    if (_fIsNoSnapshot)
        _fat.ResetNoSnapshotFree();

    return sc;
}



//+-------------------------------------------------------------------------
//
//  Method:     CMStream::EndCopyOnWrite, public
//
//  Synopsis:   End copy on write mode, either by committing the current
//              changes (in which case a merge is performed), or by
//              aborting the changes, in which case the persistent form
//              of the multistream should be identical to its form
//              before copy on write mode was entered.
//
//  Effects:    *Finish This*
//
//  Arguments:  [df] -- Flags to determine commit or abort status.
//
//  Requires:   The multistream must be in copy on write mode.
//
//  Returns:    S_OK if call completed OK.
//              STG_E_ACCESSDENIED if MStream was not in COW mode.
//
//  Algorithm:  If aborting, delete all shadow structures,
//                  call SetSize() on parent LStream to restore
//                  original size, and switch active controls back
//                  to originals.
//              If committing, delete all old structures, switch
//                  shadows into original position.
//
//  History:    18-Feb-92   PhilipLa    Created.
//              09-Jun-92   Philipla    Added support for fUnconverted
//
//  Notes:
//
//--------------------------------------------------------------------------


SCODE CMStream::EndCopyOnWrite(
        DWORD const dwCommitFlags,
        DFLAGS const df)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE,"In CMStream::EndCopyOnWrite(%lu)\n",df));

    BOOL fFlush = FLUSH_CACHE(dwCommitFlags);

    if (dwCommitFlags & STGC_OVERWRITE)
    {
        if (_pmsScratch != NULL)
        {
            msfChk(_fatDif.Fixup(NULL));
            _fat.ResetCopyOnWrite();
        }
        msfChk(Flush(fFlush));
    }
    else
    {
        msfAssert(_fBlockHeader &&
                aMsg("Tried to exit copy-on-write mode without entering."));

        ULARGE_INTEGER ulParentSize = {0,0};

        if (P_ABORT(df))
        {
            msfDebugOut((DEB_ITRACE,"Aborting Copy On Write mode\n"));

            Empty();

            InitCopy(BP_TO_P(CMStream *, _pmsShadow));

#ifdef LARGE_DOCFILE
            ulParentSize.QuadPart = _ulParentSize;
#else
            ULISetLow(ulParentSize, _ulParentSize);
#endif
        }
        else
        {
            SECT sectMax;

            msfChk(_fatDif.Fixup(BP_TO_P(CMStream *, _pmsShadow)));

            msfChk(Flush(fFlush));

            _fat.ResetCopyOnWrite();

            msfChk(_fat.GetMaxSect(&sectMax));

#ifdef LARGE_DOCFILE
            ulParentSize.QuadPart = ConvertSectOffset(sectMax, 0,
                    GetSectorShift());
#else
            ULISetLow(ulParentSize, ConvertSectOffset(sectMax, 0,
                    GetSectorShift()));
#endif

            msfChk(FlushHeader(HDR_FORCE));
            msfVerify(SUCCEEDED(ILBFlush(*_pplstParent, fFlush)) &&
                      aMsg("CMStream::EndCopyOnWrite ILBFLush failed.  "
                           "Non-fatal, hit Ok."));
        }

        //
        // Shrink the file if the size got smaller.
        // Don't shrink if we are in NoSnapshot mode, unless the NoSnapshot
        // limit has been set to 0 by Consolidate.
        //We don't ever expect this SetSize to fail, since it
        //   should never attempt to enlarge the file.
        if (!_fIsNoSnapshot || 0 == _fat.GetNoSnapshot())
        {
#ifdef LARGE_DOCFILE
            if (ulParentSize.QuadPart < _ulParentSize)
#else
            if (ULIGetLow(ulParentSize) < _ulParentSize)
#endif
            {
                olHVerSucc((*_pplstParent)->SetSize(ulParentSize));
            }
        }

        _pmsShadow->Empty();
        _fBlockHeader = FALSE;
        _fNewConvert = FALSE;
    }

    if (_pmsScratch != NULL)
    {
        //Let the no-scratch fat pick up whatever changed we've made.
        _pmsScratch->InitScratch(this, FALSE);
    }

    if (!_fIsNoSnapshot)
    {
        //In no-snapshot mode, we can't let the file shrink, since
        //we might blow away someone else's state.
        _ulParentSize = 0;
    }


    {
        SCODE sc2 = SetSize();
        msfVerify((SUCCEEDED(sc2) || (sc2 == E_PENDING)) &&
                  aMsg("SetSize after copy-on-write failed."));
    }

    if (_fIsNoSnapshot)
    {
        _ulParentSize = 0;
        _fat.SetNoSnapshot(0);
    }

#if DBG == 1
    STATSTG stat;
    msfHChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));
#ifndef LARGE_DOCFILE
    msfAssert(ULIGetHigh(stat.cbSize) == 0);
#endif
    msfDebugOut((DEB_ITRACE, "Parent size at end is %lu\n",
                 ULIGetLow(stat.cbSize)));
#endif

    msfDebugOut((DEB_ITRACE,"Out CMStream::EndCopyOnWrite()\n"));
Err:

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Consolidate, public
//
//  Synopsis:   Fill in the holes of a file by moving blocks toward the front.
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Algorithm:  1) Find a limit that all blocks should be moved below.
//                 The limit includes all the data, a new FAT, DIFAT and
//                 DirStream, and doesn't disturb the old fat/dif/dir blocks.
//              2) Move new fat/dif/dir sectors down. We do this with the
//                 cache's copy-on-write DIRTY behaviour.
//              3) Stream by stream move all the high sectors down.
//
//  History:	11-Feb-1997     BChapman    Created
//
//  Notes:  1) This is called in the contex of Begin/End Copy-on-Write.
//          2) We assume throughout that the underlying free sector allocator
//             returns the first free sector of the file.
//          3) The old fat/dif/dir may leave small holes in the finished file.
//----------------------------------------------------------------------------

SCODE CMStream::Consolidate(void)
{
    //
    // We don't support NOSCRATCH and this should have already
    // been checked in the caller.
    //
    msfAssert(_pmsScratch == NULL);

    SCODE sc=S_OK;

    ULONG cAllocatedSects;
    ULONG cDirEntries;
    CDirEntry *pde=NULL;

    SID sid;
    ULONG sectLast = 0;     // Last allocated Sector #.
    ULONG csectFree = 0;    // #sects that are  free.
    SECT sectLimit;         // #sects we will try to shrink the file into.
    ULONG csectLowDIF;      // #DIF sects below sectLimit.
    ULONG csectLowFAT;      // #FAT sects below sectLimit.
    ULONG csectLowControl;  // #motion sensitive sects below sectLimit.
    SECT *psectControl;     // list of Dir and Mini Fat sectors
    ULONG csectControl;     // # of sects in psectControl
    ULONG i;
    SECT sectType;

    //
    // It is quite impossible to consolidate a file when the Snapshot
    // limits are in effect.  This routine is only called when we have
    // confirmed there are no other "seperate" writers.  So it should be
    // safe to turn off the snapshot limits.
    //
    if(_fIsNoSnapshot)
    {
        _fat.SetNoSnapshot(0);
        _fat.ResetNoSnapshotFree();
    }
    //
    // Compute the Number of allocated sectors in the file.
    // Ignore the header.
    //
    msfChk(_fat.FindLast(&sectLast));
    sectLast--;
    msfChk(_fat.CountSectType(&csectFree, 0, sectLast, FREESECT));

    //
    // Compute the expected size of the consolidated file.  We will
    // use this limit to determine when a sector is too high and needs
    // to be copied down.
    //
    sectLimit = sectLast - csectFree;

    //
    //  We will move the stream data sectors by copying them to free
    // sectors and releasing the old sector.
    //  But, there are a class of sectors (control structures: FAT, DIF,
    // miniFat, Directory Stream) that the old sector cannot be freed until
    // end-copy-on-write.
    //  It is possible that the old (original) versions of these sectors
    // could exist below sectLimit and with therefore be taking up "dead"
    // space in the resulting file.  So we need to adjust sectLimit.
    //
    //  We are in Copy-On-Write mode so any FAT, DIF, Directory Stream, or
    // MiniFat sector that is modified (by moving other sectors) will be
    // copied to a free sector by the cache manager.
    //  It is difficult to know ahead of time which Low FAT sectors won't
    // be touched, and therefore can avoid being copied, so we just assume
    // we need to make a complete copy of the FAT, DIF, Directory Stream,
    // and MiniFAT.
    //

    // Count the number of FAT (and DIFat) blocks up to sectLimit.
    //
    msfChk(_fat.CountSectType(&csectLowFAT, 0, sectLimit, FATSECT));
    msfChk(_fat.CountSectType(&csectLowDIF, 0, sectLimit, DIFSECT));

    //
    // Build a list of sectors in the Directory Stream and MiniFat
    //
    msfChk(BuildConsolidationControlSectList(&psectControl, &csectControl));

    //
    // Sum all the copy-on-write control sectors below sectLimit.
    //
    csectLowControl = csectLowFAT + csectLowDIF;
    for(i=0; i<csectControl; i++)
    {
        if(psectControl[i] < sectLimit)
            ++csectLowControl;
    }

    //
    // Now we adjust sectLimit.  (see large comment above)
    // We want to increase it by csectLowControl # of sectors.
    // But, advancing over new control sectors doesn't help make space
    // so skip over those.
    // Note: In a well packed file we can hit EOF while doing this.
    //
    for( ; csectLowControl > 0; ++sectLimit)
    {
        if(sectLimit >= sectLast)
        {
            LocalFree(psectControl);
            return S_OK;
        }

        msfChkTo(Err_FreeList, _fat.GetNext(sectLimit, &sectType));
        if(    FATSECT != sectType
            && DIFSECT != sectType
            && (! IsSectorInList(sectLimit, psectControl, csectControl)) )
        {
            --csectLowControl;
        }
    }

    //
    // We are done with the control sector list.
    //
    LocalFree(psectControl);
    psectControl = NULL;

    //
    // At Last!  We begin to move some data.
    // Iterate through the directory.
    // Remapping the sectors of each Stream to below sectLimit.
    //
    cDirEntries = _dir.GetNumDirEntries();
    for(sid=0; sid<cDirEntries; sid++)
    {
        //
        // Always get the directory entry "for-writing".
        // This has the effect of remapping each sector of the directory
        // stream down into the front of the file.
        //
        msfChk(_dir.GetDirEntry(sid, FB_DIRTY, &pde));
        switch(pde->GetFlags())
        {
        case STGTY_LOCKBYTES:
        case STGTY_PROPERTY:
        case STGTY_STORAGE:
        case STGTY_INVALID:
        default:
            break;
        //
        // Remap The Mini-stream
        //
        case STGTY_ROOT:
            msfChkTo(Err_Release, ConsolidateStream(pde, sectLimit));
            GetMiniStream()->EmptyCache();
            break;

        //
        // Remap the regular streams.
        // Don't remap streams in the mini-streams
        //
        case STGTY_STREAM:
#ifdef LARGE_STREAMS
            if(pde->GetSize(_dir.IsLargeSector()) < MINISTREAMSIZE)
#else
            if(pde->GetSize() < MINISTREAMSIZE)
#endif
                break;

            msfChkTo(Err_Release, ConsolidateStream(pde, sectLimit));
            break;
        }
        _dir.ReleaseEntry(sid);
    }

    //
    // If there are any remaining un-remapped FAT blocks, remap them now.
    //  (begin-copy-on-write already remapped the DIF).
    //
    msfChk(_fat.DirtyAll());
    msfChk(_fatMini.DirtyAll());

    return sc;

Err_FreeList:
    LocalFree(psectControl);
    return sc;

Err_Release:
    _dir.ReleaseEntry(sid);
Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::BuildConsolidationControlSectList, private
//
//  Synopsis:	Makes a list of all the sectors that are copy-on-write
//              for the purpose of computing how much space we need to
//              make to Consolidate a file.
//
//  Arguments:	[ppsectList] -- [out] pointer to a list of sectors.
//              [pcsect]     -- [out] count of sectors on the list.
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	25-feb-1997	BChapman	Created
//
//----------------------------------------------------------------------------

SCODE CMStream::BuildConsolidationControlSectList(
        SECT **ppsectList,
        ULONG *pcsect)
{
    SECT sect;
    SECT *psectList;
    ULONG i, csect;
    SCODE sc;

    csect = _dir.GetNumDirSects() + _hdr.GetMiniFatLength();
    msfMem(psectList = (SECT*) LocalAlloc(LPTR, sizeof(SECT) * csect));

    i = 0;
    //
    // Walk the Directory Stream FAT chain and record all
    // the sector numbers.
    //
    sect = _hdr.GetDirStart();
    while(sect != ENDOFCHAIN)
    {
        msfAssert(i < csect);

        psectList[i++] = sect;
        msfChkTo(Err_Free, _fat.GetNext(sect, &sect));
    }
    msfAssert(i == _dir.GetNumDirSects());

    //
    // Walk the MiniFat FAT chain and record all
    // the sector numbers.
    //
    sect = _hdr.GetMiniFatStart();
    while(sect != ENDOFCHAIN)
    {
        msfAssert(i < csect);

        psectList[i++] = sect;
        msfChkTo(Err_Free, _fat.GetNext(sect, &sect));
    }
    msfAssert((i == csect) && aMsg("Directory Stream + MiniFat too short\n"));

    *ppsectList = psectList;
    *pcsect = csect;
    return S_OK;

Err_Free:
    LocalFree(psectList);
    return sc;
Err:
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::IsSectorOnList, private
//
//  Synopsis:	Searches a list of sector values for a given value.
//
//  Arguments:	[sect]      -- [in]  value to search for.
//              [psectList] -- [in]  list of sectors.
//              [csect]     -- [in]  count of sectors on the list.
//
//  Returns:	TRUE if the sector is on the list, otherwise FALSE.
//
//  Modifies:	
//
//  History:	25-feb-1997	BChapman	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CMStream::IsSectorInList(
        SECT sect,
        SECT *psectList,
        ULONG csectList)
{
    ULONG i;
    for(i=0; i < csectList; i++)
    {
        if(sect == psectList[i])
            return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::ConsolidateStream, private
//
//  Synopsis:	Scan the stream FAT chain and remap sectors that are
//              above the given limit.
//
//  Arguments:	[pde]       -- Directory entry of the stream (DIRTY)
//              [sectLimit] -- sector limit that all sectors should be below
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	18-feb-1997	BChapman	Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CMStream::ConsolidateStream(
        CDirEntry *pde,     // Current CDirEntry Object (read-only)
        SECT sectLimit)     // Move all sectors below this sector#
{
    SECT sectPrev, sectCurrent, sectNew;
    ULONG cbLength;
    SCODE sc=S_OK;

    //
    // This code should not be used in NOSCRATCH mode.
    //
    msfAssert(_pmsScratch == NULL);

    //
    // Check the first sector of the stream as a special case.
    //
    sectCurrent = pde->GetStart();
    if(ENDOFCHAIN != sectCurrent && sectCurrent > sectLimit)
    {
        msfChk(_fat.GetFree(1, &sectNew, GF_WRITE));

        //  This is only here because I don't understand GetFree().
        msfAssert(ENDOFCHAIN != sectNew);

        msfChk(MoveSect(ENDOFCHAIN, sectCurrent, sectNew));
        sectCurrent = sectNew;
        pde->SetStart(sectCurrent);
    }

    //
    // Do the rest of the stream FAT chain.
    //
    sectPrev = sectCurrent;
    while(ENDOFCHAIN != sectPrev)
    {
        msfChk(_fat.GetNext(sectPrev, &sectCurrent));
        if(ENDOFCHAIN != sectCurrent && sectCurrent > sectLimit)
        {
            msfChk(_fat.GetFree(1, &sectNew, GF_WRITE));

            //  This is only here because I don't understand GetFree().
            msfAssert(ENDOFCHAIN != sectNew);

            msfChk(MoveSect(sectPrev, sectCurrent, sectNew));
            sectCurrent = sectNew;
        }
        sectPrev = sectCurrent;
    }

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::MoveSect, private
//
//  Synopsis:	Move Data Sector for Consolidation Support.
//
//  Arguments:	[sectPrev] -- Previous sector, so the link can be updated.
//              [sectOld]  -- Location to copy from
//              [sectNew]  -- Location to copy to
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	20-Feb-1997	BChapman	Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SCODE CMStream::MoveSect(
        SECT sectPrev,
        SECT sectOld,
        SECT sectNew)
{
    ULONG cb;
    SCODE sc=S_OK;
    ULARGE_INTEGER ulOff;
    BYTE *pbScratch = BP_TO_P(BYTE HUGEP *, _pCopySectBuf);

    //
    // This code does not expect NOSCRATCH mode.
    //
    msfAssert(_pmsScratch == NULL);

    //
    // Copy the data from the old sector to the new sector.
    //
    ulOff.QuadPart = ConvertSectOffset(sectOld, 0, GetSectorShift());
    msfChk((*_pplstParent)->ReadAt(ulOff,
                                   pbScratch,
                                   GetSectorSize(),
                                   &cb));

    ulOff.QuadPart = ConvertSectOffset(sectNew, 0, GetSectorShift());
    msfChk((*_pplstParent)->WriteAt(ulOff,
                                    pbScratch,
                                    GetSectorSize(),
                                    &cb));

    //
    // Update the previous sector's link (if this isn't the first sector)
    //
    if(ENDOFCHAIN != sectPrev)
    {
        msfChk(_fat.SetNext(sectPrev, sectNew));
    }

    //
    // Update the link to the next sector.
    //
    SECT sectTemp;
    msfChk(_fat.GetNext(sectOld, &sectTemp));
    msfChk(_fat.SetNext(sectNew, sectTemp));

    //
    // Free the old sector.
    //
    msfChk(_fat.SetNext(sectOld, FREESECT));

Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::CopySect, private
//
//  Synopsis:	Do a partial sector delta for copy-on-write support
//
//  Arguments:	[sectOld] -- Location to copy from
//              [sectNew] -- Location to copy to
//              [oStart] -- Offset into sector to begin delta
//              [oEnd] -- Offset into sector to end delta
//              [pb] -- Buffer to delta from
//              [pulRetval] -- Return location for number of bytes written
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	22-Jan-93	PhilipLa	Created
//
//  Notes:	[pb] may be unsafe memory
//
//----------------------------------------------------------------------------


//This pragma is to avoid a C7 bug when building RETAIL
#if _MSC_VER == 700 && DBG == 0
#pragma function(memcpy)
#endif

SCODE CMStream::CopySect(
        SECT sectOld,
        SECT sectNew,
        OFFSET oStart,          // First byte of the sector to copy.
        OFFSET oEnd,            // Last byte of the sector to copy.
        BYTE const HUGEP *pb,
        ULONG *pulRetval)
{
    SCODE sc;

    ULONG cb;
    ULARGE_INTEGER ulOff;

    ULISetHigh(ulOff, 0);

    BYTE HUGEP *pbScratch = BP_TO_P(BYTE HUGEP *, _pCopySectBuf);

#if DBG == 1
    msfAssert((_uBufferRef == 0) &&
            aMsg("Attempted to use CopySect buffer while refcount != 0"));
    AtomicInc(&_uBufferRef);
#endif

    msfAssert((pbScratch != NULL) && aMsg("No CopySect buffer found."));

#ifdef LARGE_DOCFILE
    ulOff.QuadPart = ConvertSectOffset(sectOld, 0, GetSectorShift());
#else
    ULISetLow(ulOff, ConvertSectOffset(sectOld, 0, GetSectorShift()));
#endif
    msfHChk((*_pplstParent)->ReadAt(
            ulOff,
            pbScratch,
            GetSectorSize(),
            &cb));

    //Now do delta in memory.
    BYTE HUGEP *pstart;
    pstart = pbScratch + oStart;

    USHORT memLength;
    memLength = oEnd - oStart + 1;

    TRY
    {
        memcpy(pstart, pb, memLength);
    }
    CATCH(CException, e)
    {
        UNREFERENCED_PARM(e);
        msfErr(Err, STG_E_INVALIDPOINTER);
    }
    END_CATCH

#ifdef LARGE_DOCFILE
    ulOff.QuadPart = ConvertSectOffset(sectNew, 0, GetSectorShift());
#else
    ULISetLow(ulOff, ConvertSectOffset(sectNew, 0, GetSectorShift()));
#endif
    msfHChk((*_pplstParent)->WriteAt(
            ulOff,
            pbScratch,
            GetSectorSize(),
            &cb));

    *pulRetval = memLength;

 Err:
#if DBG == 1
    AtomicDec(&_uBufferRef);
#endif
    return sc;
}


//This returns the compiler to the default behavior
#if _MSC_VER == 700 && DBG == 0
#pragma intrinsic(memcpy)
#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMStream::MWrite, public
//
//  Synposis:   Do multiple sector writes
//
//  Effects:    Causes multiple stream writes.  Modifies fat and directory
//
//  Arguments:  [ph] -- Handle of stream doing write
//              [start] -- Starting sector to write
//              [oStart] -- offset into sector to begin write at
//              [end] -- Last sector to write
//              [oEnd] -- offset into last sector to write to
//              [buffer] -- Pointer to buffer into which data will be written
//              [ulRetVal] -- location to return number of bytes written
//
//  Returns:    Error code of any failed call to parent write
//              S_OK if call completed OK.
//
//  Modifies:   ulRetVal returns the number of bytes written
//
//  Algorithm:  Using a segment table, perform writes on parent stream
//              until call is completed.
//
//  History:    16-Aug-91   PhilipLa    Created.
//              10-Sep-91   PhilipLa    Converted to use sector table
//              11-Sep-91   PhilipLa    Modified interface, modified to
//                                      allow partial sector writes.
//              07-Jan-92   PhilipLa    Converted to use handle.
//              18-Feb-92   PhilipLa    Added copy on write support.
//
//  Notes:      [pvBuffer] may be unsafe memory
//
//---------------------------------------------------------------------------


SCODE CMStream::MWrite(
        SID sid,
        BOOL fIsMini,
#ifdef LARGE_STREAMS
        ULONGLONG ulOffset,
#else
        ULONG ulOffset,
#endif
        VOID const HUGEP *pvBuffer,
        ULONG ulCount,
        CStreamCache *pstmc,
        ULONG *pulRetval)
{
    SCODE sc;
    BYTE const HUGEP *pbBuffer = (BYTE const HUGEP *) pvBuffer;

    USHORT cbSector = GetSectorSize();
    CFat *pfat = &_fat;
    USHORT uShift = GetSectorShift();
    ULONG ulLastBytes = 0;

    ULARGE_INTEGER ulOff;
    ULISetHigh(ulOff, 0);

#ifdef LARGE_STREAMS
    ULONGLONG ulOldSize = 0;
#else
    ULONG ulOldSize = 0;
#endif

    //  Check if it's a small stream and whether this is a real or
    //  scratch multistream.

    if ((fIsMini) &&
        (!_fIsScratch) &&
        (SIDMINISTREAM != sid))
    {
        msfAssert(sid <= MAXREGSID &&
                aMsg("Invalid SID in MWrite"));
        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        pfat = GetMiniFat();
    }

    USHORT uMask = cbSector - 1;

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    msfDebugOut((DEB_ITRACE,"In CMStream::MWrite(%lu,%u,%lu,%u)\n",
            start,oStart,end,oEnd));

    ULONG bytecount;
    ULONG total = 0;

    msfChk(_dir.GetSize(sid, &ulOldSize));


//BEGIN COPYONWRITE

    //  Note that we don't do this for ministreams (the second pass through
    //  this code will take care of it).

    msfAssert(!_fBlockWrite &&
            aMsg("Called MWrite on Unconverted multistream"));

    if ((_fBlockHeader) && (GetMiniFat() != pfat))
    {
        msfDebugOut((DEB_ITRACE,"**MWrite preparing for copy-on-write\n"));

        SECT sectOldStart, sectNewStart, sectOldEnd, sectNewEnd;

        SECT sectNew;
        if (start != 0)
        {
            msfChk(pstmc->GetESect(start - 1, &sectNew));
        }
        else
        {
            msfChk(_dir.GetStart(sid, &sectNew));
        }

        msfChk(_fat.Remap(
                sectNew,
                (start == 0) ? 0 : 1,
                (end - start + 1),
                &sectOldStart,
                &sectNewStart,
                &sectOldEnd,
                &sectNewEnd));

        msfAssert(((end != start) || (sectNewStart == sectNewEnd)) &&
                aMsg("Remap postcondition failed."));

        if (sc != S_FALSE)
        {
            msfChk(pstmc->EmptyRegion(start, end));
        }

        if ((start == 0) && (sectNewStart != ENDOFCHAIN))
        {
            msfDebugOut((DEB_ITRACE,
                    "*** Remapped first sector.  Changing directory.\n"));
            msfChk(_dir.SetStart(sid, sectNewStart));
        }

#ifdef LARGE_STREAMS
        ULONGLONG ulSize = ulOldSize;
#else
        ULONG ulSize = ulOldSize;
#endif

        if (((oStart != 0) ||
             ((end == start) && (ulOffset + ulCount != ulSize)
              && ((USHORT)oEnd != (cbSector - 1)))) &&
            (sectNewStart != ENDOFCHAIN))
        {
            //Partial first sector.
            ULONG ulRetval;

            msfChk(CopySect(
                    sectOldStart,
                    sectNewStart,
                    oStart,
                    (end == start) ? oEnd : (cbSector - 1),
                    pbBuffer,
                    &ulRetval));

            pbBuffer = pbBuffer + ulRetval;
            total = total + ulRetval;
            start++;
            oStart = 0;
        }

        if (((end >= start) && ((USHORT)oEnd != cbSector - 1) &&
             (ulCount + ulOffset != ulSize)) &&
            (sectNewEnd != ENDOFCHAIN))
        {
            //Partial last sector.

            msfAssert(((end != start) || (oStart == 0)) &&
                    aMsg("CopySect precondition failed."));

            msfChk(CopySect(
                    sectOldEnd,
                    sectNewEnd,
                    0,
                    oEnd,
                    pbBuffer + ((end - start) << uShift) - oStart,
                    &ulLastBytes));

            end--;
            oEnd = cbSector - 1;
            //We don't need to update pbBuffer, since the change
            //    is at the end.
        }
    }


//  At this point, the entire block has been moved into the copy-on-write
//   area of the multistream, and all partial writes have been done.
//END COPYONWRITE

    msfAssert(end != 0xffffffffL);

    if (end < start)
    {
        *pulRetval = total + ulLastBytes;
        goto Err;
    }

    ULONG ulRunLength;
    ulRunLength = end - start + 1;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        SSegment segtab[CSEG + 1];

        ULONG cSeg;
        msfChk(pstmc->Contig(
                start,
                TRUE,
                (SSegment STACKBASED *) segtab,
                ulRunLength,
                &cSeg));

        msfAssert(cSeg <= CSEG);

        USHORT oend = cbSector - 1;
        ULONG i;
        SECT sectStart;
        for (USHORT iseg = 0; iseg < cSeg;)
        {
            sectStart = segtab[iseg].sectStart;
            i = segtab[iseg].cSect;
            if (i > ulRunLength)
                i = ulRunLength;

            ulRunLength -= i;
            start += i;

            iseg++;
            if (ulRunLength == 0)
                oend = oEnd;

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            msfDebugOut((
                    DEB_ITRACE,
                    "Calling lstream WriteAt(%lu,%p,%lu)\n",
                    ConvertSectOffset(sectStart,offset,uShift),
                    pbBuffer,
                    ulSize));

            if (GetMiniFat() == pfat)
            {
                sc = _pdsministream->CDirectStream::WriteAt(
                        (sectStart << uShift) + offset,
                        pbBuffer, ulSize,
                        (ULONG STACKBASED *)&bytecount);
            }
            else
            {
#ifdef LARGE_DOCFILE
                ulOff.QuadPart = ConvertSectOffset(sectStart, offset, uShift);
#else
                ULISetLow(ulOff, ConvertSectOffset(sectStart, offset,
                        uShift));
#endif
                sc = DfGetScode((*_pplstParent)->WriteAt(ulOff, pbBuffer,
                        ulSize, &bytecount));
            }

            total += bytecount;

            //Check if this write is the last one in the stream,
                //   and that the stream ends as a partial sector.
                //If so, fill out the remainder of the sector with
                //   something.
            if ((0 == ulRunLength) && (total + ulOffset > ulOldSize) &&
                (((total + ulOffset) & (GetSectorSize() - 1)) != 0))
            {
                //This is the last sector and the stream has grown.
                ULONG csectOld = (ULONG)((ulOldSize + GetSectorSize() - 1) >>
                    GetSectorShift());

                ULONG csectNew = (ULONG)((total + ulOffset + GetSectorSize() - 1) >>
                    GetSectorShift());

                if (csectNew > csectOld)
                {
                    msfAssert(!fIsMini &&
                            aMsg("Small stream grew in MWrite"));

                    SECT sectLast = sectStart + i - 1;

                    msfVerify(SUCCEEDED(SecureSect(
                            sectLast,
                            total + ulOffset,
                            FALSE)));
                }
            }

            if (0 == ulRunLength || FAILED(sc))
            {
                break;
            }

            pbBuffer = pbBuffer + bytecount;
            offset = 0;
        }

        if (0 == ulRunLength || FAILED(sc))
        {
            *pulRetval = total + ulLastBytes;
            msfDebugOut((
                    DEB_ITRACE,
                    "Out CMStream::MWrite()=>%lu, retval = %lu\n",
                    sc,
                    total));
            break;
        }
    }

 Err:

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Flush, public
//
//  Synopsis:	Flush control structures.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	16-Dec-92	PhilipLa	Created
//
//----------------------------------------------------------------------------


SCODE CMStream::Flush(BOOL fFlushCache)
{
    SCODE sc = S_OK;

    msfAssert(!_fBlockWrite &&
            aMsg("Flush called on unconverted base."));

    if ((!_fIsScratch) && (*_pplstParent != NULL))
    {
        msfChk(_pmpt->Flush());
        msfChk(FlushHeader(HDR_NOFORCE));
        msfChk(ILBFlush(*_pplstParent, fFlushCache));
    }
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILBFlush
//
//  Synopsis:   Flush as thoroughly as possible
//
//  Effects:    Flushes ILockBytes
//
//  Arguments:  [pilb]        - ILockBytes to flush
//              [fFlushCache] - Flush thoroughly iff TRUE
//
//  Returns:    SCODE
//
//  Algorithm:
//
//  History:    12-Feb-93 AlexT     Created
//
//--------------------------------------------------------------------------


SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache)
{
    //  Try to query interface to our own implementation

    IFileLockBytes *pfl;
    SCODE sc;

    msfDebugOut((DEB_ITRACE, "In ILBFlushCache(%p)\n", pilb));

    // Check for FileLockBytes

    if (!fFlushCache ||
        FAILED(DfGetScode(pilb->QueryInterface(IID_IFileLockBytes, (void **)&pfl))))
    {
        //  Either we don't have to flush the cache or its not our ILockBytes
        sc = DfGetScode(pilb->Flush());
    }
    else
    {
        //  We have to flush the cache and its our ILockBytes
        sc = DfGetScode(pfl->FlushCache());
        pfl->Release();
    }

    msfDebugOut((DEB_ITRACE, "Out ILBFlushCache()\n"));

    return(sc);
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::SecureSect, public
//
//  Synopsis:	Zero out the unused portion of a sector
//
//  Arguments:	[sect] -- Sector to zero out
//              [ulSize] -- Size of stream
//              [fIsMini] -- TRUE if stream is in ministream
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	05-Apr-93	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------


SCODE CMStream::SecureSect(
        const SECT sect,
#ifdef LARGE_STREAMS
        const ULONGLONG ulSize,
#else
        const ULONG ulSize,
#endif
        const BOOL fIsMini)
{
#ifdef SECURE_TAIL
    SCODE sc = S_OK;
    BYTE *pb = NULL;

    if (!_fIsScratch)
    {
        ULONG cbSect = fIsMini ? MINISECTORSIZE : GetSectorSize();

        msfAssert(ulSize != 0);

        ULONG ulOffset = (ULONG)(((ulSize - 1) % cbSect) + 1);

        ULONG cb = cbSect - ulOffset;

        msfAssert(cb != 0);

        //We can use any initialized block of memory here.  The header
        // is available and is the correct size, so we use that.
#ifdef SECURE_BUFFER
        pb = s_bufSecure;
#else
        pb = (BYTE *)_hdr.GetData();
#endif

#ifdef SECURETEST
        pb = (BYTE *) DfMemAlloc(cb);
        if (pb != NULL)
            memset(pb, 'Y', cb);
#endif
        ULONG cbWritten;

        if (!fIsMini)
        {
            ULARGE_INTEGER ulOff;
#ifdef LARGE_DOCFILE
            ulOff.QuadPart = ConvertSectOffset(
                    sect,
                    (OFFSET)ulOffset,
                    GetSectorShift());
#else
            ULISet32 (ulOff, ConvertSectOffset(
                    sect,
                    (OFFSET)ulOffset,
                    GetSectorShift()));
#endif

            msfChk(DfGetScode((*_pplstParent)->WriteAt(
                    ulOff,
                    pb,
                    cb,
                    &cbWritten)));
        }
        else
        {
            msfChk(_pdsministream->WriteAt(
                    (sect << MINISECTORSHIFT) + ulOffset,
                    pb,
                    cb,
                    (ULONG STACKBASED *)&cbWritten));
        }

        if (cbWritten != cb)
        {
            sc = STG_E_WRITEFAULT;
        }
    }

Err:
#ifdef SECURETEST
    DfMemFree(pb);
#endif

    return sc;
#else
    //On NT, our sectors get zeroed out by the file system, so we don't
    //  need this whole rigamarole.
    return S_OK;
#endif // WIN32 == 200
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetFileLockBytesTime, public
//
//  Synopsis:   Set the IFileLockBytes time.
//
//  Arguments:  [tt] -- Timestamp requested (WT_CREATION, WT_MODIFICATION,
//                          WT_ACCESS)
//              [nt] -- New timestamp
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Query for IFileLockBytes and call its SetTime member.
//
//  History:    01-Sep-95       MikeHill        Created.
//
//--------------------------------------------------------------------------

SCODE CMStream::SetFileLockBytesTime(
    WHICHTIME const tt,
    TIME_T nt)
{
     SCODE sc = S_OK;
     ILockBytes *pilb = *_pplstParent;
     IFileLockBytes *pfl;

     
     if (pilb && 
         (SUCCEEDED(pilb->QueryInterface(IID_IFileLockBytes, (void **)&pfl))))
     {

         sc = ((CFileStream *)pfl)->SetTime(tt, nt);
         pfl->Release();

     }

     return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetAllFileLockBytesTimes, public
//
//  Synopsis:   Set the IFileLockBytes time.
//
//  Arguments:
//              [atm] -- ACCESS time
//              [mtm] -- MODIFICATION time
//				[ctm] -- CREATION time
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Query for IFileLockBytes and call its SetAllTimes member.
//
//  History:    29-Nov-95       SusiA        Created.
//
//--------------------------------------------------------------------------

SCODE CMStream::SetAllFileLockBytesTimes(
        TIME_T atm,
        TIME_T mtm,
        TIME_T ctm)
{
     SCODE sc = S_OK;
     ILockBytes *pilb = *_pplstParent;
     IFileLockBytes *pfl;

     if (SUCCEEDED(pilb->QueryInterface( IID_IFileLockBytes, (void **)&pfl)))
     {

         sc = ((CFileStream *)pfl)->SetAllTimes(atm, mtm, ctm);
         pfl->Release();

     }

     return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetTime, public
//
//  Synopsis:   Set the time for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [tt] -- Timestamp requested (WT_CREATION, WT_MODIFICATION,
//                          WT_ACCESS)
//              [nt] -- New timestamp
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Call through to directory
//
//  History:    01-Apr-92       PhilipLa        Created.
//              14-Sep-92       PhilipLa        inlined.
//              <Missing history>
//              26-APR-99       RogerCh         Removed faulty optimization
//
//--------------------------------------------------------------------------

SCODE CMStream::SetTime(
    SID const sid,
    WHICHTIME const tt,
    TIME_T nt)
{

    if ( sid == SIDROOT )
    {
        SCODE sc;

        if( FAILED( sc = SetFileLockBytesTime( tt, nt )))
        {
          return sc;
        }
    }// if( sid == SIDROOT)

    return _dir.SetTime(sid, tt, nt);
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::SetAllTimes, public
//
//  Synopsis:   Set all the times for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [atm] -- ACCESS time
//              [mtm] -- MODIFICATION time
//				[ctm] -- CREATION time
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm:  Call through to directory
//
//  History:    27-Nov-95	SusiA	Created
//
//--------------------------------------------------------------------------

SCODE CMStream::SetAllTimes(
    SID const sid,
    TIME_T atm,
    TIME_T mtm,
	TIME_T ctm)
{

    if ( sid == SIDROOT )
    {

        SCODE sc;

           if( FAILED( sc = SetAllFileLockBytesTimes(atm, mtm, ctm )))
           {
              return sc;
           }
    }
    return _dir.SetAllTimes(sid, atm, mtm, ctm);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::GetTime, public
//
//  Synopsis:   Get the time for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [tt] -- Timestamp requested (WT_CREATION, WT_MODIFICATION,
//                          WT_ACCESS)
//              [pnt] -- Pointer to return location
//
//  Returns:    S_OK if call completed OK.
//
//  History:    01-Apr-92       PhilipLa        Created.
//              14-Sep-92       PhilipLa        inlined.
//
//--------------------------------------------------------------------------

SCODE CMStream::GetTime(SID const sid,
        WHICHTIME const tt,
        TIME_T *pnt)
{
    SCODE sc = S_OK;

    if (sid == SIDROOT)
    {
        //Get timestamp from ILockBytes
        STATSTG stat;

        msfChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));

        if (tt == WT_CREATION)
        {
            *pnt = stat.ctime;
        }
        else if (tt == WT_MODIFICATION)
        {
            *pnt = stat.mtime;
        }
        else
        {
            *pnt = stat.atime;
        }
    }
    else
        sc = _dir.GetTime(sid, tt, pnt);
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::GetAllTimes, public
//
//  Synopsis:   Get the times for a given handle
//
//  Arguments:  [sid] -- SID to retrieve time for
//              [patm] -- Pointer to the ACCESS time
//              [pmtm] -- Pointer to the MODIFICATION time
//		[pctm] -- Pointer to the CREATION time
//
//  Returns:    S_OK if call completed OK.
//
//  History:    26-May-95	SusiA	Created
//
//--------------------------------------------------------------------------

SCODE CMStream::GetAllTimes(SID const sid,
        TIME_T *patm,
        TIME_T *pmtm,
	TIME_T *pctm)
{
    SCODE sc = S_OK;

    if (sid == SIDROOT)
    {
        //Get timestamp from ILockBytes
        STATSTG stat;

        msfChk((*_pplstParent)->Stat(&stat, STATFLAG_NONAME));

        *pctm = stat.ctime;
        *pmtm = stat.mtime;
        *patm = stat.atime;

    }
    else
        sc = _dir.GetAllTimes(sid, patm, pmtm, pctm);
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::InitScratch, public
//
//  Synopsis:	Set up a multistream for NoScratch operation
//
//  Arguments:	[pms] -- Pointer to base multistream
//              [fNew] -- True if this is the first time the function has
//                        been called (init path), FALSE if merging behavior
//                        is required (EndCopyOnWrite)
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	02-Mar-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMStream::InitScratch(CMStream *pms, BOOL fNew)
{
    msfDebugOut((DEB_ITRACE, "In  CMStream::InitScratch:%p()\n", this));

    msfAssert(GetSectorSize() == SCRATCHSECTORSIZE);
    msfAssert(_fIsNoScratch &&
              aMsg("Called InitScratch on Multistream not in NoScratch mode"));

    return _fatMini.InitScratch(pms->GetFat(), fNew);
}

#ifdef MULTIHEAP
//+--------------------------------------------------------------
//
//  Member: CMStream::GetMalloc, public
//
//  Synopsis:   Returns the allocator associated with this multistream
//
//  History:    05-May-93   AlexT   Created
//
//---------------------------------------------------------------

IMalloc * CMStream::GetMalloc(VOID) const
{
    return (IMalloc *) &g_smAllocator;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\oleguid.h ===
/*****************************************************************************\
*                                                                             *
* oleguid.h -   Master definition of GUIDs for ole2.dll                       *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all public GUIDs specific to OLE 
   and is included in ole2.h.
   
   NOTE: The second least significant byte of all of these GUIDs is 1.
*/
   

DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0); // unused
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);

DEFINE_OLEGUID(IID_IRunnableObject,         0x00000126, 0, 0);

DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IOleCache2,				0x00000128, 0, 0);
DEFINE_OLEGUID(IID_IOleCacheControl,        0x00000129, 0, 0);

/* NOTE: LSB values 0x27 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\compobj.h ===
/*****************************************************************************\
*                                                                             *
* compobj.h - 	Component object model definitions							  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_

/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __cdecl
#define STDAPICALLTYPE          __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif // WIN32

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __TURBOC__
#define interface               struct huge
#else
#define interface               struct FAR
#endif
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

#else
#define interface               struct

#ifdef _MAC

#define STDMETHOD(method)       long    method##pad;\
                                HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) long    method##pad;\
                                type (STDMETHODCALLTYPE * method)

#else // _MAC

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#endif // !_MAC

#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif


/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT
#endif  // __cplusplus
#endif  // FARSTRUCT

#ifndef WIN32
//this is historical stuff

#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */

#endif // !WIN32

typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

//Handle Unicode for all platforms

//Win 16 platforms
#ifndef UNICODE

#define LPXSTR    LPSTR
#define LPCXSTR   LPCSTR
#define XCHAR     char
#define XSTR(str)  str

#else  //Win32

#define LPXSTR    LPWSTR
#define LPCXSTR   LPCWSTR
#define XCHAR     WCHAR
#define XSTR(str)  L##str

#endif //!WIN32

//end of Unicode issues

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)

#define CLASS_E_CLASSNOTAVAILABLE   (CLASSFACTORY_E_FIRST + 0x1)
// dll doesn't support that class (returned from DllGetClassObject)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)

// the caller is dispatching an intertask SendMessage call and
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)

// the caller is dispatching an asynchronus call can NOT
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)

// the callee (server [not server application]) is not available
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)

// the caller (client ) disappeared while the callee (server) was
// processing a call
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)

// the date paket with the marshalled parameter data is
// incorrect
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)

// the call was not transmitted properly; the message queue
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)

// the client (caller) can not marshall the parameter data
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)

// received data are invalid; can be server or
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)

// DDE conversation - no second outgoing call on same channel
#define RPC_E_CANTCALLOUT_AGAIN			(RPC_E_FIRST + 0x11)

// a internal error occured
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/

#ifndef GUID_DEFINED
#define GUID_DEFINED

#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

#endif     //GUID_DEFINED

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in compobj.dll.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if defined(__cplusplus)
#define REFGUID             const GUID FAR&
#define REFIID              const IID FAR&
#define REFCLSID            const CLSID FAR&
#else
#define REFGUID             const GUID FAR* const
#define REFIID              const IID FAR* const
#define REFCLSID            const CLSID FAR* const
#endif


#ifndef INITGUID
#include "coguid.h"
#endif

/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
								// and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
								// context.

	// NOTE: CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE is the same as
	// (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE, but
	// not the same as CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

typedef struct tagINTERFACEINFO
{
    interface IUnknown FAR *pUnk;       // the pointer to the object
    IID      			iid;            // interface id
    WORD        		wMethod;        // interface methode
} INTERFACEINFO, FAR * LPINTERFACEINFO;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message

} PENDINGMSG;


// bit flags for IExternalConnection
typedef enum tagEXTCONN
{
	EXTCONN_STRONG		= 0x0001	// strong connection
} EXTCONN;


/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};

typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv,
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv,
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext,
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                DWORD dwReserved ) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwPendingType  ) PURE;
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** External Connection Information ***********************************/

#undef  INTERFACE
#define INTERFACE   IExternalConnection

DECLARE_INTERFACE_(IExternalConnection, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExternalConnection methods ***
    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD extconn, DWORD reserved) PURE;
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses) PURE;
};
typedef       IExternalConnection FAR* LPEXTERNALCONNECTION;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt,
                       LPXSTR FAR* rgelt,
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);
STDAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPXSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPXSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPXSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPXSTR FAR* lplpsz);
STDAPI IIDFromString(LPXSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPXSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCXSTR lpszProgID, LPCLSID lpclsid);
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPXSTR lpsz, int cbMax);

STDAPI CoCreateGuid(GUID FAR *pguid);

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPXSTR lpstrExpr, LPXSTR lpstrMsg, LPXSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\valid.h ===
#define IsValidPtrIn(pv,cb)  (!IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );
STDAPI_(BOOL) IsValidIid( REFIID riid );

 
#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__); return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__), retval)

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__), retval)
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__); return; }

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__); return retval; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return; 
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) \
    return retval; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\dvobj.h ===
/*****************************************************************************\
*                                                                             *
* dvobj.h -		Data/View object definitions								  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _DVOBJ_H_ )
#define _DVOBJ_H_

/****** DV value types ******************************************************/

//      forward type declarations
#if defined(__cplusplus)
interface IStorage;
interface IStream;
interface IAdviseSink;
interface IMoniker;
#else
typedef interface IStorage IStorage;
typedef interface IStream IStream;
typedef interface IAdviseSink IAdviseSink;
typedef interface IMoniker IMoniker;
#endif

typedef            IStorage FAR* LPSTORAGE;
typedef             IStream FAR* LPSTREAM;
typedef         IAdviseSink FAR* LPADVISESINK;
typedef             IMoniker FAR* LPMONIKER;


#if !defined(_MAC)
typedef WORD CLIPFORMAT;
#else
typedef unsigned long CLIPFORMAT;            // ResType
#endif
typedef  CLIPFORMAT FAR* LPCLIPFORMAT;


// Data/View aspect; specifies the desired aspect of the object when
// drawing or getting data.
typedef enum tagDVASPECT
{
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;


// Data/View target device; determines the device for drawing or gettting data
typedef struct FARSTRUCT tagDVTARGETDEVICE
{
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;


// Format, etc.; completely specifices the kind of data desired, including tymed
typedef struct FARSTRUCT tagFORMATETC
{
    CLIPFORMAT          cfFormat;
    DVTARGETDEVICE FAR* ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC, FAR* LPFORMATETC;


// TYpes of storage MEDiums; determines how data is stored or passed around
typedef enum tagTYMED
{
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_NULL = 0
} TYMED;


// DATA format DIRection
typedef enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET = 2,
} DATADIR;


// SToraGe MEDIUM; a block of data on a particular medium
typedef struct FARSTRUCT tagSTGMEDIUM
{
    DWORD   tymed;
    union
    {
        HANDLE  hGlobal;
        LPXSTR   lpszFileName;
        IStream FAR* pstm;
        IStorage FAR* pstg;
    }
#ifdef NONAMELESSUNION
    u       // add a tag when name less unions not supported
#endif
    ;
    IUnknown FAR* pUnkForRelease;
} STGMEDIUM, FAR* LPSTGMEDIUM;


// Advise Flags
typedef enum tagADVF
{
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;


// Stats for data; used by several enumerations and by at least one
// implementation of IDataAdviseHolder; if a field is not used, it
// will be NULL.
typedef struct FARSTRUCT tagSTATDATA
{                                   // field used by:
    FORMATETC formatetc;            // EnumAdvise, EnumData (cache), EnumFormats
    DWORD advf;                     // EnumAdvise, EnumData (cache)
    IAdviseSink FAR* pAdvSink;      // EnumAdvise
    DWORD dwConnection;             // EnumAdvise
} STATDATA;

typedef  STATDATA FAR* LPSTATDATA;



/****** DV Interfaces ***************************************************/


#undef  INTERFACE
#define INTERFACE   IEnumFORMATETC

DECLARE_INTERFACE_(IEnumFORMATETC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) PURE;
};
typedef        IEnumFORMATETC FAR* LPENUMFORMATETC;


#undef  INTERFACE
#define INTERFACE   IEnumSTATDATA

DECLARE_INTERFACE_(IEnumSTATDATA, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IEnumSTATDATA methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATDATA FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATDATA FAR* FAR* ppenum) PURE;
};
typedef        IEnumSTATDATA FAR* LPENUMSTATDATA;



#undef  INTERFACE
#define INTERFACE   IDataObject

#define DATA_E_FORMATETC        DV_E_FORMATETC
#define DATA_S_SAMEFORMATETC    (DATA_S_FIRST + 0)

DECLARE_INTERFACE_(IDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(QueryGetData) (THIS_ LPFORMATETC pformatetc ) PURE;
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ LPFORMATETC pformatetc,
                            LPFORMATETC pformatetcOut) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,
                            LPENUMFORMATETC FAR* ppenumFormatEtc) PURE;

    STDMETHOD(DAdvise) (THIS_ FORMATETC FAR* pFormatetc, DWORD advf,
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
};
typedef      IDataObject FAR* LPDATAOBJECT;



#undef  INTERFACE
#define INTERFACE   IViewObject

#define VIEW_E_DRAW             (VIEW_E_FIRST)
#define E_DRAW                  VIEW_E_DRAW

#define VIEW_S_ALREADY_FROZEN   (VIEW_S_FIRST)

DECLARE_INTERFACE_(IViewObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw,
                    LPCRECTL lprcBounds,
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD),
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf,
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf,
                    LPADVISESINK FAR* ppAdvSink) PURE;
};
typedef      IViewObject FAR* LPVIEWOBJECT;


#undef  INTERFACE
#define INTERFACE   IViewObject2

DECLARE_INTERFACE_(IViewObject2, IViewObject)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw,
                    LPCRECTL lprcBounds,
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD),
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf,
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf,
                    LPADVISESINK FAR* ppAdvSink) PURE;
					
    // *** IViewObject2 methods ***
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    DVTARGETDEVICE FAR * ptd, LPSIZEL lpsizel) PURE;
					
};
typedef      IViewObject2 FAR* LPVIEWOBJECT2;


#undef  INTERFACE
#define INTERFACE   IAdviseSink

DECLARE_INTERFACE_(IAdviseSink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc,
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;
};
typedef      IAdviseSink FAR* LPADVISESINK;



#undef  INTERFACE
#define INTERFACE   IAdviseSink2

DECLARE_INTERFACE_(IAdviseSink2, IAdviseSink)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc,
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;

    // *** IAdviseSink2 methods ***
    STDMETHOD_(void,OnLinkSrcChange)(THIS_ LPMONIKER pmk) PURE;
};
typedef      IAdviseSink2 FAR* LPADVISESINK2;



#undef  INTERFACE
#define INTERFACE   IDataAdviseHolder

DECLARE_INTERFACE_(IDataAdviseHolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDataAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPDATAOBJECT pDataObject, FORMATETC FAR* pFetc,
            DWORD advf, LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnDataChange)(THIS_ LPDATAOBJECT pDataObject, DWORD dwReserved, DWORD advf) PURE;
};
typedef      IDataAdviseHolder FAR* LPDATAADVISEHOLDER;



#undef  INTERFACE
#define INTERFACE   IOleCache

#define CACHE_E_NOCACHE_UPDATED         (CACHE_E_FIRST)

#define CACHE_S_FORMATETC_NOTSUPPORTED  (CACHE_S_FIRST)
#define CACHE_S_SAMECACHE               (CACHE_S_FIRST+1)
#define CACHE_S_SOMECACHES_NOTUPDATED   (CACHE_S_FIRST+2)


DECLARE_INTERFACE_(IOleCache, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
};
typedef         IOleCache FAR* LPOLECACHE;



// Cache update Flags

#define	UPDFCACHE_NODATACACHE			0x00000001
#define UPDFCACHE_ONSAVECACHE			0x00000002
#define	UPDFCACHE_ONSTOPCACHE			0x00000004
#define	UPDFCACHE_NORMALCACHE			0x00000008
#define	UPDFCACHE_IFBLANK				0x00000010
#define UPDFCACHE_ONLYIFBLANK			0x80000000

#define UPDFCACHE_IFBLANKORONSAVECACHE	(UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE )
#define UPDFCACHE_ALL					(~UPDFCACHE_ONLYIFBLANK)
#define UPDFCACHE_ALLBUTNODATACACHE		(UPDFCACHE_ALL & ~UPDFCACHE_NODATACACHE)


// IOleCache2::DiscardCache options
typedef enum tagDISCARDCACHE
{
	DISCARDCACHE_SAVEIFDIRTY =	0,	// Save all dirty cache before discarding
	DISCARDCACHE_NOSAVE		 =	1	// Don't save dirty caches before
									// discarding
} DISCARDCACHE;


#undef  INTERFACE
#define INTERFACE   IOleCache2

DECLARE_INTERFACE_(IOleCache2, IOleCache)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;

    // *** IOleCache2 methods ***							
    STDMETHOD(UpdateCache) (THIS_ LPDATAOBJECT pDataObject, DWORD grfUpdf,
							LPVOID pReserved) PURE;
    STDMETHOD(DiscardCache) (THIS_ DWORD dwDiscardOptions) PURE;
						
};
typedef      IOleCache2 FAR* LPOLECACHE2;


#undef  INTERFACE
#define INTERFACE   IOleCacheControl

DECLARE_INTERFACE_(IOleCacheControl, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(OnRun) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(OnStop) (THIS) PURE;
};
typedef      IOleCacheControl FAR* LPOLECACHECONTROL;



/****** DV APIs ***********************************************************/


STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
					REFIID iid, LPVOID FAR* ppv);
					
#endif // _DVOBJ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\scode.h ===
/*****************************************************************************\
*                                                                             *
* scode.h - 	Defines standard status code services.						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr)        ((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
                            // general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -	Definitions for controlling GUID initialization				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\verinfo.h ===
#ifdef RC_INVOKED

#include <ver.h>

#define VER_FILEVERSION_STR      "2.01\0"
#define VER_FILEVERSION          2,01,0100,06

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.01 for Windows\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1993\0"
#define VER_PRODUCTVERSION_STR   "2.01\0"
#define VER_PRODUCTVERSION       2,01,0100,06
#define VER_COMMENT_STR          "Windows OLE DLLs\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS16

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -   Definitions for the strutured storage system
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_EXTANTMARSHALLINGS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x108)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef XCHAR TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
//typedef XCHAR TCHAR;   already defined in wtypes.h
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L
#define STGM_TRANSACTED		0x00010000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef XCHAR FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    XCHAR FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};

typedef IEnumSTATSTG FAR* LPENUMSTATSTG;



/****** ILockBytes Interface ************************************************/

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef ILockBytes FAR* LPLOCKBYTES;



/****** IStream Interface ***************************************************/


#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};

typedef IStream FAR* LPSTREAM;



/****** IStorage Interface **************************************************/

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const XCHAR FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const XCHAR FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const XCHAR FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const XCHAR FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ XCHAR const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              XCHAR const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const XCHAR FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const XCHAR FAR* pwcsOldName,
                const XCHAR FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const XCHAR FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef IStorage FAR* LPSTORAGE;



/****** IRootStorage Interface **********************************************/

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPXSTR lpstrFile) PURE;
};

typedef IRootStorage FAR* LPROOTSTORAGE;



/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const XCHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const XCHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const XCHAR FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(XCHAR const FAR* lpszName,
		  FILETIME const FAR* pctime,
                  FILETIME const FAR* patime,
                  FILETIME const FAR* pmtime);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\moniker.h ===
/*****************************************************************************\
*                                                                             *
* moniker.h - 	Moniker and related interfaces and APIs						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _MONIKER_H_ )
#define _MONIKER_H_

#define MK_E_CONNECTMANUALLY        MK_E_FIRST
#define MK_E_EXCEEDEDDEADLINE       (MK_E_FIRST + 1)
#define MK_E_NEEDGENERIC            (MK_E_FIRST + 2)
#define MK_E_UNAVAILABLE            (MK_E_FIRST + 3)
#define MK_E_SYNTAX                 (MK_E_FIRST + 4)
#define MK_E_NOOBJECT               (MK_E_FIRST + 5)
#define MK_E_INVALIDEXTENSION       (MK_E_FIRST + 6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED (MK_E_FIRST + 7)
#define MK_E_NOTBINDABLE            (MK_E_FIRST + 8)
#define MK_E_NOTBOUND               (MK_E_FIRST + 9)
                            // called IBindCtx->RevokeObjectBound for an
                            // object which was not bound
#define MK_E_CANTOPENFILE           (MK_E_FIRST + 10)
#define MK_E_MUSTBOTHERUSER         (MK_E_FIRST + 11)
#define MK_E_NOINVERSE              (MK_E_FIRST + 12)
#define MK_E_NOSTORAGE              (MK_E_FIRST + 13)
#define MK_E_NOPREFIX               (MK_E_FIRST + 14)


// reserved                     MK_S_FIRST
// reserved                     (MK_S_FIRST + 1)
#define MK_S_REDUCED_TO_SELF    (MK_S_FIRST + 2)
// reserved                     (MK_S_FIRST + 3)
#define MK_S_ME                 (MK_S_FIRST + 4)
#define MK_S_HIM                (MK_S_FIRST + 5)
#define MK_S_US                 (MK_S_FIRST + 6)
#define MK_S_MONIKERALREADYREGISTERED (MK_S_FIRST + 7)


// bind options; variable sized
typedef struct FARSTRUCT tagBIND_OPTS
{
    DWORD       cbStruct;       //  sizeof(BIND_OPTS)
    DWORD       grfFlags;
    DWORD       grfMode;
    DWORD       dwTickCountDeadline;
} BIND_OPTS, FAR* LPBIND_OPTS;


// bind flags; controls binding; stored in bind options above
typedef enum
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;


// system moniker types; returned from IsSystemMoniker.
typedef enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5
}MKSYS;


// bit wise enum to control how much reduction takes place.
typedef enum tagMKREDUCE
{
    MKRREDUCE_ONE           =   3<<16,
    MKRREDUCE_TOUSER        =   2<<16,
    MKRREDUCE_THROUGHUSER   =   1<<16,
    MKRREDUCE_ALL           =   0
} MKRREDUCE;


#if defined(__cplusplus)
interface IEnumMoniker;
interface IRunningObjectTable;
#else
typedef interface IEnumMoniker IEnumMoniker;
typedef interface IRunningObjectTable IRunningObjectTable;
#endif

typedef       IEnumMoniker FAR* LPENUMMONIKER;
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IBindCtx

DECLARE_INTERFACE_(IBindCtx, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBindCtx methods ***
    STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(ReleaseBoundObjects) (THIS) PURE;

    STDMETHOD(SetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
        pprot) PURE;
    STDMETHOD(RegisterObjectParam) (THIS_ LPXSTR lpszKey, LPUNKNOWN punk) PURE;
    STDMETHOD(GetObjectParam) (THIS_ LPXSTR lpszKey, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum) PURE;
    STDMETHOD(RevokeObjectParam) (THIS_ LPXSTR lpszKey) PURE;
};
typedef             IBindCtx FAR* LPBC;
typedef         IBindCtx FAR* LPBINDCTX;



#undef  INTERFACE
#define INTERFACE   IMoniker

DECLARE_INTERFACE_(IMoniker, IPersistStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID FAR* ppvResult) PURE;
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) PURE;
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER FAR* ppmkComposite) PURE;
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
        PURE;
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) PURE;
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) PURE;
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
        pmkNewlyRunning) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime) PURE;
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix) PURE;
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath) PURE;
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPXSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPXSTR lpszDisplayName, ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut) PURE;
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) PURE;
};
typedef         IMoniker FAR* LPMONIKER;


//  IRunningObjectTable::Register flags
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 1

#undef  INTERFACE
#define INTERFACE   IRunningObjectTable

DECLARE_INTERFACE_(IRunningObjectTable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRunningObjectTable methods ***
    STDMETHOD(Register) (THIS_ DWORD grfFlags, LPUNKNOWN punkObject,
        LPMONIKER pmkObjectName, DWORD FAR * pdwRegister) PURE;
    STDMETHOD(Revoke) (THIS_ DWORD dwRegister) PURE;
    STDMETHOD(IsRunning) (THIS_ LPMONIKER pmkObjectName) PURE;
    STDMETHOD(GetObject) (THIS_ LPMONIKER pmkObjectName,
        LPUNKNOWN FAR* ppunkObject) PURE;
    STDMETHOD(NoteChangeTime) (THIS_ DWORD dwRegister, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPMONIKER pmkObjectName, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(EnumRunning) (THIS_ LPENUMMONIKER FAR * ppenumMoniker ) PURE;
};
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IEnumMoniker

DECLARE_INTERFACE_(IEnumMoniker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOleDataObject methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumMoniker FAR* FAR* ppenm) PURE;
};
typedef       IEnumMoniker FAR* LPENUMMONIKER;




STDAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
STDAPI  MkParseDisplayName(LPBC pbc, LPXSTR szUserName,
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL fCalledFromMethod);
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
STDAPI  GetClassFile (LPCXSTR szFilename, CLSID FAR* pclsid);

STDAPI  CreateFileMoniker(LPXSTR lpszPathName, LPMONIKER FAR* ppmk);
STDAPI  CreateItemMoniker(LPXSTR lpszDelim, LPXSTR lpszItem,
    LPMONIKER FAR* ppmk);
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);


#endif  // _MONIKER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\coguid.h ===
/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,		0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* NOTE: LSB 0x19 through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -	Definitions for controlling GUID initialization				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This 
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2flat\ole2.h ===
/*****************************************************************************\
*                                                                             *
* ole2.h - 		Main OLE2 header; includes all subcomponents				         *
*                                                                             *
*               OLE Version 2.01 for Win16 and Win32                          *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _OLE2_H_ )
#define _OLE2_H_

#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif  /* RC_INVOKED */

#include <string.h>

/****** Standard Object Definitions *****************************************/

#include <compobj.h>


// *************** FACILITY_ITF scodes common to all interfaces ************
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an interface returns a FACILITY_ITF
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//

// error codes

#define OLE_E_OLEVERB               (OLE_E_FIRST)
// invalid OLEVERB structure

#define OLE_E_ADVF                  (OLE_E_FIRST+1)
// invalid advise flags

#define OLE_E_ENUM_NOMORE           (OLE_E_FIRST+2)
// you can't enuemrate any more, because the associated data is missing

#define OLE_E_ADVISENOTSUPPORTED    (OLE_E_FIRST+3)
// this implementation doesn't take advises

#define OLE_E_NOCONNECTION          (OLE_E_FIRST+4)
// there is no connection for this connection id

#define OLE_E_NOTRUNNING            (OLE_E_FIRST+5)
// need run the object to perform this operation

#define OLE_E_NOCACHE               (OLE_E_FIRST+6)
// there is no cache to operate on

#define OLE_E_BLANK                 (OLE_E_FIRST+7)
// Uninitialized object

#define OLE_E_CLASSDIFF             (OLE_E_FIRST+8)
// linked object's source class has changed

#define OLE_E_CANT_GETMONIKER       (OLE_E_FIRST+9)
// not able to get the moniker of the object

#define OLE_E_CANT_BINDTOSOURCE     (OLE_E_FIRST+10)
// not able to bind to the source

#define OLE_E_STATIC                (OLE_E_FIRST+11)
// object is static, operation not allowed

#define OLE_E_PROMPTSAVECANCELLED   (OLE_E_FIRST+12)
// user cancelled out of save dialog

#define OLE_E_INVALIDRECT           (OLE_E_FIRST+13)
// invalid rectangle

#define OLE_E_WRONGCOMPOBJ          (OLE_E_FIRST+14)
// compobj.dll is too old for the ole2.dll initialized

#define OLE_E_INVALIDHWND           (OLE_E_FIRST+15)
// invalid window handle

#define OLE_E_NOT_INPLACEACTIVE     (OLE_E_FIRST+16)
// object is not in any of the inplace active states

#define OLE_E_CANTCONVERT			(OLE_E_FIRST+17)
// not able to convert the object

#define OLE_E_NOSTORAGE				(OLE_E_FIRST+18)
// not able to perform the operation because object is not given storage yet.


#define DVGEN_E_FIRST               (OLE_E_FIRST+100)

#define DV_E_FORMATETC              (DVGEN_E_FIRST)
// invalid FORMATETC structure

#define DV_E_DVTARGETDEVICE         (DVGEN_E_FIRST+1)
// invalid DVTARGETDEVICE structure

#define DV_E_STGMEDIUM              (DVGEN_E_FIRST+2)
// invalid STDGMEDIUM structure

#define DV_E_STATDATA               (DVGEN_E_FIRST+3)
// invalid STATDATA structure

#define DV_E_LINDEX                 (DVGEN_E_FIRST+4)
// invalid lindex

#define DV_E_TYMED                  (DVGEN_E_FIRST+5)
// invalid tymed

#define DV_E_CLIPFORMAT             (DVGEN_E_FIRST+6)
// invalid clipboard format

#define DV_E_DVASPECT               (DVGEN_E_FIRST+7)
// invalid aspect(s)

#define DV_E_DVTARGETDEVICE_SIZE    (DVGEN_E_FIRST+8)
// tdSize paramter of the DVTARGETDEVICE structure is invalid

#define DV_E_NOIVIEWOBJECT          (DVGEN_E_FIRST+9)
// object doesn't support IViewObject interface


// Success codes

#define OLE_S_USEREG                (OLE_S_FIRST)
// use the reg database to provide the requested info

#define OLE_S_STATIC                (OLE_S_FIRST+1)
// success, but static

#define OLE_S_MAC_CLIPFORMAT        (OLE_S_FIRST+2)
// macintosh clipboard format

//*************************** Interface or API specific scodes *************

// Errors for OleConvertOLESTREAMToIStorage and OleConvertIStorageToOLESTREAM

// OLESTREAM Get method failed
#define CONVERT10_E_OLESTREAM_GET       (CONVERT10_E_FIRST + 0)

// OLESTREAM Put method failed
#define CONVERT10_E_OLESTREAM_PUT       (CONVERT10_E_FIRST + 1)

// Contents of the OLESTREAM not in correct format
#define CONVERT10_E_OLESTREAM_FMT       (CONVERT10_E_FIRST + 2)

// There was in an error in a Windows GDI call while converting the bitmap
// to a DIB.
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB (CONVERT10_E_FIRST + 3)

// Contents of the IStorage not in correct format
#define CONVERT10_E_STG_FMT             (CONVERT10_E_FIRST + 4)

// Contents of IStorage is missing one of the standard streams ("\1CompObj",
// "\1Ole", "\2OlePres000").  This may be the storage for a DLL object, or a
// class that does not use the def handler.
#define CONVERT10_E_STG_NO_STD_STREAM   (CONVERT10_E_FIRST + 5)

// There was in an error in a Windows GDI call while converting the DIB
// to a bitmap.
#define CONVERT10_E_STG_DIB_TO_BITMAP   (CONVERT10_E_FIRST + 6)


// Returned by either API, this scode indicates that the original object
//  had no presentation, therefore the converted object does not either.
#define CONVERT10_S_NO_PRESENTATION     (CONVERT10_S_FIRST + 0)


// Errors for Clipboard functions

// OpenClipboard Failed
#define CLIPBRD_E_CANT_OPEN     (CLIPBRD_E_FIRST + 0)

// EmptyClipboard Failed
#define CLIPBRD_E_CANT_EMPTY        (CLIPBRD_E_FIRST + 1)

// SetClipboard Failed
#define CLIPBRD_E_CANT_SET          (CLIPBRD_E_FIRST + 2)

// Data on clipboard is invalid
#define CLIPBRD_E_BAD_DATA          (CLIPBRD_E_FIRST + 3)

// CloseClipboard Failed
#define CLIPBRD_E_CANT_CLOSE        (CLIPBRD_E_FIRST + 4)


/****** OLE value types *****************************************************/

/* rendering options */
typedef enum tagOLERENDER
{
    OLERENDER_NONE   = 0,
    OLERENDER_DRAW   = 1,
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS   = 3
} OLERENDER;
typedef  OLERENDER FAR* LPOLERENDER;

// OLE verb; returned by IEnumOLEVERB
typedef struct FARSTRUCT tagOLEVERB
{
    LONG    lVerb;
    LPXSTR   lpszVerbName;
    DWORD   fuFlags;
    DWORD	grfAttribs;
} OLEVERB, FAR* LPOLEVERB;


// Bitwise verb attributes used in OLEVERB.grfAttribs
typedef enum tagOLEVERBATTRIB // bitwise
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;


// IOleObject::GetUserType optons; determines which form of the string to use
typedef enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT= 2,
    USERCLASSTYPE_APPNAME= 3,
} USERCLASSTYPE;


// bits returned from IOleObject::GetMistStatus
typedef enum tagOLEMISC // bitwise
{
    OLEMISC_RECOMPOSEONRESIZE				= 1,
    OLEMISC_ONLYICONIC						= 2,
    OLEMISC_INSERTNOTREPLACE				= 4,
    OLEMISC_STATIC							= 8,
    OLEMISC_CANTLINKINSIDE					= 16,
    OLEMISC_CANLINKBYOLE1					= 32,
    OLEMISC_ISLINKOBJECT					= 64,
    OLEMISC_INSIDEOUT						= 128,
    OLEMISC_ACTIVATEWHENVISIBLE				= 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512	
} OLEMISC;


// IOleObject::Close options
typedef enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE      = 1,
    OLECLOSE_PROMPTSAVE  = 2
} OLECLOSE;


// IOleObject::GetMoniker and IOleClientSite::GetMoniker options; determines
// if and how monikers should be assigned.
typedef enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE=1,
    OLEGETMONIKER_FORCEASSIGN=2,
    OLEGETMONIKER_UNASSIGN=3,
    OLEGETMONIKER_TEMPFORUSER=4
} OLEGETMONIKER;


// IOleObject::GetMoniker, IOleObject::SetMoniker and
// IOleClientSite::GetMoniker options; determines which moniker to use
typedef enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER=1,
    OLEWHICHMK_OBJREL=2,
    OLEWHICHMK_OBJFULL=3
} OLEWHICHMK;


#ifdef WIN32
#define LPSIZEL PSIZEL
#else
typedef struct FARSTRUCT tagSIZEL
{
    long cx;
    long cy;
} SIZEL, FAR* LPSIZEL;
#endif


#ifdef WIN32
#define LPRECTL PRECTL
#else
typedef struct FARSTRUCT tagRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
} RECTL, FAR* LPRECTL;

typedef struct FARSTRUCT tagPOINTL {
    LONG x;
    LONG y;
} POINTL;

#endif


#ifndef LPCRECT
typedef const RECT FAR* LPCRECT;
#endif

#ifndef LPCRECTL
typedef const RECTL FAR* LPCRECTL;
#endif


// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L // role is handler; implementation is
										 // default handler; pCF can be NULL
#define EMBDHLP_INPROC_SERVER    0x0001L // role is server; pCF can't be NULL

#define EMBDHLP_CREATENOW    0x00000000L // create using pCF immediately; if pCF
										 // is NULL, uses std remoting handler
#define EMBDHLP_DELAYCREATE  0x00010000L // delayed create; must supply pCF


// NOTE: OleCreateEmbeddingHelper(clsid, pUnkOuter,
// 		EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW, NULL, riid, lplpObj)
// is the same as OleCreateDefaultHandler(clsid, pUnkOuter, riid, lplpObj);
// i.e., the embedding helper is the default handler in various roles.

//Win32 OLE does not support Ole1.0-Ole2.0 interoperability

#ifndef WIN32

/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;

#endif // !WIN32


/****** Clipboard Data structures *****************************************/

typedef struct tagOBJECTDESCRIPTOR
{
   ULONG    cbSize;              // Size of structure in bytes
   CLSID    clsid;               // CLSID of data being transferred
   DWORD    dwDrawAspect;        // Display aspect of the object
                                 //     normally DVASPECT_CONTENT or ICON.
                                 //     dwDrawAspect will be 0 (which is NOT
                                 //     DVASPECT_CONTENT) if the copier or
                                 //     dragsource didn't draw the object to
                                 //     begin with.
   SIZEL    sizel;               // size of the object in HIMETRIC
                                 //    sizel is opt.: will be (0,0) for apps
                                 //    which don't draw the object being
                                 //    transferred
   POINTL   pointl;              // Offset in HIMETRIC units from the
                                 //    upper-left corner of the obj where the
                                 //    mouse went down for the drag.
                                 //    NOTE: y coordinates increase downward.
                                 //          x coordinates increase to right
                                 //    pointl is opt.; it is only meaningful
                                 //    if object is transfered via drag/drop.
                                 //    (0, 0) if mouse position is unspecified
                                 //    (eg. when obj transfered via clipboard)
   DWORD    dwStatus;            // Misc. status flags for object. Flags are
                                 //    defined by OLEMISC enum. these flags
                                 //    are as would be returned
                                 //    by IOleObject::GetMiscStatus.
   DWORD    dwFullUserTypeName;  // Offset from beginning of structure to
                                 //    null-terminated string that specifies
                                 //    Full User Type Name of the object.
                                 //    0 indicates string not present.
   DWORD    dwSrcOfCopy;         // Offset from beginning of structure to
                                 //    null-terminated string that specifies
                                 //    source of the transfer.
                                 //    dwSrcOfCOpy is normally implemented as
                                 //    the display name of the temp-for-user
                                 //    moniker which identifies the source of
                                 //    the data.
                                 //    0 indicates string not present.
                                 //    NOTE: moniker assignment is NOT forced.
                                 //    see IOleObject::GetMoniker(
                                 //                OLEGETMONIKER_TEMPFORUSER)

 /* variable sized string data may appear here */

} OBJECTDESCRIPTOR,  *POBJECTDESCRIPTOR,  FAR *LPOBJECTDESCRIPTOR,
  LINKSRCDESCRIPTOR, *PLINKSRCDESCRIPTOR, FAR *LPLINKSRCDESCRIPTOR;



/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)


//      forward type declarations
#if defined(__cplusplus)
interface IOleClientSite;
interface IOleContainer;
interface IOleObject;
#else
typedef interface IOleClientSite IOleClientSite;
typedef interface IOleContainer IOleContainer;
typedef interface IOleObject IOleObject;
#endif

typedef         IOleObject FAR* LPOLEOBJECT;
typedef     IOleClientSite FAR* LPOLECLIENTSITE;
typedef       IOleContainer FAR* LPOLECONTAINER;


/****** OLE GUIDs *********************************************************/

#ifndef INITGUID
#include "oleguid.h"
#endif


/****** Other Major Interfaces ********************************************/

#include <dvobj.h>

#include <storage.h>



/****** IDrop??? Interfaces ********************************************/

#define MK_ALT 0x0020


#define DROPEFFECT_NONE     0
#define DROPEFFECT_COPY     1
#define DROPEFFECT_MOVE     2
#define DROPEFFECT_LINK     4
#define DROPEFFECT_SCROLL   0x80000000

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
#define DD_DEFSCROLLINSET		11

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
#define DD_DEFSCROLLDELAY		50

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval",
//                              DD_DEFSCROLLINTERVAL)
#define DD_DEFSCROLLINTERVAL	50

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
#define DD_DEFDRAGDELAY     	200

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
#define DD_DEFDRAGMINDIST		2



/* Dragdrop specific error codes */

#define DRAGDROP_E_NOTREGISTERED        (DRAGDROP_E_FIRST)
// trying to revoke a drop target that has not been registered

#define DRAGDROP_E_ALREADYREGISTERED    (DRAGDROP_E_FIRST+1)
// this window has already been registered as a drop target

#define DRAGDROP_E_INVALIDHWND          (DRAGDROP_E_FIRST+2)
// invalid HWND


#define DRAGDROP_S_DROP                 (DRAGDROP_S_FIRST + 0)
// successful drop took place

#define DRAGDROP_S_CANCEL               (DRAGDROP_S_FIRST + 1)
// drag-drop operation canceled

#define DRAGDROP_S_USEDEFAULTCURSORS    (DRAGDROP_S_FIRST + 2)
// use the default cursor


#undef INTERFACE
#define INTERFACE   IDropTarget

DECLARE_INTERFACE_(IDropTarget, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragLeave) (THIS) PURE;
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
};
typedef         IDropTarget FAR* LPDROPTARGET;



#undef INTERFACE
#define INTERFACE   IDropSource

DECLARE_INTERFACE_(IDropSource, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropSource methods ***
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) PURE;
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) PURE;
};
typedef         IDropSource FAR* LPDROPSOURCE;



/****** IPersist??? Interfaces ********************************************/


#undef INTERFACE
#define INTERFACE   IPersist

DECLARE_INTERFACE_(IPersist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
};
typedef            IPersist FAR* LPPERSIST;



#undef INTERFACE
#define INTERFACE   IPersistStorage

DECLARE_INTERFACE_(IPersistStorage, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStorage methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) PURE;
    STDMETHOD(HandsOffStorage) (THIS) PURE;
};
typedef         IPersistStorage FAR* LPPERSISTSTORAGE;



#undef INTERFACE
#define INTERFACE   IPersistStream

DECLARE_INTERFACE_(IPersistStream, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR* pcbSize) PURE;
};
typedef          IPersistStream FAR* LPPERSISTSTREAM;



#undef INTERFACE
#define INTERFACE   IPersistFile

DECLARE_INTERFACE_(IPersistFile, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFile methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPCXSTR lpszFileName, DWORD grfMode) PURE;
    STDMETHOD(Save) (THIS_ LPCXSTR lpszFileName, BOOL fRemember) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPCXSTR lpszFileName) PURE;
    STDMETHOD(GetCurFile) (THIS_ LPXSTR FAR* lplpszFileName) PURE;
};
typedef            IPersistFile FAR* LPPERSISTFILE;


/****** Moniker Object Interfaces ******************************************/

#include <moniker.h>


/****** OLE Object Interfaces ******************************************/


#undef  INTERFACE
#define INTERFACE   IEnumOLEVERB

DECLARE_INTERFACE_(IEnumOLEVERB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumOLEVERB FAR* FAR* ppenm) PURE;
};
typedef         IEnumOLEVERB FAR* LPENUMOLEVERB;




#undef  INTERFACE
#define INTERFACE   IOleObject

#define OLEOBJ_E_NOVERBS                (OLEOBJ_E_FIRST + 0)

#define OLEOBJ_E_INVALIDVERB            (OLEOBJ_E_FIRST + 1)

#define OLEOBJ_S_INVALIDVERB            (OLEOBJ_S_FIRST + 0)

#define OLEOBJ_S_CANNOT_DOVERB_NOW      (OLEOBJ_S_FIRST + 1)
// verb number is valid but verb cannot be done now, for instance
// hiding a link or hiding a visible OLE 1.0 server

#define OLEOBJ_S_INVALIDHWND            (OLEOBJ_S_FIRST + 2)
// invalid hwnd passed


DECLARE_INTERFACE_(IOleObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) PURE;
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) PURE;
    STDMETHOD(SetHostNames) (THIS_ LPCXSTR szContainerApp, LPCXSTR szContainerObj) PURE;
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) PURE;
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved) PURE;
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved,
                LPDATAOBJECT FAR* ppDataObject) PURE;
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,
                LPMSG lpmsg,
                LPOLECLIENTSITE pActiveSite,
                LONG lindex,
                HWND hwndParent,
                LPCRECT lprcPosRect) PURE;
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) PURE;
    STDMETHOD(Update) (THIS) PURE;
    STDMETHOD(IsUpToDate) (THIS) PURE;
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) PURE;
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPXSTR FAR* pszUserType) PURE;
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;

    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) PURE;
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) PURE;
};
typedef      IOleObject FAR* LPOLEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleClientSite

DECLARE_INTERFACE_(IOleClientSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject) (THIS) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) PURE;
    STDMETHOD(ShowObject) (THIS) PURE;
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) PURE;
    STDMETHOD(RequestNewObjectLayout) (THIS) PURE;
};
typedef      IOleClientSite FAR* LPOLECLIENTSITE;


/****** OLE Runnable Object Interface **********************************/

#undef  INTERFACE
#define INTERFACE	IRunnableObject

DECLARE_INTERFACE_(IRunnableObject, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IRunnableObject methods ***
    STDMETHOD(GetRunningClass) (THIS_ LPCLSID lpClsid) PURE;
    STDMETHOD(Run) (THIS_ LPBINDCTX pbc) PURE;
    STDMETHOD_(BOOL, IsRunning) (THIS) PURE;
	STDMETHOD(LockRunning)(THIS_ BOOL fLock, BOOL fLastUnlockCloses) PURE;
	STDMETHOD(SetContainedObject)(THIS_ BOOL fContained) PURE;
};
typedef      IRunnableObject FAR* LPRUNNABLEOBJECT;


/****** OLE Container Interfaces ***************************************/


#undef  INTERFACE
#define INTERFACE   IParseDisplayName

DECLARE_INTERFACE_(IParseDisplayName, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPXSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;
};
typedef       IParseDisplayName FAR* LPPARSEDISPLAYNAME;


#undef  INTERFACE
#define INTERFACE   IOleContainer

DECLARE_INTERFACE_(IOleContainer, IParseDisplayName)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPXSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;
};
typedef IOleContainer FAR* LPOLECONTAINER;


typedef enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE    = 1,
    BINDSPEED_MODERATE      = 2,
    BINDSPEED_IMMEDIATE     = 3
} BINDSPEED;

typedef enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS     =  1,
    OLECONTF_LINKS          =  2,
    OLECONTF_OTHERS         =  4,
    OLECONTF_ONLYUSER       =  8,
    OLECONTF_ONLYIFRUNNING  = 16
} OLECONTF;


#undef  INTERFACE
#define INTERFACE   IOleItemContainer

DECLARE_INTERFACE_(IOleItemContainer, IOleContainer)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPXSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) (THIS_ DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;

    // *** IOleItemContainer methods ***
    STDMETHOD(GetObject) (THIS_ LPXSTR lpszItem, DWORD dwSpeedNeeded,
        LPBINDCTX pbc, REFIID riid, LPVOID FAR* ppvObject) PURE;
    STDMETHOD(GetObjectStorage) (THIS_ LPXSTR lpszItem, LPBINDCTX pbc,
        REFIID riid, LPVOID FAR* ppvStorage) PURE;
    STDMETHOD(IsRunning) (THIS_ LPXSTR lpszItem) PURE;
};
typedef       IOleItemContainer FAR* LPOLEITEMCONTAINER;


/****** OLE Advise Holder Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IOleAdviseHolder

DECLARE_INTERFACE_(IOleAdviseHolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD(SendOnSave)(THIS) PURE;
    STDMETHOD(SendOnClose)(THIS) PURE;
};
typedef      IOleAdviseHolder FAR* LPOLEADVISEHOLDER;


/****** OLE Link Interface ************************************************/

/* Link update options */
typedef enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS=1,
    OLEUPDATE_ONCALL=3
} OLEUPDATE;
typedef  OLEUPDATE FAR* LPOLEUPDATE;


// for IOleLink::BindToSource
typedef enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
} OLELINKBIND;


#undef  INTERFACE
#define INTERFACE   IOleLink

DECLARE_INTERFACE_(IOleLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleLink methods ***
    STDMETHOD(SetUpdateOptions) (THIS_ DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetUpdateOptions) (THIS_ LPDWORD pdwUpdateOpt) PURE;
    STDMETHOD(SetSourceMoniker) (THIS_ LPMONIKER pmk, REFCLSID rclsid) PURE;
    STDMETHOD(GetSourceMoniker) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(SetSourceDisplayName) (THIS_ LPCXSTR lpszDisplayName) PURE;
    STDMETHOD(GetSourceDisplayName) (THIS_ LPXSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(BindToSource) (THIS_ DWORD bindflags, LPBINDCTX pbc) PURE;
    STDMETHOD(BindIfRunning) (THIS) PURE;
    STDMETHOD(GetBoundSource) (THIS_ LPUNKNOWN FAR* ppUnk) PURE;
    STDMETHOD(UnbindSource) (THIS) PURE;
    STDMETHOD(Update) (THIS_ LPBINDCTX pbc) PURE;
};
typedef         IOleLink FAR* LPOLELINK;


/****** OLE InPlace Editing Interfaces ************************************/

#ifdef _MAC
typedef Handle  HOLEMENU;
typedef long    SIZE;
typedef long    HACCEL;
#else
DECLARE_HANDLE(HOLEMENU);
#endif

typedef struct FARSTRUCT tagOIFI          // OleInPlaceFrameInfo
{
    UINT    cb;
    BOOL    fMDIApp;
    HWND    hwndFrame;
    HACCEL  haccel;
    int     cAccelEntries;
} OLEINPLACEFRAMEINFO, FAR* LPOLEINPLACEFRAMEINFO;


typedef struct FARSTRUCT tagOleMenuGroupWidths
{
    LONG    width[6];
} OLEMENUGROUPWIDTHS, FAR* LPOLEMENUGROUPWIDTHS;

typedef RECT    BORDERWIDTHS;
typedef LPRECT  LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;

/* Inplace editing specific error codes */

#define INPLACE_E_NOTUNDOABLE   (INPLACE_E_FIRST)
// undo is not avaiable

#define INPLACE_E_NOTOOLSPACE       (INPLACE_E_FIRST+1)
// Space for tools is not available

#define INPLACE_S_TRUNCATED     (INPLACE_S_FIRST)
// Message is too long, some of it had to be truncated before displaying

//misc definitions
#define INPLACE_DEFBORDERWIDTH	4

//      forward type declarations
#if defined(__cplusplus)
interface IOleInPlaceUIWindow;
#else
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif

typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;


#undef  INTERFACE
#define INTERFACE   IOleWindow

DECLARE_INTERFACE_(IOleWindow, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
};

typedef         IOleWindow FAR* LPOLEWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceObject

DECLARE_INTERFACE_(IOleInPlaceObject, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceObject methods ***
    STDMETHOD(InPlaceDeactivate) (THIS) PURE;
    STDMETHOD(UIDeactivate) (THIS) PURE;
    STDMETHOD(SetObjectRects) (THIS_ LPCRECT lprcPosRect,
                    LPCRECT lprcClipRect) PURE;
    STDMETHOD(ReactivateAndUndo) (THIS) PURE;
};
typedef         IOleInPlaceObject FAR* LPOLEINPLACEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceActiveObject

DECLARE_INTERFACE_(IOleInPlaceActiveObject, IOleWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceActiveObject methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(ResizeBorder) (THIS_ LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) PURE;
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};
typedef         IOleInPlaceActiveObject FAR* LPOLEINPLACEACTIVEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceUIWindow

DECLARE_INTERFACE_(IOleInPlaceUIWindow, IOleWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                        LPCXSTR lpszObjName) PURE;
};
typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceFrame

DECLARE_INTERFACE_(IOleInPlaceFrame, IOleInPlaceUIWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                    LPCXSTR lpszObjName) PURE;


    // *** IOleInPlaceFrame methods ***
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusText) (THIS_ LPCXSTR lpszStatusText) PURE;
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) PURE;
};
typedef     IOleInPlaceFrame FAR* LPOLEINPLACEFRAME;


#undef  INTERFACE
#define INTERFACE   IOleInPlaceSite

DECLARE_INTERFACE_(IOleInPlaceSite, IOleWindow)
{
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceSite methods ***
    STDMETHOD(CanInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnUIActivate) (THIS) PURE;
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR* lplpFrame,
                        LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                        LPRECT lprcPosRect,
                        LPRECT lprcClipRect,
                        LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) PURE;
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) PURE;
    STDMETHOD(OnInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(DiscardUndoState) (THIS) PURE;
    STDMETHOD(DeactivateAndUndo) (THIS) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcPosRect) PURE;
};
typedef         IOleInPlaceSite FAR* LPOLEINPLACESITE;



/****** OLE API Prototypes ************************************************/

STDAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPXSTR lpszUserType);
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPXSTR FAR* lplpszUserType);


/* init/term */

STDAPI OleInitialize(LPMALLOC pMalloc);
STDAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from
   the data object */

STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);


/* Object creation APIs */

STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt,
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite,
                LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);

STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj);


STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkToFile(LPCXSTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCXSTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite,
            LPVOID FAR* ppvObj);

STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
STDAPI  RevokeDragDrop(HWND hwnd);
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
STDAPI  OleFlushClipboard(void);
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

STDAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
STDAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
STDAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

STDAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame,
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);


/* Helper APIs */
STDAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat,
                        UINT uiFlags);

STDAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,
                    LPCRECT lprcBounds);

STDAPI          OleRun(LPUNKNOWN pUnknown);
STDAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);
STDAPI          OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

STDAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

STDAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

STDAPI          OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
					REFIID riid, LPVOID FAR* lplpObj);
					
STDAPI_(BOOL)	IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg,
					WORD FAR* lpwCmd);

					
/* Icon extraction Helper APIs */
					
STDAPI_(HGLOBAL) OleGetIconOfFile(LPXSTR lpszPath, BOOL fUseFileAsLabel);

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,	LPXSTR lpszLabel,
					BOOL fUseTypeAsLabel);

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPXSTR lpszLabel,
					LPXSTR lpszSourceFile, UINT iIconIndex);


					
/* Registration Database Helper APIs */

STDAPI 			OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
					LPXSTR FAR* pszUserType);

STDAPI 			OleRegGetMiscStatus	(REFCLSID clsid, DWORD dwAspect,
					DWORD FAR* pdwStatus);

STDAPI 			OleRegEnumFormatEtc	(REFCLSID clsid, DWORD dwDirection,
					LPENUMFORMATETC FAR* ppenum);

STDAPI 			OleRegEnumVerbs	(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum);


#ifndef WIN32  //Ole 1.0 conversion is not available in 32-bit OLE

/* OLE 1.0 conversion APIS */

STDAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE			pstg,
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                polestm,
     LPSTORAGE                  pstg,
     const DVTARGETDEVICE FAR*  ptd);

STDAPI OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE			pstg,
									// Presentation data to OLESTREAM
	 CLIPFORMAT			cfFormat,	//		format
	 LONG				lWidth,		//		width
	 LONG				lHeight,	//		height
	 DWORD				dwSize,		//		size in bytes
     LPSTGMEDIUM		pmedium,	//		bits
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM		polestm,
	 LPSTORAGE			pstg,
									// Presentation data from OLESTREAM
	 CLIPFORMAT FAR*	pcfFormat,	//		format
	 LONG FAR*			plwWidth,	//		width
	 LONG FAR*			plHeight,	//		height
	 DWORD FAR*			pdwSize,	//		size in bytes
	 LPSTGMEDIUM		pmedium);	//		bits

#endif //WIN32

/* Storage Utility APIs */
STDAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
STDAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

STDAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
STDAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
STDAPI GetConvertStg(LPSTORAGE pStg);
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


#endif // _OLE2_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\compobj.h ===
/*****************************************************************************\
*                                                                             *
* compobj.h - 	Component object model definitions							  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_

/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __export __cdecl
#define STDAPICALLTYPE          __export __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __TURBOC__
#define interface               struct huge
#else
#define interface               struct FAR
#endif
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

#else
#define interface               struct

#ifdef _MAC

#define STDMETHOD(method)       long    method##pad;\
                                HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) long    method##pad;\
                                type (STDMETHODCALLTYPE * method)

#else // _MAC

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#endif // !_MAC

#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif

#if defined(TUNING)
	#define LOCAL static
#else
	#define LOCAL static
#endif


/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT   
#endif  // __cplusplus
#endif  // FARSTRUCT


#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */


typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

typedef WORD WCHAR;

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)         

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)         

// the caller is dispatching an intertask SendMessage call and 
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)             

// the caller is dispatching an asynchronus call can NOT 
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)         

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)                

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)         

// the callee (server [not server application]) is not available 
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)         

// the caller (client ) disappeared while the callee (server) was 
// processing a call 
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)         

// the date paket with the marshalled parameter data is
// incorrect 
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)         

// the call was not transmitted properly; the message queue 
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)         

// the client (caller) can not marshall the parameter data 
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)         
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)         

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)         
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)         

// received data are invalid; can be server or 
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)         

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)


// a internal error occured 
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/
 
#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else        
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.  
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in ole2.lib.  The GUIDs in ole2.lib are all defined in the same text 
// segment GUID_TEXT.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h 
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if defined(__cplusplus)
#define REFGUID             const GUID FAR&
#define REFIID              const IID FAR&
#define REFCLSID            const CLSID FAR&
#else
#define REFGUID             const GUID FAR* const
#define REFIID              const IID FAR* const
#define REFCLSID            const CLSID FAR* const
#endif


#ifndef INITGUID
#include "coguid.h"
#endif

/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif 

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
								// and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
								// context.

	// NOTE: CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE is the same as
	// (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE, but
	// not the same as CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call 
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

typedef struct tagINTERFACEINFO 
{               
    interface IUnknown FAR *pUnk;       // the pointer to the object
    IID      			iid;            // interface id
    WORD        		wMethod;        // interface methode
} INTERFACEINFO, FAR * LPINTERFACEINFO;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2         
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{   
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{   
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message 
    
} PENDINGMSG;

/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};

typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext, 
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                DWORD dwReserved ) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount, 
                                DWORD dwPendingType  ) PURE; 
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** External Connection Information ***********************************/

#undef  INTERFACE
#define INTERFACE   IExternalConnection

DECLARE_INTERFACE_(IExternalConnection, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExternalConnection methods ***
    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD reserved) PURE;
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD reserved, BOOL fLastReleaseCloses) PURE;
};
typedef       IExternalConnection FAR* LPEXTERNALCONNECTION;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, 
                       LPSTR FAR* rgelt, 
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);
STDAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk, 
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);


/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */

STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz);
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCSTR lpszProgID, LPCLSID lpclsid);
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax);

STDAPI CoCreateGuid(GUID FAR *pguid);

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at 
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\verinfo.h ===
#ifdef RC_INVOKED

#include <ver.h>

#define VER_FILEVERSION_STR      "2.0\0"
#define VER_FILEVERSION          2,00,1000,11

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.0 for Windows\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1993\0"
#define VER_PRODUCTVERSION_STR   "2.0\0"
#define VER_PRODUCTVERSION       2,00,1000,11
#define VER_COMMENT_STR          "Windows OLE DLLs\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS16

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ole2h\valid.h ===
STDAPI_(BOOL) IsValidPtrIn( const void FAR* pv, UINT cb );
STDAPI_(BOOL) IsValidPtrOut( void FAR* pv, UINT cb );
STDAPI_(BOOL) IsValidInterface( void FAR* pv );
STDAPI_(BOOL) IsValidIid( REFIID riid );

 
#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__); return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__), retval)

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__), retval)
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__); return; }

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__); return retval; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return; 
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) \
    return retval; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\chgtype.cxx ===
/*
 -	PVTCONV.CPP
 -
 *	Purpose:
 *		Conversion code for coercing propvariant types.
 *
 *	Copyright (C) 1997-1999 Microsoft Corporation
 *
 *	References:
 *		VariantChangeTypeEx conversion routine in variant.cpp
 *
 *	[Date]		[email]		[Comment]
 *	04/10/98	Puhazv		Creation.
 *
 */

#include "pch.cxx"
#include "chgtype.hxx"


/*
 -	PropVariantChangeType
 -
 *	Purpose:
 *		Conversion code for coercing propvariant types.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant from which the type should be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. See API documentation for more info.
 *		vartype		IN		The type to coerce to.
 */

HRESULT
PropVariantChangeType (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc,
		  			   	LCID lcid, USHORT wFlags, VARTYPE  vt)
{
	HRESULT hr = NOERROR;

	// Check if dest & src pointers are NULL.
	if (!ppvtDest || !ppvtSrc)
	{
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Check if the type to coerce to is same as the src type
	if (vt == ppvtSrc->vt)
	{
		hr = PropVariantCopy (ppvtDest, ppvtSrc);
		goto Exit;
	}
	
	// If both src and destination are variants just call VariantChangeTypeEx()
	if (FIsAVariantType(ppvtSrc->vt) && FIsAVariantType(vt))
	{
		hr = PrivVariantChangeTypeEx((VARIANT *)ppvtDest, (VARIANT *)ppvtSrc, lcid, wFlags, vt);
		goto Exit;
	}

	if ((vt &  VT_BYREF) || (ppvtSrc->vt & VT_ARRAY))
	{
		// We dont convert to VT_BYREF types and from VT_ARRAY types
		hr = DISP_E_TYPEMISMATCH;
		goto Exit;
	}

	if (ppvtSrc->vt & VT_BYREF)
	{
		PROPVARIANT pvT;

		// Convert BYREF to non-BYREF
		hr = HrConvertByRef(&pvT, ppvtSrc);
		if (hr)
			goto Exit;

		hr = HrConvertPVTypes (ppvtDest, &pvT, lcid, wFlags, vt);
	}
	else
	{
		hr = HrConvertPVTypes (ppvtDest, ppvtSrc, lcid, wFlags, vt);
	}
	
Exit:
	return (hr);
}



/*
 -	HrConvertByRef
 -
 *	Purpose:
 *		Converts Byref propvariants to non-byref propvariants.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant from which the type should be changed.
 */

HRESULT
HrConvertByRef (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc)
{
	HRESULT hr = NOERROR;

	ZeroMemory (ppvtDest, sizeof(PROPVARIANT));

	PROPASSERT ((ppvtSrc->vt) & VT_BYREF);

	switch (ppvtSrc->vt)
	{
		case VT_BYREF | VT_I1:
			ppvtDest->cVal = *(ppvtSrc->pcVal);
			break;
			
		case VT_BYREF | VT_UI1:
			ppvtDest->bVal = *(ppvtSrc->pbVal);
			break;
		
		case VT_BYREF | VT_I2:
			ppvtDest->iVal = *(ppvtSrc->piVal);
			break;
		
		case VT_BYREF | VT_UI2:		
			ppvtDest->uiVal = *(ppvtSrc->puiVal);
			break;
		
		case VT_BYREF | VT_I4:
			ppvtDest->lVal = *(ppvtSrc->plVal);
			break;
		
		case VT_BYREF | VT_UI4:
			ppvtDest->ulVal = *(ppvtSrc->pulVal);
			break;

// These types don't exist.	
//		case VT_BYREF | VT_I8:
//			ppvtDest->hVal = *(ppvtSrc->phVal);
//			break;
//		
//		case VT_BYREF | VT_UI8 :
//			ppvtDest->uhVal = *(ppvtSrc->puhVal);
//			break;
//
		case VT_BYREF | VT_R4 :
			ppvtDest->fltVal = *(ppvtSrc->pfltVal);
			break;
		
		case VT_BYREF | VT_R8 :
			ppvtDest->dblVal = *(ppvtSrc->pdblVal);
			break;
		
		case VT_BYREF | VT_BOOL:
			ppvtDest->boolVal = *(ppvtSrc->pboolVal);
			break;
		
		case VT_BYREF | VT_DECIMAL:
			ppvtDest->decVal = *(ppvtSrc->pdecVal);
			break;
		
		case VT_BYREF | VT_ERROR :
			ppvtDest->scode = *(ppvtSrc->pscode);
			break;

		case VT_BYREF | VT_CY:
			ppvtDest->cyVal = *(ppvtSrc->pcyVal);
			break;
		
		case VT_BYREF | VT_DATE:
			ppvtDest->date = *(ppvtSrc->pdate);
			break;
		
		case VT_BYREF | VT_BSTR:
			ppvtDest->bstrVal = *(ppvtSrc->pbstrVal);
			break;
		
		case VT_BYREF | VT_UNKNOWN:
			ppvtDest->punkVal = *(ppvtSrc->ppunkVal);
			break;
		
		case VT_BYREF | VT_DISPATCH:
			ppvtDest->pdispVal = *(ppvtSrc->ppdispVal);
			break;
		
		case VT_BYREF | VT_SAFEARRAY:
			ppvtDest->parray = *(ppvtSrc->pparray);
			break;

		/*

		VT_PROPVARIANT tag is not defined? Should I use someother tag?
		
		case VT_BYREF | VT_PROPVARIANT :
			*ppvtDest = *(ppvtSrc->ppropvar);
			break;
		*/
		
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	if (hr == NOERROR /* && ppvtSrc->vt != (VT_PROPVARIANT | VT_BYREF)*/)
	{
		ppvtDest->vt = (short) (ppvtSrc->vt & ~VT_BYREF);
	}

	return (hr);
}


/*
 -	HrConvertPVTypes
 -
 *	Purpose:
 *		Conversion code for coercing propvariant types.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant from which the type should be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. See API documentation for more info.
 *		vartype		IN		The type to coerce to.
 */

HRESULT
HrConvertPVTypes (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc,
		  			   LCID lcid, USHORT wFlags, VARTYPE  vt)
{
	HRESULT hr = NOERROR;

	
	switch (ppvtSrc->vt)
	{
		case VT_EMPTY:
			hr = HrConvFromVTEMPTY(ppvtDest, vt);
			break;

		case VT_I2:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
							ppvtSrc->iVal, TRUE);
			break;

		case VT_I4:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid,  wFlags, vt, 
							ppvtSrc->lVal, TRUE);
			break;

		case VT_R4:
			hr = HrGetValFromDOUBLE(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
							ppvtSrc->fltVal);
			break;

		case VT_R8:
			hr = HrGetValFromDOUBLE(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
							ppvtSrc->dblVal);
			break;

		case VT_CY:
			hr = HrConvFromVTCY(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_DATE:
			hr = HrConvFromVTDATE(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_BSTR:
			hr = HrConvFromVTBSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_BOOL:
			hr = HrConvFromVTBOOL(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_DECIMAL:
			hr = HrConvFromVTDECIMAL(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_I1:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
							ppvtSrc->cVal, TRUE);
			break;

		case VT_UI1:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
							ppvtSrc->bVal, FALSE);
			break;

		case VT_UI2:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
						ppvtSrc->uiVal, FALSE);
			break;

		case VT_UI4:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
						ppvtSrc->ulVal, FALSE);
			break;

		case VT_INT:
			hr = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
						ppvtSrc->intVal, TRUE);
			break;

		case VT_UINT:
			hr  = HrGetValFromDWORD(ppvtDest, ppvtSrc, lcid, wFlags, vt, 
						ppvtSrc->uintVal, FALSE);
			break;

		case VT_DISPATCH:
			hr = HrConvFromVTDISPATCH(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_UNKNOWN:
			hr = HrGetValFromUNK(ppvtDest, ppvtSrc->punkVal, vt);
			break;

		case VT_I8:
			hr = HrConvFromVTI8(ppvtDest, ppvtSrc, vt);
			break;

		case VT_UI8:
			hr = HrConvFromVTUI8(ppvtDest, ppvtSrc, vt);
			break;

		case VT_LPSTR:
			hr = HrConvFromVTLPSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_LPWSTR:
			hr = HrConvFromVTLPWSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_FILETIME:
			hr = HrConvFromVTFILETIME(ppvtDest, ppvtSrc, vt);
			break;

		case VT_BLOB:
			hr = HrGetValFromBLOB(ppvtDest, ppvtSrc, vt);
			break;

		case VT_STREAM:
			hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStream, vt);
			break;

		case VT_STORAGE:
			hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStorage, vt);
			break;

		case VT_STREAMED_OBJECT:
			hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStream, vt);
			break;

		case VT_STORED_OBJECT:
			hr = HrGetValFromUNK(ppvtDest, ppvtSrc->pStorage, vt);
			break;

		case VT_BLOB_OBJECT:
			hr = HrGetValFromBLOB(ppvtDest, ppvtSrc, vt);
			break;

		case VT_CF:
			hr = HrConvFromVTCF(ppvtDest, ppvtSrc, vt);
			break;

		case VT_CLSID:
			hr = HrConvFromVTCLSID(ppvtDest, ppvtSrc, vt);
			break;

		case VT_VERSIONED_STREAM:
			hr = HrConvFromVTVERSIONEDSTREAM (ppvtDest, ppvtSrc, vt);
			break;
			
		case VT_NULL:
		case VT_RECORD:
		case VT_ERROR:
		case VT_VARIANT:
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	if (hr == NOERROR)
		ppvtDest->vt = vt;

 	return hr;
}


/*
 -	FIsAVariantType
 -
 *	Purpose:
 *		Returns TRUE if the given variant type can be coerced using
 *		VariantChangeTypeEx.
 *
 *	Parameters:
 *		vt	IN		The vartype that needs to checked.
 */
 
BOOL
FIsAVariantType (VARTYPE  vt)
{
	// Remove BYREF.
	switch(vt & ~(VT_BYREF | VT_ARRAY))
	{
		case VT_NULL:
		case VT_EMPTY:
		case VT_I2:
		case VT_I4:
		case VT_R4:
		case VT_R8:
		case VT_CY:
		case VT_DATE:
		case VT_BSTR:
		case VT_BOOL:
		case VT_DECIMAL:
		case VT_I1:
		case VT_UI1:
		case VT_UI2:
		case VT_UI4:
		case VT_INT:
		case VT_UINT:
		case VT_DISPATCH:
		case VT_UNKNOWN:
		case VT_RECORD:
		case VT_ERROR:
		case VT_VARIANT:
			return (TRUE);
	}
	return (FALSE);
}

/*
 -	CFROMVAR.CPP
 -
 *	Purpose:
 *		Conversion routines to convert from a variant type.
 *
 *	Copyright (C) 1997-1999 Microsoft Corporation
 *
 *	References:
 *		VariantChangeTypeEx conversion routine in variant.cpp
 *
 *	[Date]		[email]		[Comment]
 *	04/10/98	Puhazv		Creation.
 *
 */


/*
 -	HrConvFromVTEMPTY
 -
 *	Purpose:
 *		Converts a propvariant of type VT_EMPTY.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		vt			IN		The type to coerce to.
 */

HRESULT 
HrConvFromVTEMPTY (PROPVARIANT *ppvtDest, VARTYPE vt)
{ 
	HRESULT hr = NOERROR;
	CHAR	*pszT;
	WCHAR	*pwszT;
	UUID	*puuidT;

	switch(vt)
	{
		case VT_I8:
		case VT_UI8:
		case VT_FILETIME:
		case VT_BLOB:
			ppvtDest->hVal.QuadPart = 0;
			break;
		
		case VT_LPSTR:
			// Alloc and Copy a NULL String
			pszT = (CHAR *)CoTaskMemAlloc(sizeof(CHAR));
			if (pszT)
			{
				pszT[0] = '\0';
				ppvtDest->pszVal = pszT;
			}
			else
				hr = E_OUTOFMEMORY;
			break;

		case VT_LPWSTR:
			// Alloc and Copy a NULL String
			pwszT = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR));
			if (pwszT)
			{
				pwszT[0] = L'\0';
				ppvtDest->pwszVal = pwszT;
			}
			else
				hr = E_OUTOFMEMORY;
			break;

		case VT_CLSID:
			// Alloc and Copy a NULL GUID
		 	puuidT = (CLSID *)CoTaskMemAlloc(sizeof(CLSID));
			if (puuidT)
			{
				CopyMemory (puuidT, &CLSID_NULL, sizeof(CLSID));
				ppvtDest->puuid = puuidT;
			}
			else
				hr = E_OUTOFMEMORY;
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	return hr;
}


/*
 -	HrGetValFromDWORD
 -
 *	Purpose:
 *		Converts a DWORD to the requested PV type
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. 
 *		vt			IN		The type to coerce to.
 *		dwVal		IN		Value to be converted
 *		fSigned		IN		Is the DWORD value signed?
 */

HRESULT
HrGetValFromDWORD (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc,
				   LCID lcid, USHORT wFlags, VARTYPE vt, DWORD dwVal,
				   BOOL fSigned)
{
	HRESULT hr = NOERROR;

	PROPASSERT (FIsAVariantType(ppvtSrc->vt));
	
	switch(vt)
	{
		case VT_I8:
			if (fSigned)
				ppvtDest->hVal.QuadPart = (LONG)dwVal;
			else
				ppvtDest->hVal.QuadPart = dwVal;
			break;
			
		case VT_UI8:
			if (fSigned  && ((LONG)dwVal) < 0)
			{
				hr = DISP_E_OVERFLOW;
				break;
			}
			ppvtDest->uhVal.QuadPart = dwVal;
			break;
			
		case VT_LPSTR:
		case VT_LPWSTR:
			// Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
			// and then convert the resultant BSTR to LPSTR/LPWSTR
			hr = HrGetValFromBSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;
			
		case VT_FILETIME:
			if (fSigned  && ((LONG)dwVal) < 0)
			{
				hr = DISP_E_OVERFLOW;
				break;
			}
			ppvtDest->filetime.dwLowDateTime = dwVal;
			ppvtDest->filetime.dwHighDateTime = 0;
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	return hr;
}


/*
 -	HrGetValFromDOUBLE
 -
 *	Purpose:
 *		Converts a DOUBLE to the requested PV type
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvari	ant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 *		dbl			IN		Value to be converted
 */

HRESULT 
HrGetValFromDOUBLE (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
					LCID lcid, USHORT wFlags, VARTYPE vt, DOUBLE dbl)
{ 
	HRESULT hr = NOERROR;

	PROPASSERT(FIsAVariantType(ppvtSrc->vt));

	switch(vt)
	{
		case VT_I8:
			hr = HrGetLIFromDouble(dbl, &(ppvtDest->hVal.QuadPart));
			break;

		case VT_UI8:
			hr = HrGetULIFromDouble (dbl, &(ppvtDest->uhVal.QuadPart));
			break;
			
		case VT_LPSTR:
		case VT_LPWSTR:
			// Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
			// and then convert the resultant BSTR to LPSTR/LPWSTR
			hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		case VT_FILETIME:
			hr = HrGetULIFromDouble (dbl, &(ppvtDest->uhVal.QuadPart));
			break;
			  
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	return hr;
}


/*
 -	HrConvFromVTCY
 -
 *	Purpose:
 *		Converts a propvariant of type VT_CY.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 */

HRESULT 
HrConvFromVTCY (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
					LCID lcid, USHORT wFlags, VARTYPE vt)
{
	HRESULT hr = NOERROR;

	switch(vt)
	{
		case VT_I8:
			hr = HrGetLIFromDouble((double(ppvtSrc->cyVal.int64)/double(g_cCurrencyMultiplier)), 
					&(ppvtDest->hVal.QuadPart));
			break;

		case VT_FILETIME:			
		case VT_UI8:
			hr = HrGetULIFromDouble((double(ppvtSrc->cyVal.int64)/double(g_cCurrencyMultiplier)), 
				&(ppvtDest->uhVal.QuadPart));
			break;

		case VT_LPSTR:
		case VT_LPWSTR:
			// Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
			// and then convert the resultant BSTR to LPSTR/LPWSTR
			hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	return hr;
}


/*
 -	HrConvFromVTDATE
 -
 *	Purpose:
 *		Converts a propvariant of type VT_DATE.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 */

HRESULT 
HrConvFromVTDATE (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
				  LCID lcid, USHORT wFlags, VARTYPE vt)
{ 
	HRESULT hr = NOERROR;
	switch(vt)
	{
		case VT_I8:
			hr = HrGetLIFromDouble (ppvtSrc->date, &(ppvtDest->hVal.QuadPart));
			break;

		case VT_UI8:
			hr = HrGetULIFromDouble (ppvtSrc->date, &(ppvtDest->uhVal.QuadPart));
			break;
			
		case VT_LPSTR:
		case VT_LPWSTR:
			// Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
			// and then convert the resultant BSTR to LPSTR/LPWSTR
			hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	return hr;
}


/*
 -	HrConvFromVTBSTR
 -
 *	Purpose:
 *		Converts a propvariant of type VT_BSTR
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 */

HRESULT 
HrConvFromVTBSTR (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
					LCID lcid, USHORT wFlags, VARTYPE vt)
{ 
	HRESULT hr = NOERROR;
	switch(vt)
	{
		case VT_LPSTR:
			hr = HrBStrToAStr(ppvtSrc->bstrVal, &(ppvtDest->pszVal));
			break;
			
		case VT_LPWSTR:
			hr = HrBStrToWStr(ppvtSrc->bstrVal, &(ppvtDest->pwszVal));
			break;

		case VT_I8:
			hr = HrStrToULI(ppvtSrc, lcid, wFlags, TRUE, &(ppvtDest->uhVal.QuadPart));
			break;
			
		case VT_UI8:
		case VT_FILETIME:
			hr = HrStrToULI(ppvtSrc, lcid, wFlags, FALSE, &(ppvtDest->uhVal.QuadPart));
			break;

		case VT_CLSID:
			hr = HrStrToCLSID(ppvtDest, ppvtSrc);
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	
	return hr;
}


/*
 -	HrConvFromVTBOOL
 -
 *	Purpose:
 *		Converts a propvariant of type VT_BOOL
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. 
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTBOOL (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc,
				   LCID lcid, USHORT wFlags, VARTYPE vt)
{
	HRESULT hr = NOERROR;
	BOOL	fVal= ppvtSrc->boolVal;
	
	PROPASSERT (FIsAVariantType(ppvtSrc->vt));
	
	switch(vt)
	{
		case VT_I8:
			ppvtDest->hVal.QuadPart = fVal ? VARIANT_TRUE : VARIANT_FALSE;
			break;
		
		case VT_UI8:
		case VT_FILETIME:
			ppvtDest->uhVal.QuadPart = fVal ? VARIANT_TRUE : VARIANT_FALSE;
			break;
						
		case VT_LPSTR:
		case VT_LPWSTR:
			// Convert the Src Propvariant to a BSTR using VariantChangeTypeEx() 
			// and then convert the resultant BSTR to LPSTR/LPWSTR
			hr = HrGetValFromBSTR(ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	
	return hr;
}


/*
 -	HrConvFromVTDECIMAL
 -
 *	Purpose:
 *		Converts a propvariant of type VT_DECIMAL.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 */

HRESULT 
HrConvFromVTDECIMAL (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
					LCID lcid, USHORT wFlags, VARTYPE vt)
{ 
	HRESULT hr = NOERROR;

	switch(vt)
	{
		case VT_LPSTR:
		case VT_LPWSTR:
			// Get the Src Propvariant to a BSTR using VariantChangeTypeEx() 
			// and then convert BSTR to LPSTR/LPWSTR
			hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	return hr;
}


/*
 -	HrConvFromVTDISPATCH
 -
 *	Purpose:
 *		Converts a propvariant of type VT_DISPATCH.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTDISPATCH (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
						LCID lcid, USHORT wFlags, VARTYPE vt)
{
	VARIANT		varT;
	HRESULT		hr = NOERROR;

	switch (vt)
	{
		case VT_I8:
		case VT_UI8:
		case VT_FILETIME:
			// Extract an I4 value from the DISPATCH pointer and convert it to 
			// I64/UI64 integer
			if (wFlags & VARIANT_NOVALUEPROP)
			{
				hr = DISP_E_TYPEMISMATCH;
				break;
			}
			
			ZeroMemory(&varT, sizeof(VARIANT));
			hr = PrivVariantChangeTypeEx ((VARIANT *)&varT, (VARIANT *)ppvtSrc, lcid, wFlags, VT_I4);
			if (hr)
				break;

			hr = HrGetValFromDWORD (ppvtDest, ppvtSrc, lcid, wFlags, vt, 
									varT.lVal, (vt == VT_I8));
			break;
			
		case VT_LPSTR:
		case VT_LPWSTR:
			hr = HrGetValFromBSTR (ppvtDest, ppvtSrc, lcid, wFlags, vt);
			break;
			
		case VT_STREAM:
		case VT_STREAMED_OBJECT:
		case VT_STORAGE:
		case VT_STORED_OBJECT:
		case VT_DISPATCH:
		case VT_UNKNOWN:
			hr = HrGetValFromUNK (ppvtDest, ppvtSrc->pdispVal, vt);
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	return (hr);
}


/*
 -	HrGetValFromUNK
 -
 *	Purpose:
 *		Converts a IUNKNOWN ptr to the specified type
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		punk		IN		IUnknown pointer to be coerced
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrGetValFromUNK (PROPVARIANT *ppvtDest, IUnknown *punk, VARTYPE vt)
{
	CONST IID	*piid;
	VOID		**ppvResult = NULL, *pvT = NULL;
	HRESULT		hr = NOERROR;

	if (!punk)
	{
		hr = E_INVALIDARG;
		goto Exit;
	}
	
	switch (vt)
	{
		case VT_STREAM:
		case VT_STREAMED_OBJECT:
			piid = &IID_IStream; 
			ppvResult = (void **)&(ppvtDest->pStream);
			break;
			
		case VT_STORAGE:
		case VT_STORED_OBJECT:
			piid = &IID_IStorage;
			ppvResult = (void **)&(ppvtDest->pStorage);
			break;
			
		case VT_DISPATCH:
			piid = &IID_IDispatch;
			ppvResult = (void **)&(ppvtDest->pdispVal);
			break;
			
		case VT_UNKNOWN:
			piid = &IID_IUnknown;
			ppvResult = (void **)&(ppvtDest->punkVal);
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	if (hr)
		goto Exit;

	hr = punk->QueryInterface(*piid, &pvT);
	if (hr)
		goto Exit;

	*ppvResult = pvT;

Exit:
	return (hr);
}


/*
 -	HrGetValFromBSTR
 -
 *	Purpose:
 *		Converts a BSTR to the given type.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrGetValFromBSTR (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, LCID lcid, 
			USHORT wFlags, VARTYPE vt)
{
	HRESULT 	hr = NOERROR;
	PROPVARIANT	pvtT;
	
	PROPASSERT(vt == VT_LPSTR || vt == VT_LPWSTR || vt == VT_BSTR);
	PROPASSERT(FIsAVariantType(ppvtSrc->vt));
	
	// Convert the src propvariant to a BSTR
	ZeroMemory (&pvtT, sizeof(PROPVARIANT));
	hr = PrivVariantChangeTypeEx ((VARIANT *)&pvtT, (VARIANT *)ppvtSrc, 
						lcid, wFlags, VT_BSTR);
	if (FAILED(hr) || !pvtT.bstrVal)
		goto Exit;

	if (vt == VT_BSTR)
	{
		ppvtDest->bstrVal = pvtT.bstrVal;
		pvtT.bstrVal = NULL;
	}
	else if (vt == VT_LPWSTR)
	{
		hr = HrBStrToWStr(pvtT.bstrVal, &(ppvtDest->pwszVal));
	}
	else
	{
		hr = HrBStrToAStr(pvtT.bstrVal, &(ppvtDest->pszVal));
	}


Exit:
	if (pvtT.bstrVal)
		PrivSysFreeString(pvtT.bstrVal);
	return (hr);
}


/*
 -	HrGetLIFromDouble
 -
 *	Purpose:
 *		Converts a double to large integer.
 *
 *	Parameters:
 *		dbl		IN	Double to be coerced.
 *		pll	OUT	Pointer to the resultanat LLInteger.
 */
 
HRESULT
HrGetLIFromDouble (DOUBLE dbl, LONGLONG *pll)
{
	HRESULT 	hr = NOERROR;
	LONGLONG 	ll, llRound;
	BOOL		fExactHalf;
	
	if (dbl > (_I64_MAX + 0.5)  || dbl < (_I64_MIN - 0.5))
	{
		hr = DISP_E_OVERFLOW;
		goto Exit;
	}

	ll = (LONGLONG) dbl;

	if (dbl < 0)
	{
		llRound = (LONGLONG)(dbl - 0.5);
		fExactHalf = ((ll - dbl) == 0.5);
	}
	else
	{
		llRound = (LONGLONG)(dbl + 0.5);
		fExactHalf = ((dbl - ll) == 0.5);
	}

	if (!fExactHalf || (ll & 0x1))
	{
		if ((dbl < 0 && llRound > ll) || (dbl > 0 && llRound < ll))
		{
			hr = DISP_E_OVERFLOW;
			goto Exit;
		}
		*pll = llRound;
	}
	else
	{
		*pll = ll;
	}
	
Exit:
	return (hr);
}


/*
 -	HrGetULIFromDouble
 -
 *	Purpose:
 *		Converts a double to unsigned large integer.
 *
 *	Parameters:
 *		dbl		IN	Double to be coerced.
 *		pull	OUT	Pointer to the resultanat ULLInteger.
 */
 
HRESULT
HrGetULIFromDouble (DOUBLE dbl, ULONGLONG *pull)
{
	HRESULT 	hr = NOERROR;
	ULONGLONG 	ull, ullRound;
	BOOL		fExactHalf;
	
	if (dbl >= (_UI64_MAX + 0.5) || dbl < - 0.5)
	{
		hr = DISP_E_OVERFLOW;
		goto Exit;
	}

	if (dbl < 0)
	{
		// Should be between 0 and -0.5
		*pull = 0;
		goto Exit;
	}
	
	ull  = (ULONGLONG)dbl;
	ullRound = (ULONGLONG)(dbl + 0.5);

	if (ull > _I64_MAX)
	{
		hr = DISP_E_OVERFLOW; //Compiler limitation
		goto Exit;
	}
	
	fExactHalf = ((dbl - (LONGLONG)ull) == 0.5);

	if (!fExactHalf || (ull & 0x1))
	{
		if (ullRound < ull)
		{
			hr = DISP_E_OVERFLOW;
			goto Exit;
		}
		*pull = ullRound;
	}
	else
	{
		*pull = ull;
	}
	
Exit:
	return (hr);
}


/*
 -	CFROMPVAR.CPP
 -
 *	Purpose:
 *		Conversion routines to convert from a propvariant type.
 *
 *	Copyright (C) 1997-1999 Microsoft Corporation
 *
 *	References:
 *		VariantChangeTypeEx conversion routine in variant.cpp
 *
 *	[Date]		[email]		[Comment]
 *	04/10/98	Puhazv		Creation.
 *
 */


/*
 -	HrConvFromVTI8
 -
 *	Purpose:
 *		Converts a propvariant of type VT_I8.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		vartype		IN		The type to coerce to.
 */
 
HRESULT
HrConvFromVTI8(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

	LONGLONG 	llSrc = ppvtSrc->hVal.QuadPart;
	LONGLONG	llSrcCurrency;
	HRESULT		hr = NOERROR;
	
	switch (vt)
	{
		case VT_I2:
			if (llSrc > _I16_MAX || llSrc < _I16_MIN)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->iVal = (__int16) llSrc;
			break;
			
		case VT_I4:
			if (llSrc > _I32_MAX || llSrc < _I32_MIN)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->lVal = (__int32) llSrc;
			break;

		case VT_R4:
			ppvtDest->fltVal = (float) llSrc;
			break;
			
		case VT_R8:
			ppvtDest->dblVal = (double) llSrc;
			break;

		case VT_CY:
			llSrcCurrency = llSrc * g_cCurrencyMultiplier;
			if ((llSrc > 0 && llSrcCurrency < llSrc) ||
				(llSrc < 0 && llSrcCurrency > llSrc))
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->cyVal.int64 = llSrcCurrency;
			break;

		case VT_BSTR:
		case VT_LPSTR:
		case VT_LPWSTR:
			hr = HrULIToStr (ppvtDest, ppvtSrc, vt);
			break;
			
		case VT_BOOL:
			ppvtDest->boolVal = llSrc ? VARIANT_TRUE : VARIANT_FALSE;
			break;
		
		case VT_I1:
			if (llSrc > _I8_MAX || llSrc < _I8_MIN)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->cVal = (__int8)llSrc;
			break;

		case VT_UI1:
			if (llSrc > _UI8_MAX || llSrc < 0)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->bVal = (BYTE)llSrc;
			break;

		case VT_UI2:
			if (llSrc > _UI16_MAX || llSrc < 0)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->uiVal = (USHORT) llSrc;
			break;

		case VT_INT:
			if (llSrc > INT_MAX || llSrc < INT_MIN)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->intVal = (INT)llSrc;
			break;

		case VT_UINT:
			if (llSrc > UINT_MAX || llSrc < 0)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->uintVal = (UINT)llSrc;
			break;

		case VT_UI4:
			if (llSrc > _UI32_MAX || llSrc < 0)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->ulVal = (ULONG) llSrc;
			break;

		case VT_UI8:
		case VT_FILETIME:
			if (llSrc < 0)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->uhVal.QuadPart = llSrc;
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	return (hr);
}


/*
 -	HrConvFromVTUI8
 -
 *	Purpose:
 *		Converts a propvariant of type VT_UI8.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTUI8(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

	ULONGLONG 	ullSrc = ppvtSrc->uhVal.QuadPart;
	ULONGLONG 	ullSrcCurrency;
	HRESULT		hr = NOERROR;
	
	switch (vt)
	{
		case VT_I2:
			if (ullSrc > _I16_MAX)
				hr = DISP_E_OVERFLOW;
			else		
				ppvtDest->iVal = (__int16) ullSrc;
			break;
			
		case VT_I4:
			if (ullSrc > _I32_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->lVal = (__int32)ullSrc;
			break;

		case VT_R4:
			if (ullSrc > _I64_MAX)
				hr = DISP_E_OVERFLOW; //Compiler limitation
			else
				ppvtDest->fltVal = (float)(LONGLONG) ullSrc;
			break;
			
		case VT_R8:
			if (ullSrc > _I64_MAX)
				hr = DISP_E_OVERFLOW; //Compiler limitation
			else
				ppvtDest->dblVal = (double)(LONGLONG) ullSrc;
			break;

		case VT_CY:
			ullSrcCurrency = ullSrc * g_cCurrencyMultiplier;
			if (ullSrcCurrency < ullSrc || ullSrcCurrency > _I64_MAX)
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->cyVal.int64 = ullSrcCurrency;
			break;

		case VT_BSTR:
		case VT_LPSTR:
		case VT_LPWSTR:
			hr = HrULIToStr (ppvtDest, ppvtSrc, vt);
			break;
			
		case VT_BOOL:
			ppvtDest->boolVal = ullSrc ? VARIANT_TRUE : VARIANT_FALSE;
			break;
		
		case VT_I1:
			if (ullSrc > _I8_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->cVal = (__int8)ullSrc;
			break;

		case VT_UI1:
			if (ullSrc > _UI8_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->bVal = (UCHAR)ullSrc;
			break;

		case VT_UI2:
			if (ullSrc > _UI16_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->uiVal = (USHORT) ullSrc;
			break;

		case VT_INT:
			if (ullSrc > INT_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->intVal = (INT)ullSrc;
			break;

		case VT_UINT:
			if (ullSrc > UINT_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->uintVal = (UINT)ullSrc;
			break;

		case VT_UI4:
			if (ullSrc > _UI32_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->ulVal = (ULONG)ullSrc;
			break;

		case VT_I8:
			if (ullSrc > _I64_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->hVal = ppvtSrc->hVal;
			break;
			
		case VT_FILETIME:
			ppvtDest->uhVal = ppvtSrc->uhVal;
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	return (hr);
}


/*
 -	HrConvFromVTLPSTR
 -
 *	Purpose:
 *		Converts a propvariant of type VT_LPSTR.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. See API documentation for more info.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTLPSTR (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, 
						LCID lcid, USHORT wFlags, VARTYPE vt)
{
	HRESULT	hr = NOERROR;
	BSTR	bstrT = NULL;
	VARIANT	var;
	
	switch (vt)
	{
		case VT_NULL:
		case VT_EMPTY:
		case VT_I2:
		case VT_I4:
		case VT_R4:
		case VT_R8:
		case VT_CY:
		case VT_DATE:
		case VT_BSTR:
		case VT_BOOL:
		case VT_DECIMAL:
		case VT_I1:
		case VT_UI1:
		case VT_UI2:
		case VT_UI4:
		case VT_INT:
		case VT_UINT:
		case VT_UNKNOWN:
		case VT_RECORD:
		case VT_DISPATCH:
		case VT_ERROR:
		case VT_VARIANT:
			// Convert LPSTR to BSTR and call VariantChangeTypeEx()
			hr = HrAStrToBStr (ppvtSrc->pszVal, &bstrT);
			if (hr)
				goto Exit;

			var.vt = VT_BSTR;
			var.bstrVal = bstrT;
			hr = PrivVariantChangeTypeEx((VARIANT *)ppvtDest, &var, lcid, wFlags, vt);
			break;
			
		case VT_I8:
			hr = HrStrToULI(ppvtSrc, lcid, wFlags, TRUE, (ULONGLONG *)&(ppvtDest->hVal.QuadPart));
			break;
			
		case VT_UI8:
		case VT_FILETIME:
			hr = HrStrToULI(ppvtSrc, lcid, wFlags, FALSE, &(ppvtDest->uhVal.QuadPart));
			break;
			
		case VT_LPWSTR:
			hr = HrAStrToWStr(ppvtSrc->pszVal, &(ppvtDest->pwszVal));
			break;

		case VT_CLSID:
			hr = HrStrToCLSID (ppvtDest, ppvtSrc);
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

Exit:
	if (bstrT)
		PrivSysFreeString (bstrT);
	return (hr);
}



/*
 -	HrConvFromVTLPWSTR
 -
 *	Purpose:
 *		Converts a propvariant of type VT_LPWSTR.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. See API documentation for more info.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTLPWSTR (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, LCID lcid, USHORT wFlags, VARTYPE vt)
{
	VARIANT var; 
	BSTR	bstrT = NULL;
	WCHAR	*pwszVal = NULL;
	HRESULT	hr = NOERROR;

        PrivVariantInit( &var );
	
	switch (vt)
	{
		case VT_NULL:
		case VT_EMPTY:
		case VT_I2:
		case VT_I4:
		case VT_R4:
		case VT_R8:
		case VT_CY:
		case VT_DATE:
		case VT_BSTR:
		case VT_BOOL:
		case VT_DECIMAL:
		case VT_I1:
		case VT_UI1:
		case VT_UI2:
		case VT_UI4:
		case VT_INT:
		case VT_UINT:
		case VT_UNKNOWN:
		case VT_RECORD:
		case VT_DISPATCH:
		case VT_ERROR:
		case VT_VARIANT:
			// Convert LPWSTR to BSTR and call VariantChangeTypeEx()
			hr = HrWStrToBStr (ppvtSrc->pwszVal, &bstrT);
			if (hr)
				goto Exit;
			var.vt = VT_BSTR;
			var.bstrVal = bstrT;
			hr = PrivVariantChangeTypeEx ((VARIANT *)ppvtDest, &var, lcid, wFlags, vt);
			break;
			
		case VT_I8:
			hr = HrStrToULI (ppvtSrc, lcid, wFlags, TRUE, (ULONGLONG *) &(ppvtDest->hVal.QuadPart));
			break;
			
		case VT_UI8:
		case VT_FILETIME:
			hr = HrStrToULI (ppvtSrc, lcid, wFlags, FALSE, &(ppvtDest->uhVal.QuadPart));
			break;
			
		case VT_LPSTR:
			hr = HrWStrToAStr (ppvtSrc->pwszVal, &(ppvtDest->pszVal));
			break;
	
		case VT_CLSID:
			hr = HrStrToCLSID (ppvtDest, ppvtSrc);
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
Exit:
        PrivVariantClear( &var );
	return (hr);
}



/*
 -	HrConvFromVTFILETIME
 -
 *	Purpose:
 *		Converts a propvariant of type VT_FILETIME.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTFILETIME(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

	// get the filetime value as 64bit unsigned.
	ULONGLONG 	ullSrc = ((ULARGE_INTEGER *)&(ppvtSrc->filetime))->QuadPart;
	HRESULT		hr = NOERROR;
	
	switch (vt)
	{
		case VT_I2:
			if (ullSrc > _I16_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->iVal = (__int16) ullSrc;
			break;
			
		case VT_I4:
			if (ullSrc > _I32_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->lVal = (__int32)ullSrc;
			break;

		case VT_R4:
			if (ullSrc > _I64_MAX)
				hr = DISP_E_OVERFLOW; //Compiler limitation
			else
				ppvtDest->fltVal = (float)(LONGLONG) ullSrc;
			break;

		case VT_R8:
			if (ullSrc > _I64_MAX)
				hr = DISP_E_OVERFLOW; //Compiler limitation
			else
				ppvtDest->dblVal = (double)(LONGLONG) ullSrc;
			break;

		case VT_CY:
			if (ullSrc > _I64_MAX || (ullSrc * g_cCurrencyMultiplier) > _I64_MAX)
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->cyVal.int64 = ullSrc * g_cCurrencyMultiplier;
			break;

		case VT_BOOL:
			ppvtDest->boolVal = ullSrc ? VARIANT_TRUE : VARIANT_FALSE;
			break;
		
		case VT_I1:
			if (ullSrc > _I8_MAX)
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->iVal = (__int8)ullSrc;
			break;

		case VT_UI1:
			if (ullSrc > _UI8_MAX)
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->bVal = (UCHAR)ullSrc;
			break;

		case VT_UI2:
			if (ullSrc > _UI16_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->uiVal = (USHORT) ullSrc;
			break;

		case VT_INT:
			if (ullSrc > INT_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->intVal = (INT)ullSrc;
			break;

		case VT_UINT:
			if (ullSrc > UINT_MAX)
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->uintVal = (UINT)ullSrc;
			break;

		case VT_UI4:
			if (ullSrc > _I32_MAX)
				hr = DISP_E_OVERFLOW;
			else			
				ppvtDest->ulVal = (ULONG)ullSrc;
			break;

		case VT_I8:
			if (ullSrc > _I64_MAX)
				hr = DISP_E_OVERFLOW;
			else
				ppvtDest->hVal.QuadPart = (LONGLONG)ullSrc;
			break;
			
		case VT_UI8:
			ppvtDest->uhVal.QuadPart = ullSrc;
			break;

		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	return (hr);
}


/*
 -	HrGetValFromBLOB
 -
 *	Purpose:
 *		Converts a propvariant of type VT_BLOB.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. See API documentation for more info.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrGetValFromBLOB(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
	HRESULT hr = NOERROR;
	BLOB	blobT;
	
	switch (vt)
	{
		case VT_BLOB:
		case VT_BLOB_OBJECT:
			// Check if the size is zero.
			if (ppvtSrc->blob.cbSize == 0)
			{
				PROPASSERT (ppvtSrc->blob.pBlobData == NULL);
				ppvtDest->blob.pBlobData = NULL;
				ppvtDest->blob.cbSize = 0;
				goto Exit;
			}

			// Allocate BLOB and copy data.
			blobT.cbSize = (ppvtSrc->blob).cbSize;
			blobT.pBlobData = (BYTE *) CoTaskMemAlloc((ppvtSrc->blob).cbSize);
			if (blobT.pBlobData == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
			CopyMemory (blobT.pBlobData, (ppvtSrc->blob).pBlobData, (ppvtSrc->blob).cbSize);
			ppvtDest->blob = blobT;
			break;
			
		case VT_UI1 | VT_ARRAY:
			hr = PBToSafeArray ((ppvtSrc->blob).cbSize, (ppvtSrc->blob).pBlobData, &(ppvtDest->parray));
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

Exit:
	return (hr);
}


/*
 -	HrConvFromVTCF
 -
 *	Purpose:
 *		Converts a propvariant of type VT_CF.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant to be coerced.
 *		vt			IN		The type to coerce to.
 */
 
HRESULT
HrConvFromVTCF(PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
	HRESULT 	hr = NOERROR;
	CLIPDATA 	*pclip = NULL;
	
	switch (vt)
	{
		case VT_ARRAY | VT_UI1:
			// Convert Clipdata to unsigned one byte array.
			hr = CFToSafeArray (ppvtSrc->pclipdata, &(ppvtDest->parray));
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}

	if (pclip)
		CoTaskMemFree(pclip);
	return (hr);
}


/*
 -	HrConvFromVTCLSID
 -
 *	Purpose:
 *		Converts a propvariant of type VT_CLSID.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant from which the type should be coerced.
 *		vt			IN		The type to coerce to.
 */

HRESULT
HrConvFromVTCLSID (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
	HRESULT hr = NOERROR;
	
	switch (vt)
	{
		case VT_BSTR:
		case VT_LPSTR:
		case VT_LPWSTR:
			hr = HrCLSIDToStr (ppvtDest, ppvtSrc, vt);
			break;
			
		default:
			hr = DISP_E_TYPEMISMATCH;
			break;
	}
	return (hr);
}


/*
 -	HrConvFromVTVERSIONEDSTREAM
 -
 *	Purpose:
 *		Converts a propvariant of type VT_VERSIONEDSTREAM.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant from which the type should be coerced.
 *		vt			IN		The type to coerce to.
 */
HRESULT
HrConvFromVTVERSIONEDSTREAM (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
    HRESULT             hr = NOERROR;
    PROPVARIANT         rgpvar[2];
    PROPVARIANT         pvtT;
    SAFEARRAYBOUND      sabound;
    SAFEARRAY           *psaT;

    memset( rgpvar, 0, sizeof(rgpvar) );

    switch (vt)
    {
            
        case VT_ARRAY | VT_VARIANT:
            // Convert the CLSID to string
            pvtT.vt = VT_CLSID;
            pvtT.puuid = &(ppvtSrc->pVersionedStream->guidVersion);
            hr = HrCLSIDToStr(&rgpvar[0], &pvtT, VT_BSTR);
            if (hr)
                goto Exit;
            PROPASSERT (rgpvar[0].bstrVal);
            
            // Get IStream as IUnknown
            hr = HrGetValFromUNK (&rgpvar[1], ppvtSrc->pVersionedStream->pStream,
                        VT_UNKNOWN);
            if (hr)
                goto Exit;
            PROPASSERT (rgpvar[1].punkVal);

            // Build the safearray
            sabound.lLbound = 0;
            sabound.cElements = 2;

            // Create SafeArray
            psaT = PrivSafeArrayCreate(VT_VARIANT, 1, &sabound );
            if(psaT == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            // Copy the propvariants to the safe array.
            PROPASSERT(psaT->pvData);
            CopyMemory(psaT->pvData, rgpvar, 2 * sizeof(PROPVARIANT));
            ppvtDest->parray = psaT;
            psaT = NULL;

            // Null out all temp params
            rgpvar[0].bstrVal = NULL;
            rgpvar[1].punkVal = NULL;
            break;
                
        default:
            hr = DISP_E_TYPEMISMATCH;
            break;
    }

Exit:
    if (rgpvar[0].bstrVal)
        PrivSysFreeString(rgpvar[0].bstrVal);
    if (rgpvar[1].punkVal)
        (rgpvar[1].punkVal)->Release();
        
    return (hr);
}


/*
 -	HrConvFromVTVECTOR
 -
 *	Purpose:
 *		Converts a propvariant of type VT_VECTOR.
 *
 *	Parameters:
 *		ppvtDest	OUT		Resultant Propvariant with the new type
 *		ppvtSrc		IN		Source propvariant from which the type should be coerced.
 *		vt			IN		The type to coerce to.
 */
 
HRESULT
HrConvFromVTVECTOR (PROPVARIANT *, CONST PROPVARIANT *, VARTYPE)
{
	// Brian Chapman has implemented this conversion.
	return (NOERROR);
}

/*
 -	PVTUTIL.CPP
 -
 *	Purpose:
 *		Utility routines for propvariant conversion.
 *
 *	Copyright (C) 1997-1999 Microsoft Corporation
 *
 *	References:
 *		VariantChangeTypeEx conversion routine in variant.cpp
 *
 *	[Date]		[email]		[Comment]
 *	04/14/98	Puhazv		Creation.
 *
 */

/*
 -	HrStrToClsid
 -
 *	Purpose:
 *		Converts a string to GUID
 *
 *	Parameters:
 *		ppvtDest	OUT	Dest Propvariant with the CLSID.
 *		ppvtSrc 	IN 	Propvariant with the string to be converted.
 */
 
HRESULT
HrStrToCLSID (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc)
{
	WCHAR 	*pwszT = NULL;
	BOOL 	fAllocated = FALSE;
	CLSID	clsid, *puuidT = NULL;
	HRESULT hr = NOERROR;
	

	// This routine converts only strings to CLSID.
	PROPASSERT (ppvtSrc->vt == VT_LPSTR  || 
				ppvtSrc->vt == VT_LPWSTR || 
				ppvtSrc->vt == VT_BSTR);

	// Convert the src type to a WSTR
	switch(ppvtSrc->vt)
	{
		case VT_LPSTR:
			hr = HrAStrToWStr(ppvtSrc->pszVal, &pwszT);
			if (hr)
				goto Exit;
			fAllocated = TRUE;
			break;
			
		case VT_LPWSTR:
			pwszT = ppvtSrc->pwszVal;
			break;
			
		case VT_BSTR:
			pwszT = ppvtSrc->bstrVal;
			break;
	}

	// We should have a NON-NULL wide char string here.
	if (!pwszT)
	{
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Convert WSTR to CLSID	
	hr  = CLSIDFromString(pwszT, &clsid);
	if (hr)	
		goto Exit;

	// Allocate memory and copy the GUID.
	puuidT = (CLSID *)CoTaskMemAlloc (sizeof(CLSID));
	if (!puuidT)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	CopyMemory(puuidT, &clsid, sizeof (CLSID));
	ppvtDest->puuid = puuidT;
	puuidT = NULL;

Exit:
	if (fAllocated)
		CoTaskMemFree(pwszT);
	return (hr);
}


/*
 -	HrClsidToStr
 -
 *	Purpose:
 *		Converts a GUID to a string
 *
 *	Parameters:
 *		ppvtDest	OUT	Dest Propvariant with the CLSID.
 *		ppvtSrc 	IN 	Propvariant with the string to be converted.
 *		vt			IN	Type to coerce to.
 */
 
HRESULT
HrCLSIDToStr (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{

	HRESULT hr = NOERROR;
	WCHAR	*pwszT = NULL;
	
	PROPASSERT (vt == VT_LPSTR || vt == VT_LPWSTR || vt == VT_BSTR);

	// Convert CLSID to WSTR
	hr  = StringFromCLSID (*(ppvtSrc->puuid), &pwszT);
	if (hr)	
		goto Exit;

	switch(vt)
	{
		case VT_LPSTR:
			hr = HrWStrToAStr(pwszT, &(ppvtDest->pszVal));
			if (hr)
				goto Exit;
			break;
			
		case VT_LPWSTR:
			ppvtDest->pwszVal = pwszT;
			pwszT = NULL;
			break;
			
		case VT_BSTR:
			hr = HrWStrToBStr(pwszT, &(ppvtDest->bstrVal));
			if (hr)
				goto Exit;
			break;
	}

Exit:
	if (pwszT)
		CoTaskMemFree(pwszT);
	return (hr);
}



/*
 -	HrStrToULI
 -
 *	Purpose:
 *		Converts a string to ULI
 *
 *	Parameters:
 *		ppvtDest	OUT	Dest Propvariant with the CLSID.
 *		lcid		IN		Locale Id
 *		wFlags		IN		Flags to control coercion. See API documentation for more info.
 *		fSigned		IN		Is the output LL signed?
 *		puli		OUT		Pointer to ULI to receive the resultant value
 *
 */
 
HRESULT
HrStrToULI (CONST PROPVARIANT *ppvtSrc, LCID lcid, USHORT wFlags, 
			BOOL fSigned, ULONGLONG *puli)
{

	HRESULT		hr = NOERROR;
	BSTR		bstrT = NULL;
	VARIANT 	varSrcT = {0}, varDestT = {0};
	BOOL		fAllocated = FALSE;

	switch (ppvtSrc->vt)
	{
		case VT_LPSTR:
			hr = HrAStrToBStr(ppvtSrc->pszVal, &bstrT);
			if (hr)
				goto Exit;
			PROPASSERT (bstrT);
			fAllocated = TRUE;
			break;
				
		case VT_LPWSTR:
			hr = HrWStrToBStr(ppvtSrc->pwszVal, &bstrT);
			if (hr)
				goto Exit;
			PROPASSERT (bstrT);
			fAllocated = TRUE;
			break;

		case VT_BSTR:
			bstrT = ppvtSrc->bstrVal;
			fAllocated = FALSE;
			break;

		default:
			PROPASSERT(0);
			break;
	}

	varSrcT.vt = VT_BSTR;
	varSrcT.bstrVal = bstrT;
	hr = PrivVariantChangeTypeEx (&varDestT, &varSrcT, lcid, wFlags, VT_R8);
	if (FAILED(hr))
		goto Exit;

	if (fSigned)
	{
		hr = HrGetLIFromDouble(varDestT.dblVal, (LONGLONG *)puli);
	}
	else
	{
		hr = HrGetULIFromDouble(varDestT.dblVal, puli);
	}
	
	
Exit:
	if (fAllocated)
	{
		PrivSysFreeString(bstrT);
	}
	return (hr);
}


/*
 -	HrULIToStr
 -
 *	Purpose:
 *		Converts an ULI to a STR (Ascii/BSTR/WSTR)
 *
 *	Parameters:
 *		ppvtDest	IN	Propvariant to receive the coerced type.
 *		ppvtSrc		IN	Propvariant to be coerced.
 *		vt			IN	The type to be coerced to.
 */
 
HRESULT
HrULIToStr (PROPVARIANT *ppvtDest, CONST PROPVARIANT *ppvtSrc, VARTYPE vt)
{
	HRESULT 	hr = NOERROR;
	CHAR 		sz[256], *pszT;
	WCHAR		wsz[256], *pwszT;
	BSTR		bstrT;
	BOOL		fNegative = FALSE;
	ULONGLONG	ull;
	DWORD		dw;

	if (ppvtSrc->vt == VT_I8)
	{
		fNegative = ppvtSrc->hVal.QuadPart < 0;
		ull = ppvtSrc->hVal.QuadPart;
	}
	else
	{
		PROPASSERT (ppvtSrc->vt == VT_UI8 || ppvtSrc->vt == VT_FILETIME);
		ull = ppvtSrc->uhVal.QuadPart;
	}

	switch (vt)
	{
		case VT_LPSTR:
			dw = DwULIToAStr(ull, sz, fNegative);
			pszT = (CHAR *) CoTaskMemAlloc (dw * sizeof (CHAR));
			if (!pszT)
			{
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
			CopyMemory (pszT, sz, dw * sizeof (CHAR));
			ppvtDest->pszVal = pszT;
			pszT = NULL;
			break;
			
		case VT_LPWSTR:
			dw = DwULIToWStr (ull, wsz, fNegative);	
			pwszT = (WCHAR *) CoTaskMemAlloc (dw * sizeof (WCHAR));
			if (!pwszT)
			{
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
			CopyMemory (pwszT, wsz, dw * sizeof (WCHAR));
			ppvtDest->pwszVal = pwszT;
			pwszT = NULL;
			break;
			
		case VT_BSTR:
			dw = DwULIToWStr(ull, wsz, fNegative);	
			bstrT = PrivSysAllocString (wsz);
			if (!bstrT)
			{
				hr = E_OUTOFMEMORY;
				goto Exit;
			}
			ppvtDest->bstrVal = bstrT;
			break;
	}
	
Exit:
	return (hr);
}


/*
 -	DwULIToAStr
 -
 *	Purpose:
 *		Converts an ULI to an Ascii STR
 *
 *	Parameters:
 *		ullVal		IN	ULONGLONG value to be converted
 *		pszBuf		OUT	Output buffer - Should have been allocated before.
 *		fNegative	IN	Is the number negative
 */
 
DWORD
DwULIToAStr (ULONGLONG ullVal, CHAR *pszBuf, BOOL fNegative)
{
	CHAR 	*pch, *pchFirstDigit, chT;
	BYTE 	bDigit;
	DWORD	cchWritten;

	pch = pszBuf;
	
	// If the value is negative, put a '-' sign.
	if (fNegative)
	{
		PROPASSERT(((LONGLONG)ullVal) < 0);
		*pch++ = '-';
		ullVal = -(LONGLONG)ullVal;
	}
	pchFirstDigit = pch;
	
	do
	{
		bDigit = (BYTE)(ullVal % 10);
		ullVal /= 10;
		*pch++ = (CHAR) (bDigit + '0');
	}
	while (ullVal > 0);

	*pch = 0;
	cchWritten = (DWORD)(pch - pszBuf + 1);
	
	pch--;
	do 
	{
		chT = *pch;	*pch = *pchFirstDigit; *pchFirstDigit = chT;
		--pch; ++pchFirstDigit;    
	} 
    while (pchFirstDigit < pch); 

    return (cchWritten);
}


/*
 -	DwULIToWStr
 -
 *	Purpose:
 *		Converts an ULI to a WSTR
 *
 *	Parameters:
 *		ullVal		IN	ULONGLONG value to be converted
 *		pwszBuf		OUT	Output buffer - Should have been allocated before.
 *		fNegative	IN	Is the number negative
 */
 
DWORD
DwULIToWStr (ULONGLONG ullVal, WCHAR *pwszBuf, BOOL fNegative)
{
	WCHAR 	*pwch, *pwchFirstDigit, wchT;
	BYTE 	bDigit;
	DWORD	cchWritten;

	// If the number is negative, add a '-' char to the out string.
	pwch = pwszBuf;
	if (fNegative)
	{
		PROPASSERT(((LONGLONG)ullVal) < 0);
		*pwch++ = L'-';
		ullVal = -(LONGLONG)ullVal;
	}
	pwchFirstDigit = pwch;
	
	do
	{
		bDigit = (BYTE)(ullVal % 10);
		ullVal /= 10;
		*pwch++ = (WCHAR)(bDigit + L'0');
	}
	while (ullVal > 0);

	*pwch = 0;
	cchWritten = (DWORD)(pwch - pwszBuf + 1);
	
	pwch--;
	do 
	{
		wchT = *pwch; *pwch = *pwchFirstDigit; *pwchFirstDigit = wchT;
		--pwch; ++pwchFirstDigit;    
	} 
    while (pwchFirstDigit < pwch); 

    return (cchWritten);
}


/*
 -	HrWStrToAstr
 -
 *	Purpose:
 *		Converts a WSTR to an Ascii String
 *
 *	Parameters:
 *		pwsz		IN	WSTR to be converted.
 *		ppsz		OUT	resultant Ascii Str.
 */

HRESULT
HrWStrToAStr(CONST WCHAR *pwsz, CHAR **ppsz)
{
	HRESULT	hr = NOERROR;
	CHAR 	*pszT = NULL;
	DWORD	cchLen;

	PROPASSERT (pwsz && ppsz);

	// Findout the length of the String.
	cchLen = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
	if (cchLen == 0)
		goto Win32Error;

	// Allocate memory
	pszT = (CHAR *) CoTaskMemAlloc(cchLen * sizeof (CHAR));
	if (!pszT)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Convert it
	if (!WideCharToMultiByte(CP_ACP, 0, pwsz, -1, pszT, cchLen, NULL, NULL))
		goto Win32Error;
		
	*ppsz = pszT;
	pszT = NULL;

Exit:
	if (pszT)
		CoTaskMemFree(pszT);
	return (hr);
	
Win32Error:
	hr = MAKE_HRESULT (SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
	goto Exit;
}


/*
 -	HrWStrToBStr
 -
 *	Purpose:
 *		Converts a WSTR to BSTR
 *
 *	Parameters:
 *		pwsz	IN	Input WSTR.
 *		pbstr	OUT	Output BSTR.
 */
 
HRESULT
HrWStrToBStr(CONST WCHAR *pwsz, BSTR *pbstr)
{
	BSTR bstrT;
	
	bstrT = PrivSysAllocString(pwsz);
	if (bstrT)
	{
		*pbstr = bstrT;
		return (NOERROR);
	}
	else
		return E_OUTOFMEMORY;
}


/*
 -	HrAStrToWStr
 -
 *	Purpose:
 *		Converts a Ascii STR to Wide String
 *
 *	Parameters:
 *		psz		IN	Input Ascii string.
 *		ppwsz	OUT	Output WSTR.
 */
 
HRESULT
HrAStrToWStr (CONST CHAR *psz, WCHAR **ppwsz)
{
	WCHAR 	*pwszT = NULL;
	DWORD	cchLen;
	HRESULT	hr = NOERROR;
	
	PROPASSERT (psz && ppwsz);
	
	cchLen = MultiByteToWideChar (CP_ACP, 0, psz, -1, NULL, 0);
	if (cchLen == 0)
		goto Win32Error;
	
	pwszT = (WCHAR *)CoTaskMemAlloc(cchLen * sizeof (WCHAR));
	if (!pwszT)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}
	
	if (!MultiByteToWideChar(CP_ACP, 0, psz, -1, pwszT, cchLen))
		goto Win32Error;
		
	*ppwsz = pwszT;
	pwszT = NULL;

Exit:
	if (pwszT)
		CoTaskMemFree(pwszT);
	return (hr);
	
Win32Error:
	hr = MAKE_HRESULT (SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
	goto Exit;
}


/*
 -	HrAStrToBStr
 -
 *	Purpose:
 *		Converts a Ascii STR to a BSTR
 *
 *	Parameters:
 *		psz		IN	Ascii Str to be converted
 *		ppbstr	OUT	Resultant BSTR.
 */
 
HRESULT
HrAStrToBStr (CONST CHAR *psz, BSTR *ppbstr)
{
	HRESULT hr = NOERROR;
	WCHAR	*pwszT = NULL;
	
	hr = HrAStrToWStr(psz, &pwszT);
	if (hr)
		goto Exit;

	hr = HrWStrToBStr(pwszT, ppbstr);
	if (hr)
		goto Exit;
		
Exit:
	if (pwszT)
		CoTaskMemFree (pwszT);
	return (hr);
}


/*
 -	HrBStrToAStr
 -
 *	Purpose:
 *		Converts a BSTR to ascii STR
 *
 *	Parameters:
 *		pbstr	IN	BSTR to be converted
 *		ppsz	OUT	Resultant ASCII str.
 */

HRESULT
HrBStrToAStr(CONST BSTR pbstr, CHAR **ppsz)
{

	PROPASSERT (pbstr && ppsz);
	return (HrWStrToAStr((WCHAR *)pbstr, ppsz));
}


/*
 -	HrBStrToWStr
 -
 *	Purpose:
 *		Converts a BSTR to a WSTR
 *
 *	Parameters:
 *		pbstr	IN	BSTR to be converted
 *		ppwsz	OUT	Resultant wide char str.
 */

HRESULT
HrBStrToWStr(CONST BSTR pbstr, WCHAR **ppwsz)
{
	HRESULT	hr = NOERROR;
	DWORD 	cchLen;
	WCHAR	*pwszT = NULL;
	
	PROPASSERT (pbstr && ppwsz);
	
	cchLen = PrivSysStringLen (pbstr) + 1;
	pwszT = (WCHAR *) CoTaskMemAlloc(cchLen * sizeof (WCHAR));
	if (!pwszT)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}
	
	CopyMemory (pwszT, pbstr, cchLen * sizeof (WCHAR));
	*ppwsz = pwszT;
	
Exit:
	return (hr);
}


/*
 -	PBToSafeArray
 -
 *	Purpose:
 *		Converts a BYTE array to a safe array
 *
 *	Parameters:
 *		cb		IN 		# bytes in the PB array
 *		pbData	IN		Bin array to be converted
 *		ppsa	OUT		Safe array output.
 */

HRESULT
PBToSafeArray (DWORD cb, CONST BYTE *pbData, SAFEARRAY **ppsa)
{
	HRESULT hr = NOERROR;
	SAFEARRAYBOUND sabound;
	SAFEARRAY	*psaT;
	
	PROPASSERT (ppsa);
	
    sabound.lLbound = 0;
    sabound.cElements = cb;

    // Create SafeArray
    psaT = PrivSafeArrayCreate(VT_UI1, 1, &sabound );
    if(psaT == NULL)
    {
    	hr = E_OUTOFMEMORY;
    	goto Exit;
    }

    if(psaT->pvData) // may be NULL if 0-length array.
      CopyMemory(psaT->pvData, pbData, cb );

	*ppsa = psaT;
	
  Exit:
  	return (hr);
}


/*
 -	CFToSafeArray
 -
 *	Purpose:
 *		Converts a CLIPDATA to a safe array
 *
 *	Parameters:
 *		pclipdata	IN 		CLIPDATA to be converted.
 *		ppsa		OUT		Safe array output.
 */

HRESULT
CFToSafeArray (CONST CLIPDATA *pclipdata, SAFEARRAY **ppsa)
{
	HRESULT 		hr = NOERROR;
	SAFEARRAYBOUND 	sabound;
	SAFEARRAY		*psaT;
	DWORD			cbClipFmtSize;
	
	PROPASSERT (ppsa);
	
    sabound.lLbound = 0;
    sabound.cElements = pclipdata->cbSize; // Size includes size of ulClipFmt

    // Create SafeArray
    psaT = PrivSafeArrayCreate(VT_UI1, 1, &sabound );
    if(psaT == NULL)
    {
    	hr = E_OUTOFMEMORY;
    	goto Exit;
    }

    if(psaT->pvData) 
    {
    	// may be NULL if 0-length array.

		cbClipFmtSize = sizeof(pclipdata->ulClipFmt);

    	// Copy the length of the clipdata.
		CopyMemory(psaT->pvData, &(pclipdata->ulClipFmt), cbClipFmtSize);
		
		// Copy the data itself.
		if (pclipdata->cbSize > cbClipFmtSize)
		{
			PROPASSERT (pclipdata->pClipData);
	      	CopyMemory(((BYTE*)(psaT->pvData)) + cbClipFmtSize, pclipdata->pClipData, 
	      			pclipdata->cbSize - cbClipFmtSize);
	    }
	}

	*ppsa = psaT;
  Exit:
  	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\hforpset.cxx ===
//+============================================================================
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:   hforpset.cxx
//
//          This file provides the definition of the CNtfsStorageForPropSetStg
//          class.  This class presents an IStorage implementation to the
//          CPropertySetStorage implementation of IPropertySetStorage.
//          Mostly, this class forwards to CNtfsStorage.
//
//  History:
//
//      3/10/98  MikeHill   - Factored out common code in the create/open paths.
//      5/18/98 MikeHill
//              -   Parameter validation in CNtfsStorageForPropSetStg::
//                  Create/OpenStorage.
//      6/11/98 MikeHill
//              -   Dbg output, parameter validation.
//              -   In CreateOrOpenStorage(create), clean up partially
//                  created stream on error.
//
//+============================================================================


#include <pch.cxx>
#include <expparam.hxx> // CExpParameterValidate
#include <docfilep.hxx>


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg::QueryInterface (IUnknown)
//
//  This method only allows QI between IStorage & IUnknown.  This is the only
//  kind of QI that CPropertySetStorage makes.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::QueryInterface( REFIID riid, void** ppvObject )
{
    HRESULT hr = S_OK;

    if( IID_IUnknown == riid || IID_IStorage == riid )
    {
        *ppvObject = static_cast<IStorage*>(this);
        AddRef();
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

    return( hr );

}   // CNtfsStorageForPropSetStg::QueryInterface


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorage::CNtfsStorageForPropSetStg delegation methods
//
//  These methods all delegate directly to CNtfsStorage's IStorage methods.
//
//+----------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::AddRef()
{
    return( _pNtfsStorage->AddRef() );
}

ULONG STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Release()
{
    return( _pNtfsStorage->Release() );
}


HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Commit(
            /* [in] */ DWORD grfCommitFlags)
{
    return( _pNtfsStorage->Commit( grfCommitFlags ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Revert( void)
{
    return( _pNtfsStorage->Revert() );
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::SetElementTimes(
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ const FILETIME __RPC_FAR *pctime,
            /* [unique][in] */ const FILETIME __RPC_FAR *patime,
            /* [unique][in] */ const FILETIME __RPC_FAR *pmtime)
{
    return( _pNtfsStorage->SetElementTimes( pwcsName, pctime, patime, pmtime ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::SetClass(
            /* [in] */ REFCLSID clsid)
{
    return( _pNtfsStorage->SetClass( clsid ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::SetStateBits(
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask)
{
    return( _pNtfsStorage->SetStateBits( grfStateBits, grfMask ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::Stat(
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
{
    return( _pNtfsStorage->Stat( pstatstg, grfStatFlag ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::EnumElements(
    /* [in] */ DWORD reserved1,
    /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
    /* [in] */ DWORD reserved3,
    /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum)
{
    return( _pNtfsStorage->EnumElements( reserved1, reserved2, reserved3, ppenum ));
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::DestroyElement(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName)
{
    return( _pNtfsStorage->DestroyElement( pwcsName ));
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg noimpl methods
//
//  These methods are unused by CPropertySetStorage and left unimplemented.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::CopyTo(
    /* [in] */ DWORD ciidExclude,
    /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
    /* [unique][in] */ SNB snbExclude,
    /* [unique][in] */ IStorage __RPC_FAR *pstgDest)
{
    return( E_NOTIMPL );    // No need to implement
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::MoveElementTo(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags)
{
    return( E_NOTIMPL );    // Not necessary to implement
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::RenameElement(
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName)
{
    return( E_NOTIMPL );    // Not necessary to implement
}


//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg::CreateStorage (IStorage)
//
//  CNtfsStorage doesn't support CreateStorage.  For CPropertySetStorage,
//  we support it with the special CNtfsStorageForPropStg, which is created
//  here.
//
//+----------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::CreateStorage(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{

    HRESULT hr = S_OK;
    IStorage *    pstg = NULL;
    CNtfsStream *pNtfsStream = NULL;

    propXTrace( "CNtfsStorageForPropSetStg::CreateStorage" );

    _pNtfsStorage->Lock( INFINITE );

    hr = CExpParameterValidate::CreateStorage( pwcsName, grfMode, reserved1,
                                               reserved2, ppstg );
    if( FAILED(hr) ) goto Exit;

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    propTraceParameters(( "%ws, 0x%08x, 0x%x, 0x%x, %p",
                          pwcsName, grfMode, reserved1, reserved2, ppstg ));

    // In the underlying CNtfsStorage, we give streams and storages different
    // names (storages have a "Docfile_" prefix).  So we require special
    // handling for STGM_CREATE/STGM_FAILIFTHERE.

    if( STGM_CREATE & grfMode )
    {
        // Delete any existing stream
        hr = _pNtfsStorage->DestroyStreamElement( pwcsName );
        if( FAILED(hr) && STG_E_FILENOTFOUND != hr )
        {
            propDbg(( DEB_ERROR, "Couldn't destroy %s", pwcsName ));
            goto Exit;
        }
        hr = S_OK;
    }
    else
    {
        // STGM_FAILIFTHERE
        hr = _pNtfsStorage->StreamExists( pwcsName );
        if( FAILED(hr) ) goto Exit;

        if( S_OK == hr )
        {
            hr = STG_E_FILEALREADYEXISTS;
            goto Exit;
        }
    }

    // Create the storage

    hr = CreateOrOpenStorage( pwcsName, NULL, grfMode, NULL, TRUE /* fCreate */, &pstg );
    if( FAILED(hr) ) goto Exit;

    *ppstg = pstg;
    pstg = NULL;

Exit:

    if( pstg )
        pstg->Release();

    _pNtfsStorage->Unlock();

    if( STG_E_FILEALREADYEXISTS == hr )
        propSuppressExitErrors();
    return( hr );

}   // CNtfsStorageForPropSetStg::CreateStorage

//+----------------------------------------------------------------------------
//
//  Method:     CNtfsStorageForPropSetStg::OpenStorage (IStorage)
//
//  CNtfsStorage doesn't support OpenStorage.  For CPropertySetStorage,
//  we support it with the special CNtfsStorageForPropStg, which is created
//  here.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::OpenStorage(
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg)
{
    HRESULT hr = S_OK;

    propXTrace( "CNtfsStorageForPropSetStg::OpenStorage" );

    hr = CExpParameterValidate::OpenStorage( pwcsName, pstgPriority, grfMode,
                                             snbExclude, reserved, ppstg );
    if( FAILED(hr) ) goto Exit;

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    propTraceParameters(( "%ws, %p, 0x%08x, %p, 0x%x, %p",
                          pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg ));

    hr = CreateOrOpenStorage( pwcsName, pstgPriority, grfMode, snbExclude,
                                 FALSE /*!fCreate*/, ppstg );
    if( FAILED(hr) ) goto Exit;

    hr = S_OK;

Exit:

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return( hr );

}   // CNtfsStorageForPropSetStg::OpenStorage



HRESULT
CNtfsStorageForPropSetStg::CreateOrOpenStorage( const OLECHAR *pwcsName,
                                                IStorage *pstgPriority,
                                                DWORD grfMode,
                                                SNB snbExclude,
                                                BOOL fCreate,
                                                IStorage **ppstg )
{
    HRESULT hr = S_OK;
    CNtfsStream * pNtfsStream = NULL;
    IStorage *    pstg = NULL;
    BOOL fCreated = FALSE;

    propITrace( "CNtfsStorageForPropSetStg::CreateOrOpenStorage" );
    propTraceParameters(( "%ws, %p, 0x%08x, %p, %d, %p",
                          pwcsName, pstgPriority, grfMode, snbExclude, fCreate, ppstg ));

    _pNtfsStorage->Lock( INFINITE );

    CDocfileStreamName docfsn(pwcsName);
    const WCHAR* pwcszStreamName = docfsn;

    // Open the NTFS stream
    if( fCreate )
    {
        hr = _pNtfsStorage->CreateStream( docfsn, grfMode, 0, 0,
                                          (IStream**)&pNtfsStream );
    }
    else
    {
        hr = _pNtfsStorage->OpenStream( docfsn, NULL, grfMode, 0,
                                        (IStream**)&pNtfsStream );
    }

    if( FAILED(hr) )
        goto Exit;

    fCreated = TRUE;

    hr = CreateOrOpenStorageOnILockBytes( static_cast<ILockBytes*>(pNtfsStream),
                                          NULL, grfMode, NULL, fCreate, &pstg );
    if( FAILED(hr) ) goto Exit;

    pNtfsStream->Release();
    pNtfsStream = NULL;

    *ppstg = pstg;
    pstg = NULL;

Exit:

    if( NULL != pNtfsStream )
        pNtfsStream->Release();

    if( pstg )
        pstg->Release();

    // If we fail in the create path, we shouldn't leave behind a corrupt
    // docfile.  I.e., if NewCNtfsStream succeded but create-on-ilockbyte failed,
    // we have an empty stream which cannot be opened.

    if( FAILED(hr) && fCreate && fCreated )
        _pNtfsStorage->DestroyElement( CDocfileStreamName(pwcsName) );

    _pNtfsStorage->Unlock();

    if( STG_E_FILENOTFOUND == hr )
        propSuppressExitErrors();

    return( hr );
}

//+----------------------------------------------------------------------------
//
//  Method: CreateOrOpenStorageOnILockBytes
//
//  Given an ILockBytes, create or open a docfile.  The input grfMode is that
//  of the property set, though the docfile may be opened in a different
//  mode as appropriate.
//
//+----------------------------------------------------------------------------

HRESULT // static
CNtfsStorageForPropSetStg::CreateOrOpenStorageOnILockBytes( ILockBytes *plkb,
                                                            IStorage *pstgPriority,
                                                            DWORD grfMode,
                                                            SNB snbExclude,
                                                            BOOL fCreate,
                                                            IStorage **ppstg )
{
    HRESULT hr = S_OK;

    propITraceStatic( "CNtfsStorageForPropSetStg::CreateOrOpenStorageOnILockBytes" );
    propTraceParameters(( "%p, %p, 0x%08x, %p, %d, %p",
                          plkb, pstgPriority, grfMode, snbExclude, fCreate, ppstg ));

    if( fCreate )
    {
        // We have to force the STGM_CREATE bit to avoid an error.  This is OK
        // (though the caller might not have set it) because we already handled
        // stgm_create/stgm_failifthere in the CreateStorage caller.

        hr = StgCreateDocfileOnILockBytes( plkb,
                                           grfMode | STGM_CREATE | STGM_TRANSACTED,
                                           0, ppstg );
    }
    else
    {
        // We only set stgm_transacted if necessary, and we only open deny_write in the
        // read-only open case.  This is so that we can allow multiple read-only/deny-write
        // root opens.

        hr = StgOpenStorageOnILockBytes( plkb, pstgPriority,
                                         grfMode & ~STGM_SHARE_MASK
                                         | (GrfModeIsWriteable(grfMode) ? STGM_SHARE_EXCLUSIVE | STGM_TRANSACTED
                                                                        : STGM_SHARE_DENY_WRITE),
                                         snbExclude, 0, ppstg );

        // STG_E_INVALIDHEADER in some paths of the above call gets converted into
        // STG_E_FILEALREADYEXISTS, which doesn't make a whole lot of sense from
        // from our point of view (we already knew it existed, we wanted to open it).  So,
        // translate it back.
        if( STG_E_FILEALREADYEXISTS == hr )
            hr = STG_E_INVALIDHEADER;
    }
    if( FAILED(hr) ) goto Exit;

Exit:

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  Method: CNtfsStorageForPropSetStg::CreateStream (IStorage)
//          CNtfsStorageForPropSetStg::OpenStream (IStorage)
//
//  These methods call to the CreateOrOpenStream method to do most of the
//  work.  CreateStream also needs to do extra work to handle the case where
//  a stream/storage is being created, but a storage/stream by that name
//  already exists.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::CreateStream(
    /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
    /* [in] */ DWORD grfMode,
    /* [in] */ DWORD reserved1,
    /* [in] */ DWORD reserved2,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr = S_OK;
    CDocfileStreamName dsName( pwcsName );

    propXTrace( "CNtfsStorageForPropSetStg::CreateStream" );
    _pNtfsStorage->Lock( INFINITE );

    hr = CExpParameterValidate::CreateStream( pwcsName, grfMode, reserved1,
                                              reserved2, ppstm );
    if( FAILED(hr) ) goto Exit;

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    propTraceParameters(( "%ws, 0x%08x, %x, %x, %p",
                          pwcsName, grfMode, reserved1, reserved2, ppstm ));

    // In the underlying CNtfsStorage, we give streams and storages different
    // names (storages have a "Docfile_" prefix).  So we require special
    // handling for STGM_CREATE/STGM_FAILIFTHERE.

    if( STGM_CREATE & grfMode )
    {
        hr = _pNtfsStorage->DestroyStreamElement( dsName );
        if( FAILED(hr) && STG_E_FILENOTFOUND != hr )
        {
            propDbg(( DEB_ERROR, "Couldn't destroy %ws",
                            static_cast<const WCHAR*>(dsName) ));
            goto Exit;
        }
        hr = S_OK;
    }
    else
    {
        // STGM_FAILIFTHERE
        hr = _pNtfsStorage->StreamExists( dsName );
        if( FAILED(hr) ) goto Exit;

        if( S_OK == hr )
        {
            hr = STG_E_FILEALREADYEXISTS;
            goto Exit;
        }
    }

    // Instantiate & initialize the *ppstm.

    //hr = CreateOrOpenStream( pwcsName, grfMode, TRUE /*Create*/, ppstm );
    hr = _pNtfsStorage->CreateStream( pwcsName, grfMode, 0, 0, ppstm );
    if( FAILED(hr) ) goto Exit;

Exit:

    _pNtfsStorage->Unlock();

    if( STG_E_FILEALREADYEXISTS == hr )
        propSuppressExitErrors();
    return( hr );
}

HRESULT STDMETHODCALLTYPE
CNtfsStorageForPropSetStg::OpenStream(
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
{
    HRESULT hr;
    hr = CExpParameterValidate::OpenStream( pwcsName, reserved1, grfMode,
                                            reserved2, ppstm );
    if( FAILED(hr) ) goto Exit;

    hr = EnforceSingle(grfMode);
    if( FAILED(hr) ) goto Exit;

    hr = _pNtfsStorage->OpenStream( pwcsName, NULL, grfMode, 0, ppstm );
    if( FAILED(hr) ) goto Exit;

    hr = S_OK;

Exit:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\props\bag.cxx ===
//+============================================================================
//
//  File:   bag.cxx
//
//          This file implements the IPropertyBagEx implementation used
//          in docfile, NSS (Native Structured Storage) and NFF (NTFS
//          Flat-File).  IPropertyBagEx is required to be QI-able
//          from IStorage, so CPropertyBagEx is instantiated as a 
//          data member of the various IStorage implementations.
//
//  History:
//
//      3/10/98  MikeHill   - Don't create a property set until the bag
//                            is modified
//                          - Add a constructor & IUnknown so that this class can
//                            be instantiated standalone (used by
//                            StgCreate/OpenStorageOnHandle).
//                          - Added dbg tracing.
//                          - Removed Commit-after-writes.
//                          - Chagned from STATPROPS structure to STATPROPBAG.
//                          - Added parameter validation.
//                          - Added a ShutDown method.
//      5/6/98  MikeHill
//              -   Split IPropertyBag from IPropertyBagEx, new BagEx
//                  DeleteMultiple method.
//              -   Added support for VT_UNKNOWN/VT_DISPATCH.
//              -   Beefed up dbg outs.
//              -   Use CoTaskMem rather than new/delete.
//      5/18/98 MikeHill
//              -   Moved some initialization from the constructors
//                  to a new Init method.
//              -   Disallow non-Variant types in IPropertyBag::Write.
//      6/11/98 MikeHill
//              -   Add the new reserved parameter to DeleteMultiple.
//
//+============================================================================                          


#include <pch.cxx>
#include "chgtype.hxx"

#define FORCE_EXCLUSIVE(g) ((g & ~STGM_SHARE_MASK) | STGM_SHARE_EXCLUSIVE)
//
// Add this prototype to chgtype.hxx when chgtype.hxx is finalized.
//
HRESULT ImplicitPropVariantToVariantChangeType(
                    PROPVARIANT *pDest,
                    const PROPVARIANT *pSrc,
                    LCID lcid );

HRESULT HrPropVarVECTORToSAFEARRAY(
                    PROPVARIANT *pDest,
                    const PROPVARIANT *pSrc,
                    LCID lcid,
                    VARTYPE vtCoerce );

HRESULT LoadPropVariantFromVectorElem(
                    PROPVARIANT *pDest,
                    const PROPVARIANT *pSrc,
                    int idx);

HRESULT PutPropVariantDataIntoSafeArray(
                    SAFEARRAY *psa,
                    const PROPVARIANT *pSrc,
                    int idx);

//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx
//
//+----------------------------------------------------------------------------

// Normal constructor
CPropertyBagEx::CPropertyBagEx( DWORD grfMode )
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyBagEx::CPropertyBagEx(IPropertySetStorage)" );
    propTraceParameters(( "0x%x", grfMode ));

    // mask out the stgm_transacted bit; the bag is 
    // interpreted as part of the parent storage, and should therefore
    // be in the storage's transaction set.

    _grfMode = grfMode & ~STGM_TRANSACTED;
    _lcid = LOCALE_NEUTRAL;
    _fLcidInitialized = FALSE;

    _ppropstg = NULL;
    _ppropsetstgContainer = NULL;
    _pBlockingLock = NULL;

    // We won't use this ref-count, we'll rely on _ppropsetstgContainer
    _cRefs = 0;

}   // CPropertyBagEx::CPropertyBagEx(grfMode)

// Constructor for building an IPropertyBagEx on an IPropertyStorage
CPropertyBagEx::CPropertyBagEx( DWORD grfMode,
                                IPropertyStorage *ppropstg,
                                IBlockingLock *pBlockingLock )
{
    HRESULT hr = S_OK;
    propITrace( "CPropertyBagEx::CPropertyBagEx(IPropertyStorage)" );
    propTraceParameters(( "0x%x, 0x%x", ppropstg, pBlockingLock ));

    new(this) CPropertyBagEx( grfMode );

    Init (NULL, pBlockingLock);

    // We addref and keep the IPropertyStorage
    _ppropstg = ppropstg;
    _ppropstg->AddRef();

    // We keep and addref the BlockingLock
    _pBlockingLock->AddRef();

    // We also keep our own ref-count
    _cRefs = 1;

}   // CPropertyBagEx::CPropertyBagEx(grfMode, IPropertyStorage*, IBlockingLock*)


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Init (non-interface method)
//
//  This method is used by the caller to provide the IPropertySetStorage
//  (and IBlockingLock) that is to contain the property bag.
//  This must be called after the simple grfMode-based constructor.
//
//  This method does *not* addref these interfaces.
//
//+----------------------------------------------------------------------------

void
CPropertyBagEx::Init( IPropertySetStorage *ppropsetstg, IBlockingLock *pBlockingLock )
{
    DfpAssert( NULL == _ppropsetstgContainer
               &&
               NULL == _pBlockingLock
               &&
               NULL == _ppropstg );

    _ppropsetstgContainer = ppropsetstg;
    _pBlockingLock = pBlockingLock;

}


//+----------------------------------------------------------------------------
//
//  Method: ~CPropertyBagEx
//
//+----------------------------------------------------------------------------

CPropertyBagEx::~CPropertyBagEx()
{
#if DBG
    IStorageTest *ptest = NULL;
    HRESULT hr = S_OK;

    if( NULL != _ppropstg )
    {
        hr = _ppropstg->QueryInterface( IID_IStorageTest, reinterpret_cast<void**>(&ptest) );
        if( SUCCEEDED(hr) )
        {
            hr = ptest->IsDirty();
            DfpAssert( S_FALSE == hr || E_NOINTERFACE == hr );
            RELEASE_INTERFACE(ptest);
        }
    }
#endif // #if DBG

    ShutDown();
}



//+----------------------------------------------------------------------------
//
//  Method: OpenPropStg
//
//  Open the bag's IPropertyStorage.  If FILE_OPEN_IF is specified, we open
//  it only if it already exists.  if FILE_OPEN is specified, we'll create it
//  if necessary.
//
//+----------------------------------------------------------------------------


HRESULT
CPropertyBagEx::OpenPropStg( DWORD dwDisposition )
{
    HRESULT hr = S_OK;
    IPropertyStorage *ppropstg = NULL;
    PROPVARIANT propvarCodePage;
    PROPSPEC    propspecCodePage;
    STATPROPSETSTG statpropsetstg;

    propITrace( "CPropertyBagEx::OpenPropStg" );
    propTraceParameters(( "%s", FILE_OPEN_IF == dwDisposition
                                    ? "OpenIf"
                                    : (FILE_OPEN == dwDisposition ? "Open" : "Unknown disposition")
                          ));

    DfpAssert( FILE_OPEN == dwDisposition || FILE_OPEN_IF == dwDisposition );
    PropVariantInit( &propvarCodePage );

    // Does the IPropertyStorage need to be opened?

    if( NULL == _ppropstg )
    {
        // Try to open the property storage
        // We have to open exclusive, no matter how the parent was opened.

        hr = _ppropsetstgContainer->Open( FMTID_PropertyBag,
                                          FORCE_EXCLUSIVE(_grfMode) & ~STGM_CREATE,
                                          &ppropstg );

        if( STG_E_FILENOTFOUND == hr && FILE_OPEN == dwDisposition )
        {
            // It didn't exist, and we're supposed to remedy that.
            hr = _ppropsetstgContainer->Create( FMTID_PropertyBag, NULL, 
                                                PROPSETFLAG_CASE_SENSITIVE | PROPSETFLAG_NONSIMPLE,
                                                FORCE_EXCLUSIVE(_grfMode) | STGM_CREATE,
                                                &ppropstg );
        }
        else if( STG_E_FILENOTFOUND == hr && FILE_OPEN_IF == dwDisposition )
        {
            // This is an expected error.
            propSuppressExitErrors();
        }

        if( FAILED(hr) ) goto Exit;

        // Verify that this is a Unicode property set

        propspecCodePage.ulKind = PRSPEC_PROPID;
        propspecCodePage.propid = PID_CODEPAGE;
        hr = ppropstg->ReadMultiple( 1, &propspecCodePage, &propvarCodePage );
        if( FAILED(hr) ) goto Exit;

        if( VT_I2 != propvarCodePage.vt
            ||
            CP_WINUNICODE != propvarCodePage.iVal )
        {
            propDbg(( DEB_ERROR, "Non-unicode codepage found in supposed property bag (0x%x)\n",
                      propvarCodePage.iVal ));
            hr = STG_E_INVALIDHEADER;
            goto Exit;
        }

        // Also verify that the property set is non-simple and case-sensitive

        hr = ppropstg->Stat( &statpropsetstg );
        if( FAILED(hr) ) goto Exit;

        if( !(PROPSETFLAG_CASE_SENSITIVE & statpropsetstg.grfFlags)
            ||
            !(PROPSETFLAG_NONSIMPLE & statpropsetstg.grfFlags) )
        {
            propDbg(( DEB_ERROR, "Supposed property bag isn't case sensitive or isn't non-simple (0x%x)\n",
                                 statpropsetstg.grfFlags ));
            hr = STG_E_INVALIDHEADER;
            goto Exit;
        }
                                        
        _ppropstg = ppropstg;
        ppropstg = NULL;
    }

    // Even if we already have an open IPropertyStorage, we may not have yet read the
    // Locale ID (this happens in the case where the CPropertyBagEx(IPropertyStorage*)
    // constructor is used).

    if( !_fLcidInitialized )
    {
        hr = GetLCID();
        if( FAILED(hr) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    DfpVerify( 0 == RELEASE_INTERFACE(ppropstg) );
    return(hr);

}   // CPropertyBagEx::OpenPropStg



//+----------------------------------------------------------------------------
//
//  Method: GetLCID
//
//  Get the LocalID from the property set represented by _ppropstg.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::GetLCID()
{
    HRESULT hr = S_OK;
    PROPSPEC propspecLCID;
    PROPVARIANT propvarLCID;

    propITrace( "CPropertyBagEx::GetLCID" );

    propspecLCID.ulKind = PRSPEC_PROPID;
    propspecLCID.propid = PID_LOCALE;

    if( SUCCEEDED( hr = _ppropstg->ReadMultiple( 1, &propspecLCID, &propvarLCID ))
        &&
        VT_UI4 == propvarLCID.vt )
    {
        _lcid = propvarLCID.uiVal;
    }
    else if( S_FALSE == hr )
    {
        _lcid = GetUserDefaultLCID();
    }

    PropVariantClear( &propvarLCID );
    return( hr );

}   // CPropertyBagEx::GetLCID()

//+----------------------------------------------------------------------------
//
//  Method: IUnknown methods
//
//  If we have a parent (_ppropsetstgParent), we forward all calls to there.
//  Otherwise, we implement all calls here.  Whether or not we have a parent
//  depends on which of the two constructors is called.  In NFF, NSS, and docfile,
//  we have a parent.  When creating a standalone property bag implementation
//  (in StgCreate/OpenStorageOnHandle), we have no such parent.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    // Do we have a parent?
    if( NULL != _ppropsetstgContainer )
    {
        // Yes, refer the call
        DfpAssert( 0 == _cRefs );
        return( _ppropsetstgContainer->QueryInterface( riid, ppvObject ));
    }
    else
    {
        // No, we have no parent.
        if( IID_IPropertyBagEx == riid
            ||
            IID_IUnknown == riid )
        {
            AddRef();
            *ppvObject = static_cast<IPropertyBagEx*>(this);
            return( S_OK );
        }

        else if( IID_IPropertyBag == riid )
        {
            AddRef();
            *ppvObject = static_cast<IPropertyBag*>(this);
            return( S_OK );
        }
    }

    return( E_NOINTERFACE );
}


ULONG STDMETHODCALLTYPE
CPropertyBagEx::AddRef( void)
{
    // Do we have a parent?
    if( NULL != _ppropsetstgContainer )
    {
        // Yes.  The parent does the ref-counting
        DfpAssert( 0 == _cRefs );
        return( _ppropsetstgContainer->AddRef() );
    }
    else
    {
        // No.  We don't have a parent, and we must do the ref-counting.
        LONG lRefs = InterlockedIncrement( &_cRefs );
        return( lRefs );
    }
}


ULONG STDMETHODCALLTYPE
CPropertyBagEx::Release( void)
{
    // Do we have a parent?
    if( NULL != _ppropsetstgContainer )
    {
        // Yes.  The container does the ref-counting
        DfpAssert( 0 == _cRefs );
        return( _ppropsetstgContainer->Release() );
    }
    else
    {
        // No.  We don't have a parent, and we must do the ref-counting.
        LONG lRefs = InterlockedDecrement( &_cRefs );
        if( 0 == lRefs )
        {
            // Only in this case (where we have no parent) do we release
            // the IBlockingLock
            RELEASE_INTERFACE( _pBlockingLock );

            delete this;
        }
        return( lRefs );
    }
}


//+----------------------------------------------------------------------------
//
//  Method: Read/Write (IPropertyBag)
//
//  These methods simply thunk to ReadMultiple/WriteMultiple.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Read(
    /* [in] */ LPCOLESTR pszPropName,
    /* [out][in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ IErrorLog __RPC_FAR *pErrorLog)
{
    HRESULT hr=S_OK, hr2=S_OK;
    PROPVARIANT *ppropvar, propvarTmp;

    ppropvar = reinterpret_cast<PROPVARIANT*>(pVar);
    propvarTmp = *ppropvar;

    hr = ReadMultiple(1, &pszPropName, &propvarTmp, pErrorLog );
    if( !FAILED( hr ) )
    {
        hr2 = ImplicitPropVariantToVariantChangeType( ppropvar, &propvarTmp, _lcid );
        PropVariantClear( &propvarTmp );
    }
    if( FAILED(hr2) )
        return hr2;
    else
        return hr;
}   // CPropertyBagEx::Read


HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Write(
    /* [in] */ LPCOLESTR pszPropName,
    /* [in] */ VARIANT __RPC_FAR *pVar)
{
    if( !IsVariantType( pVar->vt ))
        return( STG_E_INVALIDPARAMETER );

    return( WriteMultiple(1, &pszPropName, reinterpret_cast<PROPVARIANT*>(pVar) ));
}


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::ReadMultiple (IPropertyBagEx)
//
//  This method calls down to IPropertyStorage::ReadMultiple.  It has the
//  additional behaviour of coercing the property types into those specified
//  by the caller.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::ReadMultiple( 
        /* [in] */ ULONG cprops,
        /* [size_is][in] */ LPCOLESTR const __RPC_FAR rgoszPropNames[  ],
        /* [size_is][out][in] */ PROPVARIANT __RPC_FAR rgpropvar[  ],
        /* [in] */ IErrorLog __RPC_FAR *pErrorLog)
{
    HRESULT hr = S_OK;
    ULONG i;
    PROPSPEC *rgpropspec = NULL;    // PERF: use TStackBuffer
    PROPVARIANT *rgpropvarRead = NULL;
    BOOL fAtLeastOnePropertyRead = FALSE;

    propXTrace( "CPropertyBagEx::ReadMultiple" );

    _pBlockingLock->Lock( INFINITE );

    //  ----------
    //  Validation
    //  ----------

    if (0 == cprops)
    {
        hr = S_OK;
        goto Exit;
    }

    if (S_OK != (hr = ValidateInRGLPOLESTR( cprops, rgoszPropNames )))
        goto Exit;
    if (S_OK != (hr = ValidateOutRGPROPVARIANT( cprops, rgpropvar )))
        goto Exit;

    propTraceParameters(( "%d, 0x%x, 0x%x, 0x%x", cprops, rgoszPropNames, rgpropvar, pErrorLog ));

    //  --------------
    //  Initialization
    //  --------------

    // Open the underlying property set if it exists.

    hr = OpenPropStg( FILE_OPEN_IF );
    if( STG_E_FILENOTFOUND == hr )
    {
        // The property storage for this bag doesn't even exist.  So we simulate
        // the reading non-extant properties by setting the vt's to emtpy and returning
        // s_false.

        for( ULONG i = 0; i < cprops; i++ )
            rgpropvar[i].vt = VT_EMPTY;

        hr = S_FALSE;
        goto Exit;
    }
    else if( FAILED(hr) )
        goto Exit;


    // The property set existed and is now open.

    // Alloc propspec & propvar arrays.  
    // PERF:  Make these stack-based for typical-sized reads.

    rgpropspec = reinterpret_cast<PROPSPEC*>
                 ( CoTaskMemAlloc( cprops * sizeof(PROPSPEC) ));
    if( NULL == rgpropspec )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    rgpropvarRead = reinterpret_cast<PROPVARIANT*>
                    ( CoTaskMemAlloc( cprops * sizeof(PROPVARIANT) ));
    if( NULL == rgpropvarRead )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Put the names into the propspecs.

    for( i = 0; i < cprops; i++ )
    {
        PropVariantInit( &rgpropvarRead[i] );
        rgpropspec[i].ulKind = PRSPEC_LPWSTR;
        rgpropspec[i].lpwstr = const_cast<LPOLESTR>(rgoszPropNames[i]);
    }

    //  ----------------------------
    //  Read & coerce the properties
    //  ----------------------------

    // Read the properties into the local PropVar array
    hr = _ppropstg->ReadMultiple(cprops, rgpropspec, rgpropvarRead );
    if( FAILED(hr) ) goto Exit;
    if( S_FALSE != hr )
        fAtLeastOnePropertyRead = TRUE;

    // Coerce the properties as necessary

    for( i = 0; i < cprops; i++ )
    {
        // If the caller requested a type (something other than VT_EMPTY), and the
        // requested type isn't the same as the read type, then a coercion is necessary.
        if( VT_EMPTY != rgpropvar[i].vt && rgpropvarRead[i].vt != rgpropvar[i].vt )
        {
            PROPVARIANT propvar;
            PropVariantInit( &propvar );

            // Does this property require conversion
            // (i.e. to a VT_UNKNOWN/DISPATCH)?
            if( PropertyRequiresConversion( rgpropvar[i].vt )
                &&
                ( VT_STORED_OBJECT == rgpropvarRead[i].vt
                  ||
                  VT_STREAMED_OBJECT == rgpropvarRead[i].vt
                )
              )
            {
                // Load the object from the stream/storage in rgpropvarRead
                // into propvar.

                propvar = rgpropvar[i];
                hr = LoadObject( &propvar, &rgpropvarRead[i] );
                if( FAILED(hr) )
                    goto Exit;
            }
            else
            {
                // Coerce the property in rgpropvarRead into propvar, according
                // to the caller-requested type (which is specified in rgpropvar).

                hr = PropVariantChangeType( &propvar, &rgpropvarRead[i],
                                              _lcid, 0, rgpropvar[i].vt );
                if( FAILED(hr) )
                {
                    propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x), PropVariantChangeType"
                                         "(0x%x,0x%x,%d,%d,%d) returned %08x\n",
                                         this, &propvar, &rgpropvarRead[i], _lcid, 0, rgpropvar[i].vt, hr ));
                    goto Exit;
                }
            }

            // Get rid of the value original read, and keep the coerced value.
            PropVariantClear( &rgpropvarRead[i] );
            rgpropvarRead[i] = propvar;
        }
    }   // for( i = 0; i < cprops; i++ )

    // No errors from here to the end.
    // Copy the PropVars from the local array to the caller's

    for( i = 0; i < cprops; i++ )
        rgpropvar[i] = rgpropvarRead[i];

    //  ----
    //  Exit
    //  ----

    CoTaskMemFree( rgpropvarRead );
    rgpropvarRead = NULL;

    if( SUCCEEDED(hr) )
        hr = fAtLeastOnePropertyRead ? S_OK : S_FALSE;
            

Exit:

    // We needn't free the rgpropspec[*].lpwstr members, they point
    // into rgszPropName
    if( NULL != rgpropspec )
        CoTaskMemFree( rgpropspec );

    if( NULL != rgpropvarRead )
    {
        for( i = 0; i < cprops; i++ )
            PropVariantClear( &rgpropvarRead[i] );
        CoTaskMemFree( rgpropvarRead );
    }

    _pBlockingLock->Unlock();
    return( hr );

}   // CPropertyBagEx::ReadMultiple



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::LoadObject
//
//  This method loads an IUnknown or IDispatch object from its persisted state
//  in a stream or storage (by QI-ing for IPersistStream or IPersistStorage,
//  respectively).
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::LoadObject( OUT PROPVARIANT *ppropvarOut, IN PROPVARIANT *ppropvarIn ) const
{
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;
    IPersistStorage *pPersistStg = NULL;
    IPersistStream  *pPersistStm = NULL;

    propITrace( "CPropertyBagEx::LoadObject" );

    DfpAssert( VT_STREAMED_OBJECT == ppropvarIn->vt || VT_STORED_OBJECT == ppropvarIn->vt );
    DfpAssert( VT_UNKNOWN == ppropvarOut->vt || VT_DISPATCH == ppropvarOut->vt );

    punk = ppropvarOut->punkVal;
    DfpAssert( reinterpret_cast<void*>(&ppropvarOut->punkVal)
               ==
               reinterpret_cast<void*>(&ppropvarOut->pdispVal) );

    //  --------------------------
    //  Read in an IPersistStorage
    //  --------------------------

    if( VT_STORED_OBJECT == ppropvarIn->vt )
    {
        DfpAssert( NULL != ppropvarIn->pStorage );

        // Get an IUnknown if the caller didn't provide one.

        if( NULL == punk )
        {
            STATSTG statstg;

            hr = ppropvarIn->pStorage->Stat( &statstg, STATFLAG_NONAME );
            if( FAILED(hr) ) goto Exit;

            hr = CoCreateInstance( statstg.clsid, NULL, CLSCTX_ALL, IID_IUnknown,
                                   reinterpret_cast<void**>(&punk) );
            if( FAILED(hr) ) goto Exit;
        }

        // QI for IPersistStorage

        hr = punk->QueryInterface( IID_IPersistStorage, reinterpret_cast<void**>(&pPersistStg) );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Caller didn't provide IPersistStorage in IProeprtyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }
        
        // IPersist::Load the storage

        hr = pPersistStg->Load( ppropvarIn->pStorage );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Failed IPersistStorage::Load in IPropretyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }

    }   // if( VT_STORED_OBJECT == ppropvarIn->vt )


    //  -------------------------
    //  Read in an IPersistStream
    //  -------------------------

    else
    {
        DfpAssert( VT_STREAMED_OBJECT == ppropvarIn->vt );
        DfpAssert( NULL != ppropvarIn->pStream );

        CLSID clsid;
        ULONG cbRead;

        // Skip over the clsid

        hr = ppropvarIn->pStream->Read( &clsid, sizeof(clsid), &cbRead );
        if( FAILED(hr) ) goto Exit;
        if( sizeof(clsid) != cbRead )
        {
            hr = STG_E_INVALIDHEADER;
            propDbg(( DEB_ERROR, "Clsid missing in VT_STREAMED_OBJECT in IPropertyBagEx::ReadMultiple (%d bytes)",
                      cbRead ));
            goto Exit;
        }

        // Get an IUnknown if the caller didn't provide one.

        if( NULL == punk )
        {
            hr = CoCreateInstance( clsid, NULL, CLSCTX_ALL, IID_IUnknown,
                                   reinterpret_cast<void**>(&punk) );
            if( FAILED(hr) ) goto Exit;
        }

        // QI for the IPersistStream

        hr = punk->QueryInterface( IID_IPersistStream, reinterpret_cast<void**>(&pPersistStm) );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Caller didn't provide IPersistStream in IPropertyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }

        // Load the remainder of the stream

        IFDBG( ULONG cRefs = GetRefCount( ppropvarIn->pStream ));

        hr = pPersistStm->Load( ppropvarIn->pStream );
        if( FAILED(hr) )
        {
            propDbg(( DEB_ERROR, "Failed IPersistStream::Load in IPropertyBagEx::ReadMultiple (%08x)", hr ));
            goto Exit;
        }

        DfpAssert( GetRefCount( ppropvarIn->pStream ) == cRefs );

    }   // if( VT_STORED_OBJECT == ppropvarIn->vt ) ... else

    //  ----
    //  Exit
    //  ----

    ppropvarOut->punkVal = punk;
    punk = NULL;
    hr = S_OK;

Exit:

    RELEASE_INTERFACE( pPersistStg );
    RELEASE_INTERFACE( pPersistStm );
    RELEASE_INTERFACE( punk );

    return( hr );

}   // CPropertyBagEx::LoadObject



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::WriteMultiple (IPropertyBagEx)
//
//  This method calls down to IPropertyStorage::WriteMultiple.  Additionally,
//  this method is atomic.  So if the WriteMultiple fails, the IPropertyStorage
//  is reverted and reopened.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::WriteMultiple(
        /* [in] */ ULONG cprops,
        /* [size_is][in] */ LPCOLESTR const __RPC_FAR rgoszPropNames[  ],
        /* [size_is][in] */ const PROPVARIANT __RPC_FAR rgpropvar[  ])
{
    HRESULT hr = S_OK;
    ULONG i;
    PROPSPEC *prgpropspec = NULL;
    BOOL fInterfaces = FALSE;

    _pBlockingLock->Lock( INFINITE );

    CStackPropVarArray rgpropvarCopy;
    propXTrace( "CPropertyBagEx::WriteMultiple" );

    hr = rgpropvarCopy.Init( cprops );
    if( FAILED(hr) ) goto Exit;


    //  ----------
    //  Validation
    //  ----------

    if (0 == cprops)
    {
        hr = S_OK;
        goto Exit;
    }

    if (S_OK != (hr = ValidateInRGLPOLESTR( cprops, rgoszPropNames )))
        goto Exit;
    if (S_OK != (hr = ValidateInRGPROPVARIANT( cprops, rgpropvar )))
        goto Exit;

    propTraceParameters(("%lu, 0x%x, 0x%x", cprops, rgoszPropNames, rgpropvar));

    //  --------------
    //  Initialization
    //  --------------

    // Open the property storage if it isn't already, creating if necessary.

    hr = OpenPropStg( FILE_OPEN );
    if( FAILED(hr) ) goto Exit;

    // PERF: Create a local array of propspecs for the WriteMultiple call

    prgpropspec = reinterpret_cast<PROPSPEC*>( CoTaskMemAlloc( cprops * sizeof(PROPSPEC) ));
    if( NULL == prgpropspec )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Set up the PROPSPEC and PROPVARIANT arrays to be written.

    for( i = 0; i < cprops; i++ )
    {
        // Point the propspecs at the caller-provided names

        prgpropspec[i].ulKind = PRSPEC_LPWSTR;
        prgpropspec[i].lpwstr = const_cast<LPOLESTR>(rgoszPropNames[i]);

        // Make a copy of the input PropVariant array, converting VT_UNKNOWN and
        // VT_DISPATCH into VT_EMPTY.  We'll handle these after the initial write.

        rgpropvarCopy[i] = rgpropvar[i];
        if( PropertyRequiresConversion( rgpropvarCopy[i].vt ))
        {
            if( NULL == rgpropvarCopy[i].punkVal )
            {
                hr = E_INVALIDARG;
                goto Exit;
            }

            // We'll handle this particular property after the initial WriteMultiple.
            fInterfaces = TRUE;
            PropVariantInit( &rgpropvarCopy[i] );
        }
    }

    //  --------------------
    //  Write the properties
    //  --------------------

    // Write all the properties, though the VT_UNKNOWN and VT_DISPATCH have been
    // switched to VT_EMPTY.

    hr = _ppropstg->WriteMultiple(cprops, prgpropspec, rgpropvarCopy, PID_FIRST_USABLE );
    if( FAILED(hr) ) goto Exit;

    // Now write the VT_UNKNOWN and VT_DISPATCH properties individually, converting
    // first to VT_STREAMED_OBJECT or VT_STORED_OBJECT.

    if( fInterfaces )
    {
        hr = WriteObjects( cprops, prgpropspec, rgpropvar );
        if( FAILED(hr) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    // We don't need to delete the lpwstr fields, they just point to the caller-provided
    // names.
    if( NULL != prgpropspec )
        CoTaskMemFree( prgpropspec );

    // We don't need to clear rgpropvarCopy; it wasn't a deep copy.

    _pBlockingLock->Unlock();
    return( hr );

}   // CPropertyBagEx::WriteMultiple



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::WriteObjects
//
//  This method writes VT_UNKNOWN and VT_DISPATCH properties.  It scans the
//  input rgpropvar array for such properties.  For each that it finds, it QIs
//  for IPersistStorage or IPersistStream (in that order), creates a 
//  VT_STORED_OBJECT/VT_STREAMED_OBJECT property (respectively), and persists the object
//  to that property.
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::WriteObjects( IN ULONG cprops,
                              IN const PROPSPEC rgpropspec[],
                              IN const PROPVARIANT rgpropvar[] )
{
    HRESULT hr = S_OK;
    ULONG i;

    propITrace( "CPropertyBagEx::WriteObjects" );

    for( i = 0; i < cprops; i++ )
    {
        // Is this a type we need to handle?

        if( PropertyRequiresConversion( rgpropvar[i].vt ))
        {
            hr = WriteOneObject( &rgpropspec[i], &rgpropvar[i] );
            if( FAILED(hr) ) goto Exit;
        }
    }

    hr = S_OK;

Exit:

    return( hr );

}   // CPropertyBagEx::WriteObjects



//+----------------------------------------------------------------------------
//
//
//
//+----------------------------------------------------------------------------

HRESULT
CPropertyBagEx::WriteOneObject( const IN PROPSPEC *ppropspec, const IN PROPVARIANT *ppropvar )
{
    HRESULT hr = S_OK;
    PROPVARIANT propvarNew;
    IPersistStorage *pPersistStg = NULL;
    IPersistStream *pPersistStm = NULL;
    IUnknown *punk = NULL;

    PropVariantInit( &propvarNew );

    DfpAssert( PropertyRequiresConversion( ppropvar->vt ));

    DfpAssert( reinterpret_cast<const void*const*>(&ppropvar->punkVal)
               ==
               reinterpret_cast<const void*const*>(&ppropvar->pdispVal)
               &&
               reinterpret_cast<const void*const*>(&ppropvar->pdispVal)
               ==
               reinterpret_cast<const void*const*>(&ppropvar->ppdispVal)
               &&
               reinterpret_cast<const void*const*>(&ppropvar->ppdispVal)
               ==
               reinterpret_cast<const void*const*>(&ppropvar->ppunkVal) );

    //  --------------------
    //  Look for an IPersist
    //  --------------------

    // Get the IUnknown pointer (good for both VT_UNKNOWN and VT_DISPATCH).

    if( VT_BYREF & ppropvar->vt )
        punk = *ppropvar->ppunkVal;
    else
        punk = ppropvar->punkVal;

    DfpAssert( NULL != punk );

    // QI for IPersistStorage, then IPersistStream.  If we find one or the other,
    // set up propvarNew in preparation for a write.

    hr = punk->QueryInterface( IID_IPersistStorage, reinterpret_cast<void**>(&pPersistStg) );
    if( SUCCEEDED(hr) )
    {
        propvarNew.vt = VT_STORED_OBJECT;
    }
    else if( E_NOINTERFACE == hr )
    {
        hr = punk->QueryInterface( IID_IPersistStream, reinterpret_cast<void**>(&pPersistStm) );
        if( SUCCEEDED(hr) )
            propvarNew.vt = VT_STREAMED_OBJECT;
    }
    if( FAILED(hr) )
    {
        propDbg(( DEB_WARN, "Couldn't find an IPersist interface in IPropertyBagEx::WriteMultiple" ));
        goto Exit;
    }

    //  ----------------------------------
    //  Create the stream/storage property
    //  ----------------------------------

    // Write this empty VT_STREAMED/STORED_OBJECT (has a NULL pstm/pstg value).  This will cause the
    // property set to create a new stream/storage.

    hr = _ppropstg->WriteMultiple( 1, ppropspec, &propvarNew, PID_FIRST_USABLE );
    if( FAILED(hr) )
    {
        propDbg(( DEB_ERROR, "Couldn't write %d for interface in IPropertyBagEx", propvarNew.vt ));
        goto Exit;
    }

    // Get an interface pointer for that new stream/storage.

    hr = _ppropstg->ReadMultiple( 1, ppropspec, &propvarNew );
    if( FAILED(hr) || S_FALSE == hr )
    {
        propDbg(( DEB_ERROR, "Couldn't read stream/storage back for interface in IPropertyBagEx::WriteMultiple" ));
        if( !FAILED(hr) )
            hr = STG_E_WRITEFAULT;
        goto Exit;
    }

    //  --------------------
    //  Persist the property
    //  --------------------

    if( NULL != pPersistStg )
    {
        CLSID clsid;

        DfpAssert( VT_STORED_OBJECT == propvarNew.vt );

        // Set the clsid

        hr = pPersistStg->GetClassID( &clsid );
        if( E_NOTIMPL == hr )
            clsid = CLSID_NULL;
        else if( FAILED(hr) )
            goto Exit;

        hr = propvarNew.pStorage->SetClass( clsid );
        if( FAILED(hr) ) goto Exit;

        // Persist to VT_STORED_OBJECT

        hr = pPersistStg->Save( propvarNew.pStorage, FALSE /* Not necessarily same as load */ );
        if( FAILED(hr) ) goto Exit;

        hr = pPersistStg->SaveCompleted( propvarNew.pStorage );
        if( FAILED(hr) ) goto Exit;
    }
    else
    {
        CLSID clsid;
        ULONG cbWritten;

        DfpAssert( VT_STREAMED_OBJECT == propvarNew.vt );
        DfpAssert( NULL != pPersistStm );

#if 1 == DBG
        // This stream should be at its start.
        {
            CULargeInteger culi;
            hr = propvarNew.pStream->Seek( CLargeInteger(0), STREAM_SEEK_CUR, &culi );
            if( FAILED(hr) ) goto Exit;

            DfpAssert( CULargeInteger(0) == culi );
        }
#endif // #if 1 == DBG


        // Write the clsid

        DfpAssert( NULL != pPersistStm );
        hr = pPersistStm->GetClassID( &clsid );
        if( E_NOTIMPL == hr )
            clsid = CLSID_NULL;
        else if( FAILED(hr) )
            goto Exit;

        hr = propvarNew.pStream->Write( &clsid, sizeof(clsid), &cbWritten );
        if( FAILED(hr) || sizeof(clsid) != cbWritten )
            goto Exit;

        // Persist to VT_STREAMED_OBJECT

        IFDBG( ULONG cRefs = GetRefCount( propvarNew.pStream ));
        hr = pPersistStm->Save( propvarNew.pStream, TRUE /* Clear dirty flag */ );
        if( FAILED(hr) ) goto Exit;
        DfpAssert( GetRefCount( propvarNew.pStream ) == cRefs );
    }


Exit:

    RELEASE_INTERFACE(pPersistStg);
    RELEASE_INTERFACE(pPersistStm);

    PropVariantClear( &propvarNew );

    return( hr );

}   // CPropertyBagEx::WriteOneObject


//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::DeleteMultiple (IPropertyBagEx)
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::DeleteMultiple( /*[in]*/ ULONG cprops,
	                        /*[in]*/ LPCOLESTR const rgoszPropNames[],
                                /*[in]*/ DWORD dwReserved )
{
    HRESULT hr = S_OK;
    IEnumSTATPROPBAG *penum = NULL;
    STATPROPBAG statpropbag = { NULL };
    PROPSPEC *prgpropspec = NULL;
    ULONG i;

    //  --------------
    //  Initialization
    //  --------------

    propXTrace( "CPropertyBagEx::DeleteMultiple" );

    _pBlockingLock->Lock( INFINITE );

    // Validate the input

    if (S_OK != (hr = ValidateInRGLPOLESTR( cprops, rgoszPropNames )))
        goto Exit;

    if( 0 != dwReserved )
    {
        hr = STG_E_INVALIDPARAMETER;
        goto Exit;
    }

    propTraceParameters(( "%d, 0x%x", cprops, rgoszPropNames ));

    // If it's not already open, open the property storage now.  If it doesn't exist,
    // then our mission is accomplished; the properties don't exist.

    hr = OpenPropStg( FILE_OPEN_IF ); // Open only if it already exists
    if( STG_E_FILENOTFOUND == hr )
    {
        hr = S_OK;
        goto Exit;
    }
    else if( FAILED(hr) )
        goto Exit;

    // Create an array of PROPSPECs, and load with the caller-provided
    // names.

    prgpropspec = reinterpret_cast<PROPSPEC*>
                  ( CoTaskMemAlloc( cprops * sizeof(PROPSPEC) ));
    if( NULL == prgpropspec )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for( i = 0; i < cprops; i++ )
    {
        prgpropspec[i].ulKind = PRSPEC_LPWSTR;
        prgpropspec[i].lpwstr = const_cast<LPOLESTR>(rgoszPropNames[i]);
    }

    //  ---------------------
    //  Delete the properties
    //  ---------------------

    hr = _ppropstg->DeleteMultiple( cprops, prgpropspec );
    if( FAILED(hr) ) goto Exit;


    //  ----
    //  Exit
    //  ----

    hr = S_OK;

Exit:

    CoTaskMemFree( prgpropspec );

    _pBlockingLock->Unlock();

    return( hr );

}   // CPropertyBagEx::DeleteMultiple



//+----------------------------------------------------------------------------
//
//  Method: CPropertyBagEx::Open (IPropertyBagEx)
//
//  This method reads a VT_VERSIONED_STREAM from the underlying property set,
//  and returns the IStream pointer in *ppUnk.  If the property doesn't already
//  exist, and guidPropertyType is not GUID_NULL, then an empty property is
//  created first.  An empty property can also be created over an existing
//  one by specifying OPENPROPERTY_OVERWRITE.
//
//+----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CPropertyBagEx::Open(
        /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
        /* [in] */ LPCOLESTR pwszPropName,
        /* [in] */ GUID guidPropertyType,
        /* [in] */ DWORD dwFlags,
        /* [in] */ REFIID riid,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk)
{

    HRESULT hr = S_OK;

    PROPVARIANT propvar;
    IUnknown *pUnk = NULL;
    DBGBUF(buf1);
    DBGBUF(buf2);

    //  --------------
    //  Initialization
    //  --------------

    propXTrace( "CPropertyBagEx::Open" );

    PropVariantInit( &propvar );

    _pBlockingLock->Lock( INFINITE );

    // Validation

    GEN_VDATEPTRIN_LABEL( pUnkOuter, IUnknown*, E_INVALIDARG, Exit, hr );
    if (S_OK != (hr = ValidateInRGLPOLESTR( 1, &pwszPropName )))
        goto Exit;
    GEN_VDATEREADPTRIN_LABEL( &riid, IID*, E_INVALIDARG, Exit, hr );

    propTraceParameters(( "0x%x, %ws, %s, 0x%x, %s",
                          pUnkOuter, pwszPropName, DbgFmtId(guidPropertyType,buf1),dwFlags, DbgFmtId(riid,buf2) ));


    // Initialize out-parms
    *ppUnk = NULL;


    // We don't support aggregation
    if( NULL != pUnkOuter )
    {
        propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Open doesn't support pUnkOuter\n", this ));
        hr = E_NOTIMPL;
        goto Exit;
    }

    // Check for unsupported flags
    if( 0 != (~OPENPROPERTY_OVERWRITE & dwFlags) )
    {
        propDbg(( DEB_ERROR, "CPropertyBagEx(0x%x)::Open, invalid dwFlags (0x%x)\n", this, dwFlags ));
        hr = E_NOTIMPL;
        goto Exit;
    }

    // We don't support anything but IID_IStream
    if( IID_IStream != riid )
    {
        hr = E_NOTIMPL;
        goto Exit;
    }

    //  -----------------
    //  Read the property
    //  -----------------

    // Attempt to read the property
    hr = ReadMultiple( 1, &pwszPropName, &propvar, NULL );

    // If the property doesn't exist but we were given a valid guid, create a new one.
    if( S_FALSE == hr && GUID_NULL != guidPropertyType )
    {
        VERSIONEDSTREAM VersionedStream;
        PROPVARIANT propvarCreate;

        // Write a new property speicifying NULL for the stream

        VersionedStream.guidVersion = guidPropertyType;
        VersionedStream.pStream = NULL;
        propvarCreate.vt = VT_VERSIONED_STREAM;
        propvarCreate.pVersionedStream = &VersionedStream;

        hr = WriteMultiple( 1, &pwszPropName, &propvarCreate );
        if( FAILED(hr) ) goto Exit;

        // Read the property back, getting an IStream*
        hr = ReadMultiple( 1, &pwszPropName, &propvar, NULL );
    }
    if( FAILED(hr) ) goto Exit;

    // Is the type or guidPropertyType wr