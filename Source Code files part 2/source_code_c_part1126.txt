etEvent(hEvent);
    CloseHandle(hEvent);

    //
    // There should always be one device as that is the device who's removal
    // was vetoed.
    //
    ASSERT(removalVetoCollection.dc.NumDevices);

    //
    // Invent the VetoedOperation "VETOED_UNDOCK" from an eject containing
    // another dock.
    //
    if (removalVetoCollection.dc.DockInList) {

        if (VetoedOperation == VETOED_EJECT) {

            VetoedOperation = VETOED_UNDOCK;

        } else if (VetoedOperation == VETOED_WARM_EJECT) {

            VetoedOperation = VETOED_WARM_UNDOCK;
        }
    }

    removalVetoCollection.VetoType = vetoType;
    removalVetoCollection.VetoedOperation = VetoedOperation;

    VetoedRemovalUI(&removalVetoCollection);

    DeviceCollectionDestroy(
        (PDEVICE_COLLECTION) &removalVetoCollection
        );

    return 1;
}

DWORD
WINAPI
HotPlugSafeRemovalNotificationW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hPipeRead, hEvent;
    DEVICE_COLLECTION safeRemovalCollection;
    MSG Msg;
    WNDCLASS wndClass;
    HWND hSafeRemovalWnd;
    HANDLE hHotplugIconEvent;

    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {

        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // Read out the device ID list from the Pipe
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_SAFE_REMOVAL_NOTIFICATION,
        &safeRemovalCollection
        );

    //
    // On success or error, we are finished reading from the pipe, so close the
    // handle and tell umpnpmgr it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // If we have any devices then bring up the safe removal dialog
    //
    if (safeRemovalCollection.NumDevices) {

        if (!GetClassInfo(hHotPlug, HOTPLUG_CLASS_NAME, &wndClass)) {

            memset(&wndClass, 0, sizeof(wndClass));
            wndClass.lpfnWndProc = (safeRemovalCollection.DockInList)
                                     ? DockSafeRemovalBalloonProc
                                     : SafeRemovalBalloonProc;
            wndClass.hInstance = hHotPlug;
            wndClass.lpszClassName = HOTPLUG_CLASS_NAME;

            if (!RegisterClass(&wndClass)) {
                goto clean0;
            }
        }

        //
        // In order to prevent multiple similar icons on the tray, we will
        // create a named event that will be used to serialize the UI.
        //
        // Note that if we can't create the event for some reason then we will just
        // display the UI.  This might cause multiple icons, but it is better
        // than not displaying any UI at all.
        //
        hHotplugIconEvent = CreateEvent(NULL,
                                         FALSE,
                                         TRUE,
                                         safeRemovalCollection.DockInList
                                           ? TEXT("Local\\Dock_TaskBarIcon_Event")
                                           : TEXT("Local\\HotPlug_TaskBarIcon_Event")
                                         );

        if (hHotplugIconEvent) {

            WaitForSingleObject(hHotplugIconEvent, INFINITE);
        }

        if (!safeRemovalCollection.DockInList) {
            //
            // First disable the hotplug service so that the icon will go away from
            // the taskbar.  We do this just in case there are any other hotplug devices
            // in the machine since we don't want multiple hotplug icons
            // showing up in the taskbar.
            //
            // NOTE: We don't need to do this for the safe to undock case since
            // the docking icon is different.
            //
            SysTray_EnableService(STSERVICE_HOTPLUG, FALSE);
        }

        hSafeRemovalWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                                          HOTPLUG_CLASS_NAME,
                                          TEXT(""),
                                          WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                          CW_USEDEFAULT,
                                          CW_USEDEFAULT,
                                          0,
                                          0,
                                          NULL,
                                          NULL,
                                          hHotPlug,
                                          (LPVOID)&safeRemovalCollection
                                          );

        if (hSafeRemovalWnd != NULL) {

            while (IsWindow(hSafeRemovalWnd)) {

                if (GetMessage(&Msg, NULL, 0, 0)) {

                    TranslateMessage(&Msg);
                    DispatchMessage(&Msg);
                }
            }
        }

        //
        // Set the Event so the next surprise removal process can go to work
        // and then close the event handle.
        //
        if (hHotplugIconEvent) {

            SetEvent(hHotplugIconEvent);
            CloseHandle(hHotplugIconEvent);
        }

        if (!safeRemovalCollection.DockInList) {
            //
            // Re-enable the hotplug service so that the icon can show back up in
            // the taskbar if we have any hotplug devices.
            //
            SysTray_EnableService(STSERVICE_HOTPLUG, TRUE);
        }
    }

clean0:

    DeviceCollectionDestroy(&safeRemovalCollection);
    return 1;
}

DWORD
WINAPI
HotPlugDriverBlockedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hPipeRead, hEvent;
    DEVICE_COLLECTION blockedDriverCollection;
    HANDLE hHotplugIconEvent = NULL;

    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {

        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // Read out the list of blocked driver GUIDs from the Pipe.  Note that for
    // the CT_BLOCKED_DRIVER_NOTIFICATION collection type, we use only the
    // DeviceInstanceId field of each collection entry (which is OK because
    // MAX_GUID_STRING_LEN << MAX_DEVICE_ID_LEN).  All other fields are skipped.
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_BLOCKED_DRIVER_NOTIFICATION,
        &blockedDriverCollection
        );

    //
    // On success or error, we are finished reading from the pipe, so close the
    // handle and tell umpnpmgr it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // In order to prevent multipe driver blocked icons and ballons showing up
    // on the taskbar together and stepping on each other, we will create a
    // named event that will be used to serialize the hotplug icons and balloon
    // UI.
    //
    // Note that if we can't create the event for some reason then we will just
    // display the UI.  This might cause multiple driver blocked icons, but it
    // is better than not displaying any UI at all.
    //
    // Also note that we can coexist with normal hotplug icon. As such we have
    // a different event name and a different icon.
    //
    hHotplugIconEvent = CreateEvent(NULL,
                                    FALSE,
                                    TRUE,
                                    TEXT("Local\\HotPlug_DriverBlockedIcon_Event")
                                    );

    if (hHotplugIconEvent) {
        WaitForSingleObject(hHotplugIconEvent, INFINITE);
    }

    //
    // Show the balloon.
    //
    DisplayDriverBlockBalloon(&blockedDriverCollection);

    //
    // Set the Event so the next blocked driver process can go to work and then
    // close the event handle.
    //
    if (hHotplugIconEvent) {
        SetEvent(hHotplugIconEvent);
        CloseHandle(hHotplugIconEvent);
    }

    //
    // Destroy the collection.
    //
    DeviceCollectionDestroy(&blockedDriverCollection);

    return 1;
}

LONG
CPlApplet(
    HWND  hWnd,
    WORD  uMsg,
    DWORD_PTR lParam1,
    LRESULT  lParam2
    )
{
    LPNEWCPLINFO lpCPlInfo;
    LPCPLINFO lpOldCPlInfo;


    switch (uMsg) {
       case CPL_INIT:
           return TRUE;

       case CPL_GETCOUNT:
           return 1;

       case CPL_INQUIRE:
           lpOldCPlInfo = (LPCPLINFO)(LPARAM)lParam2;
           lpOldCPlInfo->lData = 0L;
           lpOldCPlInfo->idIcon = IDI_HOTPLUGICON;
           lpOldCPlInfo->idName = IDS_HOTPLUGNAME;
           lpOldCPlInfo->idInfo = IDS_HOTPLUGINFO;
           return TRUE;

       case CPL_NEWINQUIRE:
           lpCPlInfo = (LPNEWCPLINFO)(LPARAM)lParam2;
           lpCPlInfo->hIcon = LoadIcon(hHotPlug, MAKEINTRESOURCE(IDI_HOTPLUGICON));
           LoadString(hHotPlug, IDS_HOTPLUGNAME, lpCPlInfo->szName, sizeof(lpCPlInfo->szName));
           LoadString(hHotPlug, IDS_HOTPLUGINFO, lpCPlInfo->szInfo, sizeof(lpCPlInfo->szInfo));
           lpCPlInfo->dwHelpContext = IDH_HOTPLUGAPPLET;
           lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
           lpCPlInfo->lData = 0;
           lpCPlInfo->szHelpFile[0] = '\0';
           return TRUE;

       case CPL_DBLCLK:
           HotPlugDeviceTree(hWnd, NULL, TRUE);
           break;

       case CPL_STARTWPARMS:
           //
           // what does this mean ?
           //

           break;

       case CPL_EXIT:


           // Free up any allocations of resources made.

           break;

       default:
           break;
       }

    return 0L;
}

#if BUBBLES
VOID
OpenGetSurpriseUndockObjects(
    OUT HANDLE  *SurpriseUndockTimer,
    OUT HANDLE  *SurpriseUndockEvent
    )
{
    LARGE_INTEGER liDelayTime;
    HANDLE hSurpriseUndockEventTimer;
    HANDLE hSurpriseUndockEvent;

    hSurpriseUndockEventTimer = CreateWaitableTimer(
        NULL,
        TRUE,
        SURPRISE_UNDOCK_TIMER
        );

    if ((hSurpriseUndockEventTimer != NULL) &&
        (GetLastError() == ERROR_SUCCESS)) {

        //
        // We created it (if not the status would be ERROR_ALREADY_EXISTS).
        // Ensure it starts life signalled.
        //
        liDelayTime.QuadPart = 0;

        SetWaitableTimer(
            hSurpriseUndockEventTimer,
            &liDelayTime,
            0,
            NULL,
            NULL,
            FALSE
            );
    }

    hSurpriseUndockEvent = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        SURPRISE_UNDOCK_EVENT
        );

    *SurpriseUndockTimer = hSurpriseUndockEventTimer;
    *SurpriseUndockEvent = hSurpriseUndockEvent;
}
#endif // BUBBLES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\notify.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       notify.c
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

void
OnTimerDeviceChange(
    PDEVICETREE DeviceTree
    )
{
    //
    // if a refresh event is pending, rebuild the entire tree.
    //

    if (DeviceTree->RefreshEvent) {
        
        if (RefreshTree(DeviceTree)) {
            
            DeviceTree->RefreshEvent = FALSE;
        }
    }
}

BOOL
RefreshTree(
    PDEVICETREE DeviceTree
    )
{
    CONFIGRET ConfigRet;
    DEVINST DeviceInstance;
    DEVINST SelectedDevInst;
    PDEVTREENODE DevTreeNode;
    HTREEITEM hTreeItem;
    HCURSOR hCursor;

    if (DeviceTree->RedrawWait) {
        
        DeviceTree->RefreshEvent = TRUE;
        SetTimer(DeviceTree->hDlg, TIMERID_DEVICECHANGE,1000,NULL);
        return FALSE;
    }


    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    DeviceTree->RedrawWait = TRUE;
    SendMessage(DeviceTree->hwndTree, WM_SETREDRAW, FALSE, 0L);

    SelectedDevInst = DeviceTree->SelectedTreeNode
                          ? DeviceTree->SelectedTreeNode->DevInst
                          : 0;


    ClearRemovalList(DeviceTree);
    TreeView_DeleteAllItems(DeviceTree->hwndTree);
    RemoveChildSiblings(DeviceTree, &DeviceTree->ChildSiblingList);

    ConfigRet = CM_Get_Child_Ex(&DeviceInstance,
                                DeviceTree->DevInst,
                                0,
                                DeviceTree->hMachine
                                );

    if (ConfigRet == CR_SUCCESS) {

        AddChildSiblings(DeviceTree,
                         NULL,
                         DeviceInstance,
                         0,
                         TRUE
                         );
    }


    DisplayChildSiblings(DeviceTree,
                         &DeviceTree->ChildSiblingList,
                         NULL,
                         FALSE
                         );

    //
    // restore treeview redraw state, and reset the selected item
    //

    DevTreeNode = DevTreeNodeByDevInst(SelectedDevInst,
                                       &DeviceTree->ChildSiblingList
                                       );

    if (DevTreeNode) {
        
        hTreeItem = DevTreeNode->hTreeItem;
    }

    else {
        
        hTreeItem = NULL;
    }

    if (!hTreeItem) {
        
        hTreeItem = TreeView_GetRoot(DeviceTree->hwndTree);
    }

    SendMessage(DeviceTree->hwndTree, WM_SETREDRAW, TRUE, 0L);
    DeviceTree->RedrawWait = FALSE;

    TreeView_SelectItem(DeviceTree->hwndTree, NULL);

    if (hTreeItem) {
    
        TreeView_SelectItem(DeviceTree->hwndTree, hTreeItem);
    } else {
        
        //
        // No device is selected
        //
        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);
        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), FALSE);
        SetDlgItemText(DeviceTree->hDlg, IDC_DEVICEDESC, TEXT(""));
    }

    SetCursor(hCursor);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\rconfirm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rconfirm.c
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

#define NOTIFYICONDATA_SZINFO       256
#define NOTIFYICONDATA_SZINFOTITLE  64

#define WM_NOTIFY_MESSAGE   (WM_USER + 100)

extern HMODULE hHotPlug;

DWORD
WaitDlgMessagePump(
    HWND hDlg,
    DWORD nCount,
    LPHANDLE Handles
    )
{
    DWORD WaitReturn;
    MSG Msg;

    while ((WaitReturn = MsgWaitForMultipleObjects(nCount,
                                                   Handles,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLINPUT
                                                   ))
           == nCount)
    {
        while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {

            if (!IsDialogMessage(hDlg,&Msg)) {
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }
        }
    }

    return WaitReturn;
}

int
InsertDeviceNodeListView(
    HWND hwndList,
    PDEVICETREE DeviceTree,
    PDEVTREENODE  DeviceTreeNode,
    INT lvIndex
    )
{
    LV_ITEM lviItem;
    TCHAR Buffer[MAX_PATH];

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = lvIndex;
    lviItem.iSubItem = 0;

    if (SetupDiGetClassImageIndex(&DeviceTree->ClassImageList,
                                   &DeviceTreeNode->ClassGuid,
                                   &lviItem.iImage
                                   ))
    {
        lviItem.mask |= LVIF_IMAGE;
    }

    lviItem.pszText = FetchDeviceName(DeviceTreeNode);

    if (!lviItem.pszText) {

        lviItem.pszText = Buffer;
        wsprintf(Buffer,
                 TEXT("%s %s"),
                 szUnknown,
                 DeviceTreeNode->Location  ? DeviceTreeNode->Location : TEXT("")
                 );
    }

    lviItem.lParam = (LPARAM) DeviceTreeNode;

    return ListView_InsertItem(hwndList, &lviItem);
}

DWORD
RemoveThread(
   PVOID pvDeviceTree
   )
{
    PDEVICETREE DeviceTree = (PDEVICETREE)pvDeviceTree;
    PDEVTREENODE  DeviceTreeNode;

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    return(CM_Request_Device_Eject_Ex(DeviceTreeNode->DevInst,
                                           NULL,
                                           NULL,
                                           0,
                                           0,
                                           DeviceTree->hMachine
                                           ));
}

BOOL
OnOkRemove(
    HWND hDlg,
    PDEVICETREE DeviceTree
    )
{
    HCURSOR hCursor;
    PDEVTREENODE DeviceTreeNode;
    HANDLE hThread;
    DWORD ThreadId;
    DWORD WaitReturn;
    PTCHAR DeviceName;
    TCHAR szReply[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    BOOL bSuccess;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    DeviceTreeNode = DeviceTree->ChildRemovalList;
    DeviceTree->RedrawWait = TRUE;


    hThread = CreateThread(NULL,
                           0,
                           RemoveThread,
                           DeviceTree,
                           0,
                           &ThreadId
                           );
    if (!hThread) {

        return FALSE;
    }

    //
    // disable the ok\cancel buttons
    //
    EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);

    WaitReturn = WaitDlgMessagePump(hDlg, 1, &hThread);

    bSuccess =
        (WaitReturn == 0 &&
         GetExitCodeThread(hThread, &WaitReturn) &&
         WaitReturn == CR_SUCCESS );

    SetCursor(hCursor);
    DeviceTree->RedrawWait = FALSE;
    CloseHandle(hThread);

    return bSuccess;
}

#define idh_hwwizard_confirm_stop_list  15321   // "" (SysListView32)

DWORD RemoveConfirmHelpIDs[] = {
    IDC_REMOVELIST,    idh_hwwizard_confirm_stop_list,
    IDC_NOHELP1,       NO_HELP,
    IDC_NOHELP2,       NO_HELP,
    IDC_NOHELP3,       NO_HELP,
    0,0
    };


BOOL
InitRemoveConfirmDlgProc(
    HWND hDlg,
    PDEVICETREE DeviceTree
    )
{
    HWND hwndList;
    PDEVTREENODE DeviceTreeNode;
    int lvIndex;
    LV_COLUMN lvcCol;
    PDEVTREENODE Next;
    HICON hIcon;


    hIcon = LoadIcon(hHotPlug,MAKEINTRESOURCE(IDI_HOTPLUGICON));

    if (hIcon) {

        SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    if (!DeviceTreeNode) {

        return FALSE;
    }

    DeviceTree->hwndRemove = hDlg;

    hwndList = GetDlgItem(hDlg, IDC_REMOVELIST);

    ListView_SetImageList(hwndList, DeviceTree->ClassImageList.ImageList, LVSIL_SMALL);
    ListView_DeleteAllItems(hwndList);

    // Insert a column for the class list
    lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcCol.fmt = LVCFMT_LEFT;
    lvcCol.iSubItem = 0;
    ListView_InsertColumn(hwndList, 0, (LV_COLUMN FAR *)&lvcCol);

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);

    //
    // Walk the removal list and add each of them to the listbox.
    //
    lvIndex = 0;

    do {

        InsertDeviceNodeListView(hwndList, DeviceTree, DeviceTreeNode, lvIndex++);
        DeviceTreeNode = DeviceTreeNode->NextChildRemoval;

    } while (DeviceTreeNode != DeviceTree->ChildRemovalList);


    ListView_SetItemState(hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
    ListView_EnsureVisible(hwndList, 0, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

    return TRUE;
}

LRESULT CALLBACK
RemoveConfirmDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )
/*++

Routine Description:

   DialogProc to confirm user really wants to remove the devices.

Arguments:

   standard stuff.



Return Value:

   LRESULT

--*/

{
    PDEVICETREE DeviceTree=NULL;
    BOOL Status = TRUE;

    if (message == WM_INITDIALOG) {

        DeviceTree = (PDEVICETREE)lParam;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)DeviceTree);

        if (DeviceTree) {

            if (DeviceTree->HideUI) {

                PostMessage(hDlg, WUM_EJECTDEVINST, 0, 0);

            } else {

                InitRemoveConfirmDlgProc(hDlg, DeviceTree);
            }
        }

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    DeviceTree = (PDEVICETREE)GetWindowLongPtr(hDlg, DWLP_USER);


    switch (message) {

    case WM_DESTROY:

        DeviceTree->hwndRemove = NULL;
        break;


    case WM_CLOSE:
        SendMessage (hDlg, WM_COMMAND, IDCANCEL, 0L);
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            EndDialog(hDlg, OnOkRemove(hDlg, DeviceTree) ? IDOK : IDCANCEL);
            break;

        case IDCLOSE:
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;
        }
        break;

    case WUM_EJECTDEVINST:
        EndDialog(hDlg, OnOkRemove(hDlg, DeviceTree) ? IDOK : IDCANCEL);
        break;

    case WM_SYSCOLORCHANGE:
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam,
                TEXT("hardware.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)(PDWORD)RemoveConfirmHelpIDs
                );

        return FALSE;

    case WM_HELP:
        OnContextHelp((LPHELPINFO)lParam, RemoveConfirmHelpIDs);
        break;

    case WM_SETCURSOR:
        if (DeviceTree->RedrawWait || DeviceTree->RefreshEvent) {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
            }

         break;

    default:
        return FALSE;

    }


    return TRUE;
}

#if UNDOCK_WARNING

#define idh_hwwizard_unsafe_remove_list 15330  // "" (SysListView32)

DWORD SurpriseWarnHelpIDs[] = {
    IDC_REMOVELIST,     idh_hwwizard_unsafe_remove_list,
    IDC_NOHELP1,        NO_HELP,
    IDC_NOHELP2,        NO_HELP,
    IDC_NOHELP3,        NO_HELP,
    IDC_NOHELP4,        NO_HELP,
    IDC_NOHELP5,        NO_HELP,
    IDC_STATIC,         NO_HELP,
    0,0
    };

BOOL
InitSurpriseWarnDlgProc(
    IN  HWND                        hDlg,
    IN  PSURPRISE_WARN_COLLECTION   SurpriseWarnCollection
    )
{
    HWND hwndList;
    HICON hIcon;

    hIcon = LoadIcon(hHotPlug,MAKEINTRESOURCE(IDI_HOTPLUGICON));

    if (hIcon) {

        SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    hwndList = GetDlgItem(hDlg, IDC_REMOVELIST);
    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndList);

    DeviceCollectionPopulateListView(
        (PDEVICE_COLLECTION) SurpriseWarnCollection,
        hwndList
        );

    ListView_SetItemState(hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    ListView_EnsureVisible(hwndList, 0, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

    return TRUE;
}

BOOL
InitSurpriseUndockDlgProc(
    IN  HWND                        hDlg,
    IN  PSURPRISE_WARN_COLLECTION   SurpriseWarnCollection
    )
{
    HICON hIcon;
    TCHAR szFormat[512];
    TCHAR szMessage[MAX_DEVICE_ID_LEN + 200];
    ULONG dockDeviceIndex;

    hIcon = LoadIcon(hHotPlug,MAKEINTRESOURCE(IDI_UNDOCKICON));

    if (hIcon) {

        SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    LoadString(hHotPlug, IDS_UNSAFE_UNDOCK, szFormat, SIZECHARS(szFormat));

    if (!DeviceCollectionGetDockDeviceIndex(
        (PDEVICE_COLLECTION) SurpriseWarnCollection,
        &dockDeviceIndex
        )) {

        return FALSE;
    }

    if (!DeviceCollectionFormatDeviceText(
        (PDEVICE_COLLECTION) SurpriseWarnCollection,
        dockDeviceIndex,
        szFormat,
        SIZECHARS(szMessage),
        szMessage
        )) {

        return FALSE;
    }

    SetDlgItemText(hDlg, IDC_UNDOCK_MESSAGE, szMessage);

    return TRUE;
}

LRESULT CALLBACK
SurpriseWarnDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )
/*++

Routine Description:

   DialogProc to confirm user really wants to remove the devices.

Arguments:

   standard stuff.



Return Value:

   LRESULT

--*/

{
    PSURPRISE_WARN_COLLECTION surpriseWarnCollection = NULL;
    BOOL status = TRUE;

    if (message == WM_INITDIALOG) {

        surpriseWarnCollection = (PSURPRISE_WARN_COLLECTION) lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        status = (surpriseWarnCollection->DockInList) ?
            InitSurpriseUndockDlgProc(hDlg, surpriseWarnCollection) :
            InitSurpriseWarnDlgProc(hDlg, surpriseWarnCollection);

        if (!status) {

            EndDialog(hDlg, IDABORT);
        }

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    surpriseWarnCollection =
        (PSURPRISE_WARN_COLLECTION) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {

    case WM_DESTROY:
        break;


    case WM_CLOSE:
        SendMessage (hDlg, WM_COMMAND, IDCANCEL, 0L);
        break;

    case WM_COMMAND:
        switch(wParam) {

        case IDOK:
        case IDCLOSE:
            surpriseWarnCollection->SuppressSurprise =
                IsDlgButtonChecked(hDlg, IDC_SUPPRESS_SURPRISE);

        case IDCANCEL:

            EndDialog(hDlg, wParam);
            break;
        }
        break;

    case WM_SYSCOLORCHANGE:
        break;

    case WM_HELP:
        OnContextHelp((LPHELPINFO)lParam, SurpriseWarnHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam,
                TEXT("hardware.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)(PDWORD)SurpriseWarnHelpIDs
                );

        return FALSE;

    case WM_NOTIFY:
    switch (((NMHDR FAR *)lParam)->code) {
        case LVN_ITEMCHANGED: {
            break;
            }
        }


    default:
        return FALSE;

    }


    return TRUE;
}
#endif // UNDOCK_WARNING

#if BUBBLES
LRESULT
CALLBACK
SurpriseWarnBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NOTIFYICONDATA nid;
    static HICON hHotPlugIcon = NULL;
    static BOOL bDialogDisplayed = FALSE;
    PSURPRISE_WARN_COLLECTION surpriseWarnCollection;
    UINT_PTR timer;
    HANDLE hUndockTimer, hUndockEvent;
    static BOOL bCheckIfDeviceIsPresent = FALSE;

    switch (message) {

    case WM_CREATE:
        surpriseWarnCollection = (PSURPRISE_WARN_COLLECTION)((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) surpriseWarnCollection);

        //
        // Display the hotplug taskbar icon along with the surprise removal warning balloon.
        // The balloon will stay up for 60 seconds or until the user clicks on the balloon
        // or icon to display the dialog that lists the devices that were surprise removed.
        // After the user closes the dialog the balloon and taskbar icon will go away.
        //
        hHotPlugIcon = LoadIcon(hHotPlug, MAKEINTRESOURCE(IDI_HOTPLUGICON));
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;

        nid.hIcon = hHotPlugIcon;
        nid.uFlags = NIF_MESSAGE | NIF_ICON;
        nid.uCallbackMessage = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_INFO;
        nid.uTimeout = 45000;
        nid.dwInfoFlags = NIIF_ERROR;
        LoadString(hHotPlug,
                   IDS_HOTPLUG_TITLE,
                   nid.szInfoTitle,
                   SIZECHARS(nid.szInfoTitle)
                   );
        LoadString(hHotPlug,
                   IDS_HOTPLUG_REMOVE_INFO,
                   nid.szInfo,
                   SIZECHARS(nid.szInfo)
                   );
        Shell_NotifyIcon(NIM_MODIFY, &nid);

        surpriseWarnCollection->DialogTicker = 0;

        OpenGetSurpriseUndockObjects(&hUndockTimer, &hUndockEvent);
        if (hUndockTimer) {

            if (WaitForSingleObject(hUndockTimer, 0) == WAIT_TIMEOUT) {

                //
                // The "we're free" event isn't signalled. Nuke this bubble.
                //
                DestroyWindow(hWnd);
            }

            CloseHandle(hUndockTimer);
        }

        if (hUndockEvent) {

            CloseHandle(hUndockEvent);
        }

        SetTimer(hWnd, 0, 250, NULL);

        //
        // Wait for five seconds before we check to see if the user re-inserted
        // the device that we are warning them about.
        //
        SetTimer(hWnd, TIMERID_DEVICECHANGE, 5000, NULL);

        break;

    case WM_NOTIFY_MESSAGE:
        switch(lParam) {

        case NIN_BALLOONTIMEOUT:
            DestroyWindow(hWnd);
            break;

        case NIN_BALLOONUSERCLICK:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:

            if (!bDialogDisplayed) {

                surpriseWarnCollection = (PSURPRISE_WARN_COLLECTION) GetWindowLongPtr(hWnd, GWLP_USERDATA);

                //
                // Set this so we only display the dialog once!
                //
                bDialogDisplayed = TRUE;

                DialogBoxParam(hHotPlug,
                               MAKEINTRESOURCE(DLG_SURPRISEWARN),
                               NULL,
                               SurpriseWarnDlgProc,
                               (LPARAM)surpriseWarnCollection
                               );

                DestroyWindow(hWnd);
            }

            break;

        default:
            break;
        }
        break;

    case WM_TIMER:

        surpriseWarnCollection = (PSURPRISE_WARN_COLLECTION) GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (wParam == TIMERID_DEVICECHANGE) {
            KillTimer(hWnd, TIMERID_DEVICECHANGE);

            bCheckIfDeviceIsPresent = TRUE;

            //
            // If all of the devices are present in the machine, then that means
            // the user pluged in the device that they just surprise removed,
            // so make the balloon go away since the user got the message.
            //
            if (DeviceCollectionCheckIfAllPresent((PDEVICE_COLLECTION)surpriseWarnCollection)) {
                DestroyWindow(hWnd);
            }

        } else if (wParam == 0) {
            surpriseWarnCollection->DialogTicker++;

            OpenGetSurpriseUndockObjects(&hUndockTimer, &hUndockEvent);

            if (hUndockTimer) {

                if (WaitForSingleObject(hUndockTimer, 0) == WAIT_TIMEOUT) {

                    //
                    // The "we're free" event isn't signalled. Nuke this bubble.
                    //
                    DestroyWindow(hWnd);
                }

                CloseHandle(hUndockTimer);
            }

            if (hUndockEvent) {

                CloseHandle(hUndockEvent);
            }

            if (surpriseWarnCollection->DialogTicker >=
                surpriseWarnCollection->MaxWaitForDock*4) {

                //
                // We've waited long enough for this to be associated with a
                // surprise undock. Stop wasting CPU cycles polling....
                //
                KillTimer(hWnd, 0);
            }
        }
        break;

    case WM_DEVICECHANGE:
        if (DBT_DEVNODES_CHANGED == wParam && bCheckIfDeviceIsPresent) {
            SetTimer(hWnd, TIMERID_DEVICECHANGE, 1000, NULL);
        }
        break;

    case WM_DESTROY:
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hHotPlugIcon) {
            DestroyIcon(hHotPlugIcon);
        }

        surpriseWarnCollection = (PSURPRISE_WARN_COLLECTION) GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (surpriseWarnCollection->DialogTicker <
            surpriseWarnCollection->MaxWaitForDock*4) {

            KillTimer(hWnd, 0);
        }

        PostQuitMessage(0);
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}
#endif // BUBBLES

LRESULT CALLBACK
SafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NOTIFYICONDATA nid;
    static HICON hHotPlugIcon = NULL;
    TCHAR szFormat[512];
    PDEVICE_COLLECTION safeRemovalCollection;
    static BOOL bCheckIfDeviceIsRemoved = FALSE;

    switch (message) {

    case WM_CREATE:
        safeRemovalCollection = (PDEVICE_COLLECTION) ((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) safeRemovalCollection);

        hHotPlugIcon = (HICON)LoadImage(hHotPlug, 
                                        MAKEINTRESOURCE(IDI_HOTPLUGICON), 
                                        IMAGE_ICON,
                                        GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON),
                                        0
                                        );

        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;

        nid.hIcon = hHotPlugIcon;
        nid.uFlags = NIF_MESSAGE | NIF_ICON;
        nid.uCallbackMessage = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_INFO;
        nid.uTimeout = 10000;
        nid.dwInfoFlags = NIIF_INFO;

        LoadString(hHotPlug,
                   IDS_REMOVAL_COMPLETE_TITLE,
                   nid.szInfoTitle,
                   SIZECHARS(nid.szInfoTitle)
                   );

        LoadString(hHotPlug, IDS_REMOVAL_COMPLETE_TEXT, szFormat, SIZECHARS(szFormat));

        DeviceCollectionFormatDeviceText(
            safeRemovalCollection,
            0,
            szFormat,
            SIZECHARS(nid.szInfo),
            nid.szInfo
            );

        Shell_NotifyIcon(NIM_MODIFY, &nid);

        SetTimer(hWnd, TIMERID_DEVICECHANGE, 5000, NULL);

        break;

    case WM_NOTIFY_MESSAGE:
        switch(lParam) {

        case NIN_BALLOONTIMEOUT:
        case NIN_BALLOONUSERCLICK:
            DestroyWindow(hWnd);
            break;

        default:
            break;
        }
        break;

    case WM_DEVICECHANGE:
        if ((DBT_DEVNODES_CHANGED == wParam) && bCheckIfDeviceIsRemoved) {
            SetTimer(hWnd, TIMERID_DEVICECHANGE, 1000, NULL);
        }
        break;

    case WM_TIMER:
        if (wParam == TIMERID_DEVICECHANGE) {
            KillTimer(hWnd, TIMERID_DEVICECHANGE);
            bCheckIfDeviceIsRemoved = TRUE;

            safeRemovalCollection = (PDEVICE_COLLECTION) GetWindowLongPtr(hWnd, GWLP_USERDATA);

            if (DeviceCollectionCheckIfAllRemoved(safeRemovalCollection)) {
                DestroyWindow(hWnd);
            }
        }
        break;

    case WM_DESTROY:
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hHotPlugIcon) {
            DestroyIcon(hHotPlugIcon);
        }

        PostQuitMessage(0);
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}

LRESULT CALLBACK
DockSafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NOTIFYICONDATA nid;
    static HICON hHotPlugIcon = NULL;
    TCHAR szFormat[512];
    PDEVICE_COLLECTION safeRemovalCollection;
    static BOOL bCheckIfReDocked = FALSE;
    BOOL bIsDockStationPresent;

    switch (message) {

    case WM_CREATE:
        safeRemovalCollection = (PDEVICE_COLLECTION) ((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) safeRemovalCollection);
        hHotPlugIcon = (HICON)LoadImage(hHotPlug, 
                                        MAKEINTRESOURCE(IDI_UNDOCKICON), 
                                        IMAGE_ICON,
                                        GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON),
                                        0
                                        );
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;

        nid.hIcon = hHotPlugIcon;
        nid.uFlags = NIF_MESSAGE | NIF_ICON;
        nid.uCallbackMessage = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_INFO;
        nid.uTimeout = 10000;
        nid.dwInfoFlags = NIIF_INFO;

        LoadString(hHotPlug,
                   IDS_UNDOCK_COMPLETE_TITLE,
                   nid.szInfoTitle,
                   SIZECHARS(nid.szInfoTitle)
                   );

        LoadString(hHotPlug, IDS_UNDOCK_COMPLETE_TEXT, szFormat, SIZECHARS(szFormat));

        DeviceCollectionFormatDeviceText(
            safeRemovalCollection,
            0,
            szFormat,
            SIZECHARS(nid.szInfo),
            nid.szInfo
            );

        Shell_NotifyIcon(NIM_MODIFY, &nid);

        SetTimer(hWnd, TIMERID_DEVICECHANGE, 5000, NULL);

        break;

    case WM_NOTIFY_MESSAGE:
        switch(lParam) {

        case NIN_BALLOONTIMEOUT:
        case NIN_BALLOONUSERCLICK:
            DestroyWindow(hWnd);
            break;

        default:
            break;
        }
        break;

    case WM_DEVICECHANGE:
        if ((DBT_CONFIGCHANGED == wParam) && bCheckIfReDocked) {
            SetTimer(hWnd, TIMERID_DEVICECHANGE, 1000, NULL);
        }
        break;

    case WM_TIMER:
        if (wParam == TIMERID_DEVICECHANGE) {
            KillTimer(hWnd, TIMERID_DEVICECHANGE);
            bCheckIfReDocked = TRUE;

            //
            // Check if the docking station is now present, this means that the
            // user redocked the machine and that we should kill the safe to 
            // undock balloon.
            //
            bIsDockStationPresent = FALSE;
            CM_Is_Dock_Station_Present(&bIsDockStationPresent);

            if (bIsDockStationPresent) {
                DestroyWindow(hWnd);
            }
        }
        break;

    case WM_DESTROY:
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hHotPlugIcon) {
            DestroyIcon(hHotPlugIcon);
        }

        PostQuitMessage(0);
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}

BOOL
VetoedRemovalUI(
    IN  PVETO_DEVICE_COLLECTION VetoedRemovalCollection
    )
{
    HANDLE hVetoEvent = NULL;
    TCHAR szEventName[MAX_PATH];
    TCHAR szFormat[512];
    TCHAR szMessage[512];
    TCHAR szTitle[256];
    PTSTR culpritDeviceId;
    PTSTR vetoedDeviceInstancePath;
    PTCHAR pStr;
    ULONG messageBase;

    //
    // The first device in the list is the device that failed ejection.
    // The next "device" is the name of the vetoer. It may in fact not be a
    // device.
    //
    vetoedDeviceInstancePath = DeviceCollectionGetDeviceInstancePath(
        (PDEVICE_COLLECTION) VetoedRemovalCollection,
        0
        );

    culpritDeviceId = DeviceCollectionGetDeviceInstancePath(
        (PDEVICE_COLLECTION) VetoedRemovalCollection,
        1
        );

    //
    // We will now check to see if this same veto message is already being
    // displayed.  We do this by creating a named event where the name
    // contains the three elements that make a veto message unique:
    //  1) device instance id
    //  2) veto type
    //  3) veto operation
    //
    // If we find an identical veto message already being displayed then we wil
    // just go away silently. This prevents multiple identical veto messages
    // from showing up on the screen.
    //
    _snwprintf(szEventName,
               SIZECHARS(szEventName),
               TEXT("Local\\VETO-%d-%d-%s"),
               (DWORD)VetoedRemovalCollection->VetoType,
               VetoedRemovalCollection->VetoedOperation,
               culpritDeviceId
               );

    //
    // Replace all of the backslashes (except the first one for Local\)
    // with pound characters since CreateEvent does not like backslashes.
    //
    pStr = StrChr(szEventName, TEXT('\\'));

    if (pStr) {
        pStr++;
    }

    while (pStr = StrChr(pStr, TEXT('\\'))) {
        *pStr = TEXT('#');
    }

    hVetoEvent = CreateEvent(NULL,
                             FALSE,
                             TRUE,
                             szEventName
                             );

    if (hVetoEvent) {
        if (WaitForSingleObject(hVetoEvent, 0) != WAIT_OBJECT_0) {
            //
            // This means that this veto message is already being displayed
            // by another hotplug process...so just go away.
            //
            CloseHandle(hVetoEvent);
            return FALSE;
        }
    }

    //
    // Create the veto text
    //
    switch(VetoedRemovalCollection->VetoedOperation) {

        case VETOED_UNDOCK:
        case VETOED_WARM_UNDOCK:
            messageBase = IDS_DOCKVETO_BASE;
            break;

        case VETOED_STANDBY:
            messageBase = IDS_SLEEPVETO_BASE;
            break;

        case VETOED_HIBERNATE:
            messageBase = IDS_HIBERNATEVETO_BASE;
            break;

        case VETOED_REMOVAL:
        case VETOED_EJECT:
        case VETOED_WARM_EJECT:
        default:
            messageBase = IDS_VETO_BASE;
            break;
    }

    switch(VetoedRemovalCollection->VetoType) {

        case PNP_VetoWindowsApp:

            if (culpritDeviceId) {

                //
                // Tell our user the name of the offending application.
                //
                LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

                DeviceCollectionFormatDeviceText(
                    (PDEVICE_COLLECTION) VetoedRemovalCollection,
                    1,
                    szFormat,
                    SIZECHARS(szMessage),
                    szMessage
                    );

            } else {

                //
                // No application, use the "some app" message.
                //
                messageBase += (IDS_VETO_UNKNOWNWINDOWSAPP - IDS_VETO_WINDOWSAPP);

                LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szMessage, SIZECHARS(szMessage));
            }
            break;

        case PNP_VetoWindowsService:
        case PNP_VetoDriver:
        case PNP_VetoLegacyDriver:
            //
            // PNP_VetoWindowsService, PNP_VetoDriver and PNP_VetoLegacyDriver 
            // are passed through the service manager to get friendlier names.
            //

            LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

            //
            // For these veto types, entry index 1 is the vetoing service.
            //
            DeviceCollectionFormatServiceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                1,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;

        case PNP_VetoDevice:
            if ((VetoedRemovalCollection->VetoedOperation == VETOED_WARM_UNDOCK) &&
               (!lstrcmp(culpritDeviceId, vetoedDeviceInstancePath))) {

                messageBase += (IDS_DOCKVETO_WARM_EJECT - IDS_DOCKVETO_DEVICE);
            }

            //
            // Fall through.
            //

        case PNP_VetoLegacyDevice:
        case PNP_VetoPendingClose:
        case PNP_VetoOutstandingOpen:
        case PNP_VetoNonDisableable:
        case PNP_VetoIllegalDeviceRequest:
            //
            // Include the veto ID in the display output
            //
            LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                1,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;

        case PNP_VetoInsufficientRights:

            //
            // Use the device itself in the display, but only if we are not
            // in the dock case.
            //

            if ((VetoedRemovalCollection->VetoedOperation == VETOED_UNDOCK)||
                (VetoedRemovalCollection->VetoedOperation == VETOED_WARM_UNDOCK)) {

                LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szMessage, SIZECHARS(szMessage));
                break;

            }

            //
            // Fall through.
            //

        case PNP_VetoInsufficientPower:
        case PNP_VetoTypeUnknown:

            //
            // Use the device itself in the display
            //
            LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                0,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;

        default:
            ASSERT(0);
            LoadString(hHotPlug, messageBase+PNP_VetoTypeUnknown, szFormat, SIZECHARS(szFormat));

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                0,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;
    }

    switch(VetoedRemovalCollection->VetoedOperation) {

        case VETOED_EJECT:
        case VETOED_WARM_EJECT:
            LoadString(hHotPlug, IDS_VETOED_EJECT_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        case VETOED_UNDOCK:
        case VETOED_WARM_UNDOCK:
            LoadString(hHotPlug, IDS_VETOED_UNDOCK_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        case VETOED_STANDBY:
            LoadString(hHotPlug, IDS_VETOED_STANDBY_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        case VETOED_HIBERNATE:
            LoadString(hHotPlug, IDS_VETOED_HIBERNATION_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        default:
            ASSERT(0);

            //
            // Fall through, display something at least...
            //

        case VETOED_REMOVAL:
            LoadString(hHotPlug, IDS_VETOED_REMOVAL_TITLE, szFormat, SIZECHARS(szFormat));
            break;
    }

    switch(VetoedRemovalCollection->VetoedOperation) {

        case VETOED_STANDBY:
        case VETOED_HIBERNATE:

            lstrcpyn(szTitle, szFormat, (int)(min(SIZECHARS(szTitle), lstrlen(szFormat)+1)));
            break;

        case VETOED_EJECT:
        case VETOED_WARM_EJECT:
        case VETOED_UNDOCK:
        case VETOED_WARM_UNDOCK:
        case VETOED_REMOVAL:
        default:

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                0,
                szFormat,
                SIZECHARS(szTitle),
                szTitle
                );

            break;
    }

    MessageBox(NULL, szMessage, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_TOPMOST);

    if (hVetoEvent) {
        CloseHandle(hVetoEvent);
    }

    return TRUE;
}

void
DisplayDriverBlockBalloon(
    IN  PDEVICE_COLLECTION blockedDriverCollection
    )
{
    HRESULT hr;
    TCHAR szMessage[NOTIFYICONDATA_SZINFO];    // same size as NOTIFYICONDATA.szInfo
    TCHAR szFormat[NOTIFYICONDATA_SZINFO];     // same size as NOTIFYICONDATA.szInfo
    TCHAR szTitle[NOTIFYICONDATA_SZINFOTITLE]; // same size as NOTIFYICONDATA.szInfoTitle
    HICON hicon = NULL;
    HANDLE hShellReadyEvent = NULL;
    INT ShellReadyEventCount = 0;
    GUID guidDB, guidID;
    HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;
    PTSTR Buffer;
    ULONG BufferSize;

    if (!LoadString(hHotPlug, IDS_BLOCKDRIVER_TITLE, szTitle, SIZECHARS(szTitle))) {
        //
        // The machine is so low on memory that we can't even get the text strings, so
        // just exit.
        //
        return;
    }

    szMessage[0] = TEXT('\0');

    if (blockedDriverCollection->NumDevices == 1) {
        //
        // If we only have one device in the list then we will show specific 
        // information about this blocked driver as well as directly launching the
        // help for this blocked driver.
        //
        if (SdbGetStandardDatabaseGUID(SDB_DATABASE_MAIN_DRIVERS, &guidDB) &&
            DeviceCollectionGetGuid((PDEVICE_COLLECTION)blockedDriverCollection,
                                    &guidID,
                                    0)) {

            hAppHelpInfoContext = SdbOpenApphelpInformation(&guidDB, &guidID);

            Buffer = NULL;

            if ((hAppHelpInfoContext) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                          ApphelpAppName,
                                                          NULL,
                                                          0)) != 0) &&
                (Buffer = (PTSTR)LocalAlloc(LPTR, BufferSize)) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                          ApphelpAppName,
                                                          Buffer,
                                                          BufferSize)) != 0)) {
                if (LoadString(hHotPlug, IDS_BLOCKDRIVER_FORMAT, szFormat, SIZECHARS(szFormat)) &&
                    (lstrlen(szFormat) + lstrlen(Buffer) < NOTIFYICONDATA_SZINFO)) {
                    //
                    // The app name and format string will fit into the buffer so
                    // use the format for the balloon message.
                    //
                    _snwprintf(szMessage, 
                               SIZECHARS(szMessage),
                               szFormat,
                               Buffer);
                } else {
                    //
                    // The app name is too large to be formated int he balloon 
                    // message, so just show the app name.
                    //
                    lstrcpyn(szMessage, Buffer, SIZECHARS(szMessage));
                }
            }

            if (Buffer) {
                LocalFree(Buffer);
            }
        }
    } 
                
    if (szMessage[0] == TEXT('\0')) {
        //
        // We either have more than one driver, or an error occured while trying
        // to access the specific information about the one driver we received,
        // so just show the generic message.
        //
        if (!LoadString(hHotPlug, IDS_BLOCKDRIVER_MESSAGE, szMessage, SIZECHARS(szMessage))) {
            //
            // The machine is so low on memory that we can't even get the text strings, so
            // just exit.
            //
            return;
        }
    }
    
    hicon = (HICON)LoadImage(hHotPlug, 
                             MAKEINTRESOURCE(IDI_BLOCKDRIVER), 
                             IMAGE_ICON,
                             GetSystemMetrics(SM_CXSMICON),
                             GetSystemMetrics(SM_CYSMICON),
                             0
                             );

    //
    // Make sure the shell is up and running so we can display the balloon.
    //
    while ((hShellReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("ShellReadyEvent"))) == NULL) {
        //
        // Sleep for 1 second and then try again.
        //
        Sleep(5000);
        
        if (ShellReadyEventCount++ > 120) {
            //
            // We have been waiting for the shell for 10 minutes and it still 
            // is not around.
            //
            break;
        }
    }

    if (hShellReadyEvent) {
        WaitForSingleObject(hShellReadyEvent, INFINITE);

        CloseHandle(hShellReadyEvent);
    
        if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE))) {
        
            IUserNotification *pun;
    
            hr = CoCreateInstance(CLSID_UserNotification, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_IUserNotification,
                                  (void**)&pun);
    
            if (SUCCEEDED(hr)) {
                pun->SetIconInfo(hicon, szTitle);
        
                pun->SetBalloonInfo(szTitle, szMessage, NIIF_WARNING);
        
                //
                // Try once for 20 seconds
                //
                pun->SetBalloonRetry((20 * 1000), -1, 0);
        
                hr = pun->Show(NULL, 0);
        
                //
                // if hr is S_OK then user clicked on the balloon, if it is ERROR_CANCELLED
                // then the balloon timedout.
                //
                if (hr == S_OK) {
                    if (blockedDriverCollection->NumDevices == 1) {
                        //
                        // If we only have one device in the list then just
                        // launch the help for that blocked driver.
                        //
                        BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                      ApphelpHelpCenterURL,
                                                                      NULL,
                                                                      0);
    
                        if (BufferSize && (Buffer = (PTSTR)LocalAlloc(LPTR, BufferSize + (lstrlen(TEXT("HELPCTR.EXE -url ")) * sizeof(TCHAR))))) {
                            lstrcpy(Buffer, TEXT("HELPCTR.EXE -url "));
    
                            BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                    ApphelpHelpCenterURL,
                                                                    (PVOID)&Buffer[lstrlen(TEXT("HELPCTR.EXE -url "))],
                                                                    BufferSize);
                                ShellExecute(NULL,
                                             TEXT("open"),
                                             TEXT("HELPCTR.EXE"),
                                             Buffer,
                                             NULL,
                                             SW_SHOWNORMAL);

                                LocalFree(Buffer);
                        }
                    } else {
                        //
                        // We have more than one device in the list so launch
                        // the summary blocked driver page.
                        //
                        ShellExecute(NULL,
                                     TEXT("open"),
                                     TEXT("HELPCTR.EXE"),
                                     TEXT("HELPCTR.EXE -url hcp://services/centers/support?topic=hcp://system/sysinfo/sysHealthInfo.htm"),
                                     NULL,
                                     SW_SHOWNORMAL
                                     );
                    }
                }
        
                pun->Release();
            }
    
            CoUninitialize();
        }
    }

    if (hicon) {
        DestroyIcon(hicon);
    }

    if (hAppHelpInfoContext) {
        SdbCloseApphelpInformation(hAppHelpInfoContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\hotplug\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0B7F57F6_FFB4_4669_B827_551E77DC7212__INCLUDED_)
#define AFX_STDAFX_H__0B7F57F6_FFB4_4669_B827_551E77DC7212__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//
// DCOM support (note, this must occur after atlbase.h but before anything else)
//
class CMyModule : public CComModule
{
public:
	CMyModule() {
		bServer = FALSE;
		punkFact = NULL;
		dwROC = 0;
	}
	LONG Unlock();
	void CheckShutdown();
	void KillServer();
	HRESULT InitServer(GUID & ClsId);
	bool bServer;
	IUnknown* punkFact;
	DWORD dwROC;
};
extern CMyModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0B7F57F6_FFB4_4669_B827_551E77DC7212__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\inc\ppmacros.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ppmacros.h

Abstract:

    This header defines various generic macros for use by user mode Plug and
    Play system components.

Author:

    Jim Cavalaris (jamesca) 03/01/2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PPMACROS_H_
#define _PPMACROS_H_


//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// the mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_PNPMGR_Mask and may be set via the registry or the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\PNPMGR
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//
// The following levels are used to filter debug output.
//

#define DBGF_ERRORS                       (0x00000001 | DPFLTR_MASK)
#define DBGF_WARNINGS                     (0x00000002 | DPFLTR_MASK)
#define DBGF_EVENT                        (0x00000010 | DPFLTR_MASK)
#define DBGF_REGISTRY                     (0x00000020 | DPFLTR_MASK)
#define DBGF_INSTALL                      (0x00000040 | DPFLTR_MASK)


//
// ASSERT macros
//

#ifdef MYASSERT
#undef MYASSERT
#endif
#if ASSERTS_ON
#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }
#else
#define MYASSERT(x)
#endif


//
// macros for setting and testing flags
//

#define SET_FLAG(Status, Flag)            ((Status) |= (Flag))
#define CLEAR_FLAG(Status, Flag)          ((Status) &= ~(Flag))
#define INVALID_FLAGS(ulFlags, ulAllowed) ((ulFlags) & ~(ulAllowed))
#define TEST_FLAGS(t,ulMask, ulBit)       (((t)&(ulMask)) == (ulBit))
#define IS_FLAG_SET(t,ulMask)             TEST_FLAGS(t,ulMask,ulMask)
#define IS_FLAG_CLEAR(t,ulMask)           TEST_FLAGS(t,ulMask,0)


//
// other useful macros
//

#define ARRAY_SIZE(array)                 (sizeof(array)/sizeof(array[0]))
#define SIZECHARS(x)                      (sizeof((x))/sizeof(TCHAR))


#endif // _PPMACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)        07-May-1991
    Paula Tomlinson (paulat)   06-June-1995    Modified for plug-and-play

Revision History:


--*/

//
// system include files
//
#ifdef MIDL_PASS
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#else
#include <windows.h>
#endif
#include "cfgmgr32.h"

//
// types
//
#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define BOOL DWORD
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\lib\locks.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module contains locking routines used by both cfgmgr32
    and umpnpmgr.

            InitPrivateResource
            DestroyPrivateResource

Author:

    Jim Cavalaris (jamesca) 03-15-2001

Environment:

    User mode only.

Revision History:

    15-March-2001     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnplib.h"



//
// Common locking routines, used by client and server.
// (LOCKINFO type definition and inline lock / unlock routines defined in
// umpnplib.h)
//

BOOL
InitPrivateResource(
    OUT PLOCKINFO Lock
    )

/*++

Routine Description:

    Initialize a lock structure to be used with Synchronization routines.

Arguments:

    LockHandles - supplies structure to be initialized. This routine creates
        the locking event and mutex and places handles in this structure.

Return Value:

    TRUE if the lock structure was successfully initialized. FALSE if not.

--*/

{
    if(Lock->LockHandles[DESTROYED_EVENT] = CreateEvent(NULL,TRUE,FALSE,NULL)) {
        if(Lock->LockHandles[ACCESS_MUTEX] = CreateMutex(NULL,FALSE,NULL)) {
            return(TRUE);
        }
        CloseHandle(Lock->LockHandles[DESTROYED_EVENT]);
    }

    return(FALSE);

} // InitPrivateResource



VOID
DestroyPrivateResource(
    IN OUT PLOCKINFO Lock
    )

/*++

Routine Description:

    Tears down a lock structure created by InitPrivateResource.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    LockHandle - supplies structure to be torn down. The structure itself
        is not freed.

Return Value:

    None.

--*/

{
    HANDLE h1,h2;

    h1 = Lock->LockHandles[DESTROYED_EVENT];
    h2 = Lock->LockHandles[ACCESS_MUTEX];

    Lock->LockHandles[DESTROYED_EVENT] = NULL;
    Lock->LockHandles[ACCESS_MUTEX] = NULL;

    CloseHandle(h2);

    SetEvent(h1);
    CloseHandle(h1);

} // DestroyPrivateResource



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\lib\cutil.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    cutil.c

Abstract:

    This module contains general utility routines used by both cfgmgr32
    and umpnpmgr.

            IsLegalDeviceId
            SplitDeviceInstanceString
            DeletePrivateKey
            RegDeleteNode
            Split1
            Split2
            GetDevNodeKeyPath
            MapRpcExceptionToCR

Author:

    Paula Tomlinson (paulat) 7-12-1995

Environment:

    User mode only.

Revision History:

    12-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnplib.h"



//
// Common private utility routines (used by client and server)
//

BOOL
IsLegalDeviceId(
    IN  LPCWSTR    pszDeviceInstance
    )
/*++

Routine Description:

    This routine parses the device instance string and validates whether it
    conforms to the appropriate rules, including:

    - Total length of the device instance path must not be longer than
      MAX_DEVICE_ID_LEN characters.

    - The device instance path must contain exactly 3 non-empty path components.

    - The device instance path string must not contain any "invalid characters".

      Invalid characters are:
          c <= 0x20 (' ')
          c >  0x7F
          c == 0x2C (',')

Arguments:

    pszDeviceInstance - Device instance path.

Return value:

    The return value is TRUE if the device instance path string conforms to the
    rules.

--*/

{
    BOOL    Status;
    LPCWSTR p;
    ULONG   ulTotalLength = 0;
    ULONG   ulComponentLength = 0, ulComponents = 1;

    try {
        //
        // An empty string is used for an optional device instance path.
        //
        if ((pszDeviceInstance == NULL) || (*pszDeviceInstance == L'\0')) {
            Status = TRUE;
            goto Clean0;
        }

        //
        // Walk over the entire device instance path, counting the total length,
        // individual path component lengths, and checking for the presence of
        // invalid characters.
        //
        for (p = pszDeviceInstance; *p; p++) {
            //
            // Make sure the device instance path isn't too long.
            //
            ulTotalLength++;

            if (ulTotalLength > MAX_DEVICE_ID_LEN) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP: IsLegalDeviceId: "
                           "device instance path %ws longer than "
                           "MAX_DEVICE_ID_LEN characters!\n",
                           pszDeviceInstance));
                //ASSERT(ulTotalLength <= MAX_DEVICE_ID_LEN);
                Status = FALSE;
                goto Clean0;
            }

            //
            // Check for the presence of invalid characters.
            //
            if ((*p <= L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "PNP: IsLegalDeviceId: "
                           "device instance path %ws contains invalid character (0x%lx)!\n",
                           pszDeviceInstance, *p));
                //ASSERT((*p > L' ') && (*p <= (WCHAR)0x7F) && (*p != L','));
                Status = FALSE;
                goto Clean0;
            }

            //
            // Check the length of individual path components.
            //
            if (*p == L'\\') {
                //
                // It is illegal for a device instance path to have multiple
                // consecutive path separators, or to start with one.
                //
                if (ulComponentLength == 0) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "PNP: IsLegalDeviceId: "
                               "device instance path %ws contains "
                               "invalid path component!\n",
                               pszDeviceInstance));
                    //ASSERT(ulComponentLength != 0);
                    Status = FALSE;
                    goto Clean0;
                }

                ulComponentLength = 0;
                ulComponents++;

            } else {
                //
                // Count the length of this path component to verify it's not empty.
                //
                ulComponentLength++;
            }
        }

        //
        // It is illegal for a device instance path to end with a path separator
        // character.
        //
        if (ulComponentLength == 0) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP: IsLegalDeviceId: "
                       "device instance path %ws has trailing '\\' char!\n",
                       pszDeviceInstance));
            //ASSERT(ulComponentLength != 0);
            Status = FALSE;
            goto Clean0;
        }

        //
        // A valid device instance path must contain exactly 3 path components:
        // an enumerator id, a device id, and an instance id.
        //
        if (ulComponents != 3) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP: IsLegalDeviceId: "
                       "device instance path %ws contains "
                       "invalid number of path components!\n",
                       pszDeviceInstance));
            //ASSERT(ulComponents == 3);
            Status = FALSE;
            goto Clean0;
        }

        Status = TRUE;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "PNP: Exception in IsLegalDeviceId!! "
                   "exception code = %d\n",
                   GetExceptionCode()));
        Status = FALSE;
    }

    return Status;

} // IsLegalDeviceId



BOOL
SplitDeviceInstanceString(
   IN  LPCWSTR  pszDeviceInstance,
   OUT LPWSTR   pszBase,
   OUT LPWSTR   pszDeviceID,
   OUT LPWSTR   pszInstanceID
   )

/*++

Routine Description:

     This routine parses a device instance string into it's three component
     parts.  Since this is an internal routine, NO error checking is done on
     the pszBase, pszDeviceID, and pszInstanceID routines; I always assume that
     valid pointers are passed in and that each of these buffers is at least
     MAX_DEVICE_ID_LEN characters in length.  I do some error checking on the
     pszDeviceInstance string since it is passed in from the client side.

Arguments:


Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
   UINT  ulLength, i, j;


   ulLength = lstrlen(pszDeviceInstance);

   //
   // parse the string for the first backslash character
   //

   for (i=0; i < ulLength && pszDeviceInstance[i] != '\0' &&
         pszDeviceInstance[i] != '\\'; i++);

   if (pszDeviceInstance[i] != '\\') {
      lstrcpyn(pszBase, pszDeviceInstance,MAX_DEVICE_ID_LEN);
      *pszDeviceID = '\0';
      *pszInstanceID = '\0';
      return FALSE;  // not a complete device instance string
   }

   i++;           // increment past the backslash character
   if (i < ulLength && pszDeviceInstance[i] != '\0') {
      lstrcpyn(pszBase, pszDeviceInstance, min(i,MAX_DEVICE_ID_LEN));
   }
   else {
      *pszBase = '\0';
      *pszDeviceID = '\0';
      *pszInstanceID = '\0';
      return FALSE;
   }


   //
   // parse the string for second backslash character
   //
   for (j=i; j < ulLength && pszDeviceInstance[j] != '\0' &&
         pszDeviceInstance[j] != '\\'; j++);

   if (pszDeviceInstance[j] != '\\' || j > ulLength) {
      lstrcpyn(pszDeviceID, &pszDeviceInstance[i],MAX_DEVICE_ID_LEN);
      *pszInstanceID = '\0';
      return FALSE;
   }

   j++;
   lstrcpyn(pszDeviceID, &pszDeviceInstance[i], min(j-i,MAX_DEVICE_ID_LEN));
   lstrcpyn(pszInstanceID, &pszDeviceInstance[j], min((ulLength-j+1),MAX_DEVICE_ID_LEN));

   return TRUE;

} // SplitDeviceInstanceString



CONFIGRET
DeletePrivateKey(
   IN HKEY     hBranchKey,
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[2*MAX_CM_PATH],
               szKey1[MAX_CM_PATH],
               szKey2[MAX_CM_PATH];
   HKEY        hKey = NULL;
   ULONG       ulSubKeys = 0;


   //
   // Make sure the specified registry key paths are valid.
   //
   if ((pszParentKey == NULL) ||
       (pszChildKey == NULL)  ||
       ((lstrlen(pszParentKey) + 1) > MAX_CM_PATH) ||
       ((lstrlen(pszChildKey)  + 1) > MAX_CM_PATH)) {
       Status = CR_INVALID_POINTER;
       goto Clean0;
   }

   //
   // is the specified child key a compound registry key?
   //
   if (!Split1(pszChildKey, szKey1, szKey2)) {

      //------------------------------------------------------------------
      // Only a single child key was specified, so just open the parent
      // registry key and delete the child (and any of its subkeys)
      //------------------------------------------------------------------

      if (RegOpenKeyEx(hBranchKey, pszParentKey, 0,
               KEY_READ | KEY_WRITE, &hKey) != ERROR_SUCCESS) {
         goto Clean0;   // no error, nothing to delete
      }

      if (!RegDeleteNode(hKey, pszChildKey)) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }
   }

   else {

      //------------------------------------------------------------------
      // if a compound registry path was passed in, such as key1\key2
      // then always delete key2 but delete key1 only if it has no other
      // subkeys besides key2.
      //------------------------------------------------------------------

      //
      // open the first level key
      //
      wsprintf(RegStr, TEXT("%s\\%s"),
            pszParentKey,
            szKey1);

      RegStatus = RegOpenKeyEx(
            hBranchKey, RegStr, 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
            &hKey);

      if (RegStatus != ERROR_SUCCESS) {
         goto Clean0;         // no error, nothing to delete
      }

      //
      // try to delete the second level key
      //
      if (!RegDeleteNode(hKey, szKey2)) {
         goto Clean0;         // no error, nothing to delete
      }

      //
      // How many subkeys are remaining?
      //
      RegStatus = RegQueryInfoKey(
            hKey, NULL, NULL, NULL, &ulSubKeys,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);

      if (RegStatus != ERROR_SUCCESS) {
         goto Clean0;         // nothing to delete
      }

      //
      // if no more subkeys, then delete the first level key
      //
      if (ulSubKeys == 0) {

         RegCloseKey(hKey);
         hKey = NULL;

         RegStatus = RegOpenKeyEx(
               hBranchKey, pszParentKey, 0,
               KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey);

         if (RegStatus != ERROR_SUCCESS) {
            goto Clean0;         // no error, nothing to delete
         }

         if (!RegDeleteNode(hKey, szKey1)) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
         }
      }
   }


   Clean0:

   if (hKey != NULL) {
      RegCloseKey(hKey);
   }

   return Status;

} // DeletePrivateKey



BOOL
RegDeleteNode(
   HKEY     hParentKey,
   LPCWSTR   szKey
   )
{
   ULONG ulSize = 0;
   LONG  RegStatus = ERROR_SUCCESS;
   HKEY  hKey = NULL;
   WCHAR szSubKey[MAX_PATH];


   //
   // attempt to delete the key
   //
   if (RegDeleteKey(hParentKey, szKey) != ERROR_SUCCESS) {

      RegStatus = RegOpenKeyEx(
               hParentKey, szKey, 0, KEY_ALL_ACCESS, &hKey);

      //
      // enumerate subkeys and delete those nodes
      //
      while (RegStatus == ERROR_SUCCESS) {
         //
         // enumerate the first level children under the profile key
         // (always use index 0, enumeration looses track when a key
         // is added or deleted)
         //
         ulSize = MAX_PATH;
         RegStatus = RegEnumKeyEx(
                  hKey, 0, szSubKey, &ulSize, NULL, NULL, NULL, NULL);

         if (RegStatus == ERROR_SUCCESS) {
            RegDeleteNode(hKey, szSubKey);
         }
      }

      //
      // either an error occured that prevents me from deleting the
      // keys (like the key doesn't exist in the first place or an
      // access violation) or the subkeys have been deleted, try
      // deleting the top level key again
      //
      RegCloseKey(hKey);
      RegDeleteKey(hParentKey, szKey);
   }

   return TRUE;

} // RegDeleteNode



BOOL
Split1(
   IN  LPCWSTR pszString,
   OUT LPWSTR  pszString1,
   OUT LPWSTR  pszString2
   )
{
   BOOL    Status = TRUE;
   LPWSTR  p;


   //
   // Split the string at the first backslash character
   //

   try {

      lstrcpy(pszString1, pszString);
      for (p = pszString1; (*p) && (*p != TEXT('\\')); p++);

      if (*p == TEXT('\0')) {
         Status = FALSE;
         goto Clean0;
      }

      *p = TEXT('\0');           // truncate string1
      p++;
      lstrcpy(pszString2, p);    // the rest is string2


   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = FALSE;
   }

   return Status;

} // Split1



BOOL
Split2(
   IN  LPCWSTR pszString,
   OUT LPWSTR  pszString1,
   OUT LPWSTR  pszString2
   )
{
   BOOL    Status = TRUE;
   LPWSTR  p;


   //
   // Split the string at the second backslash character
   //

   try {

      lstrcpy(pszString1, pszString);
      for (p = pszString1; (*p) && (*p != TEXT('\\')); p++);   // first
      for (p++; (*p) && (*p != TEXT('\\')); p++);              // second

      *p = TEXT('\0');           // truncate string1
      p++;
      lstrcpy(pszString2, p);    // the rest is string2

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = FALSE;
   }

   return Status;

} // Split2



CONFIGRET
GetDevNodeKeyPath(
   IN  handle_t   hBinding,
   IN  LPCWSTR    pDeviceID,
   IN  ULONG      ulFlags,
   IN  ULONG      ulHardwareProfile,
   OUT LPWSTR     pszBaseKey,
   OUT LPWSTR     pszPrivateKey
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   WCHAR       szClassInstance[MAX_PATH], szEnumerator[MAX_DEVICE_ID_LEN];
   ULONG       ulSize, ulDataType = 0;
   ULONG       ulTransferLen;


   //-------------------------------------------------------------
   // form the key for the software branch case
   //-------------------------------------------------------------

   if (ulFlags & CM_REGISTRY_SOFTWARE) {
      //
      // retrieve the class name and instance ordinal by calling
      // the server's reg prop routine
      //
      ulSize = ulTransferLen = sizeof(szClassInstance);

      RpcTryExcept {

         Status = PNP_GetDeviceRegProp(
             hBinding,
             pDeviceID,
             CM_DRP_DRIVER,
             &ulDataType,
             (LPBYTE)szClassInstance,
             &ulTransferLen,
             &ulSize,
             0);
      }
      RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
         KdPrintEx((DPFLTR_PNPMGR_ID,
                    DBGF_ERRORS,
                    "PNP_GetDeviceRegProp caused an exception (%d)\n",
                    RpcExceptionCode()));

         Status = MapRpcExceptionToCR(RpcExceptionCode());
      }
      RpcEndExcept

      if (Status != CR_SUCCESS || *szClassInstance == '\0') {
         //
         // no Driver (class instance) value yet so ask the server to
         // create a new unique one
         //
         ulSize = sizeof(szClassInstance);

         RpcTryExcept {

            Status = PNP_GetClassInstance(
                hBinding,
                pDeviceID,
                szClassInstance,
                ulSize);
         }
         RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetClassInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
         }
         RpcEndExcept

         if (Status != CR_SUCCESS) {
            goto Clean0;
         }
      }

      //
      // the <instance> part of the class instance is the private part
      //
      Split1(szClassInstance, szClassInstance, pszPrivateKey);

      //
      // config-specific software branch case
      //
      if (ulFlags & CM_REGISTRY_CONFIG) {
         //
         // curent config
         //
         // System\CCC\Hardware Profiles\Current
         //    \System\CCC\Control\Class\<DevNodeClassInstance>
         //
         if (ulHardwareProfile == 0) {

            wsprintf(pszBaseKey, TEXT("%s\\%s\\%s\\%s"),
                     REGSTR_PATH_HWPROFILES,
                     REGSTR_KEY_CURRENT,
                     REGSTR_PATH_CLASS_NT,
                     szClassInstance);
         }

         //
         // all configs, use substitute string for profile id
         //
         else if (ulHardwareProfile == 0xFFFFFFFF) {

            wsprintf(pszBaseKey, TEXT("%s\\%s\\%s\\%s"),
                     REGSTR_PATH_HWPROFILES,
                     TEXT("%s"),
                     REGSTR_PATH_CLASS_NT,
                     szClassInstance);
         }

         //
         // specific profile specified
         //
         // System\CCC\Hardware Profiles\<profile>
         //    \System\CCC\Control\Class\<DevNodeClassInstance>
         //
         else {
            wsprintf(pszBaseKey, TEXT("%s\\%04u\\%s\\%s"),
                     REGSTR_PATH_HWPROFILES,
                     ulHardwareProfile,
                     REGSTR_PATH_CLASS_NT,
                     szClassInstance);
         }
      }

      //
      // not config-specific
      // System\CCC\Control\Class\<DevNodeClassInstance>
      //
      else  {
         wsprintf(pszBaseKey, TEXT("%s\\%s"),
                  REGSTR_PATH_CLASS_NT,
                  szClassInstance);
      }
   }


   //-------------------------------------------------------------
   // form the key for the hardware branch case
   //-------------------------------------------------------------

   else {
      //
      // config-specific hardware branch case
      //
      if (ulFlags & CM_REGISTRY_CONFIG) {

         //
         // for profile specific, the <device>\<instance> part of
         // the device id is the private part
         //
         Split1(pDeviceID, szEnumerator, pszPrivateKey);

         //
         // curent config
         //
         if (ulHardwareProfile == 0) {

            wsprintf(pszBaseKey, TEXT("%s\\%s\\%s\\%s"),
                     REGSTR_PATH_HWPROFILES,
                     REGSTR_KEY_CURRENT,
                     REGSTR_PATH_SYSTEMENUM,
                     szEnumerator);
         }

         //
         // all configs, use replacement symbol for profile id
         //
         else if (ulHardwareProfile == 0xFFFFFFFF) {

            wsprintf(pszBaseKey, TEXT("%s\\%s\\%s\\%s"),
                     REGSTR_PATH_HWPROFILES,
                     TEXT("%s"),
                     REGSTR_PATH_SYSTEMENUM,
                     szEnumerator);
         }

         //
         // specific profile specified
         //
         else {
            wsprintf(pszBaseKey, TEXT("%s\\%04u\\%s\\%s"),
                     REGSTR_PATH_HWPROFILES,
                     ulHardwareProfile,
                     REGSTR_PATH_SYSTEMENUM,
                     szEnumerator);
         }
      }

      else if (ulFlags & CM_REGISTRY_USER) {
         //
         // for hardware user key, the <device>\<instance> part of
         // the device id is the private part
         //
         Split1(pDeviceID, szEnumerator, pszPrivateKey);

         wsprintf(pszBaseKey, TEXT("%s\\%s"),
                  REGSTR_PATH_SYSTEMENUM,
                  szEnumerator);
      }

      //
      // not config-specific
      //
      else {
         wsprintf(pszBaseKey, TEXT("%s\\%s"),
                  REGSTR_PATH_SYSTEMENUM,
                  pDeviceID);

         lstrcpy(pszPrivateKey, REGSTR_KEY_DEVICEPARAMETERS);
      }
   }


   Clean0:

   return Status;

} // GetDevNodeKeyPath



CONFIGRET
MapRpcExceptionToCR(
      ULONG    ulRpcExceptionCode
      )

/*++

Routine Description:

   This routine takes an rpc exception code (typically received by
   calling RpcExceptionCode) and returns a corresponding CR_ error
   code.

Arguments:

   ulRpcExceptionCode   An RPC_S_ or RPC_X_ exception error code.

Return Value:

    Return value is one of the CR_ error codes.

--*/

{
   CONFIGRET   Status = CR_FAILURE;


   switch(ulRpcExceptionCode) {

      //
      // binding or machine name errors
      //
      case RPC_S_INVALID_STRING_BINDING:      // 1700L
      case RPC_S_WRONG_KIND_OF_BINDING:       // 1701L
      case RPC_S_INVALID_BINDING:             // 1702L
      case RPC_S_PROTSEQ_NOT_SUPPORTED:       // 1703L
      case RPC_S_INVALID_RPC_PROTSEQ:         // 1704L
      case RPC_S_INVALID_STRING_UUID:         // 1705L
      case RPC_S_INVALID_ENDPOINT_FORMAT:     // 1706L
      case RPC_S_INVALID_NET_ADDR:            // 1707L
      case RPC_S_NO_ENDPOINT_FOUND:           // 1708L
      case RPC_S_NO_MORE_BINDINGS:            // 1806L
      case RPC_S_CANT_CREATE_ENDPOINT:        // 1720L

         Status = CR_INVALID_MACHINENAME;
         break;

      //
      // general rpc communication failure
      //
      case RPC_S_INVALID_NETWORK_OPTIONS:     // 1724L
      case RPC_S_CALL_FAILED:                 // 1726L
      case RPC_S_CALL_FAILED_DNE:             // 1727L
      case RPC_S_PROTOCOL_ERROR:              // 1728L
      case RPC_S_UNSUPPORTED_TRANS_SYN:       // 1730L

         Status = CR_REMOTE_COMM_FAILURE;
         break;

      //
      // couldn't make connection to that machine
      //
      case RPC_S_SERVER_UNAVAILABLE:          // 1722L
      case RPC_S_SERVER_TOO_BUSY:             // 1723L

         Status = CR_MACHINE_UNAVAILABLE;
         break;


      //
      // server doesn't exist or not right version
      //
      case RPC_S_INVALID_VERS_OPTION:         // 1756L
      case RPC_S_INTERFACE_NOT_FOUND:         // 1759L
      case RPC_S_UNKNOWN_IF:                  // 1717L

         Status = CR_NO_CM_SERVICES;
         break;

      //
      // any other RPC exceptions will just be general failures
      //
      default:
         Status = CR_FAILURE;
         break;
   }

   return Status;

} // MapRpcExceptionToCR



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\lib\precomp.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for the statically linked library that is shared by
    both the Configuration Manager client DLL and User-Mode Plug and Play
    manager server DLL

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Win32 Public Header Files
//
#include <windows.h>
#include <regstr.h>

//
// CRT Header Files
//
#include <stdlib.h>

//
// RPC Header Files
//
#include <ntrpcp.h>     // needed for rpcasync.h
#include <rpcasync.h>   // I_RpcExceptionFilter


//
// Private Header Files
//
#include "pnp.h"        // midl generated, rpc interfaces
#include "cfgmgrp.h"    // private shared header, needs handle_t so must follow pnp.h
#include "ppmacros.h"   // private macros / debug header

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\inc\cfgmgrp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    cfgmgrp.h

Abstract:

    This module contains private Plug and Play defintions and declarations used
    by the Configuration Manager, the user mode Plug and Play manager, and other
    system components.

Author:

    Paula Tomlinson (paulat) 06/19/1995


Revision History:

    Jim Cavalaris (jamesca) 03/01/2001

        Removed definitions and declarations that are specific to only either
        CFGMGR32 or UMPNPMGR, since this header file is also included privately
        by other system components such as the service control manager (SCM).

--*/

#ifndef _CFGMGRP_H_
#define _CFGMGRP_H_


//
// The following constants are used by PNP_GetVersion / CM_Get_Version to
// retrieve the version of the Configuration Manager APIs.  CONFIGMG_VERSION is
// defined as 0x0400 in the public header cfgmgr32.h and should remain constant
// across all future versions of Windows, for compatibility reasons.
//

#define PNP_VERSION               CONFIGMG_VERSION
#define CFGMGR32_VERSION          CONFIGMG_VERSION


//
// The following constants are used for version negotiation between the client
// and the server, and are for internal use only. CFGMGR32_VERSION_INTERNAL is
// supplied to PNP_GetVersionInternal by the client, and upon successful return
// receives PNP_VERSION_INTERNAL.  For simplicity, these are defined to the
// current version of Windows the corresponding client and server shipped with.
//
// Note that there is no client routine to receive the internal version of the
// server directly.  Instead, CM_Is_Version_Available is provided to determine
// support for a particular version.  The only version publicly defined is
// CFGMG_VERSION, which is constant, and always available.
//

#define PNP_VERSION_INTERNAL      WINVER
#define CFGMGR32_VERSION_INTERNAL WINVER


//
// Common PNP constant definitions
//

#define MAX_DEVICE_INSTANCE_LEN           256
#define MAX_DEVICE_INSTANCE_SIZE          512
#define MAX_SERVICE_NAME_LEN              256
#define MAX_PROFILE_ID_LEN                5
#define MAX_CM_PATH                       360

#define NT_RESLIST_VERSION                (0x00000000)
#define NT_RESLIST_REVISION               (0x00000000)
#define NT_REQLIST_VERSION                (0x00000001)
#define NT_REQLIST_REVISION               (0x00000001)

#define CM_PRIVATE_LOGCONF_SIGNATURE      (0x08156201)
#define CM_PRIVATE_RESDES_SIGNATURE       (0x08156202)
#define CM_PRIVATE_CONFLIST_SIGNATURE     (0x08156203)

#define MAX_LOGCONF_TAG                   (0xFFFFFFFF)
#define MAX_RESDES_TAG                    (0xFFFFFFFF)
#define RESDES_CS_TAG                     (MAX_RESDES_TAG - 1) // class-specific


//
// Action types for PNP_GetRelatedDeviceInstance
//
#define PNP_GET_PARENT_DEVICE_INSTANCE    0x00000001
#define PNP_GET_CHILD_DEVICE_INSTANCE     0x00000002
#define PNP_GET_SIBLING_DEVICE_INSTANCE   0x00000003

//
//  Action types for PNP_DeviceInstanceAction
//
#define PNP_DEVINST_CREATE                0x00000001
#define PNP_DEVINST_MOVE                  0x00000002
#define PNP_DEVINST_SETUP                 0x00000003
#define PNP_DEVINST_ENABLE                0x00000004
#define PNP_DEVINST_DISABLE               0x00000005
#define PNP_DEVINST_REMOVESUBTREE         0x00000006
#define PNP_DEVINST_REENUMERATE           0x00000007
#define PNP_DEVINST_QUERYREMOVE           0x00000008
#define PNP_DEVINST_REQUEST_EJECT         0x00000009

//
// Action types for PNP_EnumerateSubKeys
//
#define PNP_ENUMERATOR_SUBKEYS            0x00000001
#define PNP_CLASS_SUBKEYS                 0x00000002

//
// Action types for PNP_HwProfFlags
//
#define PNP_GET_HWPROFFLAGS               0x00000001
#define PNP_SET_HWPROFFLAGS               0x00000002

//
// flags for PNP_SetActiveService
//
#define PNP_SERVICE_STARTED               0x00000001
#define PNP_SERVICE_STOPPED               0x00000002


//
// Mask for Flags argument to CMP_RegisterNotification, PNP_RegisterNotification
// Must be kept in sync with RegisterDeviceNotification flags, in winuser.h and
// winuserp.h.
//

//#define DEVICE_NOTIFY_WINDOW_HANDLE          0x00000000
//#define DEVICE_NOTIFY_SERVICE_HANDLE         0x00000001
//#define DEVICE_NOTIFY_COMPLETION_HANDLE      0x00000002
#define DEVICE_NOTIFY_HANDLE_MASK            0x00000003

//#define DEVICE_NOTIFY_ALL_INTERFACE_CLASSES  0x00000004
#define DEVICE_NOTIFY_PROPERTY_MASK          0x00FFFFFC

#define DEVICE_NOTIFY_WOW64_CLIENT           0x01000000
#define DEVICE_NOTIFY_RESERVED_MASK          0xFF000000

#define DEVICE_NOTIFY_BITS (DEVICE_NOTIFY_HANDLE_MASK|DEVICE_NOTIFY_ALL_INTERFACE_CLASSES|DEVICE_NOTIFY_WOW64_CLIENT)

//
// Flags returned from CMP_GetServerSideDeviceInstallFlags
//
#define SSDI_REBOOT_PENDING                 0x00000001


//-------------------------------------------------------------------
// Private routines for Service Notifications, exported from
// UMPNPMGR.dll for use by the Service Control Manager only.
//-------------------------------------------------------------------

//
// Prototype definitions for the private routines supplied to the User-mode Plug
// and Play service for direct communication with the Service Control Manager.
//

typedef
DWORD
(*PSCMCALLBACK_ROUTINE) (
    IN  SERVICE_STATUS_HANDLE hServiceStatus,
    IN  DWORD         OpCode,
    IN  DWORD         dwEventType,  // PnP wParam
    IN  LPARAM        EventData,    // PnP lParam
    IN  PDWORD        result
    );

typedef
DWORD
(*PSCMAUTHENTICATION_CALLBACK) (
    IN  LPWSTR                 lpServiceName,
    OUT SERVICE_STATUS_HANDLE  *lphServiceStatus
    );


//
// Private routines called by the Service Controller to supply (and revoke)
// entrypoints for the above routines. (Note - UnRegisterScmCallback is not
// currently used by the SCM, and is consequently not exported by UMPNPMGR)
//

CONFIGRET
RegisterScmCallback(
    IN  PSCMCALLBACK_ROUTINE         pScCallback,
    IN  PSCMAUTHENTICATION_CALLBACK  pScAuthCallback
    );

CONFIGRET
UnRegisterScmCallback(
    VOID
    );


//
// Private routine called by the Service Controller to register a service to
// receive notification events other than device events, that are also delivered
// by Plug and Play (i.e. hardware profile change events, power events).
//

CONFIGRET
RegisterServiceNotification(
    IN  SERVICE_STATUS_HANDLE hService,
    IN  LPWSTR pszService,
    IN  DWORD  scControls,
    IN  BOOL   bServiceStopped
    );


//
// Private routine caled by the Service Controller whenever a service is deleted
// to delete any Plug and Play registry keys for a service (and uninstall the
// devnode when necessary).
//

CONFIGRET
DeleteServicePlugPlayRegKeys(
    IN  LPWSTR   pszService
    );


//
// Private routine called by the Service Controller to set the ActiveService for
// devices controlled by the specified service.
// [Note that this routine is NOT an RPC server routine, it is exported only!!]
//

CONFIGRET
PNP_SetActiveService(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pszService,
    IN  ULONG      ulFlags
    );

//
// Private routine to get the current list of blocked drivers (GUIDs).
//

CONFIGRET
CMP_GetBlockedDriverInfo(
    OUT LPBYTE      Buffer,
    IN OUT PULONG   pulLength,
    IN ULONG        ulFlags,
    IN  HMACHINE    hMachine
    );

//
// Private routine to get server side device install flags.
//

CONFIGRET
CMP_GetServerSideDeviceInstallFlags(
    IN  PULONG      pulSSDIFlags,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

#endif // _CFGMGRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\inc\pnpipc.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    pnpipc.h

Abstract:

    This module contains the private defintions used by various
    user-mode pnp components to communicate.

Author:

    Paula Tomlinson (paulat) 02/21/1996

Environment:

    User-mode only.

Revision History:

    27-February-2001     jamesca

        Additional CFGMGR32-specific and UMPNPMGR-specific definitions.
        Constrained header file to only those

--*/

#ifndef _PNPIPC_H_
#define _PNPIPC_H_


//
// Module names of support libraries and executables.
//

#define SETUPAPI_DLL                    TEXT("setupapi.dll")
#define NEWDEV_DLL                      TEXT("newdev.dll")
#define HOTPLUG_DLL                     TEXT("hotplug.dll")
#define RUNDLL32_EXE                    TEXT("rundll32.exe")
#define NTSD_EXE                        TEXT("ntsd.exe")

#define WINSTA_DLL                      TEXT("winsta.dll")
#define WTSAPI32_DLL                    TEXT("wtsapi32.dll")


//
// Pending install event, shared by cfgmgr32 and umpnpmgr.
// This event is always created in the Global (i.e. Session 0) object namespace.
//

#define PNP_NO_INSTALL_EVENTS           TEXT("Global\\PnP_No_Pending_Install_Events")


//
// Named pipe, events, and timeouts used with GUI setup.
//

#define PNP_NEW_HW_PIPE                 TEXT("\\\\.\\pipe\\PNP_New_HW_Found")
#define PNP_CREATE_PIPE_EVENT           TEXT("PNP_Create_Pipe_Event")
#define PNP_BATCH_PROCESSED_EVENT       TEXT("PNP_Batch_Processed_Event")

#define PNP_PIPE_TIMEOUT                60000  // 60 seconds
#define PNP_GUISETUP_INSTALL_TIMEOUT    60000  // 60 seconds


//
// Named pipe, events, and timeouts used for communication with newdev.
//

#define PNP_DEVICE_INSTALL_PIPE         TEXT("\\\\.\\pipe\\PNP_Device_Install_Pipe")
#define PNP_DEVICE_INSTALL_EVENT        TEXT("PNP_Device_Install_Event")

// Flags to specify behavior of the device install client (newdev.dll).
#define DEVICE_INSTALL_UI_ONLY              0x00000001
#define DEVICE_INSTALL_FINISHED_REBOOT      0x00000002
#define DEVICE_INSTALL_PLAY_SOUND           0x00000004
#define DEVICE_INSTALL_BATCH_COMPLETE       0x00000008
#define DEVICE_INSTALL_PROBLEM              0x00000010
#define DEVICE_INSTALL_DISPLAY_ON_CONSOLE   0x00010000

// Bitmask for only those flags sent to newdev.dll.
#define DEVICE_INSTALL_CLIENT_MASK          0x0000FFFF
#define DEVICE_INSTALL_SERVER_MASK          0xFFFF0000

// Length of time to allow 'device install complete' bubble to be displayed.
#define DEVICE_INSTALL_COMPLETE_WAIT_TIME         3000  //  3 seconds
#define DEVICE_INSTALL_COMPLETE_DISPLAY_TIME     10000  // 10 seconds


//
// Named pipe, events, and timeouts used for communication with hotplug.
//

#define PNP_HOTPLUG_PIPE                TEXT("\\\\.\\pipe\\PNP_HotPlug_Pipe")
#define PNP_HOTPLUG_EVENT               TEXT("PNP_HotPlug_Event")

// Flags to specify behavior of the hotplug client (hotplug.dll).
#define HOTPLUG_DISPLAY_ON_CONSOLE          0x00010000


//
// Default WindowStation and Desktop names for launching hotplug and newdev
// processes on an interactive user's desktop.
//

#define DEFAULT_WINSTA                  TEXT("WinSta0")
#define DEFAULT_DESKTOP                 TEXT("Default")
#define DEFAULT_INTERACTIVE_DESKTOP     TEXT("WinSta0\\Default")


#endif // _PNPIPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\analyze.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       analyze.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <infstr.h>



INT_PTR CALLBACK
NDW_AnalyzeDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HICON hicon;
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        NewDevWiz->AnalyzeResult = 0;
        return TRUE;
    }

    NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    InstallWizard = &NewDevWiz->InstallDynaWiz;

    switch (wMsg) {

    case WM_DESTROY:

        hicon = (HICON)LOWORD(SendDlgItemMessage(hDlg,IDC_CLASSICON,STM_GETICON,0,0));
        if (hicon) {

            DestroyIcon(hicon);
        }

        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {

            int PrevPage;
            DWORD RegisterError = ERROR_SUCCESS;
            SP_DRVINFO_DATA DriverInfoData;

            PrevPage = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_ANALYZEDEV;

            if (PrevPage == IDD_WIZARDEXT_POSTANALYZE) {
                
                //
                // We decided not to show the Analyze page so just jump Back
                //
                PropSheet_PressButton(GetParent(hDlg), PSBTN_BACK);
                break;
            }

            //
            // Get info on currently selected device, since this could change
            // as the user move back and forth between wizard pages
            // we do this on each activate.
            //
            if (!SetupDiGetSelectedDevice(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData
                                          ))
            {
                RegisterError = GetLastError();
#if DBG
                DbgPrint("Add Hardware: AnalyzeDlgProc no selected device %x\n",
                         RegisterError
                         );
#endif
            }

            //
            // Set the class Icon
            //

            if (SetupDiLoadClassIcon(&NewDevWiz->DeviceInfoData.ClassGuid, &hicon, NULL)) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                
                if (hicon) {

                    DestroyIcon(hicon);
                }
            }

            SetDriverDescription(hDlg, IDC_NDW_DESCRIPTION, NewDevWiz);
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);

            //
            // need to determine conflict warning.
            //

            if (RegisterError != ERROR_SUCCESS) {

                SetDlgText(hDlg, IDC_NDW_TEXT, IDS_NDW_ANALYZEERR1, IDS_NDW_ANALYZEERR3);
            
            }
            
            else {
                
                SetDlgText(hDlg, IDC_NDW_TEXT, IDS_NDW_STDCFG1, IDS_NDW_STDCFG2);
            }

            if (InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {

                if (RegisterError == ERROR_SUCCESS ||
                    !(InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT))
                {
                   SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_ANALYZE_NEXTPAGE);
                }
            }

            //
            // Only show the Analyze page if there was an error registering this device.
            //
            if (RegisterError == ERROR_SUCCESS) {
            
                PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
            }

            break;
        }

        case PSN_WIZBACK:

            if (NewDevWiz->WizExtPostAnalyze.hPropSheet) {
                
                PropSheet_RemovePage(hwndParentDlg,
                                     (WPARAM)-1,
                                     NewDevWiz->WizExtPostAnalyze.hPropSheet
                                     );
                
                NewDevWiz->WizExtPostAnalyze.hPropSheet = NULL;
            }

            SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PREANALYZE);
            break;

        case PSN_WIZNEXT:

            //
            // Add the PostAnalyze Page and jump to it
            //

            NewDevWiz->WizExtPostAnalyze.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_POSTANALYZE,
                                                                       WizExtPostAnalyzeDlgProc,
                                                                       NewDevWiz
                                                                       );

            if (NewDevWiz->WizExtPostAnalyze.hPropSheet) {

                PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtPostAnalyze.hPropSheet);
            }

            SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_POSTANALYZE);

           break;

        }
        break;


    default:
        return(FALSE);
    
    }
    
    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreAnalyzeDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


   case WM_NOTIFY:
       
       switch (((NMHDR FAR *)lParam)->code) {
           
       case PSN_SETACTIVE:

           PrevPageId = NewDevWiz->PrevPage;
           NewDevWiz->PrevPage = IDD_WIZARDEXT_PREANALYZE;

           if (PrevPageId == IDD_WIZARDEXT_SELECT) {

               //
               // Moving forward on first page
               //


               //
               // if we are not doing the old fashioned DYNAWIZ
               // Add ClassWizard Extension pages for preanalyze
               //

               if ((NewDevWiz->Flags & IDI_FLAG_MANUALINSTALL) &&
                   !(NewDevWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED))
               {
                   AddClassWizExtPages(hwndParentDlg,
                                       NewDevWiz,
                                       &NewDevWiz->WizExtPreAnalyze.DeviceWizardData,
                                       DIF_NEWDEVICEWIZARD_PREANALYZE,
                                       NULL
                                       );
               }


               //
               // Add the end page, which is PreAnalyze end
               //

               NewDevWiz->WizExtPreAnalyze.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_PREANALYZE_END,
                                                                            WizExtPreAnalyzeEndDlgProc,
                                                                            NewDevWiz
                                                                            );

               if (NewDevWiz->WizExtPreAnalyze.hPropSheetEnd) {
                   
                   PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtPreAnalyze.hPropSheetEnd);
               }

               PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

           }
           else {

                //
                // Moving backwards from PreAnalyze end on PreAanalyze
                //

                //
                // Clean up proppages added.
                //

                if (NewDevWiz->WizExtPreAnalyze.hPropSheetEnd) {
                    
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtPreAnalyze.hPropSheetEnd
                                         );
                    NewDevWiz->WizExtPreAnalyze.hPropSheetEnd = NULL;
                }


                RemoveClassWizExtPages(hwndParentDlg,
                                       &NewDevWiz->WizExtPreAnalyze.DeviceWizardData
                                       );




                //
                // Jump back
                // Note: The target pages don't set PrevPage, so set it for them
                //
                NewDevWiz->PrevPage = IDD_WIZARDEXT_SELECT;
                
                if (NewDevWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {
                    
                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_ANALYZE_PREVPAGE);
                }
                
                else {
                    
                    SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_SELECTDEV_PAGE);
                }
            }

           break;

       case PSN_WIZNEXT:
           SetDlgMsgResult(hDlg, wMsg, 0);
           break;
           
       }
       break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreAnalyzeEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_PREANALYZE_END;

            if (PrevPageId == IDD_NEWDEVWIZ_ANALYZEDEV) {
                
                //
                // Moving backwards from analyzepage
                //

                //
                // Jump back
                //


                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);

            }
            
            else {
                
                //
                // Moving forward on end page
                //

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_ANALYZEDEV);
            }


           break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPostAnalyzeDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
           NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
           SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
           break;
    }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_POSTANALYZE;

            if (PrevPageId == IDD_NEWDEVWIZ_ANALYZEDEV) {
                //
                // Moving forward on first page
                //

                //
                // if we are not doing the old fashioned DYNAWIZ
                // Add ClassWizard Extension pages for postanalyze
                //

                if ((NewDevWiz->Flags & IDI_FLAG_MANUALINSTALL) &&
                    !(NewDevWiz->InstallDynaWiz.DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED))
                {
                    AddClassWizExtPages(hwndParentDlg,
                                        NewDevWiz,
                                        &NewDevWiz->WizExtPostAnalyze.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_POSTANALYZE,
                                        NULL
                                        );
                }


                //
                // Add the end page, which is PostAnalyze end
                //

                NewDevWiz->WizExtPostAnalyze.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_POSTANALYZE_END,
                                                                             WizExtPostAnalyzeEndDlgProc,
                                                                              NewDevWiz
                                                                              );

                if (NewDevWiz->WizExtPostAnalyze.hPropSheetEnd) {
                    
                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtPostAnalyze.hPropSheetEnd);
                }

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }
            
            else  {
                
                //
                // Moving backwards from PostAnalyze end on PostAnalyze
                //

                //
                // Clean up proppages added.
                //

                if (NewDevWiz->WizExtPostAnalyze.hPropSheetEnd) {
                    
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtPostAnalyze.hPropSheetEnd
                                         );
                    
                    NewDevWiz->WizExtPostAnalyze.hPropSheetEnd = NULL;
                }


                RemoveClassWizExtPages(hwndParentDlg,
                                       &NewDevWiz->WizExtPostAnalyze.DeviceWizardData
                                       );

            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPostAnalyzeEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
           NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
           SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
           break;
    }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_POSTANALYZE_END;

            if (PrevPageId == IDD_NEWDEVWIZ_INSTALLDEV) {

                //
                // Moving backwards from finishpage
                //

                //
                // Jump back
                //

                PropSheet_PressButton(hwndParentDlg, PSBTN_BACK);
            }
            
            else  {
                 
                //
                // Moving forward on End page
                //

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_INSTALLDEV);
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;
 
    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\finish.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       finish.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <help.h>


typedef
UINT
(*PDEVICEPROBLEMTEXT)(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPTSTR Buffer,
    UINT   BufferSize
    );

BOOL
IsNullDriverInstalled(
    DEVNODE DevNode
    )
/*++

Routine Description:

    This routine determines whether a null driver, or no driver at all, is
    installed for this device instance.  Currently the test is that I know
    a null driver was installed if the "Driver" value entry doesn't exist.

Arguments:

    DevNode

Return Value:

   Returns TRUE if a null driver was installed for this device, otherwise
   returns FALSE.

--*/

{
    TCHAR Buffer[1];
    DWORD dwSize, dwType;

    dwSize = SIZECHARS(Buffer);
    if (CM_Get_DevNode_Registry_Property(DevNode,
                                         CM_DRP_DRIVER,
                                         &dwType,
                                         (LPVOID)Buffer,
                                         &dwSize,
                                         0) == CR_BUFFER_SMALL) {

        return FALSE;

    } else {

        return TRUE;

    }
}

PTCHAR
DeviceProblemText(
   HMACHINE hMachine,
   DEVNODE DevNode,
   ULONG ProblemNumber
   )
{
   UINT LenChars, ReqLenChars;
   HMODULE hDevMgr=NULL;
   PTCHAR Buffer=NULL;
   PDEVICEPROBLEMTEXT pDeviceProblemText = NULL;

   hDevMgr = LoadLibrary(TEXT("devmgr.dll"));
   if (hDevMgr)
   {
       pDeviceProblemText = (PVOID) GetProcAddress(hDevMgr, "DeviceProblemTextW");
   }

   if (pDeviceProblemText)
   {
       LenChars = (pDeviceProblemText)(hMachine,
                                       DevNode,
                                       ProblemNumber,
                                       Buffer,
                                       0
                                       );
       if (!LenChars)
       {
           goto DPTExitCleanup;
       }

       LenChars++;  // one extra for terminating NULL

       Buffer = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));
       if (!Buffer)
       {
           goto DPTExitCleanup;
       }

       ReqLenChars = (pDeviceProblemText)(hMachine,
                                          DevNode,
                                          ProblemNumber,
                                          Buffer,
                                          LenChars
                                          );
       if (!ReqLenChars || ReqLenChars >= LenChars)
       {
           LocalFree(Buffer);
           Buffer = NULL;
       }
   }

DPTExitCleanup:

   if (hDevMgr)
   {
       FreeLibrary(hDevMgr);
   }

   return Buffer;
}

BOOL
DeviceHasResources(
   DEVINST DeviceInst
   )
{
   CONFIGRET ConfigRet;
   ULONG lcType = NUM_LOG_CONF;

   while (lcType--)
   {
       ConfigRet = CM_Get_First_Log_Conf_Ex(NULL, DeviceInst, lcType, NULL);
       if (ConfigRet == CR_SUCCESS)
       {
           return TRUE;
       }
   }

   return FALSE;
}

BOOL
GetClassGuidForInf(
    PTSTR InfFileName,
    LPGUID ClassGuid
    )
{
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD NumGuids;

    if(!SetupDiGetINFClass(InfFileName,
                           ClassGuid,
                           ClassName,
                           sizeof(ClassName)/sizeof(TCHAR),
                           NULL))
    {
       return FALSE;
    }

    if (IsEqualGUID(ClassGuid, &GUID_NULL))
    {
        //
        // Then we need to retrieve the GUID associated with the INF's class name.
        // (If this class name isn't installed (i.e., has no corresponding GUID),
        // or if it matches with multiple GUIDs, then we abort.
        //
        if(!SetupDiClassGuidsFromName(ClassName, ClassGuid, 1, &NumGuids) || !NumGuids)
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
IsInternetDriver(
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    )
{
    BOOL InternetDriver = FALSE;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(SetupDiGetSelectedDriver(hDeviceInfo, DeviceInfoData, &DriverInfoData)) {

        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(hDeviceInfo,
                                           DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams
                                           )
            &&
            (DriverInstallParams.Flags & DNF_INET_DRIVER))
        {
            InternetDriver = TRUE;
        }
    }

    return InternetDriver;
}

UINT
QueueCallback(
    IN PVOID     Context,
    IN UINT      Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)Context;

    switch (Notification) {
    
    case SPFILENOTIFY_TARGETNEWER:
        //
        // When doing a driver rollback we expect that some of the files will
        // be older then the files currently on the system since most backups
        // will be of older driver packages.  So when a user does a rollback we
        // will hide the older vs. newer file prompt and always copy the older
        // backed up file.
        //
        if (NewDevWiz->Flags & IDI_FLAG_ROLLBACK) {
            return TRUE;
        }
        break;
        
    case SPFILENOTIFY_STARTCOPY:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_COPY,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;

    case SPFILENOTIFY_STARTRENAME:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_RENAME,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;

    case SPFILENOTIFY_STARTDELETE:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_DELETE,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;

    case SPFILENOTIFY_STARTBACKUP:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_BACKUP,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;
    }

    return SetupDefaultQueueCallback(NewDevWiz->MessageHandlerContext,
                                     Notification,
                                     Param1,
                                     Param2
                                     );
}

LONG
ClassInstallerInstalls(
    HWND hwndParent,
    PNEWDEVWIZ NewDevWiz,
    BOOL BackupOldDrivers,
    BOOL ReadOnlyInstall,
    BOOL DontCreateQueue
    )
{
    DWORD Err = ERROR_SUCCESS;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    DWORD ScanResult = 0;
    int FileQueueNeedsReboot = 0;

    NewDevWiz->MessageHandlerContext = NULL;

    //
    // If we can't create our own queue and we are doing a read-only install
    // then fail with ERROR_ACCESS_DENIED.
    //
    if (DontCreateQueue && ReadOnlyInstall) {
        Err = ERROR_ACCESS_DENIED;
        goto clean0;
    }

    //
    // verify with class installer, and class-specific coinstallers
    // that the driver is not blacklisted. For DIF_ALLOW_INSTALL we
    // accept ERROR_SUCCESS or ERROR_DI_DO_DEFAULT as good return codes.
    //
    if (!SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   ) &&
        (GetLastError() != ERROR_DI_DO_DEFAULT)) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // Create our own queue.
    //
    if (!DontCreateQueue) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (!SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DeviceInstallParams
                                           )) {

            Err = GetLastError();
            goto clean0;
        }

        FileQueue = SetupOpenFileQueue();

        if (FileQueue == INVALID_HANDLE_VALUE) {
           Err = ERROR_NOT_ENOUGH_MEMORY;
           goto clean0;
        }

        DeviceInstallParams.Flags |= DI_NOVCP;
        DeviceInstallParams.FileQueue = FileQueue;

        //
        // Only set the DI_FLAGSEX_PREINSTALLBACKUP flag if we are doing a
        // backup...not in the read only install case.
        //
        if (BackupOldDrivers) {
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_PREINSTALLBACKUP;
        }

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );

        //
        // If the IDI_FLAG_SETRESTOREPOINT flag is set then we want to set the
        // SPQ_FLAG_ABORT_IF_UNSIGNED value on the file queue. With this flag
        // setup setupapi will bail out of the copy if it encounters an unsigned
        // file. At that point we will set a system restore point and then 
        // do the copy. This way the user can back out of an unsigned driver
        // install using system restore.
        //
        // Note that system restore is currently not supported on 64-bit so
        // don't bother setting the SPQ_FLAG_ABORT_IF_UNSIGNED flag.
        //
#ifndef _WIN64
        if (NewDevWiz->Flags & IDI_FLAG_SETRESTOREPOINT) {
            SetupSetFileQueueFlags(FileQueue,
                                   SPQ_FLAG_ABORT_IF_UNSIGNED,
                                   SPQ_FLAG_ABORT_IF_UNSIGNED
                                   );
        }
#endif
    }

    //
    // Install the files first in one shot.
    // This allows new coinstallers to run during the install.
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    if (FileQueue != INVALID_HANDLE_VALUE) {
        //
        // If we created our own FileQueue then we need to
        // scan and possibly commit the queue
        //
        // If we are doing a read only install then we just queued up the files so
        // that we could do a presence check on them. We will throw away the queue
        // so that the files are not copied.
        //
        // Any other install, prune copies as needed
        //
        if (!SetupScanFileQueue(FileQueue,
                                ReadOnlyInstall
                                     ? SPQ_SCAN_FILE_PRESENCE
                                     : (SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE),
                                hwndParent,
                                NULL,
                                NULL,
                                &ScanResult
                                )) {

            //
            // If the API failed then set the ScanResult to 0 (failure).
            //
            ScanResult = 0;
        }

        if (ReadOnlyInstall && (ScanResult != 1)) {
            //
            // ReadOnlyInstall cannot perform copies, deletes or renames
            // bail now!
            //
            Err = ERROR_ACCESS_DENIED;
            goto clean0;
        }

        //
        // We will always commit the file queue, even if we pruned all of the 
        // files.  The reason for this is that backing up of drivers, for 
        // driver rollback, won't work unless the file queue is committed.
        //
        if(NewDevWiz->Flags & IDI_FLAG_ROLLBACK) {
            //
            // Prepare file queue for rollback
            // we need the directory of the INF
            // that's being used for the install
            //
            SP_DRVINFO_DATA        DriverInfoData;
            SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
            DWORD                  RetVal;
            LPTSTR                 pFileName;
            TCHAR                  BackupPath[MAX_PATH];

            DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
            if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         &DriverInfoData)) {

                DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                if (SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                               &NewDevWiz->DeviceInfoData,
                                               &DriverInfoData,
                                               &DriverInfoDetailData,
                                               sizeof(SP_DRVINFO_DETAIL_DATA),
                                               NULL) ||
                            (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                    //
                    // we now have path of INF we're using for the restore
                    //
                    RetVal = GetFullPathName(DriverInfoDetailData.InfFileName,
                                             MAX_PATH,
                                             BackupPath,
                                             &pFileName);
                    if(RetVal && pFileName && (pFileName != BackupPath)) {
                        if(*CharPrev(BackupPath,pFileName)==TEXT('\\')) {
                            pFileName--;
                        }
                        *pFileName = TEXT('\0');
                        //
                        // Prepare queue for rollback
                        // if this fails, carry on, it'll work in a degraded way
                        //
                        SetupPrepareQueueForRestore(FileQueue,BackupPath,0);
                    }
                }
            }
        }

        NewDevWiz->MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                    hwndParent,
                                    (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                        ? INVALID_HANDLE_VALUE : NewDevWiz->hWnd,
                                    WUM_INSTALLPROGRESS,
                                    0,
                                    NULL
                                    );

        if (NewDevWiz->MessageHandlerContext) {
            //
            // Commit the file queue.
            //
            if (!SetupCommitFileQueue(hwndParent,
                                      FileQueue,
                                      QueueCallback,
                                      (PVOID)NewDevWiz
                                      )) {

                Err = GetLastError();

                if (Err == ERROR_SET_SYSTEM_RESTORE_POINT) {
                    UINT RestorePointResourceId;

                    //
                    // If we get back ERROR_SET_SYSTEM_RESTORE_POINT then
                    // we better have the IDI_FLAG_SETRESTOREPOINT flag
                    // set.
                    //
                    ASSERT(NewDevWiz->Flags & IDI_FLAG_SETRESTOREPOINT);

                    if (!(DeviceInstallParams.Flags & DI_QUIETINSTALL) &&
                        NewDevWiz->hWnd) {
                        PostMessage(NewDevWiz->hWnd,
                                    WUM_INSTALLPROGRESS,
                                    INSTALLOP_SETTEXT,
                                    (LPARAM)IDS_SYSTEMRESTORE_TEXT
                                    );
                    }

                    SetupTermDefaultQueueCallback(NewDevWiz->MessageHandlerContext);

                    NewDevWiz->MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                hwndParent,
                                                (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                                    ? INVALID_HANDLE_VALUE : NewDevWiz->hWnd,
                                                WUM_INSTALLPROGRESS,
                                                0,
                                                NULL
                                                );

                    if (NewDevWiz->MessageHandlerContext) {
                        //
                        // Set the system restore point.
                        //
                        if (NewDevWiz->Flags & IDI_FLAG_ROLLBACK) {
                            RestorePointResourceId = IDS_ROLLBACK_SETRESTOREPOINT;                            
                        } else if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                            RestorePointResourceId = IDS_NEW_SETRESTOREPOINT;                            
                        } else {
                            RestorePointResourceId = IDS_UPDATE_SETRESTOREPOINT;                            
                        }

                        pSetSystemRestorePoint(TRUE, FALSE, RestorePointResourceId);

                        NewDevWiz->SetRestorePoint = TRUE;

                        if (!(DeviceInstallParams.Flags & DI_QUIETINSTALL) &&
                            NewDevWiz->hWnd) {
                            PostMessage(NewDevWiz->hWnd,
                                        WUM_INSTALLPROGRESS,
                                        INSTALLOP_SETTEXT,
                                        (LPARAM)NULL
                                        );
                        }

                        //
                        // Clear the SPQ_FLAG_ABORT_IF_UNSIGNED flag so the file
                        // queue will be commited the next time.
                        //
                        SetupSetFileQueueFlags(FileQueue,
                                               SPQ_FLAG_ABORT_IF_UNSIGNED,
                                               0
                                               );

                        //
                        // Now that we have set the restore point and cleared the
                        // SPQ_FLAG_ABORT_IF_UNSIGNED flag from the file queue we
                        // can commit the queue again.
                        //
                        if (!SetupCommitFileQueue(hwndParent,
                                                  FileQueue,
                                                  QueueCallback,
                                                  (PVOID)NewDevWiz
                                                  )) {
                            Err = GetLastError();

                            //
                            // If the error we get is ERROR_CANCELLED then
                            // the user has canceld out of the file copy.
                            // This means that no changes have been made
                            // to the system, so we will tell system
                            // restore to cancel its restore point.
                            //
                            // Also clear the SetRestorePoint BOOL since
                            // we didn't actually set a restore point.
                            //
                            if (Err == ERROR_CANCELLED) {
                                pSetSystemRestorePoint(FALSE, TRUE, 0);
                                NewDevWiz->SetRestorePoint = FALSE;
                            }

                            goto clean0;
                        } else {
                            //
                            // We were successful in commiting the file queue, so check
                            // to see whether a reboot is required as a result of committing
                            // the queue (i.e. because files were in use, or the INF requested
                            // a reboot).
                            //
                            FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
                        }
                    }
                } else {
                    goto clean0;
                }
           } else {
               //
               // We were successful in commiting the file queue, so check
               // to see whether a reboot is required as a result of committing
               // the queue (i.e. because files were in use, or the INF requested
               // a reboot).
               //
               FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
           }
        }

        if (BackupOldDrivers) {
            //
            // If the backup succeeded and we have a UpdateDriverInfo structure
            // then we need to call SetupGetBackupInformation so we can get the
            // registry key that the backup was saved into.
            //
            SP_BACKUP_QUEUE_PARAMS BackupQueueParams;

            BackupQueueParams.cbSize = sizeof(SP_BACKUP_QUEUE_PARAMS);
            if (NewDevWiz->UpdateDriverInfo &&
                SetupGetBackupInformation(FileQueue, &BackupQueueParams)) {

                lstrcpy(NewDevWiz->UpdateDriverInfo->BackupRegistryKey, REGSTR_PATH_REINSTALL);
                lstrcat(NewDevWiz->UpdateDriverInfo->BackupRegistryKey, TEXT("\\"));
                lstrcat(NewDevWiz->UpdateDriverInfo->BackupRegistryKey, BackupQueueParams.ReinstallInstance);
            }
        }
    }

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {
        DWORD FileQueueFlags;
        
        //
        // If we didn't copy any files when commiting the file queue then the
        // SPQ_FLAG_FILES_MODIFIED flag will NOT be set.  In this case set
        // the DI_FLAGSEX_RESTART_DEVICE_ONLY flag so that we only stop/start
        // this single device.  By default setupapi will stop/start this device
        // as well as any other device that was using the same driver/filter 
        // that this device is using.
        //
        if ((FileQueue != INVALID_HANDLE_VALUE) &&
            SetupGetFileQueueFlags(FileQueue, &FileQueueFlags) &&
            !(FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {
            
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
        }

        //
        // Set the DI_NOFILECOPY flag since we already copied the files during
        // the DIF_INSTALLDEVICEFILES, so we don't need to copy them again during
        // the DIF_INSTALLDEVICE.
        //
        DeviceInstallParams.Flags |= DI_NOFILECOPY;
        
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }

    //
    // Register any device-specific co-installers for this device,
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // install any INF/class installer-specified interfaces.
    // and then finally the real "InstallDevice"!
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLINTERFACES,
                                  NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData
                                  )
        ||
        !SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    Err = ERROR_SUCCESS;

clean0:

    if (NewDevWiz->MessageHandlerContext) {
        SetupTermDefaultQueueCallback(NewDevWiz->MessageHandlerContext);
    }

    //
    // If the file queue said that a reboot was needed then set the 
    // DI_NEEDRESTART flag.
    //
    if (FileQueueNeedsReboot) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DeviceInstallParams
                                           )) {

            DeviceInstallParams.Flags |= DI_NEEDRESTART;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }
    }

    if (FileQueue != INVALID_HANDLE_VALUE) {
        //
        // If we have a valid file queue handle and there was an error during
        // the device install then we want to delete any new INFs that were
        // copied into the INF directory.  We do this under the assumption that
        // since there was an error during the install these INFs must be bad.
        //
        if (Err != ERROR_SUCCESS) {
            SetupUninstallNewlyCopiedInfs(FileQueue,
                                          0,
                                          NULL
                                          );
        }

        //
        // Clear out our file queue from the device install params. We need
        // to do this or else SetupCloseFileQueue will fail because it will
        // still have a ref count.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DeviceInstallParams
                                           )) {

            DeviceInstallParams.Flags &= ~DI_NOVCP;
            DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        SetupCloseFileQueue(FileQueue);
    }

    return Err;
}

//
// invokable only from finish page!
//
DWORD
InstallDev(
    HWND       hwndParent,
    PNEWDEVWIZ NewDevWiz
    )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    TCHAR ClassGuidString[MAX_GUID_STRING_LEN];
    GUID ClassGuidInf;
    LPGUID ClassGuid;
    int   ClassGuidNum;
    DWORD Error = ERROR_SUCCESS;
    BOOL IgnoreRebootFlags = FALSE;
    TCHAR Buffer[MAX_PATH*2];
    PVOID pvBuffer = Buffer;
    ULONG DevNodeStatus = 0, Problem = 0;
    DWORD ClassGuidListSize, i;
    BOOL Backup = FALSE;
    BOOL DontCreateQueue = FALSE;

    if (!NewDevWiz->ClassGuidSelected)
    {
        NewDevWiz->ClassGuidSelected = (LPGUID)&GUID_NULL;
    }


    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 ))
    {
        //
        // Get details on this driver node, so that we can examine the INF that this
        // node came from.
        //
        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       &DriverInfoData,
                                       &DriverInfoDetailData,
                                       sizeof(DriverInfoDetailData),
                                       NULL
                                       ))
        {
            Error = GetLastError();
            if (Error != ERROR_INSUFFICIENT_BUFFER)
            {
                goto clean0;
            }
        }

        //
        // Verif that the class is installed, if its not then
        // attempt to install it.
        //
        NdwBuildClassInfoList(NewDevWiz, 0);

        //
        // fetch classguid from inf, (It may be different than what we already
        // have in class guid selected).
        //
        if (!GetClassGuidForInf(DriverInfoDetailData.InfFileName, &ClassGuidInf))
        {
            ClassGuidInf = *NewDevWiz->ClassGuidSelected;
        }

        if (IsEqualGUID(&ClassGuidInf, &GUID_NULL))
        {
            ClassGuidInf = GUID_DEVCLASS_UNKNOWN;
        }

        //
        // if the ClassGuidInf wasn't found then this class hasn't been installed yet.
        // -install the class installer now.
        //
        ClassGuid = NewDevWiz->ClassGuidList;
        ClassGuidNum = NewDevWiz->ClassGuidNum;
        while (ClassGuidNum--)
        {
            if (IsEqualGUID(ClassGuid, &ClassGuidInf))
            {
                break;
            }

            ClassGuid++;
        }

        if (ClassGuidNum < 0 &&
            !SetupDiInstallClass(hwndParent,
                                 DriverInfoDetailData.InfFileName,
                                 NewDevWiz->SilentMode ? DI_QUIETINSTALL : 0,
                                 NULL
                                 ))
        {
            Error = GetLastError();
            goto clean0;
        }
    }

    //
    // No selected driver, and no associated class--use "Unknown" class.
    //
    else
    {
        //
        // If the devnode is currently running 'raw', then remember this
        // fact so that we don't require a reboot later (NULL driver installation
        // isn't going to change anything).
        //
        if (CM_Get_DevNode_Status(&DevNodeStatus,
                                  &Problem,
                                  NewDevWiz->DeviceInfoData.DevInst,
                                  0) == CR_SUCCESS)
        {
            if (!SetupDiGetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  SPDRP_SERVICE,
                                                  NULL,     // regdatatype
                                                  pvBuffer,
                                                  sizeof(Buffer),
                                                  NULL
                                                  ))
            {
                *Buffer = TEXT('\0');
            }

            if((DevNodeStatus & DN_STARTED) && (*Buffer == TEXT('\0')))
            {
                IgnoreRebootFlags = TRUE;
            }
        }

        if (IsEqualGUID(NewDevWiz->ClassGuidSelected, &GUID_NULL))
        {

            pSetupStringFromGuid(&GUID_DEVCLASS_UNKNOWN,
                                 ClassGuidString,
                                 sizeof(ClassGuidString)/sizeof(TCHAR)
                                 );


            SetupDiSetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDRP_CLASSGUID,
                                             (PBYTE)ClassGuidString,
                                             sizeof(ClassGuidString)
                                             );
        }

        ClassGuidInf = *NewDevWiz->ClassGuidSelected;
    }

    //
    // We will backup the current drivers in all cases except if any of the following are true:
    //
    //  1) The device is a printer
    //  2) The selected driver is the currently installed driver
    //  3) The DontBackupCurrentDrivers NEWDEVWIZ BOOL is TRUE
    //  4) The device has a problem
    //
    if (IsEqualGUID(&ClassGuidInf, &GUID_DEVCLASS_PRINTER) ||
        IsInstalledDriver(NewDevWiz, NULL) ||
        (NewDevWiz->Flags & IDI_FLAG_NOBACKUP) ||
        ((CM_Get_DevNode_Status(&DevNodeStatus, &Problem, NewDevWiz->DeviceInfoData.DevInst, 0) == CR_SUCCESS) &&
         ((DevNodeStatus & DN_HAS_PROBLEM) ||
          (DevNodeStatus & DN_PRIVATE_PROBLEM)))) {

        Backup = FALSE;

    } else {

        Backup = TRUE;
    }

    //
    // We will always create our own queue during device install, except in the
    // following specific cases.
    //
    // 1) The device is a printer
    //
    // Note that if we can't create our own queue then we cannot do any of the 
    // operations that need a queue, like backup, rollback, read-only install,
    // or setting a restore point.
    //
    DontCreateQueue = IsEqualGUID(&ClassGuidInf, & GUID_DEVCLASS_PRINTER);

    Error = ClassInstallerInstalls(hwndParent,
                                   NewDevWiz,
                                   Backup,
                                   (NewDevWiz->Flags & IDI_FLAG_READONLY_INSTALL),
                                   DontCreateQueue
                                   );

    //
    // If this is a WU/CDM install and it was successful then set
    // the DriverWasUpgraded to TRUE
    //
    if (NewDevWiz->UpdateDriverInfo && (Error == ERROR_SUCCESS)) {

        NewDevWiz->UpdateDriverInfo->DriverWasUpgraded = TRUE;
    }

    //
    // If this is a new device (currently no drivers are installed) and we encounter
    // an error that is not ERROR_CANCELLED then we will install the NULL driver for
    // this device and set the FAILED INSTALL flag.
    //
    if ((Error != ERROR_SUCCESS) &&
        (Error != ERROR_CANCELLED))
    {
        if (IsNullDriverInstalled(NewDevWiz->DeviceInfoData.DevInst)) {

            if (SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL
                                         ))
            {
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &DeviceInstallParams
                                                  ))
                {
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
                    SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &DeviceInstallParams
                                                  );
                }

                SetupDiInstallDevice(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData);
            }
        }

        goto clean0;
    }

    //
    // See if the device needs to the system to be restarted before it will work.
    //
    if(!IgnoreRebootFlags) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ) &&
            (DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {
            //
            // If either the DI_NEEDRESTART or the DI_NEEDREBOOT DeviceInstallParams
            // flag is set, then a restart is needed.
            //
            NewDevWiz->Reboot |= DI_NEEDREBOOT;
        
        } else if ((CM_Get_DevNode_Status(&DevNodeStatus,
                                          &Problem,
                                          NewDevWiz->DeviceInfoData.DevInst,
                                          0) == CR_SUCCESS) &&
                   (DevNodeStatus & DN_NEED_RESTART) ||
                   (Problem == CM_PROB_NEED_RESTART)) {
            //
            // If the DN_NEED_RESTART devnode status flag is set, then a restart
            // is needed.
            //
            NewDevWiz->Reboot |= DI_NEEDREBOOT;
        }
    }


clean0:

    return Error;
}

DWORD
InstallNullDriver(
    HWND  hDlg,
    PNEWDEVWIZ NewDevWiz,
    BOOL FailedInstall
    )
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;
    DWORD  Err = ERROR_SUCCESS;

    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    //
    // Set the DI_FLAGSEX_SETFAILEDINSTALL flag if this is a failed
    // install.
    //
    if (FailedInstall)
    {
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DevInstallParams
                                          ))
        {
            DevInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DevInstallParams
                                          );
        }
    }

    //
    // Set the selected driver to NULL
    //
    if (SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 NULL
                                 ))
    {
        //
        // verify with class installer, and class-specific coinstallers
        // that the driver is not blacklisted. For DIF_ALLOW_INSTALL we
        // accept ERROR_SUCCESS or ERROR_DI_DO_DEFAULT as good return codes.
        //
        if (SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                      NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData
                                      ) ||
            (GetLastError() == ERROR_DI_DO_DEFAULT)) {

            //
            // If the class/co-installers gave the OK then call DIF_INSTALLDEVICE.
            //
            if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                           NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData
                                           )) {
                Err = GetLastError();
            }

        } else {
            Err = GetLastError();
        }
    }

    return Err;

} // InstallNullDriver


BOOL
CALLBACK
AddPropSheetPageProc(
    IN HPROPSHEETPAGE hpage,
    IN LPARAM lParam
   )
{
    *((HPROPSHEETPAGE *)lParam) = hpage;
    return TRUE;
}

void
DisplayResource(
     PNEWDEVWIZ NewDevWiz,
     HWND hWndParent
     )
{
    HINSTANCE hLib;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsPages[1];
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    LPFNADDPROPSHEETPAGES ExtensionPropSheetPage = NULL;
    LPTSTR Title;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Now get the resource selection page from setupapi.dll
    //

    hLib = GetModuleHandle(TEXT("setupapi.dll"));
    if (hLib)
    {
        ExtensionPropSheetPage = (PVOID)GetProcAddress(hLib, "ExtensionPropSheetPageProc");
    }

    if (!ExtensionPropSheetPage)
    {
        return;
    }

    PropPageRequest.cbSize = sizeof(SP_PROPSHEETPAGE_REQUEST);
    PropPageRequest.PageRequested  = SPPSR_SELECT_DEVICE_RESOURCES;
    PropPageRequest.DeviceInfoSet  = NewDevWiz->hDeviceInfo;
    PropPageRequest.DeviceInfoData = &NewDevWiz->DeviceInfoData;

    if (!ExtensionPropSheetPage(&PropPageRequest,
                                AddPropSheetPageProc,
                                (LONG_PTR)hpsPages
                                ))
    {
        // warning ?
        return;
    }

    //
    // create the property sheet
    //

    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    psh.hwndParent  = hWndParent;
    psh.hInstance   = hNewDev;
    psh.pszIcon     = NULL;

    switch (NewDevWiz->InstallType) {

        case NDWTYPE_FOUNDNEW:
            Title = (LPTSTR)IDS_FOUNDDEVICE;
            break;

        case NDWTYPE_UPDATE:
            Title = (LPTSTR)IDS_UPDATEDEVICE;
            break;

        default:
            Title = TEXT(""); // unknown
        }

    psh.pszCaption  = Title;

    psh.nPages      = 1;
    psh.phpage      = hpsPages;
    psh.nStartPage  = 0;
    psh.pfnCallback = NULL;


    //
    // Clear the Propchange pending bit in the DeviceInstall params.
    //

    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DevInstallParams
                                      ))
    {
        DevInstallParams.FlagsEx &= ~DI_FLAGSEX_PROPCHANGE_PENDING;
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DevInstallParams
                                      );
    }

    if (PropertySheet(&psh) == -1)
    {
        DestroyPropertySheetPage(hpsPages[0]);
    }


    //
    // If a PropChange occurred invoke the DIF_PROPERTYCHANGE
    //

    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DevInstallParams
                                      ))
    {
        if (DevInstallParams.FlagsEx & DI_FLAGSEX_PROPCHANGE_PENDING)
        {
            SP_PROPCHANGE_PARAMS PropChangeParams;

            PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            PropChangeParams.Scope = DICS_FLAG_GLOBAL;
            PropChangeParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                             sizeof(PropChangeParams)
                                             ))
            {
                SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                          NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData
                                          );
            }

            //
            // Clear the class install parameters.
            //

            SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL,
                                         0
                                         );
        }
    }


    return;
}

DWORD WINAPI
InstallDevThreadProc(
    LPVOID lpVoid
    )
/*++

Description:

    In the Wizard, we will do the driver installation in a separate thread so that the user
    will see the driver instal wizard page.

--*/
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)lpVoid;

    //
    // Do the device install
    //
    NewDevWiz->LastError = InstallDev(NewDevWiz->hWnd, NewDevWiz);

    //
    // Post a message to the window to let it know that we are finished with the install
    //
    PostMessage(NewDevWiz->hWnd, WUM_INSTALLCOMPLETE, TRUE, GetLastError());

    return GetLastError();
}

INT_PTR CALLBACK
NDW_InstallDevDlgProc(
                     HWND hDlg,
                     UINT wMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    LONG Error;
    ULONG DevNodeStatus, Problem;
    static HANDLE DeviceInstallThread = NULL;
    TCHAR Text1[MAX_PATH], Text2[MAX_PATH], Target[MAX_PATH], Format[MAX_PATH];
    PTSTR p;

    switch (wMsg) {

    case WM_INITDIALOG: {

            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

            break;
        }

    case WM_DESTROY:
        break;

    case WUM_INSTALLCOMPLETE:
        //
        // This message is posted to the window when the device installation is complete.
        //
        WaitForSingleObject(DeviceInstallThread, INFINITE);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL));
        NewDevWiz->CurrCursor = NULL;
        PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
        break;

    case WUM_INSTALLPROGRESS:
        Text1[0] = Text2[0] = TEXT('\0');

        //
        // This is the message that is sent from setupapi so we can display our
        // own copy progress. 
        //
        // If wParam is 0 then the lParam is the number of files that will be
        // copied.
        // If wParam is 1 then that is a tick for a single file being copied,
        // so the progress bar should be advanced.
        //
        switch (wParam) {
        case 0:
            ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT2), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_HIDE);
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT1, TEXT(""));
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT2, TEXT(""));
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_SETRANGE,0,MAKELPARAM(0,lParam));
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_SETSTEP,1,0);
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_SETPOS,0,0);
            break;
        case 1:
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_STEPIT,0,0);
            break;

        case INSTALLOP_COPY:
            lstrcpyn(Target, ((PFILEPATHS)lParam)->Target, MAX_PATH);
            if (p = _tcsrchr(Target,TEXT('\\'))) {
                *p++ = 0;
                lstrcpyn(Text1, p, MAX_PATH);
                if (LoadString(hNewDev, IDS_FILEOP_TO, Format, SIZECHARS(Format))) {
                    _snwprintf(Text2, MAX_PATH, Format, Target);
                }
            } else {
                lstrcpyn(Text1, ((PFILEPATHS)lParam)->Target, MAX_PATH);
                lstrcpy(Text2, TEXT(""));
            }
            break;

        case INSTALLOP_RENAME:
            lstrcpyn(Text1, ((PFILEPATHS)lParam)->Source, MAX_PATH);
            if (p = _tcsrchr(((PFILEPATHS)lParam)->Target, TEXT('\\'))) {
                p++;
            } else {
                p = (PTSTR)((PFILEPATHS)lParam)->Target;
            }
            if (LoadString(hNewDev, IDS_FILEOP_TO, Format, SIZECHARS(Format))) {
                _snwprintf(Text2, MAX_PATH, Format, p);
            }
            break;

        case INSTALLOP_DELETE:
            lstrcpyn(Target, ((PFILEPATHS)lParam)->Target, MAX_PATH);
            if (p = _tcsrchr(Target,TEXT('\\'))) {
                *p++ = 0;
                lstrcpyn(Text1, p, MAX_PATH);
                if (LoadString(hNewDev, IDS_FILEOP_FROM, Format, SIZECHARS(Format))) {
                    _snwprintf(Text2, MAX_PATH, Format, Target);
                }
            } else {
                lstrcpyn(Text1, ((PFILEPATHS)lParam)->Target, MAX_PATH);
                lstrcpy(Text2, TEXT(""));
            }
            break;

        case INSTALLOP_BACKUP:
            lstrcpyn(Target, ((PFILEPATHS)lParam)->Source, MAX_PATH);
            if (p = _tcsrchr(Target,TEXT('\\'))) {
                *p++ = 0;
                if (((PFILEPATHS)lParam)->Target == NULL) {
                    if (LoadString(hNewDev, IDS_FILEOP_BACKUP, Format, SIZECHARS(Format))) {
                        _snwprintf(Text1, MAX_PATH, Format, p);
                    }
                } else {
                    lstrcpyn(Text1, p, MAX_PATH);
                }
                lstrcpyn(Text2, Target, MAX_PATH);
            } else {
                if (LoadString(hNewDev, IDS_FILEOP_BACKUP, Format, SIZECHARS(Format))) {
                    _snwprintf(Text1, MAX_PATH, Format, Target);
                }
                lstrcpy(Text2, TEXT(""));
            }
            break;

        case INSTALLOP_SETTEXT:
            ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_HIDE);

            if (lParam) {
                if (LoadString(hNewDev, (UINT)lParam, Text2, SIZECHARS(Text2))) {
                    ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_SHOW);
                    SetDlgItemText(hDlg, IDC_STATUS_TEXT, Text2);
                }
            } else {
                SetDlgItemText(hDlg, IDC_STATUS_TEXT, TEXT(""));
            }
            Text1[0] = TEXT('\0');
            Text2[0] = TEXT('\0');
            break;
        }

        if ((Text1[0] != TEXT('\0')) && (Text2[0] != TEXT('\0'))) {
            ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT2), SW_SHOW);
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT1, Text1);
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT2, Text2);
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {

                HICON hicon;
                SP_DRVINFO_DATA DriverInfoData;

                NewDevWiz->PrevPage = IDD_NEWDEVWIZ_INSTALLDEV;

                //
                // This is an intermediary status page, no buttons needed.
                // Set the device description
                // Set the class Icon
                //
                PropSheet_SetWizButtons(hwndParentDlg, 0);
                EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT2), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_HIDE);

                SetDriverDescription(hDlg, IDC_NDW_DESCRIPTION, NewDevWiz);

                if (SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                    hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                    if (hicon) {
                        DestroyIcon(hicon);
                    }
                }

                NewDevWiz->CurrCursor = NewDevWiz->IdcWait;
                SetCursor(NewDevWiz->CurrCursor);

                //
                // If we are doing a silent install then do the actual install here in the PSN_SETACTIVE.
                // Doing the install here means that this wizard page will never be displayed.  When we
                // are finished calling InstallDev() then we will jump to any FinishInstall pages that
                // the class/co-installers have added, or we will jump to our finish page.
                //
                if (NewDevWiz->SilentMode) {
                    //
                    // do the Install immediately and move to the next page
                    // to prevent any UI from showing.
                    //
                    NewDevWiz->hWnd = NULL;
                    NewDevWiz->LastError =InstallDev(hDlg, NewDevWiz);
                    NewDevWiz->CurrCursor = NULL;


                    //
                    // Add the FinishInstall Page and jump to it if the install was successful
                    //
                    if (NewDevWiz->LastError == ERROR_SUCCESS) {

                        NewDevWiz->WizExtFinishInstall.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL,
                                                                                     WizExtFinishInstallDlgProc,
                                                                                     NewDevWiz
                                                                                    );

                        if (NewDevWiz->WizExtFinishInstall.hPropSheet) {

                            PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtFinishInstall.hPropSheet);
                        }

                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_FINISHINSTALL);

                    } else {

                        //
                        // There was an error during the install so just jump to our finish page
                        //
                        SetDlgMsgResult(hDlg, wMsg, -1);
                    }
                }

                //
                // Post ourselves a msg, to do the actual install, this allows this
                // page to show itself while the install is actually occuring.
                //
                else {
                    DWORD ThreadId;
                    NewDevWiz->hWnd = hDlg;

                    ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL), SW_SHOW);
                    Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL), MAKEINTRESOURCE(IDA_INSTALLING));
                    Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL), 0, -1, -1);

                    //
                    // Start up a separate thread to do the device installation on.
                    // When the driver installation is complete the InstallDevThreadProc
                    // will post us a WUM_INSTALLCOMPLETE message.
                    //
                    DeviceInstallThread = CreateThread(NULL,
                                                       0,
                                                       (LPTHREAD_START_ROUTINE)InstallDevThreadProc,
                                                       (LPVOID)NewDevWiz,
                                                       0,
                                                       &ThreadId
                                                      );

                    //
                    // If the CreateThread fails then we will just call InstallDev() ourselves.
                    //
                    if (!DeviceInstallThread) {

                        NewDevWiz->hWnd = NULL;

                        //
                        // Do the device install
                        //
                        NewDevWiz->LastError = InstallDev(NewDevWiz->hWnd, NewDevWiz);

                        //
                        // Post a message to the window to let it know that we are finished with the install
                        //
                        PostMessage(hDlg, WUM_INSTALLCOMPLETE, TRUE, GetLastError());
                    }
                }

                break;
            }

        case PSN_WIZNEXT:

            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL));

            //
            // Add the FinishInstall Page and jump to it if the installation succeded.
            //
            if (NewDevWiz->LastError == ERROR_SUCCESS) {

                NewDevWiz->WizExtFinishInstall.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL,
                                                                             WizExtFinishInstallDlgProc,
                                                                             NewDevWiz
                                                                            );

                if (NewDevWiz->WizExtFinishInstall.hPropSheet) {
                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtFinishInstall.hPropSheet);
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_FINISHINSTALL);

            } else {

                //
                // There was an error during the install so just jump to our finish page
                //
                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_FINISH);
            }
            break;
        }
        break;


    case WM_SETCURSOR:
        if (NewDevWiz->CurrCursor) {
            SetCursor(NewDevWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

void
ShowInstallSummary(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    LONG Error;
    CONFIGRET ConfigRet;
    ULONG Len, Problem, DevNodeStatus;
    BOOL HasResources;
    HWND hwndParentDlg = GetParent(hDlg);
    PTCHAR ErrorMsg, ProblemText;
    TCHAR TextBuffer[MAX_PATH*4];


    Problem = 0;
    *TextBuffer = TEXT('\0');

    Error = NewDevWiz->LastError;

    //
    // On Windows Update installs we don't want to show any UI at all, even
    // if there was an error during the installation.
    // We can tell a WU install from a CDM install because only a WU install
    // has a UpdateDriverInfo structure and is SilentMode.
    // We also never want to show the finish page if this is a NonInteractive
    // install.
    //
    if ((NewDevWiz->SilentMode &&
        NewDevWiz->UpdateDriverInfo) ||
        NewDevWiz->Flags & IDI_FLAG_NONINTERACTIVE)
    {
        HideWindowByMove(hwndParentDlg);
        PropSheet_PressButton(hwndParentDlg, PSBTN_FINISH);
        return;
    }

    if (NewDevWiz->hfontTextBigBold) {
        SetWindowFont(GetDlgItem(hDlg, IDC_FINISH_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
    }

    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {
        SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_UPGRADE, IDS_FINISH_MSG1_UPGRADE);

    } else {
        SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_NEW, IDS_FINISH_MSG1_NEW);
    }

    //
    // Installation failed
    //
    if (Error != ERROR_SUCCESS) {
        NewDevWiz->Installed = FALSE;

        SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_INSTALL_PROBLEM, IDS_FINISH_MSG1_INSTALL_PROBLEM);
        SetDlgText(hDlg, IDC_FINISH_MSG2, IDS_FINISH_PROB_MSG2, IDS_FINISH_PROB_MSG2);

#if DBG
        DbgPrint("InstallDev Error =%x\n", Error);
#endif

        //
        // Display failure message for installation
        //
        // We will special case the following error codes so we can give a more
        // friendly description of the problem to the user:
        //
        // TRUST_E_SUBJECT_FORM_UNKNOWN
        // ERROR_NO_ASSOCIATED_SERVICE
        // TYPE_E_ELEMENTNOTFOUND
        // ERROR_NOT_FOUND
        //
        if ((Error == TRUST_E_SUBJECT_FORM_UNKNOWN) ||
            (Error == CERT_E_EXPIRED) ||
            (Error == TYPE_E_ELEMENTNOTFOUND) ||
            (Error == ERROR_NOT_FOUND)) {

            LoadText(TextBuffer,
                     sizeof(TextBuffer),
                     IDS_FINISH_PROB_TRUST_E_SUBJECT_FORM_UNKNOWN,
                     IDS_FINISH_PROB_TRUST_E_SUBJECT_FORM_UNKNOWN);

        } else if (Error == ERROR_NO_ASSOCIATED_SERVICE) {

            LoadText(TextBuffer,
                     sizeof(TextBuffer),
                     IDS_FINISH_PROB_ERROR_NO_ASSOCIATED_SERVICE,
                     IDS_FINISH_PROB_ERROR_NO_ASSOCIATED_SERVICE);

        } else {

            LoadText(TextBuffer, sizeof(TextBuffer), IDS_NDW_ERRORFIN1_PNP, IDS_NDW_ERRORFIN1_PNP);

            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              HRESULT_FROM_SETUPAPI(Error),
                              0,
                              (LPTSTR)&ErrorMsg,
                              0,
                              NULL
                              ))
            {
                lstrcat(TextBuffer, TEXT("\n\n"));
                lstrcat(TextBuffer, ErrorMsg);
                LocalFree(ErrorMsg);
            }
        }

        SetDlgItemText(hDlg, IDC_FINISH_MSG3, TextBuffer);
    }

    //
    // No errors installing the drivers for this device
    //
    else {
        //
        // Check to see if the device itself has any problems
        //
        Error = CM_Get_DevNode_Status(&DevNodeStatus,
                                      &Problem,
                                      NewDevWiz->DeviceInfoData.DevInst,
                                      0
                                      );
        if(Error != CR_SUCCESS) {
            //
            // For some reason, we couldn't retrieve the devnode's status.
            // Default status and problem values to zero.
            //
            DevNodeStatus = Problem = 0;
        }

        //
        // make sure the reboot flags\Problem are set correctly
        //
        if (NewDevWiz->Reboot || Problem == CM_PROB_NEED_RESTART) {
            if (Problem != CM_PROB_PARTIAL_LOG_CONF) {
                Problem = CM_PROB_NEED_RESTART;
            }

            NewDevWiz->Reboot |= DI_NEEDREBOOT;
        }


        NewDevWiz->Installed = TRUE;
        HasResources = DeviceHasResources(NewDevWiz->DeviceInfoData.DevInst);

        //
        // The device has a problem
        //
        if ((Error != CR_SUCCESS) || Problem) {
            //
            // If we are going to launch the troubleshooter then change the finish text.
            //
            // We currently launch the troubleshooter if the device has some type of problem,
            // unless the problem is CM_PROB_NEED_RESTART.
            //
            if (Problem && (Problem != CM_PROB_NEED_RESTART)) {

                SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_DEVICE_PROBLEM, IDS_FINISH_MSG1_DEVICE_PROBLEM);
                SetDlgText(hDlg, IDC_FINISH_MSG2, IDS_FINISH_PROB_MSG2, IDS_FINISH_PROB_MSG2);

                NewDevWiz->LaunchTroubleShooter = TRUE;
                SetDlgText(hDlg, IDC_FINISH_MSG4, IDS_FINISH_PROB_MSG4, IDS_FINISH_PROB_MSG4);
            }

            //
            // Show the resource button if the device has resources and it
            // has the problem CM_PROB_PARTIAL_LOG_CONF
            //
            if (HasResources && (Problem == CM_PROB_PARTIAL_LOG_CONF)) {
                ShowWindow(GetDlgItem(hDlg, IDC_NDW_DISPLAYRESOURCE), SW_SHOW);
            }

            if (Problem == CM_PROB_NEED_RESTART) {
                LoadText(TextBuffer, sizeof(TextBuffer), IDS_NEEDREBOOT, IDS_NEEDREBOOT);
            }

            else if (Problem) {
                ProblemText = DeviceProblemText(NULL,
                                                NewDevWiz->DeviceInfoData.DevInst,
                                                Problem
                                                );

                if (ProblemText) {
                    lstrcat(TextBuffer, TEXT("\n\n"));
                    lstrcat(TextBuffer, ProblemText);
                    LocalFree(ProblemText);
                }
            }

#if DBG
            DbgPrint("InstallDev CM_Get_DevNode_Status()=%x DevNodeStatus=%x Problem=%x\n",
                     Error,
                     DevNodeStatus,
                     Problem
                     );
#endif

        }

        //
        // Installation was sucessful and the device does not have any problems
        //
        else {
            //
            // If this was a silent install (a Rank 0 match for example) then don't show the finish
            // page.
            //
            if (NewDevWiz->SilentMode) {
                HideWindowByMove(hwndParentDlg);
                PropSheet_PressButton(hwndParentDlg, PSBTN_FINISH);
                return;
            }
        }

        SetDlgItemText(hDlg, IDC_FINISH_MSG3, TextBuffer);
    }
}

INT_PTR CALLBACK
NDW_FinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
    case WM_INITDIALOG:
        {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

            break;
        }

    case WM_DESTROY:
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_NDW_DISPLAYRESOURCE:
            DisplayResource(NewDevWiz, GetParent(hDlg));
            break;
        }

        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE: {
            HICON hicon;
            SP_DRVINFO_DATA DriverInfoData;


            //
            // No back button since install is already done.
            // set the device description
            // Hide Resources button until we know if resources exist or not.
            // Set the class Icon
            //
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

            EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), FALSE);

            ShowWindow(GetDlgItem(hDlg, IDC_NDW_DISPLAYRESOURCE), SW_HIDE);

            if (NewDevWiz->LastError == ERROR_CANCELLED) {

                if (NewDevWiz->SilentMode)
                {
                    HideWindowByMove(GetParent(hDlg));
                }

                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);

            } else {

                SetDriverDescription(hDlg, IDC_NDW_DESCRIPTION, NewDevWiz);

                if (SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                    hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                    if (hicon) {
                        DestroyIcon(hicon);
                    }
                }

                ShowInstallSummary(hDlg, NewDevWiz);
            }
            break;
        }

        case PSN_RESET:
            break;


        case PSN_WIZFINISH:
            if (NewDevWiz->LaunchTroubleShooter) {

                //
                // The command line that we will run is:
                // rundll32 devmgr.dll, DeviceProblenWizard_RunDLL /deviceid %s
                // where %s is the device instance id.
                //
                TCHAR szCmdLine[512];
                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

                if (CM_Get_Device_ID(NewDevWiz->DeviceInfoData.DevInst,
                                     DeviceInstanceId,
                                     sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                     0
                                     ) == CR_SUCCESS) {

                    wsprintf(szCmdLine, TEXT("devmgr.dll,DeviceProblenWizard_RunDLL /deviceid %s"),
                             DeviceInstanceId);

                    ShellExecute(NULL,
                                 TEXT("open"),
                                 TEXT("RUNDLL32.EXE"),
                                 szCmdLine,
                                 NULL,
                                 SW_SHOWNORMAL
                                 );
                }
            }
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtFinishInstallDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {

    case WM_INITDIALOG: {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL;

            if (PrevPageId == IDD_NEWDEVWIZ_INSTALLDEV)
            {
                PROPSHEETPAGE psp;
                HPROPSHEETPAGE hPage = NULL;

                //
                // Moving forward on first page
                //

                //
                // If this was a silent install and NOT a NonInteractive install
                // then we need to create the FinishInstallIntro page at this
                // point so we can add it to the wizard. We do this so the wizard
                // has a proper intro and finish page with the FinishInstall
                // pages inbetween.
                //
                if (NewDevWiz->SilentMode &&
                    !(NewDevWiz->Flags & IDI_FLAG_NONINTERACTIVE)) {

                    ZeroMemory(&psp, sizeof(PROPSHEETPAGE));
                    psp.dwSize = sizeof(PROPSHEETPAGE);
                    psp.hInstance = hNewDev;
                    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
                    psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_FINISHINSTALL_INTRO);
                    psp.pfnDlgProc = FinishInstallIntroDlgProc;
                    psp.lParam = (LPARAM)NewDevWiz;

                    hPage = CreatePropertySheetPage(&psp);
                }

                //
                // Add ClassWizard Extension pages for FinishInstall
                //
                if (AddClassWizExtPages(hwndParentDlg,
                                        NewDevWiz,
                                        &NewDevWiz->WizExtFinishInstall.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                                        hPage
                                        )) {

                    //
                    // If this is a NonInteractive install then we need to set the last
                    // error at this point so the error is propagated back to the original
                    // caller.
                    //
                    if (NewDevWiz->Flags & IDI_FLAG_NONINTERACTIVE) {

                        NewDevWiz->LastError = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;

                    } else {

                        //
                        // If we have finish install pages then we should also show the finish
                        // page.
                        //
                        NewDevWiz->SilentMode = FALSE;
                    }
                }

                //
                // Add the end page, which is FinishInstall end
                //
                NewDevWiz->WizExtFinishInstall.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL_END,
                                                                                WizExtFinishInstallEndDlgProc,
                                                                                NewDevWiz
                                                                                );

                if (NewDevWiz->WizExtFinishInstall.hPropSheetEnd)
                {
                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtFinishInstall.hPropSheetEnd);
                }
            }


            //
            // We can't go backwards, so always go forward
            //

            SetDlgMsgResult(hDlg, wMsg, -1);
            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtFinishInstallEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;


    switch (wMsg) {

    case WM_INITDIALOG: {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL_END;

           //
           // We can't go backwards, so always go forward
           //

           SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_FINISH);
           break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\lib\umpnplib.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    umpnplib.h

Abstract:

    This module contains the private prototype defintions for routines contained
    in the statically linked library that is shared by both the Configuration
    Manager client DLL and User-Mode Plug and Play manager server DLL.

Author:

    Jim Cavalaris (jamesca) 02/27/2001

Environment:

    User mode only.

Revision History:

    27-February-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _UMPNPLIB_H_
#define _UMPNPLIB_H_


//-------------------------------------------------------------------
// Common private utility routines (used by client and server)
//-------------------------------------------------------------------

BOOL
IsLegalDeviceId(
    IN  LPCWSTR    pszDeviceInstance
    );

BOOL
SplitDeviceInstanceString(
    IN  LPCWSTR    pszDeviceInstance,
    OUT LPWSTR     pszBase,
    OUT LPWSTR     pszDeviceID,
    OUT LPWSTR     pszInstanceID
    );

CONFIGRET
DeletePrivateKey(
    IN  HKEY       hBranchKey,
    IN  LPCWSTR    pszParentKey,
    IN  LPCWSTR    pszChildKey
    );

BOOL
RegDeleteNode(
    IN  HKEY       hParentKey,
    IN  LPCWSTR    szKey
    );

BOOL
Split1(
    IN  LPCWSTR    pszString,
    OUT LPWSTR     pszString1,
    OUT LPWSTR     pszString2
    );

BOOL
Split2(
    IN  LPCWSTR    pszString,
    OUT LPWSTR     pszString1,
    OUT LPWSTR     pszString2
    );

CONFIGRET
GetDevNodeKeyPath(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pDeviceID,
    IN  ULONG      ulFlags,
    IN  ULONG      ulHardwareProfile,
    OUT LPWSTR     pszBaesKey,
    OUT LPWSTR     pszPrivateKey
    );

CONFIGRET
MapRpcExceptionToCR(
    ULONG          ulRpcExceptionCode
    );


//-------------------------------------------------------------------
// Generic (private) locking support
//-------------------------------------------------------------------

//
// Locking functions. These functions are used to make various parts of
// the DLL multithread-safe. The basic idea is to have a mutex and an event.
// The mutex is used to synchronize access to the structure being guarded.
// The event is only signalled when the structure being guarded is destroyed.
// To gain access to the guarded structure, a routine waits on both the mutex
// and the event. If the event gets signalled, then the structure was destroyed.
// If the mutex gets signalled, then the thread has access to the structure.
//

#define DESTROYED_EVENT 0
#define ACCESS_MUTEX    1

typedef struct _LOCKINFO {
    //
    // DESTROYED_EVENT, ACCESS_MUTEX
    //
    HANDLE  LockHandles[2];
} LOCKINFO, *PLOCKINFO;

BOOL
InitPrivateResource(
    OUT    PLOCKINFO  Lock
    );

VOID
DestroyPrivateResource(
    IN OUT PLOCKINFO  Lock
    );

BOOL
__inline
LockPrivateResource(
    IN     PLOCKINFO  Lock
    )
{
    DWORD d = WaitForMultipleObjects(2,
                                     Lock->LockHandles,
                                     FALSE,
                                     INFINITE);
    //
    // Success if the mutex object satisfied the wait;
    // Failure if the table destroyed event satisified the wait, or
    // the mutex was abandoned, etc.
    //
    return ((d - WAIT_OBJECT_0) == ACCESS_MUTEX);
}

VOID
__inline
UnlockPrivateResource(
    IN     PLOCKINFO  Lock
    )
{
    ReleaseMutex(Lock->LockHandles[ACCESS_MUTEX]);
}


//-------------------------------------------------------------------
// Defines and typedefs needed for logconf routines
//-------------------------------------------------------------------

#include "pshpack1.h"   // set to 1-byte packing

//
// DEFINES REQUIRED FOR PARTIAL (SUR) IMPLEMENTATION OF LOG_CONF and RES_DES
//
// We only allow one logical config (the BOOT_LOG_CONF) for SUR so no need
// to keep track of multiple log confs, this will all change for Cairo.
//
typedef struct Private_Log_Conf_Handle_s {
   ULONG    LC_Signature;           // CM_PRIVATE_LOGCONF_HANDLE
   DEVINST  LC_DevInst;
   ULONG    LC_LogConfType;
   ULONG    LC_LogConfTag;  //LC_LogConfIndex;
} Private_Log_Conf_Handle, *PPrivate_Log_Conf_Handle;

typedef struct Private_Res_Des_Handle_s {
   ULONG       RD_Signature;        // CM_PRIVATE_RESDES_HANDLE
   DEVINST     RD_DevInst;
   ULONG       RD_LogConfType;
   ULONG       RD_LogConfTag;   //RD_LogConfIndex;
   RESOURCEID  RD_ResourceType;
   ULONG       RD_ResDesTag;    //RD_ResDesIndex;
} Private_Res_Des_Handle, *PPrivate_Res_Des_Handle;

typedef struct Generic_Des_s {
   DWORD    GENERIC_Count;
   DWORD    GENERIC_Type;
} GENERIC_DES, *PGENERIC_DES;

typedef struct Generic_Resource_S {
   GENERIC_DES    GENERIC_Header;
} GENERIC_RESOURCE, *PGENERIC_RESOURCE;

typedef struct  Private_Log_Conf_s {
   ULONG           LC_Flags;       // Type of log conf
   ULONG           LC_Priority;    // Priority of log conf
   CS_RESOURCE     LC_CS;          // First and only res-des, class-specific
} Private_Log_Conf, *PPrivate_Log_Conf;

#include "poppack.h"    // restore to default packing


//-------------------------------------------------------------------
// Defines and typedefs needed for range routines
//-------------------------------------------------------------------

typedef struct Range_Element_s {
   ULONG_PTR    RL_Next;
   ULONG_PTR    RL_Header;
   DWORDLONG    RL_Start;
   DWORDLONG    RL_End;
} Range_Element, *PRange_Element;

typedef struct Range_List_Hdr_s {
   ULONG_PTR RLH_Head;
   ULONG_PTR RLH_Header;
   ULONG    RLH_Signature;
   LOCKINFO RLH_Lock;
} Range_List_Hdr, *PRange_List_Hdr;

#define Range_List_Signature     0x5959574D


#endif // _UMPNPLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\newdev.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       newdev.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <initguid.h>

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

typedef
BOOL
(*PINSTALLNEWDEVICE)(
    HWND hwndParent,
    LPGUID ClassGuid,
    PDWORD pReboot
    );

WNDPROC           g_OldWizardProc;
PINSTALLNEWDEVICE pInstallNewDevice = NULL;
int g_BlankIconIndex;

typedef struct _NewDevWizPropertySheet {
    PROPSHEETHEADER   PropSheetHeader;
    HPROPSHEETPAGE    PropSheetPages[16];
} NDWPROPERTYSHEET, *PNDWPROPERTYSHEET;


LRESULT CALLBACK
WizParentWindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    This function disables auto-run when the Found New Hardware Wizard is running.
    It is a subclass of the wizard's main window.

Arguments:

    hwnd -

    uMsg -

    wParam -

    lParam -

Return Value:

    If the message is QueryCancelAutoPlay then return TRUE to cancel AutoPlay,
    otherwise return the default window value.

--*/
{
    static UINT msgQueryCancelAutoPlay = 0;

    if (!msgQueryCancelAutoPlay) {

        msgQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
    }

    if (uMsg == msgQueryCancelAutoPlay) {

        //
        // Cancel Auto-Play when the wizard is running.
        //
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        return 1;

    } else {

        return CallWindowProc(g_OldWizardProc, hwnd, uMsg, wParam, lParam);
    }
}

INT CALLBACK
iNDWDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.
    Also used to subclass the wizard's window to catch the
    QueryCancelAutoRun message sent by the shell when an AutoRun
    CD is inserted.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        g_OldWizardProc = (WNDPROC)SetWindowLongPtr(hwndDlg,
                                                   DWLP_DLGPROC,
                                                   (LONG_PTR)WizParentWindowProc
                                                   );
        break;

    case PSCB_PRECREATE:
        if( lParam ){

            //
            // This is done to hide the X and ? at the top of the wizard
            //
            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~(DS_CONTEXTHELP | WS_SYSMENU);
        }
        break;
    }

    return FALSE;
}


PNDWPROPERTYSHEET
InitNDWPropSheet(
   HWND            hwndParent,
   PNEWDEVWIZ      NewDevWiz,
   int             StartPageId
   )
{
    PNDWPROPERTYSHEET NdwPropertySheet;
    LPPROPSHEETHEADER PropSheetHeader;
    PROPSHEETPAGE    psp;
    LPTSTR Title;

    //
    // Allocate memory for the header and the page array.
    //
    NdwPropertySheet = LocalAlloc(LPTR, sizeof(NDWPROPERTYSHEET));

    if (!NdwPropertySheet) {

        NewDevWiz->LastError = ERROR_NOT_ENOUGH_MEMORY;
        return NULL;
    }

    NewDevWiz->LastError = NdwBuildClassInfoList(NewDevWiz, DIBCI_NOINSTALLCLASS);

    if (NewDevWiz->LastError != ERROR_SUCCESS) {

        return NULL;
    }

    //
    // Initialize the PropertySheet Header
    //
    PropSheetHeader = &(NdwPropertySheet->PropSheetHeader);
    PropSheetHeader->dwSize = sizeof(NdwPropertySheet->PropSheetHeader);
    PropSheetHeader->dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
    PropSheetHeader->pszbmWatermark = MAKEINTRESOURCE(IDB_WATERBMP);
    PropSheetHeader->pszbmHeader = MAKEINTRESOURCE(IDB_BANNERBMP);
    PropSheetHeader->hwndParent = hwndParent;
    PropSheetHeader->hInstance = hNewDev;
    PropSheetHeader->pfnCallback = iNDWDlgCallback;

    switch (NewDevWiz->InstallType) {

        case NDWTYPE_FOUNDNEW:
            Title = (LPTSTR)IDS_FOUNDDEVICE;
            break;

        case NDWTYPE_UPDATE:
            Title = (LPTSTR)IDS_UPDATEDEVICE;
            break;

        default:
            Title = TEXT(""); // unknown
    }

    PropSheetHeader->pszCaption = Title;
    PropSheetHeader->phpage = NdwPropertySheet->PropSheetPages;
    PropSheetHeader->nStartPage = 0;

    PropSheetHeader->nPages = 0;
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.hInstance = hNewDev;
    psp.lParam = (LPARAM)NewDevWiz;
    psp.pszTitle = Title;

    //
    // The install wizards are always spawned from some other disjoint UI,
    // (HdwWiz, devmgr, cpl applets etc. and so don't have a proper intro
    // page.
    //

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    if (StartPageId == IDD_NEWDEVWIZ_INSTALLDEV) {
        //
        // Found New Hardware, with a rank Zero match.
        // jump straight into install page.
        //
        ;

    }

    else {

        //
        // Update driver, or found new hardware without rank Zero driver
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_INTRO);
        psp.pfnDlgProc = IntroDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_ADVANCEDSEARCH);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_ADVANCEDSEARCH);
        psp.pfnDlgProc = AdvancedSearchDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
        
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_SEARCHING);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_SEARCHING);
        psp.pfnDlgProc = DriverSearchingDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_WUPROMPT);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_WUPROMPT);
        psp.pfnDlgProc = WUPromptDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
        
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_LISTDRIVERS);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_LISTDRIVERS);
        psp.pfnDlgProc = ListDriversDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_SELECTCLASS);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_SELECTCLASS);
        psp.pfnDlgProc = NDW_PickClassDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_SELECTDEVICE);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_SELECTDEVICE);
        psp.pfnDlgProc = NDW_SelectDeviceDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_ANALYZEDEV);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_ANALYZEDEV);
        psp.pfnDlgProc = NDW_AnalyzeDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        //
        // These last two wizard pages are finish pages...so hide the header
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_USECURRENT_FINISH);
        psp.pfnDlgProc = UseCurrentDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_NODRIVER_FINISH);
        psp.pfnDlgProc = NoDriverDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    }

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_INSTALLDEV);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_INSTALLDEV);
    psp.pfnDlgProc = NDW_InstallDevDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_FINISH);
    psp.pfnDlgProc = NDW_FinishDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
    //
    // Get the Class Icon Image Lists.
    //
    NewDevWiz->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);

    if (SetupDiGetClassImageList(&NewDevWiz->ClassImageList)) {

        HICON hIcon;

        //
        // Add the blank icon for "Show All Devices"
        //
        if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {

            g_BlankIconIndex = ImageList_AddIcon(NewDevWiz->ClassImageList.ImageList, hIcon);
        }
    } else {

        NewDevWiz->ClassImageList.cbSize = 0;
    }

    NewDevWiz->CurrCursor = NULL;
    NewDevWiz->IdcWait        = LoadCursor(NULL, IDC_WAIT);
    NewDevWiz->IdcAppStarting = LoadCursor(NULL, IDC_APPSTARTING);
    NewDevWiz->IdcArrow = LoadCursor(NULL, IDC_ARROW);

    return NdwPropertySheet;
}




//
// Used by "Found New Hardware" when a rank zero compatible driver is found
// from the default inf location.
//

BOOL
DoDeviceWizard(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    BOOL bUpdate
    )
{
    int  PropSheetResult = 0;
    PNDWPROPERTYSHEET NdwPropertySheet;

    NdwPropertySheet = InitNDWPropSheet(hWnd, 
                                        NewDevWiz, 
                                        bUpdate ? 0 : IDD_NEWDEVWIZ_INSTALLDEV
                                        );

    if (NdwPropertySheet) {

        CoInitialize(NULL);

        PropSheetResult = (int)PropertySheet(&NdwPropertySheet->PropSheetHeader);

        CoUninitialize();

        LocalFree(NdwPropertySheet);
    }

    //
    // If there were no other errors encounted while installing drivers and the
    // user canceled out of the wizard, then set the LastError to ERROR_CANCELED.
    //
    if ((NewDevWiz->LastError == ERROR_SUCCESS) &&
        (PropSheetResult == 0)) {
        NewDevWiz->LastError = ERROR_CANCELLED;
    }

    //
    // Final cleanup of DeviceInfoData and DeviceInfoList.
    //
    if (NewDevWiz->ClassGuidList) {
        LocalFree(NewDevWiz->ClassGuidList);
        NewDevWiz->ClassGuidList = NULL;
        NewDevWiz->ClassGuidSize = NewDevWiz->ClassGuidNum = 0;
    }

    //
    // Destroy the ClassImageList
    //
    if (NewDevWiz->ClassImageList.cbSize) {
        SetupDiDestroyClassImageList(&NewDevWiz->ClassImageList);
        NewDevWiz->ClassImageList.cbSize = 0;
    }

    return NewDevWiz->LastError == ERROR_SUCCESS;
}

BOOL
InstallSelectedDriver(
   HWND hwndParent,
   HDEVINFO hDeviceInfo,
   LPCWSTR DisplayName,
   BOOL Backup,
   PDWORD pReboot
   )
/*++

Routine Description:

   Installs the selected driver on the selected device in the hDeviceInfo.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HDEVINFO hDeviceInfo - DeviceInfoList which supplies the selected device to install the
                          selected driver on.

   DisplayName - Friendly backup string

   Backup - BOOL that indicates whether or not we should back up the current drivers before
            installing the new ones.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

    BOOL    TRUE if the driver was installed
            FALSE if the driver was not installed.  Check GetLastError() to see if the specific
                  error.

--*/
{
    NEWDEVWIZ  NewDevWiz;
    UPDATEDRIVERINFO UpdateDriverInfo;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    memset(&NewDevWiz, 0, sizeof(NewDevWiz));
    NewDevWiz.InstallType = NDWTYPE_UPDATE;
    NewDevWiz.hDeviceInfo = hDeviceInfo;


    try {

        NewDevWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiGetSelectedDevice(NewDevWiz.hDeviceInfo,
                                      &NewDevWiz.DeviceInfoData
                                      ))
        {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }

        NewDevWiz.ClassGuidSelected = &NewDevWiz.DeviceInfoData.ClassGuid;

        if (!SetupDiGetClassDescription(NewDevWiz.ClassGuidSelected,
                                        NewDevWiz.ClassDescription,
                                        sizeof(NewDevWiz.ClassDescription)/sizeof(TCHAR),
                                        NULL
                                        )
            ||
            !SetupDiClassNameFromGuid(NewDevWiz.ClassGuidSelected,
                                       NewDevWiz.ClassName,
                                       sizeof(NewDevWiz.ClassName)/sizeof(TCHAR),
                                       NULL
                                       ))
        {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }

        if (Backup) {

            UpdateDriverInfo.DisplayName = DisplayName;
            UpdateDriverInfo.FromInternet = TRUE;

            NewDevWiz.UpdateDriverInfo = &UpdateDriverInfo;

        } else {

            NewDevWiz.Flags |= IDI_FLAG_NOBACKUP;
        }

        //
        // If the driver we are installing is not digitally signed then we 
        // want to set a system restore point.
        //
        NewDevWiz.Flags |= IDI_FLAG_SETRESTOREPOINT;

        //
        // Do the install quietly since we may have a batch of installs to do,
        // only showing UI when really needed.
        //
        NewDevWiz.SilentMode = TRUE;

        DoDeviceWizard(hwndParent, &NewDevWiz, FALSE);

INDLeaveExcept:;

    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {

          NewDevWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    if (pReboot) {
        //
        // copy out the reboot flags for the caller
        //
        *pReboot = NewDevWiz.Reboot;
    
    } else if (NewDevWiz.Reboot) {
        //
        // The caller didn't want the reboot flags so just prompt for a reboot
        // ourselves if one is needed.
        //
        RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

    SetLastError(NewDevWiz.LastError);

    return NewDevWiz.LastError == ERROR_SUCCESS;
}

BOOL
InstallSelectedDevice(
   HWND hwndParent,
   HDEVINFO hDeviceInfo,
   PDWORD pReboot
   )
/*++

Routine Description:

   Installs the selected device in the hDeviceInfo.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HDEVINFO hDeviceInfo - DeviceInfoList which supplies the selected device to install.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    BOOL DriversFound;
    NEWDEVWIZ  NewDevWiz;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    memset(&NewDevWiz, 0, sizeof(NewDevWiz));
    NewDevWiz.InstallType = NDWTYPE_FOUNDNEW;
    NewDevWiz.hDeviceInfo = hDeviceInfo;

    try {

        NewDevWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiGetSelectedDevice(NewDevWiz.hDeviceInfo,
                                  &NewDevWiz.DeviceInfoData
                                  ))
        {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }


        NewDevWiz.ClassGuidSelected = &NewDevWiz.DeviceInfoData.ClassGuid;

        if (!SetupDiGetClassDescription(NewDevWiz.ClassGuidSelected,
                                       NewDevWiz.ClassDescription,
                                       sizeof(NewDevWiz.ClassDescription)/sizeof(TCHAR),
                                       NULL
                                       )
            ||
            !SetupDiClassNameFromGuid(NewDevWiz.ClassGuidSelected,
                                      NewDevWiz.ClassName,
                                      sizeof(NewDevWiz.ClassName)/sizeof(TCHAR),
                                      NULL
                                      ))
         {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }

        //
        // Do the install quietly since we may have a batch of installs to do,
        // only showing UI when really needed. During legacy detect the
        // detect summary page is showing.
        //
        NewDevWiz.SilentMode = TRUE;
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        //
        // If the driver we are installing is not digitally signed then we 
        // want to set a system restore point.
        //
        NewDevWiz.Flags = IDI_FLAG_SETRESTOREPOINT;

        if (SetupDiGetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
       {
            DeviceInstallParams.Flags |= DI_SHOWOEM | DI_QUIETINSTALL;
            DeviceInstallParams.hwndParent = hwndParent;
            wcscpy(DeviceInstallParams.DriverPath, L"");

            SetupDiSetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        //
        // If no driver list search the win inf default locations
        // If we still can't find a driver, then start at the driver
        // search page.
        //
        // otherwise go straight to the finish page and install.
        // To preserve drivers preselected by the caller (legacy detect)
        // the currently SelectedDriver is used, but if there is no selected
        // driver the highest ranking  driver is used.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        DriversFound = SetupDiEnumDriverInfo(NewDevWiz.hDeviceInfo,
                                            &NewDevWiz.DeviceInfoData,
                                            SPDIT_COMPATDRIVER,
                                            0,
                                            &DriverInfoData
                                            );

        if (!DriversFound) {

            SetupDiDestroyDriverInfoList(NewDevWiz.hDeviceInfo,
                                         &NewDevWiz.DeviceInfoData,
                                         SPDIT_COMPATDRIVER
                                         );

            if (SetupDiGetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                              &NewDevWiz.DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                wcscpy(DeviceInstallParams.DriverPath, L"");
                SetupDiSetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                              &NewDevWiz.DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }



            if (SetupDiBuildDriverInfoList(NewDevWiz.hDeviceInfo,
                                           &NewDevWiz.DeviceInfoData,
                                           SPDIT_COMPATDRIVER
                                           ))
            {
                SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                          NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData
                                          );
            }

            DriversFound = SetupDiEnumDriverInfo(NewDevWiz.hDeviceInfo,
                                                &NewDevWiz.DeviceInfoData,
                                                SPDIT_COMPATDRIVER,
                                                0,
                                                &DriverInfoData
                                                );
        }

        if (DriversFound) {

            SP_DRVINFO_DATA SelectedDriverInfo;

            SelectedDriverInfo.cbSize = sizeof(SP_DRVINFO_DATA);

            if (!SetupDiGetSelectedDriver(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &SelectedDriverInfo
                                          ))
            {
                SetupDiSetSelectedDriver(NewDevWiz.hDeviceInfo,
                                         &NewDevWiz.DeviceInfoData,
                                         &DriverInfoData
                                         );
            }

            DoDeviceWizard(hwndParent, &NewDevWiz, FALSE);
        }

        else {

            DoDeviceWizard(hwndParent, &NewDevWiz, TRUE);
        }

        if (pReboot) {
            //
            // copy out the reboot flags for the caller
            //
            *pReboot = NewDevWiz.Reboot;
        
        } else if (NewDevWiz.Reboot) {
            //
            // The caller didn't want the reboot flags so just prompt for a reboot
            // ourselves if one is needed.
            //
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }

INDLeaveExcept:;

    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {

          NewDevWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    if (NewDevWiz.hDeviceInfo &&
        (NewDevWiz.hDeviceInfo != INVALID_HANDLE_VALUE)) {

        SetupDiDestroyDriverInfoList(NewDevWiz.hDeviceInfo, &NewDevWiz.DeviceInfoData, SPDIT_COMPATDRIVER);
        SetupDiDestroyDeviceInfoList(NewDevWiz.hDeviceInfo);
    }

    SetLastError(NewDevWiz.LastError);

    return NewDevWiz.LastError == ERROR_SUCCESS;
}




BOOL
InstallNewDevice(
   HWND hwndParent,
   LPGUID ClassGuid,
   PDWORD pReboot
   )
/*++

Routine Description:

   Exported Entry point from newdev.dll. Installs a new device. A new Devnode is
   created and the user is prompted to select the device. If the class guid
   is not specified then then the user begins at class selection.

   This function has been moved to hdwwiz.cpl (which handles all legacy device
   functions now).  This entry point just forwards the function call onto hdwwiz.cpl
   now.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   LPGUID ClassGuid - Optional class of the new device to install.
                      If ClassGuid is NULL we start at detection choice page.
                      If ClassGuid == GUID_NULL or GUID_DEVCLASS_UNKNOWN
                         we start at class selection page.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    HMODULE hHdwWiz;
    BOOL Return = FALSE;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    hHdwWiz = LoadLibrary(TEXT("hdwwiz.cpl"));

    if (NULL == hHdwWiz) {

        return FALSE;
    }

    if (NULL == pInstallNewDevice) {

        pInstallNewDevice = (PINSTALLNEWDEVICE)GetProcAddress(hHdwWiz, "InstallNewDevice");
    }

    if (NULL == pInstallNewDevice) {

        return FALSE;
    }

    Return = (pInstallNewDevice)(hwndParent, ClassGuid, pReboot);

    FreeLibrary(hHdwWiz);

    return Return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\newdevp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       newdevp.h
//
//--------------------------------------------------------------------------

#define OEMRESOURCE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <string.h>
#include <cpl.h>
#include <prsht.h>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <dlgs.h>     // common dlg IDs
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlobjp.h>
#include <devguid.h>
#include <pnpmgr.h> //REGSTR_VAL_NEW_DEVICE_DESC
#include <lmcons.h>
#include <dsrole.h>
#include <newdev.h>
#include <cdm.h>
#include <wininet.h>
#include <wincrui.h>
#include <regstr.h>
#include <srrestoreptapi.h>
#include <shfusion.h>
#include "resource.h"

                               
                                

#define NEWDEV_CLASS_NAME   TEXT("NewDevClass")

#define ARRAYSIZE(array)     (sizeof(array) / sizeof(array[0]))

#define SIZECHARS(x)         (sizeof((x))/sizeof(TCHAR))


//
// The Install type, these are mutually exclusive.
//
// NDWTYPE_FOUNDNEW - A new device was found.  We will do an initial search for drivers with the only
//   UI being a subtle balloon tip on the systray.  If we don't find a driver in our initial search then
//   we will prompt the user with the Found New Hardware wizard.
// NDWTYPE_UPDATE - This is the case where a user is manually updating a driver.  For this case we just jump
//   directly into the Update Driver Wizard code.
// NDWTYPE_UPDATE_SILENT - This is the case where someone has us silently update a driver for a given device.
//   For this case we will do a driver search in the locations specified in the API call.  If we don't find a
//   driver in these locations then we do NOT bring up the wizard.  No UI is shown in this case.
//
#define NDWTYPE_FOUNDNEW        1
#define NDWTYPE_UPDATE          2
#define NDWTYPE_UPDATE_SILENT   3


//
// DEVICE_COUNT_Xxx values are used for the following settings:
//  DEVICE_COUNT_FOR_DELAY is the number of devices (times two) that we want to slow
//                         down the install for so the user can see the UI and have
//                         time to read it.  Once we get past this number of devices
//                         then we will skip the dealy.
// DEVICE_COUNT_DELAY is the number of milliseconds that we will delay between UI only
//                    (server side) installs to give the user some time to read the UI.
//
#define DEVICE_COUNT_FOR_DELAY  10
#define DEVICE_COUNT_DELAY      2000

//
// Values used to check if the device, that the Found New Hardware wizard has
// been displayed for, has been installed by some other process. This will 
// most likely happen when one user switches desktops and installs the drivers
// on this device.
//
#define INSTALL_COMPLETE_CHECK_TIMERID  1000
#define INSTALL_COMPLETE_CHECK_TIMEOUT  5000


typedef struct _NewDeviceWizardExtension {
   HPROPSHEETPAGE hPropSheet;
   HPROPSHEETPAGE hPropSheetEnd;         // optional
   SP_NEWDEVICEWIZARD_DATA DeviceWizardData;
} WIZARDEXTENSION, *PWIZARDEXTENSION;

typedef struct _UpdateDriverInfo {
   LPCWSTR InfPathName;
   LPCWSTR DisplayName;
   BOOL    DriverWasUpgraded;
   BOOL    FromInternet;
   TCHAR   BackupRegistryKey[MAX_DEVICE_ID_LEN];
   TCHAR   Description[LINE_LEN];
   TCHAR   MfgName[LINE_LEN];
   TCHAR   ProviderName[LINE_LEN];
} UPDATEDRIVERINFO, *PUPDATEDRIVERINFO;

typedef struct _NewDeviceWizard {
    HWND                    hWnd;

    HDEVINFO                hDeviceInfo;
    int                     EnterInto;
    int                     EnterFrom;
    int                     PrevPage;

    int                     ClassGuidNum;
    int                     ClassGuidSize;
    LPGUID                  ClassGuidList;
    LPGUID                  ClassGuidSelected;
    GUID                    lvClassGuidSelected;
    GUID                    SavedClassGuid;

    HCURSOR  CurrCursor;
    HCURSOR  IdcWait;
    HCURSOR  IdcAppStarting;
    HCURSOR  IdcArrow;
    HFONT    hfontTextNormal;
    HFONT    hfontTextBigBold;
    HFONT    hfontTextBold;

    HANDLE DriverSearchThread;
    HANDLE CancelEvent;

    DWORD                   AnalyzeResult;
    SP_DEVINFO_DATA         DeviceInfoData;
    SP_INSTALLWIZARD_DATA   InstallDynaWiz;
    HPROPSHEETPAGE          SelectDevicePage;
    SP_CLASSIMAGELIST_DATA  ClassImageList;

    BOOL     Installed;
    BOOL     ExitDetect;
    BOOL     SilentMode;
    BOOL     InstallChilds;
    BOOL     MultipleDriversFound;
    BOOL     DoAutoInstall;
    BOOL     CurrentDriverIsSelected;
    BOOL     NoDriversFound;
    BOOL     LaunchTroubleShooter;
    BOOL     AlreadySearchedWU;
    BOOL     CallHelpCenter;
    BOOL     SetRestorePoint;
    DWORD    Flags;
    DWORD    InstallType;
    DWORD    SearchOptions;
    DWORD    LastError;
    DWORD    Reboot;
    DWORD    Capabilities;
    PUPDATEDRIVERINFO UpdateDriverInfo;

    PVOID MessageHandlerContext;

    HMODULE  hCdmInstance;
    HANDLE   hCdmContext;

    WIZARDEXTENSION WizExtPreSelect;
    WIZARDEXTENSION WizExtSelect;
    WIZARDEXTENSION WizExtPreAnalyze;
    WIZARDEXTENSION WizExtPostAnalyze;
    WIZARDEXTENSION WizExtFinishInstall;

    TCHAR    ClassName[MAX_CLASS_NAME_LEN];
    TCHAR    ClassDescription[LINE_LEN];
    TCHAR    DriverDescription[LINE_LEN];
    TCHAR    BrowsePath[MAX_PATH];
    TCHAR    SingleInfPath[MAX_PATH];
    TCHAR    InstallDeviceInstanceId[MAX_DEVICE_ID_LEN];
} NEWDEVWIZ, *PNEWDEVWIZ;

typedef struct _DELINFNODE {
    TCHAR               szInf[MAX_PATH];
    struct _DELINFNODE  *pNext;
} DELINFNODE, *PDELINFNODE;

#define MAX_PASSWORD_TRIES  3

#define NEWDEV_TARGET_NAME  TEXT("{36149A20-7CD5-446e-A305-F14D7D6FBC49}")

//
// InstallDeviceInstance Flag values
//
#define IDI_FLAG_SILENTINSTALL          0x00000001
#define IDI_FLAG_SECONDNEWDEVINSTANCE   0x00000002
#define IDI_FLAG_NOBACKUP               0x00000004
#define IDI_FLAG_READONLY_INSTALL       0x00000008
#define IDI_FLAG_NONINTERACTIVE         0x00000010
#define IDI_FLAG_ROLLBACK               0x00000020
#define IDI_FLAG_FORCE                  0x00000040
#define IDI_FLAG_MANUALINSTALL          0x00000080
#define IDI_FLAG_SETRESTOREPOINT        0x00000100

//
// RollbackDriver Flag values
//
#define ROLLBACK_FLAG_FORCE             0x00000001
#define ROLLBACK_FLAG_DO_CLEANUP        0x00000002
#define ROLLBACK_BITS                   0x00000003

#define REINSTALL_REGKEY                TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall")
#define DEVICEINSTANCEIDS_REGVALUE      TEXT("DeviceInstanceIds")
#define REINSTALLSTRING_REGVALUE        TEXT("ReinstallString")

BOOL
DoDeviceWizard(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    BOOL bUpdate
    );

BOOL
InstallSelectedDevice(
   HWND hwndParent,
   HDEVINFO hDeviceInfo,
   PDWORD pReboot
   );

BOOL
IntializeDeviceMapInfo(
    void
    );

UINT
GetNextDriveByType(
    UINT DriveType,
    UINT DriveNumber
    );

#define SDT_MAX_TEXT         1024        // Max SetDlgText

//
// from search.c
//
BOOL
FixUpDriverListForInet(
    PNEWDEVWIZ NewDevWiz
    );

BOOL
IsDriverNodeInteractiveInstall(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData
   );

void
SearchDriveForDrivers(
    PNEWDEVWIZ NewDevWiz,
    UINT DriveType,
    UINT DriveNumber
    );

void
SetDriverPath(
   PNEWDEVWIZ NewDevWiz,
   PCTSTR      DriverPath
   );

BOOL
IsInstalledDriver(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData
   );

void
DoDriverSearch(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    ULONG SearchOptions,
    DWORD DriverType,
    BOOL bAppendToExistingDriverList
    );

BOOL
SearchWindowsUpdateCache(
    PNEWDEVWIZ NewDevWiz
    );



//
// from miscutil.c
//
BOOL
SetClassGuid(
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData,
    LPGUID ClassGuid
    );

void
SetDlgText(
   HWND hDlg,
   int iControl,
   int nStartString,
   int nEndString
   );

void
LoadText(
   PTCHAR szText,
   int SizeText,
   int nStartString,
   int nEndString
   );

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
NoPrivilegeWarning(
   HWND hWnd
   );

LONG
NdwBuildClassInfoList(
   PNEWDEVWIZ NewDevWiz,
   DWORD ClassListFlags
   );

void
HideWindowByMove(
   HWND hDlg
   );

LONG
NdwUnhandledExceptionFilter(
   struct _EXCEPTION_POINTERS *ExceptionPointers
   );

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PNEWDEVWIZ NewDevWiz
   );

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PNEWDEVWIZ NewDevWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction,
   HPROPSHEETPAGE hIntroPage
   );

void
RemoveClassWizExtPages(
   HWND hwndParentDlg,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData
   );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
pVerifyUpdateDriverInfoPath(
    PNEWDEVWIZ NewDevWiz
    );

BOOL
ConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize          OPTIONAL
    );

BOOL
RemoveDir(
    PTSTR Path
    );

RemoveCdmDirectory(
    PTSTR CdmDirectory
    );

BOOL
pSetupGetDriverDate(
    IN     PCTSTR     DriverVer,
    IN OUT PFILETIME  pFileTime
    );

BOOL
IsInternetAvailable(
    HMODULE *hCdmInstance
    );

void
CdmLogDriverNotFound(
    HMODULE hCdmInstance,
    HANDLE  hContext,
    LPCTSTR DeviceInstanceId,
    DWORD   Flags
    );

BOOL
GetInstalledInf(
    IN     DEVNODE DevNode,           OPTIONAL
    IN     PTSTR   DeviceInstanceId,  OPTIONAL
    IN OUT PTSTR   InfFile,
    IN OUT DWORD   *Size
    );

BOOL
IsInfFromOem(
    IN  PCTSTR                InfFile
    );

BOOL
IsConnectedToInternet(
    void
    );

BOOL
GetLogPnPIdPolicy(
    void
    );

DWORD
GetSearchOptions(
    void
    );

VOID
SetSearchOptions(
    DWORD SearchOptions
    );

BOOL
IsInstallComplete(
    HDEVINFO         hDevInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
GetIsWow64 (
    VOID
    );

BOOL
OpenCdmContextIfNeeded(
    HMODULE *hCdmInstance,
    HANDLE *hCdmContext
    );

BOOL
pSetSystemRestorePoint(
    BOOL Begin,
    BOOL CancelOperation,
    int RestorePointResourceId
    );

BOOL
GetProcessorExtension(
    LPTSTR ProcessorExtension,
    DWORD  ProcessorExtensionSize
    );

BOOL
GetGuiSetupInProgress(
    VOID
    );

DWORD
GetBusInformation(
    DEVNODE DevNode
    );

PTCHAR
BuildFriendlyName(
    DEVINST DevInst,
    BOOL UseNewDeviceDesc,
    HMACHINE hMachine
    );

void
CdmCancelCDMOperation(
    HMODULE hCdmInstance
    );


extern TCHAR szUnknownDevice[64];
extern USHORT LenUnknownDevice;
extern TCHAR szUnknown[64];
extern USHORT LenUnknown;
extern int g_BlankIconIndex;
extern HMODULE hSrClientDll;
extern HMODULE hNewDev;
extern TCHAR *DevicePath; // default windows inf path
extern BOOL GuiSetupInProgress;

//
// newdev.c, init.c
//
BOOL
InstallDevInst(
   HWND hwndParent,
   LPCWSTR DeviceInstanceId,
   BOOL UpdateDriver,
   PDWORD pReboot
   );

BOOL
InstallNewDevice(
   HWND hwndParent,
   LPGUID ClassGuid,
   PDWORD pReboot
   );



//
// finish.c
//
BOOL
IsNullDriverInstalled(
    DEVNODE DevNode
    );

DWORD
InstallNullDriver(
   HWND hDlg,
   PNEWDEVWIZ NewDevWiz,
   BOOL FailedInstall
   );

//
// update.c
//
void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PNEWDEVWIZ NewDevWiz
    );

void
InstallSilentChilds(
   HWND hwndParent,
   PNEWDEVWIZ NewDevWiz
   );

void
SendMessageToUpdateBalloonInfo(
    PTSTR DeviceDesc
    );



//
// Driver search options
//
#define SEARCH_DEFAULT_EXCLUDE_OLD_INET 0x00000001  // Search all Default INFs (in %windir%\INF)
                                                    //  excluding old Internet INFs
#define SEARCH_DEFAULT                  0x00000002  // Search all Default INFs (in %windir%\INF)
#define SEARCH_FLOPPY                   0x00000004  // Search all INFs on all Floppies on the system
#define SEARCH_CDROM                    0x00000008  // Search all INFs on all CD-ROMs on the system
#define SEARCH_DIRECTORY                0x00000010  // Search all INFs in NewDevWiz->BrowsePath directory
#define SEARCH_INET                     0x00000020  // Tell Setupapi to call CDM.DLL to see if the
                                                    //  WU web site has updated drivers for this device.
#define SEARCH_WINDOWSUPDATE            0x00000040  // Search all INFs in NewDevWiz->BrowsePath, but tell
                                                    //  SETUPAPI.DLL that they are from the Internet.
#define SEARCH_SINGLEINF                0x00000080  // Just search INF in NewDevWiz->SingleInfPath
#define SEARCH_CURRENTDRIVER            0x00000100  // Get the currently installed driver.
#define SEARCH_INET_IF_CONNECTED        0x00000200  // If the machine is connected to the Internet and WU
                                                    // appears to have the best driver then basically do
                                                    // a SEARCH_INET.

//
// Balloon Tip flags
//
#define TIP_LPARAM_IS_DEVICEINSTANCEID  0x00000001  // lParam is a DeviceInstanceId and not just text
#define TIP_PLAY_SOUND                  0x00000002  // play sound when balloon info is displayed
#define TIP_HIDE_BALLOON                0x00000004  // Hide the balloon

//
// Driver List Flags
//
#define DRIVER_LIST_CURRENT_DRIVER      0x00000001  // This is the currently installed driver
#define DRIVER_LIST_SELECTED_DRIVER     0x00000002  // This is the selected/best driver in the list
#define DRIVER_LIST_SIGNED_DRIVER       0x00000004  // This driver is digitally signed.

//
// Private window messages
//
#define WUM_SEARCHDRIVERS   (WM_USER+279)
#define WUM_INSTALLCOMPLETE (WM_USER+280)
#define WUM_UPDATEUI        (WM_USER+281)
#define WUM_EXIT            (WM_USER+282)
#define WUM_INSTALLPROGRESS (WM_USER+283)


//
// Private device install notifications
//
// 0 is used by setupapi to signify the begining of processing a file queue.
// 1 is used by setupapi to notify us that it has processed one file.
//
#define INSTALLOP_COPY          0x00000100
#define INSTALLOP_RENAME        0x00000101
#define INSTALLOP_DELETE        0x00000102
#define INSTALLOP_BACKUP        0x00000103
#define INSTALLOP_SETTEXT       0x00000104

//
// The wizard dialog procs
//
INT_PTR CALLBACK IntroDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FinishInstallIntroDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_PickClassDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_AnalyzeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_InstallDevDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_FinishDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_SelectDeviceDlgProc(HWND hDlg,UINT wMsg,WPARAM wParam,LPARAM lParam);

LRESULT CALLBACK BalloonInfoProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvancedSearchDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DriverSearchingDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WUPromptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK InstallNewDeviceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ListDriversDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UseCurrentDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NoDriverDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK WizExtPreSelectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtSelectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtPreAnalyzeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtPreAnalyzeEndDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtPostAnalyzeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtPostAnalyzeEndDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtFinishInstallDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtFinishInstallEndDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\init.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include "pnpipc.h"


HMODULE hNewDev=NULL;
DWORD dwRestartFlags= 0;
DWORD dwSetupFlags=0;
BOOL bQueuedRebootNeeded = FALSE;
BOOL GuiSetupInProgress = FALSE;

TCHAR *DevicePath = NULL;

HANDLE UpdateDeviceClassUiEvent = NULL;
HANDLE TerminateUiEvent = NULL;
HANDLE hTrayIconWnd = NULL;

void
BuildDevicePath(
   VOID
   )
{
    TCHAR ValueBuffer[MAX_PATH*2];
    TCHAR *ValueDevicePath;
    DWORD Len, cbData, Type;
    LONG Error;
    HKEY hKey;


    if (DevicePath) {

        free(DevicePath);
        DevicePath = NULL;
    }

    Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ, &hKey);
    if (Error != ERROR_SUCCESS) {

        return;
    }

    ValueDevicePath = ValueBuffer;
    cbData = sizeof(ValueBuffer);
    Error = RegQueryValueEx(hKey,
                            REGSTR_VAL_DEVICEPATH,
                            NULL,
                            &Type,
                            (LPBYTE)ValueDevicePath,
                            &cbData
                            );

    if (Error == ERROR_MORE_DATA) {

        if (ValueDevicePath = malloc(cbData)) {

            Error = RegQueryValueEx(hKey,
                                    REGSTR_VAL_DEVICEPATH,
                                    NULL,
                                    &Type,
                                    (LPBYTE)ValueDevicePath,
                                    &cbData
                                    );
        }
    }

    RegCloseKey(hKey);

    if (Error != ERROR_SUCCESS) {

        goto BDPExit;
    }


    DevicePath = malloc(cbData*2);
    if (!DevicePath) {

        goto BDPExit;
    }

    memset(DevicePath, 0, cbData*2);


    Len = ExpandEnvironmentStrings(ValueDevicePath,
                                   DevicePath,
                                   cbData*2/sizeof(TCHAR)
                                   );

    if (Len > cbData*2/sizeof(TCHAR)) {

        free(DevicePath);
        DevicePath = malloc(Len*sizeof(TCHAR));

        if (DevicePath) {

            memset(DevicePath, 0, Len*sizeof(TCHAR));
            ExpandEnvironmentStrings(ValueDevicePath,
                                     DevicePath,
                                     Len
                                     );
        }
    }


BDPExit:

    if (ValueDevicePath &&
        (ValueDevicePath != ValueBuffer)) {

        free(ValueDevicePath);
    }

    return;
}

BOOL
DllInitialize(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL
    )
{
    hNewDev = hmod;

    if (ulReason == DLL_PROCESS_ATTACH) {

        DisableThreadLibraryCalls(hmod);

        SHFusionInitializeFromModule(hmod);

        BuildDevicePath();
        IntializeDeviceMapInfo();
        GuiSetupInProgress = GetGuiSetupInProgress();

        LoadString(hNewDev,
                   IDS_UNKNOWN,
                   (PTCHAR)szUnknown,
                   SIZECHARS(szUnknown)
                   );

        LenUnknown = lstrlen(szUnknown) * sizeof(TCHAR) + sizeof(TCHAR);

        LoadString(hNewDev,
                   IDS_UNKNOWNDEVICE,
                   (PTCHAR)szUnknownDevice,
                   SIZECHARS(szUnknownDevice)
                   );

        LenUnknownDevice = lstrlen(szUnknownDevice) * sizeof(TCHAR) + sizeof(TCHAR);

        hSrClientDll = NULL;
    }

    else if (ulReason == DLL_PROCESS_DETACH) {

        free(DevicePath);

        SHFusionUninitialize();
    }

    return TRUE;
}

BOOL
pInstallDeviceInstanceNewDevice(
    HWND hwndParent,
    HWND hBalloonTiphWnd,
    PNEWDEVWIZ NewDevWiz
    )
{
    ULONG DevNodeStatus = 0, Problem = 0;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    BOOL bHaveDriver = TRUE;

    //
    // Set the DI_QUIETINSTALL flag for the Found New Hardware case
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {

        DeviceInstallParams.Flags |= DI_QUIETINSTALL;

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }

    //
    // Do a driver search by searching the default INF locations and excluding
    // any old Internet INFs that we find.
    //
    DoDriverSearch(hwndParent,
                   NewDevWiz,
                   SEARCH_DEFAULT_EXCLUDE_OLD_INET,
                   SPDIT_COMPATDRIVER,
                   FALSE
                   );

    //
    // Check if the Windows Update cache says it has a better driver if we are
    // connected to the Internet.
    //
    if (IsConnectedToInternet() &&
        SearchWindowsUpdateCache(NewDevWiz)) {

        //
        // The machine is connected to the Internet and the WU cache says it has
        // a better driver, so let's connect to the Internet and download this
        // driver from WU.
        //
        DoDriverSearch(hwndParent,
                       NewDevWiz,
                       SEARCH_INET,
                       SPDIT_COMPATDRIVER,
                       TRUE
                       );
    }

    //
    // Lets see if we found a driver for this device.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )) {

        wcscpy(NewDevWiz->DriverDescription, DriverInfoData.Description);

        //
        // fetch rank of driver found.
        //
        DriverInstallParams.cbSize = sizeof(DriverInstallParams);
        if (!SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams
                                           )) {

            DriverInstallParams.Rank = (DWORD)-1;
        }

        //
        // If we have a balloon tip window then have it update its UI.
        //
        if (hBalloonTiphWnd) {
            //
            // We have a new driver description for this device so use this to update the balloon
            // tip.
            //
            PostMessage(hBalloonTiphWnd,
                        WUM_UPDATEUI,
                        0,
                        (LPARAM)NewDevWiz->DriverDescription
                        );

        } else if (NewDevWiz->Flags & IDI_FLAG_SECONDNEWDEVINSTANCE) {
            //
            // This is the second NEWDEV.DLL instance running with Administrator privileges.  We need
            // to send a message to the main NEWDEV.DLL process and have it update it's balloon tooltip.
            //
            SendMessageToUpdateBalloonInfo(NewDevWiz->DriverDescription);
        }

    } else {

        *NewDevWiz->DriverDescription = L'\0';
        DriverInstallParams.Rank = (DWORD)-1;
        DriverInstallParams.Flags = 0;
        bHaveDriver = FALSE;

        //
        // If we have a balloon tip window then have it update its UI.
        //
        if (hBalloonTiphWnd) {
            //
            // We don't have a driver description, most likely because we didn't find a driver for this device,
            // so just update the balloon text using the DeviceInstanceId.
            //
            PostMessage(hBalloonTiphWnd,
                        WUM_UPDATEUI,
                        (WPARAM)TIP_LPARAM_IS_DEVICEINSTANCEID,
                        (LPARAM)NewDevWiz->InstallDeviceInstanceId
                        );
        }

    }

    //
    // Get the status of this devnode
    //
    CM_Get_DevNode_Status(&DevNodeStatus,
                          &Problem,
                          NewDevWiz->DeviceInfoData.DevInst,
                          0
                          );


    //
    // If we have a Hardware ID match and the selected (best) driver is not
    // listed as InteractiveInstall in the INF then just install the driver 
    // for this device.
    //
    if ((DriverInstallParams.Rank <= DRIVER_HARDWAREID_RANK) &&
        (!IsDriverNodeInteractiveInstall(NewDevWiz, &DriverInfoData))) {

        NewDevWiz->SilentMode = TRUE;

        DoDeviceWizard(hwndParent, NewDevWiz, FALSE);

        //
        // Install any new child devices that have come online due to the installation
        // of this device.  If there are any then install them silently.
        //
        if (!(NewDevWiz->Capabilities & CM_DEVCAP_SILENTINSTALL)) {
            InstallSilentChilds(hwndParent, NewDevWiz);
        }
    
    }  else if (!bHaveDriver &&
                (NewDevWiz->Capabilities & CM_DEVCAP_RAWDEVICEOK) &&
                (NewDevWiz->Capabilities & CM_DEVCAP_SILENTINSTALL) &&
                (DevNodeStatus & DN_STARTED)) {

        //
        // If the device is both RAW, silent install, and already started,
        // and we didn't find any drivers, then we just want to
        // install the NULL driver.
        //
        InstallNullDriver(hwndParent, NewDevWiz, FALSE);
    
    } else {
        //
        // This is the case where we don't have a hardware ID match and we don't have a special
        // RAW, silent, started device.  So in this case we will bring up the Found New Hardware
        // Wizard so the user can install a driver for this device.
        //

        //
        // If we have a balloon tip window then hide it.
        //
        if (hBalloonTiphWnd) {
            PostMessage(hBalloonTiphWnd,
                        WUM_UPDATEUI,
                        (WPARAM)TIP_HIDE_BALLOON,
                        0
                        );
        }

        //
        // We are bringing up the wizard, so clear the DI_QUIETINSTALL flag.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {

            DeviceInstallParams.Flags &= ~DI_QUIETINSTALL;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }


        //
        // Bring up the Found New Hardware Wizard
        //
        DoDeviceWizard(GetParent(hwndParent), NewDevWiz, TRUE);

        //
        // Install any new child devices that have come online due to the installation
        // of this device.  If there are any then install them silently.
        //
        if (!(NewDevWiz->Capabilities & CM_DEVCAP_SILENTINSTALL)) {

            InstallSilentChilds(hwndParent, NewDevWiz);
        }
    }

    return (GetLastError() == ERROR_SUCCESS);
}

BOOL
pInstallDeviceInstanceUpdateDevice(
    HWND hwndParent,
    PNEWDEVWIZ NewDevWiz
    )
{
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;

    //
    // We need to first check with the class/co-installers to give them the
    // change to bring up their own update driver UI.  This needs to be done
    // because there are some cases when our default behavior can cause the
    // device not to work. This only currently happens in the multiple
    // identical device case.
    //
    if (SetupDiCallClassInstaller(DIF_UPDATEDRIVER_UI,
                                  NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData
                                  ) ||
        (GetLastError() != ERROR_DI_DO_DEFAULT)) {
        
        //
        // If the class/co-installer returned NO_ERRROR, or some error other
        // than ERROR_DI_DO_DEFAULT then we will not display our default wizard.
        //
        return FALSE;
    }

    //
    // Jump directly into the Update Driver Wizard
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        //
        // This shouldn't be a quiet install, since we are doing a normal Update Driver
        //
        DeviceInstallParams.Flags &= ~DI_QUIETINSTALL;

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );

        DoDeviceWizard(hwndParent, NewDevWiz, TRUE);
    }

    return (GetLastError() == ERROR_SUCCESS);
}

BOOL
pInstallDeviceInstanceUpdateDeviceSilent(
    HWND hwndParent,
    PNEWDEVWIZ NewDevWiz
    )
{
    ULONG SearchOptions;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    //
    // Drivers are from the Internet (newdev API called from WU)
    //
    if (NewDevWiz->UpdateDriverInfo->FromInternet) {

        wcscpy(NewDevWiz->BrowsePath, NewDevWiz->UpdateDriverInfo->InfPathName);

        SearchOptions = SEARCH_WINDOWSUPDATE;
    }

    //
    // Normal app just telling us to update this device using the specified INF
    // or a driver rollback.
    //
    else {

        wcscpy(NewDevWiz->SingleInfPath, NewDevWiz->UpdateDriverInfo->InfPathName);

        SearchOptions = SEARCH_SINGLEINF;
    }

    //
    // If this is not a Force install we want to compare the driver against
    // the currently installed driver.  Note that we will only install the
    // device if it was found in the specified directory.
    //
    if (!(NewDevWiz->Flags & IDI_FLAG_FORCE)) {

        SearchOptions |= SEARCH_CURRENTDRIVER;
    }

    //
    // The silent update device code path always has the DI_QUIETINSTALL flag
    // set.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {

        DeviceInstallParams.Flags |= DI_QUIETINSTALL;

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }

    //
    // Search the specified directory or INF for drivers
    //
    DoDriverSearch(hwndParent,
                   NewDevWiz,
                   SearchOptions,
                   (NewDevWiz->Flags & IDI_FLAG_ROLLBACK) ?
                      SPDIT_CLASSDRIVER : SPDIT_COMPATDRIVER,
                   FALSE
                   );

    //
    // At this point we should already have the best driver selected, but if this is
    // a driver rollback we want to select the driver node ourselves using the
    // DevDesc, ProviderName, and Mfg of the original driver installed on this device.
    // We need to do this because the driver that we rolled back might not be the best
    // driver node in this INF.
    //
    if ((NewDevWiz->Flags & IDI_FLAG_ROLLBACK) &&
        (NewDevWiz->UpdateDriverInfo->Description[0] != TEXT('\0')) &&
        (NewDevWiz->UpdateDriverInfo->MfgName[0] != TEXT('\0')) &&
        (NewDevWiz->UpdateDriverInfo->ProviderName[0] != TEXT('\0'))) {

        ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

        DriverInfoData.cbSize = sizeof(DriverInfoData);
        DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
        DriverInfoData.Reserved = 0;
        lstrcpy(DriverInfoData.Description, NewDevWiz->UpdateDriverInfo->Description);
        lstrcpy(DriverInfoData.MfgName, NewDevWiz->UpdateDriverInfo->MfgName);
        lstrcpy(DriverInfoData.ProviderName, NewDevWiz->UpdateDriverInfo->ProviderName);

        SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 );
    }

    //
    // Since we have UpdateDriverInfo and the caller specified a specfic InfPathName (whether
    // a full path to an INF or just the path where INFs live) then we want to verify
    // that the selected driver's INF lives in that specified path.  If it does not then
    // do not automatically install it since that is not what the caller intended.
    //
    if (pVerifyUpdateDriverInfoPath(NewDevWiz)) {

        NewDevWiz->SilentMode = TRUE;

        //
        // Install the driver on this device.
        //
        DoDeviceWizard(hwndParent, NewDevWiz, FALSE);

        //
        // Quietly install any children of this device that are now present after bringing this
        // device online.
        //
        if (!NewDevWiz->UpdateDriverInfo->FromInternet) {
            InstallSilentChilds(hwndParent, NewDevWiz);
        }

    } else {

        //
        // If we get to this point then that means that the best driver we found was
        // not found in the specified directory or INF.  In this case we will not
        // install the best driver found and we'll set the appropriate error
        //
        NewDevWiz->LastError = ERROR_NO_MORE_ITEMS;
        SetLastError(ERROR_NO_MORE_ITEMS);
    }

    return (GetLastError() == ERROR_SUCCESS);
}

BOOL
InstallDeviceInstance(
    HWND hwndParent,
    HWND hBalloonTiphWnd,
    LPCTSTR DeviceInstanceId,
    PDWORD pReboot,
    PUPDATEDRIVERINFO UpdateDriverInfo,
    DWORD Flags,
    DWORD InstallType,
    HMODULE *hCdmInstance,
    HANDLE *hCdmContext,
    PBOOL pbLogDriverNotFound,
    PBOOL pbSetRestorePoint
   )
/*++

Routine Description:

    This is the main function where most of the exported functions to install drivers end up
    after they do some preprocessing.  This function will install or update the device
    depending on the parameters.


Arguments:

    hwndParent - Window handle of the top-level window to use for any UI related
                 to installing the device.

    hBalloonTiphWnd - Handle to the WNDPROC that does all of the new Balloon tip UI.  This
                      is currently only used in the NDWTYPE_FOUNDNEW case.

    DeviceInstanceId - Supplies the ID of the device instance.  This is the registry
                       path (relative to the Enum branch) of the device instance key.

    pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

    UpdateDriverInfo -

    Flags -
        IDI_FLAG_SILENTINSTALL - means the balloon tooltip will not be displayed
        IDI_FLAG_SECONDNEWDEVINSTANCE - means this is the second instance of newdev.dll
                                        that is running and the UI data should be sent
                                        over to the first instance of newdev.dll that
                                        is running.
        IDI_FLAG_NOBACKUP - Don't backup the old drivers.
        IDI_FLAG_READONLY_INSTALL - means the install is readonly (no file copy)
        IDI_FLAG_NONINTERACTIVE - Any UI will cause the API to fail.
        IDI_FLAG_ROLLBACK - set if we are doing a rollback       
        IDI_FLAG_FORCE - set if we are to force install this driver, which means
                         install it even if it is not better then the currently
                         installed driver.         
        IDI_FLAG_MANUALINSTALL - set if this is a manuall installed device. 
        IDI_FLAG_SETRESTOREPOINT - set if we are to set a restore point if the
                                   drivers that are getting installed are not
                                   digitally signed.  Currently we only set 
                                   restore points if the INF, catalog, or one
                                   of the copied files is not signed.

    InstallType - There are currently three different install types.
        NDWTYPE_FOUNDNEW - used to install drivers on a brand new device.
        NDWTYPE_UPDATE - used to bring up the Update Driver Wizard.
        NDWTYPE_UPDATE_SILENT - used to silently update the drivers for a device. The Update Driver Wizard
          won't be dispalyed in this case.

    hCdmInstance - A pointer to a hmodule that will receive the handle of the CDM
                   library when when and if we need to load it.                   

    hCdmContext - A pointer to a Cdm context handle that will receive the Cdm
                  context handle if it is opened.
    
    pbLogDriverNotFound - pointer to a BOOL that receives information on whether or not we
                          logged to Cdm.dll that we could not find a driver for this device.
                          
    pbSetRestorePoint - pointer to a BOOL that is set to TRUE if we needed to set
                        a system restore point because the drivers we were 
                        installing were not digitally signed. It is assumed that
                        if the caller wants to know if we called SRSetRestorePoint
                        then it is their responsiblity to call it again with
                        END_NESTED_SYSTEM_CHANGE to end the restore point. If 
                        the caller does not want this responsibility then they
                        should pass in NULL for this value and this function 
                        will handle calling SRSetRestorePoint with
                        END_NESTED_SYSTEM_CHANGE.                         


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    PSP_INSTALLWIZARD_DATA  InstallWizard;
    CONFIGRET ConfigRet;
    ULONG ConfigFlag, Len;
    NEWDEVWIZ NewDevWiz;
    SP_DRVINFO_DATA DriverInfoData;
    HWND hDlg;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    ULONG SearchOptions;
    CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;

    if (pbSetRestorePoint) {
        *pbSetRestorePoint = FALSE;
    }
    
    //
    // ensure we have a device instance, and that we are Admin.
    //
    if (!DeviceInstanceId  || !*DeviceInstanceId) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the InstallType is NDWTYPE_UPDATE_SILENT then they must pass in
    // an UpdateDriverInfo structure
    //
    if ((InstallType == NDWTYPE_UPDATE_SILENT) && !UpdateDriverInfo) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (NoPrivilegeWarning(hwndParent)) {

        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    memset(&NewDevWiz, 0, sizeof(NewDevWiz));

    NewDevWiz.InstallType = InstallType;
    NewDevWiz.SilentMode = FALSE;
    NewDevWiz.UpdateDriverInfo = UpdateDriverInfo;

    NewDevWiz.hDeviceInfo = SetupDiCreateDeviceInfoList(NULL, hwndParent);

    if (NewDevWiz.hDeviceInfo == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    NewDevWiz.LastError = ERROR_SUCCESS;

    NewDevWiz.Flags = Flags;

    try {

        //
        // Set the PSPGF_NONINTERACTIVE SetupGlobalFlag if we are in NonInteractive
        // mode. This means that setupapi will fail if it needs to display any UI
        // at all.
        //
        if (Flags & IDI_FLAG_NONINTERACTIVE) {

            pSetupSetGlobalFlags(pSetupGetGlobalFlags() | PSPGF_NONINTERACTIVE);
        }

        NewDevWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiOpenDeviceInfo(NewDevWiz.hDeviceInfo,
                                   DeviceInstanceId,
                                   hwndParent,
                                   0,
                                   &NewDevWiz.DeviceInfoData
                                   ))
        {
            NewDevWiz.LastError = GetLastError();
            goto IDIExit;
        }

        ConfigRet = CM_Get_Device_ID(NewDevWiz.DeviceInfoData.DevInst,
                                     NewDevWiz.InstallDeviceInstanceId,
                                     sizeof(NewDevWiz.InstallDeviceInstanceId)/sizeof(TCHAR),
                                     0
                                     );

        if (ConfigRet != CR_SUCCESS) {

            NewDevWiz.LastError = ConfigRet;
            goto IDIExit;
        }

        SetupDiSetSelectedDevice(NewDevWiz.hDeviceInfo, &NewDevWiz.DeviceInfoData);


        //
        // Get the ConfigFlags
        //
        Len = sizeof(ConfigFlag);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(NewDevWiz.DeviceInfoData.DevInst,
                                                   CM_DRP_CONFIGFLAGS,
                                                   NULL,
                                                   (PVOID)&ConfigFlag,
                                                   &Len,
                                                   0,
                                                   NULL
                                                   );

        if (ConfigRet == CR_SUCCESS && (ConfigFlag & CONFIGFLAG_MANUAL_INSTALL)) {

            NewDevWiz.Flags |= IDI_FLAG_MANUALINSTALL;
        }

        //
        // Get the device capabilities
        //
        Len = sizeof(NewDevWiz.Capabilities);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(NewDevWiz.DeviceInfoData.DevInst,
                                                        CM_DRP_CAPABILITIES,
                                                        NULL,
                                                        (PVOID)&NewDevWiz.Capabilities,
                                                        &Len,
                                                        0,
                                                        NULL
                                                        );
        if (ConfigRet != CR_SUCCESS) {

            NewDevWiz.Capabilities = 0;
        }

        //
        // initialize DeviceInstallParams
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        if (SetupDiGetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {

            DeviceInstallParams.Flags |= DI_SHOWOEM;
            DeviceInstallParams.hwndParent = hwndParent;

            //
            // If not manually installed, allow excluded drivers.
            //
            if (!(NewDevWiz.Flags & IDI_FLAG_MANUALINSTALL)) {

                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;
            }

            SetupDiSetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        else {

            NewDevWiz.LastError = GetLastError();
            goto IDIExit;
        }

        //
        // Set the ClassGuidSelected and ClassName field of NewDevWiz so we can have
        // the correct icon and class name for the device.
        //
        if (!IsEqualGUID(&NewDevWiz.DeviceInfoData.ClassGuid, &GUID_NULL)) {

            NewDevWiz.ClassGuidSelected = &NewDevWiz.DeviceInfoData.ClassGuid;

            if (!SetupDiClassNameFromGuid(NewDevWiz.ClassGuidSelected,
                                          NewDevWiz.ClassName,
                                          sizeof(NewDevWiz.ClassName),
                                          NULL
                                          )) {

                NewDevWiz.ClassGuidSelected = NULL;
                *NewDevWiz.ClassName = TEXT('\0');
            }
        }

        //
        // Create the CancelEvent in case the user wants to cancel out of the driver search
        //
        NewDevWiz.CancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        //
        // At this point we have three different cases.
        //
        // 1) Normal Update Driver case - In this case we jump directly to the Update Driver wizard code
        // 2) Silent Update Driver case - This case is treated very similar to the new hardware case. We
        //    will silently search for an updated driver in the given path or INF and if we find a (better)
        //    driver then we will install it.
        // 3) Normal New Hardware case  - In this case we will do an initial search for drivers with the only
        //    UI being the balloon tip on the tray.  If we can't find a driver for this device then we will
        //    Jump into the wizard case.
        //

        //
        // For UPDATE, search all drivers, including old internet drivers
        //
        switch (NewDevWiz.InstallType) {

        case NDWTYPE_FOUNDNEW:
            pInstallDeviceInstanceNewDevice(hwndParent, hBalloonTiphWnd, &NewDevWiz);
            break;

        case NDWTYPE_UPDATE:
            pInstallDeviceInstanceUpdateDevice(hwndParent, &NewDevWiz);
            break;

        case NDWTYPE_UPDATE_SILENT:
            pInstallDeviceInstanceUpdateDeviceSilent(hwndParent, &NewDevWiz);
            break;
        }

        //
        // Cleanup
        //
        if (NewDevWiz.CancelEvent) {

            CloseHandle(NewDevWiz.CancelEvent);
        }

        //
        // Launch Help Center if we could not find a driver for this device.
        //
        if (NewDevWiz.CallHelpCenter) {

            OpenCdmContextIfNeeded(&NewDevWiz.hCdmInstance,
                                   &NewDevWiz.hCdmContext
                                   );
    
            CdmLogDriverNotFound(NewDevWiz.hCdmInstance,
                                 NewDevWiz.hCdmContext,
                                 DeviceInstanceId,
                                 0
                                 );

            //
            // Let the caller know that we logged to cdm.dll that a driver
            // was not found.
            //
            if (pbLogDriverNotFound) {
                *pbLogDriverNotFound = TRUE;
            } else {
                //
                // If the caller did not want to know if we logged a 'not found'
                // driver to cdm.dll then at this point we need to tell Cdm
                // to call help center with it's list of 'not found' drivers.
                //
                CdmLogDriverNotFound(NewDevWiz.hCdmInstance,
                                     NewDevWiz.hCdmContext,
                                     NULL,
                                     0x00000002
                                     );
            }

        } else if (pbLogDriverNotFound) {
            *pbLogDriverNotFound = FALSE;
        }

        //
        // Let the caller know whether we had to set a system restore point or 
        // not, if they want to know.
        //
        if (pbSetRestorePoint) {
            *pbSetRestorePoint = NewDevWiz.SetRestorePoint;
        } else if (NewDevWiz.SetRestorePoint) {
            //
            // If the caller did not want to know if we set a restore point and
            // we did set a restore point, then we need to END the restore point
            // by calling SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
            //
            pSetSystemRestorePoint(FALSE, FALSE, 0);
        }

        //
        // copy out the reboot flags for the caller
        // or put up the restart dialog if caller didn't ask for the reboot flag
        //
        if (pReboot) {

            *pReboot = NewDevWiz.Reboot;
        }

        else if (NewDevWiz.Reboot) {

             RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }

IDIExit:
   ;

    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {
          NewDevWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    if (NewDevWiz.hDeviceInfo &&
        (NewDevWiz.hDeviceInfo != INVALID_HANDLE_VALUE)) {

        SetupDiDestroyDeviceInfoList(NewDevWiz.hDeviceInfo);
        NewDevWiz.hDeviceInfo = NULL;
    }

    //
    // If the caller wants the CdmInstance hmodule and context handle then pass
    // them back, otherwise close them.
    //
    if (hCdmContext) {
        *hCdmContext = NewDevWiz.hCdmContext;
    } else {

        //
        // The caller doesn't want the cdm context so close it if we have loaded
        // cdm.dll and opened a context.
        //
        if (NewDevWiz.hCdmInstance && NewDevWiz.hCdmContext) {
    
            pfnCloseCDMContext = (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(NewDevWiz.hCdmInstance,
                                                                        "CloseCDMContext"
                                                                        );
            if (pfnCloseCDMContext) {
                pfnCloseCDMContext(NewDevWiz.hCdmContext);
            }
        }
    }

    if (hCdmInstance) {
        *hCdmInstance = NewDevWiz.hCdmInstance;
    } else {
        FreeLibrary(NewDevWiz.hCdmInstance);
    }

    //
    // Clear the PSPGF_NONINTERACTIVE SetupGlobalFlag
    //
    if (Flags & IDI_FLAG_NONINTERACTIVE) {

        pSetupSetGlobalFlags(pSetupGetGlobalFlags() &~ PSPGF_NONINTERACTIVE);
    }
    
    SetLastError(NewDevWiz.LastError);

    return NewDevWiz.LastError == ERROR_SUCCESS;
}

BOOL
InstallDevInstEx(
   HWND hwndParent,
   LPCWSTR DeviceInstanceId,
   BOOL UpdateDriver,
   PDWORD pReboot,
   BOOL SilentInstall
   )
/*++

Routine Description:

   Exported Entry point from newdev.dll. Installs an existing Device Instance,
   and is invoked by Device Mgr to update a driver, or by Config mgr when a new
   device was found. In both cases the Device Instance exists in the registry.


Arguments:

    hwndParent - Window handle of the top-level window to use for any UI related
                 to installing the device.

    DeviceInstanceId - Supplies the ID of the device instance.  This is the registry
                       path (relative to the Enum branch) of the device instance key.

    UpdateDriver      - TRUE only newer or higher rank drivers are installed.

    pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

    SilentInstall - TRUE means the "New Hardware Found" dialog will not be displayed


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    DWORD InstallType = UpdateDriver ? NDWTYPE_UPDATE : NDWTYPE_FOUNDNEW;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    return InstallDeviceInstance(hwndParent,
                                 NULL,
                                 DeviceInstanceId,
                                 pReboot,
                                 NULL,
                                 IDI_FLAG_SETRESTOREPOINT |
                                 (SilentInstall ? IDI_FLAG_SILENTINSTALL : 0),
                                 InstallType,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL
                                 );
}

BOOL
InstallDevInst(
   HWND hwndParent,
   LPCWSTR DeviceInstanceId,
   BOOL UpdateDriver,
   PDWORD pReboot
   )
{
    return InstallDevInstEx(hwndParent,
                            DeviceInstanceId,
                            UpdateDriver,
                            pReboot,
                            FALSE);
}

BOOL
EnumAndUpgradeDevices(
    HWND hwndParent,
    LPCWSTR HardwareId,
    PUPDATEDRIVERINFO UpdateDriverInfo,
    DWORD Flags,
    PDWORD pReboot
    )
{
    HDEVINFO hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD Index;
    DWORD Size;
    TCHAR DeviceIdList[REGSTR_VAL_MAX_HCID_LEN];
    LPWSTR SingleDeviceId;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    BOOL Match;
    BOOL Result = TRUE;
    BOOL NoSuchDevNode = TRUE;
    ULONG InstallFlags = Flags;
    DWORD SingleNeedsReboot;
    DWORD TotalNeedsReboot = 0;
    DWORD Err = ERROR_SUCCESS;
    int i, count;
    HKEY hKey;
    BOOL bSingleDeviceSetRestorePoint = FALSE;
    BOOL bSetRestorePoint = FALSE;

    count = 0;

    if (pReboot) {
        *pReboot = 0;
    }

    hDevInfo = SetupDiGetClassDevs(NULL,
                                   NULL,
                                   hwndParent,
                                   DIGCF_ALLCLASSES | DIGCF_PRESENT
                                   );

    if (INVALID_HANDLE_VALUE == hDevInfo) {
        return FALSE;
    }

    ZeroMemory(&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    Index = 0;

    //
    // Enumerate through all of the devices until we hit an installation error
    // or we run out of devices
    //
    while (Result &&
           SetupDiEnumDeviceInfo(hDevInfo,
                                 Index++,
                                 &DeviceInfoData
                                 )) {
        Match = FALSE;

        for (i = 0; i < 2; i++) {

            Size = sizeof(DeviceIdList);
            if (SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                 &DeviceInfoData,
                                                 (i ? SPDRP_HARDWAREID : SPDRP_COMPATIBLEIDS),
                                                 NULL,
                                                 (PBYTE)DeviceIdList,
                                                 Size,
                                                 &Size
                                                 )) {

                //
                // If any of the devices Hardware Ids or Compatible Ids match the given ID then
                // we have a match and need to upgrade the drivers on this device.
                //
                for (SingleDeviceId = DeviceIdList;
                     *SingleDeviceId;
                     SingleDeviceId += lstrlen(SingleDeviceId) + 1) {

                    if (_wcsicmp(SingleDeviceId, HardwareId) == 0) {

                        Match = TRUE;
                        NoSuchDevNode = FALSE;
                        break;
                    }
                }
            }
        }

        //
        // If we have a match then install the drivers on this device instance
        //
        if (Match) {

            if (SetupDiGetDeviceInstanceId(hDevInfo,
                                           &DeviceInfoData,
                                           DeviceInstanceId,
                                           SIZECHARS(DeviceInstanceId),
                                           &Size
                                           )) {

                SingleNeedsReboot = 0;

                //
                // Since this API is used only by InstallWindowsUpdateDriver and
                // UpdateDriverForPlugAndPlayDevice then specifiy the NDWTYPE_UPDATE_SILENT
                // Flag.  This will tell the device install code not to show the Found New Hardware
                // balloon tip in the tray and not to bring up the Update Driver Wizard if it can't
                // find a driver in the specified location.
                //
                Result = InstallDeviceInstance(hwndParent,
                                               NULL,
                                               DeviceInstanceId,
                                               &SingleNeedsReboot,
                                               UpdateDriverInfo,
                                               InstallFlags,
                                               NDWTYPE_UPDATE_SILENT,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &bSingleDeviceSetRestorePoint
                                               );

                //
                // Save the last error code from the install.  Since we will be
                // doing multiple installs we want to save any error codes that
                // we get so we will only reset the last error code if our saved
                // error is ERROR_SUCCESS.
                //
                if (!Result && (Err == ERROR_SUCCESS)) {
                    Err = GetLastError();
                }

                count++;

                TotalNeedsReboot |= SingleNeedsReboot;

                //
                // We only want to backup the first device we install...not every one.
                //
                InstallFlags |= IDI_FLAG_NOBACKUP;

                //
                // If we just set a restore point when installing the last device
                // then clear the IDI_FLAG_SETRESTOREPOINT flag so we don't do
                // it for any of the other devices we install.
                // 
                if (bSingleDeviceSetRestorePoint) {
                    bSetRestorePoint = TRUE;
                    InstallFlags &= ~IDI_FLAG_SETRESTOREPOINT;
                }

                //
                // If we performed a backup and this is not the first device, then we need to add
                // this devices DeviceInstanceId to the backup key.
                //
                if ((count > 1) &&
                    (UpdateDriverInfo->BackupRegistryKey[0] != TEXT('\0'))) {

                    DWORD cbData, cbTotalSize;
                    PTSTR DeviceIdsBuffer;
                    PTSTR p;

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     UpdateDriverInfo->BackupRegistryKey,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hKey) == ERROR_SUCCESS) {


                        //
                        // Lets see how big the DeviceInstanceIds buffer is so we can allocate enough
                        // memory.
                        //
                        cbData = 0;
                        if ((RegQueryValueEx(hKey,
                                             DEVICEINSTANCEIDS_REGVALUE,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cbData
                                             ) == ERROR_SUCCESS) &&
                            (cbData)) {

                            //
                            // Allocate a buffer large enough to hold the current list of DeviceInstanceIds,
                            // as well as the current DeviceInstanceId.
                            //
                            cbTotalSize = cbData + ((lstrlen(DeviceInstanceId) + 1) * sizeof(TCHAR));
                            DeviceIdsBuffer = malloc(cbTotalSize);

                            if (DeviceIdsBuffer) {

                                ZeroMemory(DeviceIdsBuffer, cbTotalSize);

                                if (RegQueryValueEx(hKey,
                                                    DEVICEINSTANCEIDS_REGVALUE,
                                                    NULL,
                                                    NULL,
                                                    (LPBYTE)DeviceIdsBuffer,
                                                    &cbData) == ERROR_SUCCESS) {

                                    for (p = DeviceIdsBuffer; *p; p+= (lstrlen(p) + 1)) {
                                        ;
                                    }

                                    //
                                    // p now points to the second terminating NULL character at the end of
                                    // the MULTI_SZ buffer.  This is where we'll put the new DeviceInstanceId.
                                    //
                                    lstrcpy(p, DeviceInstanceId);

                                    //
                                    // Write the new string back into the registry.
                                    //
                                    RegSetValueEx(hKey,
                                                  DEVICEINSTANCEIDS_REGVALUE,
                                                  0,
                                                  REG_MULTI_SZ,
                                                  (LPBYTE)DeviceIdsBuffer,
                                                  cbTotalSize
                                                  );
                                }

                                free(DeviceIdsBuffer);
                            }
                        }

                        RegCloseKey(hKey);
                    }
                }
            }
        }
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);

    //
    // If we had to set a system restore point because one of the drivers we
    // installed was not digitally signed, then at this point we need to call
    // SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
    //
    if (bSetRestorePoint) {
        pSetSystemRestorePoint(FALSE, FALSE, 0);
    }

    //
    // If the caller wants to handle the reboot themselves then pass the information
    // back to them.
    //
    if (pReboot) {
        *pReboot = TotalNeedsReboot;
    }

    //
    // The caller did not specify a pointer to a Reboot DWORD so we will handle the
    // rebooting ourselves if necessary
    //
    else {
        if (TotalNeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }

    //
    // If NoSuchDevNode is TRUE then we were unable to match the specified Hardware ID against
    // any of the devices on the system.  In this case we will set the last error to
    // ERROR_NO_SUCH_DEVINST.
    //
    if (NoSuchDevNode) {
        Err = ERROR_NO_SUCH_DEVINST;
    }

    SetLastError(Err);

    return (Err == ERROR_SUCCESS);
}

BOOL
pDoRollbackDriverCleanup(
    LPCSTR RegistryKeyName,
    PDELINFNODE pDelInfNodeHead
    )
{
    HKEY hKey, hSubKey;
    DWORD Error;
    DWORD cbData;
    TCHAR ReinstallString[MAX_PATH];
    PDELINFNODE     pDelInfNodeCur;

    if ((Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              REINSTALL_REGKEY,
                              0,
                              KEY_ALL_ACCESS,
                              &hKey)) != ERROR_SUCCESS) {

        SetLastError(Error);
        return FALSE;
    }

    //
    // Open up the subkey so we can get the ReinstallString which will give us the directory
    // that we need to delete.
    //
    if (RegOpenKeyEx(hKey,
                     (PTSTR)RegistryKeyName,
                     0,
                     KEY_READ,
                     &hSubKey) == ERROR_SUCCESS) {


        cbData = sizeof(ReinstallString);
        if (RegQueryValueEx(hSubKey,
                            REINSTALLSTRING_REGVALUE,
                            NULL,
                            NULL,
                            (LPBYTE)ReinstallString,
                            &cbData) == ERROR_SUCCESS) {

            //
            // We have verified that this directory is a subdirectory of
            // %windir%\system32\ReinstallBackups so let's delete it.
            // Note that the string contains a foo.inf on the end, so strip that
            // off first.
            //
            PTSTR p = _tcsrchr(ReinstallString, TEXT('\\'));

            if (p) {

                *p = 0;

                RemoveCdmDirectory(ReinstallString);
            }
        }

        RegCloseKey(hSubKey);
    }

    RegDeleteKey(hKey, (PTSTR)RegistryKeyName);

    RegCloseKey(hKey);

    //
    // Now attempt to uninstall any 3rd party INFs that were just rolled
    // back over.  SetupUninstallOEMInf will fail if another device is still
    // using this INF.
    //
    if (pDelInfNodeHead) {

        for (pDelInfNodeCur = pDelInfNodeHead;
             pDelInfNodeCur;
             pDelInfNodeCur = pDelInfNodeCur->pNext) {

            SetupUninstallOEMInf(pDelInfNodeCur->szInf,
                                 0,
                                 NULL
                                 );
        }
    }

    return TRUE;
}

BOOL
RollbackDriver(
    HWND hwndParent,
    LPCSTR RegistryKeyName,
    DWORD Flags,
    PDWORD pReboot
    )
/*++

Routine Description:

   Exported Entry point from newdev.dll. It is invoked by Windows Update to update a driver.
   This function will scan through all of the devices on the machine and attempt to install
   these drivers on any devices that match the given HardwareId.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   RegistryKeyName - This is a subkey of HKLM\Software\Microsoft\Windows\CurrentVersion\Reinstall

   Flags - The following flags are defined:

           ROLLBACK_FLAG_FORCE - Force the rollback even if it is not better than the current driver
           ROLLBACK_FLAG_DO_CLEANUP - Do the necessary cleanup if the rollback was successful. This
                includes deleting the registry key as well as deleting the backup directory.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

Return Value:

   BOOL TRUE if driver rollback succeedes.
        FALSE if no rollback occured.
        GetLastError() will return one of the following values:

--*/
{
    DWORD Error;
    HKEY hKey;
    TCHAR DriverRollbackKey[MAX_DEVICE_ID_LEN];
    TCHAR ReinstallString[MAX_PATH];
    DWORD InstallDeviceFlags;
    DWORD cbData;
    DWORD TotalNeedsReboot = 0, SingleNeedsReboot;
    BOOL  Result = FALSE;
    BOOL  bSingleDeviceSetRestorePoint = FALSE;
    BOOL  bSetRestorePoint = FALSE;
    UPDATEDRIVERINFO UpdateDriverInfo;
    LPTSTR DeviceInstanceIds = NULL;
    LPTSTR p;
    TCHAR CurrentlyInstalledInf[MAX_PATH];
    DWORD cbSize;
    PDELINFNODE pDelInfNodeHead = NULL, pDelInfNodeCur;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    if (!RegistryKeyName || (RegistryKeyName[0] == TEXT('\0'))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (Flags &~ ROLLBACK_BITS) {

        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    lstrcpy(DriverRollbackKey, REINSTALL_REGKEY);
    lstrcat(DriverRollbackKey, TEXT("\\"));
    lstrcat(DriverRollbackKey, (PTSTR)RegistryKeyName);

    if ((Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              DriverRollbackKey,
                              0,
                              KEY_ALL_ACCESS,
                              &hKey)) != ERROR_SUCCESS) {

        SetLastError(Error);
        return FALSE;
    }

    InstallDeviceFlags = (IDI_FLAG_NOBACKUP | IDI_FLAG_ROLLBACK);

    if (Flags & ROLLBACK_FLAG_FORCE) {
    
        InstallDeviceFlags |= IDI_FLAG_FORCE;
    }

    //
    // Set the IDI_FLAG_SETRESTOREPOINT so if the driver we are rolling back
    // to is not digitally signed then we will set a system restore point
    // in case the user needs to rollback from the rollback.
    //
    InstallDeviceFlags |= IDI_FLAG_SETRESTOREPOINT;

    ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));

    //
    // Assume failure
    //
    UpdateDriverInfo.DriverWasUpgraded = FALSE;

    //
    // Read the "ReinstallString" string value.  This contains the path to rollback the drivers
    // from.
    //
    cbData = sizeof(ReinstallString);
    if ((Error = RegQueryValueEx(hKey,
                                REINSTALLSTRING_REGVALUE,
                                NULL,
                                NULL,
                                (LPBYTE)ReinstallString,
                                &cbData)) != ERROR_SUCCESS) {

        //
        // If we can't read the ReinstallString then we can't rollback any drivers!
        //
        SetLastError(Error);
        goto clean0;

    } else if (!cbData) {

        //
        // The ReinstallString value must contain something!
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        goto clean0;
    }

    UpdateDriverInfo.InfPathName = ReinstallString;


    UpdateDriverInfo.DisplayName = NULL;
    UpdateDriverInfo.FromInternet = FALSE;

    //
    // Get the DevDesc, ProviderName, and Mfg from the Reinstall registry key
    // so we know which specific driver node to reinstall from this INF.
    //
    cbData = sizeof(UpdateDriverInfo.Description);
    RegQueryValueEx(hKey,
                    REGSTR_VAL_DEVDESC,
                    NULL,
                    NULL,
                    (LPBYTE)UpdateDriverInfo.Description,
                    &cbData
                    );

    cbData = sizeof(UpdateDriverInfo.ProviderName);
    RegQueryValueEx(hKey,
                    REGSTR_VAL_PROVIDER_NAME,
                    NULL,
                    NULL,
                    (LPBYTE)UpdateDriverInfo.ProviderName,
                    &cbData
                    );

    cbData = sizeof(UpdateDriverInfo.MfgName);
    RegQueryValueEx(hKey,
                    REGSTR_VAL_MFG,
                    NULL,
                    NULL,
                    (LPBYTE)UpdateDriverInfo.MfgName,
                    &cbData
                    );


    //
    // We need to get the DeviceInstanceIds MULTI_SZ string.  This will contain a list of
    // DeviceInstanceIds that we need to rollback.
    //
    if ((Error = RegQueryValueEx(hKey,
                                 DEVICEINSTANCEIDS_REGVALUE,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &cbData)) != ERROR_SUCCESS) {

        SetLastError(Error);
        goto clean0;

    } else if (!cbData) {

        //
        // No DeviceInstanceIds to reinstall
        //
        SetLastError(ERROR_SUCCESS);
        goto clean0;
    }

    DeviceInstanceIds = malloc(cbData + sizeof(TCHAR));

    if (!DeviceInstanceIds) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto clean0;
    }

    ZeroMemory(DeviceInstanceIds, cbData + sizeof(TCHAR));

    if ((Error = RegQueryValueEx(hKey,
                                 DEVICEINSTANCEIDS_REGVALUE,
                                 NULL,
                                 NULL,
                                 (LPBYTE)DeviceInstanceIds,
                                 &cbData)) != ERROR_SUCCESS) {

        SetLastError(Error);
        goto clean0;
    }

    //
    // Enumerate through the list of DeviceInstanceIds and call InstallDeviceInstance() on
    // each one.
    //
    for (p = DeviceInstanceIds; *p; p += lstrlen(p) + 1) {

        SingleNeedsReboot = 0;

        //
        // We we are going to do the cleanup then we need to remember the INF files
        // that were installed before we do the rollback.
        //
        if (Flags & ROLLBACK_FLAG_DO_CLEANUP) {

            cbSize = sizeof(CurrentlyInstalledInf);

            if (GetInstalledInf(0, p, CurrentlyInstalledInf, &cbSize) &&
                IsInfFromOem(CurrentlyInstalledInf)) {

                //
                // Let's check to see if this Inf is already in our list
                //
                for (pDelInfNodeCur = pDelInfNodeHead;
                     pDelInfNodeCur;
                     pDelInfNodeCur = pDelInfNodeCur->pNext) {

                    if (!lstrcmpi(pDelInfNodeCur->szInf, CurrentlyInstalledInf)) {

                        break;
                    }
                }

                //
                // if pDelInfNodeCur is NULL then that means we walked all the way
                // through the linked list and did not find a match for the
                // CurrentlyInstalledInf...so we will add a node.
                //
                if (!pDelInfNodeCur) {

                    pDelInfNodeCur = malloc(sizeof(DELINFNODE));

                    if (pDelInfNodeCur) {

                        lstrcpy(pDelInfNodeCur->szInf, CurrentlyInstalledInf);
                        pDelInfNodeCur->pNext = pDelInfNodeHead;

                        pDelInfNodeHead = pDelInfNodeCur;
                    }
                }
            }
        }

        Result = InstallDeviceInstance(hwndParent,
                                       NULL,
                                       p,
                                       &SingleNeedsReboot,
                                       &UpdateDriverInfo,
                                       InstallDeviceFlags,
                                       NDWTYPE_UPDATE_SILENT,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &bSingleDeviceSetRestorePoint
                                       );

        TotalNeedsReboot |= SingleNeedsReboot;

        if (bSingleDeviceSetRestorePoint) {
            bSetRestorePoint = TRUE;
            InstallDeviceFlags &= ~IDI_FLAG_SETRESTOREPOINT;
        }

        //
        // If we hit an installation error, bail out.
        //
        if (!Result) {

            break;
        }
    }

clean0:
    RegCloseKey(hKey);

    if (DeviceInstanceIds) {
        free(DeviceInstanceIds);
    }

    //
    // If we were successful then lets see if the caller wants us to do the cleanup
    //
    if ((Flags & ROLLBACK_FLAG_DO_CLEANUP) &&
        Result &&
        UpdateDriverInfo.DriverWasUpgraded) {

        pDoRollbackDriverCleanup(RegistryKeyName, pDelInfNodeHead);
    }

    //
    // If we had to set a system restore point because one of the drivers we
    // installed was not digitally signed, then at this point we need to call
    // SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
    //
    if (bSetRestorePoint) {
        pSetSystemRestorePoint(FALSE, FALSE, 0);
    }

    //
    // Free up any memory we allocated to store 3rd party Infs that we want to delete.
    //
    while (pDelInfNodeHead) {
        pDelInfNodeCur = pDelInfNodeHead->pNext;
        free(pDelInfNodeHead);
        pDelInfNodeHead = pDelInfNodeCur;
    }

    //
    // If the caller wants to handle the reboot themselves then pass the information
    // back to them.
    //
    if (pReboot) {
        *pReboot = TotalNeedsReboot;
    } else {
        //
        // The caller did not specify a pointer to a Reboot DWORD so we will handle the
        // rebooting ourselves if necessary
        if (TotalNeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }

    return UpdateDriverInfo.DriverWasUpgraded;
}

BOOL
InstallWindowsUpdateDriver(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR InfPathName,
    LPCWSTR DisplayName,
    BOOL Force,
    BOOL Backup,
    PDWORD pReboot
    )
/*++

Routine Description:

   Exported Entry point from newdev.dll. It is invoked by Windows Update to update a driver.
   This function will scan through all of the devices on the machine and attempt to install
   these drivers on any devices that match the given HardwareId.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HardwareId - Supplies the Hardware ID to match agaist existing devices on the
                system.

   InfPathName - Inf Pathname and associated driver files.

   DisplayName - Friendly UI name which is stored in CDM's reinstall backup registry key
                 "DisplayName" Value.

   Force - if TRUE this API will only look for infs in the directory specified by InfLocation.

   Backup - if TRUE this API will backup the existing drivers before installing the drivers
            from Windows Update.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

Return Value:

   BOOL TRUE if a device was upgraded to a CDM driver.
        FALSE if no devices were upgraded to a CDM driver.  GetLastError()
            will be ERROR_SUCCESS if nothing went wrong, this driver
            simply wasn't for any devices on the machine or wasn't
            better than the current driver.  If GetLastError() returns
            any other error then there was an error during the installation
            of this driver.

--*/
{
    UPDATEDRIVERINFO UpdateDriverInfo;
    DWORD Flags = 0;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));

    UpdateDriverInfo.InfPathName = InfPathName;
    UpdateDriverInfo.DisplayName = DisplayName;
    UpdateDriverInfo.FromInternet = TRUE;

    if (!Backup) {

        Flags = IDI_FLAG_NOBACKUP;
    }

    if (Force) {
        
        Flags = IDI_FLAG_FORCE;
    }

    //
    // Assume that the upgrade will fail
    //
    UpdateDriverInfo.DriverWasUpgraded = FALSE;

    //
    // Call EnumAndUpgradeDevices which will enumerate through all the devices on the machine
    // and for any that match the given hardware ID it will attempt to upgrade to the specified
    // drivers.
    //
    EnumAndUpgradeDevices(hwndParent, HardwareId, &UpdateDriverInfo, Flags, pReboot);

    return UpdateDriverInfo.DriverWasUpgraded;
}

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesW(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    )
/*++

Routine Description:

   This function will scan through all of the devices on the machine and attempt to install
   the drivers in FullInfPath on any devices that match the given HardwareId. The default
   behavior is to only install the specified drivers if the are better then the currently
   installed driver.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HardwareId - Supplies the Hardware ID to match agaist existing devices on the
                system.

   FullInfPath - Full path to an Inf and associated driver files.

   InstallFlags - INSTALLFLAG_FORCE - If this flag is specified then newdev will not compare the
                    specified INF file with the current driver.  The specified INF file and drivers
                    will always be installed unless an error occurs.
                - INSTALLFALG_READONLY - if this flag is specified then newdev will attempt
                    a read-only install. This means that no file copy will be performed and
                    only the registry will be updated. Newdev.dll will do a presence check
                    on all of the files to verify that they are present first before 
                    completing the install.  If all of the files are not present then
                    ERROR_ACCESS_DENIED is returned.
                - INSTALLFLAG_NONINTERACTIVE - absolutely no UI. If any UI needs to be displayed
                    then the API will fail!

   pReboot - Optional address of BOOL to determine if a reboot is required or not.
             If pReboot is NULL then newdev.dll will prompt for a reboot if one is needed. If
             pReboot is a valid BOOL pointer then the reboot status is passed back to the
             caller and it is the callers responsibility to prompt for a reboot if one is
             needed.

Return Value:

   BOOL TRUE if a device was upgraded to the specified driver.
        FALSE if no devices were upgraded to the specified driver.  GetLastError()
            will be ERROR_SUCCESS if nothing went wrong, this driver
            wasn't better than the current driver.  If GetLastError() returns
            any other error then there was an error during the installation
            of this driver.

--*/
{
    UPDATEDRIVERINFO UpdateDriverInfo;
    DWORD NeedsReboot = 0;
    TCHAR FullyQualifiedInfPath[MAX_PATH];
    WIN32_FIND_DATA finddata;
    LPTSTR lpFilePart;
    DWORD Flags = 0;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // First verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Verify the parameters
    //
    if ((!HardwareId || (HardwareId[0] == TEXT('\0'))) ||
        (!FullInfPath || (FullInfPath[0] == TEXT('\0')))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (InstallFlags &~ INSTALLFLAG_BITS) {

        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // Make sure we get the fully qualified path and not a partial path.
    //
    if (GetFullPathName(FullInfPath,
                        SIZECHARS(FullyQualifiedInfPath),
                        FullyQualifiedInfPath,
                        &lpFilePart
                        ) == 0) {

        lstrcpy(FullyQualifiedInfPath, FullInfPath);
    }

    //
    // Make sure that the FullyQualifiedInfPath exists and that it is not
    // a directory.
    //
    if (!FileExists(FullyQualifiedInfPath, &finddata) ||
        (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

    ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));

    UpdateDriverInfo.InfPathName = FullyQualifiedInfPath;
    UpdateDriverInfo.FromInternet = FALSE;
    UpdateDriverInfo.DisplayName = NULL;

    //
    // Assume that the upgrade will fail
    //
    UpdateDriverInfo.DriverWasUpgraded = FALSE;

    //
    // If the INSTALLFLAG_READONLY is set then we will set the internal
    // IDI_FLAG_READONLY_INSTALL flag. The IDI_FLAG_NOBACKUP is also set since
    // we don't want to attempt to backup files when doing a read-only
    // install.
    //
    if (InstallFlags & INSTALLFLAG_READONLY) {

        Flags |= (IDI_FLAG_READONLY_INSTALL | IDI_FLAG_NOBACKUP);
    }

    //
    // If the INSTALLFLAG_NONINTERACTIVE flag is set then we will set the 
    // PSPGF_NONINTERACTIVE SetupGlobalFlag which tells setupapi to fail
    // if any UI at all needs to be displayed.
    //
    if (InstallFlags & INSTALLFLAG_NONINTERACTIVE) {

        Flags |= IDI_FLAG_NONINTERACTIVE;
    }

    //
    // If the INSTALLFLAG_FORCE flag is set then we will set the
    // IDI_FLAGS_FORCE flag which will tell us to not include the 
    // currently installed driver in our search for the best driver.
    //
    if (InstallFlags & INSTALLFLAG_FORCE) {

        Flags |= IDI_FLAG_FORCE;
    }

    //
    // Call EnumAndUpgradeDevices which will enumerate through all the devices on the machine
    // and for any that match the given hardware ID it will attempt to upgrade to the specified
    // drivers.
    //
    EnumAndUpgradeDevices(hwndParent, HardwareId, &UpdateDriverInfo, Flags, &NeedsReboot);

    if (bRebootRequired) {
        if (NeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            *bRebootRequired = TRUE;
        } else {
            *bRebootRequired = FALSE;
        }
    } else {
        if (NeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }

    return UpdateDriverInfo.DriverWasUpgraded;
}

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesA(
    HWND hwndParent,
    LPCSTR HardwareId,
    LPCSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    )
{
    WCHAR   UnicodeHardwareId[MAX_DEVICE_ID_LEN];
    WCHAR   UnicodeFullInfPath[MAX_PATH];

    //
    // Convert the HardwareId and FullInfPath to UNICODE and call
    // InstallDriverForPlugAndPlayDevicesW
    //
    UnicodeHardwareId[0] = TEXT('\0');
    UnicodeFullInfPath[0] = TEXT('\0');
    MultiByteToWideChar(CP_ACP, 0, HardwareId, -1, UnicodeHardwareId, SIZECHARS(UnicodeHardwareId));
    MultiByteToWideChar(CP_ACP, 0, FullInfPath, -1, UnicodeFullInfPath, SIZECHARS(UnicodeFullInfPath));

    return UpdateDriverForPlugAndPlayDevicesW(hwndParent,
                                              UnicodeHardwareId,
                                              UnicodeFullInfPath,
                                              InstallFlags,
                                              bRebootRequired
                                              );
}

DWORD
WINAPI
DevInstallW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
/*++

Routine Description:

    This function is called by newdev.dll itself when the current user is not an Admin.
    UMPNPMGR.DLL calls NEWDEV.DLL ClientSideInstall to install devices.  If the currently logged on
    user does not have Administrator privilleges then NEWDEV.DLL prompts the user for an Administator
    username and password.  It then spawns another instance of newdev.dll using the
    CreateProcessWithLogonW() API and calls this entry point.  This entry point verifies that the
    process has Administrator privileges and if it does it calls InstallDeviceInstance() to install
    the device.

Arguments:

    hwnd - Handle to the parent window.

    hInst - This parameter is ignored.

    szCmd - The command line is the DeviceInstanceId to install.

    nShow - This parameter is ignored.


Return Value:

    returns the last error set from InstallDeviceInstance if the API fails or ERROR_SUCCESS
    if it succeedes.

--*/
{
    BOOL bRebootNeeded = FALSE;
    DWORD LastError = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        ExitProcess(ERROR_IN_WOW64);
        return ERROR_IN_WOW64;
    }

    //
    // First verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {

        ExitProcess(ERROR_ACCESS_DENIED);
        return ERROR_ACCESS_DENIED;
    }

    InstallDeviceInstance(hwnd,
                          NULL,
                          szCmd,
                          &bRebootNeeded,
                          NULL,
                          IDI_FLAG_SECONDNEWDEVINSTANCE | IDI_FLAG_SETRESTOREPOINT,
                          NDWTYPE_FOUNDNEW,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                          );

    LastError = GetLastError();

    if (LastError == ERROR_SUCCESS &&
        bRebootNeeded) {

        LastError = ERROR_SUCCESS_REBOOT_REQUIRED;
    }

    ExitProcess(LastError);
    return LastError;
}


BOOL
SpecialRawDeviceInstallProblem(
    DEVNODE DevNode
    )
/*++

Routine Description:

    There are certain devices that have the RAW capability flag set that need
    a driver to work.  This means the results of the install for these devices
    are special cased so that we display a negative finish balloon message
    instead of a positive one.  
    
    We can tell these bus types by looking up the bus type GUID flags and 
    checking for the BIF_RAWDEVICENEEDSDRIVER flag.

Arguments:

    DevNode

Return Value:

    TRUE if this is one of the special RAW devices and we couldn't find
    a driver to install.

--*/
{
    BOOL bDeviceHasProblem = FALSE;
    DWORD Capabilities = 0;
    DWORD cbData, dwType;

    cbData = sizeof(Capabilities);
    if ((CM_Get_DevNode_Registry_Property(DevNode,
                                          CM_DRP_CAPABILITIES,
                                          &dwType,
                                          (PVOID)&Capabilities,
                                          &cbData,
                                          0) == CR_SUCCESS) &&
        (Capabilities & CM_DEVCAP_RAWDEVICEOK) &&
        (GetBusInformation(DevNode) & BIF_RAWDEVICENEEDSDRIVER) &&
        (IsNullDriverInstalled(DevNode))) {
        //
        // This is a RAW device that has the BIF_RAWDEVICENEEDSDRIVER bus
        // information flag set and it doesn't have any drivers installed on
        // it.  This means it has a problem so we can show the correct balloon
        // text.
        //
        bDeviceHasProblem = TRUE;
    }

    return bDeviceHasProblem;
}

BOOL
PromptAndRunClientAsAdmin(
    PCTSTR DeviceInstanceId,
    BOOL *bRebootRequired
    )
{
    DWORD Err = ERROR_SUCCESS;
    CREDUI_INFO ci;
    PTSTR UserName = NULL;
    PTSTR User = NULL;
    PTSTR Domain = NULL;
    PTSTR Password = NULL;
    PTSTR Caption = NULL;
    PTSTR Message = NULL;
    PTSTR Format = NULL;
    DWORD Status = ERROR_SUCCESS;
    BOOL bInstallSuccessful = FALSE;
    BOOL bInstallComplete = FALSE;
    int AlreadyTriedCount = 0;
    PTCHAR FriendlyName;

    if (bRebootRequired) {
        *bRebootRequired = FALSE;
    }

    //
    // Allocate the memory that we need.
    //
    UserName = LocalAlloc(LPTR, CREDUI_MAX_USERNAME_LENGTH);
    User = LocalAlloc(LPTR, CREDUI_MAX_USERNAME_LENGTH);
    Domain = LocalAlloc(LPTR, CREDUI_MAX_DOMAIN_TARGET_LENGTH);
    Password = LocalAlloc(LPTR, CREDUI_MAX_PASSWORD_LENGTH);
    Caption = LocalAlloc(LPTR, CREDUI_MAX_CAPTION_LENGTH);
    Message = LocalAlloc(LPTR, CREDUI_MAX_MESSAGE_LENGTH);
    Format = LocalAlloc(LPTR, CREDUI_MAX_MESSAGE_LENGTH);

    if (!UserName || !User || !Domain || !Password || !Caption ||
        !Message || !Format) {
        //
        // Not enough memory to create all of the buffers we need to call
        // CredUIPromptForCredentials, so bail out.
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    LoadString(hNewDev, IDS_FOUNDNEWHARDWARE, Caption, CREDUI_MAX_CAPTION_LENGTH/sizeof(TCHAR));
    
    if (LoadString(hNewDev, IDS_LOGON_TEXT, Format, CREDUI_MAX_MESSAGE_LENGTH/sizeof(TCHAR))) {

        DEVNODE DevInst = 0;

        CM_Locate_DevNode(&DevInst, (DEVINSTID)DeviceInstanceId, 0);
    
        if ((DevInst != 0) &&
            ((FriendlyName = BuildFriendlyName(DevInst, FALSE, NULL)) != NULL)) {

            _snwprintf(Message, CREDUI_MAX_MESSAGE_LENGTH/sizeof(TCHAR), Format, FriendlyName);

        } else {

            _snwprintf(Message, CREDUI_MAX_MESSAGE_LENGTH/sizeof(TCHAR), Format, szUnknownDevice);
        }
    }
    
    ZeroMemory(&ci, sizeof(ci));
    
    ci.cbSize = sizeof( ci );
    ci.pszCaptionText = Caption;
    ci.pszMessageText = Message;

    do {

        //
        // The user has not provided valid Admin credentials and they have not tried to
        // provide them MAX_PASSWORD_TRIES times.  So, we need to prompt them to provide
        // valid Admin credentials.
        //
        Status = CredUIPromptForCredentials(&ci,
                                            NULL,
                                            NULL,
                                            0,
                                            UserName,
                                            CREDUI_MAX_USERNAME_LENGTH/sizeof(TCHAR),
                                            Password,
                                            CREDUI_MAX_PASSWORD_LENGTH/sizeof(TCHAR),
                                            NULL,
                                            CREDUI_FLAGS_DO_NOT_PERSIST |
                                            CREDUI_FLAGS_REQUEST_ADMINISTRATOR |
                                            CREDUI_FLAGS_INCORRECT_PASSWORD |
                                            CREDUI_FLAGS_GENERIC_CREDENTIALS |
                                            CREDUI_FLAGS_COMPLETE_USERNAME);

        if (Status == ERROR_SUCCESS) {

            PROCESS_INFORMATION pi;
            STARTUPINFO si;
            TCHAR szCmdLine[MAX_PATH];
            DWORD dwExitCode = ERROR_SUCCESS;
            BOOL bCreateProcessSuccess = FALSE;

            User[0] = TEXT('\0');
            Domain[0] = TEXT('\0');

            CredUIParseUserName(UserName,
                                User,
                                CREDUI_MAX_USERNAME_LENGTH/sizeof(TCHAR),
                                Domain,
                                CREDUI_MAX_DOMAIN_TARGET_LENGTH/sizeof(TCHAR)
                                );

            //
            // We want to create a separate process using CreateProcessEx
            //
            ZeroMemory(&si, sizeof(si));
            ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
            si.cb = sizeof(si);
            si.wShowWindow = SW_SHOW;

            wsprintf(szCmdLine, TEXT("rundll32.exe newdev.dll,DevInstall %s"), DeviceInstanceId);

            bCreateProcessSuccess = CreateProcessWithLogonW(User,
                                                            Domain,
                                                            Password,
                                                            0,
                                                            NULL,
                                                            szCmdLine,
                                                            0,
                                                            NULL,
                                                            NULL,
                                                            &si,
                                                            &pi
                                                            );

            if (bCreateProcessSuccess) {

                ZeroMemory(Password, CREDUI_MAX_PASSWORD_LENGTH);

                //
                // Close the thread handle since all we need is the process handle.
                //
                CloseHandle(pi.hThread);
                
                //
                // The process was successfully created so we need to wait for it to finish.
                //
                WaitForSingleObject(pi.hProcess, INFINITE);

                //
                // Check the return value from the process.  It should be one of the following
                // return values:
                //  ERROR_SUCCESS if the install went successfully.
                //  ERROR_SUCCESS_REBOOT_REQUIRED if the install went successfully and a 
                //      reboot is needed.
                //  ERROR _ACCESS_DENIED if the credentials provided were not admin credentials.
                //  Other - a error code returned because the install failed for some reason.
                //
                GetExitCodeProcess(pi.hProcess, &dwExitCode);

                if ((dwExitCode == ERROR_SUCCESS) ||
                    (dwExitCode == ERROR_SUCCESS_REBOOT_REQUIRED)) {

                    //
                    // Mark this install as complete so we will break out of our loop.
                    //
                    bInstallComplete = TRUE;

                    bInstallSuccessful = TRUE;

                    //
                    // Check if we need to reboot.
                    //
                    if ((dwExitCode == ERROR_SUCCESS_REBOOT_REQUIRED) &&
                        bRebootRequired) {

                        *bRebootRequired = TRUE;
                    }
                }

                //
                // If the error code is not ERROR_SUCCESS, ERROR_SUCCESS_REBOOT_REQUIRED,
                // or ERROR_ACCESS_DENIED then it means the installed failed for some reason.
                // for this case we will set bInstallComplete so we will break out
                // of the loop since we don't want to attempt another install on this
                // device.
                //
                else if (dwExitCode != ERROR_ACCESS_DENIED) {

                    //
                    // Mark this install as complete so we will break out of our loop.
                    //
                    bInstallComplete = TRUE;
                }

                else {
                    if (dwExitCode == ERROR_CANCELLED) {
                        Status = ERROR_CANCELLED;
                    }

                    //
                    // Some type of failure occured while installing this hardware.
                    //
                    Err = dwExitCode;
                }

                CloseHandle(pi.hProcess);
            }

            //
            // If the CreateProcessWithLogonW failed or the exit code for the process
            // was ERROR_ACCESS_DENIED then we need to display the bad credentials
            // message box.
            //
            if (!bCreateProcessSuccess ||
                (dwExitCode == ERROR_ACCESS_DENIED)) {
            
                //
                // The process failed, most likely because the user did not provide a username
                // and password.  So prompt a dialog and do it again.
                //
                TCHAR szWarningMsg[MAX_PATH];
                TCHAR szWarningCaption[MAX_PATH];

                ZeroMemory(Password, CREDUI_MAX_PASSWORD_LENGTH);

                if (LoadString(hNewDev,
                               IDS_NOTADMIN_ERROR,
                               szWarningMsg,
                               MAX_PATH)
                    &&
                    LoadString(hNewDev,
                               IDS_NEWDEVICENAME,
                               szWarningCaption,
                               MAX_PATH))
                {
                    MessageBox(NULL, szWarningMsg, szWarningCaption, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
                }

                //
                // Increment AlreadyTriedCount.  If this gets passed a certain threshold
                // then we should bail out.
                //
                AlreadyTriedCount++;
            }
        
        } else {
            
            //
            // Increment AlreadyTriedCount.  If this gets passed a certain threshold
            // then we should bail out.
            //
            AlreadyTriedCount++;
        }

        ZeroMemory(Password, CREDUI_MAX_PASSWORD_LENGTH);

        //
        // We will keep looping until one of the following things happen:
        //  1) we successfully lauch the second instance of newdev to install the device.
        //  2) the user cancels out of the password prompt dialog
        //  3) the user entered bogus admin credentials more than MAX_PASSWORD_TRIES tims.
        //
    } while ((Status != ERROR_CANCELLED) && 
             !bInstallComplete &&
             (AlreadyTriedCount < MAX_PASSWORD_TRIES));

    //
    // If the install was not completed then the user either cancelled out of could not provide a
    // valid admin credentials.
    //
    if (!bInstallComplete) {
        NoPrivilegeWarning(NULL);
    }

clean0:

    //
    // Free all of the memory that we allocated.
    //
    if (UserName) {
        LocalFree(UserName);
    }

    if (User) {
        LocalFree(User);
    }

    if (Domain) {
        LocalFree(Domain);
    }

    if (Password) {
        LocalFree(Password);
    }

    if (Caption) {
        LocalFree(Caption);
    }

    if (Message) {
        LocalFree(Message);
    }

    if (Format) {
        LocalFree(Format);
    }

    SetLastError(Err);

    return bInstallSuccessful;
}

DWORD
ClientSideInstallThread(
    HANDLE hPipeRead
    )
{
    DWORD Err = ERROR_SUCCESS;
    HMODULE hCdmInstance = NULL;
    HANDLE hCdmContext = NULL;
    BOOL bRunAsAdmin = TRUE;
    HANDLE hDeviceInstallEvent = NULL;
    ULONG InstallFlags = 0;
    DWORD Flags = IDI_FLAG_SETRESTOREPOINT;
    DEVNODE DevNode;
    ULONG Status, Problem;
    ULONG DeviceInstallEventLength, DeviceInstanceIdLength, BytesRead;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    TCHAR DeviceInstallEventName[MAX_PATH];
    DWORD InstallDeviceCount = 0;
    TCHAR FinishText[MAX_PATH];
    BOOL bTotalLogDriverNotFound = FALSE;
    BOOL  bSingleDeviceSetRestorePoint = FALSE;
    BOOL  bSetRestorePoint = FALSE;
    CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;

    bQueuedRebootNeeded = FALSE;

    //
    // The very first thing in the pipe should be the size of the name of the
    // event that we will signal after each device is finished being installed.
    //
    if (ReadFile(hPipeRead,
                 (LPVOID)&DeviceInstallEventLength,
                 sizeof(ULONG),
                 &BytesRead,
                 NULL)) {

        ASSERT(DeviceInstallEventLength != 0);
        if ((DeviceInstallEventLength == 0) ||
            (DeviceInstallEventLength > MAX_PATH)) {
            goto clean0;
        }

        //
        // The next thing in the pipe should be the name of the event that we
        // will signal after each device is finished being installed.
        //
        if (!ReadFile(hPipeRead,
                      (LPVOID)&DeviceInstallEventName,
                      DeviceInstallEventLength,
                      &BytesRead,
                      NULL)) {

            goto clean0;
        }

    } else {
        if (GetLastError() == ERROR_INVALID_HANDLE) {
            //
            // The handle to the named pipe is not valid.  Make sure we don't
            // try to close it on exit.
            //
            hPipeRead = NULL;
        }
        goto clean0;
    }

    //
    // Open a handle to the specified named event that we can set and wait on.
    //
    hDeviceInstallEvent = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                     FALSE,
                                     DeviceInstallEventName);
    if (!hDeviceInstallEvent) {
        goto clean0;
    }

    //
    // Continue reading from the pipe until the other end is closed.
    //
    // The first thing in the pipe is a ULONG Flags value that tells us whether
    // this is a full install or UI only.
    //
    while(ReadFile(hPipeRead,
                   (LPVOID)&InstallFlags,
                   sizeof(DWORD),
                   &BytesRead,
                   NULL)) {

        //
        // Check to see if server side install needs a reboot.
        //
        if (InstallFlags & DEVICE_INSTALL_FINISHED_REBOOT) {
            bQueuedRebootNeeded = TRUE;
        }

        if (InstallFlags & DEVICE_INSTALL_BATCH_COMPLETE) {
            //
            // This is the last message that we should get from umpnpmgr.dll
            // when it has drained it's device install queue.  We will 
            // display a "Windows finished installing hardware" balloon that
            // will hang around until umpnpmgr.dll closes the named pipe,
            // or sends a new device install message.
            //
            // There are three different balloon messages that we can diaplay.
            // 1) all successful
            // 2) need reboot before hardware will work
            // 3) problem installing one or more devices.
            //
            UINT FinishId;

            //
            // Check to see if one of the devices that was installed server-side
            // ended up with a problem.
            //
            if (InstallFlags & DEVICE_INSTALL_PROBLEM) {
                Err = ERROR_INSTALL_FAILURE;
            }

            if (bQueuedRebootNeeded) {
                FinishId = IDS_FINISH_BALLOON_REBOOT;
            } else if (Err != ERROR_SUCCESS) {
                FinishId = IDS_FINISH_BALLOON_ERROR;
            } else {
                FinishId = IDS_FINISH_BALLOON_SUCCESS;
            }

            if (!LoadString(hNewDev, 
                            FinishId, 
                            FinishText, 
                            SIZECHARS(FinishText)
                            )) {
                FinishText[0] = TEXT('\0');
            }

            PostMessage(hTrayIconWnd,
                        WUM_UPDATEUI,
                        (WPARAM)TIP_PLAY_SOUND,
                        (LPARAM)FinishText
                        );

            //
            // If we could not find a driver for any of the new devices we just
            // installed then we need to call Cdm.dll one last time telling it
            // that we are done and it should send it's list to helpcenter.exe
            //
            // Note that we do this here as well as at the bottom of the loop
            // since this finish message hangs around for 10 seconds and that
            // is a long time to wait before we launch help center.
            //
            if (bTotalLogDriverNotFound) {

                bTotalLogDriverNotFound = FALSE;
                
                OpenCdmContextIfNeeded(&hCdmInstance,
                                       &hCdmContext
                                       );

                CdmLogDriverNotFound(hCdmInstance,
                                     hCdmContext,
                                     NULL,
                                     0x00000002
                                     );
            }
        }

        //
        // Read the DeviceInstanceId from the pipe if the DeviceInstanceIdLength
        // is valid.
        //
        if (ReadFile(hPipeRead,
                     (LPVOID)&DeviceInstanceIdLength,
                     sizeof(ULONG),
                     &BytesRead,
                     NULL) &&
            (DeviceInstanceIdLength)) {

            if (DeviceInstanceIdLength > MAX_DEVICE_ID_LEN) {
                goto clean0;
            }

            if (!ReadFile(hPipeRead,
                          (LPVOID)DeviceInstanceId,
                          DeviceInstanceIdLength,
                          &BytesRead,
                          NULL)) {

                //
                // If this read fails then just close the UI and close the process.
                //
                goto clean0;
            }

            if (InstallFlags & DEVICE_INSTALL_UI_ONLY) {

                //
                // If this is a UI only install then send a WUM_UPDATEUI message to the installer
                // window so that it can update the icon and message in the tray.
                //
                PostMessage(hTrayIconWnd,
                            WUM_UPDATEUI,
                            (WPARAM)(TIP_LPARAM_IS_DEVICEINSTANCEID |
                                    ((InstallFlags & DEVICE_INSTALL_PLAY_SOUND) ? TIP_PLAY_SOUND : 0)),
                            (LPARAM)DeviceInstanceId
                            );

                InstallDeviceCount++;

                //
                // If we are only installing a small amount of devices (less than 5) then we
                // want to delay between each device so the user has time to read the balloon
                // tip.  If we are installing more than 5 devices then we want to skip the
                // delay altogether since we have a lot of devices to install and the user
                // probably wants this done as quickly as possible.
                //
                if (InstallDeviceCount < DEVICE_COUNT_FOR_DELAY) {
                    Sleep(DEVICE_COUNT_DELAY);
                }

            } else {

                BOOL bRebootNeeded = FALSE;
                BOOL bLogDriverNotFound = FALSE;

                bSingleDeviceSetRestorePoint= FALSE;

                //
                // This is a full installation.
                //
                PostMessage(hTrayIconWnd,
                            WUM_UPDATEUI,
                            (WPARAM)TIP_LPARAM_IS_DEVICEINSTANCEID,
                            (LPARAM)DeviceInstanceId
                            );

                if (pSetupIsUserAdmin()) {
                    //
                    // This user is an Admin so simply install the device.
                    //
                    InstallDeviceInstance(NULL,
                                          hTrayIconWnd,
                                          DeviceInstanceId,
                                          &bRebootNeeded,
                                          NULL,
                                          Flags,
                                          NDWTYPE_FOUNDNEW,
                                          &hCdmInstance,
                                          &hCdmContext,
                                          &bLogDriverNotFound,
                                          &bSingleDeviceSetRestorePoint
                                          );

                } else {
                    
                    if (bRunAsAdmin) {
                        bRunAsAdmin = PromptAndRunClientAsAdmin(DeviceInstanceId,
                                                                &bRebootNeeded
                                                                );
                    }
                }

                //
                // Remember if there is a problem installing any of the devices.
                //
                if (GetLastError() != ERROR_SUCCESS) {
                    Err = GetLastError();
                }

                if (CM_Locate_DevNode(&DevNode, DeviceInstanceId, 0) == CR_SUCCESS) {
                    //
                    // If we located the devnode and it has a problem set the Err
                    // code so we can tell the user that something failed.
                    // If we cannot locate the devnode then the user most likely
                    // removed the device during the install process, so don't
                    // show this as an error.
                    //
                    if ((CM_Get_DevNode_Status(&Status, &Problem, DevNode, 0) != CR_SUCCESS) ||
                        (Status & DN_HAS_PROBLEM) ||
                        SpecialRawDeviceInstallProblem(DevNode)) {
                        //
                        // Either we couldn't locate the device, or it has some problem,
                        // so set Err to ERROR_INSTALL_FAILURE.  This error won't be
                        // shown, but it will trigger us to put up a different finish
                        // message in the balloon.
                        //
                        Err = ERROR_INSTALL_FAILURE;
                    }
                }

                if (bRebootNeeded) {
                    bQueuedRebootNeeded = TRUE;
                }

                if (bLogDriverNotFound) {
                    bTotalLogDriverNotFound = TRUE;
                }

                //
                // We only want to do one system restore point be batch of device
                // installs, so if the last driver that was installed was not
                // digitally signed and we did a system restore point, then
                // clear the IDI_FLAG_SETRESTOREPOINT.
                //
                if (bSingleDeviceSetRestorePoint) {
                    bSetRestorePoint = TRUE;
                    Flags &= ~IDI_FLAG_SETRESTOREPOINT;
                }
            }
        }

        //
        // We need to set the hDeviceInstallEvent event to let umpnpmgr.dll know that we are finished.
        //
        if (hDeviceInstallEvent) {
            SetEvent(hDeviceInstallEvent);
        }
    }

clean0:

    //
    // If we could not find a driver for any of the new devices we just
    // installed then we need to call Cdm.dll one last time telling it
    // that we are done and it should send it's list to helpcenter.exe
    //
    if (bTotalLogDriverNotFound) {
        
        OpenCdmContextIfNeeded(&hCdmInstance,
                               &hCdmContext
                               );
    
        CdmLogDriverNotFound(hCdmInstance,
                             hCdmContext,
                             NULL,
                             0x00000002
                             );
    }

    if (hCdmInstance) {

        if (hCdmContext) {
            pfnCloseCDMContext = (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hCdmInstance,
                                                                        "CloseCDMContext"
                                                                        );
            if (pfnCloseCDMContext) {
                pfnCloseCDMContext(hCdmContext);
            }
        }

        FreeLibrary(hCdmInstance);
    }

    //
    // If we had to set a system restore point because one of the drivers we
    // installed was not digitally signed, then at this point we need to call
    // SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
    //
    if (bSetRestorePoint) {
        pSetSystemRestorePoint(FALSE, FALSE, 0);
    }

    //
    // Close the event handle
    //
    if (hDeviceInstallEvent) {
        CloseHandle(hDeviceInstallEvent);
    }

    if (hPipeRead) {
        CloseHandle(hPipeRead);
    }

    //
    // Tell the UI to go away because we are done
    //
    PostMessage(hTrayIconWnd, WUM_EXIT, 0, 0);

    return bQueuedRebootNeeded;
}

DWORD
WINAPI
ClientSideInstallW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hThread;
    DWORD ThreadId;
    HANDLE hPipeRead;
    MSG Msg;
    WNDCLASS wndClass;

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        ExitProcess(ERROR_IN_WOW64);
        return ERROR_IN_WOW64;
    }

    //
    // Make sure that a named pipe was specified in the cmd line.
    //
    if(!szCmd || !*szCmd) {
        goto clean0;
    }

    //
    // Wait for the specified named pipe to become available from the server.
    //
    if (!WaitNamedPipe(szCmd,
                       180000) // BUGBUG-2000/07/10-jamesca:  How long should we wait?
                       ) {
        goto clean0;
    }

    //
    // Open a handle to the specified named pipe
    //
    hPipeRead = CreateFile(szCmd,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
    if (INVALID_HANDLE_VALUE == hPipeRead) {
        //
        // If we can't open the specified global named pipe, there is nothing
        // more we can do.
        //
        goto clean0;
    }

    //
    // Lets see if the class has been registered.
    //
    if (!GetClassInfo(hNewDev, NEWDEV_CLASS_NAME, &wndClass)) {

        //
        // register the class
        //
        memset(&wndClass, 0, sizeof(wndClass));
        wndClass.lpfnWndProc = BalloonInfoProc;
        wndClass.hInstance = hNewDev;
        wndClass.lpszClassName = NEWDEV_CLASS_NAME;

        if (!RegisterClass(&wndClass)) {
            CloseHandle(hPipeRead);
            goto clean0;
        }
    }

    //
    // Create a window.
    //
    hTrayIconWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                            NEWDEV_CLASS_NAME,
                            TEXT(""),
                            WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            0,
                            0,
                            NULL,
                            NULL,
                            hNewDev,
                            NULL
                            );

    if (hTrayIconWnd == NULL) {
        CloseHandle(hPipeRead);
        goto clean0;
    }


    //
    // Create the device install thread that will read from the named pipe.
    // Note that once the ClientSideInstallThread is successfully created, it is
    // responsible for closing the handle to the named pipe when its done with
    // it.
    //
    hThread = CreateThread(NULL,
                           0,
                           ClientSideInstallThread,
                           (PVOID)hPipeRead,
                           0,
                           &ThreadId
                           );

    if (!hThread) {
        DestroyWindow(hTrayIconWnd);
        CloseHandle(hPipeRead);
        goto clean0;
    }

    while (IsWindow(hTrayIconWnd)) {

        if (GetMessage(&Msg, NULL, 0, 0)) {

            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }
    }

    //
    // Check if a reboot is needed.
    //
    if (bQueuedRebootNeeded) {

        TCHAR RebootText[MAX_PATH];

        LoadString(hNewDev, IDS_NEWDEVICE_REBOOT, RebootText, SIZECHARS(RebootText));

        RestartDialogEx(hwnd, RebootText, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

clean0:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\intro.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       intro.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <dbt.h>


INT_PTR
InitIntroDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    HFONT hfont;
    HDC hDC;
    int FontSize, PtsPixels;
    HWND hwndParentDlg;
    HWND hwndList;
    LOGFONT LogFont;
    TCHAR Buffer[64];

    //
    // Create the big bold font
    //
    hDC = GetDC(hDlg);

    if (hDC) {
    
        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG1), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        PtsPixels = GetDeviceCaps(hDC, LOGPIXELSY);
        FontSize = 12;
        LogFont.lfHeight = 0 - (PtsPixels * FontSize / 72);
    
        NewDevWiz->hfontTextBigBold = CreateFontIndirect(&LogFont);
    
        if (NewDevWiz->hfontTextBigBold ) {

            SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
        }
    }

    //
    // Create the bold font
    //
    hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG3), WM_GETFONT, 0, 0);
    GetObject(hfont, sizeof(LogFont), &LogFont);
    LogFont.lfWeight = FW_BOLD;
    NewDevWiz->hfontTextBold = CreateFontIndirect(&LogFont);

    if (NewDevWiz->hfontTextBold ) {
        
        SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG3), NewDevWiz->hfontTextBold, TRUE);
    }

    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {

        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_UPGRADE, IDS_INTRO_MSG1_UPGRADE);
    
    } else {

        //
        // The default text on the Wizard is for the Found New Hardware case, so we only
        // need to set the title text.
        //
        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_NEW, IDS_INTRO_MSG1_NEW);
    }

    //
    // Set the Initial radio button state to do auto-search.
    //
    CheckRadioButton(hDlg,
                     IDC_INTRO_SEARCH,
                     IDC_INTRO_ADVANCED,
                     IDC_INTRO_SEARCH
                     );

    return TRUE;
}

INT_PTR CALLBACK
IntroDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    if (wMsg == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (!InitIntroDlgProc(hDlg, NewDevWiz)) {
            
            return FALSE;
        }

        return TRUE;
    }

    switch (wMsg)  {
       
    case WM_DESTROY: {
        if (NewDevWiz->hfontTextBigBold ) {

            DeleteObject(NewDevWiz->hfontTextBigBold);
            NewDevWiz->hfontTextBigBold = NULL;
        }
        
        if (NewDevWiz->hfontTextBold ) {

            DeleteObject(NewDevWiz->hfontTextBold);
            NewDevWiz->hfontTextBold = NULL;
        }
        break;
    }

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_INTRO;
            SetDriverDescription(hDlg, IDC_INTRO_DRVDESC, NewDevWiz);
            
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;

        case PSN_WIZNEXT:
            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_INTRO;

            if (IsDlgButtonChecked(hDlg, IDC_INTRO_SEARCH)) {
            
                //
                // Set the search flags to search the following places automatically:
                // - default INF search path
                // - Windows Update, if we are connected to the Internet
                // - CD-ROM drives
                // - Floppy drives
                //
                NewDevWiz->SearchOptions = (SEARCH_DEFAULT | 
                                            SEARCH_FLOPPY | 
                                            SEARCH_CDROM | 
                                            SEARCH_INET_IF_CONNECTED
                                            );

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SEARCHING);

            } else {

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_ADVANCEDSEARCH);
            }
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;
        }
        break;

    case WM_DEVICECHANGE:
        if ((wParam == DBT_DEVICEARRIVAL) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_devicetype == DBT_DEVTYP_VOLUME) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_flags & DBTF_MEDIA) &&
            (IsDlgButtonChecked(hDlg, IDC_INTRO_SEARCH))) {

            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        }
        break;
    
    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
FinishInstallInitIntroDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    HFONT hfont;
    HDC hDC;
    int FontSize, PtsPixels;
    HWND hwndParentDlg;
    HWND hwndList;
    LOGFONT LogFont;
    TCHAR Buffer[64];

    //
    // Create the big bold font
    //
    hDC = GetDC(hDlg);

    if (hDC) {
    
        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG1), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        PtsPixels = GetDeviceCaps(hDC, LOGPIXELSY);
        FontSize = 12;
        LogFont.lfHeight = 0 - (PtsPixels * FontSize / 72);
    
        NewDevWiz->hfontTextBigBold = CreateFontIndirect(&LogFont);
    
        if (NewDevWiz->hfontTextBigBold ) {

            SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
        }
    }

    //
    // Create the bold font
    //
    hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG3), WM_GETFONT, 0, 0);
    GetObject(hfont, sizeof(LogFont), &LogFont);
    LogFont.lfWeight = FW_BOLD;
    NewDevWiz->hfontTextBold = CreateFontIndirect(&LogFont);

    if (NewDevWiz->hfontTextBold ) {
        
        SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG3), NewDevWiz->hfontTextBold, TRUE);
    }

    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {

        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_UPGRADE, IDS_INTRO_MSG1_UPGRADE);
    
    } else {

        //
        // The default text on the Wizard is for the Found New Hardware case, so we only
        // need to set the title text.
        //
        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_NEW, IDS_INTRO_MSG1_NEW);
    }
    
    return TRUE;
}

INT_PTR CALLBACK
FinishInstallIntroDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HICON hicon;

    if (wMsg == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (!InitIntroDlgProc(hDlg, NewDevWiz)) {
            
            return FALSE;
        }

        return TRUE;
    }

    switch (wMsg)  {
       
    case WM_DESTROY: {
        if (NewDevWiz->hfontTextBigBold ) {

            DeleteObject(NewDevWiz->hfontTextBigBold);
            NewDevWiz->hfontTextBigBold = NULL;
        }
        
        if (NewDevWiz->hfontTextBold ) {

            DeleteObject(NewDevWiz->hfontTextBold);
            NewDevWiz->hfontTextBold = NULL;
        }

        hicon = (HICON)LOWORD(SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0));
        if (hicon) {

            DestroyIcon(hicon);
        }
        break;
    }

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_INTRO;
            SetDriverDescription(hDlg, IDC_INTRO_DRVDESC, NewDevWiz);
            if (SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                if (hicon) {
                    DestroyIcon(hicon);
                }
            }

            //
            // We also need to set the title for the wizard since we are the first wizard
            // page.
            //
            PropSheet_SetTitle(GetParent(hDlg),
                               0,
                               (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) ?
                                MAKEINTRESOURCE(IDS_FOUNDDEVICE) :
                                MAKEINTRESOURCE(IDS_UPDATEDEVICE)
                               );

            break;

        case PSN_RESET:
            break;

        case PSN_WIZNEXT:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

int CALLBACK
BrowseCallbackProc(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    switch (uMsg) {
        
    case BFFM_INITIALIZED:
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
        break;

    case BFFM_SELCHANGED: {
        TCHAR CurrentPath[MAX_PATH];

        if (lParam && SHGetPathFromIDList((LPITEMIDLIST)lParam, CurrentPath)) {

            ConcatenatePaths(CurrentPath, TEXT("*.INF"), MAX_PATH, NULL);

            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)FileExists(CurrentPath, NULL));
        }

        break;
    }

    default:
        break;
    }

    return 0;
}

VOID
DoBrowse(
    HWND hDlg
    )
{
    BROWSEINFO bi;
    TCHAR CurrentLocation[MAX_PATH];
    TCHAR Title[MAX_PATH];
    LPITEMIDLIST pidl;

    ZeroMemory(&bi, sizeof(BROWSEINFO));

    GetDlgItemText(hDlg, 
                   IDC_ADVANCED_LOCATION_COMBO, 
                   CurrentLocation,
                   SIZECHARS(CurrentLocation)
                   );

    if (!LoadString(hNewDev, IDS_BROWSE_TITLE, Title, SIZECHARS(Title))) {
        
        Title[0] = TEXT('0');
    }

    bi.hwndOwner = hDlg;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle = Title;
    bi.ulFlags = BIF_NEWDIALOGSTYLE | 
                 BIF_RETURNONLYFSDIRS | 
                 BIF_RETURNFSANCESTORS | 
                 BIF_STATUSTEXT |
                 BIF_NONEWFOLDERBUTTON |
                 BIF_UAHINT;
    bi.lpfn = BrowseCallbackProc;
    bi.lParam = (LPARAM)CurrentLocation;

    pidl = SHBrowseForFolder(&bi);

    if (pidl && SHGetPathFromIDList(pidl, CurrentLocation)) {

        SetDlgItemText(hDlg,
                       IDC_ADVANCED_LOCATION_COMBO,
                       CurrentLocation
                       );
    }
}

INT_PTR
InitAdvancedSearchDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    PTSTR *PathList;
    UINT  PathCount;
    INT   i;
    DWORD SearchOptions;

    //
    // Set the Initial radio button state to do auto-search.
    //
    CheckRadioButton(hDlg,
                     IDC_ADVANCED_SEARCH,
                     IDC_ADVANCED_LIST,
                     IDC_ADVANCED_SEARCH
                     );

    SearchOptions = GetSearchOptions();

    if ((SearchOptions & SEARCH_FLOPPY) ||
        (SearchOptions & SEARCH_CDROM)) {
    
        CheckDlgButton(hDlg, IDC_ADVANCED_REMOVABLEMEDIA, BST_CHECKED);
    }

    if (SearchOptions & SEARCH_DIRECTORY) {
    
        CheckDlgButton(hDlg, IDC_ADVANCED_LOCATION, BST_CHECKED);
    }

    //
    // Fill in the paths in the combo box
    //
    if (SetupQuerySourceList(0, &PathList, &PathCount)) {

        for (i=0; i<(int)PathCount; i++) {

            SendMessage(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO),
                        CB_ADDSTRING,
                        0,
                        (LPARAM)PathList[i]
                        );
        }

        SetupFreeSourceList(&PathList, PathCount);
    }

    //
    // Disable the search combo box and browse button by default.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), (SearchOptions & SEARCH_DIRECTORY));
    EnableWindow(GetDlgItem(hDlg, IDC_BROWSE), (SearchOptions & SEARCH_DIRECTORY));

    //
    // Limit the text in the edit control to MAX_PATH characters, select
    // the first item and set up the autocomplet for directories.
    //
    SendMessage(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), CB_LIMITTEXT, MAX_PATH, 0);
    SendMessage(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), CB_SETCURSEL, 0, 0);
    SHAutoComplete(GetWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), GW_CHILD), SHACF_FILESYS_DIRS);

    return TRUE;
}

INT_PTR CALLBACK 
AdvancedSearchDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    if (wMsg == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (!InitAdvancedSearchDlgProc(hDlg, NewDevWiz)) {
            
            return FALSE;
        }

        return TRUE;
    }

    switch (wMsg)  {
       
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        
        case IDC_ADVANCED_SEARCH:
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_REMOVABLEMEDIA), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            break;

        case IDC_ADVANCED_LIST:
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_REMOVABLEMEDIA), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE), FALSE);
            break;

        case IDC_ADVANCED_LOCATION:
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            break;

        case IDC_BROWSE:
            if (HIWORD(wParam) == BN_CLICKED) {
                
                DoBrowse(hDlg);
            }
        }
        break;

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_ADVANCEDSEARCH;
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;

        case PSN_WIZNEXT:
            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_ADVANCEDSEARCH;
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);

            if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_SEARCH)) {
            
                NewDevWiz->SearchOptions = SEARCH_DEFAULT | SEARCH_INET_IF_CONNECTED;
                
                if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_REMOVABLEMEDIA)) {

                    NewDevWiz->SearchOptions |= (SEARCH_FLOPPY | SEARCH_CDROM);
                }

                if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION)) {

                    TCHAR TempPath[MAX_PATH];
                    TCHAR MessageTitle[MAX_PATH];
                    TCHAR MessageText[MAX_PATH*2];
                    BOOL bPathIsGood = TRUE;

                    if (GetDlgItemText(hDlg, 
                                       IDC_ADVANCED_LOCATION_COMBO, 
                                       NewDevWiz->BrowsePath,
                                       SIZECHARS(NewDevWiz->BrowsePath)
                                       )) {
                    
                        //
                        // We have a path, now lets verify it. We will verify
                        // both the path, and verify that there is at least
                        // one INF file in that location. If either of these
                        // aren't true then we will display an warning to the
                        // user and remain on this page.
                        //
                        MessageTitle[0] = TEXT('\0');
                        MessageText[0] = TEXT('\0');
                        lstrcpy(TempPath, NewDevWiz->BrowsePath);
                        ConcatenatePaths(TempPath, TEXT("*.INF"), MAX_PATH, NULL);

                        //
                        // We will first check if the path exists at all. To do
                        // this we need to verify that FindFirstFile fails on
                        // the directory, and the directory with *.INF 
                        // concatonated on the end. The reason for this is that
                        // FindFirstFile does not handle root directory paths
                        // correctly for some reason so they need to be special
                        // cased.
                        //
                        if (!FileExists(NewDevWiz->BrowsePath, NULL) &&
                            !FileExists(TempPath, NULL)) {

                            LoadString(hNewDev,
                                       IDS_LOCATION_BAD_DIR,
                                       MessageText,
                                       SIZECHARS(MessageText));
                                
                            bPathIsGood = FALSE;

                        } else if (!FileExists(TempPath, NULL)) {

                            LoadString(hNewDev,
                                       IDS_LOCATION_NO_INFS,
                                       MessageText,
                                       SIZECHARS(MessageText));
                                
                            bPathIsGood = FALSE;
                        }
                        
                        if (bPathIsGood) {
                        
                            SetupAddToSourceList(SRCLIST_SYSIFADMIN, NewDevWiz->BrowsePath);
                            
                            NewDevWiz->SearchOptions |= SEARCH_DIRECTORY;
                        
                        } else {

                            if (GetWindowText(GetParent(hDlg), 
                                              MessageTitle,
                                              SIZECHARS(MessageTitle)) &&
                                (MessageText[0] != TEXT('\0'))) {

                                MessageBox(hDlg, MessageText, MessageTitle, MB_OK | MB_ICONWARNING);
                                SetDlgMsgResult(hDlg, wMsg, -1);
                                break;
                            }
                        }
                    }
                }

                SetSearchOptions(NewDevWiz->SearchOptions);

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SEARCHING);

            } else {

                ULONG DevNodeStatus;
                ULONG Problem=0;
                HDEVINFO hDeviceInfo;
                SP_DRVINFO_DATA DriverInfoData;
                HWND hwndParentDlg = GetParent(hDlg);

                //
                // If we have a selected driver,
                // or we know the class and there wasn't a problem installing
                // go into select device
                //
                //
                DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
                if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          SPDIT_COMPATDRIVER,
                                          0,
                                          &DriverInfoData
                                          )
                    ||
                    (!IsEqualGUID(&NewDevWiz->DeviceInfoData.ClassGuid,
                                  &GUID_NULL
                                  )

                     &&
                     CM_Get_DevNode_Status(&DevNodeStatus,
                                           &Problem,
                                           NewDevWiz->DeviceInfoData.DevInst,
                                           0
                                           ) == CR_SUCCESS
                     &&
                     Problem != CM_PROB_FAILED_INSTALL
                     )) {

                    NewDevWiz->ClassGuidSelected = &NewDevWiz->DeviceInfoData.ClassGuid;
                    NewDevWiz->EnterInto = IDD_NEWDEVWIZ_SELECTDEVICE;
                    SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTDEVICE);
                    break;
                }

                NewDevWiz->ClassGuidSelected = NULL;
                NewDevWiz->EnterInto = IDD_NEWDEVWIZ_SELECTCLASS;
                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTCLASS);
            }
            break;

        case PSN_WIZBACK:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_INTRO);
            break;
        }
        break;

    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDB_BANNERBMP                   100
#define IDB_WATERBMP                    101

#define IDI_NEWDEVICEICON               200
#define IDI_CD                          201
#define IDI_HELPCENTER                  204
#define IDI_BLANK                       205
#define IDI_SIGNED                      206
#define IDI_WARN                        207
#define IDI_INFO                        208

#define IDA_SEARCHING                   300
#define IDA_INSTALLING                  301

#define IDD_NEWDEVWIZ_INTRO                 10125
#define IDD_NEWDEVWIZ_SELECTCLASS           10126
#define IDD_NEWDEVWIZ_SELECTDEVICE          10127
#define IDD_WIZARDEXT_PRESELECT             10128
#define IDD_WIZARDEXT_SELECT                IDD_DYNAWIZ_SELECTCLASS_PAGE
                   // setupapi contains IDD_DYNAWIZ_SELECTDEV_PAGE
#define IDD_WIZARDEXT_PREANALYZE            IDD_DYNAWIZ_ANALYZEDEV_PAGE
#define IDD_WIZARDEXT_PREANALYZE_END        10129
#define IDD_NEWDEVWIZ_ANALYZEDEV            10130

#define IDD_WIZARDEXT_POSTANALYZE           10131
#define IDD_WIZARDEXT_POSTANALYZE_END       10132
#define IDD_NEWDEVWIZ_INSTALLDEV            10133

#define IDD_NEWDEVWIZ_FINISHINSTALL_INTRO   10134
#define IDD_WIZARDEXT_FINISHINSTALL         10135
#define IDD_WIZARDEXT_FINISHINSTALL_END     10136
#define IDD_NEWDEVWIZ_FINISH                10137

#define IDD_NEWDEVWIZ_ADVANCEDSEARCH        10153
#define IDD_NEWDEVWIZ_SEARCHING             10154
#define IDD_NEWDEVWIZ_LISTDRIVERS           10155
#define IDD_NEWDEVWIZ_WUPROMPT              10156
#define IDD_NEWDEVWIZ_USECURRENT_FINISH     10157
#define IDD_NEWDEVWIZ_NODRIVER_FINISH       10158

#define IDC_NDW_TEXT                    1002
#define IDC_NDW_PICKCLASS_CLASSLIST     1007
#define IDC_NDW_PICKCLASS_HWTYPES       1008
#define IDC_NDW_DESCRIPTION             1009
#define IDC_NDW_DISPLAYRESOURCE         1011
#define IDC_CLASSICON                   1014
#define IDC_DRVUPD_DRVDESC              1018
#define IDC_ANIMATE_SEARCH              1057
#define IDC_ANIMATE_INSTALL             1058
#define IDC_PROGRESS_INSTALL            1059
#define IDC_FILECOPY_TEXT1              1061
#define IDC_FILECOPY_TEXT2              1062
#define IDC_STATUS_TEXT                 1063
#define IDC_FINISH_PROMPT               1030
#define IDC_LISTDRIVERS_LISTVIEW        1043
#define IDC_INTRO_MSG1                  1044
#define IDC_INTRO_MSG2                  1045
#define IDC_INTRO_MSG3                  1047
#define IDC_INTRO_DRVDESC               1048
#define IDC_INTRO_SEARCH                1049
#define IDC_INTRO_ADVANCED              1050
#define IDC_INTRO_ICON                  1051
#define IDC_FINISH_MSG1                 1052
#define IDC_FINISH_MSG2                 1053
#define IDC_FINISH_MSG3                 1054
#define IDC_FINISH_MSG4                 1055
#define IDC_HELPCENTER_TEXT             1056
#define IDC_ADVANCED_SEARCH             1058
#define IDC_ADVANCED_LIST               1059
#define IDC_ADVANCED_REMOVABLEMEDIA     1060
#define IDC_ADVANCED_LOCATION           1061
#define IDC_ADVANCED_LOCATION_COMBO     1062
#define IDC_BROWSE                      1063
#define IDC_WU_SEARCHINET               1064
#define IDC_WU_NOSEARCH                 1065
#define IDC_WUPROMPT_MSG1               1066
#define IDC_HELPCENTER_ICON             1069
#define IDC_INFO_ICON                   1070
#define IDC_SIGNED_ICON                 1071
#define IDC_SIGNED_TEXT                 1072
#define IDC_SIGNED_LINK                 1073

#define IDS_UNKNOWN                     2000
#define IDS_NDW_NOTADMIN                2001
#define IDS_NEWDEVICENAME               2002

#define IDS_NEEDREBOOT                  2009
#define IDS_NDW_PICKCLASS1              2027
#define IDS_NDW_ANALYZEERR1             2034
#define IDS_NDW_ANALYZEERR2             2035
#define IDS_NDW_ANALYZEERR3             2036
#define IDS_UPDATEDEVICE                2039
#define IDS_FOUNDDEVICE                 2040
#define IDS_NDW_ERRORFIN1               2041
#define IDS_NDW_ERRORFIN1_PNP           2043
#define IDS_FINISH_PROB_MSG2            2049
#define IDS_FINISH_PROB_MSG4            2050
#define IDS_FINISH_PROB_ERROR_NO_ASSOCIATED_SERVICE     2051
#define IDS_FINISH_PROB_TRUST_E_SUBJECT_FORM_UNKNOWN    2052
#define IDS_NDW_STDCFG1                 2053
#define IDS_NDW_STDCFG2                 2054

#define IDS_NEWDEVWIZ_ADVANCEDSEARCH     2068
#define IDS_NEWDEVWIZ_SEARCH             2069
#define IDS_NEWDEVWIZ_SEARCHING          2070
#define IDS_NEWDEVWIZ_SELECTCLASS        2072
#define IDS_NEWDEVWIZ_SELECTDEVICE       2074
#define IDS_NEWDEVWIZ_ANALYZEDEV         2076
#define IDS_NEWDEVWIZ_INSTALLDEV         2078
#define IDS_NEWDEVWIZ_WUPROMPT           2079
#define IDS_NEWDEVWIZ_LISTDRIVERS        2082
#define IDS_DRIVERDESC                   2085
#define IDS_DRIVERVERSION                2086
#define IDS_DRIVERMFG                    2087
#define IDS_DRIVERINF                    2088
#define IDS_DRIVER_CURR                  2090
#define IDS_DEFAULT_INTERNET_HOST        2099
#define IDS_FOUNDNEW_FOUND               2105
#define IDS_UNKNOWNDEVICE                2108
#define IDS_SEARCHING_RESULTS            2110
#define IDS_INTRO_MSG1_NEW               2113
#define IDS_INTRO_MSG1_UPGRADE           2114
#define IDS_FINISH_MSG1_UPGRADE          2116
#define IDS_FINISH_MSG1_NEW              2117
#define IDS_FINISH_MSG1_INSTALL_PROBLEM  2118
#define IDS_FINISH_MSG1_DEVICE_PROBLEM   2119
#define IDS_NEWDEVICE_REBOOT             2121
#define IDS_NEWSEARCH                    2122
#define IDS_FOUNDNEWHARDWARE             2123
#define IDS_NOTADMIN_ERROR               2125
#define IDS_CONNECT_TITLE                2129
#define IDS_FOUNDNEW_CONNECT             2130
#define IDS_WUFOUND_UPDATEMSG1           2132
#define IDS_WUFOUND_CHOICE1              2133
#define IDS_WUFOUND_CHOICE2              2134
#define IDS_BROWSE_TITLE                 2135
#define IDS_LOGON_TEXT                   2136
#define IDS_LOCATION_BAD_DIR             2137
#define IDS_LOCATION_NO_INFS             2138
#define IDS_SHOWALLDEVICES               2150
#define IDS_FINISH_BALLOON_SUCCESS       2151
#define IDS_FINISH_BALLOON_REBOOT        2152
#define IDS_FINISH_BALLOON_ERROR         2153
#define IDS_UPDATE_SETRESTOREPOINT       2160
#define IDS_NEW_SETRESTOREPOINT          2161
#define IDS_ROLLBACK_SETRESTOREPOINT     2162
#define IDS_FILEOP_FROM                  2170
#define IDS_FILEOP_TO                    2171
#define IDS_FILEOP_FILE                  2172
#define IDS_FILEOP_BACKUP                2173
#define IDS_SYSTEMRESTORE_TEXT           2174
#define IDS_DRIVER_IS_SIGNED             2175
#define IDS_DRIVER_NOT_SIGNED            2176


#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\search.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       search.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <infstr.h>

typedef struct _DirectoryNameList {
   struct _DirectoryNameList *Next;
   UNICODE_STRING DirectoryName;
   WCHAR NameBuffer[1];
} DIRNAMES, *PDIRNAMES;


// CDM exports (there is no public header)
typedef
BOOL
(*PFNCDMINTERNETAVAILABLE)(
    void
    );

WCHAR StarDotStar[]=L"*.*";


BOOL
IsSearchCanceled(
    PNEWDEVWIZ NewDevWiz
    )
{
    DWORD Result;

    //
    // If the caller doesn't pass us a cancel event then that just means they can't
    // cancel the search.
    //
    if (!NewDevWiz->CancelEvent) {

        return FALSE;
    }

    Result = WaitForSingleObject(NewDevWiz->CancelEvent, 0);

    //
    // If Result is WAIT_OBJECT_0 then someone set the event.  This means that
    // we should cancel the driver search.
    //
    if (Result == WAIT_OBJECT_0) {

        return TRUE;
    }

    return FALSE;
}

void
GetDriverSearchPolicy(
    PULONG SearchPolicy
    )
{
    HKEY hKey;
    DWORD CurrentPolicy;
    ULONG cbData;
    OSVERSIONINFOEX info;

    //
    // Assume that all search locations are valid.
    //
    *SearchPolicy = 0;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     TEXT("Software\\Policies\\Microsoft\\Windows\\DriverSearching"),
                     0,
                     KEY_READ,
                     &hKey
                     ) == ERROR_SUCCESS) {

        //
        // Check if we can search the CD
        //
        CurrentPolicy = 0;
        cbData = sizeof(CurrentPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontSearchCD"),
                             NULL,
                             NULL,
                             (LPBYTE)&CurrentPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (CurrentPolicy)) {

            *SearchPolicy |= SEARCH_CDROM;
        }

        //
        // Check if we can search the Floppies
        //
        CurrentPolicy = 0;
        cbData = sizeof(CurrentPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontSearchFloppies"),
                             NULL,
                             NULL,
                             (LPBYTE)&CurrentPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (CurrentPolicy)) {

            *SearchPolicy |= SEARCH_FLOPPY;
        }

        //
        // Check if we can search Windows Update. Note that on DataCenter
        // machines we never search Windows Update.
        //
        info.dwOSVersionInfoSize = sizeof(info);
        if (GetVersionEx((POSVERSIONINFOW)&info) &&
            (info.wSuiteMask & VER_SUITE_DATACENTER)) {
            //
            // This is a DataCenter machine so don't search Windows Update.
            //
            *SearchPolicy |= SEARCH_INET;
            *SearchPolicy |= SEARCH_INET_IF_CONNECTED;
        } else {
            CurrentPolicy = 0;
            cbData = sizeof(CurrentPolicy);
            if ((RegQueryValueEx(hKey,
                                 TEXT("DontSearchWindowsUpdate"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&CurrentPolicy,
                                 &cbData
                                 ) == ERROR_SUCCESS) &&
                (CurrentPolicy)) {
    
                *SearchPolicy |= SEARCH_INET;
                *SearchPolicy |= SEARCH_INET_IF_CONNECTED;
            }
        }

        //
        // Check if we can search locally
        //
        CurrentPolicy = 0;
        cbData = sizeof(CurrentPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontSearchLocally"),
                             NULL,
                             NULL,
                             (LPBYTE)&CurrentPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (CurrentPolicy)) {

            *SearchPolicy |= (SEARCH_DEFAULT | SEARCH_DEFAULT_EXCLUDE_OLD_INET);
        }

        RegCloseKey(hKey);
    }
}

DWORD
GetWUDriverRank(
    PNEWDEVWIZ NewDevWiz,
    LPTSTR HardwareId
    )
{
    DWORD Rank = 0xFFFF;
    TCHAR TempBuffer[REGSTR_VAL_MAX_HCID_LEN];
    ULONG TempBufferLen;
    LPTSTR TempBufferPos;
    int RankCounter;

    //
    // First of all we will start off with a Rank of 0xFFFF which is the worst possible.
    // 
    // We will assume that WU will only return an INF Hardware Id match to us.  This means
    // that if we match against one of the device's HardwareIds then Rank will be between
    // 0x0000 and 0x0999.  Otherwise if we match against one of the device's Compatible Ids
    // then the Rank will be between 0x2000 and 0x2999.
    //
    ZeroMemory(TempBuffer, sizeof(TempBuffer));
    TempBufferLen = sizeof(TempBuffer);
    if (CM_Get_DevInst_Registry_Property(NewDevWiz->DeviceInfoData.DevInst,
                                         CM_DRP_HARDWAREID,
                                         NULL,
                                         TempBuffer,
                                         &TempBufferLen,
                                         0
                                         ) == CR_SUCCESS) {

        if (TempBufferLen > 2 * sizeof(TCHAR)) {

            RankCounter = 0x0000;
            for (TempBufferPos = TempBuffer; 
                 *TempBufferPos;
                 TempBufferPos += (lstrlen(TempBufferPos) + 1), RankCounter++) {

                if (!lstrcmpi(TempBufferPos, HardwareId)) {

                    //
                    // Matched against a Hardware Id
                    //
                    Rank = RankCounter;
                    break;
                }
            }
        }
    }

    if (Rank == 0xFFFF) {
        
        // 
        // We didn't match against a HardwareId so let's go through the Compatible Ids
        //
        ZeroMemory(TempBuffer, sizeof(TempBuffer));
        TempBufferLen = sizeof(TempBuffer);
        if (CM_Get_DevInst_Registry_Property(NewDevWiz->DeviceInfoData.DevInst,
                                             CM_DRP_COMPATIBLEIDS,
                                             NULL,
                                             TempBuffer,
                                             &TempBufferLen,
                                             0
                                             ) == CR_SUCCESS) {

            if (TempBufferLen > 2 * sizeof(TCHAR)) {

                RankCounter = 0x2000;
                for (TempBufferPos = TempBuffer; 
                     *TempBufferPos;
                     TempBufferPos += (lstrlen(TempBufferPos) + 1), RankCounter++) {

                    if (!lstrcmpi(TempBufferPos, HardwareId)) {

                        //
                        // Matcheds against a compatible Id
                        //
                        Rank = RankCounter;
                        break;
                    }
                }
            }
        }
    }

    return Rank;
}

BOOL
IsWUDriverBetter(
    PNEWDEVWIZ NewDevWiz,
    LPTSTR HardwareId,
    LPTSTR DriverVer
    )
{
    BOOL bWUDriverIsBetter = FALSE;
    DWORD WURank;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    FILETIME WUFileTime;

    //
    // WU must at least give us a Hardware Id to compare against.
    //
    if (!HardwareId) {
        
        return FALSE;
    }

    //
    // If we can't get the selected driver then return TRUE.  This will
    // usually happen if we did not find a local driver.
    //
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  &DriverInfoData
                                  )) {
        
        return TRUE;
    }

    //
    // Get the Driver Install Params so we can get the Rank of the selected (best)
    // driver.
    //
    DriverInstallParams.cbSize = sizeof(DriverInstallParams);
    if (!SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       &DriverInfoData,
                                       &DriverInstallParams
                                       )) {

        return TRUE;
    }

    //
    // Get the Rank of the HardwareId that WU returned to us.
    //
    WURank = GetWUDriverRank(NewDevWiz, HardwareId);

    if (WURank < DriverInstallParams.Rank) {

        bWUDriverIsBetter = TRUE;
    
    } else if (WURank == DriverInstallParams.Rank) {

        //
        // Need to compare the DriverDates.
        //
        if (pSetupGetDriverDate(DriverVer,
                                &WUFileTime
                                )) {

            //
            // If CompareFileTime returns 1 then the best driver date is larger.  If
            // it returns 0 or -1 then the dates are the same or the WUFileTime is
            // better, which means we should download this driver.
            //
            if (CompareFileTime(&DriverInfoData.DriverDate, &WUFileTime) != 1) {

                bWUDriverIsBetter = TRUE;
            }
        }
    }

    //
    // default is that the Best driver found is better than the WUDriver.
    //

    return bWUDriverIsBetter;
}

BOOL
SearchWindowsUpdateCache(
    PNEWDEVWIZ NewDevWiz
    )
{
    ULONG SearchPolicy = 0;
    FIND_MATCHING_DRIVER_PROC pfnFindMatchingDriver;
    DOWNLOADINFO DownloadInfo;
    WUDRIVERINFO WUDriverInfo;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    BOOL FoundBetterDriver = FALSE;

    //
    // Verify that this user is allowed to search Windows Update before we continue.
    //
    GetDriverSearchPolicy(&SearchPolicy);

    if (SearchPolicy & SEARCH_INET) {
        //
        // This user is NOT allowed to search Windows Update!
        //
        return FALSE;
    }

    //
    // Check if the search has been canceled.
    //
    if (IsSearchCanceled(NewDevWiz)) {
        goto clean0;
    }

    //
    // Load the Cdm DLL and open a context handle if needed.  If we can't then
    // bail out.
    //
    if (!OpenCdmContextIfNeeded(&NewDevWiz->hCdmInstance,
                                &NewDevWiz->hCdmContext
                                )) {
        goto clean0;
    }

    //
    // Check if the search has been canceled.
    //
    if (IsSearchCanceled(NewDevWiz)) {
        goto clean0;
    }

    pfnFindMatchingDriver = (FIND_MATCHING_DRIVER_PROC)GetProcAddress(NewDevWiz->hCdmInstance,
                                                                      "FindMatchingDriver"
                                                                      );

    if (!pfnFindMatchingDriver) {
        goto clean0;
    }
    //
    // First select the best driver in the list of drivers we have built so far
    //
    SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                              NewDevWiz->hDeviceInfo,
                              &NewDevWiz->DeviceInfoData
                              );

    //
    // Fill in the DOWNLOADINFO structure to pass to CDM.DLL
    //
    ZeroMemory(&DownloadInfo, sizeof(DownloadInfo));
    DownloadInfo.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
    DownloadInfo.lpFile = NULL;

    DeviceInstanceId[0] = TEXT('\0');
    CM_Get_Device_ID(NewDevWiz->DeviceInfoData.DevInst,
                     DeviceInstanceId,
                     SIZECHARS(DeviceInstanceId),
                     0
                     );

    DownloadInfo.lpDeviceInstanceID = (LPCTSTR)DeviceInstanceId;

    GetVersionEx((OSVERSIONINFO*)&DownloadInfo.OSVersionInfo);

    //
    // Set dwArchitecture to PROCESSOR_ARCHITECTURE_UNKNOWN, this
    // causes Windows Update to get the architecture of the machine
    // itself.  
    //
    DownloadInfo.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    DownloadInfo.dwFlags = 0;
    DownloadInfo.dwClientID = 0;
    DownloadInfo.localid = 0;

    //
    // Fill in the WUDRIVERINFO structure to pass to CDM.DLL
    //
    ZeroMemory(&WUDriverInfo, sizeof(WUDriverInfo));
    WUDriverInfo.dwStructSize = sizeof(WUDRIVERINFO);

    //
    // Check if the search has been canceled.
    //
    if (IsSearchCanceled(NewDevWiz)) {
        goto clean0;
    }

    if (pfnFindMatchingDriver(NewDevWiz->hCdmContext,
                              &DownloadInfo,
                              &WUDriverInfo
                              )) {

        //
        // Check to see if the WU Driver is better than the best selected
        // driver.
        //
        FoundBetterDriver = IsWUDriverBetter(NewDevWiz,
                                             WUDriverInfo.wszHardwareID,
                                             WUDriverInfo.wszDriverVer
                                             );
    }

clean0:
    ;


    return FoundBetterDriver;
}

BOOL
FixUpDriverListForInet(
    PNEWDEVWIZ NewDevWiz
    )
/*++
    If the best driver is an old Internet driver then it must also be the
    currently installed driver.  If it is not the currently installed driver
    then we will mark it with DNF_BAD_DRIVER and call DIF_SELECTBESTCOMPATDRV
    again.  We will keep doing this until the best driver is either NOT a Internet
    driver, or it is the currently installed driver.
    
    One issue here is if the class installer does not pay attention to the DNF_BAD_DRIVER
    flag and returns it as the best driver anyway.  If this happens then we will return
    FALSE which will cause us to re-build the list filtering out all Old Internet drivers.

--*/
{
    BOOL bReturn = TRUE;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    DWORD NumberOfDrivers = 0;
    DWORD NumberOfIterations = 0;

    ZeroMemory(&DriverInfoData, sizeof(SP_DRVINFO_DATA));
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    while (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 DriverType,
                                 NumberOfDrivers++,
                                 &DriverInfoData)) {
        ;
    }

    //
    // We need to do this over and over again until we get a non Internet Driver or 
    // the currently installed driver.
    //
    while (NumberOfIterations++ <= NumberOfDrivers) {
    
        //
        // Get the best selected driver
        //
        if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DriverInfoData
                                     ))
        {
            //
            // If it is the currently installed driver then we are fine
            //
            if (IsInstalledDriver(NewDevWiz, &DriverInfoData)) {
    
                break;
            }
    
            ZeroMemory(&DriverInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
            DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
    
            if (SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DriverInfoData,
                                              &DriverInstallParams))  {
    
                if (DriverInstallParams.Flags & DNF_OLD_INET_DRIVER) {
    
                    //
                    // If the best driver is already marked with DNF_BAD_DRIVER then we
                    // have a class installer that is picking a Bad driver as the best.
                    // This is not a good idea, so this API will return FALSE which will
                    // cause the entire driver list to get re-built filtering out all
                    // Old Internet drivers.
                    //
                    if (DriverInstallParams.Flags & DNF_BAD_DRIVER) {

                        bReturn = FALSE;
                        break;
                    }
                    
                    //
                    // The best driver is an OLD Internet driver, so mark it
                    // with DNF_BAD_DRIVER and call DIF_SELECTBESTCOMPATDRV
                    //
                    else {
                    
                        DriverInstallParams.Flags = DNF_BAD_DRIVER;
        
                        if (!SetupDiSetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                                           &NewDevWiz->DeviceInfoData,
                                                           &DriverInfoData,
                                                           &DriverInstallParams
                                                           )) {

                            //
                            // If the API fails then just break;
                            //
                            break;
                        }
        
                        if (!SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                                       NewDevWiz->hDeviceInfo,
                                                       &NewDevWiz->DeviceInfoData
                                                       )) {
                            
                            //
                            // If the API fails then just break;
                            //
                            break;
                        }
                    }
                } else {
                    
                    //
                    // The selected driver is not an Internet driver so were good.
                    //
                    break;
                }
            } else {

                //
                // If the API fails then just break
                //
                break;
            }
        } else {

            //
            // If the API fails then just break
            //
            break;
        }
    }

    //
    // If we went through every driver and we still haven't selected a best one then the 
    // class installer is probably removing the DNF_BAD_DRIVER flag and keeps choose the 
    // same Old Internet driver over and over again.  If this happens then we will just
    // return FALSE which will cause us to rebuild the driver list without any old Internet
    // drivers and then select the best driver.
    //
    if (NumberOfIterations > NumberOfDrivers) {

        bReturn = FALSE;
    }

    return bReturn;
}

void
DoDriverSearchInSpecifiedLocations(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    ULONG SearchOptions,
    DWORD DriverType
    )
/*++


--*/
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    //
    // Set the Device Install Params to set the parent window handle.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.hwndParent = hWnd;

        if (SearchOptions & SEARCH_DEFAULT_EXCLUDE_OLD_INET) {

            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;
        }
        
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }


    //
    // Search any single INFs (this only comes in through the UpdateDriverForPlugAndPlayDevices
    // API.  We don't need to update the UI in this case since this is currently always a silent
    // install (upgrade).
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_SINGLEINF)) {

        SP_DRVINFO_DATA DrvInfoData;

        SetDriverPath(NewDevWiz, NewDevWiz->SingleInfPath);

        //
        // OR in the DI_ENUMSINGLEINF flag so that we only look at this specific INF
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }        
        
        //
        // Build up the list in this specific INF file
        //
        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverType
                                   );

        //
        // Clear the DI_ENUMSINGLEINF flag in case we build from the default 
        // INF path next.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags &= ~DI_ENUMSINGLEINF;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }        

        //
        // At this point we should have a list of drivers in the INF that the caller
        // of the UpdateDriverForPlugAndPlayDevices specified.  If the list is empty
        // then the INF they passed us cannot be used on the Hardware Id that they
        // passed in.  In this case we will SetLastError to ERROR_DI_BAD_PATH.
        //
        ZeroMemory(&DrvInfoData, sizeof(SP_DRVINFO_DATA));
        DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

        if (!SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  DriverType,
                                  0,
                                  &DrvInfoData
                                  )) {

            //
            // We wern't able to find any drivers in the specified INF that match
            // the specified hardware ID.
            //
            NewDevWiz->LastError = ERROR_DI_BAD_PATH;
        }
    }


    //
    // Get the currently installed driver for this device only
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_CURRENTDRIVER)) {

        //
        // When getting the currently installed driver we don't need to set
        // the DriverPath because setupapi will figure that out.
        //
        // Set the DI_FLAGSEX_INSTALLEDDRIVER flag to let setupapi know that we
        // just want the installed driver added to the list.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags |= DI_FLAGSEX_INSTALLEDDRIVER;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }        

        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverType
                                   );

        //
        // Clear the DI_FLAGSEX_INSTALLEDDRIVER flag now that we have added
        // the installed driver to the list.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags &= ~DI_FLAGSEX_INSTALLEDDRIVER;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }        
    }


    //
    // Search the default INF path
    //
    if (!IsSearchCanceled(NewDevWiz) && 
        ((SearchOptions & SEARCH_DEFAULT) ||
         (SearchOptions & SEARCH_DEFAULT_EXCLUDE_OLD_INET)))
        
    {
        SetDriverPath(NewDevWiz, NULL);
        
        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverType
                                   );
    }

    //
    // Search any extra paths that the user specified in the wizard
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_DIRECTORY)) 
    {
        SetDriverPath(NewDevWiz, NewDevWiz->BrowsePath);

        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverType
                                   );
    }


    //
    // Search any Windows Update paths.
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_WINDOWSUPDATE)) 
    {
        BOOL bOldInetDriversAllowed = TRUE;

        SetDriverPath(NewDevWiz, NewDevWiz->BrowsePath);

        //
        // We need to OR in the DI_FLAGSEX_INET_DRIVER flag so that setupapi will
        // mark in the INFs PNF that it is from the Internet.  This is important 
        // because we don't want to ever use an Internet INF again since we don't
        // have the drivers locally.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            //
            // When searching using Windows Update we must allow old Internet drivers.  We need
            // to do this since it is posible to backup old Internet drivers and then reinstall 
            // them.
            //
            bOldInetDriversAllowed = (DeviceInstallParams.FlagsEx & DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS)
                ? FALSE : TRUE;
            
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_INET_DRIVER;
            DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;


            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }        
        
        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverType
                                   );

        if (!bOldInetDriversAllowed) {

            //
            // Old Internet drivers were not allowed so we need to reset the DI_FLAGSEX_EXLCUED_OLD_INET_DRIVERS
            // FlagsEx
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
        }
    }


    //
    // Search all floppy drives
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_FLOPPY) )
    {
        UINT DriveNumber=0;

        while (!IsSearchCanceled(NewDevWiz) &&
               (DriveNumber = GetNextDriveByType(DRIVE_REMOVABLE, ++DriveNumber)))
        {
            SearchDriveForDrivers(NewDevWiz, DRIVE_REMOVABLE, DriveNumber);
        }
    }


    //
    // Search all CD-ROM drives
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_CDROM))
    {
        UINT DriveNumber=0;

        while (!IsSearchCanceled(NewDevWiz) &&
               (DriveNumber = GetNextDriveByType(DRIVE_CDROM, ++DriveNumber)))
        {
            SearchDriveForDrivers(NewDevWiz, DRIVE_CDROM, DriveNumber);
        }
    }

    //
    // Search the Internet using CDM.DLL, only if the machine is currently connected
    // to the Internet and CDM.DLL says it has the best driver.
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_INET_IF_CONNECTED)) {

        //
        // If the machine is connected to the Internet and the WU cache says it has
        // a better driver then set the SEARCH_INET flag to get the driver from CDM.DLL
        //
        if (IsInternetAvailable(&NewDevWiz->hCdmInstance) &&
            IsConnectedToInternet() &&
            SearchWindowsUpdateCache(NewDevWiz)) {

            SearchOptions |= SEARCH_INET;
        }
    }

    //
    // Search the Internet using CDM.DLL
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_INET))
    {
        SetDriverPath(NewDevWiz, NULL);

        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_DRIVERLIST_FROM_URL;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }        

        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   SPDIT_COMPATDRIVER
                                   );

        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_DRIVERLIST_FROM_URL;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }
    }
}

void
DoDriverSearch(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    ULONG SearchOptions,
    DWORD DriverType,
    BOOL bAppendToExistingDriverList
    )
{
    ULONG SearchPolicy;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    //
    // The first thing that we do in this code is to Reset the CancelEvent in case it was set 
    // previously.
    //
    if (NewDevWiz->CancelEvent) {
        ResetEvent(NewDevWiz->CancelEvent);
    }

    //
    // Make sure that we filter out the locations that this user is not allowed to search.
    //
    SearchPolicy = 0;
    GetDriverSearchPolicy(&SearchPolicy);

    SearchOptions &= ~SearchPolicy;

    //
    // If the user does not want to append to the existing list then delete the 
    // current driver list.
    //
    if (!bAppendToExistingDriverList) {

        SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     SPDIT_COMPATDRIVER
                                     );
        
        SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     SPDIT_CLASSDRIVER
                                     );
    }

    //
    // Clear out the selected driver
    //
    SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                             &NewDevWiz->DeviceInfoData,
                             NULL
                             );

    //
    // Set the DI_FLAGSEX_APPENDDRIVERLIST since we will be building a big
    // list.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_APPENDDRIVERLIST;
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }
    
    //
    // Build up the list of drivers based on the SearchOptions
    //
    DoDriverSearchInSpecifiedLocations(hWnd, NewDevWiz, SearchOptions, DriverType);

    //
    //Pick the best driver from the list we just created
    //
    SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                              NewDevWiz->hDeviceInfo,
                              &NewDevWiz->DeviceInfoData
                              );
    
    if (!IsSearchCanceled(NewDevWiz)) 
    {
        //
        // We don't allow old Windows Update drivers to be the Best driver
        // unless it is also the Currently installed driver.  So, if the Best
        // driver is an Windows Update driver and not the currently installed driver
        // then we need to re-compute the best driver after marking the node as 
        // BAD.
        //
        // The worst case is that a bad class installer keeps choosing a bad internet
        // driver again and again.  If this is the case then FixUpDriverListForInet
        // will return FALSE and we will re-do the driver search and filter out all
        // of the Old Internet drivers.
        //
        if (!FixUpDriverListForInet(NewDevWiz)) {
    
            //
            // Re-build the entire driver list and filter out all Old Internet drivers
            //
            SearchOptions &= ~SEARCH_DEFAULT;
            SearchOptions |= SEARCH_DEFAULT_EXCLUDE_OLD_INET;
    
            DoDriverSearchInSpecifiedLocations(hWnd, NewDevWiz, SearchOptions, DriverType);
    
            //
            //Pick the best driver from the list we just created
            //
            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                      NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData
                                      );
        }

        //
        // Update the NewDevWiz->ClassGuidSelected with the class of the selected driver.
        //
        if (!IsEqualGUID(&NewDevWiz->DeviceInfoData.ClassGuid, &GUID_NULL)) {
        
            NewDevWiz->ClassGuidSelected = &NewDevWiz->DeviceInfoData.ClassGuid;
        }

        //
        // Note whether we found multiple drivers or not.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  1,
                                  &DriverInfoData
                                  )) {

            NewDevWiz->MultipleDriversFound = TRUE;
        
        } else {
            
            NewDevWiz->MultipleDriversFound = FALSE;

        }
    }

    //
    // Clear the DI_FLAGSEX_APPENDDRIVERLIST flag from the Device Install Params.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_APPENDDRIVERLIST;
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }
}

void
CancelDriverSearch(
    PNEWDEVWIZ NewDevWiz
    )
{
    //
    // First verify that there is a driver search going on by checking that the
    // NewDevWiz->DriverSearchThread is not NULL
    //
    if (NewDevWiz->DriverSearchThread) {

        if (NewDevWiz->CancelEvent) {
        
            //
            // Set the Cancel Event to that the DoDriverSearch() API knows to stop searching.
            //
            SetEvent(NewDevWiz->CancelEvent);
        }
    
        //
        // Tell cdm.dll to stop it's current operation
        //
        CdmCancelCDMOperation(NewDevWiz->hCdmInstance);

        //
        // Tell setupapi.dll to stop it's current driver info search
        //
        SetupDiCancelDriverInfoSearch(NewDevWiz->hDeviceInfo);
    
        //
        // We should always have a window handle if the user was able to cancel.
        //
        if (NewDevWiz->hWnd) {
        
            MSG Msg;
            DWORD WaitReturn;

            //
            // And finaly, wait for the NewDevWiz->DriverSearchThread to terminate
            //
            while ((WaitReturn = MsgWaitForMultipleObjects(1,
                                                           &NewDevWiz->DriverSearchThread,
                                                           FALSE,
                                                           INFINITE,
                                                           QS_ALLINPUT
                                                           ))
                   == WAIT_OBJECT_0 + 1) {

                while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {

                    if (!IsDialogMessage(NewDevWiz->hWnd, &Msg)) {

                        TranslateMessage(&Msg);
                        DispatchMessage(&Msg);
                    }
                }
            }
        }
    }
}

void
SetDriverPath(
   PNEWDEVWIZ NewDevWiz,
   PCTSTR     DriverPath
   )
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  &DeviceInstallParams
                                  );

    wcscpy(DeviceInstallParams.DriverPath, DriverPath ? DriverPath : L"");

    SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  &DeviceInstallParams
                                  );
}

void
SearchDirectoryForDrivers(
    PNEWDEVWIZ NewDevWiz,
    PCTSTR Directory
    )
{
    HANDLE FindHandle;
    PDIRNAMES DirNamesHead=NULL;
    PDIRNAMES DirNames, Next;
    PWCHAR AppendSub;
    ULONG Len;
    WIN32_FIND_DATAW FindData;
    WCHAR SubDirName[MAX_PATH+sizeof(WCHAR)];

    if (IsSearchCanceled(NewDevWiz)) {
        return;
    }

    Len = wcslen(Directory);
    memcpy(SubDirName, Directory, Len*sizeof(WCHAR));
    AppendSub = SubDirName + Len;


    //
    // See if there are is anything (files, subdirs) in this dir.
    //
    *AppendSub = L'\\';
    memcpy(AppendSub+1, StarDotStar, sizeof(StarDotStar));
    
    FindHandle = FindFirstFileW(SubDirName, &FindData);
    

    if (FindHandle == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // There might be inf files so invoke setup to look.
    //
    *AppendSub = L'\0';
    SetDriverPath(NewDevWiz, Directory);
    SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   SPDIT_COMPATDRIVER
                                   );

    //
    // find all of the subdirs, and save them in a temporary buffer,
    // so that we can close the find handle *before* going recursive.
    //
    do {

        if (IsSearchCanceled(NewDevWiz)) {
            break;
        }

        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            wcscmp(FindData.cFileName, L".") &&
            wcscmp(FindData.cFileName, L".."))
        {
            USHORT ulLen;

            ulLen = (USHORT)wcslen(FindData.cFileName) * sizeof(WCHAR);
            DirNames = malloc(sizeof(DIRNAMES) + ulLen);
            if (!DirNames) {
                return;
            }

            DirNames->DirectoryName.Length = ulLen;
            DirNames->DirectoryName.MaximumLength = ulLen + sizeof(WCHAR);
            DirNames->DirectoryName.Buffer = DirNames->NameBuffer;
            memcpy(DirNames->NameBuffer, FindData.cFileName, ulLen + sizeof(WCHAR));

            DirNames->Next = DirNamesHead;
            DirNamesHead = DirNames;

        }

    } while (FindNextFileW(FindHandle, &FindData));

    FindClose(FindHandle);

    if (!DirNamesHead) {
        return;
    }

    *AppendSub++ = L'\\';

    Next = DirNamesHead;
    while (Next) {

         DirNames = Next;

         memcpy(AppendSub,
                DirNames->DirectoryName.Buffer,
                DirNames->DirectoryName.Length + sizeof(WCHAR)
                );

         Next= DirNames->Next;
         free(DirNames);
         SearchDirectoryForDrivers(NewDevWiz, SubDirName);
     }
}

void
SearchDriveForDrivers(
    PNEWDEVWIZ NewDevWiz,
    UINT DriveType,
    UINT DriveNumber
    )
/*++

Routine Description:

    This routine will return whether or not the specified media should be
    searched for drivers, and it will return the path where the search should
    start.
    
    First the specified driver will be checked for an autorun.inf file. If there
    is an autorun.inf with a [DeviceInstall] section that contains a DriverPath=
    value then we will start the search at the path specified by DriverPath=. 
    If the [DeviceInstall] section does not contain any DriverPath= values then
    the entire drive will be skipped. This is a good way for CD's that do not 
    contain drivers to be excluded from the driver search.
    
    If there is no [DeviceInstall] section of the autorun.inf, or there is no 
    autorun.inf then the following rules apply.
    
    - DRIVE_REMOVABLE - search the entire drive if the drive root is A: or B:,
                        otherwise don't search this media.
                        
    - DRIVE_CDROM - search the entire media if the size is less than 1Gig.
                    This means if the media is a CD then we will search the
                    entire CD, but if it is another larger media source, like a
                    DVD then we will not.  We need to search the entire CD for
                    backwards compatibility even through it takes quite a while.

Arguments:

    NewDevWiz - NEWDEVWIZ structure.
    
    DriveType - specifies the type of drive this is, usually DRIVE_REMOVABLE
                or DRIVE_CDROM.
                
    DriveNumber - number specifiy the drive to search: 0 for A:, 1 for B:, etc.                

    
Return Value:


--*/
{
    TCHAR szAutoRunFile[MAX_PATH];
    TCHAR szSectionName[MAX_PATH];
    TCHAR szDriverPath[MAX_PATH];
    TCHAR szSearchPath[MAX_PATH];
    TCHAR DriveRoot[]=TEXT("a:");
    HINF  hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT Context;
    UINT  ErrorLine;
    UINT  PrevMode;

    DriveRoot[0] = DriveNumber - 1 + DriveRoot[0];

    PrevMode = SetErrorMode(0);
    SetErrorMode(PrevMode | SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    try {
        //
        // First check the media for a autorun.inf that contains a [DeviceInstall]
        // section with a DriverPath= value.
        //
        lstrcpy(szAutoRunFile, DriveRoot);
        ConcatenatePaths(szAutoRunFile, TEXT("autorun.inf"), MAX_PATH, NULL);
        szSectionName[0] = TEXT('\0');
    
        hInf = SetupOpenInfFile(szAutoRunFile, NULL, INF_STYLE_OLDNT, &ErrorLine);
    
        if (hInf != INVALID_HANDLE_VALUE) {
            lstrcpy(szSectionName, TEXT("DeviceInstall"));
            //
            // First try the decorated section.
            //
            if (!GetProcessorExtension(szDriverPath, SIZECHARS(szDriverPath)) ||
                (lstrcat(szSectionName, TEXT(".")) == NULL) ||
                (lstrcat(szSectionName, szDriverPath) == NULL) ||
                (SetupGetLineCount(hInf, szSectionName) == -1)) {
                //
                // Decorated section does not exist so try the undecorated section.
                //
                lstrcpy(szSectionName, TEXT("DeviceInstall"));
                if (SetupGetLineCount(hInf, szSectionName) == -1) {
                    //
                    // There is no [DeviceInstall] section in this autorun.inf
                    //
                    szSectionName[0] = TEXT('\0');
                }
            }
        }
    
        //
        // If szSectionName is not 0 then we have a [DeviceInstall] section.  Enumerate
        // this section looking for all of the DriverPath= lines.
        //
        if (szSectionName[0] != TEXT('\0')) {
            if (SetupFindFirstLine(hInf, szSectionName, TEXT("DriverPath"), &Context)) {
                do {
                    //
                    // Process the DriverPath= line.
                    //
                    if (SetupGetStringField(&Context,
                                            1,
                                            szDriverPath,
                                            sizeof(szDriverPath),
                                            NULL)) {
                        //
                        // Search this location recursively.
                        //
                        lstrcpyn(szSearchPath, DriveRoot, SIZECHARS(szSearchPath));
                        ConcatenatePaths(szSearchPath, szDriverPath, SIZECHARS(szSearchPath), NULL);
                        SearchDirectoryForDrivers(NewDevWiz,  (PCTSTR)szSearchPath);
                    }
                } while (SetupFindNextMatchLine(&Context, TEXT("DriverPath"), &Context));
            }
    
            //
            // If we had a valid [DeviceInstall] section then we are done.
            //
            goto clean0;
        }
    
        //
        // At this point there either was no autorun.inf, or it didn't contain a 
        // [DeviceInstall] section or the [DeviceInstall] section didn't contain
        // a DriverPath, so just do the default behavior.
        //
        if (DriveType == DRIVE_REMOVABLE) {
            //
            // We only search A: and B: removable drives by default.
            //
            if ((lstrcmpi(DriveRoot, TEXT("a:")) == 0) ||
                (lstrcmpi(DriveRoot, TEXT("b:")) == 0)) {
                //
                // This is probably a floppy disk since it is A: or B: so search
                // the drive.
                //
                lstrcpyn(szSearchPath, DriveRoot, SIZECHARS(szSearchPath));
                SearchDirectoryForDrivers(NewDevWiz,  (PCTSTR)szSearchPath);
            }
        }
    
        if (DriveType == DRIVE_CDROM) {
            //
            // For DRIVE_CDROM drives we will check the media size and if it is 
            // less than 1Gig then we will assume it is a CD media and search it
            // recursively, otherwise we won't search the drive by default.
            //
            ULARGE_INTEGER FreeBytesAvailable;
            ULARGE_INTEGER TotalNumberOfBytes;
    
            if (GetDiskFreeSpaceEx(DriveRoot,
                                 &FreeBytesAvailable,
                                 &TotalNumberOfBytes,
                                 NULL) &&
                (FreeBytesAvailable.HighPart == 0) &&
                (FreeBytesAvailable.LowPart <= 0x40000000)) {
                //
                // There is less than 1Gig of stuff on this disk so it is probably
                // a CD, so search the entire thing.
                //
                lstrcpyn(szSearchPath, DriveRoot, SIZECHARS(szSearchPath));
                SearchDirectoryForDrivers(NewDevWiz,  (PCTSTR)szSearchPath);
            }
        }
    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {
        ;
    }

clean0:

    SetErrorMode(PrevMode);

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
}

WCHAR szINFDIR[]=L"\\inf\\";

BOOL
IsSelectedDriver(
    PNEWDEVWIZ NewDevWiz,
    PSP_DRVINFO_DATA DriverInfoData
    )
/*++

--*/
{
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DRVINFO_DATA SelectedDriverInfoData;
    SP_DRVINFO_DETAIL_DATA SelectedDriverInfoDetailData;

    SelectedDriverInfoData.cbSize = sizeof(SelectedDriverInfoData);
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &SelectedDriverInfoData
                                 )) {

        //
        // If we can't get the selected driver then just return FALSE
        //
        return FALSE;
    }

    //
    // Compare the SP_DRVINFO_DATA->Descriptions fields
    //
    if (wcscmp(DriverInfoData->Description, SelectedDriverInfoData.Description)) {

        return FALSE;
    }

    //
    // Compare the SP_DRVINFO_DATA->MfgName fields
    //
    if (wcscmp(DriverInfoData->MfgName, SelectedDriverInfoData.MfgName)) {

        return FALSE;
    }

    //
    // Compare the SP_DRVINFO_DATA->ProviderName fields
    //
    if (wcscmp(DriverInfoData->ProviderName, SelectedDriverInfoData.ProviderName)) {

        return FALSE;
    }

    //
    // Get the SP_DRVINFO_DATAIL_DATA structures for both drivers
    //
    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL
                                    )
        &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        
        return FALSE;
    }

    SelectedDriverInfoDetailData.cbSize = sizeof(SelectedDriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    &SelectedDriverInfoData,
                                    &SelectedDriverInfoDetailData,
                                    sizeof(SelectedDriverInfoDetailData),
                                    NULL
                                    )
        &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        
        return FALSE;
    }
    
    //
    // Compare the SP_DRVINFO_DETAIL_DATA->InfFileName fields
    //
    if (wcscmp(DriverInfoDetailData.InfFileName, SelectedDriverInfoDetailData.InfFileName)) {

        return FALSE;
    }

    //
    // Compare the SP_DRVINFO_DETAIL_DATA->SectionName fields
    //
    if (wcscmp(DriverInfoDetailData.SectionName, SelectedDriverInfoDetailData.SectionName)) {

        return FALSE;
    }

    //
    // Compare the SP_DRVINFO_DETAIL_DATA->DrvDescription fields
    //
    if (wcscmp(DriverInfoDetailData.DrvDescription, SelectedDriverInfoDetailData.DrvDescription)) {

        return FALSE;
    }

    //
    // All of the above comparisons worked so this must be the selected driver
    //
    return TRUE;
}

BOOL
IsInstalledDriver(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData  OPTIONAL
   )
/*++
    Determines if the currently selected driver is the
    currently installed driver. By comparing DriverInfoData
    and DriverInfoDetailData.
    
--*/
{
    BOOL bReturn;
    HKEY  hDevRegKey;
    DWORD cbData, Len;
    PWCHAR pwch;
    SP_DRVINFO_DATA SelectedDriverInfoData;
    PSP_DRVINFO_DATA BestDriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    TCHAR Buffer[MAX_PATH*2];
    PVOID pvBuffer=Buffer;

    //
    // Use the PSP_DRVINFO_DATA that was passed in.  If one wasn't passed in the get the
    // selected driver.
    //
    if (DriverInfoData) {

        BestDriverInfoData = DriverInfoData;
    
    } else {

        SelectedDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &SelectedDriverInfoData
                                     )) {

            BestDriverInfoData = &SelectedDriverInfoData;

        } else {
            
            //
            // If there is no currently selected driver then it can't be the installed one
            //
            return FALSE;
        }
    }

    bReturn = FALSE;

    //
    // Open a reg key to the driver specific location
    //
    hDevRegKey = SetupDiOpenDevRegKey(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DRV,
                                      KEY_READ
                                      );

    if (hDevRegKey == INVALID_HANDLE_VALUE) {
    
        goto SIIDExit;
    }


    //
    // Compare Description, Manufacturer, and Provider Name.
    // These are the three unique "keys" within a single inf file.
    // Fetch the drvinfo, drvdetailinfo for the selected device.
    //

    //
    // If the Device Description isn't the same, its a different driver.
    //
    if (!SetupDiGetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,                 // regdatatype
                                          pvBuffer,
                                          sizeof(Buffer),
                                          NULL
                                          )) {
                                          
        *Buffer = TEXT('\0');
    }

    if (wcscmp(BestDriverInfoData->Description, Buffer)) {
    
        goto SIIDExit;
    }


    //
    // If the Manufacturer Name isn't the same, its different
    //

    if (!SetupDiGetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          SPDRP_MFG,
                                          NULL, // regdatatype
                                          pvBuffer,
                                          sizeof(Buffer),
                                          NULL
                                          )) {
                                          
        *Buffer = TEXT('\0');
    }

    if (wcscmp(BestDriverInfoData->MfgName, Buffer)) {
    
        goto SIIDExit;
    }



    //
    // If the Provider Name isn't the same, its different
    //

    cbData = sizeof(Buffer);
    if (RegQueryValueEx(hDevRegKey,
                        REGSTR_VAL_PROVIDER_NAME,
                        NULL,
                        NULL,
                        pvBuffer,
                        &cbData
                        ) != ERROR_SUCCESS) {
                        
        *Buffer = TEXT('\0');
    }

    if (wcscmp(BestDriverInfoData->ProviderName, Buffer)) {
    
        goto SIIDExit;
    }



    //
    // Check the InfName, InfSection and DriverDesc
    // NOTE: the installed infName will not contain the path to the default windows
    // inf directory. If the same inf name has been found for the selected driver
    // from another location besides the default inf search path, then it will
    // contain a path, and is treated as a *different* driver.
    //


    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    BestDriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL
                                    )
        &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        
        goto SIIDExit;
    }



    Len = GetWindowsDirectory(Buffer, MAX_PATH);
    if (Len && Len < MAX_PATH) {
    
        pwch = Buffer + Len - 1;
        if (*pwch != L'\\') {
        
            pwch++;
        }

        wcscpy(pwch, szINFDIR);
        pwch += sizeof(szINFDIR)/sizeof(WCHAR) - 1;

        cbData = MAX_PATH*sizeof(WCHAR);
        if (RegQueryValueEx(hDevRegKey,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            NULL,
                            (PVOID)pwch,
                            &cbData
                            ) != ERROR_SUCCESS )
        {
            *Buffer = TEXT('\0');
        }

        if (_wcsicmp( DriverInfoDetailData.InfFileName, Buffer)) {
        
            goto SIIDExit;
        }

    } else {
    
        goto SIIDExit;
    }



    cbData = sizeof(Buffer);
    if (RegQueryValueEx(hDevRegKey,
                        REGSTR_VAL_INFSECTION,
                        NULL,
                        NULL,
                        pvBuffer,
                        &cbData
                        ) != ERROR_SUCCESS ) {
                        
        *Buffer = TEXT('\0');
    }

    if (wcscmp(DriverInfoDetailData.SectionName, Buffer)) {
    
        goto SIIDExit;
    }


    cbData = sizeof(Buffer);
    if (RegQueryValueEx(hDevRegKey,
                        REGSTR_VAL_DRVDESC,
                        NULL,
                        NULL,
                        pvBuffer,
                        &cbData
                        ) != ERROR_SUCCESS ) {
                        
        *Buffer = TEXT('\0');
    }

    if (wcscmp(DriverInfoDetailData.DrvDescription, Buffer)) {
    
        goto SIIDExit;
    }


    bReturn = TRUE;



SIIDExit:

    if (hDevRegKey != INVALID_HANDLE_VALUE) {
    
        RegCloseKey(hDevRegKey);
    }


    return bReturn;
}

BOOL
IsDriverNodeInteractiveInstall(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData
   )
/*++

    This function checks to see if the given PSP_DRVINFO_DATA is listed as a
    InteractiveInstall in the [ControlFlags] section of the INF.

Return Value:

    TRUE if the driver node is InteractiveInstall, FALSE otherwise.
    
--*/
{
    BOOL b;
    DWORD Err;
    DWORD DriverInfoDetailDataSize;
    HINF hInf;
    INFCONTEXT InfContext;
    TCHAR szBuffer[MAX_PATH];
    DWORD i;
    LPTSTR p;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData;

    //
    // Get the SP_DRVINFO_DETAIL_DATA so we can get the list of hardware and
    // compatible Ids for this device.
    //
    b = SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverInfoData,
                                   NULL,
                                   0,
                                   &DriverInfoDetailDataSize
                                   );

    Err = GetLastError();

    //
    // The above call to get the driver info detail data should never succeed because the
    // buffer will always be too small (we're just interested in sizeing the buffer
    // at this point).
    //
    if (b || (Err != ERROR_INSUFFICIENT_BUFFER)) {

        //
        // For some reason the SetupDiGetDriverInfoDetail API failed...so return FALSE.
        //
        return FALSE;
    }

    //
    // Now that we know how big of a buffer we need to hold the driver info details,
    // allocate the buffer and retrieve the information.
    //
    pDriverInfoDetailData = malloc(DriverInfoDetailDataSize);

    if (!pDriverInfoDetailData) {
        return FALSE;
    }

    pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    DriverInfoData,
                                    pDriverInfoDetailData,
                                    DriverInfoDetailDataSize,
                                    NULL)) {

        free(pDriverInfoDetailData);
        return FALSE;
    }

    //
    // At this point we have all of the hardware and compatible IDs for this driver node.
    // Now we need to open up the INF and see if any of them are referenced in an
    // "InteractiveInstall" control flag entry.
    //
    hInf = SetupOpenInfFile(pDriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {

        //
        // For some reason we couldn't open the INF!
        //
        free(pDriverInfoDetailData);
        return FALSE;
    }

    b = FALSE;

    //
    // Look at each InteractiveInstall line in the INF's [ControlFlags] section...
    //
    if (SetupFindFirstLine(hInf, INFSTR_CONTROLFLAGS_SECTION, INFSTR_KEY_INTERACTIVEINSTALL, &InfContext)) {

        do {
            //
            // and within each line, examine each value...
            //
            for (i = 1;
                 SetupGetStringField(&InfContext, i, szBuffer, sizeof(szBuffer) / sizeof(TCHAR), NULL);
                 i++) {
                //
                // Check to see if this ID matches up with one of the driver node's hardware
                // or compatible IDs.
                //
                for (p = pDriverInfoDetailData->HardwareID; *p; p+= (lstrlen(p) + 1)) {

                    if (!lstrcmpi(p, szBuffer)) {
                        //
                        // We found a match, this device is marked with 
                        // InteractiveInstall.
                        //
                        b = TRUE;
                    }
                }
            }

        } while (SetupFindNextMatchLine(&InfContext, INFSTR_KEY_INTERACTIVEINSTALL, &InfContext));
    }

    SetupCloseInfFile(hInf);
    free(pDriverInfoDetailData);

    return b;
}

BOOL
IsDriverAutoInstallable(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA BestDriverInfoData
   )
/*++

    A driver (the selected driver) is considered auto installable if the following are TRUE:
    
        - It is not a printer
        - This must be a NDWTYPE_FOUNDNEW or NDWTYPE_UPDATE InstallType.
        - There is no "InteractiveInstall" key in the [ControlFlags] section for any of the 
          Hardware or Compatible IDs of this device.
        - There are no other drivers in the list that have the same or better Ranks or Dates then 
          the selected driver.
        - If this is an Update Driver case the selected driver must not be the current driver
        
    The reason for this function is that in the Found New Hardware case we want to automatically
    install the best driver we find.  We can't do that in the case where we have multiple drivers
    that have the same Rank as the best driver found.  The problem is that there are certain cases
    where a user MUST choose the driver in these cases and so we can't automatically make the decision
    for them.  If this API does return FALSE that just means that the user will have to hit Next
    on one extra wizard page.

Return Value:

    TRUE if this device/driver is auto installable.
    FALSE if this device/driver is NOT auto installable.  This means that we will stop on the install
          page and the user will have to hit Next to proceede.
    
--*/
{
    DWORD BestRank;
    DWORD DriverIndex;
    DWORD BestRankCount = 0;
    FILETIME BestDriverDate;
    DWORDLONG BestDriverVersion;
    TCHAR BestProviderName[LINE_LEN];
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    //
    // We only do Auto Installs if this is a NDWTYPE_FOUNDNEW or NDWTYPE_UPDATE install
    //
    if ((NewDevWiz->InstallType != NDWTYPE_FOUNDNEW) &&
        (NewDevWiz->InstallType != NDWTYPE_UPDATE)) {

        return FALSE;
    }

    //
    // We need to special case printers as usuall.
    //
    if (IsEqualGUID(&NewDevWiz->DeviceInfoData.ClassGuid, &GUID_DEVCLASS_PRINTER)) {
        //
        // This is a printer, so if there is more than one printer driver node
        // in the list, this isn't auto-installable.
        //
        DriverInfoData.cbSize = sizeof(DriverInfoData);
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  1,
                                  &DriverInfoData
                                  )) {

            return FALSE;
        }
    }

    //
    // Check if the best driver is listed in the INF as InteractiveInstall. If
    // it is, and there is more than one driver in the list, then this driver
    // is not auto-installable.
    //
    if (IsDriverNodeInteractiveInstall(NewDevWiz, BestDriverInfoData)) {
        //
        // The best driver is marked as InteractiveInstall.  If there is more 
        // than one driver in the list then this driver is NOT auto-installable.
        //
        DriverInfoData.cbSize = sizeof(DriverInfoData);
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  1,
                                  &DriverInfoData
                                  )) {

            return FALSE;
        }
    }

    //
    // First get the Rank of the selected driver.
    //
    DriverInstallParams.cbSize = sizeof(DriverInstallParams);
    if (!SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       BestDriverInfoData,
                                       &DriverInstallParams
                                       )) {

        //
        // If we can't get the Rank of the best driver then just return FALSE
        //
        return FALSE;
    }

    //
    // Remember the Rank and DriverDate of the selected (best) driver.
    //
    BestRank = DriverInstallParams.Rank;
    memcpy(&BestDriverDate, &BestDriverInfoData->DriverDate, sizeof(BestDriverDate));
    BestDriverVersion = BestDriverInfoData->DriverVersion;
    lstrcpy(BestProviderName, BestDriverInfoData->ProviderName);

    DriverInfoData.cbSize = sizeof(DriverInfoData);
    DriverIndex = 0;
    while (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 DriverIndex++,
                                 &DriverInfoData
                                 )) {

        DriverInstallParams.cbSize = sizeof(DriverInstallParams);
        if (SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams
                                           )) {

            //
            // Don't bother doing the comparison if this driver is marked as a BAD driver
            //
            if (!(DriverInstallParams.Flags & DNF_BAD_DRIVER) &&
                !(DriverInstallParams.Flags & DNF_OLD_INET_DRIVER)) {
                //
                // Check if the current driver node is identical enough to the
                // best driver that setupapi picked, so that we need the user
                // to manually pick the one to install.  This should be very
                // rare that the user would ever need to make this choice.
                //
                if (DriverInstallParams.Rank < BestRank) {
                    //
                    // We found another driver node in the list that has a
                    // better (smaller) rank then the best driver.
                    //
                    BestRankCount++;

                } else if ((DriverInstallParams.Rank == BestRank) &&
                           (CompareFileTime(&DriverInfoData.DriverDate, &BestDriverDate) == 1)) {
                    //
                    // We found another driver node in the list that has the 
                    // same rank as the best driver and it has a newer driver
                    // date.
                    //
                    BestRankCount++;

                } else if ((DriverInstallParams.Rank == BestRank) &&
                           (CompareFileTime(&DriverInfoData.DriverDate, &BestDriverDate) == 0)) {
                    //
                    // We found another driver node in the list that has the 
                    // same rank as the best driver and the driver dates are
                    // the same.
                    // Check the provider names and if they are the same, then
                    // check which driver has the larger version, otherwise 
                    // the driver version is meaningless so the user will have
                    // to make the choice.
                    //
                    if (lstrcmpi(BestProviderName, DriverInfoData.ProviderName) == 0) {
                        //
                        // Since the provider names are the same if the current
                        // driver node has a better, or the same, version as the 
                        // best driver then the user will have to manually pick 
                        // which driver they want.
                        //
                        if (DriverInfoData.DriverVersion >= BestDriverVersion) {
                            BestRankCount++;
                        }
                    } else {
                        //
                        // The provider names are different, which means the
                        // driver version information is meaningless, so the
                        // user will have to pick which driver they want.
                        //
                        BestRankCount++;
                    }
                }
            }
        }
    }

    //
    // If BestRankCount is 2 or more than that means we have multiple drivers with the same or better
    // Rank as the best driver.
    //
    if (BestRankCount >= 2) {

        return FALSE;
    }

    //
    // If we are in a NDWTYPE_UPDATE install then we need to make sure that the selected driver is not
    // the current driver.
    //
    if ((NewDevWiz->InstallType == NDWTYPE_UPDATE) &&
        IsInstalledDriver(NewDevWiz, BestDriverInfoData)) {

        return FALSE;
    }

    //
    // If we have come this far then that means 
    // - we're not dealing with a printer
    // - this is either a NDWTYPE_FOUNDNEW or NDWTYPE_UPDATE install
    // - this is not an "InteractiveInstall"
    // - no other driver has the same or better rank then the selected driver.
    // - if this is a NDWTYPE_UPDATE then the selected driver is not the current driver.
    // 
    return TRUE;
}

DWORD WINAPI
DriverSearchThreadProc(
    LPVOID lpVoid
    )
/*++

Description:
    
    In the Wizard, we must do the driver search in a separate thread so that the user has the option
    to cancel out.

--*/
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)lpVoid;

    //
    // Do the driver search.
    //
    DoDriverSearch(NewDevWiz->hWnd, 
                   NewDevWiz, 
                   NewDevWiz->SearchOptions,
                   SPDIT_COMPATDRIVER,
                   FALSE
                   );


    //
    // Post a message to the window to let it know that we are finished with the search
    //
    PostMessage(NewDevWiz->hWnd, WUM_SEARCHDRIVERS, TRUE, GetLastError());

    return GetLastError();
}

INT_PTR CALLBACK
DriverSearchingDlgProc(
    HWND hDlg, 
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz;
    TCHAR PropSheetHeaderTitle[MAX_PATH];

    if (message == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        return TRUE;
    }

    NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message) {

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {
            HICON hicon;
            int PrevPage;

            SetDriverDescription(hDlg, IDC_DRVUPD_DRVDESC, NewDevWiz);

            hicon = NULL;
            if (NewDevWiz->ClassGuidSelected &&
                SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL))
            {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }
            
            else {
                
                SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, NULL);
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                
                DestroyIcon(hicon);
            }

            PrevPage = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SEARCHING;
            NewDevWiz->ExitDetect = FALSE;


            //
            // if coming from IDD_NEWDEVWIZ_INTRO or IDD_NEWDEVWIZ_ADVANCEDSEARCH
            // page then begin driver search
            //
            if ((PrevPage == IDD_NEWDEVWIZ_INTRO) ||
                (PrevPage == IDD_NEWDEVWIZ_ADVANCEDSEARCH) ||
                (PrevPage == IDD_NEWDEVWIZ_WUPROMPT)) {

                DWORD ThreadId;

                LoadString(hNewDev, IDS_NEWDEVWIZ_SEARCHING, PropSheetHeaderTitle, SIZECHARS(PropSheetHeaderTitle));
                
                PropSheet_SetHeaderTitle(GetParent(hDlg),
                                         PropSheet_IdToIndex(GetParent(hDlg), IDD_NEWDEVWIZ_SEARCHING),
                                         PropSheetHeaderTitle
                                         );
                
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

                ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), SW_SHOW);
                Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), MAKEINTRESOURCE(IDA_SEARCHING));
                Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), 0, -1, -1);


                NewDevWiz->CurrCursor = NewDevWiz->IdcAppStarting;
                SetCursor(NewDevWiz->CurrCursor);

                NewDevWiz->hWnd = hDlg;

                //
                // Start up a separate thread to do the driver search on.
                // When the driver searching is complete the DriverSearchThreadProc
                // will post us a WUM_SEARCHDRIVERS message.
                //
                NewDevWiz->DriverSearchThread = CreateThread(NULL,
                                                             0,
                                                             (LPTHREAD_START_ROUTINE)DriverSearchThreadProc,
                                                             (LPVOID)NewDevWiz,
                                                             0,
                                                             &ThreadId
                                                             );
            }

            //
            // if coming back from DRVUPD_FINISH page, search is done,
            // so wait for instructions from user.
            //
            else {
                
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }

        }
        break;

        case PSN_WIZNEXT:
            
            NewDevWiz->EnterInto = IDD_NEWDEVWIZ_INSTALLDEV;

            if (NewDevWiz->DoAutoInstall) {
                //
                // This is the case where we found a better driver (or a driver in the 
                // Found New Hardware case) and so we will just do an AutoInstall.
                //
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_INSTALLDEV);
            
            } else if (NewDevWiz->CurrentDriverIsSelected) {
                //
                // This is the case where the current driver is the best driver.
                //
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_USECURRENT_FINISH);
            
            } else if (NewDevWiz->NoDriversFound) {
                //
                // This is the case where we could not find any drivers for this device.
                //
                //
                // If we could not find any drivers for this device then we have two choices,
                // we either take the user to the Windows Update prompting wizard page,
                // or take them directly to the no driver found finish page.  We will only
                // take them to the Windows Update prompting page if the AlreadySearchedInet
                // BOOL is FALSE and the machine is NOT currently connected to the Internet.
                //
                if (!IsInternetAvailable(&NewDevWiz->hCdmInstance) ||
                    NewDevWiz->AlreadySearchedWU ||
                    IsConnectedToInternet()) {
                
                    SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_NODRIVER_FINISH);

                } else {

                    SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_WUPROMPT);
                }
            } else {
                //
                // If we aren't doing an AutoInstall and this is NOT the current driver or 
                // NO driver case, then we need to jump to the page that lists out the drivers.
                //
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_LISTDRIVERS);
            }
             
            break;

        case PSN_WIZBACK:
            if (NewDevWiz->ExitDetect) {
                SetDlgMsgResult(hDlg, message, -1);
                break;
            }

            NewDevWiz->CurrentDriverIsSelected = FALSE;
            NewDevWiz->ExitDetect = TRUE;
            NewDevWiz->CurrCursor = NewDevWiz->IdcWait;
            SetCursor(NewDevWiz->CurrCursor);
            CancelDriverSearch(NewDevWiz);
            NewDevWiz->CurrCursor = NULL;
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
            SetDlgMsgResult(hDlg, message, NewDevWiz->EnterFrom);
            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
            break;

        case PSN_QUERYCANCEL:
            if (NewDevWiz->ExitDetect) {
                
                SetDlgMsgResult(hDlg, message, TRUE);
                break;
            }

            NewDevWiz->ExitDetect = TRUE;
            NewDevWiz->CurrCursor = NewDevWiz->IdcWait;
            SetCursor(NewDevWiz->CurrCursor);
            CancelDriverSearch(NewDevWiz);
            NewDevWiz->CurrCursor = NULL;
            SetDlgMsgResult(hDlg, message, FALSE);
            break;

        case PSN_RESET:
            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
            break;

        default:
            return FALSE;
        }

        break;


    case WM_DESTROY:
        CancelDriverSearch(NewDevWiz);
        break;


    case WUM_SEARCHDRIVERS: {
    
        SP_DRVINFO_DATA DriverInfoData;

        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
        ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), SW_HIDE);

        NewDevWiz->CurrCursor = NULL;
        SetCursor(NewDevWiz->IdcArrow);

        if (NewDevWiz->ExitDetect) {
            
            break;
        }

        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DriverInfoData
                                     ))
        {
            //
            // We basically have three cases when we find a driver for the device.
            // 1) The driver is autoinstallable. This means we jump directly to the install page.
            // 2) The driver is the current driver. This means we don't reinstall the driver.
            // 3) We have muliple drivers or the drivers aren't autoinstallable.  This means we
            //    show a list of the drivers to the user and make them pick.
            //
            NewDevWiz->NoDriversFound = FALSE;                 

            //
            // If this driver is Auto Installable then we will skip stoping at the Install
            // confirmation page.
            //
            NewDevWiz->DoAutoInstall = IsDriverAutoInstallable(NewDevWiz, &DriverInfoData);
            
            //
            // If the selected driver is the currently installed driver then jump to the currently
            // installed driver finish page.
            //
            if (IsInstalledDriver(NewDevWiz, &DriverInfoData)) {
            
                NewDevWiz->CurrentDriverIsSelected = TRUE;
            }

        } else {

            //
            // This is the case where we could not get a selected driver because we didn't
            // find any drivers in the driver search.
            //
            NewDevWiz->NoDriversFound = TRUE;                 
        }

        //
        // Auto Jump to the next page.
        //
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        break;
    }


    case WM_SETCURSOR:
        if (NewDevWiz->CurrCursor) {

            SetCursor(NewDevWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);


    default:
        return FALSE;

    } // end of switch on message


    return TRUE;
}

INT_PTR CALLBACK
WUPromptDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    static int pEnterFrom;
    static DWORD dwWizCase = 0;
    HICON hicon;

    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)  {
        
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        //
        // Set the Initial radio button state to connect to the Internet.
        //
        CheckRadioButton(hDlg,
                         IDC_WU_SEARCHINET,
                         IDC_WU_NOSEARCH,
                         IDC_WU_SEARCHINET
                         );

        pEnterFrom = NewDevWiz->EnterFrom;
    }
    break;

    case WM_DESTROY:
        hicon = (HICON)LOWORD(SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0));
        if (hicon) {

            DestroyIcon(hicon);
        }
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_WUPROMPT;

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

            hicon = NULL;
            if (NewDevWiz->ClassGuidSelected &&
                SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL))
            {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }
            
            else {
                
                SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, NULL);
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                
                DestroyIcon(hicon);
            }

            SetDriverDescription(hDlg, IDC_DRVUPD_DRVDESC, NewDevWiz);
            break;

        case PSN_RESET:
            break;

        case PSN_WIZNEXT:
            NewDevWiz->AlreadySearchedWU = TRUE;
            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_WUPROMPT;

            //
            // Set the SEARCH_INET search option and go to the searching
            // wizard page.
            //
            if (IsDlgButtonChecked(hDlg, IDC_WU_SEARCHINET)) {
            
                NewDevWiz->SearchOptions = SEARCH_INET;

                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_SEARCHING);

            } else {
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_NODRIVER_FINISH);
            }
            break;
        
        case PSN_WIZBACK:
            NewDevWiz->AlreadySearchedWU = FALSE;
            SetDlgMsgResult(hDlg, message, pEnterFrom);
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

void
FillDriversList(
    HWND hwndList,
    PNEWDEVWIZ NewDevWiz,
    int SignedIconIndex,
    int UnsignedIconIndex
    )
{
    int IndexDriver;
    int SelectedDriver;
    int lvIndex;
    LV_ITEM lviItem;
    BOOL FoundInstalledDriver;
    BOOL FoundSelectedDriver;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndList);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    IndexDriver = 0;
    SelectedDriver = 0;
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);

    FoundInstalledDriver = FALSE;
    FoundSelectedDriver = FALSE;
    while (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 IndexDriver,
                                 &DriverInfoData
                                 )) {

        //
        // Get the DriverInstallParams so we can see if we got this driver from the Internet
        //
        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInstallParams))  {
            //
            // Don't show old Internet drivers because we don't have the files locally
            // anymore to install these!  Also don't show BAD drivers.
            //
            if ((DriverInstallParams.Flags & DNF_OLD_INET_DRIVER) ||
                (DriverInstallParams.Flags & DNF_BAD_DRIVER)) {

                IndexDriver++;
                continue;
            }
                                 
            lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
            lviItem.iItem = IndexDriver;
            lviItem.iSubItem = 0;
            lviItem.pszText = DriverInfoData.Description;
            lviItem.lParam = 0;
            lviItem.iImage = (DriverInstallParams.Flags & DNF_INF_IS_SIGNED)
                ? SignedIconIndex
                : UnsignedIconIndex;

            //
            // If this is the currently installed driver then set the DRIVER_LIST_CURRENT_DRIVER
            // flag in the lParam.
            //
            if (!FoundInstalledDriver &&
                (NewDevWiz->InstallType == NDWTYPE_UPDATE) &&
                IsInstalledDriver(NewDevWiz, &DriverInfoData)) {

                lviItem.lParam |= DRIVER_LIST_CURRENT_DRIVER;
            }

            //
            // If this is the selected driver then set the DRIVER_LIST_SELECTED_DRIVER
            // flag in the lParam
            //
            if (!FoundSelectedDriver &&
                IsSelectedDriver(NewDevWiz, &DriverInfoData)) {

                lviItem.lParam |= DRIVER_LIST_SELECTED_DRIVER;
                SelectedDriver = IndexDriver;
            }

            if (DriverInstallParams.Flags & DNF_INF_IS_SIGNED) {
                lviItem.lParam |= DRIVER_LIST_SIGNED_DRIVER;
            }
            
            lvIndex = ListView_InsertItem(hwndList, &lviItem);

            if (DriverInfoData.DriverVersion != 0) {

                ULARGE_INTEGER Version;
                TCHAR VersionString[LINE_LEN];

                Version.QuadPart = DriverInfoData.DriverVersion;

                wsprintf(VersionString, TEXT("%0d.%0d.%0d.%0d"),
                    HIWORD(Version.HighPart), LOWORD(Version.HighPart),
                    HIWORD(Version.LowPart), LOWORD(Version.LowPart));
            
                ListView_SetItemText(hwndList, lvIndex, 1, VersionString);
            
            } else {
                
                ListView_SetItemText(hwndList, lvIndex, 1, szUnknown);
            }
            
            ListView_SetItemText(hwndList, lvIndex, 2, DriverInfoData.MfgName);


            if (DriverInstallParams.Flags & DNF_INET_DRIVER) {

                //
                // Driver is from the Internet
                //
                TCHAR WindowsUpdate[MAX_PATH];
                LoadString(hNewDev, IDS_DEFAULT_INTERNET_HOST, WindowsUpdate, SIZECHARS(WindowsUpdate));
                ListView_SetItemText(hwndList, lvIndex, 3, WindowsUpdate);

            } else {           

                //
                // Driver is not from the Internet
                //
                if (SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                               &NewDevWiz->DeviceInfoData,
                                               &DriverInfoData,
                                               &DriverInfoDetailData,
                                               sizeof(DriverInfoDetailData),
                                               NULL
                                               )
                    ||
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    
                    ListView_SetItemText(hwndList, lvIndex, 3, DriverInfoDetailData.InfFileName);

                } else {
                    ListView_SetItemText(hwndList, lvIndex, 3, TEXT(""));
                }
            }            
        }

        IndexDriver++;
    }

    //
    // Select the SelectedDriver item in the list and scroll it into view
    // since this is the best driver in the list.
    //
    ListView_SetItemState(hwndList,
                          SelectedDriver,
                          LVIS_SELECTED|LVIS_FOCUSED,
                          LVIS_SELECTED|LVIS_FOCUSED
                          );

    ListView_EnsureVisible(hwndList, SelectedDriver, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hwndList, 2, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hwndList, 3, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
}

BOOL
SelectDriverFromList(
    HWND hwndList,
    PNEWDEVWIZ NewDevWiz
    )
{
    int lvSelected;
    SP_DRVINFO_DATA DriverInfoData;
    LVITEM lvi;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    lvSelected = ListView_GetNextItem(hwndList,
                                      -1,
                                      LVNI_SELECTED
                                      );

    if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                              &NewDevWiz->DeviceInfoData,
                              SPDIT_COMPATDRIVER,
                              lvSelected,
                              &DriverInfoData
                              ))
    {
        SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 );
    }

    //
    // if there is no selected driver call DIF_SELECTBESTCOMPATDRV.
    //

    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  &DriverInfoData
                                  ))
    {
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  0,
                                  &DriverInfoData
                                  ))
        {
            //
            //Pick the best driver from the list we just created
            //
            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                      NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData
                                      );
        }

        else 
        {
            SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     NULL
                                     );
        }
    }

    //
    // Return TRUE if the selected driver in the list is the current driver, otherwise return FALSE
    //
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.iItem = lvSelected;
    lvi.mask = LVIF_PARAM;

    if (ListView_GetItem(hwndList, &lvi) &&
        (lvi.lParam & DRIVER_LIST_CURRENT_DRIVER)) {

        return(TRUE);
    }

    return(FALSE);
}

INT_PTR CALLBACK
ListDriversDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    static int pEnterFrom;
    static HIMAGELIST himl = NULL;
    static int SignedIconIndex, UnsignedIconIndex;

    switch (message)  {
        
    case WM_INITDIALOG: {
            
        HWND hwndParentDlg;
        HWND hwndList;
        LV_COLUMN lvcCol;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        TCHAR Buffer[64];
        HFONT hfont;
        LOGFONT LogFont;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        pEnterFrom = NewDevWiz->EnterFrom;

        //
        // Create the normal and bold fonts
        //
        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_SIGNED_TEXT), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        NewDevWiz->hfontTextNormal = CreateFontIndirect(&LogFont);

        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_SIGNED_TEXT), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        NewDevWiz->hfontTextBold = CreateFontIndirect(&LogFont);

        hwndList = GetDlgItem(hDlg, IDC_LISTDRIVERS_LISTVIEW);

        //
        // Create the image list that contains the signed and not signed icons.
        //
        himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON),
                                ILC_MASK |
                                (GetWindowLong(GetParent(hDlg), GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                                  ? ILC_MIRROR 
                                  : 0,
                                1,
                                1);

        //
        // Associate the image list with the list view.
        //
        if (himl) {
            HICON hIcon;

            ImageList_SetBkColor(himl, GetSysColor(COLOR_WINDOW));
            
            //
            // Add the signed and unsigned icons to the imagelist.
            //
            if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {
                UnsignedIconIndex = ImageList_AddIcon(himl, hIcon);
            }

            if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_SIGNED))) != NULL) {
                SignedIconIndex = ImageList_AddIcon(himl, hIcon);
            }

            ListView_SetImageList(hwndList,
                                  himl,
                                  LVSIL_SMALL
                                  );
        }

        //
        // Insert columns for listview.
        // 0 == device name
        // 1 == version
        // 2 == manufacturer
        // 3 == INF location
        //
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.pszText = Buffer;

        lvcCol.iSubItem = 0;
        LoadString(hNewDev, IDS_DRIVERDESC, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 0, &lvcCol);

        lvcCol.iSubItem = 1;
        LoadString(hNewDev, IDS_DRIVERVERSION, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 1, &lvcCol);

        lvcCol.iSubItem = 2;
        LoadString(hNewDev, IDS_DRIVERMFG, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 2, &lvcCol);

        lvcCol.iSubItem = 3;
        LoadString(hNewDev, IDS_DRIVERINF, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 3, &lvcCol);

        SendMessage(hwndList,
                    LVM_SETEXTENDEDLISTVIEWSTYLE,
                    LVS_EX_FULLROWSELECT,
                    LVS_EX_FULLROWSELECT
                    );
    }
    break;

    case WM_DESTROY:
        if (NewDevWiz->hfontTextNormal ) {
            DeleteObject(NewDevWiz->hfontTextNormal);
            NewDevWiz->hfontTextBigBold = NULL;
        }
        
        if (NewDevWiz->hfontTextBold ) {
            DeleteObject(NewDevWiz->hfontTextBold);
            NewDevWiz->hfontTextBold = NULL;
        }

        if (himl) {
            ImageList_Destroy(himl);
        }
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE: {
            int PrevPage;
            HICON hicon;

            PrevPage = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_LISTDRIVERS;

            SetDriverDescription(hDlg, IDC_DRVUPD_DRVDESC, NewDevWiz);
            ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_LINK), SW_HIDE);

            hicon = NULL;
            if (NewDevWiz->ClassGuidSelected &&
                SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            } else {
                SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, NULL);
                SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                DestroyIcon(hicon);
            }

            //
            // Fill the list view
            //
            FillDriversList(GetDlgItem(hDlg, IDC_LISTDRIVERS_LISTVIEW),
                            NewDevWiz,
                            SignedIconIndex,
                            UnsignedIconIndex);

        }
        break;

        case PSN_RESET:
            break;

        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, message, pEnterFrom);
            break;

        case PSN_WIZNEXT:

            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_LISTDRIVERS;
            
            if (SelectDriverFromList(GetDlgItem(hDlg, IDC_LISTDRIVERS_LISTVIEW), NewDevWiz)) {

                NewDevWiz->EnterInto = IDD_NEWDEVWIZ_USECURRENT_FINISH;
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_USECURRENT_FINISH);
            
            } else {

                NewDevWiz->EnterInto = IDD_NEWDEVWIZ_INSTALLDEV;
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_INSTALLDEV);
            }
            break;

        case LVN_ITEMCHANGED: {

            LPNM_LISTVIEW   lpnmlv = (LPNM_LISTVIEW)lParam;
            int StringId = 0;
            int DigitalSignatureSignedId = 0;
            HICON hIcon = NULL;

            if ((lpnmlv->uChanged & LVIF_STATE)) {
                if (lpnmlv->uNewState & LVIS_SELECTED) {
                    //
                    // lParam & DRIVER_LIST_CURRENT_DRIVER means this is the currently installed driver.
                    // lParam & DRIVER_LIST_SELECTED_DRIVER means this is the selected/best driver.
                    //
                    if (lpnmlv->lParam & DRIVER_LIST_CURRENT_DRIVER) {
                        StringId = IDS_DRIVER_CURR;
                    }

                    DigitalSignatureSignedId = (lpnmlv->lParam & DRIVER_LIST_SIGNED_DRIVER)
                        ? IDS_DRIVER_IS_SIGNED
                        : IDS_DRIVER_NOT_SIGNED;

                    hIcon = LoadImage(hNewDev,
                                      (lpnmlv->lParam & DRIVER_LIST_SIGNED_DRIVER)
                                          ? MAKEINTRESOURCE(IDI_SIGNED)
                                          : MAKEINTRESOURCE(IDI_WARN),
                                      IMAGE_ICON,
                                      GetSystemMetrics(SM_CXSMICON),
                                      GetSystemMetrics(SM_CYSMICON),
                                      0
                                      );

                    if (NewDevWiz->hfontTextNormal && NewDevWiz->hfontTextBold) {
                        SetWindowFont(GetDlgItem(hDlg, IDC_SIGNED_TEXT),
                                      (lpnmlv->lParam & DRIVER_LIST_SIGNED_DRIVER)
                                          ? NewDevWiz->hfontTextNormal
                                          : NewDevWiz->hfontTextBold,
                                      TRUE
                                      );
                    }

                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_ICON), SW_SHOW);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_TEXT), SW_SHOW);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_LINK), SW_SHOW);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                } else {
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_ICON), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_TEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_LINK), SW_HIDE);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                }

                if (!StringId) {
                    SetDlgItemText(hDlg, IDC_NDW_TEXT, TEXT(""));
                } else {
                    SetDlgText(hDlg, IDC_NDW_TEXT, StringId, StringId);
                }

                if (!DigitalSignatureSignedId) {
                    SetDlgItemText(hDlg, IDC_SIGNED_TEXT, TEXT(""));
                } else {
                    SetDlgText(hDlg, IDC_SIGNED_TEXT, DigitalSignatureSignedId, DigitalSignatureSignedId);
                }

                if (hIcon) {
                    hIcon = (HICON)SendDlgItemMessage(hDlg,
                                  IDC_SIGNED_ICON,
                                  STM_SETICON,
                                  (WPARAM)hIcon,
                                  0L
                                  );
                }

                if (hIcon) {
                    DestroyIcon(hIcon);
                }
            }
        }
        break;

        case NM_RETURN:
        case NM_CLICK:
            if((((LPNMHDR)lParam)->idFrom) == IDC_SIGNED_LINK) {
                ShellExecute(hDlg,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                             NULL,
                             SW_SHOWNORMAL
                             );
            }
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
UseCurrentDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)  {
        
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (NewDevWiz->hfontTextBigBold) {

            SetWindowFont(GetDlgItem(hDlg, IDC_FINISH_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
        }
    }
    break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_USECURRENT_FINISH;
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_RESET:
            break;

        case PSN_WIZBACK:
            NewDevWiz->CurrentDriverIsSelected = FALSE;
            SetDlgMsgResult(hDlg, message, NewDevWiz->EnterFrom);
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
InitNoDriversDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    if (NewDevWiz->hfontTextBigBold) {
        SetWindowFont(GetDlgItem(hDlg, IDC_FINISH_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
    }
    
    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {
        ShowWindow(GetDlgItem(hDlg, IDC_FINISH_MSG3), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_ICON), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_TEXT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_FINISH_PROMPT), SW_HIDE);

    } else {

        CheckDlgButton(hDlg, IDC_FINISH_PROMPT, BST_CHECKED);

        //
        // If this user has the policy set to not send the Hardware Id to Windows
        // Update then don't put in the text about launching help center.
        //
        if (GetLogPnPIdPolicy() == FALSE) {
            ShowWindow(GetDlgItem(hDlg, IDC_FINISH_MSG3), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_TEXT), SW_HIDE);
        }
    }

    return TRUE;
}

INT_PTR CALLBACK
NoDriverDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HICON hicon;

    switch (message)  {
        
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        InitNoDriversDlgProc(hDlg, NewDevWiz);
    }
    break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_USECURRENT_FINISH;

            //
            // Set the Help Center icon next to the text
            //
            hicon = LoadImage(hNewDev, 
                              MAKEINTRESOURCE(IDI_HELPCENTER), 
                              IMAGE_ICON,
                              GetSystemMetrics(SM_CXSMICON),
                              GetSystemMetrics(SM_CYSMICON),
                              0
                              );

            if (hicon) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_HELPCENTER_ICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                DestroyIcon(hicon);
            }

            //
            // Set the Info icon next to the text
            //
            hicon = LoadImage(hNewDev, 
                              MAKEINTRESOURCE(IDI_INFO), 
                              IMAGE_ICON,
                              GetSystemMetrics(SM_CXSMICON),
                              GetSystemMetrics(SM_CYSMICON),
                              0
                              );

            if (hicon) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_INFO_ICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                DestroyIcon(hicon);
            }
            
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;

        case PSN_WIZFINISH:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            
            if (IsDlgButtonChecked(hDlg, IDC_FINISH_PROMPT)) {
                InstallNullDriver(hDlg,
                                  NewDevWiz,
                                  (NewDevWiz->Capabilities & CM_DEVCAP_RAWDEVICEOK)
                                     ? FALSE : TRUE
                                  );
            
            } else {
                NewDevWiz->LastError = ERROR_CANCELLED;
            }

            //
            // Set the BOOL that tells us to call CDM which will launch HelpCenter
            // if we are in the Found New Hardware Wizard and if the user has the 
            // policy set to TRUE.
            //
            if ((NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) &&
                GetLogPnPIdPolicy()) {
            
                NewDevWiz->CallHelpCenter = TRUE;
            }
            break;
        
        case PSN_WIZBACK:
            NewDevWiz->CurrentDriverIsSelected = FALSE;
            SetDlgMsgResult(hDlg, message, NewDevWiz->EnterFrom);
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;
        }
        break;

    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\miscutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       miscutil.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"



TCHAR szUnknownDevice[64];
USHORT LenUnknownDevice;

TCHAR szUnknown[64];
USHORT LenUnknown;


HMODULE hSrClientDll;

typedef
BOOL
(*SRSETRESTOREPOINT)(
    PRESTOREPOINTINFO pRestorePtSpec,
    PSTATEMGRSTATUS pSMgrStatus
    );


BOOL
FormatMessageString(
    UINT idTemplate,
    LPTSTR pszStrOut,
    DWORD cchSize,
    ...
    )
{
    BOOL fResult = FALSE;

    va_list vaParamList;

    TCHAR szFormat[1024];
    if (LoadString(hNewDev, idTemplate, szFormat, ARRAYSIZE(szFormat)))
    {
        va_start(vaParamList, cchSize);

        fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, pszStrOut, cchSize, &vaParamList);

        va_end(vaParamList);
    }

    return fResult;
}

void
OffsetWindow(
    HWND hwnd,
    int dx,
    int dy
    )
{
    RECT rc;
    GetWindowRect(hwnd, &rc);
    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rc, 2);
    OffsetRect(&rc, dx, dy);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}

PTCHAR
BuildFriendlyName(
    DEVINST DevInst,
    BOOL UseNewDeviceDesc,
    HMACHINE hMachine
    )
{
    PTCHAR Location;
    PTCHAR FriendlyName;
    CONFIGRET ConfigRet = CR_SUCCESS;
    ULONG ulSize;
    TCHAR szBuffer[MAX_PATH];

    *szBuffer = TEXT('\0');

    //
    // Try the registry for NewDeviceDesc
    //
    if (UseNewDeviceDesc) {

        HKEY hKey;
        DWORD dwType = REG_SZ;

        ConfigRet = CM_Open_DevNode_Key(DevInst,
                                        KEY_READ,
                                        0,
                                        RegDisposition_OpenExisting,
                                        &hKey,
                                        CM_REGISTRY_HARDWARE
                                        );

        if (ConfigRet == CR_SUCCESS) {

            ulSize = sizeof(szBuffer);
            RegQueryValueEx(hKey,
                            REGSTR_VAL_NEW_DEVICE_DESC,
                            NULL,
                            &dwType,
                            (LPBYTE)szBuffer,
                            &ulSize
                            );

            RegCloseKey(hKey);
        }
    }

    if (ConfigRet != CR_SUCCESS || !*szBuffer) {

        //
        // Try the registry for FRIENDLYNAME
        //

        ulSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_FRIENDLYNAME,
                                                        NULL,
                                                        szBuffer,
                                                        &ulSize,
                                                        0,
                                                        hMachine
                                                        );
        if (ConfigRet != CR_SUCCESS || !*szBuffer) {
            //
            // Try the registry for DEVICEDESC
            //

            ulSize = sizeof(szBuffer);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                            CM_DRP_DEVICEDESC,
                                                            NULL,
                                                            szBuffer,
                                                            &ulSize,
                                                            0,
                                                            hMachine
                                                            );
            if (ConfigRet != CR_SUCCESS || !*szBuffer) {

                GUID ClassGuid;

                //
                // Initialize ClassGuid to GUID_NULL
                //
                CopyMemory(&ClassGuid,
                           &GUID_NULL,
                           sizeof(GUID)
                           );

                //
                // Try the registry for CLASSNAME
                //
                ulSize = sizeof(szBuffer);
                ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                                CM_DRP_CLASSGUID,
                                                                NULL,
                                                                szBuffer,
                                                                &ulSize,
                                                                0,
                                                                hMachine
                                                                );


                if (ConfigRet == CR_SUCCESS) {

                    pSetupGuidFromString(szBuffer, &ClassGuid);
                }


                if (!IsEqualGUID(&ClassGuid, &GUID_NULL) &&
                    !IsEqualGUID(&ClassGuid, &GUID_DEVCLASS_UNKNOWN))
                {
                    ulSize = sizeof(szBuffer);
                    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                                    CM_DRP_CLASS,
                                                                    NULL,
                                                                    szBuffer,
                                                                    &ulSize,
                                                                    0,
                                                                    hMachine
                                                                    );
                }
                else {

                    ConfigRet = ~CR_SUCCESS;
                }


            }
        }
    }


    if (ConfigRet == CR_SUCCESS && *szBuffer) {

        FriendlyName = LocalAlloc(LPTR, ulSize);

        if (FriendlyName) {

            memcpy(FriendlyName, szBuffer, ulSize);
        }
    }
    else {

        FriendlyName = NULL;
    }

    return FriendlyName;
}

/* ----------------------------------------------------------------------
 * SetDlgText - Set Dialog Text Field
 *
 * Concatenates a number of string resources and does a SetWindowText()
 * for a dialog text control.
 *
 * Parameters:
 *
 *      hDlg         - Dialog handle
 *      iControl     - Dialog control ID to receive text
 *      nStartString - ID of first string resource to concatenate
 *      nEndString   - ID of last string resource to concatenate
 *
 *      Note: the string IDs must be consecutive.
 */

void
SetDlgText(HWND hDlg, int iControl, int nStartString, int nEndString)
{
    int     iX;
    TCHAR   szText[SDT_MAX_TEXT];

    szText[0] = '\0';

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hNewDev,
                    iX,
                    szText + lstrlen(szText),
                    sizeof(szText)/sizeof(TCHAR) - lstrlen(szText)
                    );
    }

    if (iControl) {

        SetDlgItemText(hDlg, iControl, szText);

    } else {

        SetWindowText(hDlg, szText);
    }
}


void
LoadText(PTCHAR szText, int SizeText, int nStartString, int nEndString)
{
    int     iX;

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hNewDev,
                    iX,
                    szText + lstrlen(szText),
                    SizeText/sizeof(TCHAR) - lstrlen(szText)
                    );
    }

    return;
}

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);

    while (hChildWnd != NULL) {

        SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
    }
}

BOOL
NoPrivilegeWarning(
   HWND hWnd
   )
/*++

    This function checks to see if the user has Administrator privileges.

    If the user does NOT have this administrator privilege then a warning is displayed telling
    them that they have insufficient privileges to install hardware on this machine.

Arguments

    hWnd - Parent window handle

Return Value:
    TRUE if the user does NOT have Administrator privileges and
    FALSE if the user does have this privilege

--*/
{
   TCHAR szMsg[MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   if (!pSetupIsUserAdmin()) {

       if (LoadString(hNewDev,
                      IDS_NDW_NOTADMIN,
                      szMsg,
                      MAX_PATH)
          &&
           LoadString(hNewDev,
                      IDS_NEWDEVICENAME,
                      szCaption,
                      MAX_PATH))
        {
            MessageBox(hWnd, szMsg, szCaption, MB_OK | MB_ICONEXCLAMATION);
        }

       return TRUE;
    }

   return FALSE;
}

LONG
NdwBuildClassInfoList(
    PNEWDEVWIZ NewDevWiz,
    DWORD ClassListFlags
    )
{
    LONG Error;

    //
    // Build the class info list
    //
    while (!SetupDiBuildClassInfoList(ClassListFlags,
                                      NewDevWiz->ClassGuidList,
                                      NewDevWiz->ClassGuidSize,
                                      &NewDevWiz->ClassGuidNum
                                      ))
    {
        Error = GetLastError();

        if (NewDevWiz->ClassGuidList) {

            LocalFree(NewDevWiz->ClassGuidList);
            NewDevWiz->ClassGuidList = NULL;
        }

        if (Error == ERROR_INSUFFICIENT_BUFFER &&
            NewDevWiz->ClassGuidNum > NewDevWiz->ClassGuidSize)
        {
            NewDevWiz->ClassGuidList = LocalAlloc(LPTR, NewDevWiz->ClassGuidNum*sizeof(GUID));

            if (!NewDevWiz->ClassGuidList) {

                NewDevWiz->ClassGuidSize = 0;
                NewDevWiz->ClassGuidNum = 0;
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            NewDevWiz->ClassGuidSize = NewDevWiz->ClassGuidNum;

        } else {

            if (NewDevWiz->ClassGuidList) {

                LocalFree(NewDevWiz->ClassGuidList);
            }

            NewDevWiz->ClassGuidSize = 0;
            NewDevWiz->ClassGuidNum = 0;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

void
HideWindowByMove(
    HWND hDlg
    )
{
    RECT rect;

    //
    // Move the window offscreen, using the virtual coords for Upper Left Corner
    //
    GetWindowRect(hDlg, &rect);
    MoveWindow(hDlg,
               GetSystemMetrics(SM_XVIRTUALSCREEN),
               GetSystemMetrics(SM_YVIRTUALSCREEN) - (rect.bottom - rect.top),
               rect.right - rect.left,
               rect.bottom - rect.top,
               TRUE
               );
}

LONG
NdwUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionPointers
    )
{
    LONG lRet;
    BOOL BeingDebugged;

    lRet = UnhandledExceptionFilter(ExceptionPointers);

    BeingDebugged = IsDebuggerPresent();

    //
    // Normal code path is to handle the exception.
    // However, if a debugger is present, and the system's unhandled
    // exception filter returns continue search, we let it go
    // thru to allow the debugger a chance at it.
    //
    if (lRet == EXCEPTION_CONTINUE_SEARCH && !BeingDebugged) {
        lRet = EXCEPTION_EXECUTE_HANDLER;
    }

    return lRet;
}

BOOL
SetClassGuid(
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData,
    LPGUID ClassGuid
    )
{
    TCHAR ClassGuidString[MAX_GUID_STRING_LEN];

    pSetupStringFromGuid(ClassGuid,
                         ClassGuidString,
                         sizeof(ClassGuidString)/sizeof(TCHAR)
                         );

    return SetupDiSetDeviceRegistryProperty(hDeviceInfo,
                                            DeviceInfoData,
                                            SPDRP_CLASSGUID,
                                            (LPBYTE)ClassGuidString,
                                            MAX_GUID_STRING_LEN * sizeof(TCHAR)
                                            );
}

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PNEWDEVWIZ NewDevWiz
   )
{
    PROPSHEETPAGE    psp;

    memset(&psp, 0, sizeof(PROPSHEETPAGE));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hNewDev;
    psp.lParam = (LPARAM)NewDevWiz;
    psp.pszTemplate = MAKEINTRESOURCE(PageResourceId);
    psp.pfnDlgProc = pfnDlgProc;

    return CreatePropertySheetPage(&psp);
}

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PNEWDEVWIZ NewDevWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction,
   HPROPSHEETPAGE hIntroPage
   )
{
    DWORD NumPages;
    BOOL bRet = FALSE;

    //
    // If this is not a manual install, then only the DIF_NEWDEVICEWIZARD_FINISHINSTALL
    // wizard is valid.
    //
    if (!(NewDevWiz->Flags & IDI_FLAG_MANUALINSTALL) &&
        (DIF_NEWDEVICEWIZARD_FINISHINSTALL != InstallFunction)) {

        return FALSE;
    }

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));
    DeviceWizardData->ClassInstallHeader.InstallFunction = InstallFunction;
    DeviceWizardData->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    DeviceWizardData->hwndWizardDlg = hwndParentDlg;

    if (SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA)
                                     )
        &&

        (SetupDiCallClassInstaller(InstallFunction,
                                  NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData
                                  )

            ||

            (ERROR_DI_DO_DEFAULT == GetLastError()))

        &&
        SetupDiGetClassInstallParams(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA),
                                     NULL
                                     )
        &&
        DeviceWizardData->NumDynamicPages)
    {
        //
        // If this is not a IDI_FLAG_NONINTERACTIVE install and we were given a intro
        // page then add it first.
        //
        PropSheet_AddPage(hwndParentDlg, hIntroPage);
        
        for (NumPages = 0; NumPages < DeviceWizardData->NumDynamicPages; NumPages++) {

            //
            // If this is a IDI_FLAG_NONINTERACTIVE install then we will destory the property
            // sheet pages since we can't display them, otherwise we will add them
            // to the wizard.
            //
            if (NewDevWiz->Flags & IDI_FLAG_NONINTERACTIVE) {

                DestroyPropertySheetPage(DeviceWizardData->DynamicPages[NumPages]);

            } else {

                PropSheet_AddPage(hwndParentDlg, DeviceWizardData->DynamicPages[NumPages]);
            }
        }

        //
        // If class/co-installers said they had pages to display then we always return TRUE,
        // regardless of if we actually added those pages to the wizard or not.
        //
        bRet = TRUE;
    }

    //
    // Clear the class install parameters.
    //
    SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 NULL,
                                 0
                                 );

    return bRet;
}

void
RemoveClassWizExtPages(
   HWND hwndParentDlg,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData
   )
{
    DWORD NumPages;

    NumPages = DeviceWizardData->NumDynamicPages;

    while (NumPages--) {

        PropSheet_RemovePage(hwndParentDlg,
                             (WPARAM)-1,
                             DeviceWizardData->DynamicPages[NumPages]
                             );
    }

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));

    return;
}

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName, &findData);

    if(FindHandle == INVALID_HANDLE_VALUE) {

        Error = GetLastError();

    } else {

        FindClose(FindHandle);

        if(FindData) {

            *FindData = findData;
        }

        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

BOOL
pVerifyUpdateDriverInfoPath(
    PNEWDEVWIZ NewDevWiz
    )

/*++

    This API will verify that the selected driver node lives in the path
    specified in UpdateDriverInfo->InfPathName.

Return Value:
    This API will return TRUE in all cases except where we have a valid
    UpdateDriverInfo structure and a valid InfPathName field and that
    path does not match the path where the selected driver lives.

--*/

{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;

    //
    // If we don't have a UpdateDriverInfo structure or a valid InfPathName field
    // in that structure then just return TRUE now.
    //
    if (!NewDevWiz->UpdateDriverInfo || !NewDevWiz->UpdateDriverInfo->InfPathName) {

        return TRUE;
    }

    //
    // Get the selected driver's path
    //
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )) {
        //
        // There is no selected driver so just return TRUE
        //
        return TRUE;
    }

    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    &DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL
                                    )
        &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {

        //
        // We should never hit this case, but if we have a selected driver and
        // we can't get the SP_DRVINFO_DETAIL_DATA that contains the InfFileName
        // the return FALSE.
        //
        return FALSE;
    }

    if (lstrlen(NewDevWiz->UpdateDriverInfo->InfPathName) ==
        lstrlen(DriverInfoDetailData.InfFileName)) {

        //
        // If the two paths are the same size then we will just compare them
        //
        return (!lstrcmpi(NewDevWiz->UpdateDriverInfo->InfPathName,
                          DriverInfoDetailData.InfFileName));

    } else {

        //
        // The two paths are different lengths so we'll tack a trailing backslash
        // onto the UpdateDriverInfo->InfPathName and then do a _tcsnicmp
        // NOTE that we only tack on a trailing backslash if the length of the
        // path is greater than two since it isn't needed on the driver letter
        // followed by a colon case (A:).
        //
        // The reason we do this is we don't want the following case to match
        // c:\winnt\in
        // c:\winnt\inf\foo.inf
        //
        TCHAR TempPath[MAX_PATH];

        lstrcpy(TempPath, NewDevWiz->UpdateDriverInfo->InfPathName);

        if (lstrlen(NewDevWiz->UpdateDriverInfo->InfPathName) > 2) {

            lstrcat(TempPath, TEXT("\\"));
        }

        return (!_tcsnicmp(TempPath,
                           DriverInfoDetailData.InfFileName,
                           lstrlen(TempPath)));
    }
}

BOOL
ConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize          OPTIONAL
    )

/*++

Routine Description:

    Concatenate 2 paths, ensuring that one, and only one,
    path separator character is introduced at the junction point.

Arguments:

    Target - supplies first part of path. Path is appended to this.

    Path - supplies path to be concatenated to Target.

    TargetBufferSize - supplies the size of the Target buffer,
        in characters.

    RequiredSize - if specified, receives the number of characters
        required to hold the fully concatenated path, including
        the terminating nul.

Return Value:

    TRUE if the full path fit in Target buffer. Otherwise the path
    will have been truncated.

--*/

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (*CharPrev(Target,Target+TargetLength) == TEXT('\\'))) {
        TrailingBackslash = TRUE;
        TargetLength--;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // See whether the path has a leading backshash.
    //
    if(Path[0] == TEXT('\\')) {
        LeadingBackslash = TRUE;
        PathLength--;
    } else {
        LeadingBackslash = FALSE;
    }

    //
    // Calculate the ending length, which is equal to the sum of
    // the length of the two strings modulo leading/trailing
    // backslashes, plus one path separator, plus a nul.
    //
    EndingLength = TargetLength + PathLength + 2;
    if(RequiredSize) {
        *RequiredSize = EndingLength;
    }

    if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
        Target[TargetLength++] = TEXT('\\');
    }

    if(TargetBufferSize > TargetLength) {
        lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
    }

    //
    // Make sure the buffer is nul terminated in all cases.
    //
    if (TargetBufferSize) {
        Target[TargetBufferSize-1] = 0;
    }

    return(EndingLength <= TargetBufferSize);
}

BOOL
RemoveDir(
    PTSTR Path
    )
/*++

Routine Description:

    This routine recursively deletes the specified directory and all the
    files in it.


Arguments:

    Path - Path to remove.

Return Value:

    TRUE - if the directory was sucessfully deleted.
    FALSE - if the directory was not successfully deleted.

--*/
{
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFind;
    BOOL            bFind = TRUE;
    BOOL            Ret = TRUE;
    TCHAR           szTemp[MAX_PATH];
    TCHAR           FindPath[MAX_PATH];
    DWORD           dwAttributes;

    //
    //If this is a directory then tack on *.* to the end of the path
    //
    lstrcpyn(FindPath, Path, MAX_PATH);
    dwAttributes = GetFileAttributes(Path);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        ConcatenatePaths(FindPath,TEXT("*.*"),MAX_PATH,NULL);
    }

    hFind = FindFirstFile(FindPath, &FindFileData);

    while (hFind != INVALID_HANDLE_VALUE && bFind == TRUE) {

        lstrcpyn(szTemp, Path, MAX_PATH);
        ConcatenatePaths(szTemp,FindFileData.cFileName,MAX_PATH,NULL);

        //
        //This is a directory
        //
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (FindFileData.cFileName[0] != TEXT('.'))) {

            if (!RemoveDir(szTemp)) {

                Ret = FALSE;
            }

            RemoveDirectory(szTemp);
        }

        //
        //This is a file
        //
        else if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            DeleteFile(szTemp);
        }

        bFind = FindNextFile(hFind, &FindFileData);
    }

    FindClose(hFind);

    //
    //Remove the root directory
    //
    dwAttributes = GetFileAttributes(Path);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        if (!RemoveDirectory(Path)) {

            Ret = FALSE;
        }
    }

    return Ret;
}

BOOL
pAToI(
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    INT Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    INT OverflowCheck;
    BOOL b;

    if(!Field) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*Field == TEXT('-')) {
        Neg = TRUE;
        Field++;
    } else {
        Neg = FALSE;
        if(*Field == TEXT('+')) {
            Field++;
        }
    }

    if((*Field == TEXT('0')) &&
       ((*(Field+1) == TEXT('x')) || (*(Field+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        Field += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *Field; Field++) {

        c = (UINT)*Field;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(INT) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*Field) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *IntegerValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}

RemoveCdmDirectory(
    PTSTR CdmDirectory
    )
{
    TCHAR ReinstallBackupDirectory[MAX_PATH];

    //
    // First verify that this directory is a subdirectory of %windir%\system32\ReinstallBackups
    //
    if (GetSystemDirectory(ReinstallBackupDirectory, SIZECHARS(ReinstallBackupDirectory))) {

        ConcatenatePaths(ReinstallBackupDirectory, TEXT("ReinstallBackups"), MAX_PATH, NULL);

        do {

            PTSTR p = _tcsrchr(CdmDirectory, TEXT('\\'));

            if (!p) {

                break;
            }

            *p = 0;

            if (_tcsnicmp(CdmDirectory,
                           ReinstallBackupDirectory,
                           lstrlen(ReinstallBackupDirectory))) {

                //
                // This is not a subdirectory of the ReinstallBackups directory, so don't
                // delete it!
                //
                break;
            }

            if (!lstrcmpi(CdmDirectory,
                         ReinstallBackupDirectory)) {

                //
                // We have reached the actuall ReinstallBackups directory so stop deleting!
                //
                break;
            }

        } while (RemoveDir(CdmDirectory));
    }
}

BOOL
pSetupGetDriverDate(
    IN     PCTSTR     DriverVer,
    IN OUT PFILETIME  pFileTime
    )

/*++

Routine Description:

    Retreive the date from a DriverVer string.

    The Date specified in DriverVer string has the following format:

    DriverVer=xx/yy/zzzz

        or

    DriverVer=xx-yy-zzzz

    where xx is the month, yy is the day, and zzzz is the for digit year.
    Note that the year MUST be 4 digits.  A year of 98 will be considered
    0098 and not 1998!

    This date should be the date of the Drivers and not for the INF itself.
    So a single INF can have multiple driver install Sections and each can
    have different dates depending on when the driver was last updated.

Arguments:

    DriverVer - String that holds the DriverVer entry from an INF file.

    pFileTime - points to a FILETIME structure that will receive the Date,
        if it exists.

Return Value:

    BOOL. TRUE if a valid date existed in the specified string and FALSE otherwise.

--*/

{
    SYSTEMTIME SystemTime;
    TCHAR DriverDate[LINE_LEN];
    PTSTR Convert, Temp;
    DWORD Value;

    if (!DriverVer) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {

        *DriverDate = 0;
        ZeroMemory(&SystemTime, sizeof(SYSTEMTIME));
        pFileTime->dwLowDateTime = 0;
        pFileTime->dwHighDateTime = 0;

        //
        // First copy just the DriverDate portion of the DriverVer into the DriverDate
        // variable.  The DriverDate should be everything before the first comma.
        //
        lstrcpy(DriverDate, DriverVer);

        Temp = DriverDate;

        while (*Temp && (*Temp != TEXT(','))) {

            Temp++;
        }

        if (*Temp) {
            *Temp = TEXT('\0');
        }

        Convert = DriverDate;

        if (*Convert) {

            Temp = DriverDate;
            while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                Temp++;

            *Temp = 0;

            //
            //Convert the month
            //
            pAToI(Convert, (PINT)&Value);
            SystemTime.wMonth = LOWORD(Value);

            Convert = Temp+1;

            if (*Convert) {

                Temp = Convert;
                while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                    Temp++;

                *Temp = 0;

                //
                //Convert the day
                //
                pAToI(Convert, (PINT)&Value);
                SystemTime.wDay = LOWORD(Value);

                Convert = Temp+1;

                if (*Convert) {

                    //
                    //Convert the year
                    //
                    pAToI(Convert, (PINT)&Value);
                    SystemTime.wYear = LOWORD(Value);

                    //
                    //Convert SYSTEMTIME into FILETIME
                    //
                    SystemTimeToFileTime(&SystemTime, pFileTime);
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SetLastError(NO_ERROR);
    return((pFileTime->dwLowDateTime != 0) || (pFileTime->dwHighDateTime != 0));
}

BOOL
IsInternetAvailable(
    HMODULE *hCdmInstance
    )
{
    OSVERSIONINFOEX info;
    CDM_INTERNET_AVAILABLE_PROC pfnCDMInternetAvailable;

    if (!hCdmInstance) {
        return FALSE;
    }

    //
    // We can't call CDM during GUI setup.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    //
    // Never call CDM if this is DataCenter
    //
    info.dwOSVersionInfoSize = sizeof(info);
    if (GetVersionEx((POSVERSIONINFOW)&info) &&
        (info.wSuiteMask & VER_SUITE_DATACENTER)) {
        return FALSE;
    }

    //
    // Load CDM.DLL if it is not already loaded
    //
    if (!(*hCdmInstance)) {
        *hCdmInstance = LoadLibrary(TEXT("CDM.DLL"));
    }

    pfnCDMInternetAvailable = (CDM_INTERNET_AVAILABLE_PROC)GetProcAddress(*hCdmInstance,
                                                                          "DownloadIsInternetAvailable"
                                                                           );

    if (!pfnCDMInternetAvailable) {
        return FALSE;
    }

    return pfnCDMInternetAvailable();
}

BOOL
GetLogPnPIdPolicy(
    )
/*++

Routine Description:

    This function checks the policy portion of the registry to see if the user wants
    us to log the Hardware Id for devices that we cannot find drivers for.

Arguments:

    none

Return Value:

    BOOL - TRUE if we can log the Hardware Id and FALSE if the policy tells us not
    to log the hardware Id.

--*/
{
    HKEY hKey;
    DWORD LogPnPIdPolicy;
    ULONG cbData;
    BOOL bLogHardwareIds = TRUE;
    OSVERSIONINFOEX info;

    //
    // If we are in gui-setup then we can't log hardware Ids, so always return
    // FALSE.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    //
    // Never call log Ids on DataCenter
    //
    info.dwOSVersionInfoSize = sizeof(info);
    if (GetVersionEx((POSVERSIONINFOW)&info) &&
        (info.wSuiteMask & VER_SUITE_DATACENTER)) {
        return FALSE;
    }


    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     TEXT("Software\\Policies\\Microsoft\\Windows\\DriverSearching"),
                     0,
                     KEY_READ,
                     &hKey
                     ) == ERROR_SUCCESS) {

        LogPnPIdPolicy = 0;
        cbData = sizeof(LogPnPIdPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontLogHardwareIds"),
                             NULL,
                             NULL,
                             (LPBYTE)&LogPnPIdPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (LogPnPIdPolicy)) {

            bLogHardwareIds = FALSE;
        }

        RegCloseKey(hKey);
    }

    return (bLogHardwareIds);
}

void
CdmLogDriverNotFound(
    HMODULE hCdmInstance,
    HANDLE  hContext,
    LPCTSTR DeviceInstanceId,
    DWORD   Flags
    )
{
    LOG_DRIVER_NOT_FOUND_PROC pfnLogDriverNotFound;

    if (!hCdmInstance) {
        return;
    }

    pfnLogDriverNotFound = (LOG_DRIVER_NOT_FOUND_PROC)GetProcAddress(hCdmInstance,
                                                                     "LogDriverNotFound"
                                                                     );

    if (!pfnLogDriverNotFound) {
        return;
    }

    pfnLogDriverNotFound(hContext, DeviceInstanceId, Flags);
}

BOOL
GetInstalledInf(
    IN     DEVNODE DevNode,           OPTIONAL
    IN     PTSTR   DeviceInstanceId,  OPTIONAL
    IN OUT PTSTR   InfFile,
    IN OUT DWORD   *Size
    )
{
    DEVNODE dn;
    HKEY hKey = INVALID_HANDLE_VALUE;
    DWORD dwType;
    BOOL bSuccess = FALSE;

    if (DevNode != 0) {

        dn = DevNode;

    } else  if (CM_Locate_DevNode(&dn, DeviceInstanceId, 0) != CR_SUCCESS) {

        goto clean0;
    }

    //
    // Open the device's driver (software) registry key so we can get the InfPath
    //
    if (CM_Open_DevNode_Key(dn,
                            KEY_READ,
                            0,
                            RegDisposition_OpenExisting,
                            &hKey,
                            CM_REGISTRY_SOFTWARE
                            ) != CR_SUCCESS) {

        goto clean0;
    }

    if (hKey != INVALID_HANDLE_VALUE) {

        dwType = REG_SZ;

        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            &dwType,
                            (LPBYTE)InfFile,
                            Size
                            ) == ERROR_SUCCESS) {

            bSuccess = TRUE;
        }
    }

clean0:

    if (hKey != INVALID_HANDLE_VALUE) {

        RegCloseKey(hKey);
    }

    return bSuccess;
}

BOOL
IsInfFromOem(
    IN  PCTSTR                InfFile
    )

/*++

Routine Description:

    Determine if an Inf is an OEM Inf.

Arguments:

    InfFile - supplies name of Inf file.

Return Value:

    BOOL. TRUE if the InfFile is an OEM Inf file, and FALSE otherwise.

--*/

{
    PTSTR p;

    //
    // Make sure we are passed a valid Inf file and it's length is at least 8
    // chararacters or more for oemX.inf
    if (!InfFile ||
        (InfFile[0] == TEXT('\0')) ||
        (lstrlen(InfFile) < 8)) {

        return FALSE;
    }

    //
    // First check that the first 3 characters are OEM
    //
    if (_tcsnicmp(InfFile, TEXT("oem"), 3)) {

        return FALSE;
    }

    //
    // Next verify that any characters after "oem" and before ".inf"
    // are digits.
    //
    p = (PTSTR)InfFile;
    p = CharNext(p);
    p = CharNext(p);
    p = CharNext(p);

    while ((*p != TEXT('\0')) && (*p != TEXT('.'))) {

        if ((*p < TEXT('0')) || (*p > TEXT('9'))) {

            return FALSE;
        }

        p = CharNext(p);
    }

    //
    // Finally, verify that the last 4 characters are ".inf"
    //
    if (lstrcmpi(p, TEXT(".inf"))) {

        return FALSE;
    }

    //
    // This is an OEM Inf file
    //
    return TRUE;
}

BOOL
IsConnectedToInternet()
{
    DWORD dwFlags = INTERNET_CONNECTION_LAN | 
                    INTERNET_CONNECTION_MODEM |
                    INTERNET_CONNECTION_PROXY;

    //
    // If we are in gui-setup then return FALSE since we can't connect to the 
    // Internet at this time, and since the network is not fully installed yet
    // bad things can happen when we call Inet APIs.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    return InternetGetConnectedState(&dwFlags, 0);
}

DWORD
GetSearchOptions(
    void
    )
{
    DWORD SearchOptions = SEARCH_FLOPPY;
    DWORD cbData;
    HKEY hKeyDeviceInstaller;

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     REGSTR_PATH_DEVICEINSTALLER,
                     0,
                     KEY_READ,
                     &hKeyDeviceInstaller
                     ) == ERROR_SUCCESS) {

        cbData = sizeof(SearchOptions);

        RegQueryValueEx(hKeyDeviceInstaller,
                        REGSTR_VAL_SEARCHOPTIONS,
                        NULL,
                        NULL,
                        (LPBYTE)&SearchOptions,
                        &cbData
                        );

        RegCloseKey(hKeyDeviceInstaller);
    }

    return SearchOptions;
}

VOID
SetSearchOptions(
    DWORD SearchOptions
    )
{
    HKEY hKeyDeviceInstaller;

    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                       REGSTR_PATH_DEVICEINSTALLER,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &hKeyDeviceInstaller,
                       NULL) == ERROR_SUCCESS) {

        RegSetValueEx(hKeyDeviceInstaller,
                      REGSTR_VAL_SEARCHOPTIONS,
                      0,
                      REG_DWORD,
                      (LPBYTE)&SearchOptions,
                      sizeof(SearchOptions)
                      );

        RegCloseKey(hKeyDeviceInstaller);
    }
}

BOOL
IsInstallComplete(
    HDEVINFO         hDevInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine determines whether the install is complete on the specified
    device or not. If a device has configflags and CONFIGFLAG_REINSTALL and
    CONFIGFLAG_FINISH_INSTALL are not set then the install is considered
    complete.
    
    This API is needed since we could bring up the Found New Hardware wizard
    for one user and another user can switch away to their session. Umpnpmgr.dll
    will prompt the new user to install drivers as well.  If the new user does
    complete the device install then we want the first user's Found New
    Hardware wizard to go away as well.

Arguments:

    hDevInfo -
    
    DeviceInfoData - 

Return Value:

    BOOL. TRUE if the installation is complete and FALSE otherwise.

--*/
{
    BOOL bDriverInstalled = FALSE;
    DWORD ConfigFlags = 0;

    if (SetupDiGetDeviceRegistryProperty(hDevInfo,
                                         DeviceInfoData,
                                         SPDRP_CONFIGFLAGS,
                                         NULL,
                                         (PBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags),
                                         NULL) &&
        !(ConfigFlags & CONFIGFLAG_REINSTALL) &&
        !(ConfigFlags & CONFIGFLAG_FINISH_INSTALL)) {

        bDriverInstalled = TRUE;
    }

    return bDriverInstalled;
}

BOOL
GetIsWow64 (
    VOID
    )
/*++

Routine Description:

    Determine if we're running on WOW64 or not.  This will tell us if somebody
    is calling the 32-bit version of newdev.dll on a 64-bit machine.
    
    We call the GetSystemWow64Directory API, and if it fails and GetLastError()
    returns ERROR_CALL_NOT_IMPLENETED then this means we are on a 32-bit OS.

Arguments:

    none

Return value:

    TRUE if running under WOw64 (and special Wow64 features available)

--*/
{
#ifdef _WIN64
    //
    // If this is the 64-bit version of newdev.dll then always return FALSE.
    //
    return FALSE;

#else
    TCHAR Wow64Directory[MAX_PATH];

    if ((GetSystemWow64Directory(Wow64Directory, SIZECHARS(Wow64Directory)) == 0) &&
        (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)) {
        return FALSE;
    }
    
    //
    // GetSystemWow64Directory succeeded so we are on a 64-bit OS.
    //
    return TRUE;
#endif
}

BOOL
OpenCdmContextIfNeeded(
    HMODULE *hCdmInstance,
    HANDLE *hCdmContext
    )
{
    OPEN_CDM_CONTEXT_EX_PROC pfnOpenCDMContextEx;
    OSVERSIONINFOEX info;

    //
    // We can't load CDM if we are in the gui-setup.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    //
    // Never call CDM if this is DataCenter
    //
    info.dwOSVersionInfoSize = sizeof(info);
    if (GetVersionEx((POSVERSIONINFOW)&info) &&
        (info.wSuiteMask & VER_SUITE_DATACENTER)) {
        return FALSE;
    }

    //
    // First check to see if they are already loaded
    //
    if (*hCdmInstance && *hCdmContext) {
        return TRUE;
    }

    //
    // Load CDM.DLL if it is not already loaded
    //
    if (!(*hCdmInstance)) {
        *hCdmInstance = LoadLibrary(TEXT("CDM.DLL"));
    }

    if (*hCdmInstance) {
        //
        // Get a context handle to Cdm.dll by calling OpenCDMContextEx(FALSE).  
        // By passing FALSE we are telling CDM.DLL to not connect to the Internet
        // if there isn't currently a connection.
        //
        if (!(*hCdmContext)) {
            pfnOpenCDMContextEx = (OPEN_CDM_CONTEXT_EX_PROC)GetProcAddress(*hCdmInstance,
                                                                           "OpenCDMContextEx"
                                                                           );
        
            if (pfnOpenCDMContextEx) {
                *hCdmContext = pfnOpenCDMContextEx(FALSE);
            }
        }
    }

    if (*hCdmInstance && *hCdmContext) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
pSetSystemRestorePoint(
    BOOL Begin,
    BOOL CancelOperation,
    int RestorePointResourceId
    )
{
    RESTOREPOINTINFO RestorePointInfo;
    STATEMGRSTATUS SMgrStatus;
    SRSETRESTOREPOINT pfnSrSetRestorePoint;    
    BOOL b = FALSE;
    
    if (!hSrClientDll) {
        hSrClientDll = LoadLibrary(TEXT("srclient.dll"));

        if (!hSrClientDll) {
            return FALSE;
        }
    }

    pfnSrSetRestorePoint = (SRSETRESTOREPOINT)GetProcAddress(hSrClientDll,
                                                             "SRSetRestorePointW"
                                                             );

    //
    // If we can't get the proc address for SRSetRestorePoint then just
    // free the library.
    //
    if (!pfnSrSetRestorePoint) {
        FreeLibrary(hSrClientDll);
        hSrClientDll = FALSE;
        return FALSE;
    }

    //
    // Set the system restore point.
    //
    RestorePointInfo.dwEventType = Begin 
        ? BEGIN_NESTED_SYSTEM_CHANGE
        : END_NESTED_SYSTEM_CHANGE;
    RestorePointInfo.dwRestorePtType = CancelOperation 
        ? CANCELLED_OPERATION
        : DEVICE_DRIVER_INSTALL;
    RestorePointInfo.llSequenceNumber = 0;

    if (RestorePointResourceId) {
        if (!LoadString(hNewDev,
                        RestorePointResourceId,
                        RestorePointInfo.szDescription,
                        SIZECHARS(RestorePointInfo.szDescription)
                        )) {
            RestorePointInfo.szDescription[0] = TEXT('\0');
        }
    } else {
        RestorePointInfo.szDescription[0] = TEXT('\0');
    }

    b = pfnSrSetRestorePoint(&RestorePointInfo, &SMgrStatus);

    //
    // If we are calling END_NESTED_SYSTEM_CHANGE then unload the srclient.dll
    // since we won't be needing it again.
    //
    if (!Begin) {
        FreeLibrary(hSrClientDll);
        hSrClientDll = FALSE;
    }

    return b;
}

BOOL
GetProcessorExtension(
    LPTSTR ProcessorExtension,
    DWORD  ProcessorExtensionSize
    )
{
    SYSTEM_INFO SystemInfo;
    BOOL bReturn = TRUE;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));

    GetSystemInfo(&SystemInfo);

    switch(SystemInfo.wProcessorArchitecture) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        lstrcpyn(ProcessorExtension, TEXT("i386"), ProcessorExtensionSize);
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        lstrcpyn(ProcessorExtension, TEXT("IA64"), ProcessorExtensionSize);
        break;

    case PROCESSOR_ARCHITECTURE_MSIL:
        lstrcpyn(ProcessorExtension, TEXT("MSIL"), ProcessorExtensionSize);
        break;

    case PROCESSOR_ARCHITECTURE_AMD64:
        lstrcpyn(ProcessorExtension, TEXT("AMD64"), ProcessorExtensionSize);
        break;

    default:
        ASSERT(0);
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

BOOL
GetGuiSetupInProgress(
    VOID
    )
/*++

Routine Description:

    This routine determines if we're doing a gui-mode setup.

    This value is retrieved from the following registry location:

    \HKLM\System\Setup\

        SystemSetupInProgress : REG_DWORD : 0x00 (where nonzero means we're doing a gui-setup)

Arguments:

    None.

Return Value:

    TRUE if we are in gui-mode setup, FALSE otherwise.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[SIZECHARS(REGSTR_PATH_SETUP) - 1 + SIZECHARS(REGSTR_KEY_SETUP)];
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {
            return(TRUE);
        }
    }

    return(FALSE);

}

DWORD
GetBusInformation(
    DEVNODE DevNode
    )
/*++

Routine Description:

    This routine retrieves the bus information flags.

Arguments:

    DeviceInfoSet -
    
    DeviceInfoData - 

Return Value:

    DWORD that contains the bus information flags.

--*/
{
    GUID BusTypeGuid;
    TCHAR BusTypeGuidString[MAX_GUID_STRING_LEN];
    HKEY hBusInformationKey;
    DWORD BusInformation = 0;
    DWORD dwType, cbData;

    //
    // Get the bus type GUID for this device.
    //
    cbData = sizeof(BusTypeGuid);
    if (CM_Get_DevNode_Registry_Property(DevNode,
                                         CM_DRP_BUSTYPEGUID,
                                         &dwType,
                                         (PVOID)&BusTypeGuid,
                                         &cbData,
                                         0) != CR_SUCCESS) {
        goto clean0;
    }

    //
    // Convert the bus type GUID into a string.
    //
    if (pSetupStringFromGuid(&BusTypeGuid,
                             BusTypeGuidString,
                             sizeof(BusTypeGuidString)/sizeof(TCHAR)
                             ) != NO_ERROR) {
        goto clean0;
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_BUSINFORMATION,
                     0,
                     KEY_READ,
                     &hBusInformationKey
                     ) != ERROR_SUCCESS) {
        goto clean0;
    }

    cbData = sizeof(BusInformation);
    RegQueryValueEx(hBusInformationKey,
                    BusTypeGuidString,
                    NULL,
                    &dwType,
                    (LPBYTE)&BusInformation,
                    &cbData);

    RegCloseKey(hBusInformationKey);

clean0:
    return BusInformation;
}

void
CdmCancelCDMOperation(
    HMODULE hCdmInstance
    )
{
    CANCEL_CDM_OPERATION_PROC pfnCancelCDMOperation;
    
    if (!hCdmInstance) {
        return;
    }
    
    pfnCancelCDMOperation = (CANCEL_CDM_OPERATION_PROC)GetProcAddress(hCdmInstance,
                                                                      "CancelCDMOperation"
                                                                      );
    if (!pfnCancelCDMOperation) {
        return;
    }
    
    pfnCancelCDMOperation();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\selclass.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       selclass.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"         // Private header stuff not in the PCH

int CALLBACK
ClassListCompare(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    TCHAR ClassDescription1[LINE_LEN];
    TCHAR ClassDescription2[LINE_LEN];

    //
    // Check if the 1st item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam1, &GUID_DEVCLASS_UNKNOWN)) {
        return -1;
    }

    //
    // Check if the 2nd item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam2, &GUID_DEVCLASS_UNKNOWN)) {
        return 1;
    }

    if (SetupDiGetClassDescription((LPGUID)lParam1,
                                   ClassDescription1,
                                   LINE_LEN,
                                   NULL
                                   ) &&
        SetupDiGetClassDescription((LPGUID)lParam2,
                                   ClassDescription2,
                                   LINE_LEN,
                                   NULL
                                   )) {
    
        return (lstrcmpi(ClassDescription1, ClassDescription2));
    }

    return 0;
}

void InitNDW_PickClassDlg(
    HWND hwndClassList,
    PNEWDEVWIZ NewDevWiz
    )
{
    int  Index;
    LPGUID ClassGuid, lpClassGuidSelected;
    GUID ClassGuidSelected;
    int    lvIndex;
    DWORD  ClassGuidNum;
    LV_ITEM lviItem;
    TCHAR ClassDescription[LINE_LEN];

    SendMessage(hwndClassList, WM_SETREDRAW, FALSE, 0L);

    //
    // Clear the Class List
    //
    ListView_DeleteAllItems(hwndClassList);

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;

    ClassGuid = NewDevWiz->ClassGuidList;
    ClassGuidNum = NewDevWiz->ClassGuidNum;

    //
    // Keep track of previosuly selected item
    //
    if (IsEqualGUID(&NewDevWiz->lvClassGuidSelected, &GUID_NULL)) {
        
        lpClassGuidSelected = NULL;
    }
    
    else {
        
        ClassGuidSelected = NewDevWiz->lvClassGuidSelected;
        NewDevWiz->lvClassGuidSelected = GUID_NULL;
        lpClassGuidSelected = &ClassGuidSelected;
    }


    while (ClassGuidNum--) {
        
        if (SetupDiGetClassDescription(ClassGuid,
                                       ClassDescription,
                                       LINE_LEN,
                                       NULL
                                       ))
        {
            if (IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN)) {

                //
                // We need to special case the UNKNOWN class and to give it a 
                // special icon (blank) and special text (Show All Devices).
                //
                LoadString(hNewDev, 
                           IDS_SHOWALLDEVICES, 
                           ClassDescription, 
                           SIZECHARS(ClassDescription)
                           );
                lviItem.iImage = g_BlankIconIndex;                
                lviItem.mask |= LVIF_IMAGE;

            } else if (SetupDiGetClassImageIndex(&NewDevWiz->ClassImageList,
                                           ClassGuid,
                                           &lviItem.iImage
                                           )) {

                lviItem.mask |= LVIF_IMAGE;
            
            } else {
                
                lviItem.mask &= ~LVIF_IMAGE;
            }

            lviItem.pszText = ClassDescription;
            lviItem.lParam = (LPARAM) ClassGuid;
            lvIndex = ListView_InsertItem(hwndClassList, &lviItem);

            //
            // check for previous selection
            //
            if (lpClassGuidSelected &&
                IsEqualGUID(lpClassGuidSelected, ClassGuid))
            {
                ListView_SetItemState(hwndClassList,
                                      lvIndex,
                                      LVIS_SELECTED|LVIS_FOCUSED,
                                      LVIS_SELECTED|LVIS_FOCUSED
                                      );

                lpClassGuidSelected = NULL;
            }
        }

        ClassGuid++;
    }

    //
    // Sort the list
    //
    ListView_SortItems(hwndClassList, (PFNLVCOMPARE)ClassListCompare, NULL);

    //
    // if previous selection wasn't found select first in list.
    //
    if (IsEqualGUID(&NewDevWiz->lvClassGuidSelected, &GUID_NULL)) {
        
        lvIndex = 0;
        ListView_SetItemState(hwndClassList,
                              lvIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                              );
    }

    //
    // previous selection was found, fetch its current index
    //
    else {
        
        lvIndex = ListView_GetNextItem(hwndClassList,
                                       -1,
                                       LVNI_SELECTED
                                       );
    }


    //
    // scroll the selected item into view.
    //
    ListView_EnsureVisible(hwndClassList, lvIndex, FALSE);
    ListView_SetColumnWidth(hwndClassList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndClassList, WM_SETREDRAW, TRUE, 0L);
}

INT_PTR CALLBACK
NDW_PickClassDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    DWORD Error;
    HWND hwndClassList = GetDlgItem(hDlg, IDC_NDW_PICKCLASS_CLASSLIST);
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);



    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        LV_COLUMN lvcCol;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        SetDlgText(hDlg, IDC_NDW_TEXT, IDS_NDW_PICKCLASS1, IDS_NDW_PICKCLASS1);

        //
        // Get the Class Icon Image Lists.  We do this only the first
        // time this dialog is initialized.
        //
        if (NewDevWiz->ClassImageList.cbSize) {
            ListView_SetImageList(hwndClassList,
                                  NewDevWiz->ClassImageList.ImageList,
                                  LVSIL_SMALL
                                  );
        }

        //
        // Insert a column for the class list
        //
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(hwndClassList, 0, (LV_COLUMN FAR *)&lvcCol);

        //
        // Save the class before the user chooses one. This will be restored
        // in the event the install is cancelled.
        //
        NewDevWiz->SavedClassGuid = NewDevWiz->DeviceInfoData.ClassGuid;

        break;
    }


    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        //
        // This dialog is being activated.  Each time we are activated
        // we free up the current DeviceInfo and create a new one. Although
        // inefficient, its necessary to reenumerate the class list.
        //
        case PSN_SETACTIVE:

            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SELECTCLASS;

            //
            // If we have DeviceInfo from going forward delete it.
            //
            if (NewDevWiz->ClassGuidSelected) {

                SetClassGuid(NewDevWiz->hDeviceInfo,
                             &NewDevWiz->DeviceInfoData,
                             &NewDevWiz->SavedClassGuid
                             );
            }

            NewDevWiz->ClassGuidSelected = NULL;

            NdwBuildClassInfoList(NewDevWiz, 0);
            InitNDW_PickClassDlg(hwndClassList, NewDevWiz);
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            SetClassGuid(NewDevWiz->hDeviceInfo,
                         &NewDevWiz->DeviceInfoData,
                         &NewDevWiz->SavedClassGuid
                         );
            break;



        case PSN_WIZBACK:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SELECTCLASS;
               
            if (NewDevWiz->EnterInto == IDD_NEWDEVWIZ_SELECTCLASS) {
                   
                SetDlgMsgResult(hDlg, wMsg, NewDevWiz->EnterFrom);
            }
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;



        case PSN_WIZNEXT: {
               
            HDEVINFO hDeviceInfo;
            LPGUID  ClassGuidSelected;
            SP_DEVINSTALL_PARAMS DeviceInstallParams;

            SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTDEVICE);

            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);

            if (IsEqualGUID(&NewDevWiz->lvClassGuidSelected, &GUID_NULL)) {
                   
                NewDevWiz->ClassGuidSelected = NULL;
                break;
            }

            ClassGuidSelected = &NewDevWiz->lvClassGuidSelected;
            NewDevWiz->ClassGuidSelected = ClassGuidSelected;

            //
            // Add a new element to the DeviceInfo from the GUID and class name
            //
            NewDevWiz->DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            if (!SetupDiGetClassDescription(NewDevWiz->ClassGuidSelected,
                                            NewDevWiz->ClassDescription,
                                            sizeof(NewDevWiz->ClassDescription)/sizeof(TCHAR),
                                            NULL
                                            )
                ||
                !SetupDiClassNameFromGuid(NewDevWiz->ClassGuidSelected,
                                          NewDevWiz->ClassName,
                                          sizeof(NewDevWiz->ClassName)/sizeof(TCHAR),
                                          NULL
                                          ))
            {
                // unhandled error!
                NewDevWiz->ClassGuidSelected = NULL;
                break;
            }

            if (IsEqualGUID(NewDevWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                   
                ClassGuidSelected = (LPGUID)&GUID_NULL;
            }


            SetClassGuid(NewDevWiz->hDeviceInfo,
                         &NewDevWiz->DeviceInfoData,
                         ClassGuidSelected
                         );

            break;
        }

        case NM_DBLCLK:
            PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
            break;

        case LVN_ITEMCHANGED: {
               
            LPNM_LISTVIEW   lpnmlv = (LPNM_LISTVIEW)lParam;

            if ((lpnmlv->uChanged & LVIF_STATE)) {
                   
                if (lpnmlv->uNewState & LVIS_SELECTED) {
                       
                    NewDevWiz->lvClassGuidSelected = *((LPGUID)lpnmlv->lParam);
                }
                   
                else if (IsEqualGUID((LPGUID)lpnmlv->lParam,
                                        &NewDevWiz->lvClassGuidSelected
                                        ))
                {
                    NewDevWiz->lvClassGuidSelected = GUID_NULL;
                }
            }

            break;
        }
        }
        break;


    case WM_SYSCOLORCHANGE:
        _OnSysColorChange(hDlg, wParam, lParam);

        //
        // Update the ImageList Background color
        //
        ImageList_SetBkColor((HIMAGELIST)SendMessage(GetDlgItem(hDlg, IDC_NDW_PICKCLASS_CLASSLIST), LVM_GETIMAGELIST, (WPARAM)(LVSIL_SMALL), 0L),
                                GetSysColor(COLOR_WINDOW));
        break;

    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

void
DestroyDynamicWizard(
    HWND hwndParentDlg,
    PNEWDEVWIZ NewDevWiz,
    BOOL WmDestroy
    )
{
    DWORD Pages;
    PSP_INSTALLWIZARD_DATA InstallWizard = &NewDevWiz->InstallDynaWiz;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;


    Pages = InstallWizard->NumDynamicPages;
    InstallWizard->NumDynamicPages = 0;

    if (InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {

        if (!WmDestroy) {
            
            while (Pages--) {
                
                PropSheet_RemovePage(hwndParentDlg,
                                     (WPARAM)-1,
                                     InstallWizard->DynamicPages[Pages]
                                     );

                InstallWizard->DynamicPages[Pages] = NULL;
            }
        }


        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags |= DI_CLASSINSTALLPARAMS;
            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }


        InstallWizard->DynamicPageFlags &= ~DYNAWIZ_FLAG_PAGESADDED;
        InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        InstallWizard->ClassInstallHeader.InstallFunction = DIF_DESTROYWIZARDDATA;
        InstallWizard->hwndWizardDlg = hwndParentDlg;

        if (SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         &InstallWizard->ClassInstallHeader,
                                         sizeof(SP_INSTALLWIZARD_DATA)
                                         ))
        {
            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA,
                                      NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData
                                      );
        }
    }
}

//
// The real select device page is in either setupapi or the class installer
// for dyanwiz. this page is a blank page which never shows its face
// to have a consistent place to jump to when the class is known.
//
INT_PTR CALLBACK
NDW_SelectDeviceDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);



    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {
            int PrevPage, BackUpPage;

            PrevPage = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SELECTDEVICE;
            BackUpPage = NewDevWiz->EnterInto == IDD_NEWDEVWIZ_SELECTDEVICE
                           ? NewDevWiz->EnterFrom : IDD_NEWDEVWIZ_SELECTCLASS;

            //
            // If we are coming from select class, driver update or Install NewDevice
            // then we are going forward.
            //
            if (!NewDevWiz->ClassGuidSelected || PrevPage == IDD_WIZARDEXT_PRESELECT) {

                //
                // going backwards, cleanup and backup
                //
                SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL
                                         );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_COMPATDRIVER
                                             );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );


                //
                // Cleanup the WizExtPreSelect Page
                //
                if (NewDevWiz->WizExtPreSelect.hPropSheet) {
                       
                    PropSheet_RemovePage(GetParent(hDlg),
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtPreSelect.hPropSheet
                                         );
                }

                SetDlgMsgResult(hDlg, wMsg, BackUpPage);
                break;
            }


            //
            // Set the Cursor to an Hourglass
            //
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            NewDevWiz->WizExtPreSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_PRESELECT,
                                                                     WizExtPreSelectDlgProc,
                                                                     NewDevWiz
                                                                     );

            if (NewDevWiz->WizExtPreSelect.hPropSheet) {
                   
                PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtPreSelect.hPropSheet);
                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
            }
               
            else {
                
                SetDlgMsgResult(hDlg, wMsg, BackUpPage);
            }

            break;
        }

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_PRESELECT;

            if (PrevPageId == IDD_NEWDEVWIZ_SELECTDEVICE) {
                  
                PSP_NEWDEVICEWIZARD_DATA WizardExt;

                //
                // Moving forward on first page
                //


                //
                // Set the Cursor to an Hourglass
                //
                SetCursor(LoadCursor(NULL, IDC_WAIT));

                //
                // Add ClassWizard Extension pages
                //
                if (NewDevWiz->Flags & IDI_FLAG_MANUALINSTALL) {

                    AddClassWizExtPages(hwndParentDlg,
                                        NewDevWiz,
                                        &NewDevWiz->WizExtPreSelect.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_PRESELECT,
                                        NULL
                                        );
                }


                //
                // Add the end page, which is first of the select page set
                //
                NewDevWiz->WizExtSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_SELECT,
                                                                      WizExtSelectDlgProc,
                                                                      NewDevWiz
                                                                      );

                if (NewDevWiz->WizExtSelect.hPropSheet) {

                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtSelect.hPropSheet);
                }

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }

            else {
                //
                // Moving backwards on first page
                //

                //
                // Clean up proppages added.
                //
                if (NewDevWiz->WizExtSelect.hPropSheet) {
                      
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtSelect.hPropSheet
                                         );
                      
                    NewDevWiz->WizExtSelect.hPropSheet = NULL;
                }

                RemoveClassWizExtPages(hwndParentDlg,
                                       &NewDevWiz->WizExtPreSelect.DeviceWizardData
                                       );

                //
                // Jump back
                //
                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTDEVICE);
            }
            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        DestroyDynamicWizard(hwndParentDlg, NewDevWiz, TRUE);
        break;


    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_SELECT;

            if (PrevPageId == IDD_WIZARDEXT_PRESELECT) {
                  
                SP_DEVINSTALL_PARAMS  DeviceInstallParams;

                //
                // Moving forward on first page
                //



                //
                // Prepare to call the class installer, for class install wizard pages.
                // and Add in setup's SelectDevice wizard page.
                //
                InstallWizard = &NewDevWiz->InstallDynaWiz;
                memset(InstallWizard, 0, sizeof(SP_INSTALLWIZARD_DATA));
                InstallWizard->ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
                InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                InstallWizard->hwndWizardDlg = GetParent(hDlg);

                if (!SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &InstallWizard->ClassInstallHeader,
                                                  sizeof(SP_INSTALLWIZARD_DATA)
                                                  ))
                {
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                    break;
                }


                SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL
                                         );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_COMPATDRIVER
                                             );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );
                
                //
                // Get current DeviceInstall parameters, and then set the fields
                // we wanted changed from default
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                  
                if (!SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                   &NewDevWiz->DeviceInfoData,
                                                   &DeviceInstallParams
                                                   ))
                {
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                    break;
                }


                DeviceInstallParams.Flags |= DI_SHOWCLASS | DI_SHOWCOMPAT | DI_SHOWOEM | DI_CLASSINSTALLPARAMS;

                DeviceInstallParams.DriverPath[0] = TEXT('\0');

                if (IsEqualGUID(NewDevWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                      
                    DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_FILTERCLASSES;
                }
                  
                else {
                
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERCLASSES;
                }

                //
                // Check to see if we should show all class drivers or only similar
                // drivers for this device.
                //
                if (GetBusInformation(NewDevWiz->DeviceInfoData.DevInst) & BIF_SHOWSIMILARDRIVERS) {
                    
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERSIMILARDRIVERS;
                
                } else {

                    DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_FILTERSIMILARDRIVERS;
                }

                DeviceInstallParams.hwndParent = hwndParentDlg;
                if (!SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                   &NewDevWiz->DeviceInfoData,
                                                   &DeviceInstallParams
                                                   ))
                {
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                    break;
                }


                //
                // Call the class installer for installwizard
                // If no class install wizard pages default to run the standard
                // setup wizard select device page.
                //
                if ((NewDevWiz->Flags & IDI_FLAG_MANUALINSTALL) &&
                    SetupDiCallClassInstaller(DIF_INSTALLWIZARD,
                                              NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData
                                              )
                    &&
                    SetupDiGetClassInstallParams(NewDevWiz->hDeviceInfo,
                                                 &NewDevWiz->DeviceInfoData,
                                                 &InstallWizard->ClassInstallHeader,
                                                 sizeof(SP_INSTALLWIZARD_DATA),
                                                 NULL
                                                 )
                    &&
                    InstallWizard->NumDynamicPages)
                {
                    DWORD   Pages;

                    InstallWizard->DynamicPageFlags |= DYNAWIZ_FLAG_PAGESADDED;
                      
                    for (Pages = 0; Pages < InstallWizard->NumDynamicPages; ++Pages ) {
                           
                        PropSheet_AddPage(hwndParentDlg, InstallWizard->DynamicPages[Pages]);
                    }

                    NewDevWiz->SelectDevicePage = SetupDiGetWizardPage(NewDevWiz->hDeviceInfo,
                                                                       &NewDevWiz->DeviceInfoData,
                                                                       InstallWizard,
                                                                       SPWPT_SELECTDEVICE,
                                                                       SPWP_USE_DEVINFO_DATA
                                                                       );

                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->SelectDevicePage);
                }

                else {

                    InstallWizard->DynamicPageFlags = 0;
                    NewDevWiz->SelectDevicePage = NULL;

                    if (!(NewDevWiz->Flags & IDI_FLAG_MANUALINSTALL) ||
                        !AddClassWizExtPages(hwndParentDlg,
                                             NewDevWiz,
                                             &NewDevWiz->WizExtSelect.DeviceWizardData,
                                             DIF_NEWDEVICEWIZARD_SELECT,
                                             NULL
                                             ))
                    {
                        NewDevWiz->SelectDevicePage = SetupDiGetWizardPage(NewDevWiz->hDeviceInfo,
                                                                           &NewDevWiz->DeviceInfoData,
                                                                           InstallWizard,
                                                                           SPWPT_SELECTDEVICE,
                                                                           SPWP_USE_DEVINFO_DATA
                                                                           );

                        PropSheet_AddPage(hwndParentDlg, NewDevWiz->SelectDevicePage);
                    }
                }


                //
                // Clear the class install parameters.
                //
                SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             NULL,
                                             0
                                             );

                //
                // Add the end page, which is the preanalyze page.
                //
                NewDevWiz->WizExtPreAnalyze.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_PREANALYZE,
                                                                          WizExtPreAnalyzeDlgProc,
                                                                          NewDevWiz
                                                                          );

                PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtPreAnalyze.hPropSheet);

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }

            else {
                  
                //
                // Moving backwards on first page
                //


                //
                // Clean up proppages added.
                //
                DestroyDynamicWizard(hwndParentDlg, NewDevWiz, FALSE);

                if (NewDevWiz->SelectDevicePage) {
                      
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->SelectDevicePage
                                         );
                      
                    NewDevWiz->SelectDevicePage = NULL;
                }


                if (NewDevWiz->WizExtPreAnalyze.hPropSheet) {
                      
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtPreAnalyze.hPropSheet
                                         );
                      
                    NewDevWiz->WizExtPreAnalyze.hPropSheet = NULL;
                }



                RemoveClassWizExtPages(hwndParentDlg,
                                       &NewDevWiz->WizExtSelect.DeviceWizardData
                                       );


                //
                // Jump back
                //
                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
            }
            break;

        case PSN_WIZNEXT:
          SetDlgMsgResult(hDlg, wMsg, 0);
          break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\update.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       update.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"

#define INSTALL_UI_TIMERID  1423

PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo={0};

BOOL
RegistryDeviceName(
    DEVINST DevInst,
    PTCHAR  Buffer,
    DWORD   cbBuffer
    )
{
    ULONG ulSize;
    CONFIGRET ConfigRet;

    //
    // Try the registry for FRIENDLYNAME
    //

    ulSize = cbBuffer;
    ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                 CM_DRP_FRIENDLYNAME,
                                                 NULL,
                                                 Buffer,
                                                 &ulSize,
                                                 0);

    if (ConfigRet == CR_SUCCESS && *Buffer) {

        return TRUE;
    }


    //
    // Try the registry for DEVICEDESC
    //

    ulSize = cbBuffer;
    ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                 CM_DRP_DEVICEDESC,
                                                 NULL,
                                                 Buffer,
                                                 &ulSize,
                                                 0);

    if (ConfigRet == CR_SUCCESS && *Buffer) {

        return TRUE;
    }

    return FALSE;
}




//
// returns TRUE if we were able to find a reasonable name
// (something besides unknown device).
//

void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PNEWDEVWIZ NewDevWiz
    )
{
    CONFIGRET ConfigRet;
    ULONG  ulSize;
    PTCHAR FriendlyName;
    PTCHAR Location;
    SP_DRVINFO_DATA DriverInfoData;


    //
    // If there is a selected driver use its driver description,
    // since this is what the user is going to install.
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )
        &&
        *DriverInfoData.Description) {

        wcscpy(NewDevWiz->DriverDescription, DriverInfoData.Description);
        SetDlgItemText(hDlg, iControl, NewDevWiz->DriverDescription);
        return;
    }


    FriendlyName = BuildFriendlyName(NewDevWiz->DeviceInfoData.DevInst, FALSE, NULL);
    if (FriendlyName) {

        SetDlgItemText(hDlg, iControl, FriendlyName);
        LocalFree(FriendlyName);
        return;
    }

    SetDlgItemText(hDlg, iControl, szUnknown);

    return;
}

/*
 *  Intializes\Updates the global ProcessDeviceMapInfo which is used
 *  by GetNextDriveByType().
 *
 *  WARNING: NOT multithread safe!
 */
BOOL
IntializeDeviceMapInfo(
   void
   )
{
    NTSTATUS Status;

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessDeviceMap,
                                       &ProcessDeviceMapInfo.Query,
                                       sizeof(ProcessDeviceMapInfo.Query),
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {

        RtlZeroMemory(&ProcessDeviceMapInfo, sizeof(ProcessDeviceMapInfo));
        return FALSE;
    }

    return TRUE;
}

UINT
GetNextDriveByType(
    UINT DriveType,
    UINT DriveNumber
    )
/*++

Routine Description:

   Inspects each drive starting from DriveNumber in ascending order to find the
   first drive of the specified DriveType from the global ProcessDeviceMapInfo.
   The ProcessDeviceMapInfo must have been intialized and may need refreshing before
   invoking this function. Invoke IntializeDeviceMapInfo to initialize or update
   the DeviceMapInfo.

Arguments:

   DriveType - DriveType as defined in winbase, GetDriveType().

   DriveNumber - Starting DriveNumber, 1 based.

Return Value:

   DriveNumber - if nonzero Drive found, 1 based.

--*/
{

    //
    // OneBased DriveNumber to ZeroBased.
    //
    DriveNumber--;
    while (DriveNumber < 26) {

        if ((ProcessDeviceMapInfo.Query.DriveMap & (1<< DriveNumber)) &&
             ProcessDeviceMapInfo.Query.DriveType[DriveNumber] == DriveType) {

            return DriveNumber+1; // return 1 based DriveNumber found.
        }

        DriveNumber++;
    }

    return 0;
}



//
// This function takes a fully qualified path name and returns a pointer to
// the begining of the path portion.
//
// e.g. \\server\pathpart
//      d:\pathpart
//
// This function will always return a valid pointer, provided
// a valid pointer was passed in. If the caller passes in a badly
// formed pathname or an unknown format, where path ends up pointing is
// unknown, except that it will be someplace within the string.
//

WCHAR *
GetPathPart(
    WCHAR *Path
    )
{
    //
    // We assume that we are being passed a fully qualified path name
    //

    //
    // check for UNC path.
    //

    if (*Path == L'\\') {

        Path += 2;                           // skip double backslash
    }


    //
    // if UNC Path points to beg of server name
    // if drive letter format, points to the drive letter
    //

    while (*Path && *Path++ != L'\\') {

        ;
    }

    return Path;
}

void
InstallSilentChildSiblings(
   HWND hwndParent,
   PNEWDEVWIZ NewDevWiz,
   DEVINST DeviceInstance,
   BOOL ReinstallAll
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;
    ULONG Ulong, ulValue;
    BOOL NeedsInstall, IsSilent;

    do {

        //
        // If this device instance needs installing and is silent then install it,
        // and its children.
        //

        IsSilent = FALSE;
        if (!ReinstallAll) {

            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CAPABILITIES,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CM_DEVCAP_SILENTINSTALL)) {

                IsSilent = TRUE;
            }
        }

        if (IsSilent || ReinstallAll) {

            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CONFIGFLAGS,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CONFIGFLAG_FINISH_INSTALL)) {

                NeedsInstall = TRUE;

            } else {

                ConfigRet = CM_Get_DevNode_Status(&Ulong,
                                                  &ulValue,
                                                  DeviceInstance,
                                                  0
                                                  );

                NeedsInstall = ConfigRet == CR_SUCCESS &&
                               (ulValue == CM_PROB_REINSTALL ||
                                ulValue == CM_PROB_NOT_CONFIGURED
                                );
            }


            if (NeedsInstall) {

                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

                ConfigRet = CM_Get_Device_ID(DeviceInstance,
                                            DeviceInstanceId,
                                            sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                            0
                                            );

                if (ConfigRet == CR_SUCCESS) {

                    if (InstallDevInst(hwndParent,
                                       DeviceInstanceId,
                                       FALSE,   // only for found new.
                                       &Ulong
                                       )) {

                        NewDevWiz->Reboot |= Ulong;
                    }


                    //
                    // If this devinst has children, then recurse to install them as well.
                    //

                    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                                DeviceInstance,
                                                0,
                                                NULL
                                                );

                    if (ConfigRet == CR_SUCCESS) {

                        InstallSilentChildSiblings(hwndParent, NewDevWiz, ChildDeviceInstance, ReinstallAll);
                    }

                }
            }
        }


        //
        // Next sibling ...
        //

        ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                      DeviceInstance,
                                      0,
                                      NULL
                                      );

    } while (ConfigRet == CR_SUCCESS);

}

void
InstallSilentChilds(
   HWND hwndParent,
   PNEWDEVWIZ NewDevWiz
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;

    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                NewDevWiz->DeviceInfoData.DevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        InstallSilentChildSiblings(hwndParent, NewDevWiz, ChildDeviceInstance, FALSE);
    }
}

void
SendMessageToUpdateBalloonInfo(
    PTSTR DeviceDesc
    )
{
    HWND hBalloonInfoWnd;
    COPYDATASTRUCT cds;

    hBalloonInfoWnd = FindWindow(NEWDEV_CLASS_NAME, NULL);

    if (hBalloonInfoWnd) {

        cds.dwData = 0;
        cds.cbData = (lstrlen(DeviceDesc) + 1) * sizeof(TCHAR);
        cds.lpData = DeviceDesc;

        SendMessage(hBalloonInfoWnd, WM_COPYDATA, 0, (LPARAM)&cds);
    }
}

void
UpdateBalloonInfo(
    HWND hWnd,
    PTSTR DeviceDesc    OPTIONAL,
    DEVINST DevInst     OPTIONAL,
    HICON hNewDevIcon,
    BOOL bPlaySound
    )
{
    PTCHAR FriendlyName = NULL;
    NOTIFYICONDATA nid = { sizeof(nid), hWnd, 0 };

    nid.uID = 1;                                       

    if (DeviceDesc || DevInst) {
        if (DeviceDesc) {
            //
            // First use the DeviceDesc string that is passed into this API
            //
            lstrcpy(nid.szInfo, DeviceDesc);
        
        } else if ((FriendlyName = BuildFriendlyName(DevInst, TRUE, NULL)) != NULL) {
            //
            // If no DeviceDesc string was passed in then use the DevInst to get
            // the Device's FriendlyName or DeviceDesc property
            //
            lstrcpy(nid.szInfo, FriendlyName);
            LocalFree(FriendlyName);
        
        } else {
            //
            // If we could not get a friendly name for the device or no device was specified
            // so just display the Searching... text.
            //
            LoadString(hNewDev, IDS_NEWSEARCH, nid.szInfo, SIZECHARS(nid.szInfo));
        }
    
        nid.uFlags = NIF_INFO;
        nid.uTimeout = 60000;
        nid.dwInfoFlags = NIIF_INFO | (bPlaySound ? 0 : NIIF_NOSOUND);
        LoadString(hNewDev, IDS_FOUNDNEWHARDWARE, nid.szInfoTitle, SIZECHARS(nid.szInfoTitle));
        Shell_NotifyIcon(NIM_MODIFY, &nid);
    }
}

LRESULT CALLBACK
BalloonInfoProc(
    HWND   hWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
   )
{
    static HICON hNewDevIcon = NULL;
    static BOOL bCanExit;
    NOTIFYICONDATA nid;
    
    switch (message) {
     
    case WM_CREATE:
        hNewDevIcon = LoadImage(hNewDev, 
                                MAKEINTRESOURCE(IDI_NEWDEVICEICON), 
                                IMAGE_ICON,
                                GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON),
                                0
                                );

        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = 1;
        nid.hIcon = hNewDevIcon;

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_ICON;
        Shell_NotifyIcon(NIM_ADD, &nid);

        //
        // We want the tray icon to be displayed for at least 3 seconds otherwise it flashes too 
        // quickly and a user can't see it.
        //
        bCanExit = FALSE;
        SetTimer(hWnd, INSTALL_UI_TIMERID, 3000, NULL);
        break;

    case WM_DESTROY: {

        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = 1;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hNewDevIcon) {

            DestroyIcon(hNewDevIcon);
        }

        break;
    }

    case WM_TIMER:
        if (INSTALL_UI_TIMERID == wParam) {

            //
            // At this point the tray icon has been displayed for at least 10 seconds so we can
            // exit whenever we are finished.  If bCanExit is already TRUE then we have
            // already been asked to exit so just do a DestroyWindow at this point, otherwise
            // set bCanExit to TRUE so we can exit when we are finished installing devices.
            //
            if (bCanExit) {
            
                DestroyWindow(hWnd);

            } else {
                
                KillTimer(hWnd, INSTALL_UI_TIMERID);
                bCanExit = TRUE;
            }
        }
        break;

    case WUM_UPDATEUI:
        if (wParam & TIP_HIDE_BALLOON) {
            //
            // Hide the balloon.
            //
            NOTIFYICONDATA nid = { sizeof(nid), hWnd, 0 };

            nid.uID = 1;                                       
            nid.uFlags = NIF_INFO;
            nid.uTimeout = 0;
            nid.dwInfoFlags = NIIF_INFO;
            Shell_NotifyIcon(NIM_MODIFY, &nid);

        } else if (wParam & TIP_LPARAM_IS_DEVICEINSTANCEID) {
            //
            // The lParam is a DeviceInstanceID.  Convert it to a devnode
            // and then call UpdateBalloonInfo.
            //
            DEVINST DevInst = 0;

            if (lParam &&
                (CM_Locate_DevNode(&DevInst,
                                  (PTSTR)lParam,
                                  CM_LOCATE_DEVNODE_NORMAL
                                  ) == CR_SUCCESS)) {
                UpdateBalloonInfo(hWnd, 
                                  NULL, 
                                  DevInst, 
                                  hNewDevIcon,
                                  (wParam & TIP_PLAY_SOUND) ? TRUE : FALSE
                                  );
            }
        } else {
            //
            // The lParam is plain text (device description).  Send it directly
            // to UpdateBalloonInfo.
            //
            UpdateBalloonInfo(hWnd, 
                              (PTSTR)lParam, 
                              0, 
                              hNewDevIcon,
                              (wParam & TIP_PLAY_SOUND) ? TRUE : FALSE
                              );
        }
        break;

    case WM_COPYDATA:
    {
        //
        // This is the case where we needed to launch another instance of newdev.dll with Admin
        // credentials to do the actuall device install.  In order for it to update the UI it
        // will send the main newdev.dll a WM_COPYDATA message which will contain the string
        // to display in the balloon tooltip.
        //
        PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;

        if (pcds && pcds->lpData) {

            //
            // We assume that the lParam is plain text since the main newdev.dll updated the balloon
            // initially with the DeviceDesc.
            //
            UpdateBalloonInfo(hWnd, (PTSTR)pcds->lpData, 0, hNewDevIcon, FALSE);
        }
        
        break;
    }

    case WUM_EXIT:
        if (bCanExit) {
        
            DestroyWindow(hWnd);
        } else {

            ShowWindow(hWnd, SW_SHOW);
            bCanExit = TRUE;
        }
        break;

    default:
        break;

    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\newdev\sthread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sthread.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\backup.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    backup.h

Abstract:

    Private header for....
    Routines to control backup during install process
    And restore of an old install process
    (See also backup.c)

Author:

    Jamie Hunter (jamiehun) 13-Jan-1997

Revision History:

--*/

typedef struct _SP_TARGET_ENT {
    //
    // Used for backup and unwind-backup
    // Data of TargetLookupTable of a file Queue
    //

    // this file information (strings in StringTable)
    LONG        TargetRoot;
    LONG        TargetSubDir;
    LONG        TargetFilename;

    // where file is, or is-to-be backed up (strings in StringTable)
    LONG        BackupRoot;
    LONG        BackupSubDir;
    LONG        BackupFilename;

    // if file has been renamed, what the new target is (string in TargetLookupTable)
    LONG        NewTargetFilename;

    // Various flags as needed
    DWORD       InternalFlags;

    // security attributes etc
    // (jamiehun TODO)

} SP_TARGET_ENT, *PSP_TARGET_ENT;

typedef struct _SP_UNWIND_NODE {
    //
    // List of things to unwind, FILO
    //
    struct _SP_UNWIND_NODE *NextNode;

    LONG TargetID;                          // TargetID to use for UNWIND
    PSECURITY_DESCRIPTOR SecurityDesc;      // Security descriptor to apply
    FILETIME CreateTime;                    // Time stamps to apply
    FILETIME AccessTime;
    FILETIME WriteTime;

} SP_UNWIND_NODE, *PSP_UNWIND_NODE;

typedef struct _SP_DELAYMOVE_NODE {
    //
    // List of things to rename, FIFO
    //
    struct _SP_DELAYMOVE_NODE *NextNode;

    LONG SourceFilename;                    // What to rename
    LONG TargetFilename;                    // what to rename to
    DWORD SecurityDesc;                     // security descriptor index in the string table
    BOOL TargetIsProtected;                 // target file is a protected system file

} SP_DELAYMOVE_NODE, *PSP_DELAYMOVE_NODE;

#define SP_BKFLG_LATEBACKUP      (1)        // backup only if file is modified in any way
#define SP_BKFLG_PREBACKUP       (2)        // backup uninstall files first
#define SP_BKFLG_CALLBACK        (4)        // flag, indicating app should be callback aware

#define SP_TEFLG_SAVED          (0x00000001)    // set if file already copied/moved to backup
#define SP_TEFLG_TEMPNAME       (0x00000002)    // set if backup is temporary file
#define SP_TEFLG_ORIGNAME       (0x00000004)    // set if backup specifies an original name
#define SP_TEFLG_MODIFIED       (0x00000008)    // set if target has been modified/deleted (backup has original)
#define SP_TEFLG_MOVED          (0x00000010)    // set if target has been moved (to NewTargetFilename)
#define SP_TEFLG_BACKUPQUEUE    (0x00000020)    // set if backup queued in backup sub-queue
#define SP_TEFLG_RESTORED       (0x00000040)    // set if file already restored during unwind operation
#define SP_TEFLG_UNWIND         (0x00000080)    // set if file added to unwind list
#define SP_TEFLG_SKIPPED        (0x00000100)    // we didn't manage to back it up, we cannot back it up, we should not try again
#define SP_TEFLG_INUSE          (0x00000200)    // while backing up, we determined we cannot backup file because it cannot be read
#define SP_TEFLG_RENAMEEXISTING (0x00000400)    // rename existing file to temp filename in same directory.
#define SP_TEFLG_PRUNE_COPY     (0x00010000)    // set during file pruning, detected this file is on copy queue
#define SP_TEFLG_PRUNE_DEL      (0x00020000)    // set during file pruning, detected this file is on delete queue
#define SP_TEFLG_PRUNE_RENSRC   (0x00040000)    // set during file pruning, detected this file is on rename queue
#define SP_TEFLG_PRUNE_RENTARG  (0x00080000)    // file RENSRC is renamed to RENTARG

#define SP_BACKUP_DRIVERFILES   TEXT("DriverFiles")
#define SP_BACKUP_OLDFILES      TEXT("Temp") // relative to the windows directory
#define SP_LASTGOOD_NAME        TEXT("LastGood")

//
// these are private routines
//


DWORD
pSetupQueueBackupCopy(
    IN HSPFILEQ QueueHandle,
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,       OPTIONAL
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,       OPTIONAL
    IN LONG   BackupFilename
    );

BOOL
pSetupGetFullBackupPath(
    OUT     PTSTR       FullPath,
    IN      PCTSTR      Path,
    IN      UINT        TargetBufferSize,
    OUT     PUINT       RequiredSize    OPTIONAL
    );

DWORD
pSetupBackupCopyString(
    IN PVOID            DestStringTable,
    OUT PLONG           DestStringID,
    IN PVOID            SrcStringTable,
    IN LONG             SrcStringID
    );

DWORD
pSetupBackupGetTargetByPath(
    IN HSPFILEQ         QueueHandle,
    IN PVOID            PathStringTable,    OPTIONAL
    IN PCTSTR           TargetPath,         OPTIONAL
    IN LONG             TargetRoot,
    IN LONG             TargetSubDir,       OPTIONAL
    IN LONG             TargetFilename,
    OUT PLONG           TableID,            OPTIONAL
    OUT PSP_TARGET_ENT  TargetInfo
    );

DWORD
pSetupBackupGetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    OUT PSP_TARGET_ENT  TargetInfo
    );

DWORD
pSetupBackupSetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    IN PSP_TARGET_ENT   TargetInfo
    );

BOOL
pSetupResetTarget(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,        OPTIONAL
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

DWORD
pSetupBackupAppendFiles(
    IN HSPFILEQ         TargetQueueHandle,
    IN PCTSTR           BackupSubDir,
    IN DWORD            BackupFlags,
    IN HSPFILEQ         SourceQueueHandle OPTIONAL
    );

DWORD
pSetupBackupFile(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR TargetPath,
    IN PCTSTR BackupPath,
    IN LONG   TargetID,         OPTIONAL
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,
    IN LONG   BackupFilename,
    BOOL *DelayedBackup
    );

VOID
pSetupDeleteBackup(
    IN PCTSTR           BackupInstance
    );

DWORD
pSetupGetCurrentlyInstalledDriverNode(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );

DWORD
pSetupGetBackupQueue(
    IN      PCTSTR      DeviceID,
    IN OUT  HSPFILEQ    FileQueue,
    IN      DWORD       BackupFlags
    );

BOOL
PostDelayedMove(
    IN struct _SP_FILE_QUEUE *Queue,
    IN PCTSTR                 CurrentName,
    IN PCTSTR                 NewName,     OPTIONAL
    IN DWORD                  SecurityDesc,
    IN BOOL                   TargetIsProtected
    );

BOOL
UnPostDelayedMove(
    IN struct _SP_FILE_QUEUE *Queue,
    IN PCTSTR                 CurrentName,
    IN PCTSTR                 NewName      OPTIONAL
    );

DWORD
DoAllDelayedMoves(
    IN struct _SP_FILE_QUEUE *Queue
    );

DWORD
pSetupCompleteBackup(
    IN OUT  HSPFILEQ    FileQueue
    );

VOID
pSetupUnwindAll(
    IN struct _SP_FILE_QUEUE *Queue,
    IN BOOL              Succeeded
    );

VOID
pSetupCleanupBackup(
    IN struct _SP_FILE_QUEUE *Queue
    );

VOID
RestoreRenamedOrBackedUpFile(
    IN PCTSTR             TargetFilename,
    IN PCTSTR             CurrentFilename,
    IN BOOL               RenameFile,
    IN PSETUP_LOG_CONTEXT LogContext       OPTIONAL
    );

DWORD
pSetupDoLastKnownGoodBackup(
    IN struct _SP_FILE_QUEUE *Queue,           OPTIONAL
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    );

BOOL
pSetupRestoreLastKnownGoodFile(
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    );

#define SP_LKG_FLAG_FORCECOPY       0x00000001  // if set, turns copy safety-guards off
#define SP_LKG_FLAG_DELETEIFNEW     0x00000002  // if set, writes a delete entry for new files
#define SP_LKG_FLAG_DELETEEXISTING  0x00000004  // if set, writes a delete entry for existing files
#define SP_LKG_FLAG_DELETEOP        0x00000008  // if set, caller is deleting (or renaming) a file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\cntxtlog.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cntxtlog.h

Abstract:

    This module implements more logging for setupapi

Author:

    Gabe Schaffer (t-gabes) 7-Jul-1998

Revision History:

    Jamie Hunter (jamiehun) 26-Aug-1998

--*/

/*
    There are two log levels. One is set in the registry, which determines
    what is logged and how. The other is passed as a parameter, and indicates
    under what conditions the entry should be logged. For example, the registry
    would say that all errors and warnings should be logged, while the call to
    WriteLogEntry would specify in the LogLevel parameter that some string
    should be logged as a warning.

    The 24 least-significant bits specify flags which indicate the type of
    message when passed as a parameter, or the type of messages to logged
    when set in the registry.

    The 4 most-significant bits are flags:

    SETUP_LOG_DEBUGOUT - when specified in the registry, indicates that all
        log output should be sent to the debugger as well as the logfile.
        This flag is currently not supported as a parameter to WriteLogEntry.

    SETUP_LOG_SIMPLE - when specified in the registry, indicates that all
        logfile entries should be appended to the logfile in chronological
        order, rather than grouped by section name. This flag is not
        currently supported as a parameter.

    SETUP_LOG_BUFFER - when specified as a parameter, indicates that the
        message to be logged will be buffered until such time as a call to
        WriteLogEntry with the same LogContext but this flag is not specified.
        When an entry is to be logged without this flag set, the latest
        message will be added to the buffer, and the buffer will be flushed to
        the logfile.

        This allows you to build up a string to log without having to do
        buffer management everywhere.

        This flag does not make sense in the registry.

        NOTE: for proper functioning, do not mix log levels while buffering
        output.

        NOTE: if this flag is NOT specified, the string to be logged MUST
        end in a newline, otherwise bad stuff will happen if another log
        context writes to the logfile immediately afterward.

    SETUP_LOG_IS_CONTEXT - when specified in the registry, indicates that
        all context messages should be immediately logged to the logfile,
        rather than buffered in the LogContext.

        This flag should never appear in a file other than cntxtlog.*;
        that is, as a parameter it only makes sense if added to a multiple
        of SETUP_FIRST_LOG_CONTEXT.

        NOTE: the context buffering mechanism is explained below where
        ContextInfo is defined in SETUP_LOG_CONTEXT.
*/

//
// These registry/filename strings should probably belong elsewhere
//
#define SP_REGKEY_LOGLEVEL      TEXT("LogLevel")
#define SP_REGKEY_LOGPATH       TEXT("LogPath")
#define SP_REGKEY_APPLOGLEVEL   TEXT("AppLogLevels")
#define SP_LOG_FILENAME         TEXT("setupapi.log")


//
// these are for general setup log entries
//
#define SETUP_LOG_SHIFT         (0)
#define SETUP_LOG_LEVELMASK     0x000000FF
#define SETUP_LOG_NOLOG         0x00000001 // indicates no-logging (remember 0 is default)
#define SETUP_LOG_ERROR         0x00000010 // 10-1f is varying levels of errors
#define SETUP_LOG_WARNING       0x00000020 // 20-2f is varying levels of warnings
#define SETUP_LOG_INFO          0x00000030 // 30-3f is varying levels of info
#define SETUP_LOG_VERBOSE       0x00000040 // 40-4f is varying levels of verbose
#define SETUP_LOG_TIME          0x00000050 // 50+ allow logging of time-stamped enties
#define SETUP_LOG_TIMEALL       0x00000060 // 60+ turns on time-stamping of all entries
#define SETUP_LOG_VVERBOSE      0x00000070 // 70-7f is very-verbose - reserved for stuff that logging really slows down
#define SETUP_LOG_DEFAULT       0x00000020

//
// these are for driver-only log entries
//
#define DRIVER_LOG_SHIFT        (8)
#define DRIVER_LOG_LEVELMASK    0x0000FF00
#define DRIVER_LOG_NOLOG        0x00000100 // indicates no-logging (remember 0 is default)
#define DRIVER_LOG_ERROR        0x00001000
#define DRIVER_LOG_WARNING      0x00002000
#define DRIVER_LOG_INFO         0x00003000
#define DRIVER_LOG_INFO1        0x00003100
#define DRIVER_LOG_VERBOSE      0x00004000
#define DRIVER_LOG_VERBOSE1     0x00004100
#define DRIVER_LOG_TIME         0x00005000
#define DRIVER_LOG_TIMEALL      0x00006000
#define DRIVER_LOG_VVERBOSE     0x00007000 // 70-7f is very-verbose - reserved for stuff that logging really slows down
#define DRIVER_LOG_DEFAULT      0x00003000

//
// Calling AllocLogInfoSlot will return an index with SETUP_LOG_IS_CONTEXT set
// this index represents a nested stack entry for logging information
// that will get dumped if an actual log entry is dumped
// thus providing more information
// note that lower 16 bits are used for index, re-using above Log level bits
//
#define SETUP_LOG_IS_CONTEXT    0x10000000
#define SETUP_LOG_CONTEXTMASK   0x0000ffff

//
// pass this flag to WriteLogEntry to have the entry stored in a buffer,
// to be spit out the next time the flag is *not* specified
//
#define SETUP_LOG_BUFFER    0x20000000

//
// pass this flag to registry to have output sent to debugger
//
#define SETUP_LOG_DEBUGOUT  0x80000000
//
// pass this flag to registry to have entries simply appended to the log
//
#define SETUP_LOG_SIMPLE    0x40000000
//
// pass this flag to registry to speed up logging
//
#define SETUP_LOG_NOFLUSH   0x20000000
//
// pass this flag to registry to indicate we want to always log SETUP_LOG_ISCONTEXT
//
#define SETUP_LOG_ALL_CONTEXT 0x10000000
//
// pass this flag to registry to indicate we always want to log timestamp
//
#define SETUP_LOG_TIMESTAMP 0x08000000
//
// for validating registry log value
//
#define SETUP_LOG_VALIDREGBITS (SETUP_LOG_DEBUGOUT|SETUP_LOG_SIMPLE|SETUP_LOG_NOFLUSH|SETUP_LOG_ALL_CONTEXT|SETUP_LOG_TIMESTAMP|DRIVER_LOG_LEVELMASK|SETUP_LOG_LEVELMASK)
//
// for validating non-context log value
//
#define SETUP_LOG_VALIDLOGBITS (SETUP_LOG_DEBUGOUT|SETUP_LOG_BUFFER|DRIVER_LOG_LEVELMASK|SETUP_LOG_LEVELMASK)
//
// for validating context log value
//
#define SETUP_LOG_VALIDCONTEXTBITS (SETUP_LOG_IS_CONTEXT | SETUP_LOG_CONTEXTMASK)


//
// timeouts when waiting for log acquired by another process
//
#define MAX_LOG_INTERVAL        (1000)       // 1s
#define MAX_LOG_WAIT            (10 * MAX_LOG_INTERVAL)


//
// This is the structure that holds all of the data required to persist logging
// information. It is not to be confused with the SETUPLOG_CONTEXT struct that
// is used elsewhere in setup.
//
typedef struct _SETUP_LOG_CONTEXT {
    //
    // Pointer to allocated name of section to be used.
    // If NULL, a section name will be generated on first use.
    //
    PTSTR       SectionName;

    //
    // Multiple structures may simultaneously have pointers to
    // this struct, so a ref count is needed. CreateLogContext()
    // will set this to 1, and DeleteLogContext() will decrement
    // this until it reaches 0 (at which point the structure is
    // actually freed).
    //
    UINT        RefCount;

    //
    // This is the number of entries that have been logged in this
    // context. If timestamp is used for the section name, this will
    // allow us to use the time of the first error, rather than the
    // time the log context was created.
    //
    UINT        LoggedEntries;

    //
    // These fields are for implementation of
    // AllocLogSlot and ReleaseLogSlot functions
    // ContextInfo is a list of strings indexable via SETUP_LOG_CONTEXTMASK
    // bits of a context slot returned by AllocLogSlot (ie, the slot)
    // it is also enumeratable via the link list headed by ContextFirstUsed
    // ContextFirstUsed points to first slot currently in use (bottom of stack)
    // ContextIndexes[ContextFirstUsed] points to next and so on
    // ContextLastUnused points to last slot that was released
    // -1 is used as end of list value
    // An entry may disappear in the middle of the stack if the context is used in
    // more than one thread
    //
    PTSTR       *ContextInfo;       // pointer to array of strings
    int         *ContextIndexes;    // by mark, is either index to ContextInfo, or to next unused mark
    int         ContextLastUnused;  // LIFO linked list of unused marks
    int         ContextBufferSize;  // items allocated for
    int         ContextFirstUsed;   // FIFO linked list of used marks
    int         ContextFirstAuto;   // FIFO linked list of auto-release used marks

    //
    // Sometimes multiple strings need to be logged as one entry, which
    // requires making multiple calls to WriteLogEntry. If SETUP_LOG_BUFFER
    // is specified, the text will be accumulated in the buffer until such
    // time as SETUP_LOG_BUFFER is not specified, in which case the
    // contents of Buffer is output together with the current string.
    //
    PTSTR       Buffer;

    //
    // In case multiple threads access this struct simultaneously,
    // access to ContextInfo must be serialized. Also, we
    // don't want this to be deleted while another thread is using it.
    //

} SETUP_LOG_CONTEXT, *PSETUP_LOG_CONTEXT;

//
// TLS data used by logging
//
typedef struct _SETUP_LOG_TLS {
    //
    // stack of context's
    //
    PSETUP_LOG_CONTEXT  ThreadLogContext;

} SETUP_LOG_TLS, *PSETUP_LOG_TLS;

//
// Convenient macro for determining whether a deletion failure should be
// considered an error or a verbose entry.
//
#define DEL_ERR_LOG_LEVEL(Err) ((((Err) == ERROR_FILE_NOT_FOUND) || ((Err) == ERROR_PATH_NOT_FOUND)) \
                                ? SETUP_LOG_VERBOSE : SETUP_LOG_ERROR)

DWORD
CreateLogContext(
    IN PCTSTR SectionName,              OPTIONAL
    IN  BOOL UseDefault,
    OUT PSETUP_LOG_CONTEXT *LogContext
    );

VOID
DeleteLogContext(
    IN PSETUP_LOG_CONTEXT LogContext
    );

DWORD
RefLogContext(  // increment reference count
    IN PSETUP_LOG_CONTEXT LogContext
    );

VOID
SetLogSectionName(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR SectionName
    );

DWORD
InheritLogContext(
    IN TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN PSETUP_LOG_CONTEXT Source,
    OUT PSETUP_LOG_CONTEXT *Dest
    );

DWORD
ShareLogContext(
    IN OUT PSETUP_LOG_CONTEXT *Primary,
    IN OUT PSETUP_LOG_CONTEXT *Secondary
    );

DWORD
pSetupWriteLogEntry(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD MessageId,
    IN PCTSTR MessageStr,               OPTIONAL
    ...                                 OPTIONAL
    );

VOID
pSetupWriteLogError(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD Error
    );

#define WriteLogEntry pSetupWriteLogEntry
#define WriteLogError pSetupWriteLogError

DWORD
MakeUniqueName(
    IN  PCTSTR Component,        OPTIONAL
    OUT PTSTR * UniqueString
    );

DWORD
AllocLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN BOOL               AutoRelease
    );

DWORD
AllocLogInfoSlotOrLevel(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN DWORD              Level,
    IN BOOL               AutoRelease
    );

VOID
ReleaseLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    DWORD Slot
    );

BOOL
InitializeContextLogging(
    IN BOOL Attach
    );

BOOL
ContextLoggingTlsInit(
    IN BOOL Init
    );

BOOL
SetThreadLogContext(
    IN PSETUP_LOG_CONTEXT LogContext,
    OUT PSETUP_LOG_CONTEXT *PrevContext   OPTIONAL
    );

PSETUP_LOG_CONTEXT
GetThreadLogContext(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\childreg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    childreg.h

Abstract:

    Shared between setupapi.dll and wowreg32.exe

Author:

    Jamie Hunter (jamiehun) May-25-2000

--*/

//
// definition of shared memory region for wow surragate dll registration
//
typedef struct _WOW_IPC_REGION_TOSURRAGATE {
    WCHAR               FullPath[MAX_PATH];
    WCHAR               Argument[MAX_PATH];
    UINT                RegType;
    BOOL                Register; // or unregister
} WOW_IPC_REGION_TOSURRAGATE, *PWOW_IPC_REGION_TOSURRAGATE;

//
// definition of shared memory region for wow surragate dll registration
//
typedef struct _WOW_IPC_REGION_FROMSURRAGATE {
    DWORD               Win32Error;
    DWORD               FailureCode;
} WOW_IPC_REGION_FROMSURRAGATE, *PWOW_IPC_REGION_FROMSURRAGATE;

//
// this should be the max of WOW_IPC_REGION_TOSURRAGATE,WOW_IPC_REGION_FROMSURRAGATE
//
#define WOW_IPC_REGION_SIZE  sizeof(WOW_IPC_REGION_TOSURRAGATE)

#ifdef _WIN64
#define SURRAGATE_PROCESSNAME                   L"%SystemRoot%\\syswow64\\WOWReg32.exe"
#else
#define SURRAGATE_PROCESSNAME                   L"%SystemRoot%\\system32\\WOWReg32.exe"
#endif
#define SURRAGATE_REGIONNAME_SWITCH             L"/RegionName"
#define SURRAGATE_SIGNALREADY_SWITCH            L"/SignalReady"
#define SURRAGATE_SIGNALCOMPLETE_SWITCH         L"/SignalComplete"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\backup.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    backup.c

Abstract:

    Routines to control backup during install process
    And restore of an old install process

Author:

    Jamie Hunter (jamiehun) 13-Jan-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
pSetupExemptFileFromProtection(
    IN  PCTSTR             FileName,
    IN  DWORD              FileChangeFlags,
    IN  PSETUP_LOG_CONTEXT LogContext,      OPTIONAL
    OUT PDWORD             QueueNodeFlags   OPTIONAL
    );


//
// ==========================================================
//

DWORD
pSetupQueueBackupCopy(
    IN HSPFILEQ QueueHandle,
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,       OPTIONAL
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,       OPTIONAL
    IN LONG   BackupFilename
    )

/*++

Routine Description:

    Place a backup copy operation on a setup file queue.
    Target is to be backed up at Backup location

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    TargetRootPath  - Supplies the source directory, eg C:\WINNT\

    TargetSubDir    - Supplies the optional sub-directory (eg WINNT if RootPath = c:\ )

    TargetFilename - supplies the filename part of the file to be copied.

    BackupRootPath - supplies the directory where the file is to be copied.

    BackupSubDir   - supplies the optional sub-directory

    BackupFilename - supplies the name of the target file.

Return Value:

    same value as GetLastError() indicating error, or NO_ERROR

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode,TempNode;
    int Size;
    DWORD Err;
    PVOID StringTable;
    PTSTR FullRootName;

    Queue = (PSP_FILE_QUEUE)QueueHandle;
    Err = NO_ERROR;

    try {
        StringTable = Queue->StringTable;  // used for strings in source queue
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if (!QueueNode) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // Operation is backup.
    //
    QueueNode->Operation = FILEOP_BACKUP;
    QueueNode->InternalFlags = 0;

    QueueNode->SourceRootPath = BackupRootPath;
    QueueNode->SourcePath = BackupSubDir;
    QueueNode->SourceFilename = BackupFilename;

    // if target has a sub-dir, we have to combine root and subdir into one string
    if (TargetSubDir != -1) {

        FullRootName = pSetupFormFullPath(
                                            StringTable,
                                            TargetRootPath,
                                            TargetSubDir,
                                            -1);

        if (!FullRootName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }

        TargetRootPath = pSetupStringTableAddString(StringTable,
                                                FullRootName,
                                                STRTAB_CASE_SENSITIVE
                                                );
        MyFree(FullRootName);

        if (TargetRootPath == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }

        // now combined into TargetRootPath
        TargetSubDir = -1;

    }
    QueueNode->TargetDirectory = TargetRootPath;
    QueueNode->TargetFilename = TargetFilename;

    QueueNode->Next = NULL;

    //
    // Link the node onto the end of the backup queue
    //

    if (Queue->BackupQueue) {
        for (TempNode = Queue->BackupQueue; TempNode->Next; TempNode=TempNode->Next) /* blank */ ;
        TempNode->Next = QueueNode;
    } else {
        Queue->BackupQueue = QueueNode;
    }

    Queue->BackupNodeCount++;

    Err = NO_ERROR;
    goto clean0;

clean1:
    MyFree(QueueNode);
clean0:
    SetLastError(Err);
    return Err;
}


//
// ==========================================================
//

BOOL
pSetupGetFullBackupPath(
    OUT     PTSTR       FullPath,
    IN      PCTSTR      Path,           OPTIONAL
    IN      UINT        TargetBufferSize,
    OUT     PUINT       RequiredSize    OPTIONAL
    )
/*++

Routine Description:

    This routine takes a potentially relative path
    and concatenates it to the base path

Arguments:

    FullPath    - Destination for full path
    Path        - Relative source path to backup directory if specified.
                    If NULL, generates a temporary path
    TargetBufferSize - Size of buffer (characters)
    RequiredSize - Filled in with size required to contain full path

Return Value:

    If the function succeeds, return TRUE
    If there was an error, return FALSE

--*/
{
    UINT PathLen;
    LPCTSTR Base = WindowsBackupDirectory;

    if(!Path) {
        //
        // temporary location
        //
        Path = SP_BACKUP_OLDFILES;
        Base = WindowsDirectory;
    }

    //
    // Backup directory is stored in "WindowsBackupDirectory" for permanent backups
    // and WindowsDirectory\SP_BACKUP_OLDFILES for temporary backups
    //

    PathLen = lstrlen(Base);

    if ( FullPath == NULL || TargetBufferSize <= PathLen ) {
        // just calculate required path len
        FullPath = (PTSTR) Base;
        TargetBufferSize = 0;
    } else {
        // calculate and copy
        lstrcpy(FullPath, Base);
    }
    return pSetupConcatenatePaths(FullPath, Path, TargetBufferSize, RequiredSize);
}

//
// ==========================================================
//

DWORD
pSetupBackupCopyString(
    IN PVOID            DestStringTable,
    OUT PLONG           DestStringID,
    IN PVOID            SrcStringTable,
    IN LONG             SrcStringID
    )
/*++

Routine Description:

    Gets a string from source string table, adds it to destination string table with new ID.

Arguments:

    DestStringTable     - Where string has to go
    DestStringID        - pointer, set to string ID in respect to DestStringTable
    SrcStringTable      - Where string is coming from
    StringID            - string ID in respect to SrcStringTable

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    DWORD Err = NO_ERROR;
    LONG DestID;
    PTSTR String;

    if (DestStringID == NULL) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if (SrcStringID == -1) {
        // "not supplied"
        DestID = -1;
    } else {
        // actually need to copy

        String = pSetupStringTableStringFromId( SrcStringTable, SrcStringID );
        if (String == NULL) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        DestID = pSetupStringTableAddString( DestStringTable, String, STRTAB_CASE_SENSITIVE );
        if (DestID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        *DestStringID = DestID;
    }

    Err = NO_ERROR;

clean0:
    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupGetTargetByPath(
    IN HSPFILEQ         QueueHandle,
    IN PVOID            PathStringTable,    OPTIONAL
    IN PCTSTR           TargetPath,         OPTIONAL
    IN LONG             TargetRoot,
    IN LONG             TargetSubDir,       OPTIONAL
    IN LONG             TargetFilename,
    OUT PLONG           TableID,            OPTIONAL
    OUT PSP_TARGET_ENT  TargetInfo
    )
/*++

Routine Description:

    Given a pathname, obtains/creates target info

Arguments:

    QueueHandle         - Queue we're looking at
    PathStringTable     - String table used for the Target Root/SubDir/Filename strings, NULL if same as QueueHandle's
    TargetPath          - if given, is the full path, previously generated
    TargetRoot          - root portion, eg c:\winnt
    TargetSubDir        - optional sub-directory portion, -1 if not provided
    TargetFilename      - filename , eg readme.txt
    TableID             - filled with ID for future use in pSetupBackupGetTargetByID or pSetupBackupSetTargetByID
    TargetInfo          - Filled with information about target

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    LONG PathID;
    TCHAR PathBuffer[MAX_PATH];
    PTSTR TmpPtr;
    PVOID LookupTable = NULL;
    PVOID QueueStringTable = NULL;
    PTSTR FullTargetPath = NULL;
    DWORD Err = NO_ERROR;
    PSP_FILE_QUEUE Queue;
    DWORD RequiredSize;

    Queue = (PSP_FILE_QUEUE)QueueHandle;
    try {
        LookupTable = Queue->TargetLookupTable;  // used for path lookup in source queue
        QueueStringTable = Queue->StringTable;  // used for strings in source queue
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if (PathStringTable == NULL) {
        // default string table is that of queue's
        PathStringTable = QueueStringTable;
    }

    if (TargetPath == NULL) {
        // obtain the complete target path and filename (Duplicated String)
        FullTargetPath = pSetupFormFullPath(
                                            PathStringTable,
                                            TargetRoot,
                                            TargetSubDir,
                                            TargetFilename);

        if (!FullTargetPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        TargetPath = FullTargetPath;
    }

    //
    // normalize path
    //
    RequiredSize = GetFullPathName(TargetPath,
                                   SIZECHARS(PathBuffer),
                                   PathBuffer,
                                   &TmpPtr
                                  );
    //
    // This call should always succeed.
    //
    MYASSERT((RequiredSize > 0) &&
             (RequiredSize < SIZECHARS(PathBuffer)) // RequiredSize doesn't include terminating NULL char
            );

    //
    // Even though we asserted that this should not be the case above,
    // we should handle failure in case asserts are turned off.
    //
    if(!RequiredSize) {
        Err = GetLastError();
        goto clean0;
    } else if(RequiredSize >= SIZECHARS(PathBuffer)) {
        Err = ERROR_BUFFER_OVERFLOW;
        goto clean0;
    }

    PathID = pSetupStringTableLookUpStringEx(LookupTable, PathBuffer, 0, TargetInfo, sizeof(SP_TARGET_ENT));
    if (PathID == -1) {
        ZeroMemory(TargetInfo, sizeof(SP_TARGET_ENT));
        if (PathStringTable != QueueStringTable) {
            // need to add entries to Queue's string table if we're using another

            Err = pSetupBackupCopyString(QueueStringTable, &TargetRoot, PathStringTable, TargetRoot);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            Err = pSetupBackupCopyString(QueueStringTable, &TargetSubDir, PathStringTable, TargetSubDir);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            Err = pSetupBackupCopyString(QueueStringTable, &TargetFilename, PathStringTable, TargetFilename);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            PathStringTable = QueueStringTable;
        }
        TargetInfo->TargetRoot = TargetRoot;
        TargetInfo->TargetSubDir = TargetSubDir;
        TargetInfo->TargetFilename = TargetFilename;
        TargetInfo->BackupRoot = -1;
        TargetInfo->BackupSubDir = -1;
        TargetInfo->BackupFilename = -1;
        TargetInfo->NewTargetFilename = -1;
        TargetInfo->InternalFlags = 0;

        PathID = pSetupStringTableAddStringEx(LookupTable, PathBuffer, 0, TargetInfo, sizeof(SP_TARGET_ENT));
        if (PathID == -1)
        {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }

    if (TableID != NULL) {
        *TableID = PathID;
    }

    Err = NO_ERROR;

clean0:
    if (FullTargetPath != NULL) {
        MyFree(FullTargetPath);
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupGetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    OUT PSP_TARGET_ENT  TargetInfo
    )
/*++

Routine Description:

    Given an entry in the LookupTable, gets info

Arguments:

    QueueHandle         - Queue we're looking at
    TableID             - ID relating to string entry we've found (via pSetupBackupGetTargetByPath)
    TargetInfo          - Filled with information about target

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    PVOID LookupTable = NULL;
    DWORD Err = NO_ERROR;
    PSP_FILE_QUEUE Queue;

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    try {
        LookupTable = Queue->TargetLookupTable;  // used for strings in source queue
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if (pSetupStringTableGetExtraData(LookupTable, TableID, TargetInfo, sizeof(SP_TARGET_ENT)) == FALSE) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    Err = NO_ERROR;

clean0:
    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupSetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    IN PSP_TARGET_ENT   TargetInfo
    )
/*++

Routine Description:

    Given an entry in the LookupTable, sets info

Arguments:

    QueueHandle         - Queue we're looking at
    TableID             - ID relating to string entry we've found (via pSetupBackupGetTargetByPath)
    TargetInfo          - Filled with information about target

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    PVOID LookupTable = NULL;
    DWORD Err = NO_ERROR;
    PSP_FILE_QUEUE Queue;

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    try {
        LookupTable = Queue->TargetLookupTable;  // used for strings in source queue
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if ( pSetupStringTableSetExtraData(LookupTable, TableID, TargetInfo, sizeof(SP_TARGET_ENT)) == FALSE) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    Err = NO_ERROR;

clean0:
    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupGetReinstallKeyStrings(
    IN PSP_FILE_QUEUE   BackupFileQueue,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PCTSTR           DeviceID
    )
/*++

Routine Description:

    This routine will save the values needed to create the Reinstall backup key
    in the string table of the backup queue. We save these strings in the string
    table before the new drivers are installed and then create the registry key
    after the new device is installed. It is done this way because the Rollback
    UI code will look for the Reinstall subkeys, so we want to make sure that
    we have successfully backed-up all of the needed files before we create
    this Reinstall subkey.

Arguments:

    BackupFileQueue     -
    DeviceInfoSet       -
    DeviceInfoData      -
    DeviceID            -

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/
{
    DWORD Err = NO_ERROR;
    HKEY hKeyDevReg = INVALID_HANDLE_VALUE;
    DWORD RegCreated, cbData;
    TCHAR Buffer[MAX_PATH];

    try {

        //
        // Get the DeviceDesc of the device and fill in the BackupDevDescID and
        // BackupDisplayNameID values in the string table. This value is
        // required since it is needed during a rollback for us to choose the
        // exact driver that was installed from the specific INF.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              SPDRP_DEVICEDESC,
                                              NULL,
                                              (PBYTE)Buffer,
                                              sizeof(Buffer),
                                              NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        BackupFileQueue->BackupDeviceDescID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupDeviceDescID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // At this point we will also set the BackupDisplayNameID value just in
        // case the device does not have a FriendlyName.
        //
        BackupFileQueue->BackupDisplayNameID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupDisplayNameID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // We will try and get the device's FriendlyName. If it has one then we
        // will set the BackupDisplayNameID to this value, otherwise DisplayName
        // will just be the DeviceDesc.
        //
        if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             NULL,
                                             (PBYTE)Buffer,
                                             sizeof(Buffer),
                                             NULL)) {

            BackupFileQueue->BackupDisplayNameID =
                pSetupStringTableAddString(BackupFileQueue->StringTable,
                                           Buffer,
                                           STRTAB_CASE_SENSITIVE);

            if (BackupFileQueue->BackupDisplayNameID == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        }

        //
        // Set the BackupMfgID value.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              SPDRP_MFG,
                                              NULL,
                                              (PBYTE)Buffer,
                                              sizeof(Buffer),
                                              NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        BackupFileQueue->BackupMfgID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupMfgID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Set the BackupProviderNameID value.
        //
        hKeyDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ
                                          );

        if (hKeyDevReg == INVALID_HANDLE_VALUE) {
            goto clean0;
        }

        cbData = sizeof(Buffer);
        Err = RegQueryValueEx(hKeyDevReg,
                              pszProviderName,
                              NULL,
                              NULL,
                              (PBYTE)Buffer,
                              &cbData
                              );

        RegCloseKey(hKeyDevReg);

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        BackupFileQueue->BackupProviderNameID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupProviderNameID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Set the DeviceInstanceIds value. This is a multi-sz value so make
        // sure we put a double NULL on the end.
        //
        BackupFileQueue->BackupDeviceInstanceID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       (PTSTR)DeviceID,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupDeviceInstanceID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }


clean0: ;   // Nothing to do.


    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupCreateReinstallKey(
    IN PSP_FILE_QUEUE   BackupFileQueue
    )
/*++

Routine Description:

    This routine will create the needed reinstall registry key so that these
    drivers can be later rolled back. The reinstall registry key lives in the
    following location:

        HKLM\Software\Microsoft\Windows\CurrentVersion\Reinstall\xxxx

    where xxxx is the BackupInstanceId.

    Under this key we will store the following information

        DisplayName         - This is the name that is displayed in any UI of
                              drivers that can be reinstalled. This is normally
                              just the device description.
        DeviceInstanceIds   - Multi-sz string of the device instance Ids of
                              every device that is using this backup. Setupapi
                              only sets the first device instance Id. Newdev
                              can append other device instance Ids to this list
                              if it is doing multiple device installs (in the
                              case of UpdateDriverForPlugAndPlayDevices or
                              InstallWindowsUpdateDriver).
        ReinstallString     - The full backup path including the INF file
        DeviceDesc          - The DeviceDesc of the driver that was installed.
                              This is needed to make sure we pick the identical
                              driver during a roll back.
        Mfg                 - The Mfg of the driver that was installed.
                              This is needed to make sure we pick the identical
                              driver during a roll back.
        ProviderName        - The ProviderName of the driver that was installed.
                              This is needed to make sure we pick the identical
                              driver during a roll back.


Arguments:

    BackupFileQueue         -

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/
{
    DWORD Err = NO_ERROR;
    HKEY hKeyReinstall = INVALID_HANDLE_VALUE;
    HKEY hKeyReinstallInstance = INVALID_HANDLE_VALUE;
    DWORD RegCreated, cbData;
    TCHAR Buffer[MAX_PATH];
    BOOL b;

    try {

        //
        // Make sure the BackupInfID is valid. If it is -1 then something went
        // wrong during the backup and so we do not want to create the Reinstall
        // instance subkey.
        //
        if (BackupFileQueue->BackupInfID == -1) {

            Err = ERROR_NO_BACKUP;
            goto clean0;
        }

        //
        // Open/Create the Reinstall registry key. Call RegCreateKeyEx in case
        // this is the first time a backup is being performed and this key
        // does not yet exist.
        //
        Err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             pszReinstallPath,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKeyReinstall,
                             &RegCreated
                             );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Create the Reinstall instance key under the Reinstall key.
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupInstanceID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegCreateKeyEx(hKeyReinstall,
                             Buffer,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKeyReinstallInstance,
                             &RegCreated
                             );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the DeviceDesc to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupDeviceDescID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszDeviceDesc,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the DisplayName to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupDisplayNameID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        RegSetValueEx(hKeyReinstallInstance,
                      pszReinstallDisplayName,
                       0,
                       REG_SZ,
                       (PBYTE)Buffer,
                       (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                       );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the Mfg to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupMfgID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszMfg,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the ProviderName to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupProviderNameID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszProviderName,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Set the DeviceInstanceIds value. This is a multi-sz value so make
        // sure we put a double NULL on the end.
        //
        //
        // Add the Mfg to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        ZeroMemory(Buffer, sizeof(Buffer));
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupDeviceInstanceID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszReinstallDeviceInstanceIds,
                            0,
                            REG_MULTI_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 2) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the ReinstallString to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupInfID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszReinstallString,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          Err = ERROR_INVALID_PARAMETER;
    }

    if (hKeyReinstallInstance != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyReinstallInstance);
    }

    if (hKeyReinstall != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyReinstall);
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupAppendFiles(
    IN HSPFILEQ         TargetQueueHandle,
    IN PCTSTR           BackupSubDir,
    IN DWORD            BackupFlags,
    IN HSPFILEQ         SourceQueueHandle OPTIONAL
    )
/*++

Routine Description:

    This routine will take a list of files from SourceQueueHandle Copy sub-queue's
    These files will appear in the Target Queue's target cache
    And may be placed into the Target Backup Queue
    Typically the copy queue is entries of..
        <oldsrc-root>\<oldsrc-sub>\<oldsrc-name> copied to
        <olddest-path>\<olddest-name>

Arguments:

    TargetQueueHandle   - Where Backups are queued to
    BackupSubDir        - Directory to backup to, relative to backup root
    BackupFlags         - How backup should occur
    SourceQueueHandle   - Handle that has a series of copy operations (backup hint)
                          created, say, by pretending to do the re-install
                          If not specified, only flags are passed

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/
{
    TCHAR BackupPath[MAX_PATH];
    PSP_FILE_QUEUE SourceQueue = NULL;
    PSP_FILE_QUEUE TargetQueue = NULL;
    PSP_FILE_QUEUE_NODE QueueNode = NULL;
    PSOURCE_MEDIA_INFO SourceMediaInfo = NULL;
    BOOL b = TRUE;
    PVOID SourceStringTable = NULL;
    PVOID TargetStringTable = NULL;
    LONG BackupRootID = -1;
    DWORD Err = NO_ERROR;
    LONG PathID = -1;
    SP_TARGET_ENT TargetInfo;

    SourceQueue = (PSP_FILE_QUEUE)SourceQueueHandle; // optional
    TargetQueue = (PSP_FILE_QUEUE)TargetQueueHandle;

    b=TRUE; // set if we can skip this routine
    try {

        TargetStringTable = TargetQueue->StringTable;  // used for strings in target queue

        if (SourceQueue == NULL) {
            b = TRUE; // nothing to do
        } else {
            SourceStringTable = SourceQueue->StringTable;  // used for strings in source queue
            b = (!SourceQueue->CopyNodeCount);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    // these are backup flags to be passed into the queue
    if (BackupFlags & SP_BKFLG_CALLBACK) {
        TargetQueue->Flags |= FQF_BACKUP_AWARE;
    }

    if (b) {
        // nothing to do
        goto clean0;
    }

    //
    // get full directory path of backup - this appears as the "dest" for any backup entries
    //
    if ( BackupSubDir == NULL ) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if ( pSetupGetFullBackupPath(BackupPath, BackupSubDir, MAX_PATH,NULL) == FALSE ) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    //
    // Target will often use this, so we create the ID now instead of later
    //
    BackupRootID = pSetupStringTableAddString(TargetStringTable,
                                              BackupPath,
                                              STRTAB_CASE_SENSITIVE);
    if (BackupRootID == -1) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // CopyQueue is split over a number of media's
    // we're not (currently) bothered about media
    // iterate through all the copy sub-queue's
    // and (1) add them to the target lookup table
    // (2) if wanted, add them into the backup queue

    for (SourceMediaInfo=SourceQueue->SourceMediaList; SourceMediaInfo!=NULL ; SourceMediaInfo=SourceMediaInfo->Next) {
        if (!SourceMediaInfo->CopyNodeCount) {
            continue;
        }
        MYASSERT(SourceMediaInfo->CopyQueue);

        for (QueueNode = SourceMediaInfo->CopyQueue; QueueNode!=NULL; QueueNode = QueueNode->Next) {
            // for each "Copy"
            // we want information about the destination path
            //

            Err = pSetupBackupGetTargetByPath(TargetQueueHandle,
                                                    SourceStringTable,
                                                    NULL, // precalculated string
                                                    QueueNode->TargetDirectory,
                                                    -1,
                                                    QueueNode->TargetFilename,
                                                    &PathID,
                                                    &TargetInfo);
            if (Err != NO_ERROR) {
                goto clean0;
            }

            // we now have a created (or obtained) TargetInfo, and PathID
            // provide a source name for backup
            TargetInfo.BackupRoot = BackupRootID;
            Err = pSetupBackupCopyString(TargetStringTable, &TargetInfo.BackupSubDir, SourceStringTable, QueueNode->SourcePath);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            Err = pSetupBackupCopyString(TargetStringTable, &TargetInfo.BackupFilename, SourceStringTable, QueueNode->SourceFilename);
            if (Err != NO_ERROR) {
                goto clean0;
            }

            if ((BackupFlags & SP_BKFLG_LATEBACKUP) == FALSE) {
                // we need to add this item to the backup queue
                Err = pSetupQueueBackupCopy(TargetQueueHandle,
                                      // source
                                      TargetInfo.TargetRoot,
                                      TargetInfo.TargetSubDir,
                                      TargetInfo.TargetFilename,
                                      TargetInfo.BackupRoot,
                                      TargetInfo.BackupSubDir,
                                      TargetInfo.BackupFilename);

                if (Err != NO_ERROR) {
                    goto clean0;
                }
                // flag that we've added it to the pre-copy backup sub-queue
                TargetInfo.InternalFlags |= SP_TEFLG_BACKUPQUEUE;
            }

            // any backups should go to this specified directory
            TargetInfo.InternalFlags |= SP_TEFLG_ORIGNAME;

            Err = pSetupBackupSetTargetByID(TargetQueueHandle, PathID, &TargetInfo);
            if (Err != NO_ERROR) {
                goto clean0;
            }

        }
    }

    Err = NO_ERROR;

clean0:

    SetLastError(Err);
    return (Err);
}

//
// ==========================================================
//

DWORD
pSetupBackupFile(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR TargetPath,
    IN PCTSTR BackupPath,
    IN LONG   TargetID,         OPTIONAL
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,
    IN LONG   BackupFilename,
    OUT BOOL *InUseFlag
    )
/*++

Routine Description:

    If BackupFilename not supplied, it is obtained/created
    Will either
    1) copy a file to the backup directory, or
    2) queue that a file is backed up on reboot
    The latter occurs if the file was locked.

Arguments:

HSPFILEQ    - QueueHandle   - specifies Queue
LONG        - TargetID      - if specified (not -1), use for target
LONG        - TargetRootPath - used if TargetID == -1
LONG        - TargetSubDir - used if TargetID == -1
LONG        - TargetFilename - used if TargetID == -1
LONG        - BackupRootPath - alternate root (valid if BackupFilename != -1)
LONG        - BackupSubDir - alternate directory (valid if BackupFilename != -1)
LONG        - BackupFilename - alternate filename

Return Value:

    If the function succeeds, return value is TRUE
    If the function fails, return value is FALSE

--*/
{
    PSP_FILE_QUEUE Queue = NULL;
    PVOID StringTable = NULL;
    PVOID LookupTable = NULL;
    DWORD Err = NO_ERROR;
    SP_TARGET_ENT TargetInfo;
    PTSTR FullTargetPath = NULL;
    PTSTR FullBackupPath = NULL;
    BOOL InUse = FALSE;
    PTSTR TempNamePtr = NULL, DirTruncPos;
    TCHAR TempPath[MAX_PATH];
    TCHAR TempFilename[MAX_PATH];
    TCHAR ParsedPath[MAX_PATH];
    UINT OldMode;
    LONG NewTargetFilename;
    BOOL DoRename = FALSE;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    try {
        StringTable = Queue->StringTable;  // used for strings in source queue
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    if(TargetPath == NULL && TargetID == -1) {

        if (TargetRootPath == -1 || TargetFilename == -1) {
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        // complete target path

        FullTargetPath = pSetupFormFullPath(
                                           StringTable,
                                           TargetRootPath,
                                           TargetSubDir,
                                           TargetFilename
                                           );

        if (!FullTargetPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        TargetPath = FullTargetPath;

    }

    if (TargetID == -1) {
        Err = pSetupBackupGetTargetByPath(QueueHandle,
                                                NULL, // string table
                                                TargetPath, // precalculated string
                                                TargetRootPath,
                                                TargetSubDir,
                                                TargetFilename,
                                                &TargetID,
                                                &TargetInfo);
    } else {
        Err = pSetupBackupGetTargetByID(QueueHandle,
                                                TargetID,
                                                &TargetInfo);
    }

    if(Err != NO_ERROR) {
        goto clean0;
    }

    //
    // if we're not interested in backing up (global flag) we can skip
    // but it's only safe to do so if we'd copy & then later throw the copy away on success
    // note that if FQF_DEVICE_BACKUP is set, we'll always backup
    //
    if (((TargetInfo.InternalFlags & SP_TEFLG_RENAMEEXISTING) == 0)
         && ((Queue->Flags & FQF_DEVICE_BACKUP)==0)
         && ((GlobalSetupFlags & PSPGF_NO_BACKUP)!=0)) {

        Err = NO_ERROR;
        goto clean0;
    }
    //
    // Figure out whether we've been asked to rename the existing file to a
    // temp name in the same directory, but haven't yet done so.
    //
    DoRename = ((TargetInfo.InternalFlags & (SP_TEFLG_RENAMEEXISTING | SP_TEFLG_MOVED)) == SP_TEFLG_RENAMEEXISTING);

    if(BackupFilename == -1) {
        //
        // non-specific backup
        //
        if((TargetInfo.InternalFlags & SP_TEFLG_SAVED) && !DoRename) {
            //
            // Already backed up, and we don't need to rename the existing file.
            // Nothing to do.
            //
            Err = NO_ERROR;
            goto clean0;
        }

        if(TargetInfo.InternalFlags & SP_TEFLG_INUSE) {
            //
            // Previously marked as INUSE, not allowed to change it.  If we
            // were asked to rename the existing file, then we need to return
            // failure, otherwise, we can report success.
            //
            //
            InUse = TRUE;

            Err = DoRename ? ERROR_SHARING_VIOLATION : NO_ERROR;
            goto clean0;
        }

        if(TargetInfo.InternalFlags & SP_TEFLG_ORIGNAME) {
            //
            // original name given, use that
            //
            BackupRootPath = TargetInfo.BackupRoot;
            BackupSubDir = TargetInfo.BackupSubDir;
            BackupFilename = TargetInfo.BackupFilename;
        }

    } else {
        //
        // We should never be called if the file has already been
        // saved.
        //
        MYASSERT(!(TargetInfo.InternalFlags & SP_TEFLG_SAVED));

        //
        // Even if the above assert fires, we should still deal with
        // the case where this occurs.  Also, we should deal with the
        // case where a backup was previously attempted but failed due
        // to the file being in-use.
        //
        if(TargetInfo.InternalFlags & SP_TEFLG_SAVED) {
            //
            // nothing to do, we shouldn't treat this as an actual error
            //
            Err = NO_ERROR;
            goto clean0;
        } else if(TargetInfo.InternalFlags & SP_TEFLG_INUSE) {
            //
            // force the issue of InUse
            //
            InUse = TRUE;

            Err = ERROR_SHARING_VIOLATION;
            goto clean0;
        }

        TargetInfo.BackupRoot = BackupRootPath;
        TargetInfo.BackupSubDir = BackupSubDir;
        TargetInfo.BackupFilename = BackupFilename;
        TargetInfo.InternalFlags |= SP_TEFLG_ORIGNAME;
        TargetInfo.InternalFlags &= ~SP_TEFLG_TEMPNAME;
    }

    if(TargetPath == NULL) {
        //
        // must have looked up using TargetID, use TargetInfo to generate TargetPath
        // complete target path
        //
        FullTargetPath = pSetupFormFullPath(StringTable,
                                            TargetInfo.TargetRoot,
                                            TargetInfo.TargetSubDir,
                                            TargetInfo.TargetFilename
                                           );

        if(!FullTargetPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        TargetPath = FullTargetPath;
    }

    if(DoRename) {
        //
        // We'd better not already have a temp filename stored in our TargetInfo.
        //
        MYASSERT(TargetInfo.NewTargetFilename == -1);

        //
        // First, strip the filename off the path.
        //
        _tcscpy(TempPath, TargetPath);
        TempNamePtr = (PTSTR)pSetupGetFileTitle(TempPath);
        *TempNamePtr = TEXT('\0');

        //
        // Now get a temp filename within that directory...
        //
        if(GetTempFileName(TempPath, TEXT("OLD"), 0, TempFilename) == 0 ) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // ...and store this path's string ID in our TargetInfo
        //
        NewTargetFilename = pSetupStringTableAddString(StringTable,
                                                 TempFilename,
                                                 STRTAB_CASE_SENSITIVE
                                                );

        if(NewTargetFilename == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }

    if(!(TargetInfo.InternalFlags & (SP_TEFLG_ORIGNAME | SP_TEFLG_TEMPNAME))) {
        //
        // If we don't yet have a name to use in backing up this file, then
        // generate one now.  If we are doing a rename, we can use that name.
        //
        if(DoRename) {
            //
            // Make sure that all flags agree on the fact that we need to back
            // up this file.
            //
            MYASSERT(!(TargetInfo.InternalFlags & SP_TEFLG_SAVED));

            //
            // Temp filename was stored in TempFilename buffer above.
            //
            TempNamePtr = (PTSTR)pSetupGetFileTitle(TempFilename);

            BackupFilename = pSetupStringTableAddString(StringTable, TempNamePtr, STRTAB_CASE_SENSITIVE);
            if(BackupFilename == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            DirTruncPos = CharPrev(TempFilename, TempNamePtr);

            //
            // (We know pSetupGetFileTitle will never return a pointer to a path
            // separator character, so the following check is valid.)
            //
            if(*DirTruncPos == TEXT('\\')) {
                //
                // If this is in a root directory (e.g., "A:\"), then we don't want to strip off
                // the trailing backslash.
                //
                if(((DirTruncPos - TempFilename) != 2) || (*CharNext(TempFilename) != TEXT(':'))) {
                    TempNamePtr = DirTruncPos;
                }
            }

            lstrcpyn(TempPath, TempFilename, (int)(TempNamePtr - TempFilename) + 1);

            BackupRootPath = pSetupStringTableAddString(StringTable, TempPath, STRTAB_CASE_SENSITIVE);
            if(BackupRootPath == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

        } else {

            //
            // specify "NULL" as the sub-directory, since all we want is a temporary location
            //
            if(pSetupGetFullBackupPath(TempPath, NULL, MAX_PATH,NULL) == FALSE ) {
                Err = ERROR_INVALID_HANDLE;
                goto clean0;
            }
            _tcscpy(TempFilename,TempPath);

            //
            // Note:  In the code below, we employ a "trick" to get the
            // pSetupMakeSurePathExists API to make sure that a directory
            // exists.  Since we don't yet know the filename (we need to call
            // GetTempFileName against an existing directory to find that out),
            // we just use a dummy placeholder filename ("OLD") so that it can
            // be discarded by the pSetupMakeSurePathExists API.
            //
            if(pSetupConcatenatePaths(TempFilename, TEXT("OLD"), MAX_PATH, NULL) == FALSE ) {
                Err = GetLastError();
                goto clean0;
            }
            pSetupMakeSurePathExists(TempFilename);
            if(GetTempFileName(TempPath, TEXT("OLD"), 0, TempFilename) == 0 ) {
                Err = GetLastError();
                goto clean0;
            }

            TempNamePtr = TempFilename + _tcslen(TempPath) + 1 /* 1 to skip past \ */;
            BackupRootPath = pSetupStringTableAddString( StringTable, TempPath, STRTAB_CASE_SENSITIVE );
            if(BackupRootPath == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
            BackupFilename = pSetupStringTableAddString( StringTable, TempNamePtr, STRTAB_CASE_SENSITIVE );
            if(BackupFilename == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        }

        BackupPath = TempFilename;

        TargetInfo.BackupRoot = BackupRootPath;
        TargetInfo.BackupSubDir = BackupSubDir = -1;
        TargetInfo.BackupFilename = BackupFilename;
        TargetInfo.InternalFlags |= SP_TEFLG_TEMPNAME;

    }


    if(BackupPath == NULL) {
        //
        // make a complete path from this source
        //
        FullBackupPath = pSetupFormFullPath(StringTable,
                                            BackupRootPath,
                                            BackupSubDir,
                                            BackupFilename
                                           );

        if (!FullBackupPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        BackupPath = FullBackupPath;
    }

    //
    // If we need to make a copy of the existing file, do so now.
    //
    if(!DoRename || (TargetInfo.InternalFlags & SP_TEFLG_ORIGNAME)) {

        SetFileAttributes(BackupPath, FILE_ATTRIBUTE_NORMAL);
        pSetupMakeSurePathExists(BackupPath);
        Err = CopyFile(TargetPath, BackupPath, FALSE) ? NO_ERROR : GetLastError();

        if(Err == NO_ERROR) {
            TargetInfo.InternalFlags |= SP_TEFLG_SAVED;
        } else {
            //
            // Delete placeholder file created by GetTempFileName.
            //
            SetFileAttributes(BackupPath, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(BackupPath);

            if(Err == ERROR_SHARING_VIOLATION) {
                //
                // Unless we were also going to attempt a rename, don't
                // consider sharing violations to be errors.
                //
                InUse = TRUE;
                TargetInfo.InternalFlags |= SP_TEFLG_INUSE;
                if(!DoRename) {
                    Err = NO_ERROR;
                }
            }
        }
    }

    //
    // OK, now rename the existing file, if necessary.
    //
    if(DoRename && (Err == NO_ERROR)) {

        if(DoMove(TargetPath, TempFilename)) {

            TargetInfo.InternalFlags |= SP_TEFLG_MOVED;
            TargetInfo.NewTargetFilename = NewTargetFilename;

            //
            // Post a delayed deletion for this temp filename so it'll get
            // cleaned up after reboot.
            //
            if(!PostDelayedMove(Queue, TempFilename, NULL, -1, FALSE)) {
                //
                // Don't abort just because we couldn't schedule a delayed
                // delete.  If this fails, the only bad thing that will happen
                // is a turd will get left over after reboot.
                //
                // We should log an event about this, however.
                //
                Err = GetLastError();

                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_RENAME_EXISTING_DELAYED_DELETE_FAILED,
                              NULL,
                              TargetPath,
                              TempFilename
                             );

                WriteLogError(Queue->LogContext,
                              SETUP_LOG_WARNING,
                              Err
                             );

                Err = NO_ERROR;
            }

        } else {
            Err = GetLastError();
            SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(TempFilename);
            if(Err == ERROR_SHARING_VIOLATION) {
                InUse = TRUE;
                TargetInfo.InternalFlags |= SP_TEFLG_INUSE;
            }
        }
    }

    //
    // update internal info (this call should never fail)
    //
    pSetupBackupSetTargetByID(QueueHandle,
                              TargetID,
                              &TargetInfo
                             );

clean0:

    if (FullTargetPath != NULL) {
        MyFree(FullTargetPath);
    }
    if (FullBackupPath != NULL) {
        MyFree(FullBackupPath);
    }
    if (Err != NO_ERROR) {
        //
        // note the fact that at least one backup error has occurred
        //
        Queue->Flags |= FQF_BACKUP_INCOMPLETE;
    }

clean1:
    SetErrorMode(OldMode);

    SetLastError(Err);

    if(InUseFlag) {
        *InUseFlag = InUse;
    }

    return Err;

}

//
// ==========================================================
//

VOID
pSetupDeleteBackup(
    IN PCTSTR           BackupInstance
    )
/*++

Routine Description:

    This function will delete an entire backup instance. This entails deleting
    the relative BackupInstance out of the registry Reinstall key as well

Arguments:

    BackupInstance - Instance Id of the backup

Return Value:

    If the function succeeds, return value is TRUE
    If the function fails, return value is FALSE

--*/
{
    TCHAR Buffer[MAX_PATH];
    HKEY hKeyReinstall = INVALID_HANDLE_VALUE;

    if (BackupInstance == NULL) {
        return;
    }

    //
    // Delete this instance from the Reinstall key.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszReinstallPath,
                     0,
                     KEY_ALL_ACCESS,
                     &hKeyReinstall
                     ) == ERROR_SUCCESS) {

        RegDeleteKey(hKeyReinstall, BackupInstance);

        RegCloseKey(hKeyReinstall);
    }


    //
    // Now delete the entire backup directory.
    //
    if (pSetupGetFullBackupPath(Buffer, BackupInstance, MAX_PATH, NULL)) {
        pRemoveDirectory(Buffer);
    }
}


//
// ==========================================================
//

DWORD
pSetupGetCurrentlyInstalledDriverNode(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Get driver node that relates to current INF file of device

Arguments:

    DeviceInfoSet
    DeviceInfoData

Return Value:

    Error Status

--*/
{
    DWORD Err;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
        return GetLastError();
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the currently installed
    // driver node in the list, and that it should allow excluded drivers.
    //
    DeviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(!SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Now build a class driver list that just contains the currently installed driver.
    //
    if(!SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, SPDIT_CLASSDRIVER)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // The only driver in the list should be the currently installed driver, if there
    // is a currently installed driver.
    //
    if (!SetupDiEnumDriverInfo(DeviceInfoSet, DeviceInfoData, SPDIT_CLASSDRIVER,
                               0, &DriverInfoData)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Make the currently installed driver the selected driver.
    //
    if(!SetupDiSetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // At this point, we've successfully selected the currently installed driver for the specified
    // device information element.  We're done!
    //

    Err = NO_ERROR;

clean0:

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupGetBackupQueue(
    IN      PCTSTR      DeviceID,
    IN OUT  HSPFILEQ    FileQueue,
    IN      DWORD       BackupFlags
    )
/*++

Routine Description:

    Creates a backup Queue for current device (DeviceID)
    Also makes sure that the INF file is backed up

Arguments:

    DeviceID            String ID of device
    FileQueue           Backup queue is filled with files that need copying
    BackupFlags         Various flags

Return Value:

    Error Status

--*/


{

    //
    // we want to obtain a copy/move list of device associated with DeviceID
    //
    //
    PSP_FILE_QUEUE FileQ = (PSP_FILE_QUEUE)FileQueue;
    HDEVINFO TempInfoSet = (HDEVINFO)INVALID_HANDLE_VALUE;
    HSPFILEQ TempQueueHandle = (HSPFILEQ)INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA TempInfoData;
    SP_DEVINSTALL_PARAMS TempParams;
    TCHAR SubDir[MAX_PATH];
    LONG Instance;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PTSTR szInfFileName = NULL;
    PTSTR szInfFileNameExt = NULL;
    PTSTR BackupPathExt = NULL;
    TCHAR BackupInstance[MAX_PATH];
    TCHAR BackupPath[MAX_PATH];
    TCHAR ReinstallString[MAX_PATH];
    TCHAR OemOrigName[MAX_PATH];
    TCHAR CatBackupPath[MAX_PATH];
    TCHAR CatSourcePath[MAX_PATH];
    DWORD Err;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    int InstanceId;
    DWORD BackupInfID = -1;
    DWORD BackupInstanceID = -1;
    PSP_INF_INFORMATION pInfInformation = NULL;
    DWORD InfInformationSize;
    SP_ORIGINAL_FILE_INFO InfOriginalFileInformation;
    BOOL success;
    PSETUP_LOG_CONTEXT SavedLogContext = NULL;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    BOOL  ChangedThreadLogContext = FALSE;

    //
    // if backup information exists, abort (no flags will be set)
    //
    if(FileQ->BackupInfID != -1) {
        return ERROR_ALREADY_EXISTS;
    }

    //
    // detach any backup related logging from current log section
    // putting it into it's own section
    // this stops confusion when debugging (v)verbose logs
    // and we're going down this path
    //
    CreateLogContext(NULL,FALSE,&LocalLogContext);
    if(LocalLogContext) {
        DWORD LogTag = AllocLogInfoSlot(LocalLogContext,TRUE);
        if(LogTag) {
            WriteLogEntry(LocalLogContext,
                          LogTag,
                          MSG_LOG_DRIVERBACKUP,
                          NULL,
                          DeviceID
                         );
        }

    }
    ChangedThreadLogContext = SetThreadLogContext(LocalLogContext,&SavedLogContext);

    CatBackupPath[0] = 0; // by default, don't bother with a catalog
    CatSourcePath[0] = 0;

    // pretend we're installing old INF
    // this gives us a list of files we need

    TempInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if ( TempInfoSet == (HDEVINFO)INVALID_HANDLE_VALUE ) {
        Err = GetLastError();
        goto clean0;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(TempInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }
    //
    // make sure info-set has our local context
    //
    InheritLogContext(LocalLogContext,&pDeviceInfoSet->InstallParamBlock.LogContext);

    //
    // Open the driver info, related to DeviceID I was given
    //

    TempInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if ( SetupDiOpenDeviceInfo(TempInfoSet ,DeviceID, NULL, 0, &TempInfoData) == FALSE ) {
        Err = GetLastError();
        goto clean0;
    }
    //
    // make sure the temporary element has our backup logging context
    //
    DevInfoElem = FindAssociatedDevInfoElem(TempInfoSet,
                                                 &TempInfoData,
                                                 NULL);
    MYASSERT(DevInfoElem);
    if(DevInfoElem) {
        InheritLogContext(LocalLogContext,&DevInfoElem->InstallParamBlock.LogContext);
    }

    //
    // Get the currently-installed driver node selected for this element.
    //
    if ( pSetupGetCurrentlyInstalledDriverNode(TempInfoSet, &TempInfoData) != NO_ERROR ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Now queue all files to be copied by this driver node into our own file queue.
    // it'll inherit the backup logging context
    //
    TempQueueHandle = SetupOpenFileQueue();

    if ( TempQueueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        //
        // SetupOpenFileQueue modified to return error
        //
        Err = GetLastError();
        goto clean0;
    }

    TempParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(TempInfoSet, &TempInfoData, &TempParams) ) {
        Err = GetLastError();
        goto clean0;
    }

    TempParams.FileQueue = TempQueueHandle;
    TempParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(TempInfoSet, &TempInfoData, &TempParams) ) {
        Err = GetLastError();
        goto clean0;
    }

    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, TempInfoSet, &TempInfoData) ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // We want this backup to be in a unique directory. To do this we just do
    // the standard instance number trick where we enumerate from 0000 to 9999
    // and choose the first number where there isn't a backup directory with
    // that name already created.
    //
    for (InstanceId=0; InstanceId<=9999; InstanceId++) {

        wsprintf(SubDir, TEXT("\\%04d\\%s"), (LONG) InstanceId, (PCTSTR) SP_BACKUP_DRIVERFILES );

        if ( pSetupGetFullBackupPath(BackupPath, SubDir, MAX_PATH, NULL) == FALSE ) {
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // If this backup path does not exist then we have a valid directory.
        //
        if (!FileExists(BackupPath, NULL)) {
            break;
        }
    }

    if (InstanceId <= 9999) {
        //
        // Add string indicating Backup InstanceID to file Queue
        // for later retrieval
        //
        wsprintf(BackupInstance, TEXT("%04d"), (LONG) InstanceId);
        BackupInstanceID = pSetupStringTableAddString(FileQ->StringTable,
                                                  BackupInstance,
                                                  STRTAB_CASE_SENSITIVE);
        if (BackupInstanceID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    } else {
        //
        // If we don't have any free backup directories then we will fail. There
        // should never be this many drivers backed up so this shouldn't be a
        // problem.
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // get the path of the INF file, we will need to back it up
    //
    if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                 &TempInfoData,
                                                 NULL))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                             DevInfoElem->SelectedDriver->InfFileName
                                            );
    if (szInfFileName == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // we want to get the "real" name of the INF - we may have a precompiled inf
    //

    ZeroMemory(&InfOriginalFileInformation, sizeof(InfOriginalFileInformation));

    //
    // if nothing else, use same name as is in the INF directory
    //
    lstrcpy(OemOrigName,pSetupGetFileTitle(szInfFileName));

    //
    // but use the original name if available
    //
    InfInformationSize = 8192;  // I'd rather have this too big and succeed first time, than read the INF twice
    pInfInformation = (PSP_INF_INFORMATION)MyMalloc(InfInformationSize);

    if (pInfInformation != NULL) {
        success = SetupGetInfInformation(szInfFileName,INFINFO_INF_NAME_IS_ABSOLUTE,pInfInformation,InfInformationSize,&InfInformationSize);
        if (!success && GetLastError()==ERROR_INSUFFICIENT_BUFFER) {
            PVOID newbuff = MyRealloc(pInfInformation,InfInformationSize);
            if (!newbuff) {
                MyFree(pInfInformation);
                pInfInformation = NULL;
            } else {
                pInfInformation = (PSP_INF_INFORMATION)newbuff;
                success = SetupGetInfInformation(szInfFileName,INFINFO_INF_NAME_IS_ABSOLUTE,pInfInformation,InfInformationSize,&InfInformationSize);
            }
        }
        if (success) {
            InfOriginalFileInformation.cbSize = sizeof(InfOriginalFileInformation);
            if (SetupQueryInfOriginalFileInformation(pInfInformation,0,NULL,&InfOriginalFileInformation)) {
                if (InfOriginalFileInformation.OriginalInfName[0]) {
                    //
                    // we have a "real" inf name
                    //
                    lstrcpy(OemOrigName,pSetupGetFileTitle(InfOriginalFileInformation.OriginalInfName));
                } else {
                    MYASSERT(InfOriginalFileInformation.OriginalInfName[0]);
                }

                //
                // Don't bother finding out about the INF's catalog if we're in
                // "minimal embedded" mode...
                //
                if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {

                    if (InfOriginalFileInformation.OriginalCatalogName[0]) {

                        TCHAR CurrentCatName[MAX_PATH];

                        //
                        // given that the file is ....\OEMx.INF the catalog is "OEMx.CAT"
                        // we key off OemOrigName (eg mydisk.inf )
                        // and we won't bother copying the catalog if we can't verify the inf
                        //
                        lstrcpy(CurrentCatName,pSetupGetFileTitle(szInfFileName));
                        lstrcpy(_tcsrchr(CurrentCatName, TEXT('.')), pszCatSuffix);

                        //
                        // we have a catalog name
                        // now consider making a copy of the cached catalog into our backup
                        // we get out CatProblem and szCatFileName
                        //
                        // if all seems ok, copy file from szCatFileName to backupdir\OriginalCatalogName
                        //

                        Err = _VerifyFile(
                                  FileQ->LogContext,
                                  &(FileQ->hCatAdmin),
                                  NULL,
                                  CurrentCatName, // eg "OEMx.CAT"
                                  NULL,0,         // we're not verifying against another catalog image
                                  OemOrigName,    // eg "mydisk.inf"
                                  szInfFileName,  // eg "....\OEMx.INF"
                                  NULL,           // return: problem info
                                  NULL,           // return: problem file
                                  FALSE,          // has to be FALSE because we're getting full path
                                  ((PSP_FILE_QUEUE)TempQueueHandle)->ValidationPlatform, // alt platform info
                                  VERIFY_FILE_IGNORE_SELFSIGNED | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK,
                                  CatSourcePath,  // return: catalog file, full path
                                  NULL,           // return: number of catalogs considered
                                  NULL,
                                  NULL
                                 );

                        if (Err == NO_ERROR && CatSourcePath[0]) {
                            //
                            // we have a catalog file of interest to copy
                            //
                            lstrcpy(CatBackupPath,BackupPath);
                            if (!pSetupConcatenatePaths(CatBackupPath, InfOriginalFileInformation.OriginalCatalogName, MAX_PATH, NULL)) {
                                //
                                // non-fatal
                                //
                                CatSourcePath[0]=0;
                                CatBackupPath[0]=0;
                            }
                        }
                    }
                }
            }
        }
        if (pInfInformation != NULL) {
            MyFree(pInfInformation);
            pInfInformation = NULL;
        }
    }
    if ( pSetupConcatenatePaths(BackupPath, OemOrigName, MAX_PATH, NULL) == FALSE ) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    pSetupMakeSurePathExists(BackupPath);
    SetFileAttributes(BackupPath,FILE_ATTRIBUTE_NORMAL);
    Err = CopyFile(szInfFileName, BackupPath ,FALSE) ? NO_ERROR : GetLastError();

    if (Err != NO_ERROR) {
        goto clean0;
    }

    if(CatSourcePath[0] && CatBackupPath[0]) {
        //
        // if we copied Inf file, try to copy catalog file
        // if we don't succeed, don't consider this a fatal error
        //
        SetFileAttributes(CatBackupPath,FILE_ATTRIBUTE_NORMAL);
        CopyFile(CatSourcePath, CatBackupPath ,FALSE);
    }

    //
    // Add string indicating Backup INF location to file Queue
    // for later retrieval
    //

    BackupInfID = pSetupStringTableAddString(FileQ->StringTable,
                                              BackupPath,
                                              STRTAB_CASE_SENSITIVE);
    if (BackupInfID == -1) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // Save the full inf backup path since we need to put it in the registry
    // below.
    //
    lstrcpy(ReinstallString, BackupPath);

    //
    // Also backup the PNF file
    //
    // WARNING: We reuse the szInfFileName and BackupPath variables at this point
    // so if you add code that needs them then add it above.
    //
    szInfFileNameExt = _tcsrchr(szInfFileName,TEXT('.'));
    MYASSERT(szInfFileNameExt);
    BackupPathExt = _tcsrchr(BackupPath,TEXT('.'));
    MYASSERT(BackupPathExt);

    if (szInfFileNameExt && BackupPathExt) {
        lstrcpy(szInfFileNameExt,pszPnfSuffix);
        lstrcpy(BackupPathExt,pszPnfSuffix);
        SetFileAttributes(BackupPath,FILE_ATTRIBUTE_NORMAL);
        CopyFile(szInfFileName, BackupPath, FALSE);
    }

    //
    // add items we may need to backup
    // (ie the copy queue of TempQueueHandle is converted to a backup queue of FileQueue)
    //

    if ( pSetupBackupAppendFiles(FileQueue, SubDir, BackupFlags, TempQueueHandle) != NO_ERROR ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Create the Reinstall registry key that points to the backup directory we
    // just made.
    //

    if (pSetupBackupGetReinstallKeyStrings(FileQ,
                                           TempInfoSet,
                                           &TempInfoData,
                                           DeviceID
                                       ) != NO_ERROR) {
        Err = GetLastError();
        goto clean0;
    }

    Err = NO_ERROR;

    //
    // update BackupInfID so that INF name can be queried later. We will set
    // these values at the very end since the fact that FileQ->BackupInfID is
    // not -1 means the backup initialization has been successful.
    //
    FileQ->BackupInfID = BackupInfID;
    FileQ->BackupInstanceID = BackupInstanceID;

    //
    // Set the FQF_DEVICE_BACKUP flag so that we know this is a device install
    // backup.
    //
    FileQ->Flags |= FQF_DEVICE_BACKUP;

clean0:

    //
    // If we encountered an error during our backup initialization then we want
    // to clean out the backup directory and Reinstall subkey.
    //
    if ((Err != NO_ERROR) &&
        (BackupInstanceID != -1)) {
        if (pSetupStringTableStringFromIdEx(FileQ->StringTable,
                                            BackupInstanceID,
                                            BackupInstance,
                                            NULL)) {
            pSetupDeleteBackup(BackupInstance);
        }
    }

    //
    // delete temporary structures used
    //
    if (pDeviceInfoSet != NULL ) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }
    if ( TempInfoSet != (HDEVINFO)INVALID_HANDLE_VALUE ) {
        SetupDiDestroyDeviceInfoList(TempInfoSet);
    }
    if ( TempQueueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        SetupCloseFileQueue(TempQueueHandle);
    }

    if(ChangedThreadLogContext) {
        //
        // restore thread log context if we changed (cleared) it
        //
        SetThreadLogContext(SavedLogContext,NULL);
    }
    DeleteLogContext(LocalLogContext);

    SetLastError(Err);

    return Err;
}

//
// ==========================================================
//

DWORD
pSetupCompleteBackup(
    IN OUT  HSPFILEQ    FileQueue
    )
/*++

Routine Description:

    This routine is called after we have successfully finished installing a
    device. At this point the new backup that we have created is valid and
    so any old backups that this device was using need to be removed.

    To do this the code will enumerate all of the backup instances under the
    Reinstall key and scan their DeviceInstanceIds multi-sz value. If it finds
    this DeviceInstanceId in the list then it will remove it. If the list is
    empty after this removal then the entire backup instance and its
    cooresponding backup directory will be deleted.

Arguments:

    FileQueue           Backup queue is filled with files that need copying

Return Value:

    Error Status

--*/


{
    PSP_FILE_QUEUE BackupFileQueue = (PSP_FILE_QUEUE)FileQueue;
    HKEY hKeyReinstall;
    HKEY hKeyReinstallInstance;
    DWORD Index;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    TCHAR ReinstallInstance[MAX_PATH];
    FILETIME ftLastWriteTime;
    DWORD cbData, cbInstanceSize;
    BOOL bDeleteBackupInstance;
    DWORD Err = NO_ERROR;
    PTSTR DeviceInstanceIdsList, p;

    try {

        //
        // If we don't have a BackupInfID then the backup failed, so don't bother
        // cleaning out the old backup information or creating the new Reinstall
        // instance key.
        //
        if (BackupFileQueue->BackupInfID == -1) {
            Err = ERROR_NO_BACKUP;
            goto clean0;
        }

        //
        // Get the Device Instance Id from the backup queue. This value must be
        // cleaned out from all other Reinstall Instance keys.
        //
        cbData = MAX_PATH;
        if (!pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                             BackupFileQueue->BackupDeviceInstanceID,
                                             DeviceInstanceId,
                                             &cbData)) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        //
        // Open the Reinstall key so we can enumerate all of the instance subkeys.
        //
        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           pszReinstallPath,
                           0,
                           KEY_ALL_ACCESS,
                           &hKeyReinstall
                           );

        if (Err == ERROR_SUCCESS) {

            cbInstanceSize = sizeof(ReinstallInstance) / sizeof(TCHAR);
            Index = 0;
            while (RegEnumKeyEx(hKeyReinstall,
                                Index++,
                                ReinstallInstance,
                                &cbInstanceSize,
                                NULL,
                                NULL,
                                NULL,
                                &ftLastWriteTime
                                ) == ERROR_SUCCESS) {

                //
                // Assume that we don't need to delete this backup instance
                //
                bDeleteBackupInstance = FALSE;

                Err = RegOpenKeyEx(hKeyReinstall,
                                   ReinstallInstance,
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKeyReinstallInstance
                                   );

                if (Err == ERROR_SUCCESS) {

                    cbData = 0;
                    if ((RegQueryValueEx(hKeyReinstallInstance,
                                         pszReinstallDeviceInstanceIds,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &cbData
                                         ) == ERROR_SUCCESS) &&
                        (cbData)) {

                        DeviceInstanceIdsList = MyMalloc(cbData + sizeof(TCHAR));

                        if (DeviceInstanceIdsList) {

                            if (RegQueryValueEx(hKeyReinstallInstance,
                                                pszReinstallDeviceInstanceIds,
                                                NULL,
                                                NULL,
                                                (LPBYTE)DeviceInstanceIdsList,
                                                &cbData) == ERROR_SUCCESS) {

                                //
                                // Walk the list of DeviceInstanceIds and check for
                                // a match with our device.
                                //
                                for (p = DeviceInstanceIdsList;
                                     *p;
                                     p += (lstrlen(p) + 1)) {

                                    if (lstrcmpi(p, DeviceInstanceId) == 0) {

                                        //
                                        // We have a match! First we will check to
                                        // see if this is the only DeviceInstanceId
                                        // in the list. To do this take the length of
                                        // the string and add two for the two terminating
                                        // NULLs of a multi-sz string and compare that
                                        // to cbData.  If it is the same as (or larger
                                        // than) cbData then this is the only string
                                        // in the multi-sz list.
                                        //
                                        if ((p == DeviceInstanceIdsList) &&
                                            (((lstrlen(DeviceInstanceIdsList) + 2) * sizeof(TCHAR)) >= cbData)) {

                                            //
                                            // Since there is only this one DeviceInstanceId
                                            // in the list set bDeleteBackupInstance to TRUE
                                            // so we can delete this entire subkey along
                                            // with the files that are backed up for it.
                                            //
                                            bDeleteBackupInstance = TRUE;

                                        } else {

                                            //
                                            // Since there is more than this DeviceInstanceId
                                            // in the list we need to remove just this
                                            // one Id from the multi-sz string and
                                            // put the new multi-sz string back
                                            // into the registry.
                                            //
                                            DWORD pLength = lstrlen(p);
                                            PTSTR p2 = p + (pLength + 1);

                                            memcpy(p, p2, cbData - ((ULONG_PTR)p2 - (ULONG_PTR)DeviceInstanceIdsList));

                                            RegSetValueEx(hKeyReinstallInstance,
                                                          pszReinstallDeviceInstanceIds,
                                                          0,
                                                          REG_MULTI_SZ,
                                                          (PBYTE)DeviceInstanceIdsList,
                                                          cbData - ((pLength + 1) * sizeof(TCHAR))
                                                          );
                                        }

                                        break;
                                    }
                                }
                            }

                            MyFree(DeviceInstanceIdsList);
                        }
                    }

                    RegCloseKey(hKeyReinstallInstance);

                    //
                    // If this entire subkey and it's corresponding directory need
                    // to be deleted then do it now.
                    //
                    if (bDeleteBackupInstance) {

                        pSetupDeleteBackup(ReinstallInstance);
                    }
                }

                //
                // Need to update the cbInstanceSize variable before calling
                // RegEnumKeyEx again.
                //
                cbInstanceSize = sizeof(ReinstallInstance) / sizeof(TCHAR);
            }

            RegCloseKey(hKeyReinstall);
        }

        //
        // Create the new Reinstall instance backup subkey.
        //
        Err = pSetupBackupCreateReinstallKey(BackupFileQueue);

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

VOID
pSetupCleanupBackup(
    IN PSP_FILE_QUEUE   Queue
    )
/*++

Routine Description:

    This routine is called to delete any backup directories or registry entries
    associated with this queue.

Arguments:

    Queue               file queue

Return Value:

    VOID

--*/
{
    TCHAR BackupInstance[MAX_PATH];
    DWORD cbData;

    //
    // If we don't have a BackupInfID or a BackupInstanceID then the backup
    // must have failed much earlier. If the backup failed then it would have
    // cleaned itself up so there is no cleanup that needs to be done now.
    //
    if ((Queue->BackupInfID == -1) ||
        (Queue->BackupInstanceID == -1)) {
        return;
    }

    //
    // Get the Backup Instance from the backup queue.
    //
    cbData = MAX_PATH;
    if (pSetupStringTableStringFromIdEx(Queue->StringTable,
                                        Queue->BackupInstanceID,
                                        BackupInstance,
                                        &cbData)) {

        pSetupDeleteBackup(BackupInstance);
    }
}

//
// ==========================================================
//

BOOL
PostDelayedMove(
                IN PSP_FILE_QUEUE    Queue,
                IN PCTSTR CurrentName,
                IN PCTSTR NewName,       OPTIONAL
                IN DWORD SecurityDesc,
                IN BOOL TargetIsProtected
                )
/*++

Routine Description:

    Helper for DelayedMove
    We don't do any delayed Moves until we know all else succeeded

Arguments:

    Queue               Queue that the move is applied to
    CurrentName         Name of file we want to move
    NewName             Name we want to move to
    SecurityDesc        Index in string table of Security Descriptor string or -1 if not present
    TargetIsProtected   Indicates whether target file is a protected system file

Return Value:

    FALSE if error

--*/
{
    PSP_DELAYMOVE_NODE DelayMoveNode;
    LONG SourceFilename;
    LONG TargetFilename;
    DWORD Err;

    if (CurrentName == NULL) {
        SourceFilename = -1;
    } else {
        SourceFilename = pSetupStringTableAddString(Queue->StringTable,
                                                (PTSTR)CurrentName,
                                                STRTAB_CASE_SENSITIVE
                                                );
        if (SourceFilename == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }
    if (NewName == NULL) {
        TargetFilename = -1;
    } else {
        TargetFilename = pSetupStringTableAddString(Queue->StringTable,
                                                (PTSTR)NewName,
                                                STRTAB_CASE_SENSITIVE
                                                );
        if (TargetFilename == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }

    DelayMoveNode = MyMalloc(sizeof(SP_DELAYMOVE_NODE));

    if (DelayMoveNode == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    DelayMoveNode->NextNode = NULL;
    DelayMoveNode->SourceFilename = SourceFilename;
    DelayMoveNode->TargetFilename = TargetFilename;
    DelayMoveNode->SecurityDesc = SecurityDesc;
    DelayMoveNode->TargetIsProtected = TargetIsProtected;

    if (Queue->DelayMoveQueueTail == NULL) {
        Queue->DelayMoveQueue = DelayMoveNode;
    } else {
        Queue->DelayMoveQueueTail->NextNode = DelayMoveNode;
    }
    Queue->DelayMoveQueueTail = DelayMoveNode;

    Err = NO_ERROR;

clean0:

    SetLastError(Err);

    return (Err == NO_ERROR);

}

//
// ==========================================================
//

DWORD
DoAllDelayedMoves(
    IN PSP_FILE_QUEUE    Queue
    )
/*++

Routine Description:

    Execute the Delayed Moves previously posted

Arguments:

    Queue               Queue that has the list in

Return Value:

    Error Status

--*/
{
    PSP_DELAYMOVE_NODE DelayMoveNode;
    PTSTR CurrentName;
    PTSTR TargetName;
    BOOL b = TRUE;
    PSP_DELAYMOVE_NODE DoneQueue = NULL;
    PSP_DELAYMOVE_NODE NextNode = NULL;
    DWORD Err = NO_ERROR;
    BOOL EnableProtectedRenames = FALSE;

    for (DelayMoveNode = Queue->DelayMoveQueue ; DelayMoveNode ; DelayMoveNode = NextNode ) {
        NextNode = DelayMoveNode->NextNode;

        MYASSERT(DelayMoveNode->SourceFilename != -1);
        CurrentName = pSetupStringTableStringFromId(Queue->StringTable, DelayMoveNode->SourceFilename);
        MYASSERT(CurrentName);

        if (DelayMoveNode->TargetFilename == -1) {
            TargetName = NULL;
        } else {
            TargetName = pSetupStringTableStringFromId( Queue->StringTable, DelayMoveNode->TargetFilename );
            MYASSERT(TargetName);
        }

        //
        // Keep track of whether we've encountered any protected system files.
        //
        EnableProtectedRenames |= DelayMoveNode->TargetIsProtected;

#ifdef UNICODE
        //
        // If this is a move (instead of a delete), then set security (letting
        // SCE know what the file's final name will be.
        //
        if((DelayMoveNode->SecurityDesc != -1) && TargetName) {

            Err = pSetupCallSCE(ST_SCE_RENAME,
                                CurrentName,
                                Queue,
                                TargetName,
                                DelayMoveNode->SecurityDesc,
                                NULL
                               );

            if(Err != NO_ERROR ){
                //
                // If we're on the first delay-move node, then we can abort.
                // However, if we've already processed one or more nodes, then
                // we can't abort--we must simply log an error indicating what
                // happened and keep on going.
                //
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_DELAYED_MOVE_SCE_FAILED,
                              NULL,
                              CurrentName,
                              TargetName
                             );

                WriteLogError(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              Err
                             );

                if(DelayMoveNode == Queue->DelayMoveQueue) {
                    //
                    // Failure occurred on 1st node--we can abort.
                    //
                    WriteLogEntry(Queue->LogContext,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_OPERATION_CANCELLED,
                                  NULL
                                 );
                    break;
                } else {
                    //
                    // There's no turning back--log an error and keep on going.
                    //
                    WriteLogEntry(Queue->LogContext,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_ERROR_IGNORED,
                                  NULL
                                 );

                    Err = NO_ERROR;
                }
            }

        } else
#endif
        {
            Err = NO_ERROR;
        }

        //
        // finally delay the move
        //
        if(!DelayedMove(CurrentName, TargetName)) {

            Err = GetLastError();

            //
            // Same deal as above with SCE call--if we've already processed one
            // or more delay-move nodes, we can't abort.
            //
            if(TargetName) {
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_DELAYED_MOVE_FAILED,
                              NULL,
                              CurrentName,
                              TargetName
                             );
            } else {
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_DELAYED_DELETE_FAILED,
                              NULL,
                              CurrentName
                             );
            }

            WriteLogError(Queue->LogContext,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          Err
                         );

            if(DelayMoveNode == Queue->DelayMoveQueue) {
                //
                // Failure occurred on 1st node--we can abort.
                //
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_OPERATION_CANCELLED,
                              NULL
                             );
                break;
            } else {
                //
                // There's no turning back--log an error and keep on going.
                //
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_ERROR_IGNORED,
                              NULL
                             );

                Err = NO_ERROR;
            }
        }

        //
        // Move node to queue containing nodes that have already been processed
        //
        DelayMoveNode->NextNode = DoneQueue;
        DoneQueue = DelayMoveNode;
    }

    //
    // If we have any replacement of protected system files, then we need to
    // inform session manager so that it allows the replacement to occur upon
    // reboot.
    //
    // NOTE: We don't have to worry about enabling replacement of system files
    // with unsigned (hence, untrusted) versions.  We only queue up unsigned
    // system files for replacement if the user was explicitly warned of (and
    // agreed to) the consequences.
    //
    // NTRAID#55485-2000/02/03-jamiehun
    // Protected renames only allows "rename all" or "rename none"
    //
    //         the session manager only allows the granularity of "allow all
    //         renames" or "allow no renames".  If Err != NO_ERROR, then we
    //         might want to clear out this flag, but that means we'd negate
    //         any renames that were previously allowed.  Yuck.  So we flip a
    //         coin, decide to do nothing, and hope for the best if an error
    //         occurred.  We have similar situation above -- it's all or
    //         nothing.
    //
    if((Err == NO_ERROR) && EnableProtectedRenames) {
        pSetupProtectedRenamesFlag(TRUE);
    }

    //
    // any nodes that are left are dropped
    //
    for ( ; DelayMoveNode ; DelayMoveNode = NextNode ) {
        NextNode = DelayMoveNode->NextNode;

        MyFree(DelayMoveNode);
    }
    Queue->DelayMoveQueue = NULL;
    Queue->DelayMoveQueueTail = NULL;

    //
    // delete all nodes we queue'd
    //
    for ( ; DoneQueue ; DoneQueue = NextNode ) {
        NextNode = DoneQueue->NextNode;
        //
        // done with node
        //
        MyFree(DoneQueue);
    }

    return Err;
}

//
// ==========================================================
//

VOID
pSetupUnwindAll(
    IN PSP_FILE_QUEUE    Queue,
    IN BOOL              Succeeded
    )
/*++

Routine Description:

    Processes the Unwind Queue. If Succeeded is FALSE, restores any data that was backed up

Arguments:

    Queue               Queue to be unwound
    Succeeded           Indicates if we should treat the whole operation as succeeded or failed

Return Value:

    None--this routine should always succeed.  (Any file errors encountered
    along the way are logged in the setupapi logfile.)

--*/

{
    // if Succeeded, we need to delete Temp files
    // if we didn't succeed, we need to restore backups

    PSP_UNWIND_NODE UnwindNode;
    PSP_UNWIND_NODE ThisNode;
    SP_TARGET_ENT TargetInfo;
    PTSTR BackupFilename;
    PTSTR TargetFilename;
    PTSTR RenamedFilename;
    DWORD Err = NO_ERROR;
    TCHAR TempPath[MAX_PATH];
    PTSTR TempNamePtr;
    TCHAR TempFilename[MAX_PATH];
    BOOL  RestoreByRenaming;
    BOOL  OkToDeleteBackup;

    try {
        if (Succeeded == FALSE) {
            //
            // we need to restore backups
            //

            WriteLogEntry(
                Queue->LogContext,
                SETUP_LOG_WARNING,
                MSG_LOG_UNWIND,
                NULL);

            for ( UnwindNode = Queue->UnwindQueue; UnwindNode != NULL; ) {
                ThisNode = UnwindNode;
                UnwindNode = UnwindNode->NextNode;

                if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, ThisNode->TargetID, &TargetInfo) == NO_ERROR) {


                    BackupFilename = NULL;
                    TargetFilename = NULL;
                    RenamedFilename = NULL;

                    // restore backup
                    if(!(TargetInfo.InternalFlags & SP_TEFLG_RESTORED)) {

                        // get target name
                        TargetFilename = pSetupFormFullPath(
                                            Queue->StringTable,
                                            TargetInfo.TargetRoot,
                                            TargetInfo.TargetSubDir,
                                            TargetInfo.TargetFilename);

                        if(TargetInfo.InternalFlags & SP_TEFLG_MOVED) {
                            //
                            // Get renamed filename
                            //
                            RenamedFilename = pSetupStringTableStringFromId(Queue->StringTable,
                                                                      TargetInfo.NewTargetFilename
                                                                     );
                        }

                        if(TargetInfo.InternalFlags & SP_TEFLG_SAVED) {
                            //
                            // get backup name
                            //
                            BackupFilename = pSetupFormFullPath(
                                                Queue->StringTable,
                                                TargetInfo.BackupRoot,
                                                TargetInfo.BackupSubDir,
                                                TargetInfo.BackupFilename);

                        }
                    }

                    if(TargetFilename && (RenamedFilename || BackupFilename)) {
                        //
                        // We either renamed the original file or we backed it up.
                        // We need to put it back.
                        //
                        RestoreByRenaming = RenamedFilename ? TRUE : FALSE;

                        RestoreRenamedOrBackedUpFile(TargetFilename,
                                                     (RestoreByRenaming
                                                        ? RenamedFilename
                                                        : BackupFilename),
                                                     RestoreByRenaming,
                                                     Queue->LogContext
                                                    );

                        //
                        // If we were doing a copy (i.e., from a backup) as opposed
                        // to a rename, then we need to reapply timestamp and
                        // security.
                        //
                        if(!RestoreByRenaming) {

                            Err = GetSetFileTimestamp(TargetFilename,
                                                      &(ThisNode->CreateTime),
                                                      &(ThisNode->AccessTime),
                                                      &(ThisNode->WriteTime),
                                                      TRUE
                                                     );

                            if(Err != NO_ERROR) {
                                //
                                // We just blew away the timestamp on the file--log
                                // an error entry to that effect.
                                //
                                WriteLogEntry(Queue->LogContext,
                                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                              MSG_LOG_BACKUP_EXISTING_RESTORE_FILETIME_FAILED,
                                              NULL,
                                              TargetFilename
                                             );

                                WriteLogError(Queue->LogContext,
                                              SETUP_LOG_ERROR,
                                              Err
                                             );
                            }

                            if(ThisNode->SecurityDesc != NULL){

                                Err = StampFileSecurity(TargetFilename, ThisNode->SecurityDesc);

                                if(Err != NO_ERROR) {
                                    //
                                    // We just blew away the existing security on
                                    // the file--log an error entry to that effect.
                                    //
                                    WriteLogEntry(Queue->LogContext,
                                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                                  MSG_LOG_BACKUP_EXISTING_RESTORE_SECURITY_FAILED,
                                                  NULL,
                                                  TargetFilename
                                                 );

                                    WriteLogError(Queue->LogContext,
                                                  SETUP_LOG_ERROR,
                                                  Err
                                                 );
                                }
    #ifdef UNICODE
                                Err = pSetupCallSCE(ST_SCE_UNWIND,
                                                    TargetFilename,
                                                    NULL,
                                                    NULL,
                                                    -1,
                                                    ThisNode->SecurityDesc
                                                   );

                                if(Err != NO_ERROR) {
                                    //
                                    // We just blew away the existing security on
                                    // the file--log an error entry to that effect.
                                    //
                                    WriteLogEntry(Queue->LogContext,
                                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                                  MSG_LOG_BACKUP_EXISTING_RESTORE_SCE_FAILED,
                                                  NULL,
                                                  TargetFilename
                                                 );

                                    WriteLogError(Queue->LogContext,
                                                  SETUP_LOG_ERROR,
                                                  Err
                                                 );
                                }
    #endif
                            }
                        }

                        //
                        // Now mark that we've restored this file.  We'll delete
                        // tempfiles later
                        //
                        TargetInfo.InternalFlags |= SP_TEFLG_RESTORED;
                        pSetupBackupSetTargetByID((HSPFILEQ)Queue, ThisNode->TargetID, &TargetInfo);
                    }

                    if(BackupFilename) {
                        MyFree(BackupFilename);
                    }
                    if(TargetFilename) {
                        MyFree(TargetFilename);
                    }
                }
            }
        }

        //
        // cleanup - remove temporary files
        //
        for ( UnwindNode = Queue->UnwindQueue; UnwindNode != NULL; ) {
            ThisNode = UnwindNode;
            UnwindNode = UnwindNode->NextNode;

            if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, ThisNode->TargetID, &TargetInfo) == NO_ERROR) {
                // delete temporary file
                if (TargetInfo.InternalFlags & SP_TEFLG_TEMPNAME) {
                    //
                    // get name of file that was used for backup
                    //
                    BackupFilename = pSetupFormFullPath(
                                        Queue->StringTable,
                                        TargetInfo.BackupRoot,
                                        TargetInfo.BackupSubDir,
                                        TargetInfo.BackupFilename);

                    if(BackupFilename) {
                        //
                        // If this operation was a bootfile replacement, then we
                        // don't want to delete the backup (if we used the renamed
                        // file for the backup as well).  A delayed delete will
                        // have been queued to get rid of the file after a reboot.
                        //
                        OkToDeleteBackup = TRUE;

                        if(TargetInfo.InternalFlags & SP_TEFLG_MOVED) {
                            //
                            // Retrieve the renamed filename to see if it's the
                            // same as the backup filename.
                            //
                            RenamedFilename = pSetupStringTableStringFromId(Queue->StringTable,
                                                                      TargetInfo.NewTargetFilename
                                                                     );

                            if(!lstrcmpi(BackupFilename, RenamedFilename)) {
                                OkToDeleteBackup = FALSE;
                            }
                        }

                        if(OkToDeleteBackup) {
                            //
                            // since it was temporary, delete it
                            //
                            SetFileAttributes(BackupFilename, FILE_ATTRIBUTE_NORMAL);
                            if(!DeleteFile(BackupFilename)) {
                                //
                                // Alright, see if we can set it up for delayed delete
                                // instead.
                                //
                                if(!DelayedMove(BackupFilename, NULL)) {
                                    //
                                    // Oh well, just write a log entry indicating that
                                    // this file turd was left on the user's disk.
                                    //
                                    Err = GetLastError();

                                    WriteLogEntry(Queue->LogContext,
                                                  SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                                  MSG_LOG_BACKUP_DELAYED_DELETE_FAILED,
                                                  NULL,
                                                  BackupFilename
                                                 );

                                    WriteLogError(Queue->LogContext,
                                                  SETUP_LOG_WARNING,
                                                  Err
                                                 );
                                }
                            }
                        }

                        MyFree(BackupFilename);
                    }
                }

                pSetupResetTarget(Queue->TargetLookupTable,
                                  ThisNode->TargetID,
                                  NULL,
                                  &TargetInfo,
                                  sizeof(TargetInfo),
                                  (LPARAM)0
                                 );
            }

            // cleanup node
            if (ThisNode->SecurityDesc != NULL) {
                MyFree(ThisNode->SecurityDesc);
            }
            MyFree(ThisNode);
        }
        Queue->UnwindQueue = NULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // should generally not get here
        // unless Queue is invalid
        //
    }
}

//
// ==========================================================
//

DWORD _SetupGetBackupInformation(
         IN     PSP_FILE_QUEUE               Queue,
         OUT    PSP_BACKUP_QUEUE_PARAMS_V2   BackupParams
         )
/*++

Routine Description:

    Get Backup INF path - Internal version

Arguments:

    Queue - pointer to queue structure (validated)
    BackupParams OUT - filled with INF file path

Return Value:

    TRUE if success, else FALSE

--*/
{
    //
    // Queue is assumed to have been validated
    // BackupParams is in Native format
    //

    LONG BackupInfID;
    ULONG BufSize = MAX_PATH;
    BOOL b;
    DWORD err = NO_ERROR;
    LPCTSTR filename;
    INT offset;

    BackupInfID = Queue->BackupInfID;

    if (BackupInfID != -1) {
        //
        // get inf from stringtable
        //
        b = pSetupStringTableStringFromIdEx(Queue->StringTable,
                                    BackupInfID,
                                    BackupParams->FullInfPath,
                                    &BufSize);
        if (b == FALSE) {
            if (BufSize == 0) {
                err = ERROR_NO_BACKUP;
            } else {
                err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto Clean0;
        }

        //
        // find index of filename
        //
        filename = pSetupGetFileTitle(BackupParams->FullInfPath);
        offset = (INT)(filename - BackupParams->FullInfPath);
        BackupParams->FilenameOffset = offset;

        //
        // If the caller passed in a SP_BACKUP_QUEUE_PARAMS_V2 structure then
        // also fill in the ReinstallInstance string value.
        //
        if (BackupParams->cbSize >= sizeof(SP_BACKUP_QUEUE_PARAMS_V2)) {
            BufSize = MAX_PATH;
            if(Queue->BackupInstanceID != -1) {
                b = pSetupStringTableStringFromIdEx(Queue->StringTable,
                                                    Queue->BackupInstanceID,
                                                    BackupParams->ReinstallInstance,
                                                    &BufSize);
            } else {
                //
                // no instance ID
                //
                BackupParams->ReinstallInstance[0] = TEXT('\0');
            }
            if (b == FALSE) {
                if (BufSize == 0) {
                    err = ERROR_NO_BACKUP;
                } else {
                    err = ERROR_INSUFFICIENT_BUFFER;
                }
                goto Clean0;
            }
        }

    } else {
        //
        // no backup path
        //
        err = ERROR_NO_BACKUP;
    }

Clean0:

    return err;
}




#ifdef UNICODE
//
// ANSI version in UNICODE
//
BOOL
WINAPI
SetupGetBackupInformationA(
    IN     HSPFILEQ                     QueueHandle,
    OUT    PSP_BACKUP_QUEUE_PARAMS_V2_A BackupParams
    )
{
    BOOL b;
    int i;
    INT c;
    LPCSTR p;
    SP_BACKUP_QUEUE_PARAMS_W BackupParamsW;

    //
    // confirm structure size
    //

    try {
        if((BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V2_A)) &&
           (BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V1_A))) {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            leave;              // exit try block
        }
        //
        // call Unicode version of API
        //
        ZeroMemory( &BackupParamsW, sizeof(BackupParamsW) );
        BackupParamsW.cbSize = sizeof(BackupParamsW);

        b = SetupGetBackupInformationW(QueueHandle,&BackupParamsW);
        if (b) {
            //
            // success, convert structure from UNICODE to ANSI
            //
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    BackupParamsW.FullInfPath,
                    MAX_PATH,
                    BackupParams->FullInfPath,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                b = FALSE;
                leave;              // exit try block
            }

            //
            // we need to recalc the offset of INF filename
            // taking care of internationalization
            //
            p = BackupParams->FullInfPath;
            for(c = 0; c < BackupParamsW.FilenameOffset; c++) {
                p = CharNextA(p);
            }
            BackupParams->FilenameOffset = (int)(p-(BackupParams->FullInfPath));  // new offset in ANSI

            if (BackupParams->cbSize >= sizeof(SP_BACKUP_QUEUE_PARAMS_V2_A)) {
                //
                // instance
                //
                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        BackupParamsW.ReinstallInstance,
                        MAX_PATH,
                        BackupParams->ReinstallInstance,
                        MAX_PATH,
                        NULL,
                        NULL
                        );
                if (i==0) {
                    //
                    // error occurred (LastError set to error)
                    //
                    b = FALSE;
                    leave;              // exit try block
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          SetLastError(ERROR_INVALID_PARAMETER);
          b = FALSE;
    }

    return b;
}

#else
//
// Unicode version in ANSI
//
BOOL
WINAPI
SetupGetBackupInformationW(
   IN     HSPFILEQ                     QueueHandle,
   OUT    PSP_BACKUP_QUEUE_PARAMS_V2_W BackupParams
   )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(BackupParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

//
// Native version
//
BOOL
WINAPI
SetupGetBackupInformation(
    IN     HSPFILEQ                     QueueHandle,
    OUT    PSP_BACKUP_QUEUE_PARAMS_V2   BackupParams
    )
/*++

Routine Description:

    Get Backup INF path

Arguments:

    QueueHandle - handle of queue to retrieve backup INF file from
    BackupParams - IN - has cbSize set, OUT - filled with INF file path

Return Value:

    TRUE if success, else FALSE

--*/
{
    BOOL b = TRUE;
    PSP_FILE_QUEUE Queue = (PSP_FILE_QUEUE)QueueHandle;
    DWORD res;

    //
    // first validate QueueHandle
    //
    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Clean0;
    }

    //
    // now fill in structure
    // if we except, assume bad pointer
    //
    try {
        if((BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V2)) &&
           (BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V1))) {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            leave;              // exit try block
        }
        res = _SetupGetBackupInformation(Queue,BackupParams);
        if (res == NO_ERROR) {
            b = TRUE;
        } else {
            SetLastError(res);
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          SetLastError(ERROR_INVALID_PARAMETER);
          b = FALSE;
    }

Clean0:
    return b;
}


//
// ==========================================================
//

VOID
RestoreRenamedOrBackedUpFile(
    IN PCTSTR             TargetFilename,
    IN PCTSTR             CurrentFilename,
    IN BOOL               RenameFile,
    IN PSETUP_LOG_CONTEXT LogContext       OPTIONAL
    )
/*++

Routine Description:

    This routine does its best to restore a backed-up or renamed file back to
    its original name.

Arguments:

    TargetFilename - filename to be restored to

    CurrentFilename - file to restore

    RenameFile - if TRUE, CurrentFilename was previously renamed from
        TargetFilename (hence should be renamed back).  If FALSE,
        CurrentFilename is merely a copy, and should be copied back.

    LogContext - supplies a log context used if errors are encountered.

Return Value:

    None.

--*/
{
    DWORD Err;
    TCHAR TempPath[MAX_PATH];
    PTSTR TempNamePtr;
    TCHAR TempFilename[MAX_PATH];
    DWORD LogTag = AllocLogInfoSlotOrLevel(LogContext,SETUP_LOG_INFO,FALSE);

    WriteLogEntry(
        LogContext,
        LogTag,
        MSG_LOG_UNWIND_FILE,
        NULL,
        CurrentFilename,
        TargetFilename
        );

    //
    // First, clear target attributes...
    //
    SetFileAttributes(TargetFilename, FILE_ATTRIBUTE_NORMAL);

    if(RenameFile) {
        //
        // simple case, move temporary file over existing file
        //
        pSetupExemptFileFromProtection(
                    TargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        Err = DoMove(CurrentFilename, TargetFilename) ? NO_ERROR : GetLastError();
    } else {
        pSetupExemptFileFromProtection(
                    TargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        Err = CopyFile(CurrentFilename, TargetFilename, FALSE) ? NO_ERROR : GetLastError();
    }

    if(Err != NO_ERROR) {
        //
        // Can't replace the file that got copied in place of
        // the original one--try to move that one to a tempname
        // and schedule it for delayed deletion.
        //
        WriteLogEntry(LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_UNWIND_TRY1_FAILED,
                    NULL,
                    CurrentFilename,
                    TargetFilename
                    );
        WriteLogError(LogContext,
                    SETUP_LOG_ERROR,
                    Err
                    );

        //
        // First, strip the filename off the path.
        //
        _tcscpy(TempPath, TargetFilename);
        TempNamePtr = (PTSTR)pSetupGetFileTitle(TempPath);
        *TempNamePtr = TEXT('\0');

        //
        // Now get a temp filename within that directory...
        //
        if(GetTempFileName(TempPath, TEXT("OLD"), 0, TempFilename) == 0 ) {
            //
            // Uh oh!
            //
            Err = GetLastError();
        } else if(!DoMove(TargetFilename, TempFilename)) {
            Err = GetLastError();
        } else {
            //
            // OK, we were able to rename the current file to a
            // temp filename--now attempt to copy or move the
            // original file back to its original name.
            //
            if(RenameFile) {
                Err = DoMove(CurrentFilename, TargetFilename) ? NO_ERROR : GetLastError();
            } else {
                Err = CopyFile(CurrentFilename, TargetFilename, FALSE) ? NO_ERROR : GetLastError();
            }

            if(Err != NO_ERROR) {
                //
                // This is very bad--put the current file back (it's probably
                // better to have something than nothing at all).
                //
                DoMove(TempFilename, TargetFilename);
            }
        }

        if(Err == NO_ERROR) {
            //
            // We successfully moved the current file to a temp
            // filename, and put the original file back.  Now
            // queue a delayed delete for the temp file.
            //
            if(!DelayedMove(TempFilename, NULL)) {
                //
                // All this means is that a file turd will get
                // left on the disk--simply log an event about
                // this.
                //
                Err = GetLastError();

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_RENAME_EXISTING_DELAYED_DELETE_FAILED,
                              NULL,
                              TargetFilename,
                              TempFilename
                             );

                WriteLogError(LogContext,
                              SETUP_LOG_WARNING,
                              Err
                             );
            }

        } else {
            //
            // We were unable to put the original file back--we
            // can't fail, so just log an error about this and
            // keep on going.
            //
            // in the case of a backed-up file,
            // we might get away with queueing the original file
            // for a delayed rename and then prompting the user
            // to reboot.  However, that won't work for renamed
            // files, because they're typically needed very
            // early on in the boot (i.e., before session
            // manager has had a chance to process the delayed
            // rename operations).
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          (RenameFile
                              ? MSG_LOG_RENAME_EXISTING_RESTORE_FAILED
                              : MSG_LOG_BACKUP_EXISTING_RESTORE_FAILED),
                          NULL,
                          CurrentFilename,
                          TargetFilename
                         );

            WriteLogError(LogContext,
                          SETUP_LOG_ERROR,
                          Err
                         );
        }
    }

    if (LogTag) {
        ReleaseLogInfoSlot(LogContext,LogTag);
    }
}

//
// ==========================================================
//

BOOL
UnPostDelayedMove(
    IN PSP_FILE_QUEUE Queue,
    IN PCTSTR         CurrentName,
    IN PCTSTR         NewName      OPTIONAL
    )
/*++

Routine Description:

    Locates a delay-move node (either for rename or delete), and removes it
    from the delay-move queue.

Arguments:

    Queue               Queue that the move was applied to
    CurrentName         Name of file to be moved
    NewName             Name to move file to (NULL if delayed-delete)

Return Value:

    If successful, the return value is TRUE, otherwise it is FALSE.

--*/
{
    PSP_DELAYMOVE_NODE CurNode, PrevNode;
    PCTSTR SourceFilename, TargetFilename;

    //
    // Since the path string IDs in the delay-move nodes are case-sensitive, we
    // don't attempt to match on ID.  We instead retrieve the strings, and do
    // case-insensitive string compares.  Since this routine is rarely used, the
    // performance hit isn't a big deal.
    //
    for(CurNode = Queue->DelayMoveQueue, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->NextNode) {

        if(NewName) {
            //
            // We're searching for a delayed rename, so we must pay attention
            // to the target filename.
            //
            if(CurNode->TargetFilename == -1) {
                continue;
            } else {
                TargetFilename = pSetupStringTableStringFromId(Queue->StringTable, CurNode->TargetFilename);
                MYASSERT(TargetFilename);
                if(lstrcmpi(NewName, TargetFilename)) {
                    //
                    // Target filenames differ--move on.
                    //
                    continue;
                }
            }

        } else {
            //
            // We're searching for a delayed delete.
            //
            if(CurNode->TargetFilename != -1) {
                //
                // This is a rename, not a delete--move on.
                //
                continue;
            }
        }

        //
        // If we get to here, then the target filenames match (if this is a
        // rename), or they're both empty (if it's a delete).  Now compare the
        // source filenames.
        //
        MYASSERT(CurNode->SourceFilename != -1);
        SourceFilename = pSetupStringTableStringFromId(Queue->StringTable, CurNode->SourceFilename);
        MYASSERT(SourceFilename);

        if(lstrcmpi(CurrentName, SourceFilename)) {
            //
            // Source filenames differ--move on.
            //
            continue;
        } else {
            //
            // We have a match--remove the node from the delay-move queue.
            //
            if(PrevNode) {
                PrevNode->NextNode = CurNode->NextNode;
            } else {
                Queue->DelayMoveQueue = CurNode->NextNode;
            }
            if(!CurNode->NextNode) {
                MYASSERT(Queue->DelayMoveQueueTail == CurNode);
                Queue->DelayMoveQueueTail = PrevNode;
            }
            MyFree(CurNode);

            return TRUE;
        }
    }

    //
    // We didn't find a match.
    //
    return FALSE;
}


DWORD
pSetupDoLastKnownGoodBackup(
    IN struct _SP_FILE_QUEUE *Queue,           OPTIONAL
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    )
/*++

Routine Description:

    Process LastKnownGood backups into <<LastGoodDirectory>>.
    If files are to be deleted on restore, write apropriate flags to HKLM\System\LastGoodRecovery\LastGood\<path/file>

    Caviats:

    If file is not inside <<WindowsDirectory>> or sub-directory, exit no-error.

    Backup will not occur if PSPGF_NO_BACKUP is set.

    If !SP_LKG_FLAG_FORCECOPY
        If file is inside <<LastGoodDirectory>>, exit with error.
        If file is inside <<InfDirectory>> throw warnings

    If an INF inside of <<InfDirectory>> is backed up, it's PNF is backed up too.

    If backup fails, we don't abort copy.

Arguments:

    Queue               Queue (optional) if specified, flags will be checked
    TargetFilename      Name of file to backup
    Flags
        SP_LKG_FLAG_FORCECOPY       - if set, turns copy safety-guards off
        SP_LKG_FLAG_DELETEIFNEW     - if set, writes a delete entry for new files
        SP_LKG_FLAG_DELETEEXISTING  - if set, writes a delete entry for existing files
        SP_LKG_FLAG_DELETEOP        - if set, primary operation is trying to delete/rename file

    LogContext          If specified, provides preferred logging context

Return Value:

    error if operation should be aborted, NO_ERROR otherwise.

--*/
{
#ifdef UNICODE
    int wd_len;   // windows directory len
    int tf_len;   // target file len
    int id_len;   // inf directory len
    int lkgd_len; // last known good directory len
    int rf_len;   // relative file len (including preceeding slash)
    BOOL is_inf = FALSE;
    BOOL is_infdir = FALSE;
    BOOL write_delete = FALSE;
    BOOL no_copy = FALSE;
    BOOL source_exists = FALSE;
    BOOL target_exists = FALSE;
    TCHAR FullTargetFilename[MAX_PATH];
    TCHAR BackupTargetFilename[MAX_PATH+14];
    TCHAR TempFilename[MAX_PATH];
    TCHAR RegName[MAX_PATH];
    PCTSTR RelativeFilename;
    PCTSTR CharPtr;
    PTSTR DestPtr;
    PTSTR NamePart = NULL;
    PTSTR ExtPart = NULL;
    DWORD attr;
    HANDLE hFile;
    HKEY hKeyLastGood;
    DWORD disposition;
    LONG regres;
    DWORD LastGoodFlags = 0;
    DWORD rval = NO_ERROR;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;

    if (!LogContext) {
        //
        // LogContext may be obmitted if there's a Queue parameter
        //
        if (Queue && Queue->LogContext) {
            LogContext = Queue->LogContext;
        } else {
            if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
                LogContext = LocalLogContext;
            }
        }
        MYASSERT(LogContext);
    }

    if ((GlobalSetupFlags & PSPGF_NO_BACKUP)!=0) {
        //
        // in a scenario where (1) we trust what we're doing and
        // (2) what we're doing modifies lots of files
        // or (3) what we're doing is undoable (eg, upgrading OS)
        //
        no_copy = TRUE;
    }
#if 0
    else if (Queue && !(Queue->Flags & FQF_DEVICE_INSTALL)) {
        //
        // in this scenario, a queue was specified, but it's not marked
        // for device install
        // we're not interested in this case
        //
        no_copy = TRUE;
    }
#endif

    //
    // cannonicalize the Target name so user doesn't do stuff like .../TEMP/../INF
    //
    tf_len = (int)GetFullPathName(TargetFilename,
                             MAX_PATH,
                             FullTargetFilename,
                             &NamePart);
    if (tf_len <= 0 || tf_len > MAX_PATH) {
        //
        // we don't do large paths very well
        //
        rval = NO_ERROR;
        goto final;
    }
    wd_len = lstrlen(WindowsDirectory);
    lkgd_len = lstrlen(LastGoodDirectory);
    id_len = lstrlen(InfDirectory);

    //
    // see if this file is nested below <<WindowsDirectory>>
    // note that such a file must be at least two characters longer
    //
    if((tf_len <= wd_len)
       || (FullTargetFilename[wd_len] != TEXT('\\'))
       || (_tcsnicmp(WindowsDirectory,FullTargetFilename,wd_len)!=0)) {
        //
        // this file is outside of %windir%, not handled by LKG
        //
        rval = NO_ERROR;
        goto final;
    }
    if (!(Flags&SP_LKG_FLAG_FORCECOPY)) {
        //
        // sanity check for files being copied into LKG dir
        //
        if((tf_len > lkgd_len)
           && (FullTargetFilename[lkgd_len] == TEXT('\\'))
           && (_tcsnicmp(LastGoodDirectory,FullTargetFilename,lkgd_len)==0)) {
            //
            // this file is prefixed by LastGoodDirectory
            // not allowed - throw a log message and inform caller of this mistake
            // return FALSE to abort the operation
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR,
                          MSG_LOG_FILE_BLOCK,
                          NULL,
                          FullTargetFilename,
                          LastGoodDirectory
                          );
            rval = ERROR_ACCESS_DENIED;
            goto final;
        }
    }
    if((tf_len > id_len)
       && (FullTargetFilename[id_len] == TEXT('\\'))
       && (_tcsnicmp(InfDirectory,FullTargetFilename,id_len)==0)
       && ((NamePart-FullTargetFilename) == (id_len+1))) {
        //
        // the file sits in the primary INF directory
        //
        is_infdir = TRUE;
        //
        // check for name ending in ".INF" - if so, we need to backup ".PNF" too
        //
        ExtPart = FullTargetFilename+tf_len;
        while ((ExtPart = CharPrev(NamePart,ExtPart)) != NamePart) {
            if (ExtPart[0] == TEXT('.')) {
                break;
            }
        }

        if(lstrcmpi(ExtPart,TEXT(".INF"))==0) {
            //
            // ends in .INF
            //
            is_inf = TRUE;
            //
            // we should only get here if Force is set (ie, we've already determined
            // what is being copied and all is OK). If we don't, this implies someone
            // is trying a back-door INF copy. we've already logged above that they're writing
            // to this directory when they shouldn't. However, if we don't do anything
            // about it, culprit could render machine in bad state
            // change this behavior into a "Force" behavior
            //
            if (!(Flags&SP_LKG_FLAG_FORCECOPY)) {
                no_copy = FALSE; // ensure we'll go through copy logic
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_INF_WARN,
                              NULL,
                              FullTargetFilename,
                              InfDirectory
                              );
                if(!(Flags&SP_LKG_FLAG_DELETEOP)) {
                    //
                    // we're invalidly trying to overwrite an INF/create an INF
                    //
                    Flags|=SP_LKG_FLAG_DELETEIFNEW;
                }
            }
        } else if (!(Flags&SP_LKG_FLAG_FORCECOPY)) {
            //
            // writing something else into this directory - huh?
            // well, if it's not an INF, we won't pick it up via INF searching
            // if it's a PNF or cache, we're regenerate it
            // don't fret too much, but slap wrist.
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR,
                          MSG_LOG_FILE_WARN,
                          NULL,
                          FullTargetFilename,
                          InfDirectory
                          );
        }
    }

    if (no_copy) {
        //
        // we determined that we're not going to backup, and we've now done logging items
        //
        rval = NO_ERROR;
        goto final;
    }

    //
    // does source really exist?
    //
    if ((attr=GetFileAttributes(FullTargetFilename))!=(DWORD)(-1)) {
        source_exists = TRUE;
        if (Flags & SP_LKG_FLAG_DELETEEXISTING) {
            write_delete = TRUE;
        }
    } else if (Flags & SP_LKG_FLAG_DELETEIFNEW) {
        write_delete = TRUE;
    } else {
        //
        // we're done
        //
        rval = NO_ERROR;
        goto final;
    }
    //
    // remap to LKG directory
    //
    RelativeFilename = FullTargetFilename+wd_len; // includes preceeding backslash
    rf_len = tf_len-wd_len;
    MYASSERT((MAX_PATH+(lkgd_len-wd_len))<=SIZECHARS(BackupTargetFilename));
    lstrcpy(BackupTargetFilename,LastGoodDirectory);
    lstrcpy(BackupTargetFilename+lkgd_len,RelativeFilename);

    //
    // does backup already exist?
    //
    if ((attr=GetFileAttributes(BackupTargetFilename))!=(DWORD)(-1)) {
        //
        // if it does, nothing useful to do.
        //
        rval = NO_ERROR;
        goto final;
    }

    //
    // create intermediate directories as needed
    //
    pSetupMakeSurePathExists(BackupTargetFilename);

    //
    // we need to use a temporary file first, and then move it into place
    // so we don't get in the situation where we write a bad file, reboot
    // and decide to use LKG.
    //
    if(GetTempFileName(LastGoodDirectory, TEXT("TMP"), 0, TempFilename) == 0 ) {
        //
        // if this fails, it could be because we haven't got right permissions
        // non-fatal
        //
        rval = NO_ERROR;
        goto final;
    }
    //
    // after this point, aborts require cleaning up of temporary file
    //

    if (write_delete) {
        //
        // GetTempFileName created an empty place holder
        // ensure it has right attributes
        // before moving into place
        //
        SetFileAttributes(TempFilename,FILE_ATTRIBUTE_HIDDEN);
    } else {
        //
        // copy original to this temporary file
        // apply apropriate permissions
        //
        if(!CopyFile(FullTargetFilename, TempFilename ,FALSE)) {
            //
            // copy failed - non fatal
            //
            goto cleanup;
        }
    }

    //
    // we have a temporary file ready to be moved into place
    // move it to final name, ensuring that while we were doing above, a new file
    // was not already written
    //
    if(!MoveFileEx(TempFilename,BackupTargetFilename,MOVEFILE_WRITE_THROUGH)) {
        //
        // could be that a file with that name now exists, but didn't earlier
        // oh well, clean up the mess and leave gracefully
        //
        goto cleanup;
    }

    if (write_delete) {
        //
        // if we successfully wrote an empty placeholder for a file to be deleted, we need to shadow this file with
        // an entry in registry
        //
        regres = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                REGSTR_PATH_LASTGOOD,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKeyLastGood,
                                &disposition);
        if (regres == NO_ERROR) {
            //
            // copy string, remapping slash's from '\\' to '/'
            //
            CharPtr = RelativeFilename+1; // after initial '\'
            DestPtr = RegName;
            while(*CharPtr) {
                PCTSTR Next = _tcschr(CharPtr,TEXT('\\'));
                if (!Next) {
                    Next = CharPtr + lstrlen(CharPtr);
                }
                if(Next-CharPtr) {
                    CopyMemory(DestPtr,CharPtr,(Next-CharPtr)*sizeof(TCHAR));
                    DestPtr+=(Next-CharPtr);
                    CharPtr = Next;
                }
                if (*CharPtr == TEXT('\\')) {
                    *DestPtr = TEXT('/');
                    DestPtr++;
                    CharPtr++;
                }
            }
            *DestPtr = TEXT('\0');

            //
            // write key, name = modified relative path, value = flags
            //
            LastGoodFlags = LASTGOOD_OPERATION_DELETE;
            regres = RegSetValueEx(hKeyLastGood,
                                   RegName,
                                   0,
                                   REG_DWORD,
                                   (PBYTE)&LastGoodFlags,
                                   sizeof(LastGoodFlags));
            RegCloseKey(hKeyLastGood);
        }
    }

    //
    // ok, now we've populated the LKG directory with this file
    //
    if (is_inf) {
        //
        // if we backed up an INF that's in primary INF directory, we should also backup existing PNF
        // if we're writing an entry to delete INF, we'll always write an entry to delete PNF
        //
        MYASSERT(ExtPart);
        lstrcpy(ExtPart,TEXT(".PNF"));
        if(pSetupDoLastKnownGoodBackup(NULL,
                                       FullTargetFilename,
                                       SP_LKG_FLAG_FORCECOPY|SP_LKG_FLAG_DELETEIFNEW|(write_delete?SP_LKG_FLAG_DELETEEXISTING:0),
                                       LogContext) != NO_ERROR) {
            //
            // should never fail
            //
            MYASSERT(FALSE);
        }
    }
    //
    // done!
    //
    rval = NO_ERROR;
    goto final;

cleanup:

    //
    // cleanup in the case where we've already created temporary file
    //
    SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(TempFilename);

    rval = NO_ERROR;

final:
    if(LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }
    return rval;

#else
    //
    // ANSI - not supported
    //
    return NO_ERROR;
#endif
}

#ifdef UNICODE
BOOL
pSetupRestoreLastKnownGoodFile(
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    )
/*++

Routine Description:

    Restore a single LKG file
    The assumption here is that if this API was called, we detected something
    really bad that needs to be fixed immediately

Arguments:

    TargetFilename      Name of file to restore
    Flags

    LogContext          If specified, provides preferred logging context

Return Value:

    TRUE if file was successfully restored

--*/
{
    int wd_len;   // windows directory len
    int tf_len;   // target file len
    int lkgd_len; // last known good directory len
    int rf_len;   // relative file len (including preceeding slash)
    TCHAR FullTargetFilename[MAX_PATH];
    TCHAR BackupTargetFilename[MAX_PATH+14];
    TCHAR TempFilename[MAX_PATH];
    TCHAR TempPathname[MAX_PATH];
    TCHAR RegName[MAX_PATH];
    PCTSTR RelativeFilename;
    PTSTR NamePart = NULL;
    BOOL rflag = FALSE;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    LONG regres;
    HKEY hKeyLastGood;
    PCTSTR CharPtr;
    PTSTR DestPtr;
    DWORD RegType;
    DWORD RegSize;
    DWORD LastGoodFlags;

    if (!LogContext) {
        //
        // LogContext may be obmitted if there's a Queue parameter
        //
        if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
            LogContext = LocalLogContext;
        }
        MYASSERT(LogContext);
    }

    //
    // cannonicalize the Target name so user doesn't do stuff like .../TEMP/../INF
    //
    tf_len = (int)GetFullPathName(TargetFilename,
                             MAX_PATH,
                             FullTargetFilename,
                             &NamePart);
    if (tf_len <= 0 || tf_len > MAX_PATH) {
        //
        // we don't do large paths very well
        //
        goto final;
    }
    wd_len = lstrlen(WindowsDirectory);
    lkgd_len = lstrlen(LastGoodDirectory);

    //
    // see if this file is nested below <<WindowsDirectory>>
    // note that such a file must be at least two characters longer
    //
    if((tf_len <= wd_len)
       || (FullTargetFilename[wd_len] != TEXT('\\'))
       || (_tcsnicmp(WindowsDirectory,FullTargetFilename,wd_len)!=0)) {
        //
        // this file is outside of %windir%, not handled by LKG
        //
        goto final;
    }

    //
    // remap to LKG directory
    //
    RelativeFilename = FullTargetFilename+wd_len; // includes preceeding backslash
    rf_len = tf_len-wd_len;
    MYASSERT((MAX_PATH+(lkgd_len-wd_len))<=SIZECHARS(BackupTargetFilename));
    lstrcpy(BackupTargetFilename,LastGoodDirectory);
    lstrcpy(BackupTargetFilename+lkgd_len,RelativeFilename);

    //
    // does backup already exist?
    //
    if (GetFileAttributes(BackupTargetFilename)==(DWORD)(-1)) {
        //
        // if not, nothing we can do
        //
        goto final;
    }
    //
    // find LKG flags to see what we need to do
    //
    regres = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_LASTGOOD,
                          0,
                          KEY_READ,
                          &hKeyLastGood);
    if (regres == NO_ERROR) {
        //
        // copy string, remapping slash's from '\\' to '/'
        //
        CharPtr = RelativeFilename+1; // after initial '\'
        DestPtr = RegName;
        while(*CharPtr) {
            PCTSTR Next = _tcschr(CharPtr,TEXT('\\'));
            if (!Next) {
                Next = CharPtr + lstrlen(CharPtr);
            }
            if(Next-CharPtr) {
                CopyMemory(DestPtr,CharPtr,(Next-CharPtr)*sizeof(TCHAR));
                DestPtr+=(Next-CharPtr);
                CharPtr = Next;
            }
            if (*CharPtr == TEXT('\\')) {
                *DestPtr = TEXT('/');
                DestPtr++;
                CharPtr++;
            }
        }
        *DestPtr = TEXT('\0');

        RegSize = sizeof(LastGoodFlags);
        regres = RegQueryValueEx(hKeyLastGood,
                                 RegName,
                                 NULL,
                                 &RegType,
                                 (PBYTE)&LastGoodFlags,
                                 &RegSize);
        if((regres != NO_ERROR)
           || (RegType != REG_DWORD)
           || (RegSize != sizeof(DWORD))) {
            //
            // default action is copy
            //
            LastGoodFlags = 0;
        }
        RegCloseKey(hKeyLastGood);
    }

    //
    // base directory of target file
    //
    lstrcpyn(TempPathname, FullTargetFilename, MAX_PATH);
    *((PTSTR)pSetupGetFileTitle(TempPathname)) = TEXT('\0');

    if (LastGoodFlags & LASTGOOD_OPERATION_DELETE) {
        //
        // delete
        //
        if(GetFileAttributes(FullTargetFilename)==(DWORD)(-1)) {
            //
            // already deleted
            //
            rflag = TRUE;
            goto final;
        }

        pSetupExemptFileFromProtection(
                    FullTargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        //
        // try the simple way first
        //
        SetFileAttributes(FullTargetFilename, FILE_ATTRIBUTE_NORMAL);
        if(!DeleteFile(FullTargetFilename)) {
            //
            // can't delete target directly
            //
            if(!GetTempFileName(TempPathname, TEXT("SETP"), 0, BackupTargetFilename)) {
                //
                // can't create backup temp, nothing we can do
                //
                goto final;
            }
            //
            // move existing file into a temp backup
            //
            if(!MoveFileEx(FullTargetFilename,BackupTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                //
                // this failed too for some reason
                //
                SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(BackupTargetFilename);
                goto final;
            }
            //
            // now do something with the bad file
            // we don't care if this fails
            //
            SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
            if(!DeleteFile(BackupTargetFilename)) {
                MoveFileEx(BackupTargetFilename,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }

    } else {
        //
        // restore back to LKG file
        //

        //
        // create intermediate directories as needed as part of the restore
        //
        pSetupMakeSurePathExists(FullTargetFilename);

        //
        // create a temporary filename to copy to
        // before moving restored file into place
        //
        if(!GetTempFileName(TempPathname, TEXT("SETP"), 0, TempFilename)) {
            //
            // can't create temp, nothing we can do
            //
            goto final;
        }
        if(!CopyFile(BackupTargetFilename,TempFilename,FALSE)) {
            //
            // failed to copy to temporary file
            //
            DeleteFile(TempFilename);
            goto final;
        }
        //
        // simple case, move temporary file over existing file
        //
        pSetupExemptFileFromProtection(
                    FullTargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        SetFileAttributes(FullTargetFilename, FILE_ATTRIBUTE_NORMAL);
        if(!MoveFileEx(TempFilename,FullTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
            //
            // we failed to overwrite file, need slightly different stratagy
            //
            if(!GetTempFileName(TempPathname, TEXT("SETP"), 0, BackupTargetFilename)) {
                //
                // can't create backup temp, nothing we can do
                //
                SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(TempFilename);
                goto final;
            }
            //
            // move existing file into a temp backup
            //
            if(!MoveFileEx(FullTargetFilename,BackupTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                //
                // this failed too for some reason
                //
                SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(BackupTargetFilename);
                SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(TempFilename);
                goto final;
            }
            //
            // we moved existing file out of place, now move new file into place
            //
            if(!MoveFileEx(TempFilename,FullTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                //
                // huh? Ok, that failed, try to recover
                //
                MoveFileEx(BackupTargetFilename,FullTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);
                SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(TempFilename);
                goto final;
            }
            //
            // now do something with the bad file
            // we don't care if this fails
            //
            SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
            if(!DeleteFile(BackupTargetFilename)) {
                MoveFileEx(BackupTargetFilename,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }
    }

    //
    // done!
    //
    rflag = TRUE;

final:
    if(LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }
    return rflag;
}
#endif


#ifdef UNICODE
WINSETUPAPI
BOOL
WINAPI
SetupPrepareQueueForRestoreA(
    IN     HSPFILEQ                     QueueHandle,
    IN     PCSTR                        BackupPath,
    IN     DWORD                        RestoreFlags
    )
/*++

    See SetupPrepareQueueForRestore

--*/
{
    BOOL f;
    DWORD rc;
    PCWSTR UnicodeBackupPath;

    if(BackupPath) {
        rc = pSetupCaptureAndConvertAnsiArg(BackupPath, &UnicodeBackupPath);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    f = SetupPrepareQueueForRestore(QueueHandle,UnicodeBackupPath,RestoreFlags);
    rc = GetLastError();
    MyFree(UnicodeBackupPath);
    SetLastError(rc);
    return f;
}

#else

WINSETUPAPI
BOOL
WINAPI
SetupPrepareQueueForRestoreW(
    IN     HSPFILEQ                     QueueHandle,
    IN     PCWSTR                       BackupPath,
    IN     DWORD                        RestoreFlags
    )
/*++

    ANSI stub

--*/
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(BackupPath);
    UNREFERENCED_PARAMETER(RestoreFlags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif

WINSETUPAPI
BOOL
WINAPI
SetupPrepareQueueForRestore(
    IN     HSPFILEQ                     QueueHandle,
    IN     PCTSTR                       BackupPath,
    IN     DWORD                        RestoreFlags
    )
/*++

Routine Description:

    Initializes restore directory

Arguments:

    QueueHandle      - file queue to modify
    BackupPath       - original backup directory to use for restore
    RestoreFlags     - options

Return Value:

    TRUE if success, else FALSE

--*/
{
    BOOL b = TRUE;
    DWORD rc;
    BOOL f = FALSE;
    PSP_FILE_QUEUE Queue = (PSP_FILE_QUEUE)QueueHandle;
    LONG RestorePathID;

    //
    // validate string pointer
    //
    if(!BackupPath) {
        rc = ERROR_INVALID_PARAMETER;
        goto clean;
    }
    //
    // validate flags (currently not implemented)
    //
    if(RestoreFlags) {
        rc = ERROR_INVALID_PARAMETER;
        goto clean;
    }
    //
    // validate QueueHandle
    //
    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        rc = ERROR_INVALID_HANDLE;
        goto clean;
    }

    try {
        //
        // if a restore point has previously been set, return error
        //
        if(Queue->RestorePathID != -1) {
            rc = ERROR_ALREADY_EXISTS;
            leave;
        }
        RestorePathID = pSetupStringTableAddString(Queue->StringTable,
                                                   (PTSTR)BackupPath ,
                                                   STRTAB_CASE_SENSITIVE);
        if (RestorePathID == -1) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // done - just need to set the restore-path
        //
        Queue->RestorePathID = RestorePathID;

        WriteLogEntry(Queue->LogContext,
                      SETUP_LOG_WARNING,
                      MSG_LOG_RESTORE,
                      NULL,
                      BackupPath
                     );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_DATA;
    }

    f = TRUE;
    rc = NO_ERROR;
clean:
    //
    // no cleanup required
    //
    SetLastError(rc);
    return f;
}


#define SP_TEFLG_BITS_TO_RESET  (  SP_TEFLG_SAVED         \
                                 | SP_TEFLG_TEMPNAME      \
                                 | SP_TEFLG_ORIGNAME      \
                                 | SP_TEFLG_MODIFIED      \
                                 | SP_TEFLG_MOVED         \
                                 | SP_TEFLG_BACKUPQUEUE   \
                                 | SP_TEFLG_RESTORED      \
                                 | SP_TEFLG_UNWIND        \
                                 | SP_TEFLG_SKIPPED       \
                                 | SP_TEFLG_INUSE         \
                                 | SP_TEFLG_RENAMEEXISTING )

BOOL
pSetupResetTarget(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,        OPTIONAL
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This routine resets the SP_TARGET_ENT data stored with a string table entry
    in a file queue's TargetLookupTable.  This routine may be used as the
    callback function to iterate such entries via pSetupStringTableEnum.

Arguments:

    StringTable - Supplies a handle to the string table being enumerated

    StringId - Supplies the ID of the current string

    String - Optionally, supplies a pointer to the current string (this will
        always be filled in when this routine is used as a callback for
        pSetupStringTableEnum, but other callers may omit it, as it isn't
        needed).

    ExtraData - Supplies a pointer to the SP_TARGET_ENT data associatd with
        the string

    ExtraDataSize - Supplies the size of the buffer pointed to by ExtraData--
        should always be sizeof(SP_TARGET_ENT)

    lParam - unused

Return Value:

    This routine always returns TRUE, so that all string entries will be
    enumerated.

--*/

{
    PSP_TARGET_ENT TargetInfo;
    BOOL b;

    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(lParam);

    MYASSERT(ExtraData);
    MYASSERT(ExtraDataSize == sizeof(SP_TARGET_ENT));

    //
    // Clear the bits that will get re-generated when the queue is committed
    // again.
    //
    ((PSP_TARGET_ENT)ExtraData)->InternalFlags &= ~SP_TEFLG_BITS_TO_RESET;

    //
    // Also need to reset the NewTargetFilename
    //
    ((PSP_TARGET_ENT)ExtraData)->NewTargetFilename = -1;

    //
    // Store the modified data back to the string table entry
    //
    b = pSetupStringTableSetExtraData(StringTable,
                                      StringId,
                                      ExtraData,
                                      ExtraDataSize
                                     );
    //
    // This should never fail
    //
    MYASSERT(b);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\cntxtlog.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cntxtlog.c

Abstract:

    This module implements more logging for setupapi

Author:

    Gabe Schaffer (t-gabes) 25-Jun-1998

Revision History:

    Jamie Hunter (jamiehun) Apr 11 2000 - added #xnnnn identifiers
    Jamie Hunter (jamiehun) Feb 2 2000  - cleanup
    Jamie Hunter (jamiehun) Aug 31 1998

--*/

#include "precomp.h"
#pragma hdrstop

//
// global data used by logging
//

struct _GlobalLogData {

    CRITICAL_SECTION CritSec;
    BOOL             DoneInitCritSec;
    LONG             UID;
    ULONG            Flags;
    PTSTR            FileName;

} GlobalLogData;

#define LogLock()          EnterCriticalSection(&GlobalLogData.CritSec)
#define LogUnlock()        LeaveCriticalSection(&GlobalLogData.CritSec)

// process-wide log counter
//
// C = critical
// E = error
// W = warning
// I = information
// V = verbose
// T = timing
// * = currently undefined
//
static const TCHAR LogLevelShort[17] = TEXT("CEWIVTTV********");
#define LOGLEVELSHORT_MASK (0x0f)
#define LOGLEVELSHORT_INIT (0x100)
#define LOGLEVELSHORT_SHIFT (4)


__inline // we want to always optimize this out
BOOL
_WouldNeverLog(
    IN DWORD Level
    )

/*++

Routine Description:

    Determines if at the current logging level and the required level, we would never log
    inline'd for optimization (used only in this file)


Arguments:

    Level - only required to check for special case of 0.

Return Value:

    TRUE if we know we would never log based on passed information

--*/

{

    if (Level == 0) {
        //
        // don't-log level
        //
        return TRUE;
    }

    if (((GlobalLogData.Flags & SETUP_LOG_LEVELMASK) <= SETUP_LOG_NOLOG)
        &&((GlobalLogData.Flags & DRIVER_LOG_LEVELMASK) <= DRIVER_LOG_NOLOG)) {
        //
        // Global flags indicate do no logging at all
        //
        return TRUE;
    }

    return FALSE;
}

__inline // we want to always optimize this out
BOOL
_WouldLog(
    IN DWORD Level
    )

/*++

Routine Description:

    Determines if at the current logging level and the required level, we would log
    inline'd for optimization (used only in this file)

    Note that if _WouldNeverLog is TRUE, _WouldLog is always FALSE
    if _WouldLog is TRUE, _WouldNeverLog is always FALSE
    if both are FALSE, then we are on "maybe"

Arguments:

    Level - bitmask indicating logging flags. See SETUP_LOG_* and DRIVER_LOG_*
        at the beginning of cntxtlog.h for details. It may also be a slot
        returned by AllocLogInfoSlot, or 0 (no logging)

Return Value:

    TRUE if we know we would log

--*/

{

    if (_WouldNeverLog(Level)) {
        //
        // some simple tests (LogLevel==NULL is a not sure case)
        //
        return FALSE;
    }

    if ((Level & SETUP_LOG_IS_CONTEXT)!=0) {
        //
        // context logging - ignored here (a not sure case)
        //
        return FALSE;
    }

    //
    // determine logability
    //
    if ((Level & SETUP_LOG_LEVELMASK) > 0 && (Level & SETUP_LOG_LEVELMASK) <= (GlobalLogData.Flags & SETUP_LOG_LEVELMASK)) {
        //
        // we're interested in logging - raw error level
        //
        return TRUE;
    }
    if ((Level & DRIVER_LOG_LEVELMASK) > 0 && (Level & DRIVER_LOG_LEVELMASK) <= (GlobalLogData.Flags & DRIVER_LOG_LEVELMASK)) {
        //
        // we're interested in logging - driver error level
        //
        return TRUE;
    }

    return FALSE;
}

VOID
UnMapLogFile(
    IN PSTR baseaddr,
    IN HANDLE hLogfile,
    IN HANDLE hMapping,
    IN BOOL seteof
    )

/*++

Routine Description:

    Unmap, possibly unlock, maybe set the EOF, and close a file.  Note, setting
    EOF must occur after unmapping.

Arguments:

    baseaddr - this is the address where the file is mapped.  It must be what
        was returned by MapLogFile.

    hLogfile - this is the Win32 handle for the log file.

    hMapping - this is the Win32 handle to the mapping object.

    seteof - Boolean value indicating whether the EOF should be set to the
        current file pointer.  If the EOF is set and the file pointer has not
        been moved, the EOF will be set at byte 0, thus truncating the file
        to 0 bytes.

Return Value:

    NONE.

--*/

{
    DWORD success;

    //
    // we brute-force try to close everything up
    //

    try {
        if (baseaddr != NULL) {
            success = UnmapViewOfFile(baseaddr);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }

    try {
        if (hMapping != NULL) {
            //
            // hMapping uses NULL to indicate a problem
            //
            success = CloseHandle(hMapping);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }

    try {
        if (hLogfile != INVALID_HANDLE_VALUE && seteof) {
            success = SetEndOfFile(hLogfile);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }

    try {
        if (hLogfile != INVALID_HANDLE_VALUE) {
            if (!(GlobalLogData.Flags & SETUP_LOG_NOFLUSH)) {
                FlushFileBuffers(hLogfile);
            }
            success = CloseHandle(hLogfile);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }
    //
    // Win9x provides no way to wait for a file to become unlocked, so we
    // have to poll. Putting this Sleep(0) allows others to have a chance
    // at the file.
    //
    Sleep(0);
}

VOID
WriteLogFileHeader(
    IN HANDLE hLogFile
    )
/*++

Routine Description:

    Write general information at start of log file

    [SetupAPI Log]
    OS Version = %1!u!.%2!u!.%3!u! %4!s!
    Platform ID = %5!u!
    Service Pack = %6!u!.%7!u!
    Suite = 0x%8!04x!
    Product Type = %9!u!

Arguments:

    hLogfile - file to write header to

Return Value:

    NONE

--*/
{
#ifdef UNICODE
    OSVERSIONINFOEX VersionInfo;
#else
    OSVERSIONINFO VersionInfo;
#endif
    DWORD count;
    DWORD written;
    PTSTR buffer;
    PSTR ansibuffer;
    ULONG_PTR args[14];
    DWORD MessageId = MSG_LOGFILE_HEADER_OTHER;

    ZeroMemory(&VersionInfo,sizeof(VersionInfo));
#ifdef UNICODE
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if(!GetVersionEx((POSVERSIONINFO)&VersionInfo)) {
        VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if(!GetVersionEx((POSVERSIONINFO)&VersionInfo)) {
            return;
        }
    }
#else
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx((POSVERSIONINFO)&VersionInfo)) {
        return;
    }
#endif

    args[1] = (ULONG_PTR)VersionInfo.dwMajorVersion;
    args[2] = (ULONG_PTR)VersionInfo.dwMinorVersion;
    args[4] = (ULONG_PTR)VersionInfo.szCSDVersion;   // string
    args[5] = (ULONG_PTR)VersionInfo.dwPlatformId;
    if(VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        args[3] = (ULONG_PTR)VersionInfo.dwBuildNumber;
#ifdef UNICODE
        MessageId = MSG_LOGFILE_HEADER_NT;
#endif
    } else {
        args[3] = (ULONG_PTR)LOWORD(VersionInfo.dwBuildNumber); // Win9x re-uses high word
    }
#ifdef UNICODE
    args[6] = (ULONG_PTR)VersionInfo.wServicePackMajor;
    args[7] = (ULONG_PTR)VersionInfo.wServicePackMinor;
    args[8] = (ULONG_PTR)VersionInfo.wSuiteMask;
    args[9] = (ULONG_PTR)VersionInfo.wProductType;
    args[10] = (ULONG_PTR)pszPlatformName;
#endif

    count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY|FORMAT_MESSAGE_FROM_HMODULE,
                          MyDllModuleHandle,
                          MessageId,
                          0,
                          (LPTSTR) &buffer,
                          0,
                          (va_list*)(args+1));
    if (count && buffer) {
#ifdef UNICODE
        ansibuffer = pSetupUnicodeToMultiByte(buffer,CP_ACP);
        if (ansibuffer) {
            WriteFile(hLogFile,ansibuffer,strlen(ansibuffer),&written,NULL);
            MyFree(ansibuffer);
        }
#else
        WriteFile(hLogFile,buffer,strlen(buffer),&written,NULL);
#endif
        LocalFree(buffer);
    }
}

DWORD
MapLogFile(
    IN PCTSTR FileName,
    OUT PHANDLE hLogfile,
    OUT PHANDLE hMapping,
    OUT PDWORD dwFilesize,
    OUT PSTR *mapaddr,
    IN DWORD extrabytes
    )

/*++

Routine Description:

    Open the log file for writing and memory map it.  On NT the file is locked,
    but Win9x doesn't allow memory mapped access to locked files, so the file
    is opened without FILE_SHARE_WRITE access.  Since CreateFile won't block
    like LockFileEx, we have to poll once per second on Win9x until the file
    opens.

Arguments:

    FileName - supplies path name to the log file.

    hLogfile - receives the Win32 file handle for the log file.

    hMapping - receives the Win32 handle to the mapping object.

    dwFileSize - receives the size of the file before it is mapped, because
        mapping increases the size of the file by extrabytes.

    mapaddr - receives the address of where the log file is mapped.

    extrabytes - supplies the number of extra bytes (beyond the size of the
        file) to add to the size of the mapping object to allow for appending
        the new log line and possibly a section header.

Return Value:

    NO_ERROR if the file is successfully opened and mapped.  The caller must
    call UnMapLogFile when finished with the file.

    Win32 error code if the file is not open.

--*/

{
    HANDLE logfile = INVALID_HANDLE_VALUE;
    HANDLE mapping = NULL;
    DWORD filesize = 0;
    DWORD lockretrywait = 1;
    DWORD wait_total = 0;
    PSTR baseaddr = NULL;
    DWORD retval = ERROR_INVALID_PARAMETER;

    //
    // wrap it all up in a nice big try/except, because you just never know
    //
    try {

        //
        // give initial "failed" values
        // this also validates the pointers
        //
        *hLogfile = logfile;
        *hMapping = mapping;
        *dwFilesize = filesize;
        *mapaddr = baseaddr;

        do {
            //
            // retry here, in case lock fails
            //
            logfile = CreateFile(
                FileName,
                GENERIC_READ | GENERIC_WRITE,   // access mode
                FILE_SHARE_READ,
                NULL,                           // security
                OPEN_ALWAYS,                    // open, or create if not already there
                //FILE_FLAG_WRITE_THROUGH,        // flags - ensures that if machine crashes in the next operation, we are still logged
                0,
                NULL);                          // template

            if (logfile == INVALID_HANDLE_VALUE) {
                retval = GetLastError();
                if (retval != ERROR_SHARING_VIOLATION) {
                    MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Could not create file %s. Error %d\n"), FileName, retval));
                    leave;
                }
                if(wait_total >= MAX_LOG_WAIT) {
                    MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Given up waiting for log file %s.\n"), FileName));
                    leave;
                }
                //
                // don't want to wait more than a second at a time
                //
                if (lockretrywait < MAX_LOG_INTERVAL) {
                    lockretrywait *= 2;
                }
                MYTRACE((DPFLTR_WARNING_LEVEL, TEXT("Setup: Could not open file. Error %d; waiting %ums\n"), GetLastError(), lockretrywait));

                Sleep(lockretrywait);
                wait_total += lockretrywait;
            }
        } while (logfile == INVALID_HANDLE_VALUE);

        //
        // this will NOT work with files >= 4GB, but it's not supposed to
        //
        filesize = GetFileSize(logfile,NULL);

        if (filesize == 0) {
            //
            // fill some OS information into file
            //
            WriteLogFileHeader(logfile);
            filesize = GetFileSize(logfile,NULL);
        }

        //
        // make the mapping object with extra space to accomodate the new log entry
        //
        mapping = CreateFileMapping(
            logfile,            // file to map
            NULL,               // security
            PAGE_READWRITE,     // protection
            0,                  // maximum size high
            filesize + extrabytes,      // maximum size low
            NULL);              // name

        if (mapping != NULL) {
            //
            // NULL isn't a bug, CreateFileMapping returns this
            // to indicate error, instead of INVALID_HANDLE_VALUE
            //

            //
            // now we have a section object, so attach it to the log file
            //
            baseaddr = (PSTR) MapViewOfFile(
                mapping,                // file mapping object
                FILE_MAP_ALL_ACCESS,    // desired access
                0,                      // file offset high
                0,                      // file offset low
                0);                     // number of bytes to map (0 = whole file)
        }
        else {
            retval = GetLastError();
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Could not create mapping. Error %d\n"), retval));
            leave;
        }

        if (baseaddr == NULL) {
            //
            // either the mapping object couldn't be created or
            // the file couldn't be mapped
            //
            retval = GetLastError();
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Could not map file. Error %d\n"), retval));
            leave;
        }

        //
        // now put everything where the caller can see it, but make sure we clean
        // up first
        //
        *hLogfile = logfile;
        *hMapping = mapping;
        *dwFilesize = filesize;
        *mapaddr = baseaddr;

        retval = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // something bad happened, probably an AV, so just dump everything
        // and return an error meaning "Attempt to access invalid address."
        //
    }

    if (retval != NO_ERROR) {
        //
        // an error occurred, cleanup what we need to
        //
        UnMapLogFile(baseaddr, logfile, mapping, FALSE);
    }

    return retval;
}

BOOL
IsSectionHeader(
    IN PCSTR Header,
    IN DWORD Size,
    IN PCSTR Beginning
    )

/*++

Routine Description:

    Determines whether a given string starts with a section header.  This is
    the routine that essentially defines what a valid section header is.

Arguments:

    Header - supplies a pointer to what may be the first character in a header.

    Size - supplies the length of the string passed in, which is NOT the size
        of the header.

    Beginning - supplies a pointer to the beginning of the file.

Return Value:

    BOOL indicating if Header points to a valid section header.

--*/

{
    //
    // assume a header looks like [foobar]\r\n
    //
    DWORD i;
    //
    // state holds the value we're looking for
    UINT state = '[';

    //
    // a section header must always be either at the start of a line or at
    // the beginning of a file
    //
    if (Header != Beginning && Header[-1] != '\n')
        return FALSE;

    for (i = 0; i < Size; i++) {
        switch (state) {
        case '[':
            if (Header[i] == '[') {
                state = ']';
            } else {
                return FALSE;
            }
            break;

        case ']':
            if (Header[i] == ']') {
                state = '\r';
            }
            break;

        case '\r':
            if (Header[i] == '\r') {
                state = '\n';
            //
            // allow for the case where a line has a linefeed, but no CR
            //
            } else if (Header[i] == '\n') {
                return TRUE;
            } else {
                return FALSE;
            }
            break;

        case '\n':
            if (Header[i] == '\n') {
                return TRUE;
            } else {
                return FALSE;
            }
            //
            // break; -- commented out to avoid unreachable code error
            //
        default:
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Invalid state! (%d)\n"), state));
            MYASSERT(0);
        }
    }

    return FALSE;
}

BOOL
IsEqualSection(
    IN PCSTR Section1,
    IN DWORD Len1,
    IN PCSTR Section2,
    IN DWORD Len2
    )

/*++

Routine Description:

    Says whether two ANSI strings both start with the same section header.  One of
    the strings must be just a section header, while the other one may be
    anything, such as the entire log file.

Arguments:

    Section1 - supplies the address of the first string.

    Len1 - supplies the length of the first string.

    Section2 - supplies the address of the second string.

    Len2 - supplies the length of the second string.

Return Value:

    BOOL indicating if the longer string starts with the shorter string.

--*/

{
    //
    // maxlen is the maximum length that both strings could be, and still be
    // the same section name
    //
    DWORD maxlen = Len2;

    if (Len1 < Len2) {
        maxlen = Len1;
    }

    if (_strnicmp(Section1, Section2, maxlen) == 0) {
        //
        // they're the same (ignoring case)
        //
        return TRUE;
    }

    return FALSE;
}

DWORD
AppendLogEntryToSection(
    IN PCTSTR FileName,
    IN PCSTR Section,
    IN PCSTR Entry,
    IN BOOL SimpleAppend
    )

/*++

Routine Description:

    Opens the log file, finds the appropriate section, moves it to the end of
    the file, appends the new entry, and closes the file.

Arguments:

    FileName - supplies the path name of the log file.

    Section - supplies the ANSI name of the section to be logged to.

    Entry - supplies the ANSI string to be logged.

    SimpleAppend - specifies whether entries will simply be appended to the log
        file or appended to the section where they belong.

Return Value:

    NO_ERROR if the entry gets written to the log file.

    Win32 error or exception code if anything went wrong.

--*/

{
    DWORD retval = NO_ERROR;
    DWORD fpoff;
    HANDLE hLogfile = INVALID_HANDLE_VALUE;
    HANDLE hMapping = NULL;
    DWORD filesize = 0;
    PSTR baseaddr = NULL;
    DWORD sectlen = lstrlenA(Section);
    DWORD entrylen = lstrlenA(Entry);
    DWORD error;
    BOOL seteof = FALSE;
    BOOL mapped = FALSE;
    PSTR eof;
    PSTR curptr;
    PSTR lastsect = NULL;

    try {
        MYASSERT(Section != NULL && Entry != NULL);

        sectlen = lstrlenA(Section);
        entrylen = lstrlenA(Entry);
        if (sectlen == 0 || entrylen == 0) {
            //
            // not an error as such, but not useful either
            //
            retval = NO_ERROR;
            leave;
        }

        error = MapLogFile(
                    FileName,
                    &hLogfile,
                    &hMapping,
                    &filesize,
                    &baseaddr,
                    sectlen + entrylen + 8);// add some extra space to the mapping
                                            // to take into account the log entry
                                            // +2 to terminate unterminated last line
                                            // +2 to append CRLF or ": " after section
                                            // +2 to append CRLF after entrylen if req
                                            // +2 for good measure
        if (error != NO_ERROR) {
            //
            // could not map file
            //
            retval = error;
            leave;
        }

        mapped = TRUE;

        eof = baseaddr + filesize; // end of file, as of now
        curptr = eof;

        while (curptr > baseaddr && (curptr[-1]==0 || curptr[-1]==0x1A)) {
            //
            // eat up trailing Nul's or ^Z's
            // the former is a side-effect of mapping
            // the latter could be introduced by an editor
            //
            curptr --;
            eof = curptr;
        }
        if (eof > baseaddr && eof[-1] != '\n') {
            //
            // make sure file already ends in LF
            // if it doesn't, append a CRLF
            //
            memcpy(eof, "\r\n", 2);
            eof += 2;
        }
        if (SimpleAppend) {
            //
            // instead of having a regular section header, the section name is
            // placed at the beginning of each log line followed by a colon.
            // this is particularly only of interest when debugging the logging functions
            //
            memcpy(eof, Section, sectlen);
            eof += sectlen;
            memcpy(eof, ": ", 2);
            eof += 2;

        } else {
            //
            // the entry must be appended to the correct section in the log,
            // which requires finding the section and moving it to the end of
            // the file if required.
            //
            // search backwards in the file, looking for the section header
            //
            if (eof == baseaddr) {
                //
                // truncated (empty) file
                //
                curptr = NULL;
            } else {
                curptr = eof - 1;

                while(curptr > baseaddr) {
                    //
                    // scan for section header a line at a time
                    // going backwards, since our section should be near end
                    //
                    if (curptr[-1] == '\n') {
                        //
                        // speed optimization: only bother checking if we think we're at the beginning of a new line
                        // this may find a '\n' that is part of a MBCS char,
                        // but should be eliminated by IsSectionHeader check
                        //
                        if (IsSectionHeader(curptr, (DWORD)(eof - curptr), baseaddr)) {
                            //
                            // looks like a section header, now see if it's the one we want
                            //
                            if (IsEqualSection(curptr, (DWORD)(eof - curptr), Section, sectlen)) {
                                //
                                // yep - done
                                //
                                break;
                            } else {
                                //
                                // will eventually be the section after the one of interest
                                //
                                lastsect = curptr;
                            }
                        }
                    }
                    curptr --;
                }
                if (curptr == baseaddr) {
                    //
                    // final check if we got to the beginning of the file (no find)
                    //
                    if (IsSectionHeader(curptr, (DWORD)(eof - curptr), baseaddr)) {
                        //
                        // the first line should always be a section header
                        //
                        if (!IsEqualSection(curptr, (DWORD)(eof - curptr), Section, sectlen)) {
                            //
                            // first section isn't the one of interest
                            // so therefore we couldn't find it
                            //
                            curptr = NULL;
                        }
                    }
                }
            }
            if (curptr == NULL) {
                //
                // no matching section found (or file was empty)
                // copy the section header to the end of the file
                // eof is known to be actual end of file
                //
                memcpy(eof, Section, sectlen);
                eof += sectlen;
                memcpy(eof, "\r\n", 2);
                eof += 2;

            } else if (lastsect != NULL) {
                //
                // we have to rearrange the sections, as we have a case as follows:
                //
                // ....
                // ....
                // (curptr) [section A]     = section of interest
                // ....
                // ....
                // (lastsect) [section B]   = section after section of interest
                // ....
                // ....
                //
                // we want to move the text between curptr and lastsect to end of file
                //
                PSTR buffer = MyMalloc((DWORD)(lastsect - curptr));

                if (buffer) {
                    // first copy the important section to the buffer
                    //
                    memcpy(buffer, curptr, (size_t)(lastsect - curptr));
                    //
                    // now move the rest of the thing back
                    //
                    memcpy(curptr, lastsect, (size_t)(eof - lastsect));
                    //
                    // put the important section at the end where it belongs
                    //
                    memcpy(curptr - lastsect + eof, buffer, (size_t)(lastsect - curptr));

                    MyFree(buffer);

                } else {
                    //
                    // For some reason, we cannot allocate enough memory.
                    //
                    // There are 4 options here:
                    // 1. Do nothing; this will cause the entry to be appended to
                    //    the file, but as part of the wrong section.
                    // 2. Bail; this will cause the log entry to get lost.
                    // 3. Create a second file to contain a temporary copy of the
                    //    section; this will require creating another file, and
                    //    then deleting it.
                    // 4. Extend the mapping of the current file to be big enough
                    //    to hold another copy of the section; this will cause the
                    //    file to have a lot of 0s or possibly another copy of the
                    //    section, should the machine crash during the processing.
                    //
                    // we do option 2 - BAIL!
                    //
                    retval = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }
            }
        }

        //
        // now append the log entry
        //
        memcpy(eof, Entry, entrylen);
        eof += entrylen;
        if (eof[-1] != '\n') {
            //
            // entry did not supply en end of line, so we will
            //
            memcpy(eof, "\r\n", 2);
            eof += 2;
        }
        //
        // because of the memory mapping, the file size will not be correct,
        // so set the pointer to where we think the end of file is, and then
        // the real EOF will be set after unmapping, but before closing
        //
        fpoff = SetFilePointer(
            hLogfile,           // handle of file
            (LONG)(eof - baseaddr), // number of bytes to move file pointer
            NULL,               // pointer to high-order DWORD of
                                // distance to move
            FILE_BEGIN);        // how to move

        if (fpoff == (DWORD)(-1) && (error = GetLastError()) != NO_ERROR) {
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: SFP returned %u; eof = %u\n"), error, (eof - baseaddr)));
            retval = error;
            leave;
        }
        seteof = TRUE;
        retval = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // invalid data
        //
        retval = ERROR_INVALID_DATA;
    }

    //
    // unmap
    //
    if (mapped) {
        UnMapLogFile(baseaddr, hLogfile, hMapping, seteof);
    }

    return retval;
}

VOID
WriteLogSectionEntry(
    IN PCTSTR FileName,
    IN PCTSTR Section,
    IN PCTSTR Entry,
    IN BOOL SimpleAppend
    )

/*++

Routine Description:

    Convert parameters to ANSI, then append an entry to a given section of the
    log file.

Arguments:

    FileName - supplies the path name of the log file.

    Section - supplies the name of section.

    Entry - supplies the string to append to section.

    SimpleAppend - specifies whether entries will simply be appended to the log
        file or appended to the section where they belong.

Return Value:

    NONE.

--*/

{
    PCSTR ansiSection = NULL;
    PCSTR ansiEntry = NULL;

    try {
        MYASSERT(Section != NULL && Entry != NULL);

#ifdef UNICODE
        ansiSection = pSetupUnicodeToMultiByte(Section, CP_ACP);
        ansiEntry = pSetupUnicodeToMultiByte(Entry, CP_ACP);

        if(!ansiSection || !ansiEntry) {
            leave;
        }
#else
        ansiSection = Section;
        ansiEntry = Entry;
#endif

        AppendLogEntryToSection(
            FileName,
            ansiSection,
            ansiEntry,
            SimpleAppend);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // invalid data
        //
    }
#ifdef UNICODE
    if (ansiSection != NULL) {
        MyFree(ansiSection);
    }
    if (ansiEntry != NULL) {
        MyFree(ansiEntry);
    }
#endif

}

DWORD
MakeUniqueName(
    IN  PCTSTR Component,        OPTIONAL
    OUT PTSTR * UniqueString
    )

/*++

Routine Description:

    Create a section name that's unique by using a timestamp.
    If Component is supplied, append that to the timestamp.

Arguments:

    Component - supplies a string to be included in the unique name.
    UniqueString - supplies a pointer to be set with return string

Return Value:

    Error status

--*/

{
    SYSTEMTIME now;
    LPTSTR buffer = NULL;
    DWORD status = ERROR_INVALID_DATA;
    ULONG sz;
    LONG UID;

    try {
        if (UniqueString == NULL) {
            //
            // invalid param
            //
            status = ERROR_INVALID_PARAMETER;
            leave;
        }
        *UniqueString = NULL;

        if (Component == NULL) {
            //
            // treat as empty string
            //
            Component = TEXT("");
        }

        UID = InterlockedIncrement(&(GlobalLogData.UID)); // returns a new ID value whenever called, ensures uniqueness per process

        //
        // calculate how big string is going to be, be generous (see wsprintf below)
        //
        sz = /*[] and padding*/ 4 /*date*/ +5+3+3 /*time*/ +3+3+3 /*PID*/ +12 /*UID*/ +12 /*Component*/ +1+lstrlen(Component);
        buffer = MyTaggedMalloc(sz * sizeof(TCHAR),MEMTAG_LCSECTION);
        if (buffer == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        GetLocalTime(&now);

        wsprintf(buffer, TEXT("[%04d/%02d/%02d %02d:%02d:%02d %u.%u%s%s]"),
            now.wYear, now.wMonth, now.wDay,
            now.wHour, now.wMinute, now.wSecond,
            (UINT)GetCurrentProcessId(),
            (UINT)UID,
            (Component[0] ? TEXT(" ") : TEXT("")),
            Component);

        *UniqueString = buffer;
        buffer = NULL;

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // status remains ERROR_INVALID_DATA
        //
    }

    if (buffer != NULL) {
        MyTaggedFree(buffer,MEMTAG_LCSECTION);
    }

    return status;
}

DWORD
CreateLogContext(
    IN  PCTSTR SectionName,              OPTIONAL
    IN  BOOL UseDefault,
    OUT PSETUP_LOG_CONTEXT *LogContext
    )

/*++

Routine Description:

    Creates and initializes a SETUP_LOG_CONTEXT struct.

Arguments:

    SectionName - supplies an initial string to be used as part of the
        section name.

    LogContext - supplies a pointer to where the pointer to the allocated
        SETUP_LOG_CONTEXT should be stored.

Return Value:

    NO_ERROR in case of successful structure creation.

    Win32 error code in case of error.

--*/

{
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD status = ERROR_INVALID_DATA;
    DWORD rc;

    try {

        if (LogContext == NULL) {
            status = ERROR_INVALID_PARAMETER;
            leave;
        }

        *LogContext = NULL;

        if (UseDefault) {
            lc = GetThreadLogContext();
            RefLogContext(lc);
        }
        if (!lc) {
            lc = (PSETUP_LOG_CONTEXT) MyTaggedMalloc(sizeof(SETUP_LOG_CONTEXT),MEMTAG_LOGCONTEXT);
            if (lc == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }
            //
            // all fields start out at 0
            //
            ZeroMemory(lc, sizeof(SETUP_LOG_CONTEXT));
            lc->RefCount = 1;
            lc->ContextInfo = NULL;
            lc->ContextIndexes = NULL;
            lc->ContextBufferSize = 0;
            lc->ContextLastUnused = -1;
            lc->ContextFirstUsed = -1;
            lc->ContextFirstAuto = -1;

            rc = MakeUniqueName(SectionName,&(lc->SectionName));
            if (rc != NO_ERROR) {
                status = rc;
                leave;
            }
        }
        *LogContext = lc;

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // status remains ERROR_INVALID_DATA
        //
    }

    if (status != NO_ERROR) {
        if (lc != NULL) {
            DeleteLogContext(lc);
            lc = NULL;
        }
    }

    return status;
}

DWORD
AllocLogInfoSlotOrLevel(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN DWORD              Level,
    IN BOOL               AutoRelease
    )
/*++

Routine Description:

    Obtain a new context stack entry for a context string only if current logging level is less verbose than specified
    Eg, if we specified DRIVER_LOG_VERBOSE, we will either return DRIVER_LOG_VERBOSE (if we would log it) or a slot
    if we would not normally log it.

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    Level - logging level we want to always log the information at
    AutoRelease - if set, will release the context when dumped

Return Value:

    Slot value to pass to logging functions, or a copy of Level
    note that if there is an error, 0 is returned
    return value can always be passed to ReleaseLogInfoSlot

--*/
{
    if((LogContext == NULL) || _WouldNeverLog(Level)) {
        //
        // when 0 get's passed to logging functions, it will exit out very quickly
        //
        return 0;
    }
    if(_WouldLog(Level)) {
        //
        // Level specifies a verbosity level that would cause logging
        //
        return Level;
    } else {
        //
        // interestingly enough, we will also get here if Level is a slot
        // this is what we want
        //
        return AllocLogInfoSlot(LogContext,AutoRelease);
    }
}

DWORD
AllocLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN BOOL               AutoRelease
    )
/*++

Routine Description:

    Obtain a new context stack entry for a context string

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    AutoRelease - if set, will release the context when dumped

Return Value:

    Slot value to pass to logging functions
    note that if there is an error, 0 is returned
    which may be safely used (means don't log)

--*/
{
    DWORD retval = 0;
    LPVOID newbuffer;
    int newsize;
    int newitem;
    BOOL locked = FALSE;

    if (LogContext == NULL) {

        //
        // if they pass no LogContext - duh!
        //
        return 0;
    }

    if (((GlobalLogData.Flags & SETUP_LOG_LEVELMASK) <= SETUP_LOG_NOLOG)
        &&((GlobalLogData.Flags & DRIVER_LOG_LEVELMASK) <= DRIVER_LOG_NOLOG)) {
        //
        // no logging, period! Don't waste time in locked code
        //
        return 0;
    }



    try {
        LogLock();
        locked = TRUE;

        if (LogContext->ContextLastUnused < 0) {
            //
            // need to allocate more
            //
            if (LogContext->ContextBufferSize >= SETUP_LOG_CONTEXTMASK) {
                //
                // too many contexts
                //
                leave;
            }
            //
            // need to (re)alloc buffer
            //
            newsize = LogContext->ContextBufferSize+10;

            if (LogContext->ContextInfo) {
                newbuffer = MyTaggedRealloc(LogContext->ContextInfo,sizeof(PTSTR)*(newsize),MEMTAG_LCINFO);
            } else {
                newbuffer = MyTaggedMalloc(sizeof(PTSTR)*(newsize),MEMTAG_LCINFO);
            }
            if (newbuffer == NULL) {
                leave;
            }
            LogContext->ContextInfo = (PTSTR*)newbuffer;

            if (LogContext->ContextIndexes) {
                newbuffer = MyTaggedRealloc(LogContext->ContextIndexes,sizeof(UINT)*(newsize),MEMTAG_LCINDEXES);
            } else {
                newbuffer = MyTaggedMalloc(sizeof(UINT)*(newsize),MEMTAG_LCINDEXES);
            }
            if (newbuffer == NULL) {
                leave;
            }
            LogContext->ContextIndexes = (UINT*)newbuffer;
            LogContext->ContextLastUnused = LogContext->ContextBufferSize;
            LogContext->ContextBufferSize ++;
            while(LogContext->ContextBufferSize < newsize) {
                LogContext->ContextIndexes[LogContext->ContextBufferSize-1] = LogContext->ContextBufferSize;
                LogContext->ContextBufferSize ++;
            }
            LogContext->ContextIndexes[LogContext->ContextBufferSize-1] = -1;
        }

        newitem = LogContext->ContextLastUnused;
        LogContext->ContextLastUnused = LogContext->ContextIndexes[newitem];

        if(AutoRelease) {
            if (LogContext->ContextFirstAuto<0) {
                //
                // first auto-release context item
                //
                LogContext->ContextFirstAuto = newitem;
            } else {
                int lastitem = LogContext->ContextFirstAuto;
                while (LogContext->ContextIndexes[lastitem]>=0) {
                    lastitem = LogContext->ContextIndexes[lastitem];
                }
                LogContext->ContextIndexes[lastitem] = newitem;
            }
        } else {
            if (LogContext->ContextFirstUsed<0) {
                //
                // first context item
                //
                LogContext->ContextFirstUsed = newitem;
            } else {
                int lastitem = LogContext->ContextFirstUsed;
                while (LogContext->ContextIndexes[lastitem]>=0) {
                    lastitem = LogContext->ContextIndexes[lastitem];
                }
                LogContext->ContextIndexes[lastitem] = newitem;
            }
        }
        LogContext->ContextIndexes[newitem] = -1;   // init
        LogContext->ContextInfo[newitem] = NULL;

        retval = (DWORD)(newitem) | SETUP_LOG_IS_CONTEXT;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
        retval = 0;
    }

    if(locked) {
        LogUnlock();
    }

    //
    // returns a logging flag (SETUP_LOG_IS_CONTEXT | n) or 0
    //
    return retval;
}

VOID
ReleaseLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    DWORD Slot
    )
/*++

Routine Description:

    Releases (non auto-release) slot previously obtained

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    Slot - supplies Slot value returned by AllocLogInfoSlot

Return Value:

    none

--*/
{
    int item;
    int lastitem;
    BOOL locked = FALSE;

    if ((Slot & SETUP_LOG_IS_CONTEXT) == 0) {
        //
        // GetLogContextMark had failed, value wasn't set, or not a context log
        //
        return;
    }
    MYASSERT(LogContext != NULL);


    try {
        LogLock();
        locked = TRUE;
        //
        // log context must have been supplied
        //

        item = (int)(Slot & SETUP_LOG_CONTEXTMASK);

        MYASSERT(item >= 0);
        MYASSERT(item < LogContext->ContextBufferSize);
        MYASSERT(LogContext->ContextFirstUsed >= 0);

        //
        // remove item out of linked list
        //

        if (item == LogContext->ContextFirstUsed) {
            //
            // removing first in list
            //
            LogContext->ContextFirstUsed = LogContext->ContextIndexes[item];
        } else {
            lastitem = LogContext->ContextFirstUsed;
            while (lastitem >= 0) {
                if (LogContext->ContextIndexes[lastitem] == item) {
                    LogContext->ContextIndexes[lastitem] = LogContext->ContextIndexes[item];
                    break;
                }
                lastitem = LogContext->ContextIndexes[lastitem];
            }
        }

        //
        // drop a string that hasn't been output
        //

        if (LogContext->ContextInfo[item] != NULL) {
            MyTaggedFree(LogContext->ContextInfo[item],MEMTAG_LCBUFFER);
            LogContext->ContextInfo[item] = NULL;
        }

        //
        // add item into free list
        //

        LogContext->ContextIndexes[item] = LogContext->ContextLastUnused;
        LogContext->ContextLastUnused = item;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
    }

    if(locked) {
        LogUnlock();
    }

}

VOID
ReleaseLogInfoList(
    IN     PSETUP_LOG_CONTEXT LogContext,
    IN OUT PINT               ListStart
    )
/*++

Routine Description:

    Releases whole list of slots
    Helper function. Caller must have exclusive access to LogContext

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    ListStart - pointer to list index

Return Value:

    none

--*/
{
    int item;

    MYASSERT(ListStart);

    try {
        if (*ListStart < 0) {
            //
            // list is empty
            //
            leave;
        }

        //
        // log context must have been supplied
        //

        MYASSERT(LogContext != NULL);

        while (*ListStart >= 0) {
            item = *ListStart;                                  // item we're about to release
            MYASSERT(item < LogContext->ContextBufferSize);
            *ListStart = LogContext->ContextIndexes[item];      // next item on list (we're going to trash this index)

            if (LogContext->ContextInfo[item] != NULL) {
                MyTaggedFree(LogContext->ContextInfo[item],MEMTAG_LCBUFFER);          // release string if still allocated
                LogContext->ContextInfo[item] = NULL;
            }

            //
            // add to free list
            //
            LogContext->ContextIndexes[item] = LogContext->ContextLastUnused;
            LogContext->ContextLastUnused = item;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
    }
}

VOID
DeleteLogContext(
    IN PSETUP_LOG_CONTEXT LogContext
    )

/*++

Routine Description:

    Decrement ref count of LogContext, and delete if zero.

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to be deleted.

Return Value:

    NONE.

--*/

{
    BOOL locked = FALSE;

    if (!LogContext) {
        return;
    }


    try {
        LogLock();
        locked = TRUE;

        //
        // check ref count
        //
        MYASSERT(LogContext->RefCount > 0);
        if (--LogContext->RefCount) {
            leave;
        }

        //
        // we can unlock now, since we have exclusive access to this context (it is unowned)
        // and we don't want to hold global lock longer than needed
        //
        LogUnlock();
        locked = FALSE;
        ReleaseLogInfoList(LogContext,&LogContext->ContextFirstAuto);
        ReleaseLogInfoList(LogContext,&LogContext->ContextFirstUsed);

        if (LogContext->SectionName) {
            MyTaggedFree(LogContext->SectionName,MEMTAG_LCSECTION);
        }

        if (LogContext->Buffer) {
            MyTaggedFree(LogContext->Buffer,MEMTAG_LCBUFFER);
        }

        if (LogContext->ContextInfo) {
            MyTaggedFree(LogContext->ContextInfo,MEMTAG_LCINFO);
        }

        if (LogContext->ContextIndexes) {
            MyTaggedFree(LogContext->ContextIndexes,MEMTAG_LCINDEXES);
        }

        //
        // now deallocate the struct
        //
        MyTaggedFree(LogContext,MEMTAG_LOGCONTEXT);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // cleanup below
        //
    }
    //
    // if we have not yet released global lock, release it now
    //
    if(locked) {
        LogUnlock();
    }

    return;
}

DWORD
RefLogContext(  // increment reference count
    IN PSETUP_LOG_CONTEXT LogContext
    )

/*++

Routine Description:

    Increment the reference count on a SETUP_LOG_CONTEXT object.


Arguments:

    LogContext - supplies a pointer to a valid SETUP_LOG_CONTEXT object. If
        NULL, this is a NOP.

Return Value:

    DWORD containing old reference count.

--*/

{
    DWORD ref = 0;
    BOOL locked = FALSE;

    if (LogContext == NULL) {
        return 0;
    }


    try {
        LogLock();
        locked = TRUE;

        ref = LogContext->RefCount++;
        MYASSERT(LogContext->RefCount);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    if(locked) {
        LogUnlock();
    }

    return ref;
}

VOID
SendLogString(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR Buffer
    )

/*++

Routine Description:

    Send a string to the logfile and/or debugger based on settings.

    It's expected that LogLock has been called prior to calling this function
    LogLock causes per-process thread synchronisation

Arguments:

    LogContext - supplies a pointer to a valid SETUP_LOG_CONTEXT object.

    Buffer - supplies the buffer to be sent to the logfile/debugger.

Return Value:

    NONE.

--*/

{
    int len;

    try {
        MYASSERT(LogContext);
        MYASSERT(Buffer);

        if (Buffer[0] == 0) {
            //
            // useless call
            //
            leave;
        }

        if (GlobalLogData.FileName) {
            WriteLogSectionEntry(
                GlobalLogData.FileName,
                LogContext->SectionName,
                Buffer,
                (GlobalLogData.Flags & SETUP_LOG_SIMPLE) ? TRUE : FALSE);
        }

        //
        // do debugger output here
        //
        if (GlobalLogData.Flags & SETUP_LOG_DEBUGOUT) {
            DebugPrintEx(DPFLTR_ERROR_LEVEL,
                TEXT("SetupAPI: %s: %s"),
                LogContext->SectionName,
                Buffer);
            len = lstrlen(Buffer);
            if (Buffer[len-1] != TEXT('\n')) {
                DebugPrintEx(DPFLTR_ERROR_LEVEL, TEXT("\r\n"));
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }
}

DWORD
pSetupWriteLogEntry(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD MessageId,
    IN PCTSTR MessageStr,               OPTIONAL
    ...                                 OPTIONAL
    )

/*++

Routine Description:

    Write a log entry to a file or debugger. If MessageId is 0 and MessageStr
    is NULL, the LogContext's buffer will be flushed.

Arguments:

    LogContext - optionally supplies a pointer to the SETUP_LOG_CONTEXT to be
        used for logging. If not supplied, a temporary one is created just for
        a single use.

    Level - bitmask indicating logging flags. See SETUP_LOG_* and DRIVER_LOG_*
        at the beginning of cntxtlog.h for details. It may also be a slot
        returned by AllocLogInfoSlot, or 0 (no logging)

    MessageId - ID of string from string table. Ignored if MessageStr is
        supplied. The string may contain formatting codes for FormatMessage.

    MessageStr - optionally supplies string to be formatted with FormatMessage.
        If not supplied, MessageId is used instead.

    ... - supply optional parameters based on string to be formatted.

Return Value:

    Win32 error code.

--*/

{
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD retval = NO_ERROR;
    DWORD error;
    DWORD flags;
    DWORD context = 0;
    DWORD logmask;
    DWORD count;
    LPVOID source = NULL;
    PTSTR buffer = NULL;
    PTSTR locbuffer = NULL;
    PTSTR buffer2 = NULL;
    va_list arglist;
    BOOL logit = FALSE;
    BOOL timestamp = FALSE;
    BOOL endsync = FALSE;
    SYSTEMTIME now;
    TCHAR scratch[1024];
    int logindex;
    int thisindex;
    int numeric=0;

    try {
        //
        // return immediately if we know we'll never log
        //
        if (_WouldNeverLog(Level)) {
            retval = NO_ERROR;
            leave;
        }

        if ((Level & SETUP_LOG_IS_CONTEXT)!=0) {
            //
            // write to context slot
            //
            if(Level & ~SETUP_LOG_VALIDCONTEXTBITS) {
                MYASSERT((Level & ~SETUP_LOG_VALIDCONTEXTBITS)==0);
                retval = ERROR_INVALID_PARAMETER;
                leave;
            }
            if ((GlobalLogData.Flags & SETUP_LOG_ALL_CONTEXT)!=0) {
                //
                // don't treat as context - log it anyway
                //
                Level = 0;
                logit = TRUE;
            } else if (LogContext) {
                //
                // determine which slot
                //
                context = Level & SETUP_LOG_CONTEXTMASK;
                Level = SETUP_LOG_IS_CONTEXT;   // effective log level, we've stripped out log context
                logit = TRUE;
            } else {
                //
                // can't write something to slot if there's no LogContext
                //
                leave;
            }
        }

        if(!logit) {
            //
            // we're still not sure if we'll end up logging this, let's see if we should log this based on level rules
            //
            logit = _WouldLog(Level);
            if (!logit) {
                leave;
            }
        }

        if (LogContext == NULL) {
            //
            // if they pass no LogContext and they want buffering, this call's a nop
            //
            if (Level & SETUP_LOG_BUFFER) {
                retval = NO_ERROR;
                leave;
            }

            //
            // now make a temporary context
            //
            error = CreateLogContext(NULL, TRUE, &lc);
            if (error != NO_ERROR) {
                lc = NULL;
                retval = error;
                leave;
            }

            LogContext = lc;
        }

        //
        // after this point, we know we're going to log something, and we know we have a LogContext
        // note that going down this path is a perf hit.
        // anything we can do in reducing number of times we go down here for "context" information is good
        //
        // hold the lock through to cleanup. It is needed for ReleaseLogInfoList,
        // LogContext modifications and will reduce conflicts when actually writing to the log file
        //
        LogLock();
        endsync = TRUE; // indicate we need to release later

        timestamp = (GlobalLogData.Flags & SETUP_LOG_TIMESTAMP)
                    || ((Level & DRIVER_LOG_LEVELMASK) >= DRIVER_LOG_TIME)
                    || ((Level & SETUP_LOG_LEVELMASK) >= SETUP_LOG_TIME)
                    || (((Level & SETUP_LOG_LEVELMASK) > 0) && (SETUP_LOG_TIMEALL <= (GlobalLogData.Flags & SETUP_LOG_LEVELMASK)))
                    || (((Level & DRIVER_LOG_LEVELMASK) > 0) && (DRIVER_LOG_TIMEALL <= (GlobalLogData.Flags & DRIVER_LOG_LEVELMASK)));

        if ((Level & SETUP_LOG_IS_CONTEXT) == FALSE) {
            //
            // only do this if we're about to do REAL logging
            //
            // if this is the first log output in the section, we will give the
            // command line and module to help the user see what's going on
            //
            if (LogContext->LoggedEntries==0) {
                //
                // recursively call ourselves to log what the command line is
                // note that some apps (eg rundll32) will go and trash command line
                // if this is the case, try and do the right thing
                // we're willing to spend a little extra time in this case, since we know we're going to
                // log something to the section, and we'll only do this once per section
                //
                PTSTR CmdLine = GetCommandLine();

                LogContext->LoggedEntries++; // stop calling this code when we do the pSetupWriteLogEntry's below

                if (CmdLine[0] == TEXT('\"')) {
                    CmdLine++;
                }
                if(_tcsnicmp(ProcessFileName,CmdLine,_tcslen(ProcessFileName))==0) {
                    //
                    // commandline is prefixed with process file name
                    // chance is it's good
                    //
                    pSetupWriteLogEntry(
                        LogContext,
                        AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                        MSG_LOG_COMMAND_LINE,
                        NULL,
                        GetCommandLine());
                } else {
                    //
                    // it appears that the command line has been modified somewhat
                    // so show what we have
                    //
                    pSetupWriteLogEntry(
                        LogContext,
                        AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                        MSG_LOG_BAD_COMMAND_LINE,
                        NULL,
                        ProcessFileName,
                        GetCommandLine());

#ifdef UNICODE
                    {
                        //
                        // UNICODE only
                        //
                        // now see if we can get something more useful by looking at the ANSI command line buffer
                        //
                        PSTR AnsiProcessFileName = pSetupUnicodeToMultiByte(ProcessFileName,CP_ACP);
                        PSTR AnsiCmdLine = GetCommandLineA();
                        if (AnsiCmdLine[0] == '\"') {
                            AnsiCmdLine++;
                        }
                        if(AnsiProcessFileName && _mbsnicmp(AnsiProcessFileName,AnsiCmdLine,_mbslen(AnsiProcessFileName))==0) {
                            //
                            // well, the Ansi version appears ok, let's use that
                            //
                            pSetupWriteLogEntry(
                                LogContext,
                                AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                                MSG_LOG_COMMAND_LINE_ANSI,
                                NULL,
                                GetCommandLineA());
                        } else {
                            //
                            // appears that both Unicode and Ansi might be bad
                            //
                            AnsiCmdLine = pSetupUnicodeToMultiByte(GetCommandLine(),CP_ACP);
                            if (AnsiCmdLine && _mbsicmp(AnsiCmdLine,GetCommandLineA())!=0) {
                                //
                                // also log ansi as reference, since it's different
                                //
                                pSetupWriteLogEntry(
                                    LogContext,
                                    AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                                    MSG_LOG_BAD_COMMAND_LINE_ANSI,
                                    NULL,
                                    GetCommandLineA());
                            }
                            if (AnsiCmdLine) {
                                MyFree(AnsiCmdLine);
                            }
                        }
                        if (AnsiProcessFileName) {
                            MyFree(AnsiProcessFileName);
                        }
                    }
#endif // UNICODE
                }
#ifdef UNICODE
#ifndef _WIN64
                //
                // we're running 32-bit setupapi
                //
                if (IsWow64) {
                    //
                    // we're running it under WOW64
                    //
                    pSetupWriteLogEntry(
                        LogContext,
                        AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                        MSG_LOG_WOW64,
                        NULL,
                        GetCommandLine());
                }
#endif
#endif // UNICODE
            }
        }

        flags = FORMAT_MESSAGE_ALLOCATE_BUFFER;

        //
        // if MessageStr is supplied, we use that; otherwise use a
        // string from a string table
        //
        if (MessageStr) {
            flags |= FORMAT_MESSAGE_FROM_STRING;
            source = (PTSTR) MessageStr;    // cast away const
        } else if (MessageId) {
            //
            // the message ID may be an HRESULT error code
            //
            if (MessageId & 0xC0000000) {
                flags |= FORMAT_MESSAGE_FROM_SYSTEM;
                //
                // Some system messages contain inserts, but whomever is calling
                // will not supply them, so this flag prevents us from
                // tripping over those cases.
                //
                flags |= FORMAT_MESSAGE_IGNORE_INSERTS;
            } else {
                flags |= FORMAT_MESSAGE_FROM_HMODULE;
                source = MyDllModuleHandle;
                numeric = (int)(MessageId-MSG_LOG_FIRST);
            }
        }

        if (MessageStr || MessageId) {
            va_start(arglist, MessageStr);
            count = FormatMessage(
                        flags,
                        source,
                        MessageId,
                        0,              // LANGID
                        (LPTSTR) &locbuffer,
                        0,              // minimum size of buffer
                        &arglist);

        } else {
            //
            // There is no string to format, so we are probably just
            // flushing the buffer.
            //
            count = 1;
        }

        if (count > 0) {
            //
            // no error; prefix string with a code and place into a MyMalloc allocated buffer
            // we don't want to prefix string with a code if we're appending to an existing message
            //
            if (locbuffer) {
                if ((numeric > 0) && (LogContext->Buffer==NULL)) {
                    //
                    // determine level code, which indicates severity for why we logged this
                    // and machine readable ID
                    //
                    if (Level & SETUP_LOG_IS_CONTEXT) {
                        //
                        // if this is context information, use #-xxxx
                        //
                        _stprintf(scratch,TEXT("#-%03d "),numeric);
                    } else {
                        logindex = LOGLEVELSHORT_INIT; // maps to 0. after >>4&0x0f.

                        if ((Level & SETUP_LOG_LEVELMASK) > 0 && (Level & SETUP_LOG_LEVELMASK) <= (GlobalLogData.Flags & SETUP_LOG_LEVELMASK)) {
                            thisindex = (Level & SETUP_LOG_LEVELMASK) >> SETUP_LOG_SHIFT;
                            if (thisindex < logindex) {
                                logindex = thisindex;
                            }
                        }
                        if ((Level & DRIVER_LOG_LEVELMASK) > 0 && (Level & DRIVER_LOG_LEVELMASK) <= (GlobalLogData.Flags & DRIVER_LOG_LEVELMASK)) {
                            thisindex = (Level & DRIVER_LOG_LEVELMASK) >> DRIVER_LOG_SHIFT;
                            if (thisindex < logindex) {
                                logindex = thisindex;
                            }
                        }
                        //
                        // #Cxxxx #Vxxxx etc
                        //
                        _stprintf(scratch,TEXT("#%c%03d "),LogLevelShort[(logindex>>LOGLEVELSHORT_SHIFT)&LOGLEVELSHORT_MASK],numeric);
                    }
                } else {
                    scratch[0] = TEXT('\0');
                }
                buffer = (PTSTR)MyTaggedMalloc((lstrlen(scratch)+lstrlen(locbuffer)+1)*sizeof(TCHAR),MEMTAG_LCBUFFER);
                if (buffer) {
                    lstrcpy(buffer,scratch);
                    lstrcat(buffer,locbuffer);
                }
                LocalFree(locbuffer);
            } else {
                buffer = NULL;
            }

            //
            // Check to see if the buffer has anything in it. If so, the newest
            // string needs to be appended to it.
            //
            if (LogContext->Buffer) {
                //
                // in case of a flush, buffer == NULL
                //
                if (buffer!=NULL) {
                    int blen = lstrlen(LogContext->Buffer);
                    int pad = 0;
                    TCHAR lastchr = *CharPrev(LogContext->Buffer,LogContext->Buffer+blen);

                    if (lastchr != TEXT(' ')) {
                        //
                        // silently correct any errors in the message text (which should end in a space)
                        //
                        while((lastchr == TEXT('\t')) ||
                              (lastchr == TEXT('\r')) ||
                              (lastchr == TEXT('\n'))) {
                            blen--; // these characters are always sizeof(TCHAR)
                            lastchr = *CharPrev(LogContext->Buffer,LogContext->Buffer+blen);
                        }
                        LogContext->Buffer[blen] = TEXT('\0');
                        if (lastchr != TEXT(' ')) {
                            //
                            // we want to insert a space padding
                            //
                            pad++;
                        }
                    }
                    buffer2 = MyTaggedRealloc(LogContext->Buffer,
                                              (blen + pad + lstrlen(buffer) + 1) * sizeof(TCHAR),
                                              MEMTAG_LCBUFFER
                                              );

                    //
                    // if the realloc was successful, add the new data, otherwise
                    // just drop it on the floor
                    //
                    if (buffer2) {
                        if (pad) {
                            lstrcat(buffer2,TEXT(" "));
                        }
                        lstrcat(buffer2, buffer);
                        LogContext->Buffer = buffer2;
                        buffer2 = NULL;
                    }

                    MyTaggedFree(buffer,MEMTAG_LCBUFFER);
                    buffer = NULL;
                }
                buffer = LogContext->Buffer;
                LogContext->Buffer = NULL;
            }

            if (Level & SETUP_LOG_BUFFER) {

                LogContext->Buffer = buffer;
                buffer = NULL;

            } else if (Level & SETUP_LOG_IS_CONTEXT) {

                PTSTR TempDupeString;

                //
                // replace the string indicated
                //

                if(buffer) {
                    if (LogContext->ContextInfo[context]) {
                        MyTaggedFree(LogContext->ContextInfo[context],MEMTAG_LCBUFFER);
                    }
                    LogContext->ContextInfo[context] = buffer;
                    buffer = NULL;
                }

            } else {
                int item;
                //
                // actually do some logging
                //
                LogContext->LoggedEntries++;

                if (!LogContext->SectionName) {
                     error = MakeUniqueName(NULL,&(LogContext->SectionName));
                }

                //
                // first dump the auto-release context info
                //
                item = LogContext->ContextFirstAuto;

                while (item >= 0) {
                    if (LogContext->ContextInfo[item]) {
                        //
                        // dump this string
                        //
                        SendLogString(LogContext, LogContext->ContextInfo[item]);
                        MyTaggedFree (LogContext->ContextInfo[item],MEMTAG_LCBUFFER);
                        LogContext->ContextInfo[item] = NULL;
                    }
                    item = LogContext->ContextIndexes[item];
                }

                ReleaseLogInfoList(LogContext,&LogContext->ContextFirstAuto);

                //
                // now dump any strings set in currently allocated slots
                //
                item = LogContext->ContextFirstUsed;

                while (item >= 0) {
                    if (LogContext->ContextInfo[item]) {
                        //
                        // dump this string
                        //
                        SendLogString(LogContext, LogContext->ContextInfo[item]);
                        MyTaggedFree (LogContext->ContextInfo[item],MEMTAG_LCBUFFER);
                        LogContext->ContextInfo[item] = NULL;
                    }
                    item = LogContext->ContextIndexes[item];
                }

                //
                // we have built up a line to send
                //
                if (buffer != NULL) {
                    if(timestamp) {
                        //
                        // this is the point we're interested in prefixing with timestamp
                        // this allows us to build up a string, then emit it prefixed with stamp
                        //
                        GetLocalTime(&now);

                        _stprintf(scratch, TEXT("@ %02d:%02d:%02d.%03d "),
                            now.wHour, now.wMinute, now.wSecond, now.wMilliseconds);

                        buffer2 = MyTaggedMalloc((lstrlen(scratch)+lstrlen(buffer)+1)*sizeof(TCHAR),MEMTAG_LCBUFFER);
                        if (buffer2) {
                            lstrcpy(buffer2,scratch);
                            lstrcat(buffer2,buffer);
                            MyTaggedFree(buffer,MEMTAG_LCBUFFER);
                            buffer = buffer2;
                            buffer2 = NULL;
                        }
                    }

                    SendLogString(LogContext,buffer);
                }
            }

        } else {
            //
            // the FormatMessage failed
            //
            retval = GetLastError();
            if(retval == NO_ERROR) {
                retval = ERROR_INVALID_DATA;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
        retval = ERROR_INVALID_DATA;
    }

    //
    // cleanup
    //
    if (endsync) {
        LogUnlock();
    }

    if (buffer) {
        MyTaggedFree(buffer,MEMTAG_LCBUFFER);
    }
    if (lc) {
        DeleteLogContext(lc);
    }
    return retval;
}

VOID
SetLogSectionName(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR SectionName
    )

/*++

Routine Description:

    Sets the section name for the log context if it hasn't been used.

Arguments:

    LogContext - supplies pointer to SETUP_LOG_CONTEXT.

    SectionName - supplies a pointer to a string to be included in the
        section name.

Return Value:

    NONE.

--*/

{
    DWORD rc;
    PTSTR NewSectionName = NULL;
    BOOL locked = FALSE;

    MYASSERT(LogContext);
    MYASSERT(SectionName);


    try {
        LogLock();
        locked = TRUE;

        //
        // make sure the entry has never been used before
        //
        if (LogContext->LoggedEntries==0 || LogContext->SectionName==NULL) {
            //
            // get rid of any previous name
            //

            rc = MakeUniqueName(SectionName,&NewSectionName);
            if (rc == NO_ERROR) {
                if (LogContext->SectionName) {
                    MyTaggedFree(LogContext->SectionName,MEMTAG_LCSECTION);
                }
                LogContext->SectionName = NewSectionName;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

    if(locked) {
        LogUnlock();
    }
}

#if MEM_DBG
#undef InheritLogContext            // defined again below
#endif

DWORD
InheritLogContext(
    IN TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN PSETUP_LOG_CONTEXT Source,
    OUT PSETUP_LOG_CONTEXT *Dest
    )

/*++

Routine Description:

    Copies a log context from one structure to another, deleting the one that
    gets overwritten. If Source and Dest are both NULL, a new log context is
    created for Dest.

Arguments:

    Source - supplies pointer to source SETUP_LOG_CONTEXT. If NULL, this
        creates a new log context for Dest.

    Dest - supplies the location to receive a pointer to the log context.

Return Value:

    NONE.

--*/

{
    DWORD status = ERROR_INVALID_DATA;
    DWORD rc;
    PSETUP_LOG_CONTEXT Old = NULL;

    TRACK_PUSH

    try {
        MYASSERT(Dest);
        Old = *Dest;
        if (Old == NULL && Source == NULL) {
            //
            // this is a roundabout way of saying we want to create a context
            // used when the source logcontext is optional
            //
            rc = CreateLogContext(NULL, TRUE, Dest);
            if (rc != NO_ERROR) {
                status = rc;
                leave;
            }
        } else if (Source != NULL && (Old == NULL || Old->LoggedEntries == 0)) {
            //
            // We can replace Dest, since it hasn't been used yet
            //
            *Dest = Source;
            RefLogContext(Source);
            if (Old != NULL) {
                //
                // now delete old
                //
                DeleteLogContext(Old);
            }
        }

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    TRACK_POP

    return status;
}

#if MEM_DBG
#define InheritLogContext(a,b)          InheritLogContext(TRACK_ARG_CALL,a,b)
#endif

DWORD
ShareLogContext(
    IN OUT PSETUP_LOG_CONTEXT *Primary,
    IN OUT PSETUP_LOG_CONTEXT *Secondary
    )
/*++

Routine Description:

    Bidirectional inherit

Arguments:

    Primary - preferred source

    Secondary - preferred target

Return Value:

    any potential error

--*/
{
    DWORD rc = ERROR_INVALID_DATA;

    try {
        MYASSERT(Primary);
        MYASSERT(*Primary);
        MYASSERT(Secondary);
        MYASSERT(*Secondary);

        if((*Secondary)->LoggedEntries) {
            //
            // secondary has already been used, so see if we can update primary
            //
            rc = InheritLogContext(*Secondary,Primary);
        } else {
            //
            // else behave exactly like InheritLogContext
            //
            rc = InheritLogContext(*Primary,Secondary);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }
    return rc;
}

VOID
pSetupWriteLogError(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD Error
    )

/*++

Routine Description:

    Logs an error code and an error message on the same line.

Arguments:

    LogContext - supplies a pointer to a valid SETUP_LOG_CONTEXT object. If
        NULL, this is a NOP.

    Level - supplies a log level as defined by pSetupWriteLogEntry.

    Error - supplies the Win32 error, HRESULT, or SETUPAPI error code to log.

Return Value:

    NONE.

--*/

{
    DWORD err;

    if (!LogContext) {
        //
        // error is meaningless without context
        //
        goto final;
    }

    if (Error == NO_ERROR) {
        pSetupWriteLogEntry(
            LogContext,
            Level,
            MSG_LOG_NO_ERROR,
            NULL);
        goto final;
    }

    pSetupWriteLogEntry(
        LogContext,
        Level | SETUP_LOG_BUFFER,
        //
        // print HRESULTs in hex, Win32 errors in decimal
        //
        (Error & 0xC0000000 ? MSG_LOG_HRESULT_ERROR
                            : MSG_LOG_WIN32_ERROR),
        NULL,
        Error);

    //
    // If it's a Win32 error, we convert it to an HRESULT, because
    // pSetupWriteLogEntry only knows that it's an error code by the fact
    // that it's an HRESULT.  However, we don't want the user to
    // get an HRESULT if we can help it, so just do the conversion
    // after converting to a string. Also, SETUPAPI errors are not
    // in proper HRESULT format without conversion
    //
    Error = HRESULT_FROM_SETUPAPI(Error);

    //
    // writing the error message may fail...
    //
    err = pSetupWriteLogEntry(
        LogContext,
        Level,
        Error,
        NULL);

    if (err != NO_ERROR) {
        pSetupWriteLogEntry(
            LogContext,
            Level,
            MSG_LOG_UNKNOWN_ERROR,
            NULL);
    }

final:
    SetLastError(Error);
}

BOOL
ContextLoggingTlsInit(
    IN BOOL Init
    )
/*++

Routine Description:

    Init = TRUE Initializes per-thread data for logging
    Init = FALSE releases memory on cleanup

Arguments:

    Init - set to initialize

Return Value:

    TRUE if initialized ok.

--*/
{
    BOOL b = FALSE;
    PSETUP_TLS pTLS;
    PSETUP_LOG_TLS pLogTLS;

    pTLS = SetupGetTlsData();
    MYASSERT(pTLS);
    pLogTLS = &pTLS->SetupLog;

    if (Init) {
        pLogTLS->ThreadLogContext = NULL;
        b = TRUE;
    } else {
        //
        // ISSUE-JamieHun-2001/05/01 ASSERT when thread terminated
        // thread might not have terminated cleanly
        // causing this assert to fire
        //
        // MYASSERT(!pLogTLS->ThreadLogContext);
        b = TRUE;
    }
    return b;
}

BOOL
SetThreadLogContext(
    IN PSETUP_LOG_CONTEXT LogContext,
    OUT PSETUP_LOG_CONTEXT *PrevContext  OPTIONAL
    )
/*++

Routine Description:

    Modify current thread log context

Arguments:

    LogContext new log context (expected to be apropriately ref counted)
    PrevContext if set, filled with previous context

Return Value:

    TRUE if set ok.

--*/
{
    PSETUP_TLS pTLS;
    PSETUP_LOG_TLS pLogTLS;
    PSETUP_LOG_CONTEXT Top;

    pTLS = SetupGetTlsData();
    if(!pTLS) {
        return FALSE;
    }
    pLogTLS = &pTLS->SetupLog;

    if (PrevContext) {
        *PrevContext = pLogTLS->ThreadLogContext;
    }
    pLogTLS->ThreadLogContext = LogContext;
    return TRUE;
}

PSETUP_LOG_CONTEXT
GetThreadLogContext(
    )
/*++

Routine Description:

    Return thread's default log context

Arguments:

    NONE

Return Value:

    Current LogContext or NULL

--*/
{
    PSETUP_TLS pTLS;

    pTLS = SetupGetTlsData();
    if(!pTLS) {
        return NULL;
    }
    return pTLS->SetupLog.ThreadLogContext;
}

BOOL
InitializeContextLogging(
    IN BOOL Attach
    )
/*++

Routine Description:

    Initializes structures/data for logging or releases allocated memory.

Arguments:

    Attach - set when called at attach time as opposed to detach time

Return Value:

    TRUE if initialized ok.

--*/
{
    BOOL Successful = FALSE;

    if (Attach) {

        LONG error;
        HKEY key;
        HKEY loglevel;
        DWORD len;
        DWORD level = 0;
        DWORD type;
        PTSTR PathName = NULL;
        TCHAR testchar;
        BOOL isdir = FALSE;

        GlobalLogData.FileName = NULL;
        GlobalLogData.Flags = 0;
        GlobalLogData.UID = 0;
        GlobalLogData.DoneInitCritSec = FALSE;

        try {
            InitializeCriticalSection(&GlobalLogData.CritSec);
            GlobalLogData.DoneInitCritSec = TRUE;
            error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_SETUP REGSTR_KEY_SETUP,
                0,                  // reserved
                KEY_QUERY_VALUE,
                &key);

            if (error == ERROR_SUCCESS) {

                if(QueryRegistryDwordValue(key,SP_REGKEY_LOGLEVEL,&level) != NO_ERROR) {
                    level = 0;
                }

                if(QueryRegistryValue(key,SP_REGKEY_LOGPATH,&PathName,&type,&len) != NO_ERROR) {
                    PathName = NULL;
                }

                //
                // Allow a user to override the log level for a particular program
                //

                error = RegOpenKeyEx(
                    key,
                    SP_REGKEY_APPLOGLEVEL,
                    0,                  // reserved
                    KEY_QUERY_VALUE,
                    &loglevel);

                if (error == ERROR_SUCCESS) {

                    DWORD override;
                    if(QueryRegistryDwordValue(key,SP_REGKEY_LOGLEVEL,&override) == NO_ERROR) {
                        level = override;
                    }

                    RegCloseKey(loglevel);
                }

                RegCloseKey(key);
            }

            //
            // if they don't supply a valid name, we use the Windows dir
            //
            if (!(PathName && PathName[0])) {
                if(PathName) {
                    MyFree(PathName);
                }
                PathName = DuplicateString(WindowsDirectory);
                if(!PathName) {
                    leave;
                }
                isdir = TRUE; // we know this should be a directory
            } else {
                //
                // see if we're pointing at a directory
                //
                testchar = CharPrev(PathName,PathName+lstrlen(PathName))[0];
                if(testchar == TEXT('\\') || testchar == TEXT('/')) {
                    //
                    // explicit directiory
                    //
                    isdir = TRUE;
                } else {
                    DWORD attr = GetFileAttributes(PathName);
                    if (isdir || (attr != (DWORD)(-1) && (attr & FILE_ATTRIBUTE_DIRECTORY) != 0 )) {
                        //
                        // implicit directory
                        //
                        isdir = TRUE;
                    }
                }
            }

            if (isdir) {
                //
                // if they gave a directory, add a filename
                //
                LPTSTR NewPath;
                if(!pSetupAppendPath(PathName,SP_LOG_FILENAME,&NewPath)) {
                    MyFree(PathName);
                    PathName = NULL;
                    leave;
                }
                MyFree(PathName);
                PathName = NewPath;
            }
            pSetupMakeSurePathExists(PathName);

            //
            // validate level flags
            //
            level &= SETUP_LOG_VALIDREGBITS;
            //
            // handle defaults
            //
            if((level & SETUP_LOG_LEVELMASK) == 0) {
                //
                // level not explicitly set
                //
                level |= SETUP_LOG_DEFAULT;
            }

            if((level & DRIVER_LOG_LEVELMASK) == 0) {
                //
                // level not explicitly set
                //
                level |= DRIVER_LOG_DEFAULT;
            }
            GlobalLogData.Flags = level;

            GlobalLogData.FileName = PathName;
            PathName = NULL;
            if (GlobalLogData.FileName == NULL) {
                leave;
            }

            Successful = TRUE;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Successful remains FALSE
            //
        }


    } else {

        if (GlobalLogData.FileName) {
            MyFree(GlobalLogData.FileName);
            GlobalLogData.FileName = NULL;
        }
        if(GlobalLogData.DoneInitCritSec) {
            DeleteCriticalSection(&GlobalLogData.CritSec);
        }
        Successful = TRUE;
    }

    return Successful;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\debug.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    debug.c

Abstract:

    Diagnositc/debug routines for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 17-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if ASSERTS_ON

extern BOOL InInitialization;


VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition,
    IN BOOL NoUI
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    LPSTR Msg;
    DWORD msglen;
    DWORD sz;
    DWORD rc;

    rc = GetLastError(); // preserve GLE

    //
    // Use dll name as caption
    //
    sz = GetModuleFileNameA(NULL,Name,MAX_PATH);
    if((sz == 0) || (sz > MAX_PATH)) {
        strcpy(Name,"?");
    }
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }
    msglen = strlen(p)+strlen(FileName)+strlen(Condition)+128;
    //
    // assert might be out of memory condition
    // stack alloc is more likely to succeed than memory alloc
    //
    try {
        Msg = (LPSTR)_alloca(msglen);
        wsprintfA(
            Msg,
            "Assertion failure at line %u in file %s!%s: %s%s",
            LineNumber,
            p,
            FileName,
            Condition,
            (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? "\r\n" : "\n\nCall DebugBreak()?"
            );

        OutputDebugStringA(Msg);

        if((GlobalSetupFlags & PSPGF_NONINTERACTIVE) || InInitialization || NoUI) {
            i = IDYES;
        } else {
            i = MessageBoxA(
                    NULL,
                    Msg,
                    p,
                    MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                    );
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        OutputDebugStringA("SetupAPI ASSERT!!!! (out of stack)\r\n");
        i=IDYES;
    }


    if(i == IDYES) {
        SetLastError(rc);
        DebugBreak();
    }
    SetLastError(rc);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devclass.c ===
/*++

Copyright (c) 1993-1998 Microsoft Corporation

Module Name:

    devclass.c

Abstract:

    Device Installer routines dealing with class installation

Author:

    Lonny McMichael (lonnym) 1-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetINFClassA(
    IN  PCSTR  InfName,
    OUT LPGUID ClassGuid,
    OUT PSTR   ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    )
{
    PWSTR infname;
    WCHAR classname[MAX_CLASS_NAME_LEN];
    PSTR ansiclassname;
    DWORD requiredsize;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(InfName,&infname);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupDiGetINFClassW(infname,ClassGuid,classname,MAX_CLASS_NAME_LEN,&requiredsize);
    rc = GetLastError();

    if(b) {

        if(ansiclassname = pSetupUnicodeToAnsi(classname)) {

            requiredsize = lstrlenA(ansiclassname) + 1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    rc = ERROR_INVALID_PARAMETER;
                }
            }

            if(b) {
                if(requiredsize <= ClassNameSize) {
                    if(!lstrcpyA(ClassName,ansiclassname)) {
                        //
                        // lstrcpy faulted; ClassName must be bad
                        //
                        b = FALSE;
                        rc = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }

            MyFree(ansiclassname);
        } else {
            b = FALSE;
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    MyFree(infname);
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetINFClassW(
    IN  PCWSTR InfName,
    OUT LPGUID ClassGuid,
    OUT PWSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfName);
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassNameSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetINFClass(
    IN  PCTSTR InfName,
    OUT LPGUID ClassGuid,
    OUT PTSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    )
/*++

Routine Description:

    This API will return the class of the specified (Windows 4.0) INF.  If just the
    filename was specified, then the file will be searched for in each of the
    directories listed in the DevicePath value entry under:

        HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion

    Otherwise, the filename will be used as-is.

Arguments:

    InfName - Supplies the name of the INF file for which to retrieve class information.
        This name may include a path.

    ClassGuid - Receives the class GUID for the specified INF file.  If the INF
        does not specify a class GUID, this variable will be set to GUID_NULL.
        (SetupDiClassGuidsFromName may then be used to determine if one or more
        classes of this name have already been installed.)

    ClassName - Receives the name of the class for the specified INF file.  If the
        INF does not specify a class name, but does specify a GUID, then this buffer
        receives the name retrieved by calling SetupDiClassNameFromGuid.  If
        SetupDiClassNameFromGuid can't retrieve a class name (e.g., the class hasn't
        yet been installed), then an empty string will be returned.

    ClassNameSize - Supplies the size, in characters, of the ClassName buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class name (including terminating NULL).  This will always be less
        than MAX_CLASS_NAME_LEN.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    TCHAR PathBuffer[MAX_PATH];
    PLOADED_INF Inf = NULL;
    PCTSTR GuidString, ClassNameString;
    DWORD ErrorLineNumber, ClassNameStringLen;
    DWORD Err;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR DontCare;
    DWORD TempRequiredSize;

    try {

        if(InfName == pSetupGetFileTitle(InfName)) {
            //
            // The specified INF name is a simple filename.  Search for it in
            // the DevicePath search path list.
            //
            Err = SearchForInfFile(InfName,
                                   &FindData,
                                   INFINFO_INF_PATH_LIST_SEARCH,
                                   PathBuffer,
                                   SIZECHARS(PathBuffer),
                                   NULL
                                  );
            if(Err == NO_ERROR) {
                TryPnf = TRUE;
            } else {
                goto clean0;
            }

        } else {
            //
            // The specified INF filename contains more than just a filename.
            // Assume it's an absolute path.  (We need to make sure it's
            // fully-qualified, because that's what LoadInfFile expects.)
            //
            TempRequiredSize = GetFullPathName(InfName,
                                               SIZECHARS(PathBuffer),
                                               PathBuffer,
                                               &DontCare
                                              );
            if(!TempRequiredSize) {
                Err = GetLastError();
                goto clean0;
            } else if(TempRequiredSize >= SIZECHARS(PathBuffer)) {
                MYASSERT(0);
                Err = ERROR_BUFFER_OVERFLOW;
                goto clean0;
            }

            if(FileExists(PathBuffer, &FindData)) {
                //
                // We have a valid file path, and we're ready to load this INF.
                //
                InfSourcePathFromFileName(PathBuffer, NULL, &TryPnf);
            } else {
                Err = GetLastError();
                goto clean0;
            }
        }

        //
        // Load the INF.
        //
        Err = LoadInfFile(PathBuffer,
                          &FindData,
                          INF_STYLE_WIN4,
                          LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0),
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL, // LogContext
                          &Inf,
                          &ErrorLineNumber,
                          NULL
                         );
        if(Err != NO_ERROR) {
            goto clean0;
        }

        //
        // Retrieve the Class name from the version section of the INF, if
        // supplied.
        //
        ClassNameString = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass);
        if(ClassNameString) {

            ClassNameStringLen = lstrlen(ClassNameString) + 1;
            if(RequiredSize) {
                *RequiredSize = ClassNameStringLen;
            }

            if(ClassNameStringLen > ClassNameSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
                goto clean1;
            }

            CopyMemory(ClassName,
                       ClassNameString,
                       ClassNameStringLen * sizeof(TCHAR)
                      );
        }

        //
        // Retrieve the ClassGUID string from the version section,
        // if supplied
        //
        GuidString = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClassGuid);
        if(GuidString) {

            if((Err = pSetupGuidFromString(GuidString, ClassGuid)) != NO_ERROR) {
                goto clean1;
            }

            if(!ClassNameString) {
                //
                // Call SetupDiClassNameFromGuid to retrieve the class name
                // corresponding to this class GUID.
                //
                if(!SetupDiClassNameFromGuid(ClassGuid,
                                             ClassName,
                                             ClassNameSize,
                                             RequiredSize)) {
                    Err = GetLastError();
                    if(Err == ERROR_INVALID_CLASS) {
                        //
                        // Then this GUID represents a class that hasn't been
                        // installed yet, so simply set the ClassName to be an
                        // empty string.
                        //
                        if(RequiredSize) {
                            *RequiredSize = 1;
                        }

                        if(ClassNameSize < 1) {
                            Err = ERROR_INSUFFICIENT_BUFFER;
                            goto clean1;
                        }

                        *ClassName = TEXT('\0');
                        Err = NO_ERROR;

                    } else {
                        goto clean1;
                    }
                }
            }

        } else if(ClassNameString) {
            //
            // Since no ClassGUID was given, set the supplied GUID buffer to GUID_NULL.
            //
            CopyMemory(ClassGuid,
                       &GUID_NULL,
                       sizeof(GUID)
                      );
        } else {
            //
            // Neither the ClassGUID nor the Class version entries were provided,
            // so return an error.
            //
            Err = ERROR_NO_ASSOCIATED_CLASS;
            goto clean1;
        }

clean1:
        FreeInfFile(Inf);
        Inf = NULL;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        if(Inf) {
            FreeInfFile(Inf);
        }
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiClassNameFromGuidA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    )
{
    return SetupDiClassNameFromGuidExA(ClassGuid, ClassName, ClassNameSize, RequiredSize, NULL, NULL);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiClassNameFromGuidW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassNameSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiClassNameFromGuid(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    )
/*++

Routine Description:

    See SetupDiClassNameFromGuidEx for details.

--*/

{
    return SetupDiClassNameFromGuidEx(ClassGuid, ClassName, ClassNameSize, RequiredSize, NULL, NULL);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiClassNameFromGuidExA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCSTR       MachineName,   OPTIONAL
    IN  PVOID       Reserved
    )
{
    WCHAR UnicodeClassName[MAX_CLASS_NAME_LEN];
    DWORD requiredsize;
    PSTR ansiclassname;
    DWORD rc;
    BOOL b;
    PCWSTR UnicodeMachineName;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
    } else {
        UnicodeMachineName = NULL;
    }

    b = SetupDiClassNameFromGuidExW(ClassGuid,
                                    UnicodeClassName,
                                    SIZECHARS(UnicodeClassName),
                                    &requiredsize,
                                    UnicodeMachineName,
                                    Reserved
                                   );
    rc = GetLastError();

    if(b) {
        if(ansiclassname = pSetupUnicodeToAnsi(UnicodeClassName)) {

            requiredsize = lstrlenA(ansiclassname)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    rc = ERROR_INVALID_PARAMETER;
                }
            }

            if(b) {
                if(requiredsize <= ClassNameSize) {
                    if(!lstrcpyA(ClassName,ansiclassname)) {
                        //
                        // ClassName must be bad because lstrcpy faulted
                        //
                        b = FALSE;
                        rc = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    b = FALSE;
                    rc = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            MyFree(ansiclassname);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiClassNameFromGuidExW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCWSTR      MachineName,   OPTIONAL
    IN  PVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassNameSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiClassNameFromGuidEx(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCTSTR      MachineName,   OPTIONAL
    IN  PVOID       Reserved
    )
/*++

Routine Description:

    This API retrieves the class name associated with the class GUID.  It does this
    by searching through all installed classes in the PnP Class branch of the registry.

Arguments:

    ClassGuid - Supplies the class GUID for which the class name is to be retrieved.

    ClassName - Receives the name of the class for the specified GUID.

    ClassNameSize - Supplies the size, in characters, of the ClassName buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class name (including terminating NULL).  This will always be less
        than MAX_CLASS_NAME_LEN.

    MachineName - Optionally, supplies the name of the remote machine where the specified
        class is installed.  If this parameter is not supplied, the local machine is
        used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    CONFIGRET cr;
    DWORD Err = NO_ERROR;
    HMACHINE hMachine;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the caller specified a remote machine name, connect to that machine now.
    //
    if(MachineName) {
        cr = CM_Connect_Machine(MachineName, &hMachine);
        if(cr != CR_SUCCESS) {
            SetLastError(MapCrToSpError(cr, ERROR_INVALID_DATA));
            return FALSE;
        }
    } else {
        hMachine = NULL;
    }

    try {
        //
        // Get the class name associated with this GUID.
        //
        cr = CM_Get_Class_Name_Ex((LPGUID)ClassGuid,
                                  ClassName,
                                  &ClassNameSize,
                                  0,
                                  hMachine
                                 );

        if((RequiredSize) && ((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL))) {
            *RequiredSize = ClassNameSize;
        }

        if(cr != CR_SUCCESS) {
            Err = (cr == CR_BUFFER_SMALL) ? ERROR_INSUFFICIENT_BUFFER
                                          : ERROR_INVALID_CLASS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiClassGuidsFromNameA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
{
    PWSTR classname;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(ClassName,&classname);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupDiClassGuidsFromNameExW(classname,ClassGuidList,ClassGuidListSize,RequiredSize,NULL,NULL);
    rc = GetLastError();

    MyFree(classname);
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiClassGuidsFromNameW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
{
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassGuidList);
    UNREFERENCED_PARAMETER(ClassGuidListSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiClassGuidsFromName(
    IN  PCTSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
/*++

Routine Description:

    See SetupDiClassGuidsFromNameEx for details.

--*/

{
    return SetupDiClassGuidsFromNameEx(ClassName,
                                       ClassGuidList,
                                       ClassGuidListSize,
                                       RequiredSize,
                                       NULL,
                                       NULL
                                      );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiClassGuidsFromNameExA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
{
    PCWSTR UnicodeClassName, UnicodeMachineName;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(ClassName, &UnicodeClassName);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
        if(rc != NO_ERROR) {
            MyFree(UnicodeClassName);
            SetLastError(rc);
            return FALSE;
        }
    } else {
        UnicodeMachineName = NULL;
    }

    b = SetupDiClassGuidsFromNameExW(UnicodeClassName,
                                     ClassGuidList,
                                     ClassGuidListSize,
                                     RequiredSize,
                                     UnicodeMachineName,
                                     Reserved
                                    );
    rc = GetLastError();

    MyFree(UnicodeClassName);

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiClassGuidsFromNameExW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCWSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassGuidList);
    UNREFERENCED_PARAMETER(ClassGuidListSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiClassGuidsFromNameEx(
    IN  PCTSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCTSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This API retrieves the GUID(s) associated with the specified class name.
    This list is built up based on what classes are currently installed on
    the system.

Arguments:

    ClassName - Supplies the class name for which to retrieve associated class GUIDs.

    ClassGuidList - Supplies a pointer to an array of GUIDs that will receive the
        list of GUIDs associated with the specified class name.

    ClassGuidListSize - Supplies the number of GUIDs in the ClassGuidList buffer.

    RequiredSize - Supplies a pointer to the variable that recieves the number of GUIDs
        associated with the class name.  If there are more GUIDs than there is room in
        the ClassGuidList buffer, then this value indicates how big the list must be in
        order to store all of the GUIDs.

    MachineName - Optionally, supplies the name of the remote machine where the specified
        class name is to be 'looked up' (i.e., where one or more classes are installed that
        have this name).  If this parameter is not specified, the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    BOOL MoreToEnum;
    DWORD Err = NO_ERROR;
    CONFIGRET cr;
    ULONG i, CurClassNameLen, GuidMatchCount = 0;
    GUID CurClassGuid;
    TCHAR CurClassName[MAX_CLASS_NAME_LEN];
    HMACHINE hMachine;

    //
    // Make sure the caller specified the class name, and didn't pass us anything in the
    // Reserved parameter.
    //
    if(!ClassName || Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the caller specified a remote machine name, connect to that machine now.
    //
    if(MachineName) {
        cr = CM_Connect_Machine(MachineName, &hMachine);
        if(cr != CR_SUCCESS) {
            SetLastError(MapCrToSpError(cr, ERROR_INVALID_DATA));
            return FALSE;
        }
    } else {
        hMachine = NULL;
    }

    try {
        //
        // Enumerate all the installed classes.
        //
        for(i = 0, MoreToEnum = TRUE; MoreToEnum; i++) {

            if((cr = CM_Enumerate_Classes_Ex(i, &CurClassGuid, 0, hMachine)) != CR_SUCCESS) {
                //
                // For any failure other than no-more-to-enum (or some kind of RPC error),
                // we simply want to go on to the next class.
                //
                switch(cr) {

                    case CR_INVALID_MACHINENAME :
                    case CR_REMOTE_COMM_FAILURE :
                    case CR_MACHINE_UNAVAILABLE :
                    case CR_NO_CM_SERVICES :
                    case CR_ACCESS_DENIED :
                    case CR_CALL_NOT_IMPLEMENTED :
                    case CR_REGISTRY_ERROR :
                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        //
                        // Fall through to 'no more values' case to terminate loop.
                        //
                    case CR_NO_SUCH_VALUE :
                        MoreToEnum = FALSE;
                        break;

                    default :
                        //
                        // Nothing to do.
                        //
                        break;

                }
                continue;
            }

            //
            // Now, retrieve the class name associated with this class GUID.
            //
            CurClassNameLen = SIZECHARS(CurClassName);
            if(CM_Get_Class_Name_Ex(&CurClassGuid,
                                    CurClassName,
                                    &CurClassNameLen,
                                    0,
                                    hMachine) != CR_SUCCESS) {
                continue;
            }

            //
            // See if the current class name matches the class we're interested in.
            //
            if(!lstrcmpi(ClassName, CurClassName)) {

                if(GuidMatchCount < ClassGuidListSize) {
                    CopyMemory(&(ClassGuidList[GuidMatchCount]), &CurClassGuid, sizeof(GUID));
                }

                GuidMatchCount++;
            }
        }

        if(Err == NO_ERROR) {

            *RequiredSize = GuidMatchCount;

            if(GuidMatchCount > ClassGuidListSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassDescriptionA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    )
{
    return SetupDiGetClassDescriptionExA(ClassGuid,
                                         ClassDescription,
                                         ClassDescriptionSize,
                                         RequiredSize,
                                         NULL,
                                         NULL
                                        );
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetClassDescriptionW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(ClassDescription);
    UNREFERENCED_PARAMETER(ClassDescriptionSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetClassDescription(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the class description associated with the specified
    class GUID.

Arguments:

    ClassGuid - Specifies the class GUID to retrieve the description for.

    ClassDescription - Supplies the address of the character buffer that is to receive
        the textual description of the class.

    ClassDescriptionSize - Supplies the size, in characters, of the ClassDescription buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class description (including terminating NULL).  This will always be less
        than LINE_LEN.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    return SetupDiGetClassDescriptionEx(ClassGuid,
                                        ClassDescription,
                                        ClassDescriptionSize,
                                        RequiredSize,
                                        NULL,
                                        NULL
                                       );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassDescriptionExA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCSTR       MachineName,          OPTIONAL
    IN  PVOID       Reserved
    )
{
    WCHAR UnicodeClassDescription[LINE_LEN];
    PSTR ansidescription;
    DWORD requiredsize;
    DWORD rc;
    BOOL b;
    PCWSTR UnicodeMachineName;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
    } else {
        UnicodeMachineName = NULL;
    }

    b = SetupDiGetClassDescriptionExW(ClassGuid,
                                      UnicodeClassDescription,
                                      SIZECHARS(UnicodeClassDescription),
                                      &requiredsize,
                                      UnicodeMachineName,
                                      Reserved
                                     );
    rc = GetLastError();

    if(b) {
        if(ansidescription = pSetupUnicodeToAnsi(UnicodeClassDescription)) {

            requiredsize = lstrlenA(ansidescription)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(b) {
                if(requiredsize <= ClassDescriptionSize) {
                    if(!lstrcpyA(ClassDescription,ansidescription)) {
                        //
                        // ClassDescription must be bad because lstrcpy faulted.
                        //
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }

            MyFree(ansidescription);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetClassDescriptionExW(
    IN  CONST GUID *ClassGuid,
    OUT PWSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCWSTR      MachineName,          OPTIONAL
    IN  PVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(ClassDescription);
    UNREFERENCED_PARAMETER(ClassDescriptionSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetClassDescriptionEx(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCTSTR      MachineName,          OPTIONAL
    IN  PVOID       Reserved
    )
/*++

Routine Description:

    This routine retrieves the class description associated with the specified
    class GUID.

Arguments:

    ClassGuid - Specifies the class GUID to retrieve the description for.

    ClassDescription - Supplies the address of the character buffer that is to receive
        the textual description of the class.

    ClassDescriptionSize - Supplies the size, in characters, of the ClassDescription buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class description (including terminating NULL).  This will always be less
        than LINE_LEN.

    MachineName - Optionally, supplies the name of the remote machine where the class
        whose name we're retrieving is installed.  If this parameter is not supplied,
        the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR;
    LONG l;
    TCHAR NullChar = TEXT('\0');
    CONFIGRET cr;
    HKEY hk = INVALID_HANDLE_VALUE;
    DWORD ValueType, BufferSize;
    BOOL DescFound = FALSE;
    HMACHINE hMachine;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the caller specified a remote machine name, connect to that machine now.
    //
    if(MachineName) {
        cr = CM_Connect_Machine(MachineName, &hMachine);
        if(cr != CR_SUCCESS) {
            SetLastError(MapCrToSpError(cr, ERROR_INVALID_DATA));
            return FALSE;
        }
    } else {
        hMachine = NULL;
    }

    try {

        if(CM_Open_Class_Key_Ex((LPGUID)ClassGuid,
                                NULL,
                                KEY_READ,
                                RegDisposition_OpenExisting,
                                &hk,
                                CM_OPEN_CLASS_KEY_INSTALLER,
                                hMachine) != CR_SUCCESS) {

            Err = ERROR_INVALID_CLASS;
            hk = INVALID_HANDLE_VALUE;
            goto clean0;
        }

        //
        // Retrieve the class description from the opened key.  This is an (optional)
        // unnamed REG_SZ value.
        //
        BufferSize = ClassDescriptionSize * sizeof(TCHAR);
        l = RegQueryValueEx(hk,
                            &NullChar,  // retrieved the unnamed value
                            NULL,
                            &ValueType,
                            (LPBYTE)ClassDescription,
                            &BufferSize
                           );
        if((l == ERROR_SUCCESS) || (l == ERROR_MORE_DATA)) {
            //
            // Verify that the data type is correct.
            //
            if(ValueType == REG_SZ) {
                DescFound = TRUE;
                BufferSize /= sizeof(TCHAR);    // we need this in characters
                //
                // Be careful here, because the user may have passed in a NULL
                // pointer for the ClassDescription buffer (ie, they just wanted
                // to know what size they needed).  RegQueryValueEx would return
                // ERROR_SUCCESS in this case, but we want to return
                // ERROR_INSUFFICIENT_BUFFER.
                //
                if((l == ERROR_MORE_DATA) || !ClassDescription) {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }

        if(!DescFound) {
            //
            // Then we simply retrieve the class name associated with this GUID--in
            // this case it serves as both name and description.
            //
            BufferSize = ClassDescriptionSize;
            cr = CM_Get_Class_Name_Ex((LPGUID)ClassGuid,
                                      ClassDescription,
                                      &BufferSize,
                                      0,
                                      hMachine
                                     );
            switch(cr) {

                case CR_BUFFER_SMALL :
                    Err = ERROR_INSUFFICIENT_BUFFER;
                    //
                    // Allow to fall through to CR_SUCCESS case.
                    //
                case CR_SUCCESS :
                    DescFound = TRUE;
                    break;

                case CR_REGISTRY_ERROR :
                    Err = ERROR_INVALID_CLASS;
                    break;

                default :
                    Err = ERROR_INVALID_PARAMETER;
            }
        }

        //
        // Store the required size in the output parameter, if supplied.
        //
        if(DescFound && RequiredSize) {
            *RequiredSize = BufferSize;
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variable so the compiler will respect statement ordering
        // w.r.t. assignment.
        //
        hk = hk;

    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiBuildClassInfoList(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
/*++

Routine Description:

    See SetupDiBuildClassInfoListEx for details.

--*/

{
    return SetupDiBuildClassInfoListEx(Flags, ClassGuidList, ClassGuidListSize, RequiredSize, NULL, NULL);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiBuildClassInfoListExA(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
{
    PCWSTR UnicodeMachineName;
    DWORD rc;
    BOOL b;

    b = FALSE;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
    } else {
        UnicodeMachineName = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        b = SetupDiBuildClassInfoListExW(Flags,
                                         ClassGuidList,
                                         ClassGuidListSize,
                                         RequiredSize,
                                         UnicodeMachineName,
                                         Reserved
                                        );
        rc = GetLastError();
        if(UnicodeMachineName) {
            MyFree(UnicodeMachineName);
        }
    }

    SetLastError(rc);
    return b;
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiBuildClassInfoListExW(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCWSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
{
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(ClassGuidList);
    UNREFERENCED_PARAMETER(ClassGuidListSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiBuildClassInfoListEx(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCTSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This routine returns a list of class GUIDs representing every class installed
    on the user's system. (NOTE: Classes that have a 'NoUseClass' value entry in
    their registry branch will be excluded from this list.)

Arguments:

    Flags - Supplies flags used to control exclusion of classes from the list.  If
        no flags are specified, then all classes are included.  The flags may be a
        combination of the following:

        DIBCI_NOINSTALLCLASS - Exclude a class if it has the value entry
                               'NoInstallClass' in its registry key.
        DIBCI_NODISPLAYCLASS - Exclude a class if it has the value entry
                               'NoDisplayClass' in its registry key.

    ClassGuidList - Supplies the address of an array of GUIDs that will receive the
        GUID list.

    ClassGuidListSize - Supplies the number of GUIDs in the ClassGuidList array.

    RequiredSize - Supplies the address of a variable that will receive the number
        of GUIDs returned.  If this number is greater than the size of the ClassGuidList,
        then this number will specify how large the array needs to be in order to contain
        the list.

    MachineName - Optionally, supplies the name of a remote machine to retrieve installed
        classes from.  If this parameter is not specified, the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR, ClassGuidCount = 0;
    CONFIGRET cr;
    BOOL MoreToEnum;
    ULONG i;
    HKEY hk = INVALID_HANDLE_VALUE;
    GUID CurClassGuid;
    HMACHINE hMachine;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the caller specified a remote machine name, connect to that machine now.
    //
    if(MachineName) {
        cr = CM_Connect_Machine(MachineName, &hMachine);
        if(cr != CR_SUCCESS) {
            SetLastError(MapCrToSpError(cr, ERROR_INVALID_DATA));
            return FALSE;
        }
    } else {
        hMachine = NULL;
    }

    try {
        //
        // Enumerate through the list of all installed classes.
        //
        for(i = 0, MoreToEnum = TRUE; MoreToEnum; i++) {

            cr = CM_Enumerate_Classes_Ex(i,
                                         &CurClassGuid,
                                         0,
                                         hMachine
                                        );
            if(cr != CR_SUCCESS) {
                //
                // For any failure other than no-more-to-enum (or some kind of RPC error),
                // we simply want to go on to the next class.
                //
                switch(cr) {

                    case CR_INVALID_MACHINENAME :
                    case CR_REMOTE_COMM_FAILURE :
                    case CR_MACHINE_UNAVAILABLE :
                    case CR_NO_CM_SERVICES :
                    case CR_ACCESS_DENIED :
                    case CR_CALL_NOT_IMPLEMENTED :
                    case CR_REGISTRY_ERROR :
                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        //
                        // Fall through to 'no more values' case to terminate loop.
                        //
                    case CR_NO_SUCH_VALUE :
                        MoreToEnum = FALSE;
                        break;

                    default :
                        //
                        // Nothing to do.
                        //
                        break;
                }
                continue;
            }

            //
            // Open the key for this class.
            //
            if(CM_Open_Class_Key_Ex(&CurClassGuid,
                                    NULL,
                                    KEY_READ,
                                    RegDisposition_OpenExisting,
                                    &hk,
                                    CM_OPEN_CLASS_KEY_INSTALLER,
                                    hMachine) != CR_SUCCESS) {

                hk = INVALID_HANDLE_VALUE;
                continue;
            }

            //
            // First, check for the presence of the value entry "NoUseClass"
            // If this value is present, then we will skip this class.
            //
            if(RegQueryValueEx(hk, pszNoUseClass, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                goto clean0;
            }

            //
            // Check for special exclusion flags.
            //
            if(Flags & DIBCI_NOINSTALLCLASS) {
                if(RegQueryValueEx(hk, pszNoInstallClass, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                    goto clean0;
                }
            }

            if(Flags & DIBCI_NODISPLAYCLASS) {
                if(RegQueryValueEx(hk, pszNoDisplayClass, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                    goto clean0;
                }
            }

            if(ClassGuidCount < ClassGuidListSize) {
                CopyMemory(&(ClassGuidList[ClassGuidCount]), &CurClassGuid, sizeof(GUID));
            }

            ClassGuidCount++;

clean0:
            RegCloseKey(hk);
            hk = INVALID_HANDLE_VALUE;
        }

        if(Err == NO_ERROR) {

            *RequiredSize = ClassGuidCount;

            if(ClassGuidCount > ClassGuidListSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hk != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk);
        }
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\decomp.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    decomp.c

Abstract:

    File decompression support routines.

Author:

    Ted Miller (tedm) 1-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <pshpack1.h>
struct LZINFO;
typedef struct LZINFO *PLZINFO;
#include <lz_header.h>
#include <poppack.h>


typedef struct _SFD_INFO {
    unsigned FileCount;
    PCTSTR TargetFile;
    BOOL GotTimestamp;
    FILETIME FileTime;
} SFD_INFO, *PSFD_INFO;


UINT
pGetCompressInfoCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );

UINT
pSingleFileDecompCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );

//
// OldMyMalloc/OldMyFree used by SetupGetFileCompressionInfo
// for app-compat
//
PVOID
OldMyMalloc(
    IN DWORD Size
    );

VOID
OldMyFree(
    IN PVOID Block
    );

PTSTR
SetupGenerateCompressedName(
    IN PCTSTR Filename
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise there is a 3-character or greater extension and we replace
    the last character with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

Return Value:

    Pointer to buffer containing nul-terminated compressed-form filename.
    The caller must free this buffer via MyFree().

--*/

{
    PTSTR CompressedName,p,q;
    UINT u;

    //
    // The maximum length of the compressed filename is the length of the
    // original name plus 2 (for ._).
    //
    if(CompressedName = MyMalloc((lstrlen(Filename)+3)*sizeof(TCHAR))) {

        lstrcpy(CompressedName,Filename);

        p = _tcsrchr(CompressedName,TEXT('.'));
        q = _tcsrchr(CompressedName,TEXT('\\'));
        if(q < p) {

            //
            // If there are 0, 1, or 2 characters after the dot, just append
            // the underscore.  p points to the dot so include that in the length.
            //
            u = lstrlen(p);
            if(u < 4) {
                lstrcat(CompressedName,TEXT("_"));
            } else {
                //
                // There are at least 3 characters in the extension.
                // Replace the final one with an underscore.
                //
                p[u-1] = TEXT('_');
            }
        } else {
            //
            // No dot, just add ._.
            //
            lstrcat(CompressedName,TEXT("._"));
        }
    }

    return(CompressedName);
}


DWORD
pSetupAttemptLocate(
    IN  PCTSTR           FileName,
    OUT PBOOL            Found,
    OUT PWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Attempt to locate a source file via FindFirstFile().

    Errors of the 'file not found' type are not considered errors
    and result in NO_ERROR. Any non-NO_ERROR return indicates that
    we could not determine whether the file is present or not
    because of some hardware or system problem, etc.

Arguments:

    FileName - supplies filename of the file to be located.

    Found - receives a value indicating whether the file was found.
        This value is only valid when the function returns NO_ERROR.

    FindData - if found, returns win32 find data for the file.

Return Value:

    Win32 error code indicating the outcome. If NO_ERROR, check
    the Found return value to see whether the file was found.

--*/

{
    DWORD d;

    if(*Found = FileExists(FileName,FindData)) {
        d = NO_ERROR;
    } else {
        //
        // We didn't find the file. See whether that was because
        // the file wasn't there or because some other error occured.
        //
        d = GetLastError();

        if((d == ERROR_NO_MORE_FILES)
        || (d == ERROR_FILE_NOT_FOUND)
        || (d == ERROR_PATH_NOT_FOUND)
        || (d == ERROR_BAD_NETPATH))
        {
            d = NO_ERROR;
        }
    }

    return(d);
}


DWORD
SetupDetermineSourceFileName(
    IN  PCTSTR            FileName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated,
    OUT PWIN32_FIND_DATA  FindData
    )

/*++

Routine Description:

    Attempt to locate a source file whose name can be compressed
    or uncompressed.

    The order of attempt is

    - the name as given (should be the uncompressed name)
    - the compressed form, using _ as the compression char
    - the compressed form, using $ as the compression char

Arguments:

    FileName - supplies filename of the file to be located.

    UsedCompressedName - receives a boolean indicating whether
        the filename we located seems to indicate that the file
        is compressed.

    FileNameLocated - receives a pointer to the filename actually
        located. The caller must free with MyFree().

    FindData - if found, returns win32 find data for the file.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located; check UsedCompressedName and FileNameOpened.

    Others - something is wrong with the hardware or system.

--*/

{
    DWORD d;
    PTSTR TryName;
    BOOL Found;


    TryName = DuplicateString(FileName);
    if(!TryName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *UsedCompressedName = FALSE;
    *FileNameLocated = TryName;

    d = pSetupAttemptLocate(TryName,&Found,FindData);
    if(d != NO_ERROR) {
        MyFree(TryName);
        *FileNameLocated = NULL;
        return(d);
    }

    if(Found) {
        return(NO_ERROR);
    }

    MyFree(TryName);
    *UsedCompressedName = TRUE;
    *FileNameLocated = NULL;

    TryName = SetupGenerateCompressedName(FileName);
    if(!TryName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *FileNameLocated = TryName;

    d = pSetupAttemptLocate(TryName,&Found,FindData);
    if(d != NO_ERROR) {
        MyFree(TryName);
        *FileNameLocated = NULL;
        return(d);
    }

    if(Found) {
        return(NO_ERROR);
    }

    MYASSERT(TryName[lstrlen(TryName)-1] == TEXT('_'));
    TryName[lstrlen(TryName)-1] = TEXT('$');

    d = pSetupAttemptLocate(TryName,&Found,FindData);

    if((d != NO_ERROR) || !Found) {
        *FileNameLocated = NULL;
        MyFree(TryName);
    }

    return(Found ? NO_ERROR : ERROR_FILE_NOT_FOUND);
}

BOOL
pSetupDoesFileMatch(
    IN  PCTSTR            InputName,
    IN  PCTSTR            CompareName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated
    )

/*++

Routine Description:

    determine if the specified input file matches the
    name to compare it with.  We try the undecorated name
    as well as the compressed versions of the file name.

    The order of attempt is

    - the name as given (should be the uncompressed name)
    - the compressed form, using _ as the compression char
    - the compressed form, using $ as the compression char

Arguments:

    FileName - supplies filename we're looking at.

    CompareName -supplies the filename we're comparing against

    UsedCompressedName - receives a boolean indicating whether
        the filename we located seems to indicate that the file
        is compressed.

    FileNameLocated - receives a pointer to the filename actually
        located. The caller must free with MyFree().


Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located; check UsedCompressedName and FileNameOpened.

    Others - something is wrong with the hardware or system.

--*/

{
    DWORD d;
    PTSTR TryName,TargetName,src,dst;
    BOOL Found;


    TryName = DuplicateString(InputName);
    if(!TryName) {
        return(FALSE);
    }

    TargetName = DuplicateString(CompareName);
    if(!TargetName) {
        MyFree(TryName);
        return(FALSE);
    }

    dst = _tcsrchr(TryName,TEXT('.'));
    if (dst) {
        *dst = 0;
    }
    src = _tcsrchr(TargetName,TEXT('.'));
    if (src) {
        *src = 0;
    }

    if (lstrcmpi(TargetName,TryName)) {
        // the "surnames" do not match, so none of the other comparisons will work.
        MyFree(TryName);
        MyFree(TargetName);
        return(FALSE);
    }

    if (dst) {
        *dst = TEXT('.');
    }

    if (src) {
        *src = TEXT('.');
    }

    *UsedCompressedName = FALSE;
    *FileNameLocated = TryName;

    if (!lstrcmpi(TryName,TargetName)) {
        // we matched
        MyFree(TargetName);
        return(TRUE);
    }

    MyFree(TryName);
    *UsedCompressedName = TRUE;

    TryName = SetupGenerateCompressedName(TargetName);
    if(!TryName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *FileNameLocated = TryName;

    if (!lstrcmpi(TryName,InputName)) {
        // we matched
        MyFree(TargetName);
        return(TRUE);
    }

    MYASSERT(TryName[lstrlen(TryName)-1] == TEXT('_'));
    TryName[lstrlen(TryName)-1] = TEXT('$');

    if (!lstrcmpi(TryName,InputName)) {
        // we matched
        MyFree(TargetName);
        return(TRUE);
    }

    //
    // no match
    //
    MyFree(TargetName);
    MyFree(TryName);

    return(FALSE);
}



DWORD
pSetupDecompressWinLzFile(
    IN PTSTR SourceFileName,
    IN PTSTR TargetFileName
    )

/*++

Routine Description:

    Determine whether a file is compressed, and retreive additional
    information about it.

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileName - receives a pointer to the filename
        that was actually located. Caller can free with MyFree().
        Valid only if the return code from this routine is NO_ERROR.

    SourceFileSize - receives the size of the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and output params are filled in.

    Others - something is wrong with the hardware or system.

--*/

{
    INT hSrc,hDst;
    OFSTRUCT ofSrc,ofDst;
    LONG l;
    DWORD d;
    FILETIME CreateTime,AccessTime,WriteTime;

    //
    // Get the timestamp of the source.
    //
    d = GetSetFileTimestamp(
            SourceFileName,
            &CreateTime,
            &AccessTime,
            &WriteTime,
            FALSE
            );

    if(d != NO_ERROR) {
        return(d);
    }

    hSrc = LZOpenFile(SourceFileName,&ofSrc,OF_READ|OF_SHARE_DENY_WRITE);
    if(hSrc >= 0) {

        hDst = LZOpenFile(TargetFileName,&ofSrc,OF_CREATE|OF_WRITE|OF_SHARE_EXCLUSIVE);
        if(hDst >= 0) {

            l = LZCopy(hSrc,hDst);
            if(l >= 0) {
                l = 0;

                //
                // Set the timestamp of the target. The file is already there
                // so just ignore errors.
                //
                GetSetFileTimestamp(
                    TargetFileName,
                    &CreateTime,
                    &AccessTime,
                    &WriteTime,
                    TRUE
                    );
            }

            LZClose(hDst);

        } else {
            l = hDst;
        }

        LZClose(hSrc);

    } else {
        l = hSrc;
    }

    //
    // lz error to win32 error
    //
    switch(l) {

    case 0:
        return(NO_ERROR);

    case LZERROR_BADINHANDLE:
    case LZERROR_READ:
        return(ERROR_READ_FAULT);

    case LZERROR_BADOUTHANDLE:
    case LZERROR_WRITE:
        return(ERROR_WRITE_FAULT);

    case LZERROR_GLOBALLOC:
    case LZERROR_GLOBLOCK:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case LZERROR_BADVALUE:
    case LZERROR_UNKNOWNALG:
        return(ERROR_INVALID_DATA);

    default:
        return(ERROR_INVALID_FUNCTION);
    }
}


DWORD
SetupInternalGetFileCompressionInfo(
    IN  PCTSTR            SourceFileName,
    OUT PTSTR            *ActualSourceFileName,
    OUT PWIN32_FIND_DATA  SourceFindData,
    OUT PDWORD            TargetFileSize,
    OUT PUINT             CompressionType
    )

/*++

Routine Description:

    Determine whether a file is compressed, and retreive additional
    information about it.

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileName - receives a pointer to the filename
        that was actually located. Caller can free with MyFree().
        Valid only if the return code from this routine is NO_ERROR.

    SourceFindData - receives win32 find data for the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and output params are filled in.

    Others - something is wrong with the hardware or system.

--*/

{
    DWORD d;
    DWORD caberr = NO_ERROR;
    BOOL b;
    HANDLE hFile,hMapping;
    DWORD size;
    FH UNALIGNED *LZHeader;

    d = SetupDetermineSourceFileName(
            SourceFileName,
            &b,
            ActualSourceFileName,
            SourceFindData
            );

    if(d != NO_ERROR) {
        return(d);
    }

    //
    // If the file is 0-length it isn't compressed;
    // trying to map it in below will fail in this case.
    //
    if(SourceFindData->nFileSizeLow) {

        //
        // See if it's a diamond file.
        //
        d = DiamondProcessCabinet(
                *ActualSourceFileName,
                0,
                pGetCompressInfoCB,
                &size,
                TRUE
                );

        if(d == NO_ERROR) {

            *TargetFileSize = size;
            *CompressionType = FILE_COMPRESSION_MSZIP;
            return(NO_ERROR);
        } else if (d != ERROR_INVALID_DATA) {
            //
            // general problems not specific to the file format itself
            // however if this might be a plain file, ignore it
            //
            size_t len1 = lstrlen(SourceFileName);
            size_t len2 = lstrlen(*ActualSourceFileName);
            TCHAR c1 = *CharPrev(SourceFileName,SourceFileName+len1);
            TCHAR c2 = *CharPrev(*ActualSourceFileName,*ActualSourceFileName+len2);
            if(((c2 == TEXT('_')) || (c2 == TEXT('$'))) && ((len1 != len2) || (c1 != c2))) {
                //
                // ActualSourceFileName ends in '_' or '$' and is a modification of SourceFileName
                // don't let us try and parse this as a plain file
                //
                caberr = d;
            }
        }

        //
        // See if it's a WINLZ file.
        //
        d = pSetupOpenAndMapFileForRead(
                *ActualSourceFileName,
                &SourceFindData->nFileSizeLow,
                &hFile,
                &hMapping,
                (PVOID *)&LZHeader
                );

        if(d != NO_ERROR) {
            MyFree(*ActualSourceFileName);
            return(d);
        }

        b = FALSE;
        try {
            if((SourceFindData->nFileSizeLow >= HEADER_LEN)
            && !memcmp(LZHeader->rgbyteMagic,COMP_SIG,COMP_SIG_LEN)
            && RecognizeCompAlg(LZHeader->byteAlgorithm))
            {
                *TargetFileSize = LZHeader->cbulUncompSize;
                b = TRUE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }

        pSetupUnmapAndCloseFile(hFile,hMapping,LZHeader);

        if(b) {
            *CompressionType = FILE_COMPRESSION_WINLZA;
            return(NO_ERROR);
        }

        if(caberr) {
            //
            // looks like a compressed file and DiamondProcessCabinet
            // returned a suspicious error
            //
            return(caberr);
        }
    }

    //
    // File is not compressed.
    //
    *CompressionType = FILE_COMPRESSION_NONE;
    *TargetFileSize = SourceFindData->nFileSizeLow;
    return(NO_ERROR);
}


UINT
pGetCompressInfoCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    PFILE_IN_CABINET_INFO FileInfo;
    DWORD rc;

    switch(Notification) {

    case SPFILENOTIFY_CABINETINFO:
        //
        // We don't do anything with this.
        //
        rc = NO_ERROR;
        break;

    case SPFILENOTIFY_FILEINCABINET:
        //
        // New file within a cabinet.
        //
        // We don't ever want to copy the file. Save size info
        // and abort.
        //
        FileInfo = (PFILE_IN_CABINET_INFO)Param1;

        *((PDWORD)Context) = FileInfo->FileSize;

        FileInfo->Win32Error = NO_ERROR;
        rc = FILEOP_ABORT;
        SetLastError(NO_ERROR);
        break;

    //case SPFILENOTIFY_FILEEXTRACTED:
    //case SPFILENOTIFY_NEEDNEWCABINET:
    default:
        //
        // We should never get these.
        //
        MYASSERT(0);
        rc = ERROR_INVALID_FUNCTION;
        break;
    }

    return(rc);
}


#ifdef UNICODE
//
// ANSI version
//
DWORD
SetupGetFileCompressionInfoA(
    IN  PCSTR   SourceFileName,
    OUT PSTR   *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCWSTR source;
    PWSTR actualsource = NULL;
    PSTR actualsourceansi = NULL;
    PSTR la_actualsourceansi = NULL;
    DWORD targetsize;
    UINT type;

    d = pSetupCaptureAndConvertAnsiArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        return(d);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {

        MYASSERT(actualsource);

        if((actualsourceansi = pSetupUnicodeToAnsi(actualsource))==NULL) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        if((la_actualsourceansi = (PSTR)OldMyMalloc(1+strlen(actualsourceansi)))==NULL) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        strcpy(la_actualsourceansi,actualsourceansi);
        try {
            *SourceFileSize = FindData.nFileSizeLow;
            *ActualSourceFileName = la_actualsourceansi; // free using LocalFree
            *TargetFileSize = targetsize;
            *CompressionType = type;
            la_actualsourceansi = NULL;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    }

clean0:
    if(actualsource) {
        MyFree(actualsource);
    }
    if(actualsourceansi) {
        MyFree(actualsourceansi);
    }
    if(la_actualsourceansi) {
        OldMyFree(la_actualsourceansi);
    }

    MyFree(source);

    return(d);
}
#else
//
// Unicode stub
//
DWORD
SetupGetFileCompressionInfoW(
    IN  PCWSTR  SourceFileName,
    OUT PWSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(ActualSourceFileName);
    UNREFERENCED_PARAMETER(SourceFileSize);
    UNREFERENCED_PARAMETER(TargetFileSize);
    UNREFERENCED_PARAMETER(CompressionType);
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif

DWORD
SetupGetFileCompressionInfo(
    IN  PCTSTR  SourceFileName,
    OUT PTSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )

/*++

Routine Description:

    Here for App-Compat only
    Replaced by SetupGetFileCompressionInfoEx

    Return pointer is allocated by OldMyMalloc,
    it can be freed by (*cough*) OldMyFree (exported as MyFree)
    This is because there are apps out there that use this,
    and run-time link to setupapi!MyFree to release memory

    !!!! DO NOT USE THIS API !!!!

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileName - receives a pointer to the filename
        that was actually located. Caller can free with exported MyFree().
        Valid only if the return code from this routine is NO_ERROR.

    SourceFileSize - receives the size of the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and output params are filled in.

    Others - something is wrong with the hardware or system.

--*/

{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCTSTR source;
    PTSTR actualsource = NULL;
    PTSTR la_actualsource = NULL;
    DWORD targetsize;
    UINT type;

    d = CaptureStringArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        return(d);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {
        MYASSERT(actualsource);
        la_actualsource = (PTSTR)OldMyMalloc(sizeof(TCHAR)*(1+lstrlen(actualsource)));
        if (la_actualsource == NULL) {
            MyFree(actualsource);
            MyFree(source);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        lstrcpy(la_actualsource,actualsource);
        try {
            *SourceFileSize = FindData.nFileSizeLow;
            *ActualSourceFileName = la_actualsource; // free using LocalFree
            *TargetFileSize = targetsize;
            *CompressionType = type;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
        if(d != NO_ERROR) {
            OldMyFree(la_actualsource);
        }
        MyFree(actualsource);
    }

    MyFree(source);

    return(d);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupGetFileCompressionInfoExA(
    IN  PCSTR   SourceFileName,
    IN  PSTR    ActualSourceFileNameBuffer,
    IN  DWORD   ActualSourceFileNameBufferLen,
    OUT PDWORD  RequiredBufferLen,              OPTIONAL
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCWSTR source;
    PWSTR actualsource = NULL;
    PSTR actualsourceansi = NULL;
    DWORD targetsize;
    DWORD reqbufsize;
    UINT type;

    d = pSetupCaptureAndConvertAnsiArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        SetLastError(d);
        return (d==NO_ERROR);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {
        MYASSERT(actualsource);
        actualsourceansi = pSetupUnicodeToAnsi(actualsource);
        if(actualsourceansi != NULL) {
            try {
                reqbufsize = strlen(actualsourceansi)+1;
                if (RequiredBufferLen) {
                    *RequiredBufferLen = reqbufsize;
                }
                if(ActualSourceFileNameBuffer) {
                    if((ActualSourceFileNameBufferLen < reqbufsize)) {
                        d = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        strcpy(ActualSourceFileNameBuffer,actualsourceansi);
                    }
                } else if(ActualSourceFileNameBufferLen) {
                    d = ERROR_INVALID_USER_BUFFER;
                }
                *SourceFileSize = FindData.nFileSizeLow;
                *TargetFileSize = targetsize;
                *CompressionType = type;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                d = ERROR_INVALID_PARAMETER;
            }
        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(actualsource) {
        MyFree(actualsource);
    }
    if(actualsourceansi) {
        MyFree(actualsourceansi);
    }
    MyFree(source);

    SetLastError(d);
    return (d==NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupGetFileCompressionInfoExW(
    IN  PCWSTR  SourceFileName,
    IN  PWSTR   ActualSourceFileNameBuffer,
    IN  DWORD   ActualSourceFileNameBufferLen,
    OUT PDWORD  RequiredBufferLen,              OPTIONAL
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(ActualSourceFileNameBuffer);
    UNREFERENCED_PARAMETER(ActualSourceFileNameBufferLen);
    UNREFERENCED_PARAMETER(RequiredBufferLen);
    UNREFERENCED_PARAMETER(SourceFileSize);
    UNREFERENCED_PARAMETER(TargetFileSize);
    UNREFERENCED_PARAMETER(CompressionType);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupGetFileCompressionInfoEx(
    IN  PCTSTR  SourceFileName,
    IN  PTSTR   ActualSourceFileNameBuffer,
    IN  DWORD   ActualSourceFileNameBufferLen,
    OUT PDWORD  RequiredBufferLen,              OPTIONAL
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )

/*++

Routine Description:

    Determine whether a file is compressed, and retreive additional
    information about it.
    This is the replacement for the very broken SetupGetFileCompressionInfo
    Caller must pass in a buffer
    If the buffer is NULL, return size
    and all other parameters filled out (unless some other error occurred)
    note however, you would typically call this with a buffer size of MAX_PATH.

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileNameBuffer - if not NULL, receives actual filename
        Valid only if the return code from this routine is NO_ERROR.

    ActualSourceFileNameBufferLen - pass in length (characters) of
        ActualSourceFileNameBuffer. must be 0 if ActualSourceFileNameBuffer
        is NULL.

    RequiredBufferLen - if not NULL, filled with length of actual filename
        including terminating NULL.
        Valid only if the return code from this routine is NO_ERROR or ERROR_INSUFFICIENT_BUFFER.

    SourceFileSize - receives the size of the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR or  ERROR_INSUFFICIENT_BUFFER.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR or  ERROR_INSUFFICIENT_BUFFER.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR or  ERROR_INSUFFICIENT_BUFFER.

Return Value:

    TRUE indicating success (NO_ERROR)
    FALSE indicating failure
    GetLastError() provides Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and all output params are filled in including ActualSourceFileNameBuffer.
        also returned if ActualSourceFileNameBuffer is NULL

    ERROR_INSUFFICIENT_BUFFER - file was located and output params are filled in, excluding
        ActualSourceFileNameBuffer.

    Others - something is wrong with the hardware or system.

--*/

{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCTSTR source;
    PTSTR actualsource = NULL;
    DWORD targetsize;
    UINT type;
    DWORD reqbufsize;

    d = CaptureStringArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        SetLastError(d);
        return (d==NO_ERROR);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {
        MYASSERT(actualsource);
        try {
            reqbufsize = lstrlen(actualsource)+1;
            if (RequiredBufferLen) {
                *RequiredBufferLen = reqbufsize;
            }
            if(ActualSourceFileNameBuffer) {
                if(ActualSourceFileNameBufferLen < reqbufsize) {
                    d = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    lstrcpy(ActualSourceFileNameBuffer,actualsource);
                }
            } else if(ActualSourceFileNameBufferLen) {
                d = ERROR_INVALID_USER_BUFFER;
            }
            *SourceFileSize = FindData.nFileSizeLow;
            *TargetFileSize = targetsize;
            *CompressionType = type;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
        MyFree(actualsource);
    }

    MyFree(source);

    SetLastError(d);
    return (d==NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
DWORD
SetupDecompressOrCopyFileA(
    IN  PCSTR   SourceFileName,
    OUT PCSTR   TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    )
{
    DWORD rc;
    PCWSTR s,t;

    rc = pSetupCaptureAndConvertAnsiArg(SourceFileName,&s);
    if(rc == NO_ERROR) {

        rc = pSetupCaptureAndConvertAnsiArg(TargetFileName,&t);
        if(rc == NO_ERROR) {

            rc = pSetupDecompressOrCopyFile(s,t,CompressionType,FALSE,NULL);
            MyFree(t);
        }

        MyFree(s);
    }

    return(rc);
}
#else
//
// Unicode stub
//
DWORD
SetupDecompressOrCopyFileW(
    IN  PCWSTR  SourceFileName,
    OUT PCWSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(TargetFileName);
    UNREFERENCED_PARAMETER(CompressionType);
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif

DWORD
SetupDecompressOrCopyFile(
    IN PCTSTR SourceFileName,
    IN PCTSTR TargetFileName,
    IN PUINT  CompressionType OPTIONAL
    )

/*++

Routine Description:

    Decompress or copy a file.

Arguments:

    SourceFileName - supplies filename of the file to be decompressed.
        If CompressionType is specified, no additional processing is
        performed on this name -- the caller is responsible for determining
        the actual file name (ie, foo.ex_ instead of foo.exe) before calling
        this routine. If CompressionType is not specified, then this routine
        attempts to locate the compressed form of the filename if the file
        is not found with the name given.

    TargetFileName - supplies filename of target file.

    CompressionType - if specified, supplies type of compression in use
        on the source. This can be determined by calling
        SetupGetFileCompressionInfo(). Specifying FILE_COMPRESSION_NONE
        results in the file being copied and not decompressed,
        regardless of the type of compression that may be in use on the source.
        If this value is not specified then this routine attempts to determine
        the compression type and decompresses/copies accordingly.

Return Value:

    Win32 error code indicating the outcome.

--*/

{
    DWORD rc;
    PCTSTR s,t;

    rc = CaptureStringArg(SourceFileName,&s);
    if(rc == NO_ERROR) {

        rc = CaptureStringArg(TargetFileName,&t);
        if(rc == NO_ERROR) {

            rc = pSetupDecompressOrCopyFile(s,t,CompressionType,FALSE,NULL);
            MyFree(t);
        }

        MyFree(s);
    }

    return(rc);
}


DWORD
pSetupDecompressOrCopyFile(
    IN  PCTSTR SourceFileName,
    IN  PCTSTR TargetFileName,
    IN  PUINT  CompressionType, OPTIONAL
    IN  BOOL   AllowMove,
    OUT PBOOL  Moved            OPTIONAL
    )

/*++

Routine Description:

    Decompress or copy a file.

Arguments:

    SourceFileName - supplies filename of the file to be decompressed.
        If CompressionType is specified, no additional processing is
        performed on this name -- the caller is responsible for determining
        the actual file name (ie, foo.ex_ instead of foo.exe) before calling
        this routine. If CompressionType is not specified, then this routine
        attempts to locate the compressed form of the filename if the file
        is not found with the name given.

    TargetFileName - supplies filename of target file.

    CompressionType - if specified, supplies type of compression in use
        on the source. This can be determined by calling
        SetupGetFileCompressionInfo(). Specifying FILE_COMPRESSION_NONE
        results in the file being copied and not decompressed,
        regardless of the type of compression that may be in use on the source.
        If this value is not specified then this routine attempts to determine
        the compression type and decompresses/copies accordingly.

    AllowMove - if specified, then files that do not require decompression
        will be moved instead of copied.

    Moved - if specified receives a boolean indicating whether the file was
        moved (as opposed to copied or decompressed).

Return Value:

    Win32 error code indicating the outcome.

--*/

{
    DWORD d;
    UINT ComprType;
    PTSTR ActualName;
    DWORD TargetSize;
    FILETIME CreateTime,AccessTime,WriteTime;
    SFD_INFO CBData;
    BOOL moved;
    WIN32_FIND_DATA FindData;

    if(Moved) {
        *Moved = FALSE;
    }

    if(CompressionType) {
        ComprType = *CompressionType;
        ActualName = (PTSTR)SourceFileName;
    } else {
        //
        // Need to determine compresison type.
        //
        d = SetupInternalGetFileCompressionInfo(
                SourceFileName,
                &ActualName,
                &FindData,
                &TargetSize,
                &ComprType
                );

        if(d != NO_ERROR) {
            return(d);
        }
    }

    //
    // Blast the target file. Ignore if failure -- it'll be caught later.
    //
    SetFileAttributes(TargetFileName,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(TargetFileName);

    switch(ComprType) {

    case FILE_COMPRESSION_NONE:
        moved = (AllowMove ? MoveFile(ActualName,TargetFileName) : FALSE);
        if(moved) {
            d = NO_ERROR;
            if(Moved) {
                *Moved = TRUE;
            }
        } else {
            d = GetSetFileTimestamp(ActualName,&CreateTime,&AccessTime,&WriteTime,FALSE);
            if(d == NO_ERROR) {
                d = CopyFile(ActualName,TargetFileName,FALSE) ? NO_ERROR : GetLastError();
                if(d == NO_ERROR) {
                    GetSetFileTimestamp(TargetFileName,&CreateTime,&AccessTime,&WriteTime,TRUE);
                }
            }
        }
        break;

    case FILE_COMPRESSION_WINLZA:
        d = pSetupDecompressWinLzFile(ActualName,(PTSTR)TargetFileName);
        break;

    case FILE_COMPRESSION_MSZIP:

        CBData.FileCount = 0;
        CBData.TargetFile = TargetFileName;
        CBData.GotTimestamp = FALSE;

        d = DiamondProcessCabinet(
                ActualName,
                0,
                pSingleFileDecompCB,
                &CBData,
                TRUE
                );
        break;

    default:
        d = ERROR_INVALID_PARAMETER;
        break;
    }

    if(!CompressionType) {
        MyFree(ActualName);
    }

    return(d);
}


UINT
pSingleFileDecompCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    PSFD_INFO Data;
    PFILE_IN_CABINET_INFO FileInfo;
    PFILEPATHS FilePaths;
    DWORD rc;
    HANDLE h;

    Data = Context;

    switch(Notification) {

    case SPFILENOTIFY_CABINETINFO:
        //
        // We don't do anything with this.
        //
        rc = NO_ERROR;
        break;

    case SPFILENOTIFY_FILEINCABINET:
        //
        // New file within a cabinet.
        //
        FileInfo = (PFILE_IN_CABINET_INFO)Param1;
        FileInfo->Win32Error = NO_ERROR;

        //
        // We only want the first file. If this is a subsequent file,
        // bail out.
        //
        if(Data->FileCount++) {

            rc = FILEOP_ABORT;
            SetLastError(NO_ERROR);

        } else {
            //
            // We want the file. Ignore the names in the cabinet and
            // use the name given to us. Also, we want to preserve
            // the timestamp of the cabinet, not of the file within it.
            //
            lstrcpyn(FileInfo->FullTargetName,Data->TargetFile,MAX_PATH);

            h = CreateFile(
                    (PCTSTR)Param2,         // cabinet filename
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

            if(h != INVALID_HANDLE_VALUE) {
                if(GetFileTime(h,NULL,NULL,&Data->FileTime)) {
                    Data->GotTimestamp = TRUE;
                }
                CloseHandle(h);
            }

            rc = FILEOP_DOIT;
        }

        break;

    case SPFILENOTIFY_FILEEXTRACTED:
        //
        // File was successfully extracted.
        // Preserve timestamp.
        //
        FilePaths = (PFILEPATHS)Param1;

        if(Data->GotTimestamp) {

            h = CreateFile(
                    FilePaths->Target,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

            if(h != INVALID_HANDLE_VALUE) {
                SetFileTime(h,NULL,NULL,&Data->FileTime);
                CloseHandle(h);
            }
        }

        rc = NO_ERROR;
        break;

    //case SPFILENOTIFY_NEEDNEWCABINET:
    default:
        //
        // We should never get this.
        //
        MYASSERT(0);
        rc = ERROR_INVALID_FUNCTION;
        break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devicon.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    devicon.c

Abstract:

    Device Installer routines dealing with retrieval/display of icons.

Author:

    Lonny McMichael (lonnym) 28-Aug--1995

Notes:

    You must include "basetyps.h" first.

--*/

#include "precomp.h"
#pragma hdrstop
#include <shellapi.h>


MINI_ICON_LIST GlobalMiniIconList;


/*++

    Class-to-Icon conversion tables exist in two places.  First, there
    is the built-in one defined below that is based on a hard-wired
    bitmap in the resource.  The second is a linked list of CLASSICON
    structures that is created every time a new class with an icon
    comes along.

    Check out resource\ilwinmsd.bmp to see the mini-icons.  The icons
    are referenced via their (zero-based) index (e.g., computer is 0,
    chip is 1, display is 2, etc.).  Today, the bitmap indexes look as follows:

        0 - computer
        1 - chip
        2 - display
        3 - network
        4 - windows
        5 - mouse
        6 - keyboard
        7 - phone
        8 - sound
        9 - drives
        10 - plugs
        11 - generic
        12 - check
        13 - uncheck
        14 - printer
        15 - nettrans
        16 - netclient
        17 - netservice
        18 - unknown
        19 - Fax machine
        20 - greyed check
        21 - dial up networking
        22 - direct cable connection
        23 - briefcase (filesync)
        24 - Exchange
        25 - partial check
        26 - Generic folder / Accessories
        27 - media (music)
        28 - Quick View
        29 - old MSN
        30 - calculator
        31 - FAT32 Converter
        32 - Document Templates
        33 - disk compression
        34 - Games
        35 - HyperTerminal
        36 - package
        37 - mspaint
        38 - Screensavers
        39 - WordPad
        40 - Clipboard Viewer
        41 - Accessibility Options
        42 - backup
        43 - Desktop Wallpaper
        44 - Character Map
        45 - Mouse Pointers
        46 - Net Watcher
        47 - phone dialer
        48 - resource monitor
        49 - Online User's Guide
        50 - Multilanguage Support
        51 - Audio Compression
        52 - CD player
        53 - Media Player
        54 - WAV sounds
        55 - Sample Sounds
        56 - Video Compression
        57 - Volume Control
        58 - Musica sound scheme
        59 - Jungle sound scheme
        60 - Robotz sound scheme
        61 - Utopia sound scheme
        62 - Eudcedit
        63 - Minesweeper
        64 - Pinball
        65 - Imaging
        66 - Clock
        67 - Infrared
        68 - MS Wallet
        69 - FrontPage Express (aka FrontPad)
        70 - MS Agent
        71 - Internet Tools
        72 - NetShow Player
        73 - Net Meeting
        74 - DVD Player
        75 - Freecell
        76 - Athena / Outlook Express / Internet Mail and News
        77 - Desktop Themes
        78 - Baseball theme
        79 - Dangerous Creatures theme
        80 - Inside your Computer theme
        81 - Jungle theme
        82 - Leonardo da Vinci theme
        83 - More Windows theme
        84 - Mystery theme
        85 - Nature theme
        86 - Science theme
        87 - Space theme
        88 - Sports theme
        89 - The 60's USA theme
        90 - The Golden Era theme
        91 - Travel theme
        92 - Underwater theme
        93 - Windows 95 theme
        94 - Personal Web Server
        95 - Real Audio
        96 - Web Publisher / WebPost
        97 - WaveTop
        98 - WebTV

--*/

CONST INT UnknownClassMiniIconIndex = 11;

CONST CLASSICON MiniIconXlate[] = { {&GUID_DEVCLASS_COMPUTER,      0, NULL},
                                    {&GUID_DEVCLASS_DISPLAY,       2, NULL},
                                    {&GUID_DEVCLASS_MOUSE,         5, NULL},
                                    {&GUID_DEVCLASS_KEYBOARD,      6, NULL},
                                    {&GUID_DEVCLASS_FDC,           9, NULL},
                                    {&GUID_DEVCLASS_HDC,           9, NULL},
                                    {&GUID_DEVCLASS_PORTS,        10, NULL},
                                    {&GUID_DEVCLASS_NET,          15, NULL},
                                    {&GUID_DEVCLASS_SYSTEM,        0, NULL},
                                    {&GUID_DEVCLASS_SOUND,         8, NULL},
                                    {&GUID_DEVCLASS_PRINTER,      14, NULL},
                                    {&GUID_DEVCLASS_MONITOR,       2, NULL},
                                    {&GUID_DEVCLASS_NETTRANS,      3, NULL},
                                    {&GUID_DEVCLASS_NETCLIENT,    16, NULL},
                                    {&GUID_DEVCLASS_NETSERVICE,   17, NULL},
                                    {&GUID_DEVCLASS_UNKNOWN,      18, NULL},
                                    {&GUID_DEVCLASS_LEGACYDRIVER, 11, NULL},
                                    {&GUID_DEVCLASS_MTD,           9, NULL}
                                  };

#define MINIX 16
#define MINIY 16

#define RGB_WHITE (RGB(255, 255, 255))
#define RGB_BLACK (RGB(0, 0, 0))
#define RGB_TRANSPARENT (RGB(0, 128, 128))


// This should removed when WINVER defined >= 0x0500 for this project.
#ifndef NOMIRRORBITMAP

#ifdef UNICODE
#define NOMIRRORBITMAP      (DWORD)0x80000000 /* Do not Mirror the bitmap in this call */
#else
#define NOMIRRORBITMAP      (DWORD)0x0
#endif //UNICODE

#endif

//
// Private function prototypes.
//
INT
NewMiniIcon(
    IN CONST GUID *ClassGuid,
    IN HICON       hIcon      OPTIONAL
    );


INT
WINAPI
SetupDiDrawMiniIcon(
    IN HDC   hdc,
    IN RECT  rc,
    IN INT   MiniIconIndex,
    IN DWORD Flags
    )
/*++

Routine Description:

    This routine draws the specified mini-icon at the requested location.

Arguments:

    hdc - Supplies the handle of the device context in which the mini-icon
        will be drawn.

    rc - Supplies the rectangle in the specified HDC to draw the icon in.

    MiniIconIndex - The index of the mini-icon, as retrieved from
        SetupDiLoadClassIcon or SetupDiGetClassBitmapIndex.  The following are
        pre-defined indices that may be used.

            0    Computer
            2    display
            5    mouse
            6    keyboard
            9    fdc
            9    hdc
            10   ports
            15   net
            0    system
            8    sound
            14   printer
            2    monitor
            3    nettrans
            16   netclient
            17   netservice
            18   unknown

    Flags - Controls the drawing operation.  The LOWORD contains the actual flags
        defined as follows:

        DMI_MASK - Draw the mini-icon's mask into HDC.

        DMI_BKCOLOR - Use the system color index specified in the HIWORD of Flags
            as the background color.  If not specified, COLOR_WINDOW is used.

        DMI_USERECT - If set, SetupDiDrawMiniIcon will use the supplied rect,
            stretching the icon to fit as appropriate.

Return Value:

    This function returns the offset from the left of rc where the string should
    start.

Remarks:

    By default, the icon will be centered vertically and butted against the left
    corner of the specified rectangle.

--*/
{
    HBITMAP hbmOld;
    DWORD rgbBk, rgbText;
    INT ret = 0;

    if(!LockMiniIconList(&GlobalMiniIconList)) {
        return 0;
    }

    CreateMiniIcons();

    if(GlobalMiniIconList.hbmMiniImage) {
        //
        // Set the Foreground and  background color for the
        // conversion of the Mono Mask image
        //
        if(Flags & DMI_MASK) {
            rgbBk = SetBkColor(hdc, RGB_WHITE);
        } else {
            rgbBk = SetBkColor(hdc,
                               GetSysColor(((int)(Flags & DMI_BKCOLOR
                                                      ? HIWORD(Flags)
                                                      : COLOR_WINDOW)))
                              );
        }
        rgbText = SetTextColor(hdc, RGB_BLACK);

        if(Flags & DMI_USERECT) {
            //
            // Copy the converted mask into the dest.  The transparent
            // areas will be drawn with the current window color.
            //
            hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                                  GlobalMiniIconList.hbmMiniMask
                                 );
            StretchBlt(hdc,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       rc.bottom - rc.top,
                       GlobalMiniIconList.hdcMiniMem,
                       MINIX * MiniIconIndex,
                       0,
                       MINIX,
                       MINIY,
                       SRCCOPY | NOMIRRORBITMAP);

            if(!(Flags & DMI_MASK)) {
                //
                // OR the image into the dest
                //
                SelectObject(GlobalMiniIconList.hdcMiniMem,
                             GlobalMiniIconList.hbmMiniImage
                            );
                StretchBlt(hdc,
                           rc.left,
                           rc.top,
                           rc.right - rc.left,
                           rc.bottom - rc.top,
                           GlobalMiniIconList.hdcMiniMem,
                           MINIX * MiniIconIndex,
                           0,
                           MINIX,
                           MINIY,
                           SRCPAINT | NOMIRRORBITMAP);
            }

        } else {
            //
            // Copy the converted mask into the dest.  The transparent
            // areas will be drawn with the current window color.
            //
            hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                                  GlobalMiniIconList.hbmMiniMask
                                 );
            BitBlt(hdc,
                   rc.left,
                   rc.top + (rc.bottom - rc.top - MINIY)/2,
                   MINIX,
                   MINIY,
                   GlobalMiniIconList.hdcMiniMem,
                   MINIX * MiniIconIndex,
                   0,
                   SRCCOPY | NOMIRRORBITMAP
                  );


            if(!(Flags & DMI_MASK)) {
                //
                // OR the image into the dest
                //
                SelectObject(GlobalMiniIconList.hdcMiniMem,
                             GlobalMiniIconList.hbmMiniImage
                            );
                BitBlt(hdc,
                       rc.left,
                       rc.top + (rc.bottom - rc.top - MINIY)/2,
                       MINIX,
                       MINIY,
                       GlobalMiniIconList.hdcMiniMem,
                       MINIX * MiniIconIndex,
                       0,
                       SRCPAINT | NOMIRRORBITMAP
                      );
            }
        }

        SetBkColor(hdc, rgbBk);
        SetTextColor(hdc, rgbText);

        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);
        if(Flags & DMI_USERECT) {
            ret = rc.right - rc.left + 2;   // offset to string from left edge
        } else {
            ret = MINIX + 2;                // offset to string from left edge
        }
    }

    UnlockMiniIconList(&GlobalMiniIconList);

    return ret;
}

BOOL
WINAPI
pSetupDiLoadClassIcon(
    IN  CONST GUID *ClassGuid,
    OUT HICON      *LargeIcon,     OPTIONAL
    OUT HICON      *SmallIcon,     OPTIONAL
    OUT LPINT      MiniIconIndex   OPTIONAL
    )
/*++

Routine Description:

    This routine loads both the large and mini-icons for the specified class

Arguments:

    ClassGuid - Supplies the GUID of the class for which the icon(s) should
        be loaded.

    LargeIcon - Optionally, supplies a pointer to a variable that will receive
        a handle to the loaded large icon for the specified class.  If this
        parameter is not specified, the large icon will not be loaded.
        
    SmallIcon - Optionally, supplies a pointer to a variable that will receive
        a handle to the loaded small icon for the specified class.  If this
        parameter is not specified, the small icon will not be loaded.        

    MiniIconIndex - Optionally, supplies a pointer to a variable that will
        receive the index of the mini-icon for the specified class.  The
        mini-icon is stored in the device installer's mini-icon cache.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The icons of the class are either pre-defined, and loaded from the  device
    installer's internal cache, or they are loaded directly from the class
    installer's executable.  This function will query the registry value ICON in
    the specified class's section.  If this value is specified then it indicates
    what mini icon to load.  If the icon value is negative the absolute value
    represents a predefined icon.  See SetupDiDrawMiniIcon for a list of pre-defined
    mini icons.  If the icon value is positive it represents an icon in the class
    installer's executable, and will be extracted (the number one is reserved).
    This function also uses the INSTALLER value first and ENUMPROPPAGES value second
    to determine what executable to extract the icon(s) from.

--*/
{
    HKEY hk = INVALID_HANDLE_VALUE;
    DWORD Err;
    HICON hRetLargeIcon = NULL;
    HICON hRetSmallIcon = NULL;
    INT ClassIconIndex;
    DWORD RegDataType, StringSize;
    PTSTR EndPtr;
    BOOL bGetMini = FALSE;
    BOOL bDestroyLargeIcon = FALSE, bDestroySmallIcon = FALSE;
    TCHAR TempString[MAX_PATH];
    TCHAR FullPath[MAX_PATH];
    UINT  IconsExtracted;

    if(!LockMiniIconList(&GlobalMiniIconList)) {
        SetLastError(ERROR_CANT_LOAD_CLASS_ICON);
        return FALSE;
    }

    try {

        if(MiniIconIndex) {
            *MiniIconIndex = -1;
        }

        if((hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) == INVALID_HANDLE_VALUE) {
            goto clean0;
        }

        StringSize = sizeof(TempString);
        Err = RegQueryValueEx(hk,
                              pszInsIcon,
                              NULL,
                              &RegDataType,
                              (PBYTE)TempString,
                              &StringSize
                             );

        if((Err == ERROR_SUCCESS) && (RegDataType == REG_SZ) && (StringSize > sizeof(TCHAR))) {

            if((ClassIconIndex = _tcstol(TempString, &EndPtr, 10)) == 1) {
                //
                // Positive values indicate that we should access an icon
                // directly using its ID.  Since ExtractIconEx uses negative
                // values to indicate these IDs, and since the value -1 has
                // a special meaning to that API, we must disallow a ClassIconIndex
                // of +1.
                //
                goto clean1;
            }

        } else {
            //
            // Icon index not specified, so assume index is 0.
            //
            ClassIconIndex = 0;
        }

        if(MiniIconIndex) {
            //
            // If mini-icon is already around, then we're done with it.
            //
            if(!SetupDiGetClassBitmapIndex(ClassGuid, MiniIconIndex)) {
                //
                // mini-icon not around--set flag to show we didn't get it.
                //
                bGetMini = TRUE;
            }
        }

        if(ClassIconIndex < 0) {
            INT ClassIconIndexNeg = -ClassIconIndex;
            //
            // Icon index is negative.  This means that this class is one
            // of our special classes with icons in setupapi.dll
            //
            if(LargeIcon) {
                hRetLargeIcon = LoadIcon(MyDllModuleHandle,
                                         MAKEINTRESOURCE(ClassIconIndexNeg)
                                        );
            }

            if(bGetMini || SmallIcon) {
                //
                // Retrieve the small icon as well.  If the resource doesn't
                // have a small icon then the big one will get smushed, but it's
                // better than getting the default icon.
                //
                hRetSmallIcon = LoadImage(MyDllModuleHandle,
                                          MAKEINTRESOURCE(ClassIconIndexNeg),
                                          IMAGE_ICON,
                                          MINIX,
                                          MINIY,
                                          0
                                         );

                if(hRetSmallIcon && bGetMini) {
                    *MiniIconIndex = NewMiniIcon(ClassGuid, hRetSmallIcon);
                }
            }

        } else if(bGetMini || LargeIcon || SmallIcon) {
            //
            // Look for the binary containing the icon(s) first in the
            // "Installer32" entry, and if not found, then in the "EnumPropPages32"
            // entry.
            //
            lstrcpyn(FullPath, SystemDirectory, MAX_PATH);

            StringSize = sizeof(TempString);
            Err = RegQueryValueEx(hk,
                                  pszInstaller32,
                                  NULL,
                                  &RegDataType,
                                  (PBYTE)TempString,
                                  &StringSize
                                 );

            if((Err != ERROR_SUCCESS) || (RegDataType != REG_SZ) ||
               (StringSize < sizeof(TCHAR))) {

                StringSize = sizeof(TempString);
                Err = RegQueryValueEx(hk,
                                      pszEnumPropPages32,
                                      NULL,
                                      &RegDataType,
                                      (PBYTE)TempString,
                                      &StringSize
                                     );

                if((Err != ERROR_SUCCESS) || (RegDataType != REG_SZ) ||
                   (StringSize < sizeof(TCHAR))) {

                    goto clean1;
                }
            }

            //
            // Remove function name, if present, from installer name.
            //
            for(EndPtr = TempString + ((StringSize / sizeof(TCHAR)) - 1);
                EndPtr >= TempString;
                EndPtr--) {

                if(*EndPtr == TEXT(',')) {
                    *EndPtr = TEXT('\0');
                    break;
                }
                //
                // If we hit a double-quote mark, we terminate the search.
                //
                if(*EndPtr == TEXT('\"')) {
                    break;
                }
            }
            pSetupConcatenatePaths(FullPath, TempString, MAX_PATH, NULL);

            IconsExtracted = ExtractIconEx(FullPath,
                                           -ClassIconIndex,
                                           LargeIcon ? &hRetLargeIcon : NULL,
                                           (bGetMini || SmallIcon) ? &hRetSmallIcon : NULL,
                                           1
                                          );
            if((IconsExtracted != (UINT)-1) && (IconsExtracted > 0)) {

                if(hRetLargeIcon) {
                    bDestroyLargeIcon = TRUE;
                }
                if(hRetSmallIcon) {
                    *MiniIconIndex = NewMiniIcon(ClassGuid, hRetSmallIcon);
                    bDestroySmallIcon = TRUE;
                }
            }
        }

clean1:
        RegCloseKey(hk);
        hk = INVALID_HANDLE_VALUE;

clean0:
        //
        // Assume success, unless we hit some really big problem below.
        //
        Err = NO_ERROR;

        if(LargeIcon && !hRetLargeIcon) {
            //
            // We didn't retrieve a large icon, so use a default.
            //
            if(!(hRetLargeIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(ICON_DEFAULT)))) {
                Err = GetLastError();
            }
        }

        if (SmallIcon && !hRetSmallIcon) {
            //
            // We didn't retrieve a small icon, so use a default.
            //
            if (!(hRetSmallIcon = LoadImage(MyDllModuleHandle,
                                            MAKEINTRESOURCE(ICON_DEFAULT),
                                            IMAGE_ICON,
                                            GetSystemMetrics(SM_CXSMICON),
                                            GetSystemMetrics(SM_CYSMICON),
                                            0
                                           ))) {
                Err = GetLastError();
            }
        }

        if(Err == NO_ERROR) {

            if(LargeIcon) {
                *LargeIcon = hRetLargeIcon;
            }

            if (SmallIcon) {
                *SmallIcon = hRetSmallIcon;
            }

            if(MiniIconIndex && (*MiniIconIndex == -1)) {
                SetupDiGetClassBitmapIndex(NULL, MiniIconIndex);
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hk != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk);
        }
    }

    if(Err != NO_ERROR) {
        if (bDestroyLargeIcon) {
            DestroyIcon(hRetLargeIcon);
        }

        if (bDestroySmallIcon) {
            DestroyIcon(hRetSmallIcon);
        }
    }

    UnlockMiniIconList(&GlobalMiniIconList);

    SetLastError(Err);

    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupDiLoadClassIcon(
    IN  CONST GUID *ClassGuid,
    OUT HICON      *LargeIcon,     OPTIONAL
    OUT LPINT       MiniIconIndex  OPTIONAL
    )
/*++

Routine Description:

    This routine loads both the large and mini-icons for the specified class

Arguments:

    ClassGuid - Supplies the GUID of the class for which the icon(s) should
        be loaded.

    LargeIcon - Optionally, supplies a pointer to a variable that will receive
        a handle to the loaded large icon for the specified class.  If this
        parameter is not specified, the large icon will not be loaded.

    MiniIconIndex - Optionally, supplies a pointer to a variable that will
        receive the index of the mini-icon for the specified class.  The
        mini-icon is stored in the device installer's mini-icon cache.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The icons of the class are either pre-defined, and loaded from the  device
    installer's internal cache, or they are loaded directly from the class
    installer's executable.  This function will query the registry value ICON in
    the specified class's section.  If this value is specified then it indicates
    what mini icon to load.  If the icon value is negative the absolute value
    represents a predefined icon.  See SetupDiDrawMiniIcon for a list of pre-defined
    mini icons.  If the icon value is positive it represents an icon in the class
    installer's executable, and will be extracted (the number one is reserved).
    This function also uses the INSTALLER value first and ENUMPROPPAGES value second
    to determine what executable to extract the icon(s) from.

--*/
{
    return (pSetupDiLoadClassIcon(ClassGuid,
                                  LargeIcon,
                                  NULL,
                                  MiniIconIndex
                                  ));
}


BOOL
WINAPI
SetupDiGetClassBitmapIndex(
    IN  CONST GUID *ClassGuid,    OPTIONAL
    OUT PINT        MiniIconIndex
    )
/*++

Routine Description:

    This routine retrieves the index of the mini-icon for the specified class.

Arguments:

    ClassGuid - Optionally, supplies the GUID of the class to get the mini-icon
        index for.  If this parameter is not specified, the index of the 'unknown'
        icon is returned.

    MiniIconIndex - Supplies a pointer to a variable that receives the index of
        the mini-icon for the specified class.  This buffer is always filled in,
        and receives the index of the unknown mini-icon if there is no mini-icon
        for the specified class (i.e., the return value is FALSE).

Return Value:

    If there was a mini-icon for the specified class, the return value is TRUE.

    If there was not a mini-icon for the specified class, or if no class was
    specified, the return value is FALSE (and GetLastError returns
    ERROR_NO_DEVICE_CLASS_ICON).  In this case, MiniIconIndex will contain the
    index of the unknown mini-icon.

--*/
{
    BOOL bRet = FALSE;  // assume not found
    int i;
    PCLASSICON pci;
    DWORD Err;

    if(ClassGuid) {
        //
        // First check the built-in list.
        //
        for(i = 0; !bRet && (i < ARRAYSIZE(MiniIconXlate)); i++) {

            if(IsEqualGUID(MiniIconXlate[i].ClassGuid, ClassGuid)) {
                *MiniIconIndex = MiniIconXlate[i].MiniBitmapIndex;
                bRet = TRUE;
            }
        }

        //
        // Next check the "new stuff" list to see if it's there.
        //
        if(!bRet && LockMiniIconList(&GlobalMiniIconList)) {

            for(pci = GlobalMiniIconList.ClassIconList;
                !bRet && pci;
                pci = pci->Next) {

                if(IsEqualGUID(pci->ClassGuid, ClassGuid)) {
                    *MiniIconIndex = pci->MiniBitmapIndex;
                    bRet = TRUE;
                }
            }

            UnlockMiniIconList(&GlobalMiniIconList);
        }
    }

    //
    // If no match was found, snag the "unknown" class.
    //
    if(!bRet) {
        *MiniIconIndex = UnknownClassMiniIconIndex;
        Err = ERROR_NO_DEVICE_ICON;
    } else {
        Err = NO_ERROR;
    }

    SetLastError(Err);
    return bRet;
}


BOOL
CreateMiniIcons(
    VOID
    )
/*++

Routine Description:

    This routine loads the default bitmap of mini-icons and turns it into
    the image/mask pair that will be the cornerstone of mini-icon management.
    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    HDC hdc, hdcMem;
    HBITMAP hbmOld;
    BITMAP bm;
    BOOL bRet = FALSE;          // assume failure

    if(GlobalMiniIconList.hdcMiniMem) {
        //
        // Then the mini-icon list has already been built, so
        // return success.
        //
        return TRUE;
    }

    hdc = GetDC(NULL);
    if (!hdc) {
        goto clean0;
    }
    GlobalMiniIconList.hdcMiniMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);
    if(!GlobalMiniIconList.hdcMiniMem) {
        goto clean0;
    }


    if(!(hdcMem = CreateCompatibleDC(GlobalMiniIconList.hdcMiniMem))) {
        goto clean0;
    }

    if(!(GlobalMiniIconList.hbmMiniImage = LoadBitmap(MyDllModuleHandle,
                                                      MAKEINTRESOURCE(BMP_DRIVERTYPES)))) {
        goto clean1;
    }


    GetObject(GlobalMiniIconList.hbmMiniImage, sizeof(bm), &bm);

    if(!(GlobalMiniIconList.hbmMiniMask = CreateBitmap(bm.bmWidth,
                                                       bm.bmHeight,
                                                       1,
                                                       1,
                                                       NULL))) {
        goto clean1;
    }


    hbmOld = SelectObject(hdcMem, GlobalMiniIconList.hbmMiniImage);
    SelectObject(GlobalMiniIconList.hdcMiniMem,
                 GlobalMiniIconList.hbmMiniMask
                );

    //
    // make the mask.  white where transparent, black where opaque
    //
    SetBkColor(hdcMem, RGB_TRANSPARENT);
    BitBlt(GlobalMiniIconList.hdcMiniMem,
           0,
           0,
           bm.bmWidth,
           bm.bmHeight,
           hdcMem,
           0,
           0,
           SRCCOPY
          );

    //
    // black-out all of the transparent parts of the image, in preparation
    // for drawing.
    //
    SetBkColor(hdcMem, RGB_BLACK);
    SetTextColor(hdcMem, RGB_WHITE);
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, GlobalMiniIconList.hdcMiniMem, 0, 0, SRCAND);

    SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);

    GlobalMiniIconList.NumClassImages = bm.bmWidth/MINIX;
    bRet = TRUE;

    SelectObject(hdcMem, hbmOld);

clean1:
    DeleteObject(hdcMem);

clean0:
    //
    // If failure, clean up anything we might have built
    //
    if(!bRet) {
        DestroyMiniIcons();
    }

    return bRet;
}


INT
NewMiniIcon(
    IN CONST GUID *ClassGuid,
    IN HICON       hIcon      OPTIONAL
    )
/*++

Routine Description:

    It's a new class, and we have a mini-icon for it, so let's add it
    to the mini-icon database.  First pull out the image and mask
    bitmaps.  Then add these to the mini-icon bitmap.  If this all
    works, add the new class to the list

    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    ClassGuid - Supplies a pointer to the class GUID for this mini-icon.

    hIcon - Optionally, supplies a handle to the mini-icon to be added to
        the database.  If this parameter is not specified, then the index
        for the "unknown class" icon will be returned.

Return Value:

    Index for class (set to "unknown class" if error)

--*/
{
    INT iBitmap = -1;
    ICONINFO ii;
    PCLASSICON pci = NULL;

    if(hIcon && GetIconInfo(hIcon, &ii)) {

        try {

            if((iBitmap = pSetupAddMiniIconToList(ii.hbmColor, ii.hbmMask)) != -1) {
                //
                // Allocate an extra GUID's worth of memory, so we can store
                // the class GUID in the same chunk of memory as the CLASSICON
                // node.
                //
                if(pci = (PCLASSICON)MyMalloc(sizeof(CLASSICON) + sizeof(GUID))) {

                    CopyMemory((PBYTE)pci + sizeof(CLASSICON),
                               ClassGuid,
                               sizeof(GUID)
                              );
                    pci->ClassGuid = (LPGUID)((PBYTE)pci + sizeof(CLASSICON));
                    pci->MiniBitmapIndex = iBitmap;

                    pci->Next = GlobalMiniIconList.ClassIconList;
                    GlobalMiniIconList.ClassIconList = pci;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            if(pci) {
                MyFree(pci);
            }

            iBitmap = -1;
        }

        DeleteObject(ii.hbmColor);
        DeleteObject(ii.hbmMask);
    }

    if(iBitmap == -1) {
        SetupDiGetClassBitmapIndex(NULL, &iBitmap);
    }

    return iBitmap;
}


INT
pSetupAddMiniIconToList(
    IN HBITMAP hbmImage,
    IN HBITMAP hbmMask
    )
/*++

Routine Description:

    Given the image and mask bitmaps of a mini-icon, add these to the
    mini-icon bitmap.

    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    hbmImage - Supplies the handle of the bitmap for the mini-icon.

    hbmMask - Supplies the handle of the bitmap for the mini-icon's mask.

Return Value:

    If success, returns the index of the added mini-icon.
    If failure, returns -1.

--*/
{
    HBITMAP hbmNewImage, hbmNewMask, hbmOld;
    HDC     hdcMem;
    BITMAP  bm;
    INT     iIcon = -1;  // assume failure

    if(!CreateMiniIcons()) {
        goto AddIcon_Exit;
    }

    MYASSERT(GlobalMiniIconList.hdcMiniMem);

    if(!(hdcMem = CreateCompatibleDC(GlobalMiniIconList.hdcMiniMem))) {
        goto AddIcon_Exit;
    }

    //
    // Create a New global Bitmap for the minis
    //
    hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                          GlobalMiniIconList.hbmMiniImage
                         );

    if(!(hbmNewImage = CreateCompatibleBitmap(GlobalMiniIconList.hdcMiniMem,
                                              MINIX * (GlobalMiniIconList.NumClassImages + 1),
                                              MINIY))) {
        goto AddIcon_Exit1;
    }

    //
    // Copy the current Mini bitmap
    //
    SelectObject(hdcMem, hbmNewImage);
    BitBlt(hdcMem,
           0,
           0,
           MINIX * GlobalMiniIconList.NumClassImages,
           MINIY,
           GlobalMiniIconList.hdcMiniMem,
           0,
           0,
           SRCCOPY
          );

    //
    // Fit the New icon into ours. We need to stretch it to fit correctly.
    //
    SelectObject(GlobalMiniIconList.hdcMiniMem, hbmImage);
    GetObject(hbmImage, sizeof(bm), &bm);
    StretchBlt(hdcMem,
               MINIX * GlobalMiniIconList.NumClassImages,
               0,
               MINIX,
               MINIY,
               GlobalMiniIconList.hdcMiniMem,
               0,
               0,
               bm.bmWidth,
               bm.bmHeight,
               SRCCOPY
              );

    SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);

    DeleteObject(GlobalMiniIconList.hbmMiniImage);
    GlobalMiniIconList.hbmMiniImage = hbmNewImage;

    //
    // Next, copy the mask.
    //
    hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                          GlobalMiniIconList.hbmMiniMask
                         );
    if(!(hbmNewMask = CreateBitmap(MINIX * (GlobalMiniIconList.NumClassImages + 1),
                                   MINIY,
                                   1,
                                   1,
                                   NULL))) {
        goto AddIcon_Exit1;
    }

    SelectObject(hdcMem, hbmNewMask);
    BitBlt(hdcMem,
           0,
           0,
           MINIX * GlobalMiniIconList.NumClassImages,
           MINIY,
           GlobalMiniIconList.hdcMiniMem,
           0,
           0,
           SRCCOPY
          );

    SelectObject(GlobalMiniIconList.hdcMiniMem, hbmMask);
    GetObject(hbmMask, sizeof(bm), &bm);
    StretchBlt(hdcMem,
               MINIX * GlobalMiniIconList.NumClassImages,
               0,
               MINIX,
               MINIY,
               GlobalMiniIconList.hdcMiniMem,
               0,
               0,
               bm.bmWidth,
               bm.bmHeight,
               SRCCOPY
              );

    SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);

    DeleteObject(GlobalMiniIconList.hbmMiniMask);
    GlobalMiniIconList.hbmMiniMask = hbmNewMask;

    iIcon = GlobalMiniIconList.NumClassImages;
    GlobalMiniIconList.NumClassImages++;           // one more image on the table

AddIcon_Exit1:
    DeleteDC(hdcMem);

AddIcon_Exit:
    return iIcon;
}


VOID
DestroyMiniIcons(
    VOID
    )
/*++

Routine Description:

    This routine destroys the mini-icon bitmaps, if they exist.
    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    None.

Return Value:

    None.

--*/
{
    PCLASSICON pci;

    if(GlobalMiniIconList.hdcMiniMem) {
        DeleteDC(GlobalMiniIconList.hdcMiniMem);
        GlobalMiniIconList.hdcMiniMem = NULL;
    }

    if(GlobalMiniIconList.hbmMiniImage) {
        DeleteObject(GlobalMiniIconList.hbmMiniImage);
        GlobalMiniIconList.hbmMiniImage = NULL;
    }

    if(GlobalMiniIconList.hbmMiniMask) {
        DeleteObject(GlobalMiniIconList.hbmMiniMask);
        GlobalMiniIconList.hbmMiniMask = NULL;
    }

    GlobalMiniIconList.NumClassImages = 0;

    //
    // Free up any additional class icon guys that were created
    //
    while(GlobalMiniIconList.ClassIconList) {
        pci = GlobalMiniIconList.ClassIconList;
        GlobalMiniIconList.ClassIconList = pci->Next;
        MyFree(pci);
    }
}


BOOL
WINAPI
SetupDiGetClassImageList(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
/*++

Routine Description:

    See SetupDiGetClassImageListEx for details.

--*/
{
    return SetupDiGetClassImageListEx(ClassImageListData, NULL, NULL);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassImageListExA(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCSTR                   MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    )
{
    PCWSTR UnicodeMachineName;
    DWORD rc;
    BOOL b;

    b = FALSE;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
    } else {
        UnicodeMachineName = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = SetupDiGetClassImageListExW(ClassImageListData, UnicodeMachineName, Reserved);
        rc = GetLastError();
        if(UnicodeMachineName) {
            MyFree(UnicodeMachineName);
        }
    }

    SetLastError(rc);
    return b;
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiGetClassImageListExW(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCWSTR                  MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassImageListData);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetClassImageListEx(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCTSTR                  MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    )
/*++

Routine Description:

    This routine builds an image list containing bitmaps for every installed class,
    and returns a data structure containing the list.

Arguments:

    ClassImageListData - Supplies the address of a SP_CLASSIMAGELIST_DATA structure
        that will receive information regarding the class list (including a handle
        to the image list).  The cbSize field of this structure must be initialized
        with the size of the structure (in bytes) before calling this routine, or the
        API will fail.

    MachineName - Optionally, specifies the name of the remote machine whose installed
        classes are to be used in building the class image list.  If this parameter is
        not specified, the local machine is used.

        NOTE:  Presently, class-specific icons can only be displayed if the class is
               also present on the local machine.  Thus, if the remote machine has
               class x, but class x is not installed locally, then the generic (unknown)
               icon will be returned.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The image list contained in structure filled in by this API should NOT be
    destroyed by calling ImageList_Destroy.  Instead, SetupDiDestroyClassImageList
    should be called, for proper clean-up to occur.

--*/
{
    DWORD   Err = NO_ERROR;
    int     cxMiniIcon, cyMiniIcon;
    int     MiniIconIndex = 0, DefaultIndex = 0;
    int     GuidCount, i;
    int     iIcon, iIndex;
    HDC     hDC = NULL, hMemImageDC = NULL;
    HBITMAP hbmMiniImage = NULL, hbmMiniMask = NULL, hbmOldImage = NULL;
    RECT    rc;
    CONST GUID *pClassGuid = NULL;
    BOOL    bUseBitmap, ComputerClassFound = FALSE;
    HICON   hiLargeIcon = NULL, hiSmallIcon = NULL, hIcon = NULL;
    HBRUSH  hOldBrush;
    PCLASSICON   pci = NULL;
    PCLASS_IMAGE_LIST ImageData = NULL;
    BOOL    DestroyLock = FALSE;
    HIMAGELIST ImageList = NULL;
    DWORD   dwLayout = 0;
    UINT    ImageListFlags = 0;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {

        if(ClassImageListData->cbSize != sizeof(SP_CLASSIMAGELIST_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Allocate and initialize the image list, including setting up the
        // synchronization lock.  Destroy it when done.
        //
        if(ImageData = MyMalloc(sizeof(CLASS_IMAGE_LIST))) {
            ZeroMemory(ImageData, sizeof(CLASS_IMAGE_LIST));
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        if(InitializeSynchronizedAccess(&ImageData->Lock)) {
            DestroyLock = TRUE;
        }

        //
        // Build the class image list. Create an Image List with no mask,
        // 1 image, and a growth factor of 1.
        //
        cxMiniIcon = GetSystemMetrics(SM_CXSMICON);
        cyMiniIcon = GetSystemMetrics(SM_CYSMICON);

        ImageListFlags = ILC_MASK;

        //
        // Check which color depth we are running in. Set the ILC_COLOR32 
        // imagelist create flag if we are running at greate than 8bit (256)
        // color depth.
        //
        hDC = GetDC(NULL);
        if (hDC) {
            if (GetDeviceCaps(hDC, BITSPIXEL) > 8) {
                ImageListFlags |= ILC_COLOR32;
            }

            ReleaseDC(NULL, hDC);
            hDC = NULL;
        }

#ifdef UNICODE
        //
        // If we are running on an RTL build then we need to set the ILC_MIRROR
        // flag when calling ImageList_Create to un-mirror the icons.  By 
        // default the icons are mirrored.
        //
        if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) {
            ImageListFlags |= ILC_MIRROR;
        }
#endif

        if(!(ImageList = ImageList_Create(cxMiniIcon,
                                          cyMiniIcon,
                                          ImageListFlags,
                                          1,
                                          1)))
        {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        ImageList_SetBkColor(ImageList, GetSysColor(COLOR_WINDOW));

        //
        // Create a DC to draw the mini icons into.  This is needed
        // for the system defined Minis
        //
        if(!(hDC = GetDC(HWND_DESKTOP)) ||
           !(hMemImageDC = CreateCompatibleDC(hDC)))
        {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Create a bitmap to draw the icons on.  Defer checking for creation
        // of bitmap until afer freeing DC, so it only has to be done once.
        //
        hbmMiniImage = CreateCompatibleBitmap(hDC, cxMiniIcon, cyMiniIcon);
        hbmMiniMask = CreateCompatibleBitmap(hDC, cxMiniIcon, cyMiniIcon);

        ReleaseDC(HWND_DESKTOP, hDC);
        hDC = NULL;

        //
        // Did the bitmap get created?
        //
        if (!hbmMiniImage || ! hbmMiniMask) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Select our bitmap into the memory DC.
        //
        hbmOldImage = SelectObject(hMemImageDC, hbmMiniImage);

        //
        // Prepare to draw the mini icon onto the memory DC
        //
        rc.left   = 0;
        rc.top    = 0;
        rc.right  = cxMiniIcon;
        rc.bottom = cyMiniIcon;

        //
        // Get the Index of the Default mini icon.
        //
        SetupDiGetClassBitmapIndex(NULL, &DefaultIndex);

        //
        // Enumerate all classes, and for each class, draw its bitmap.
        //
        GuidCount = 32;
        ImageData->ClassGuidList = (LPGUID)MyMalloc(sizeof(GUID) * GuidCount);

        if (!SetupDiBuildClassInfoListEx(0,
                                         ImageData->ClassGuidList,
                                         GuidCount,
                                         &GuidCount,
                                         MachineName,
                                         NULL)) {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                //
                // Realloc buffer and try again.
                //
                MyFree(ImageData->ClassGuidList);

                if(!(ImageData->ClassGuidList = MyMalloc(sizeof(GUID) * GuidCount))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

                if (!SetupDiBuildClassInfoListEx(0,
                                                 ImageData->ClassGuidList,
                                                 GuidCount,
                                                 &GuidCount,
                                                 MachineName,
                                                 NULL)) {
                    Err = GetLastError();
                    goto clean0;
                }

            } else {
                Err = GetLastError();
                goto clean0;
            }
        }

        //
        // Retrieve the icon for each class in the class list.
        //
        for (pClassGuid = ImageData->ClassGuidList, i = 0;
             i < GuidCount;
             pClassGuid++, i++) {

            if (!pSetupDiLoadClassIcon(pClassGuid,
                                       &hiLargeIcon,
                                       &hiSmallIcon,
                                       &MiniIconIndex)) {
                Err = GetLastError();
                goto clean0;
            }

            //
            // If the returned Mini Icon index is not the Default one, then
            // we use the MiniBitmap, since it is a pre-defined one in SETUPAPI.
            // If the Mini is not pre-defined, and there is no Class Installer
            // then we use the Mini, since it is a valid default.  If there
            // is no Mini, and there is a class installer, then we will use
            // the Class installer's big Icon, and have the Image list crunch
            // it for us.
            //
            bUseBitmap = FALSE;

            if (DefaultIndex != MiniIconIndex) {

                SetupDiDrawMiniIcon(hMemImageDC,
                                    rc,
                                    MiniIconIndex,
                                    DMI_USERECT);

                SelectObject(hMemImageDC, hbmMiniMask);

                SetupDiDrawMiniIcon(hMemImageDC,
                                    rc,
                                    MiniIconIndex,
                                    DMI_MASK | DMI_USERECT);
                bUseBitmap = TRUE;
            }

            //
            // Deselect the bitmap from our DC BEFORE calling ImageList
            // functions.
            //
            SelectObject(hMemImageDC, hbmOldImage);

            //
            // Add the image. Allocate a new PCI.
            //
            if(!(pci = (PCLASSICON)MyMalloc(sizeof(CLASSICON)))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            if (hiSmallIcon) {
                pci->MiniBitmapIndex = (UINT)ImageList_AddIcon(ImageList, hiSmallIcon);
            } else if (bUseBitmap) {
                    pci->MiniBitmapIndex = (UINT)ImageList_Add(ImageList, hbmMiniImage, hbmMiniMask);
            } else {
                pci->MiniBitmapIndex = (UINT)ImageList_AddIcon(ImageList, hiLargeIcon);
            }

            if (hiLargeIcon) {
                DestroyIcon(hiLargeIcon);
                hiLargeIcon = NULL;
            }
            
            if (hiSmallIcon) {
                DestroyIcon(hiSmallIcon);
                hiSmallIcon = NULL;
            }

            if(pci->MiniBitmapIndex == (UINT)-1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                MyFree(pci);
                pci = NULL;
                goto clean0;
            }

            pci->ClassGuid = pClassGuid;

            //
            // Link it in.
            //
            pci->Next = ImageData->ClassIconList;
            ImageData->ClassIconList = pci;

            //
            // Reset pci to NULL so we won't try to free it later.
            //
            pci = NULL;

            //
            // Select our bitmap back for the next ICON.
            //
            SelectObject(hMemImageDC, hbmMiniImage);

            if(IsEqualGUID(pClassGuid, &GUID_DEVCLASS_UNKNOWN)) {
                ImageData->UnknownImageIndex = i;
            }

            //
            // Check to see if we've encountered the computer class.  This used
            // to be a special pseudo-class used solely by DevMgr to retrieve
            // the icon for the root of the device tree.  Now, we use this class
            // for specifying the 'drivers' for the computer itself (i.e., the
            // HALs and the appropriate versions of files that are different for
            // MP vs. UP.
            //
            // We should encounter this class GUID, but if we don't, then we
            // want to maintain the old behavior of adding this in manually
            // later on.
            //
            if(!ComputerClassFound && IsEqualGUID(pClassGuid, &GUID_DEVCLASS_COMPUTER)) {
                ComputerClassFound = TRUE;
            }
        }

        if(!ComputerClassFound) {
            //
            // Special Case for the Internal Class "Computer"
            //
            if(!(pci = (PCLASSICON)MyMalloc(sizeof(CLASSICON)))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            pci->ClassGuid = &GUID_DEVCLASS_COMPUTER;
            SelectObject(hMemImageDC, hbmMiniImage);
            hOldBrush = SelectObject(hMemImageDC, GetSysColorBrush(COLOR_WINDOW));
            PatBlt(hMemImageDC, 0, 0, cxMiniIcon, cyMiniIcon, PATCOPY);
            SelectObject(hMemImageDC, hOldBrush);

            SetupDiGetClassBitmapIndex((LPGUID)pci->ClassGuid, &MiniIconIndex);

            SetupDiDrawMiniIcon(hMemImageDC,
                                rc,
                                MiniIconIndex,
                                DMI_USERECT);

            SelectObject(hMemImageDC, hbmMiniMask);
            SetupDiDrawMiniIcon(hMemImageDC,
                                rc,
                                MiniIconIndex,
                                DMI_MASK | DMI_USERECT);

            //
            // Deselect the bitmap from our DC BEFORE calling ImageList
            // functions.
            //
            SelectObject(hMemImageDC, hbmOldImage);

            pci->MiniBitmapIndex = ImageList_Add(ImageList, hbmMiniImage, hbmMiniMask);

            if(pci->MiniBitmapIndex == (UINT)-1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                MyFree(pci);
                pci = NULL;
                goto clean0;
            }

            //
            // Link it in.
            //
            pci->Next = ImageData->ClassIconList;
            ImageData->ClassIconList = pci;

            //
            // Reset pci to NULL so we won't try to free it later.
            //
            pci = NULL;
        }

        //
        // Add the Overlay ICONs.
        //
        for (iIcon = IDI_CLASSICON_OVERLAYFIRST;
             iIcon <= IDI_CLASSICON_OVERLAYLAST;
             ++iIcon) {

            if(!(hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(iIcon)))) {
                Err = GetLastError();
                goto clean0;
            }

            iIndex = ImageList_AddIcon(ImageList, hIcon);

            if(iIndex == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            if(!ImageList_SetOverlayImage(ImageList, iIndex, iIcon - IDI_CLASSICON_OVERLAYFIRST + 1)) {
                Err = ERROR_INVALID_DATA;
                goto clean0;
            }
        }

        //
        // If we get to this point, then we've successfully constructed the entire
        // image list, and associated CLASSICON nodes.  Now, store this information
        // in the caller's SP_CLASSIMAGELIST_DATA buffer.
        //
        ClassImageListData->Reserved  = (ULONG_PTR)ImageData;
        ClassImageListData->ImageList = ImageList;

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_USER_BUFFER;

        if(hDC) {
            ReleaseDC(HWND_DESKTOP, hDC);
        }

        if(pci) {
            MyFree(pci);
        }

        //
        // Reference the following variables so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        ImageData = ImageData;
        DestroyLock = DestroyLock;
        ImageList = ImageList;
    }

    if (hbmMiniImage) {
        DeleteObject(hbmMiniImage);
    }
    if (hbmMiniMask) {
        DeleteObject(hbmMiniMask);
    }
    if (hMemImageDC) {
        DeleteDC(hMemImageDC);
    }

    if(Err != NO_ERROR) {

        if(ImageData) {
            if(DestroyLock) {
                DestroySynchronizedAccess(&ImageData->Lock);
            }
            if(ImageData->ClassGuidList) {
                MyFree(ImageData->ClassGuidList);
            }
            while(ImageData->ClassIconList) {
                pci = ImageData->ClassIconList;
                ImageData->ClassIconList = pci->Next;
                MyFree(pci);
            }
            MyFree(ImageData);
        }

        if(ImageList) {
            ImageList_Destroy(ImageList);
        }
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDestroyClassImageList(
    IN PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
/*++

Routine Description:

    This routine destroys a class image list built by a call to SetupDiGetClassImageList.

Arguments:

    ClassImageListData - Supplies the address of a SP_CLASSIMAGELIST_DATA structure
        containing the class image list to be destroyed.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err = NO_ERROR;
    PCLASS_IMAGE_LIST ImageData = NULL;
    PCLASSICON pci;

    try {

        if(ClassImageListData->cbSize != sizeof(SP_CLASSIMAGELIST_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        if (ClassImageListData->Reserved == 0x0) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }


        ImageData = (PCLASS_IMAGE_LIST)ClassImageListData->Reserved;

        if (!LockImageList(ImageData)) {
            Err = ERROR_CANT_LOAD_CLASS_ICON;
            goto clean0;
        }

        if (ClassImageListData->ImageList) {
            ImageList_Destroy(ClassImageListData->ImageList);
        }

        if (ImageData->ClassGuidList) {
            MyFree(ImageData->ClassGuidList);
        }

        while(ImageData->ClassIconList) {
            pci = ImageData->ClassIconList;
            ImageData->ClassIconList = pci->Next;
            MyFree(pci);
        }

        DestroySynchronizedAccess(&ImageData->Lock);
        MyFree(ImageData);
        ClassImageListData->Reserved = 0;


clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_USER_BUFFER;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetClassImageIndex(
    IN  PSP_CLASSIMAGELIST_DATA  ClassImageListData,
    IN  CONST GUID              *ClassGuid,
    OUT PINT                     ImageIndex
    )
/*++

Routine Description:

    This routine retrieves the index within the class image list of a specified
    class.

Arguments:

    ClassImageListData - Supplies the address of a SP_CLASSIMAGELIST_DATA
        structure containing the specified class's image.

    ClassGuid - Supplies the address of the GUID for the class whose index is
        to be retrieved.

    ImageIndex - Supplies the address of a variable that receives the index of
        the specified class's image within the class image list.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err = NO_ERROR;
    BOOL  bFound = FALSE, bLocked = FALSE;
    PCLASS_IMAGE_LIST ImageData = NULL;
    PCLASSICON pci;


    try {

        if(ClassImageListData->cbSize != sizeof(SP_CLASSIMAGELIST_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        if (ClassImageListData->Reserved == 0x0) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        ImageData = (PCLASS_IMAGE_LIST)ClassImageListData->Reserved;

        if (!LockImageList(ImageData)) {
            Err = ERROR_CANT_LOAD_CLASS_ICON;
            goto clean0;
        }
        bLocked = TRUE;


        if (ClassGuid) {
            //
            // check the "new stuff" list to see if it's there
            //
            for (pci = ImageData->ClassIconList;
                 !bFound && pci;
                 pci = pci->Next) {

                if(IsEqualGUID(pci->ClassGuid, ClassGuid)) {
                    *ImageIndex = pci->MiniBitmapIndex;
                    bFound = TRUE;
                }
            }
        }

        //
        // if no match was found, snag the "unknown" class
        //
        if (!bFound) {
            *ImageIndex = ImageData->UnknownImageIndex;
        }


clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_USER_BUFFER;
    }

    if (bLocked && ImageData) {
        UnlockImageList(ImageData);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\copy.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    copy.c

Abstract:

    High-level file copy/installation functions

Author:

    Ted Miller (tedm) 14-Feb-1995

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop

#include <winioctl.h>

#define FILE_COMPARE_BLOCK_SIZE (0x1000000)

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );


//
// Mask for all copy flags that will require us to determine
// version information.
//
#define SP_COPY_MASK_NEEDVERINFO    (SP_COPY_NEWER_OR_SAME | SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER | SP_COPY_LANGUAGEAWARE)


VOID
pGetVersionText(
   OUT PTSTR VersionText,
   IN DWORDLONG Version
   )
/*++

Routine Description:

    Convert a 64-bit version number into either
    n.n.n.n  or "0"

Arguments:

    VersionText - buffer, big enough to hold 4x16 bit numbers
    Version - 64-bit version, or 0 if no version

Return Value:

    none

--*/
{
    if (Version == 0) {
        lstrcpy(VersionText,TEXT("0"));
    } else {
        int m1 = (int)((Version >> 48) & 0xffff);
        int m2 = (int)((Version >> 32) & 0xffff);
        int m3 = (int)((Version >> 16) & 0xffff);
        int m4 = (int)(Version & 0xffff);

        wsprintf(VersionText,TEXT("%d.%d.%d.%d"),m1,m2,m3,m4);
    }
}

DWORD
CreateTargetAsLinkToMaster(
   IN PSP_FILE_QUEUE Queue,
   IN PCTSTR FullSourceFilename,
   IN PCTSTR FullTargetFilename,
   IN PVOID CopyMsgHandler OPTIONAL,
   IN PVOID Context OPTIONAL,
   IN BOOL IsMsgHandlerNativeCharWidth
   )
{
#ifdef ANSI_SETUPAPI
    return ERROR_CALL_NOT_IMPLEMENTED;
#else

    PTSTR p;
    TCHAR c;
    DWORD bytesReturned;
    DWORD error;
    BOOL ok;
    DWORD sourceLength;
    DWORD targetLength;
    DWORD sourceDosDevLength;
    DWORD targetDosDevLength;
    DWORD copyFileSize;
    PSI_COPYFILE copyFile;
    PCHAR s;
    HANDLE targetHandle;

    //
    // Get the name of the source directory.
    //
    p = _tcsrchr( FullSourceFilename, TEXT('\\') );
    if ( (p == NULL) || (p == FullSourceFilename) ) {
        return ERROR_FILE_NOT_FOUND;    // copy by usual means
    }
    if ( *(p-1) == TEXT(':') ) {
        p++;
    }
    c = *p;
    *p = 0;

    //
    // If this is the same as the previous source directory, then we already
    // have a handle to the directory; otherwise, close the old handle and
    // open a handle to this directory.
    //
    if ( (Queue->SisSourceDirectory == NULL) ||
         (_tcsicmp(FullSourceFilename, Queue->SisSourceDirectory) != 0) ) {

        if ( Queue->SisSourceHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( Queue->SisSourceHandle );
        }
        Queue->SisSourceHandle = CreateFile(
                                    FullSourceFilename,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_BACKUP_SEMANTICS,
                                    NULL
                                    );
        if ( Queue->SisSourceHandle == INVALID_HANDLE_VALUE ) {
            return ERROR_FILE_NOT_FOUND;
        }
        if ( Queue->SisSourceDirectory != NULL ) {
            MyFree( Queue->SisSourceDirectory );
        }
        Queue->SisSourceDirectory = DuplicateString( FullSourceFilename );

        //
        // If the DuplicateString fails, we press on. Because SisSourceDirectory
        // is NULL, we'll reopen the source directory next time.
        //
    }

    *p = c;

    //
    // Build the FSCTL command buffer.
    //

    sourceLength = (_tcslen(FullSourceFilename) + 1) * sizeof(TCHAR);
    if ( *FullSourceFilename != TEXT('\\') ) {
        sourceDosDevLength = _tcslen(TEXT("\\??\\")) * sizeof(TCHAR);
    } else {
        sourceDosDevLength = 0;
    }
    targetLength = (_tcslen(FullTargetFilename) + 1) * sizeof(TCHAR);
    if ( *FullTargetFilename != TEXT('\\') ) {
        targetDosDevLength = _tcslen(TEXT("\\??\\")) * sizeof(TCHAR);
    } else {
        targetDosDevLength = 0;
    }

    copyFileSize = FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) +
                    sourceDosDevLength + sourceLength +
                    targetDosDevLength + targetLength;

    copyFile = MyMalloc( copyFileSize );
    if ( copyFile == NULL ) {
        return ERROR_FILE_NOT_FOUND;
    }

    copyFile->SourceFileNameLength = sourceDosDevLength + sourceLength;
    copyFile->DestinationFileNameLength = targetDosDevLength + targetLength;
    copyFile->Flags = COPYFILE_SIS_REPLACE;

    s = (PCHAR)copyFile->FileNameBuffer;
    if ( sourceDosDevLength != 0 ) {
        RtlCopyMemory(
            s,
            TEXT("\\??\\"),
            sourceDosDevLength
            );
        s += sourceDosDevLength;
    }
    RtlCopyMemory(
        s,
        FullSourceFilename,
        sourceLength
        );
    s += sourceLength;

    if ( targetDosDevLength != 0 ) {
        RtlCopyMemory(
            s,
            TEXT("\\??\\"),
            targetDosDevLength
            );
        s += targetDosDevLength;
    }
    RtlCopyMemory(
        s,
        FullTargetFilename,
        targetLength
        );

    //
    // Invoke the SIS CopyFile FsCtrl.
    //

    ok = DeviceIoControl(
            Queue->SisSourceHandle,
            FSCTL_SIS_COPYFILE,
            copyFile,               // Input buffer
            copyFileSize,           // Input buffer length
            NULL,                   // Output buffer
            0,                      // Output buffer length
            &bytesReturned,
            NULL
            );
    error = GetLastError( );

    MyFree( copyFile );

    if ( ok ) {

        //DbgPrint( "\n\nCreateTargetAsLinkToMaster: SIS copy %ws->%ws succeeded\n\n\n", FullSourceFilename, FullTargetFilename );

        //
        // Open the target file so that CSC knows about it and pins it,
        // if necessary.
        //

        targetHandle = CreateFile(
                            FullTargetFilename,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );
        if ( targetHandle == INVALID_HANDLE_VALUE ) {
            error = GetLastError();
            DbgPrint( "\n\nCreateTargetAsLinkToMaster: SIS copy %ws->%ws succeeded, but open failed: %d\n\n\n", FullSourceFilename, FullTargetFilename, error );
        } else {
            CloseHandle( targetHandle );
        }

        error = NO_ERROR;

    } else {

        //DbgPrint( "\n\nCreateTargetAsLinkToMaster: SIS copy %ws->%ws failed: %d\n\n\n", FullSourceFilename, FullTargetFilename, error );

        //
        // If it looks like SIS isn't active on the remote file system, close
        // the SIS root handle so that we can avoid repeatedly getting this
        // error.
        //
        // Note: NTFS returns STATUS_INVALID_PARAMETER (ERROR_INVALID_PARAMETER).
        // FAT returns STATUS_INVALID_DEVICE_REQUEST (ERROR_INVALID_FUNCTION).
        //

        if ( (error == ERROR_INVALID_PARAMETER) ||
             (error == ERROR_INVALID_FUNCTION) ) {
            CloseHandle( Queue->SisSourceHandle );
            Queue->SisSourceHandle = INVALID_HANDLE_VALUE;
            if ( Queue->SisSourceDirectory != NULL ) {
                MyFree( Queue->SisSourceDirectory );
                Queue->SisSourceDirectory = NULL;
            }
            Queue->Flags &= ~FQF_TRY_SIS_COPY;
        }
    }

    return error;

#endif
}

BOOL
pCompareFilesExact(
    IN PCTSTR File1,
    IN PCTSTR File2
    )
/*++

Routine Description:

    Determine if File1 and File2 are byte-for-byte exactly the same. If they are, we don't need to do anything.

Arguments:

    File1 - the two files to compare. The order does not matter
    File2

Return Value:

    TRUE if the files are exactly the same
    Note that we have to allow for potentially huge files.

--*/
{
    HANDLE hFile1,hFile2;
    HANDLE hMap1,hMap2;
    LPVOID View1,View2;
    ULARGE_INTEGER Size1,Size2,Offset;
    SIZE_T BlockSize;
    SIZE_T ChunkSize;
    BOOL match;

    match = FALSE;
    hFile1=hFile2=INVALID_HANDLE_VALUE;
    hMap1=hMap2=NULL;
    View1=View2=NULL;

    try {
        hFile1 = CreateFile(File1,
                            GENERIC_READ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
        if (hFile1 == INVALID_HANDLE_VALUE) {
            leave;
        }
        hFile2 = CreateFile(File2,
                            GENERIC_READ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
        if (hFile2 == INVALID_HANDLE_VALUE) {
            leave;
        }

        Size1.LowPart = GetFileSize(hFile1,&Size1.HighPart);
        if(Size1.LowPart == (DWORD)(-1) && GetLastError()) {
            //
            // get file size failed
            //
            leave;
        }
        Size2.LowPart = GetFileSize(hFile2,&Size2.HighPart);
        if(Size2.LowPart == (DWORD)(-1) && GetLastError()) {
            //
            // get file size failed
            //
            leave;
        }
        if (Size1.QuadPart != Size2.QuadPart) {
            leave;
        }

        if (Size1.QuadPart == 0) {
            //
            // both files are zero length, nothing to do
            //
            match = TRUE;
            leave;
        }

        //
        // basic checks done, we'll mark both files as mappable to do the byte-checks
        //
        hMap1 = CreateFileMapping(hFile1,
                                  NULL,
                                  PAGE_READONLY,
                                  Size1.HighPart,
                                  Size1.LowPart,
                                  NULL);
        if (hMap1 == NULL) {
            //
            // mapping failed
            //
            leave;
        }

        hMap2 = CreateFileMapping(hFile2,
                                  NULL,
                                  PAGE_READONLY,
                                  Size1.HighPart,
                                  Size1.LowPart,
                                  NULL);
        if (hMap2 == NULL) {
            //
            // mapping failed
            //
            leave;
        }

        if (Size1.QuadPart > FILE_COMPARE_BLOCK_SIZE) {
            BlockSize = FILE_COMPARE_BLOCK_SIZE;
        } else {
            BlockSize = (SIZE_T)Size1.QuadPart;
            MYASSERT(BlockSize);
        }

        //
        // now proceed in BlockSize chunks comparing the two files
        //
        Offset.QuadPart = 0;

        do {
            if ((Size1.QuadPart - Offset.QuadPart) < BlockSize) {
                ChunkSize = (SIZE_T)(Size1.QuadPart - Offset.QuadPart);
                MYASSERT(ChunkSize);
            } else {
                ChunkSize = BlockSize;
            }

            //
            // map and compare the two views
            // for most files, we will only need to do this once
            // for big files, we'll do this approx (Size1+BlockSize-1)/BlockSize times
            //
            View1 = MapViewOfFile(hMap1,
                                  FILE_MAP_READ,
                                  Offset.HighPart,
                                  Offset.LowPart,
                                  ChunkSize);
            if (View1 == NULL) {
                //
                // get view failed
                //
                leave;
            }
            View2 = MapViewOfFile(hMap2,
                                  FILE_MAP_READ,
                                  Offset.HighPart,
                                  Offset.LowPart,
                                  ChunkSize);
            if (View2 == NULL) {
                //
                // get view failed
                //
                leave;
            }
            if(memcmp(View1,View2,ChunkSize) != 0) {
                //
                // file chunks mismatch
                //
                leave;
            }
            UnmapViewOfFile(View1);
            UnmapViewOfFile(View2);
            View1 = NULL;
            View2 = NULL;

            Offset.QuadPart += ChunkSize;

        } while (Offset.QuadPart<Size1.QuadPart);

        //
        // if we get here, we have a 100% match
        //
        match = TRUE;

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if (View1 != NULL) {
        UnmapViewOfFile(View1);
    }
    if (View2 != NULL) {
        UnmapViewOfFile(View2);
    }
    if (hMap1 != NULL) {
        CloseHandle(hMap1);
    }
    if (hMap2 != NULL) {
        CloseHandle(hMap2);
    }
    if (hFile1 != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile1);
    }
    if (hFile2 != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile2);
    }
    return match;
}

BOOL
_SetupInstallFileEx(
    IN  PSP_FILE_QUEUE      Queue,             OPTIONAL
    IN  PSP_FILE_QUEUE_NODE QueueNode,         OPTIONAL
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCTSTR              SourceFile,        OPTIONAL
    IN  PCTSTR              SourcePathRoot,    OPTIONAL
    IN  PCTSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PVOID               CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    OUT PBOOL               SignatureVerifyFailed
    )

/*++

Routine Description:

    Actual implementation of SetupInstallFileEx. Handles either ANSI or
    Unicode callback routine.

Arguments:

    Same as SetupInstallFileEx().

    QueueNode - must be specified if Queue is supplied.  This parameter gives
        us the queue node for this operation so we can get at the pertinent
        catalog info for driver signing.

    IsMsgHandlerNativeCharWidth - supplies a flag indicating whether
        CopyMsgHandler expects native char widths args (or ansi ones, in the
        unicode build of the dll).

    SignatureVerifyFailed - supplies the address of a boolean variable that is
        set to indicate whether or not digital signature verification failed for
        the source file.  This will be set to FALSE if some other failure caused
        us to abort prior to attempting the signature verification.  This is
        used by the queue commit routines to determine whether or not the queue
        callback routine should be given a chance to handle a copy failure
        (skip, retry, etc.).  Digital signature verification failures are
        handled within this routine (including user prompting, if policy
        requires it), and queue callback routines _are not_ allowed to override
        the behavior.

Return Value:

    Same as SetupInstallFileEx().

--*/

{
    BOOL b;
    BOOL Ok;
    DWORD rc = NO_ERROR;
    DWORD SigVerifRc;
    UINT SourceId;
    TCHAR Buffer1[MAX_PATH];
    TCHAR Buffer2[MAX_PATH];
    PCTSTR FullSourceFilename;
    PCTSTR FullTargetFilename;
    PCTSTR SourceFilenamePart;
    PTSTR ActualSourceFilename;
    PTSTR TemporaryTargetFile;
    UINT CompressionType;
    DWORD SourceFileSize;
    DWORD TargetFileSize;
    PTSTR p;
    DWORDLONG SourceVersion, TargetVersion;
    TCHAR SourceVersionText[50], TargetVersionText[50];
    LANGID SourceLanguage;
    LANGID TargetLanguage;
    WIN32_FIND_DATA SourceFindData;
    UINT NotifyFlags;
    PSECURITY_DESCRIPTOR SecurityInfo;
    FILEPATHS FilePaths;
    UINT param;
    FILETIME sFileTime,tFileTime;
    WORD sDosTime,sDosDate,tDosTime,tDosDate;
    BOOL Moved;
    SetupapiVerifyProblem Problem;
    BOOL ExistingTargetFileWasSigned;
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD slot_fileop = 0;
    SP_TARGET_ENT TargetInfo;
    PCTSTR ExistingFile = NULL;
    PCTSTR CompareFile = NULL;
    PCTSTR BackupFileName = NULL;
    BOOL CompareSameFilename = FALSE;
    BOOL FileUnchanged = FALSE;
    PLOADED_INF LoadedInf = NULL;
    DWORD ExemptCopyFlags = 0;
    BOOL DoingDeviceInstall;
    DWORD DriverSigningPolicy;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;
    PTSTR DeviceDesc = NULL;

    if (Queue) {
        lc = Queue->LogContext;
    } else if (InfHandle && InfHandle != INVALID_HANDLE_VALUE) {
        //
        // Lock INF for the duration of this routine.
        //
        try {
            if(!LockInf((PLOADED_INF)InfHandle)) {
                rc = ERROR_INVALID_HANDLE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // Assume InfHandle was bad pointer
            //
            rc = ERROR_INVALID_HANDLE;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }

        LoadedInf = (PLOADED_INF)InfHandle;

        lc = LoadedInf->LogContext;
    }

    //
    // If Queue is specified, then so must QueueNode (and vice versa).
    //
    MYASSERT((Queue && QueueNode) || !(Queue || QueueNode));

    *SignatureVerifyFailed = FALSE;
    SigVerifRc = NO_ERROR;

    //
    // Assume failure.
    //
    Ok = FALSE;
    SecurityInfo = NULL;
    Moved = FALSE;
    try {
        *FileWasInUse = FALSE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if((rc == NO_ERROR) && InfContext) {
        if(!InfHandle || (InfHandle == INVALID_HANDLE_VALUE)) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(rc != NO_ERROR) {
        goto clean0;
    }

    //
    // Determine the full source path and filename of the file.
    //
    if(CopyStyle & SP_COPY_SOURCE_ABSOLUTE) {
        if (!SourceFile) {
            rc = ERROR_INVALID_PARAMETER;
            goto clean0;
        }
        FullSourceFilename = DuplicateString(SourceFile);
    } else {

        //
        // Get the relative path for this file if necessary.
        //
        if(CopyStyle & SP_COPY_SOURCEPATH_ABSOLUTE) {
            Buffer2[0] = TEXT('\0');
            b = TRUE;
        } else {
            b = _SetupGetSourceFileLocation(
                    InfHandle,
                    InfContext,
                    SourceFile,
                    (Queue && (Queue->Flags & FQF_USE_ALT_PLATFORM))
                        ? &(Queue->AltPlatformInfo)
                        : NULL,
                    &SourceId,
                    Buffer2,
                    MAX_PATH,
                    NULL,
                    NULL
                   );
        }

        //
        // Concatenate the relative path and the filename to the source root.
        //
        if(!b) {
            rc = (GetLastError() == ERROR_INSUFFICIENT_BUFFER
               ? ERROR_FILENAME_EXCED_RANGE : GetLastError());
            goto clean0;
        }

        if (SourcePathRoot) {
            lstrcpyn(Buffer1,SourcePathRoot,MAX_PATH);
        } else {
            Buffer1[0] = TEXT('\0');
        }

        if(!pSetupConcatenatePaths(Buffer1,Buffer2,MAX_PATH,NULL)
        || !pSetupConcatenatePaths(Buffer1,SourceFile,MAX_PATH,NULL)) {
            rc = ERROR_FILENAME_EXCED_RANGE;
            goto clean0;
        }

        FullSourceFilename = DuplicateString(Buffer1);
    }

    if(!FullSourceFilename) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    SourceFilenamePart = pSetupGetFileTitle(FullSourceFilename);

    //
    // Determine the full target path and filename of the file.
    // For now ignore the issues regarding compressed vs. uncompressed names.
    //
    if(InfContext) {
        //
        // DestinationName is the filename only (no path) of the target.
        // We'll need to fetch the target path information for the section
        // that InfContext references.
        //
        b = SetupGetTargetPath(
                InfHandle,
                InfContext,
                NULL,
                Buffer1,
                MAX_PATH,
                NULL
                );

        if(!b) {
            rc = (GetLastError() == ERROR_INSUFFICIENT_BUFFER
               ? ERROR_FILENAME_EXCED_RANGE : GetLastError());
            goto clean1;
        }

        lstrcpyn(Buffer2,Buffer1,MAX_PATH);

        b = pSetupConcatenatePaths(
                Buffer2,
                DestinationName ? DestinationName : SourceFilenamePart,
                MAX_PATH,
                NULL
                );

        if(!b) {
            rc = ERROR_FILENAME_EXCED_RANGE;
            goto clean1;
        }

        FullTargetFilename = DuplicateString(Buffer2);
    } else {
        //
        // DestinationName is the full path and filename of the target file.
        //
        FullTargetFilename = DuplicateString(DestinationName);
    }

    if(!FullTargetFilename) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    //
    // Log the file copy - only if we log something else
    // note that once we've determined temporary name, we'll change this message
    //
    slot_fileop = AllocLogInfoSlot(lc,FALSE); // for conditional display of extra logging info
    WriteLogEntry(
        lc,
        slot_fileop,
        MSG_LOG_COPYING_FILE,
        NULL,
        FullSourceFilename,
        FullTargetFilename);

    //
    // Make sure the target path exists.
    //
    rc = pSetupMakeSurePathExists(FullTargetFilename);
    if(rc != NO_ERROR) {
        rc = ERROR_INVALID_TARGET;
        goto clean2;
    }

    //
    // Determine if the source file is compressed and get compression type
    // if so.
    //
    rc = SetupInternalGetFileCompressionInfo(
            FullSourceFilename,
            &ActualSourceFilename,
            &SourceFindData,
            &TargetFileSize,
            &CompressionType
            );

    //
    // If the source doesn't exist but the target does, and we don't want to
    // overwrite it, then there is no error and we're finished.
    //
    // When doing a driver uninstall (i.e., re-installing the
    // previous driver from the backup directory), it's possible that not all
    // source files will be present in that directory (i.e., only those files
    // that were modified got backed up).  In that case, we want to consider a
    // source file-not-found error here to be OK, even if the force-nooverwrite
    // flag isn't set.
    //
    // Note that driver signing isn't relevant here, because if an INF was signed
    // with the force-nooverwrite flag, then the signer (i.e., WHQL) must've been
    // satisfied that the file in question was not crucial to the package's
    // integrity/operation (a default INI file would be an example of this).
    //
    if(rc == ERROR_FILE_NOT_FOUND &&
        CopyStyle & SP_COPY_FORCE_NOOVERWRITE &&
        FileExists(FullTargetFilename,NULL)
        ) {

        rc = NO_ERROR;
        goto clean2;

    } else if(rc != NO_ERROR) {
        goto clean2;
    }

    //
    // Got the actual source file name now.
    //
    MyFree(FullSourceFilename);
    FullSourceFilename = ActualSourceFilename;
    SourceFilenamePart = pSetupGetFileTitle(FullSourceFilename);

    //
    // If the file to be copied is a .CAB and the source and destination
    // filenames are the same, then we don't want to attempt to decompress it
    // (because if we do, we'd just be pulling the first file out of the cab
    // and renaming it to the destination filename, which is never the desired
    // behavior.
    //
    if(!lstrcmpi(SourceFilenamePart, pSetupGetFileTitle(FullTargetFilename))) {
        p = _tcsrchr(SourceFilenamePart, TEXT('.'));
        if(p && !lstrcmpi(p, TEXT(".CAB"))) {
            CopyStyle |= SP_COPY_NODECOMP;
        }
    }

    //
    // If SP_COPY_NODECOMP flag is set, adjust the target filename so that
    // the filename part is the same as the actual name of the source.
    // We do this regardless of whether the source file is compressed.
    //
    // Note:  For driver signing, the fact that this file is installed in its
    // compressed form means we must have an entry for the compressed file in
    // the catalog.  However, if at some point in the future this file is going
    // to be expanded (as is typically the case), then we need to have the
    // expanded file's signature in the catalog as well, so that sigverif
    // doesn't consider this expanded file to be from a non-certified package.
    //
    if(CopyStyle & SP_COPY_ALREADYDECOMP) {
        //
        // this flag indicates we've decompressed it as far as we want
        // (used when restoring backup)
        //
        CompressionType = FILE_COMPRESSION_NONE;

    } else if(CopyStyle & SP_COPY_NODECOMP) {
        //
        // Strip out version-related bits and ensure that we treat the file
        // as uncompressed.
        //
        CopyStyle &= ~SP_COPY_MASK_NEEDVERINFO;
        CompressionType = FILE_COMPRESSION_NONE;

        //
        // Isolate the path part of the target filename.
        //
        lstrcpyn(Buffer1, FullTargetFilename, MAX_PATH);
        *((PTSTR)pSetupGetFileTitle(Buffer1)) = TEXT('\0');

        //
        // Concatenate the source filename onto the target pathname.
        //
        if(!pSetupConcatenatePaths(Buffer1,SourceFilenamePart,MAX_PATH,NULL)) {
            rc = ERROR_FILENAME_EXCED_RANGE;
            goto clean2;
        }

        p = DuplicateString(Buffer1);
        if(!p) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean2;
        }

        MyFree(FullTargetFilename);
        FullTargetFilename = p;
    }

    //
    // See if the target file exists, either as a renamed file (i.e., because
    // we're replacing a boot file), or as a file presently existing at the
    // target location.
    //
    if(Queue && (CopyStyle & SP_COPY_REPLACE_BOOT_FILE)) {
        //
        // First, we need to find the corresponding target info node so
        // we can find out what temporary name our file was renamed to.
        //
        rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                         NULL, // use Queue's string table
                                         FullTargetFilename,
                                         QueueNode->TargetDirectory,
                                         -1,
                                         QueueNode->TargetFilename,
                                         NULL,
                                         &TargetInfo
                                        );
        if(rc == NO_ERROR) {
            //
            // Has the file previously been renamed (and not yet restored)?
            //
            if((TargetInfo.InternalFlags & (SP_TEFLG_MOVED | SP_TEFLG_RESTORED)) == SP_TEFLG_MOVED) {

                CompareFile = ExistingFile =
                       pSetupStringTableStringFromId(
                                                     Queue->StringTable,
                                                     TargetInfo.NewTargetFilename
                                                     );
                MYASSERT(ExistingFile);
            }
        }
    }

    if(!ExistingFile && FileExists(FullTargetFilename, NULL)) {
        CompareFile = ExistingFile = FullTargetFilename;
        CompareSameFilename = TRUE; // allows optimization later
    }

    if(ExistingFile) {

        if(CopyStyle & SP_COPY_FORCE_NOOVERWRITE) {
            //
            // No overwrite and no callback notification either
            //
            // Note that driver signing isn't relevant here, because if an INF
            // was signed with the force-nooverwrite flag, then the signer
            // (i.e., WHQL) must've been satisfied that the file in question was
            // not crucial to the package's integrity/operation (a default INI
            // file would be an example of this).
            //
            rc = NO_ERROR;
            goto clean2;
        }

        if(CopyStyle & SP_COPY_MASK_NEEDVERINFO) {
            if(!GetVersionInfoFromImage(ExistingFile, &TargetVersion, &TargetLanguage)) {
                TargetVersion = 0;
                TargetLanguage = 0;
            }
        }

        //
        // If the target file exists we'll want to preserve security info on it.
        //
        if(RetreiveFileSecurity(ExistingFile, &SecurityInfo) != NO_ERROR) {
            SecurityInfo = NULL;
        }

    } else {

        if(CopyStyle & SP_COPY_REPLACEONLY) {
            //
            // Target file doesn't exist, so there's nothing to do.
            //
            rc = NO_ERROR;
            goto clean2;
        }
        if(Queue && ((Queue->Flags & FQF_FILES_MODIFIED)==0)) {
            //
            // maybe the file was renamed/deleted first
            // so we might still want to compare against backup
            // to determine if it was "modified"
            //
            rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                             NULL, // use Queue's string table
                                             FullTargetFilename,
                                             QueueNode->TargetDirectory,
                                             -1,
                                             QueueNode->TargetFilename,
                                             NULL,
                                             &TargetInfo
                                            );
            if((rc == NO_ERROR) &&
                  ((TargetInfo.InternalFlags & (SP_TEFLG_MOVED | SP_TEFLG_SAVED)) != 0)) {
                    //
                    // get filename of copy of original file, if there is one
                    //
                    CompareFile = BackupFileName =
                                     pSetupFormFullPath(Queue->StringTable,
                                                        TargetInfo.TargetRoot,
                                                        TargetInfo.TargetSubDir,
                                                        TargetInfo.TargetFilename
                                                       );
            }
        }
    }

    //
    // If the source is not compressed (LZ or cabinet), and SIS is (or might be)
    // present, create the target as an SIS link to the master instead of copying it.
    //
    // If the target exists, and NOOVERWRITE was specified, don't try to create
    // an SIS link. Instead, fall through to the normal copy code. The overwrite
    // semantics are wrong if the file already exists.
    //
    if((CompressionType == FILE_COMPRESSION_NONE) &&
       (!ExistingFile || ((CopyStyle & SP_COPY_NOOVERWRITE) == 0)) &&
       (Queue != NULL) &&
       ((Queue->Flags & FQF_TRY_SIS_COPY) != 0)) {

        //
        // First, verify that the sourcefile is signed.  If it is not, but the
        // user elects to proceed with the copy (or if the policy is 'ignore')
        // then we'll go ahead and attempt to setup the SIS link.
        //
        ValidationPlatform = (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                ? &(Queue->AltPlatformInfo)
                                : Queue->ValidationPlatform;

        rc = VerifySourceFile(lc,
                              Queue,
                              QueueNode,
                              pSetupGetFileTitle(FullTargetFilename),
                              FullSourceFilename,
                              NULL,
                              ValidationPlatform,
                              VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_FAIL_COPIED_INFS,
                              &Problem,
                              Buffer1,
                              NULL,
                              NULL,
                              NULL
                             );

        if(rc != NO_ERROR) {

            *SignatureVerifyFailed = TRUE;
            SigVerifRc = rc;

            if(Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
                goto clean2;
            }

            if (Problem != SetupapiVerifyDriverBlocked) {
                //
                // If this is a device installation and the policy is "Ignore",
                // then crank it up to "Warn" if the file is under SFP's
                // protection.  This will allow the user to update a driver that
                // ships in our box for which no WHQL certification program
                // exists.
                //
                if((Queue->Flags & FQF_DEVICE_INSTALL) &&
                   (Queue->DriverSigningPolicy == DRIVERSIGN_NONE) &&
                   IsFileProtected(FullTargetFilename, lc, NULL)) {

                    Queue->DriverSigningPolicy = DRIVERSIGN_WARNING;

                    //
                    // Log the fact that policy was elevated.
                    //
                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_POLICY_ELEVATED_FOR_SFC,
                                  NULL
                                 );
                }
            }

            if(!pSetupHandleFailedVerification(
                    Queue->hWndDriverSigningUi,
                    Problem,
                    (Problem == SetupapiVerifyDriverBlocked)
                      ? FullSourceFilename : Buffer1,
                    ((Queue->DeviceDescStringId == -1)
                        ? NULL
                        : pStringTableStringFromId(Queue->StringTable, Queue->DeviceDescStringId)),
                    Queue->DriverSigningPolicy,
                    (Queue->Flags & FQF_DIGSIG_ERRORS_NOUI),
                    rc,
                    lc,
                    (((Queue->Flags & FQF_ABORT_IF_UNSIGNED) &&
                      (Problem != SetupapiVerifyDriverBlocked))
                        ? NULL : &ExemptCopyFlags),
                    (((Queue->Flags & FQF_ABORT_IF_UNSIGNED) &&
                      (Problem != SetupapiVerifyDriverBlocked))
                        ? NULL : FullTargetFilename)))
            {
                //
                // User elected not to install the unsigned file (or was blocked
                // by policy from doing so).
                //
                goto clean2;
            }

            //
            // The user wants to proceed with the unsigned installation (or
            // policy is ignore, so they weren't even informed).  If the
            // caller wants a chance to set a system restore point prior to
            // doing any unsigned installations, then we abort now with a
            // "special" error code that tells them what to do...
            //
            if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                //
                // We don't want the user to see the driver signing UI again
                // when the queue is re-committed...
                //
                if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                    Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                }

                rc = ERROR_SET_SYSTEM_RESTORE_POINT;
                goto clean2;
            }

            //
            // Set a flag in the queue that indicates the user has been informed
            // of a signature problem with this queue, and has elected to go
            // ahead and install anyway.  Don't set this flag if the queue's
            // policy is "Ignore", on the chance that the policy might be
            // altered later, and we'd want the user to get informed on any
            // subsequent errors.
            //
            if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
            }

            if (QueueNode) {
                QueueNode->InternalFlags |= ExemptCopyFlags;
            }

            //
            // Reset rc to NO_ERROR and carry on.
            //
            rc = NO_ERROR;
        }

        if(rc == NO_ERROR) {

            rc = CreateTargetAsLinkToMaster(
                    Queue,
                    FullSourceFilename,
                    FullTargetFilename,
                    CopyMsgHandler,
                    Context,
                    IsMsgHandlerNativeCharWidth
                    );
        }

        if(rc == NO_ERROR) {
            //
            // ISSUE JamieHun-2001/03/20 Is this best thing to do for SIS link?
            //
            Queue->Flags |= FQF_FILES_MODIFIED;

            //
            // We're done!
            //
            Ok = TRUE;
            goto clean2;
        }
    }

    //
    // We will copy the file to a temporary location. This makes version checks
    // possible in all cases (even when the source is compressed) and simplifies
    // the logic below. Start by forming the name of the temporary file.
    //
    lstrcpyn(Buffer1, FullTargetFilename, MAX_PATH);
    *((PTSTR)pSetupGetFileTitle(Buffer1)) = TEXT('\0');

    if(!GetTempFileName(Buffer1, TEXT("SETP"), 0, Buffer2)) {
        rc = ERROR_INVALID_TARGET;
        goto clean2;
    }

    TemporaryTargetFile = DuplicateString(Buffer2);
    if(!TemporaryTargetFile) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }
    //
    // Log the file copy - only if we log something else unless at Info level
    //
    ReleaseLogInfoSlot(lc,slot_fileop);
    slot_fileop = AllocLogInfoSlotOrLevel(lc,SETUP_LOG_INFO,FALSE); // for conditional display of extra logging info
    WriteLogEntry(
        lc,
        slot_fileop,
        MSG_LOG_COPYING_FILE_VIA,
        NULL,
        FullSourceFilename,
        FullTargetFilename,
        TemporaryTargetFile);

    //
    // Perform the actual file copy. This creates the temporary target file.
    // Move is allowed as an optimization if we're deleting the source file.
    // The call we make below will not use move if the file is compressed
    // and we are supposed to decompress it, so the right thing will happen
    // in all cases.
    //
    // There are 2 potential issues:
    //
    // 1) When we call the callback function below for a version check,
    //    the source file won't exist any more if the file was moved. Oh well.
    //
    // 2) If the MoveFileEx below fails, the source will have still been 'deleted'.
    //    This is different from the non-move case, where the source remains
    //    intact unless this function is successful.
    //
    // Otherwise this is a non-issue since any compressed file will be decompressed
    // by this call, so version gathering, etc, will all work properly.
    //
    rc = pSetupDecompressOrCopyFile(
            FullSourceFilename,
            TemporaryTargetFile,
            &CompressionType,
            ((CopyStyle & SP_COPY_DELETESOURCE) != 0),
            &Moved
            );

    if(rc != NO_ERROR) {
        goto clean3;
    }

    //
    // Do digital signature check on source file, now that it exists in its
    // final form under a temp name.  Note that for signed files, we ignore
    // version checking since they're an inherently unreliable mechanism for
    // comparing files provided from two different vendors (who use different
    // versioning schemes, etc.)
    //
    // To see why we ignore version numbers, consider the decision tree we'd
    // use if we were paying attention to version numbers as well as digital
    // signatures.  In the discussion that follows, NewFile is the (signed) file
    // we're going to copy, and OldFile is the file that will be overwritten if
    // the copy goes through...
    //
    // if NewFile is versioned {
    //     if OldFile is signed {
    //         if OldFile is versioned {
    //             //
    //             // Both NewFile and OldFile are signed and versioned.
    //             //
    //             if OldFile is a newer version {
    //                 //
    //                 // This is the controversial case.  Since these two incarnations could've come from different vendors
    //                 // with different versioning schemes, we really can't use versioning as a very accurate method of determining
    //                 // which file is 'better'.  So there are two options:
    //                 //    1.  Leave OldFile alone, and if the package being installed can't work with OldFile, then the user must 'undo'
    //                 //         the installation, and then call their vendor to gripe--there'll be no way for them to get the new package to
    //                 //         work, even though WHQL certified it.
    //                 //    2.  Overwrite OldFile.  Since we're then guaranteeing that every file signed as part of the package will be
    //                 //         present, then we can have a much higher degree of certainty that our WHQL certification will hold true
    //                 //         for every user's machine.  If replacing OldFile breaks someone else (e.g., the previously-installed package
    //                 //         that uses it, then the user can 'undo' the installation.  This scenario is better because even though the old
    //                 //         and new packages can't be used simultaneously, at least one or the other can be made to work
    //                 //         independently.
    //                 //
    //                 overwrite OldFile
    //             } else {  // NewFile is a newer version
    //                 overwrite OldFile
    //             }
    //         } else {  // OldFile isn't versioned--NewFile wins
    //             overwrite OldFile
    //         }
    //     } else {  // OldFile isn't signed--we don't care what its version is
    //         overwrite OldFile
    //     }
    // } else {  // NewFile isn't versioned
    //     if OldFile is versioned {
    //         if OldFile is signed {
    //             //
    //             // (See discussion above where both OldFile and NewFile are signed and versioned, and OldFile is newer.  Note
    //             // that something funny is going on if we've been asked to replace a versionable file with an unversionable one!)
    //             //
    //             overwrite OldFile
    //         } else {  // OldFile isn't signed
    //             overwrite OldFile
    //         }
    //     } else {  // OldFile isn't versioned either
    //         overwrite OldFile
    //     }
    // }
    //

    //
    // Check to see if the source file is signed.  (Note--we may have already
    // checked this previously in determining whether an SIS link could be
    // created.  If we failed to verify the file's digital signature then,
    // there's no use in re-verifying here.)
    //
    if(*SignatureVerifyFailed) {
        //
        // We saved the signature verification failure error when we previously
        // attempted to verify this file.  Restore that code to rc now, because
        // the code below relies on the value of rc.
        //
        MYASSERT(SigVerifRc != NO_ERROR);
        rc = SigVerifRc;

    } else {

        if(Queue) {

            ValidationPlatform = (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                    ? &(Queue->AltPlatformInfo)
                                    : Queue->ValidationPlatform;
        } else {
            //
            // Since we aren't dealing with a queue, we need to retrieve the
            // appropriate validation platform information, if any, for our INF.
            //
            DoingDeviceInstall = IsInfForDeviceInstall(lc,
                                                       NULL,
                                                       LoadedInf,
                                                       &DeviceDesc,
                                                       &ValidationPlatform,
                                                       &DriverSigningPolicy,
                                                       NULL
                                                      );
        }

        rc = VerifySourceFile(lc,
                              Queue,
                              QueueNode,
                              pSetupGetFileTitle(FullTargetFilename),
                              TemporaryTargetFile,
                              FullSourceFilename,
                              ValidationPlatform,
                              VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_FAIL_COPIED_INFS,
                              &Problem,
                              Buffer1,
                              NULL,
                              NULL,
                              NULL
                             );

        *SignatureVerifyFailed = (rc != NO_ERROR);

    }

    //
    // Don't muck with the value of rc below unless you're setting it
    // immediately before jumping to clean4.  The return value from
    // VerifySourceFile needs to be preserved until we finish with the
    // pSetupHandleFailedVerification stuff.
    //

    //
    // If we are going to perform version checks, fetch the version data
    // of the source (which is now the temporary target file).
    //
    NotifyFlags = 0;
    if(ExistingFile) {

        param = 0;

        //
        // If we're not supposed to overwrite existing files,
        // then the overwrite check fails.
        //
        if(CopyStyle & SP_COPY_NOOVERWRITE) {
            NotifyFlags |= SPFILENOTIFY_TARGETEXISTS;
        }

        //
        // Even if the source file has a verified digital signature, we still
        // want to retrieve version information for the source and target.  We
        // do this so that we can detect when we've overwritten a newer-
        // versioned file with an older-versioned one.  If we discover that
        // this is the case, then we generate an exception log entry that will
        // help PSS troubleshoot any problems that result.
        //
        if(!GetVersionInfoFromImage(TemporaryTargetFile, &SourceVersion, &SourceLanguage)) {
            SourceVersion = 0;
            SourceLanguage = 0;
        }

        //
        // If we're not supposed to overwrite files in a different language
        // and the languages differ, then the language check fails.
        // If either file doesn't have language data, then don't do a language
        // check.
        //
        //
        // Special case:
        //
        // If
        //  a) the source version is greater than the target version
        //  b) the source doesn't have a lang id
        //  c) the target does have a lang id
        // Then
        //  we will do a language check, and we will consider this language check
        //  as passed since we are replacing an older language specific file with
        //  a language neutral file, which is an OK thing.
        //
        //
        if(CopyStyle & SP_COPY_LANGUAGEAWARE) {
            if ( SourceLanguage
                 && TargetLanguage
                 && (SourceLanguage != TargetLanguage) ) {

                NotifyFlags |= SPFILENOTIFY_LANGMISMATCH;
                param = (UINT)MAKELONG(SourceLanguage, TargetLanguage);

            } else if ( !SourceLanguage
                        && TargetLanguage
                        && (TargetVersion >= SourceVersion) ) {

                NotifyFlags |= SPFILENOTIFY_LANGMISMATCH;
                param = (UINT)MAKELONG(SourceLanguage, TargetLanguage);

            }

        }


        //
        // If we're not supposed to overwrite newer versions and the target is
        // newer than the source, then the version check fails. If either file
        // doesn't have version info, fall back to timestamp comparison.
        //
        // If the files are the same version/timestamp, assume that either
        // replacing the existing one is a benevolent operation, or that
        // we are upgrading an existing file whose version info is unimportant.
        // In this case we just go ahead and copy the file (unless the
        // SP_COPY_NEWER_ONLY flag is set).
        //
        // Note that the version checks below are made without regard to presence
        // or absence of digital signatures on either the source or target files.
        // That will be handled later.  We want to see what would've happened
        // without driver signing, so we can generate a PSS exception log when
        // something weird happens.
        //
        if(SourceVersion || TargetVersion) {

            b = (CopyStyle & SP_COPY_NEWER_ONLY)
              ? (TargetVersion >= SourceVersion)
              : (TargetVersion > SourceVersion);

        } else {
#if 0
            //
            // (tedm) removed timestamp-based checking. It's just not a reliable
            // way of doing things.
            //

            //
            // File time on FAT is only guaranteed accurate to within 2 seconds.
            // Round the filetimes before comparison by converting to DOS time
            // and back. If the conversions fail then just use the original values.
            //
            if(!FileTimeToDosDateTime(&SourceFindData.ftLastWriteTime,&sDosDate,&sDosTime)
            || !FileTimeToDosDateTime(&TargetFindData.ftLastWriteTime,&tDosDate,&tDosTime)
            || !DosDateTimeToFileTime(sDosDate,sDosTime,&sFileTime)
            || !DosDateTimeToFileTime(tDosDate,tDosTime,&tFileTime)) {

                sFileTime = SourceFindData.ftLastWriteTime;
                tFileTime = TargetFindData.ftLastWriteTime;
            }

            //
            // If the FORCE_NEWER flag is set then don't use timestamps
            // for versioning. This more closely matches Win95's setupx behavior.
            //
            b = (CopyStyle & SP_COPY_FORCE_NEWER)
              ? FALSE
              : (CompareFileTime(&tFileTime,&sFileTime) > 0);
#else
            b  = FALSE;
#endif
        }

        //
        // At this point, if b is TRUE then the target file has a later (newer)
        // version than the sourcefile.  If we've been asked to pay attention to
        // that, then set the NotifyFlags to indicate this problem.
        // Note that this may get reset later if the source file is signed.  We
        // still wanted to get this information so we could put it in our PSS
        // logfile.
        //
        if(b &&
           (CopyStyle & (SP_COPY_NEWER_OR_SAME | SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER))) {

            NotifyFlags |= SPFILENOTIFY_TARGETNEWER;
        }
    }

    if(NotifyFlags & SPFILENOTIFY_TARGETNEWER) {

        if(!*SignatureVerifyFailed) {
            //
            // Source file is signed, but the target file is newer.  We know
            // that we still want to replace the existing targetfile with the
            // sourcefile, regardless of version numbers.  However, we need to
            // make note of that in our PSS logfile.
            //
            NotifyFlags &= ~SPFILENOTIFY_TARGETNEWER;

            //
            // Check to see if the target file is signed, in order to include
            // this information in our PSS logfile.
            //
            ExistingTargetFileWasSigned = (NO_ERROR == _VerifyFile(
                                                           lc,
                                                           (Queue ? &(Queue->hCatAdmin) : NULL),
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           0,
                                                           pSetupGetFileTitle(FullTargetFilename),
                                                           ExistingFile,
                                                           NULL,
                                                           NULL,
                                                           FALSE,
                                                           ValidationPlatform,
                                                           (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                                           NULL,
                                                           NULL,
                                                           NULL,
                                                           NULL
                                                          ));

            //
            // SPLOG -- report that newer target was overwritten by older (signed)
            // source, whether target was signed, both files' versions, etc.
            // Also probably want to throw in the fact that the SP_COPY_FORCE_NEWER
            // flag was ignored, if it's set.
            //
            pGetVersionText(SourceVersionText,SourceVersion);
            pGetVersionText(TargetVersionText,TargetVersion);
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                MSG_LOG_NEWER_FILE_OVERWRITTEN,
                NULL,
                FullTargetFilename,
                SourceVersionText,
                TargetVersionText);

            if (CopyStyle & SP_COPY_FORCE_NEWER) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_FLAG_FORCE_NEWER_IGNORED,
                    NULL);
            }
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                (ExistingTargetFileWasSigned ?
                    MSG_LOG_TARGET_WAS_SIGNED :
                    MSG_LOG_TARGET_WAS_NOT_SIGNED),
                NULL);
            //
            // flush the log buffer
            //
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING,
                0,
                TEXT("\n"));

        } else {
            //
            // Source file isn't signed, so we'll let the old behavior apply.
            // If version dialogs are allowed, for example, the user will be
            // prompted that they're attempting to overwrite a newer file with an
            // older one.  If they say "go ahead and copy over the older version",
            // _then_ they'll get a prompt about the file not having a valid
            // signature.
            //
            // Check special case where a flag is set indicating that we should
            // just silently not copy the newer file.
            //
            if(CopyStyle & SP_COPY_FORCE_NEWER) {
                //
                // Target is newer; don't copy the file.
                //
                rc = NO_ERROR;
                goto clean4;
            }

        }
    }

    //
    // If we have any reason to notify the caller via the callback,
    // do that here. If there is no callback, then don't copy the file,
    // because one of the conditions has not been met.
    //
    if((NotifyFlags & SPFILENOTIFY_LANGMISMATCH) && ! *SignatureVerifyFailed) {
        //
        //
        //
        // if the source was signed, we will ignore a language mismatch
        // as this is a package deal
        // NTRAID9#498046-2001/11/20-JamieHun handle LANGMISMATCH better
        //
        NotifyFlags &=~SPFILENOTIFY_LANGMISMATCH;
        WriteLogEntry(
            lc,
            SETUP_LOG_WARNING,
            MSG_LOG_NOTIFY_LANGMISMATCH,
            NULL);
    }
    if(NotifyFlags) {

        FilePaths.Source = FullSourceFilename;
        FilePaths.Target = FullTargetFilename;
        FilePaths.Win32Error = NO_ERROR;

        if(!CopyMsgHandler
        || !pSetupCallMsgHandler(
                lc,
                CopyMsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                NotifyFlags,
                (UINT_PTR)&FilePaths,
                param))
        {
            if(ExistingFile) {
                //
                // Check to see if the target file is signed, in order to include
                // this information in our PSS logfile.
                //
                ExistingTargetFileWasSigned = (NO_ERROR == _VerifyFile(
                                                               lc,
                                                               (Queue ? &(Queue->hCatAdmin) : NULL),
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               0,
                                                               pSetupGetFileTitle(FullTargetFilename),
                                                               ExistingFile,
                                                               NULL,
                                                               NULL,
                                                               FALSE,
                                                               ValidationPlatform,
                                                               (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               NULL
                                                              ));
            }

            //
            // SPLOG -- error that occurred, info on whether source and target
            // files were signed, what their versions were, etc.
            //

            pGetVersionText(SourceVersionText,SourceVersion);
            pGetVersionText(TargetVersionText,TargetVersion);
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                MSG_LOG_FILE_NOT_OVERWRITTEN,
                NULL,
                SourceVersionText,
                TargetVersionText);
            if (NotifyFlags & SPFILENOTIFY_TARGETEXISTS) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_NOTIFY_TARGETEXISTS,
                    NULL);
            }
            if (NotifyFlags & SPFILENOTIFY_LANGMISMATCH) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_NOTIFY_LANGMISMATCH,
                    NULL);
            }
            if (NotifyFlags & SPFILENOTIFY_TARGETNEWER) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_NOTIFY_TARGETNEWER,
                    NULL);
            }
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                (ExistingTargetFileWasSigned ?
                    MSG_LOG_TARGET_WAS_SIGNED :
                    MSG_LOG_TARGET_WAS_NOT_SIGNED),
                NULL);
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                (*SignatureVerifyFailed ?
                    MSG_LOG_SOURCE_WAS_NOT_SIGNED :
                    MSG_LOG_SOURCE_WAS_SIGNED),
                NULL);
            WriteLogError(
                lc,
                SETUP_LOG_WARNING,
                rc);

            rc = NO_ERROR;
            goto clean4;
        }
    }

    //
    // OK, now that all non-codesigning stuff is done, tell the user about
    // any digital signature problems we found with the source file.
    //
    // NOTE: If SigVerifRc is set to something other than NO_ERROR, then we know
    // that the pSetupHandleFailedVerification routine has already been called, thus
    // we don't want to call it again or otherwise the user may get multiple
    // prompts about a bad signature for the same file.
    //
    if(*SignatureVerifyFailed) {

        if(SigVerifRc == NO_ERROR) {

            MYASSERT(ExemptCopyFlags == 0);

            //
            // Save away the verification error in SigVerifRc, so we can use
            // this later to determine whether we're dealing with an unsigned
            // file.
            //
            MYASSERT(rc != NO_ERROR);
            SigVerifRc = rc;

            //
            // If we're using a file queue, the retrieve information from the
            // queue regarding policy, whether it's a device install (and if
            // so, what description to use), etc.  There's no need to do this
            // in the non-queue case, because we already did this previously.
            //
            if(Queue) {
                //
                // if we're set to block on a per queue basis, then bail out
                // here
                //
                if(Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
                    goto clean4;
                }
                if(Queue->DeviceDescStringId != -1) {
                    DeviceDesc = pStringTableStringFromId(
                                     Queue->StringTable,
                                     Queue->DeviceDescStringId
                                    );
                    MYASSERT(DeviceDesc);
                } else {
                    DeviceDesc = NULL;
                }

                DoingDeviceInstall = Queue->Flags & FQF_DEVICE_INSTALL;
                DriverSigningPolicy = Queue->DriverSigningPolicy;
            }

            if (Problem != SetupapiVerifyDriverBlocked) {
                //
                // If this is a device installation and the policy is "Ignore",
                // then crank it up to "Warn" if the file is under SFP's
                // protection.  This will allow the user to update a driver that
                // ships in our box for which no WHQL certification program
                // exists.
                //
                if(DoingDeviceInstall && (DriverSigningPolicy == DRIVERSIGN_NONE) &&
                   IsFileProtected(FullTargetFilename, lc, NULL)) {

                    DriverSigningPolicy = DRIVERSIGN_WARNING;

                    //
                    // If we have a queue, update the queue's policy as well.
                    //
                    if(Queue) {
                        Queue->DriverSigningPolicy = DRIVERSIGN_WARNING;
                    }

                    //
                    // Log the fact that policy was elevated.
                    //
                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_POLICY_ELEVATED_FOR_SFC,
                                  NULL
                                 );
                }
            }

            if(!pSetupHandleFailedVerification(
                    (Queue ? Queue->hWndDriverSigningUi : NULL),
                    Problem,
                    (Problem == SetupapiVerifyDriverBlocked)
                      ? FullSourceFilename : Buffer1,
                    DeviceDesc,
                    DriverSigningPolicy,
                    (Queue ? (Queue->Flags & FQF_DIGSIG_ERRORS_NOUI) : FALSE),
                    rc,
                    lc,
                    (((Queue && (Queue->Flags & FQF_ABORT_IF_UNSIGNED)) &&
                      (Problem != SetupapiVerifyDriverBlocked))
                        ? NULL : &ExemptCopyFlags),
                    (((Queue && (Queue->Flags & FQF_ABORT_IF_UNSIGNED)) &&
                      (Problem != SetupapiVerifyDriverBlocked))
                        ? NULL : FullTargetFilename)))
            {
                //
                // User elected not to install the unsigned file (or was blocked
                // by policy from doing so).
                //
                goto clean4;
            }
        }

        if(Queue) {
            //
            // If the caller wants a chance to set a system restore point prior
            // to doing any unsigned installations, then we abort now with a
            // "special" error code that tells them what to do...
            //
            if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                //
                // We don't want the user to see the driver signing UI again
                // when the queue is re-committed...
                //
                if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                    Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                }

                rc = ERROR_SET_SYSTEM_RESTORE_POINT;
                goto clean4;
            }

            //
            // Set a flag in the queue that indicates the user has been informed
            // of a signature problem with this queue, and has elected to go
            // ahead and install anyway.  Don't set this flag if the queue's
            // policy is "Ignore", on the chance that the policy might be
            // altered later, and we'd want the user to get informed on any
            // subsequent errors.
            //
            if(Queue->DriverSigningPolicy != DRIVERSIGN_NONE) {
                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
            }

            if (QueueNode) {
                QueueNode->InternalFlags |= ExemptCopyFlags;
            }
        }

        //
        // Reset rc to NO_ERROR and carry on.
        //
        rc = NO_ERROR;
    }

    //
    // Move the target file into its final location.
    //
    SetFileAttributes(FullTargetFilename, FILE_ATTRIBUTE_NORMAL);

    if(Queue && ((Queue->Flags & FQF_FILES_MODIFIED)==0)) {
        //
        // so far we haven't flagged that any files are modified
        //
        if(CompareFile) {
            //
            // we have an "original" file
            //
            if(pCompareFilesExact(TemporaryTargetFile,CompareFile)) {
                //
                // new file of this name is same as original file of same name
                //
                if(CompareSameFilename) {
                    //
                    // original is already in place
                    // don't need to do a delayed-rename
                    //
                    FileUnchanged = TRUE;
                }
            } else {
                //
                // file appears to have been modified
                //
                Queue->Flags |= FQF_FILES_MODIFIED;
            }
        } else {
            //
            // be safe, copying over nothing = modified
            //
            Queue->Flags |= FQF_FILES_MODIFIED;
        }
    }


    //
    // If the target exists and the force-in-use flag is set, then don't try to
    // move the file into place now -- automatically drop into in-use behavior.
    //
    // Want to use MoveFileEx but it didn't exist in Win95. Ugh.
    //
    if(!(ExistingFile && (CopyStyle & SP_COPY_FORCE_IN_USE))
        && (b = DoMove(TemporaryTargetFile, FullTargetFilename))) {
        //
        // Place security information on the target file if necessary.
        // Ignore errors. The theory here is that the file is already on
        // the target, so if this fails the worst case is that the file is
        // not secure. But the user can still use the system.
        //
        if(SecurityInfo) {
            DWORD err = StampFileSecurity(FullTargetFilename, SecurityInfo);
            if(err != NO_ERROR) {
                WriteLogEntry(lc,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_FILE_SECURITY_FAILED,
                              NULL,
                              FullTargetFilename
                             );
                WriteLogError(lc,SETUP_LOG_ERROR,err);
            } else {
                WriteLogEntry(lc,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_SET_FILE_SECURITY,
                              NULL,
                              FullTargetFilename
                             );
            }
        }
    } else {
        //
        // If this fails, assume the file is in use and mark it for copy on next
        // boot (except in the case where we're copying a boot file, in which
        // case this is a catastrophic failure).
        //
        if(ExistingFile != FullTargetFilename) {

            WriteLogEntry(lc,
                          SETUP_LOG_ERROR,
                          MSG_LOG_REPLACE_BOOT_FILE_FAILED,
                          NULL,
                          FullTargetFilename
                         );

            b = FALSE;
            SetLastError(ERROR_ACCESS_DENIED);
        } else if (((CopyStyle & SP_COPY_FORCE_IN_USE) == 0) &&
                   (FileUnchanged || pCompareFilesExact(TemporaryTargetFile,FullTargetFilename))) {
            //
            // It turns out that new file and old file are exactly the same
            // we can optimize out the delayed move and delete the temporary file
            //
            WriteLogEntry(lc,
                          SETUP_LOG_INFO,
                          MSG_LOG_COPY_IDENTICAL,
                          NULL,
                          FullTargetFilename,
                          TemporaryTargetFile
                         );

            if(SecurityInfo) {
                //
                // we still need to adjust security on it though
                //
                DWORD err = StampFileSecurity(FullTargetFilename, SecurityInfo);
                if(err != NO_ERROR) {
                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                  MSG_LOG_FILE_SECURITY_FAILED,
                                  NULL,
                                  FullTargetFilename
                                 );
                    WriteLogError(lc,SETUP_LOG_ERROR,err);
                } else {
                    WriteLogEntry(lc,
                                  SETUP_LOG_VERBOSE,
                                  MSG_LOG_SET_FILE_SECURITY,
                                  NULL,
                                  FullTargetFilename
                                 );
                }
            }

            SetFileAttributes(TemporaryTargetFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(TemporaryTargetFile);

            b = TRUE;

        } else {
            b = TRUE;
            try {
                *FileWasInUse = TRUE;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
            }

            if(b) {
                //
                // If we're trying to do a delayed move to replace a protected
                // system file (using an unsigned one), and we've not been
                // granted an exception to do so, then we should skip the
                // operation altogether (and make a log entry about it)
                //
                if((SigVerifRc != NO_ERROR) &&
                   ((ExemptCopyFlags & (IQF_TARGET_PROTECTED | IQF_ALLOW_UNSIGNED)) == IQF_TARGET_PROTECTED)) {

                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_DELAYED_MOVE_SKIPPED_FOR_SFC,
                                  NULL,
                                  FullTargetFilename
                                  );

                    //
                    // Delete the source file.
                    //

                    SetFileAttributes(TemporaryTargetFile, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(TemporaryTargetFile);

                } else {

                    BOOL TargetIsProtected = IsFileProtected(FullTargetFilename, lc, NULL);

                    if(Queue == NULL) {

                        b = DelayedMove(
                                TemporaryTargetFile,
                                FullTargetFilename
                                );

                        if(b && TargetIsProtected) {
                            //
                            // we have to explicitly tell the session manager it's ok
                            // to replace the changed files on reboot.
                            //
                            // in the case that we're using a queue, we post the
                            // delayed move and set this flag only if all the delayed
                            // move operations succeed
                            //
                            pSetupProtectedRenamesFlag(TRUE);
                        }
                    } else {
                        b = PostDelayedMove(
                                Queue,
                                TemporaryTargetFile,
                                FullTargetFilename,
                                QueueNode->SecurityDesc,
                                TargetIsProtected
                                );
                    }

                    if(b) {
                        //
                        // Couldn't set security info on the actual target, so at least
                        // set it on the temp file that will become the target.
                        //
                        if(SecurityInfo) {
                            StampFileSecurity(TemporaryTargetFile,SecurityInfo);
                        }

                        if (lc) {
                            WriteLogEntry(lc,
                                          SETUP_LOG_WARNING,
                                          MSG_LOG_COPY_DELAYED,
                                          NULL,
                                          FullTargetFilename,
                                          TemporaryTargetFile
                                          );
                        }

                        //
                        // Tell the callback that we queued this file for delayed copy.
                        //
                        if(CopyMsgHandler) {

                            FilePaths.Source = TemporaryTargetFile;
                            FilePaths.Target = FullTargetFilename;
                            FilePaths.Win32Error = NO_ERROR;
                            FilePaths.Flags = FILEOP_COPY;

                            pSetupCallMsgHandler(
                                lc,
                                CopyMsgHandler,
                                IsMsgHandlerNativeCharWidth,
                                Context,
                                SPFILENOTIFY_FILEOPDELAYED,
                                (UINT_PTR)&FilePaths,
                                0
                                );
                        }
                    }
                }

            } else {
                //
                // FileWasInUse pointer went bad
                //
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        }
    }

    if(!b) {
        rc = GetLastError();
        goto clean4;
    }

    //
    // We're done. Delete the source if necessary and return.
    //
    if((CopyStyle & SP_COPY_DELETESOURCE) && !Moved) {
        DeleteFile(FullSourceFilename);
    }

    rc = NO_ERROR;
    Ok = TRUE;
    goto clean3;

clean4:
    //
    // Remove temporary target file.
    // In case pSetupDecompressOrCopyFile MoveFile'd the source,
    // we really need to try to move it back, so the source file isn't
    // blown away when this routine fails.
    //
    if(Moved) {
        MoveFile(TemporaryTargetFile,FullSourceFilename);
    } else {
        SetFileAttributes(TemporaryTargetFile,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TemporaryTargetFile);
    }

clean3:
    MyFree(TemporaryTargetFile);
    //
    // If we didn't have a file queue, then we may have allocated a device
    // description and validation platform structure when we called
    // IsInfForDeviceInstall.  Clean those up now.
    //
    if(!Queue) {
        if(DeviceDesc) {
            MyFree(DeviceDesc);
        }
        if(ValidationPlatform) {
            MyFree(ValidationPlatform);
        }
    }

clean2:
    if (BackupFileName) {
        MyFree(BackupFileName);
    }
    MyFree(FullTargetFilename);

clean1:
    MyFree(FullSourceFilename);

clean0:
    if(SecurityInfo) {
        MyFree(SecurityInfo);
    }
    //
    // if there was an error of some sort, log it
    //
    if (rc != NO_ERROR) {
        //
        // maybe we ought to embelish this a bit.
        //
        WriteLogEntry(
            lc,
            SETUP_LOG_ERROR,
            rc,
            NULL);
    }

    if(slot_fileop) {
        ReleaseLogInfoSlot(lc, slot_fileop);
    }

    if(LoadedInf) {
        UnlockInf(LoadedInf);
    }

    SetLastError(rc);
    return(Ok);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFileExA(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCSTR               SourceFile,        OPTIONAL
    IN  PCSTR               SourcePathRoot,    OPTIONAL
    IN  PCSTR               DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    )
{
    PCWSTR sourceFile,sourcePathRoot,destinationName;
    BOOL b, DontCare;
    DWORD rc;

    sourceFile = NULL;
    sourcePathRoot = NULL;
    destinationName = NULL;
    rc = NO_ERROR;

    if(SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && SourcePathRoot) {
        rc = pSetupCaptureAndConvertAnsiArg(SourcePathRoot,&sourcePathRoot);
    }
    if((rc == NO_ERROR) && DestinationName) {
        rc = pSetupCaptureAndConvertAnsiArg(DestinationName,&destinationName);
    }

    if(rc == NO_ERROR) {

        b = _SetupInstallFileEx(
                NULL,
                NULL,
                InfHandle,
                InfContext,
                sourceFile,
                sourcePathRoot,
                destinationName,
                CopyStyle,
                CopyMsgHandler,
                Context,
                FileWasInUse,
                FALSE,
                &DontCare
                );

        rc = b ? NO_ERROR : GetLastError();

    } else {
        b = FALSE;
    }

    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(sourcePathRoot) {
        MyFree(sourcePathRoot);
    }
    if(destinationName) {
        MyFree(destinationName);
    }
    SetLastError(rc);
    return b;
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFileExW(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCWSTR              SourceFile,        OPTIONAL
    IN  PCWSTR              SourcePathRoot,    OPTIONAL
    IN  PCWSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(SourcePathRoot);
    UNREFERENCED_PARAMETER(DestinationName);
    UNREFERENCED_PARAMETER(CopyStyle);
    UNREFERENCED_PARAMETER(CopyMsgHandler);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FileWasInUse);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupInstallFileEx(
    IN  HINF              InfHandle,         OPTIONAL
    IN  PINFCONTEXT       InfContext,        OPTIONAL
    IN  PCTSTR            SourceFile,        OPTIONAL
    IN  PCTSTR            SourcePathRoot,    OPTIONAL
    IN  PCTSTR            DestinationName,   OPTIONAL
    IN  DWORD             CopyStyle,
    IN  PSP_FILE_CALLBACK CopyMsgHandler,    OPTIONAL
    IN  PVOID             Context,           OPTIONAL
    OUT PBOOL             FileWasInUse
    )

/*++

Routine Description:

    Same as SetupInstallFile().

Arguments:

    Same as SetupInstallFile().

    FileWasInUse - receives flag indicating whether the file was in use.

Return Value:

    Same as SetupInstallFile().

--*/

{
    BOOL b, DontCare;
    PCTSTR sourceFile,sourcePathRoot,destinationName;
    PCTSTR p;
    DWORD rc;

    //
    // Capture args.
    //
    if(SourceFile) {
        rc = CaptureStringArg(SourceFile,&p);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
        sourceFile = p;
    } else {
        sourceFile = NULL;
    }

    if(SourcePathRoot) {
        rc = CaptureStringArg(SourcePathRoot,&p);
        if(rc != NO_ERROR) {
            if(sourceFile) {
                MyFree(sourceFile);
            }
            SetLastError(rc);
            return FALSE;
        }
        sourcePathRoot = p;
    } else {
        sourcePathRoot = NULL;
    }

    if(DestinationName) {
        rc = CaptureStringArg(DestinationName,&p);
        if(rc != NO_ERROR) {
            if(sourceFile) {
                MyFree(sourceFile);
            }
            if(sourcePathRoot) {
                MyFree(sourcePathRoot);
            }
            SetLastError(rc);
            return FALSE;
        }
        destinationName = p;
    } else {
        destinationName = NULL;
    }

    b = _SetupInstallFileEx(
            NULL,
            NULL,
            InfHandle,
            InfContext,
            sourceFile,
            sourcePathRoot,
            destinationName,
            CopyStyle,
            CopyMsgHandler,
            Context,
            FileWasInUse,
            TRUE,
            &DontCare
            );

    //
    // We GetLastError and then set it back again before returning, so that
    // the memory frees we do below can't blow away the error code.
    //
    rc = b ? NO_ERROR : GetLastError();

    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(sourcePathRoot) {
        MyFree(sourcePathRoot);
    }
    if(destinationName) {
        MyFree(destinationName);
    }

    SetLastError(rc);
    return b;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFileA(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCSTR               SourceFile,        OPTIONAL
    IN PCSTR               SourcePathRoot,    OPTIONAL
    IN PCSTR               DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    )
{
    BOOL b;
    BOOL InUse;

    b = SetupInstallFileExA(
            InfHandle,
            InfContext,
            SourceFile,
            SourcePathRoot,
            DestinationName,
            CopyStyle,
            CopyMsgHandler,
            Context,
            &InUse
            );

    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFileW(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCWSTR              SourceFile,        OPTIONAL
    IN PCWSTR              SourcePathRoot,    OPTIONAL
    IN PCWSTR              DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(SourcePathRoot);
    UNREFERENCED_PARAMETER(DestinationName);
    UNREFERENCED_PARAMETER(CopyStyle);
    UNREFERENCED_PARAMETER(CopyMsgHandler);
    UNREFERENCED_PARAMETER(Context);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupInstallFile(
    IN HINF              InfHandle,         OPTIONAL
    IN PINFCONTEXT       InfContext,        OPTIONAL
    IN PCTSTR            SourceFile,        OPTIONAL
    IN PCTSTR            SourcePathRoot,    OPTIONAL
    IN PCTSTR            DestinationName,   OPTIONAL
    IN DWORD             CopyStyle,
    IN PSP_FILE_CALLBACK CopyMsgHandler,    OPTIONAL
    IN PVOID             Context            OPTIONAL
    )

/*++

Routine Description:

    Note: no disk prompting is performed by this routine. The caller must
    ensure that the source specified in SourcePathRoot or SourceFile
    (see below) is accessible.

Arguments:

    InfHandle - handle of inf file containing [SourceDisksNames]
        and [SourceDisksFiles] sections. If InfContext is not specified
        and CopyFlags includes SP_COPY_SOURCE_ABSOLUTE or
        SP_COPY_SOURCEPATH_ABSOLUTE, then InfHandle is ignored.

    InfContext - if specified, supplies context for a line in a copy file
        section in an inf file. The routine looks this file up in the
        [SourceDisksFiles] section of InfHandle to get file copy info.
        If not specified, SourceFile must be.  If this parameter is specified,
        then InfHandle must also be specified.

    SourceFile - if specified, supplies the file name (no path) of the file
        to be copied. The file is looked up in [SourceDisksFiles].
        Must be specified if InfContext is not; ignored if InfContext
        is specified.

    SourcePathRoot - Supplies the root path for the source (for example,
        a:\ or f:\).  Paths in [SourceDisksNames] are appended to this path.
        Ignored if CopyStyle includes SP_COPY_SOURCE_ABSOLUTE.

    DestinationName - if InfContext is specified, supplies the filename only
        (no path) of the target file. Can be NULL to indicate that the
        target file is to have the same name as the source file. If InfContext is
        not specified, supplies the full target path and filename for the target
        file.

    CopyStyle - supplies flags that control the behavior of the copy operation.

        SP_COPY_DELETESOURCE - Delete the source file upon successful copy.
            The caller receives no notification if the delete fails.

        SP_COPY_REPLACEONLY - Copy the file only if doing so would overwrite
            a file at the destination path.

        SP_COPY_NEWER - Examine each file being copied to see if its version resources
            (or timestamps for non-image files) indicate that it it is not newer than
            an existing copy on the target. If so, and a CopyMsgHandler is specified,
            the caller is notified and may veto the copy. If CopyMsgHandler is not
            specified, the file is not copied.

        SP_COPY_NOOVERWRITE - Check whether the target file exists, and, if so,
            notify the caller who may veto the copy. If no CopyMsgHandler is specified,
            the file is not overwritten.

        SP_COPY_NODECOMP - Do not decompress the file. When this option is given,
            the target file is not given the uncompressed form of the source name
            (if appropriate). For example, copying f:\mips\cmd.ex_ to \\foo\bar
            will result a target file \\foo\bar\cmd.ex_. (If this flag wasn't specified
            the file would be decompressed and the target would be called
            \\foo\bar\cmd.exe). The filename part of the target file name
            is stripped and replaced with the filename of the soruce. When this option
            is given, SP_COPY_LANGUAGEAWARE and SP_COPY_NEWER are ignored.

        SP_COPY_ALREADYDECOMP - assume file to be decompressed but may have
            compressed source name. In this case, rename the file on copy and
            check SP_COPY_LANGUAGEAWARE/SP_COPY_NEWER, but don't attempt to
            decompress the file any further.

        SP_COPY_LANGUAGEAWARE - Examine each file being copied to see if its language
            differs from the language of any existing file already on the target.
            If so, and a CopyMsgHandler is specified, the caller is notified and
            may veto the copy. If CopyMsgHandler is not specified, the file is not copied.

        SP_COPY_SOURCE_ABSOLUTE - SourceFile is a full source path.
            Do not attempt to look it up in [SourceDisksNames].

        SP_COPY_SOURCEPATH_ABSOLUTE - SourcePathRoot is the full path part of the
            source file. Ignore the relative source specified in the [SourceDisksNames]
            section of the inf file for the source media where the file is located.
            Ignored if SP_COPY_SOURCE_ABSOLUTE is specified.

        SP_COPY_FORCE_IN_USE - if the target exists, behave as if it is in use and
            queue the file for copy on next reboot.

    CopyMsgHandler - if specified, supplies a callback function to be notified of
        various conditions that may arise during the file copy.

    Context - supplies a caller-defined value to be passed as the first
        parameter to CopyMsgHandler.

Return Value:

    TRUE if a file was copied. FALSE if not. Use GetLastError for extended
    error information. If GetLastError returns NO_ERROR, then the file copy was
    aborted because (a) it wasn't needed or (b) a callback function returned
    FALSE.

--*/

{
    BOOL b;
    BOOL InUse;

    b = SetupInstallFileEx(
            InfHandle,
            InfContext,
            SourceFile,
            SourcePathRoot,
            DestinationName,
            CopyStyle,
            CopyMsgHandler,
            Context,
            &InUse
            );

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devdrv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devdrv.c

Abstract:

    Device Installer routines dealing with driver information lists

Author:

    Lonny McMichael (lonnym) 5-July-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global list containing nodes for each HDEVINFO currently involved in building
// a driver list.
//
DRVSEARCH_INPROGRESS_LIST GlobalDrvSearchInProgressList;



typedef struct _DRVLIST_TO_APPEND {
    PDRIVER_NODE DriverHead;
    PDRIVER_NODE DriverTail;
    UINT         DriverCount;
} DRVLIST_TO_APPEND, *PDRVLIST_TO_APPEND;

//
// Private function prototypes
//
BOOL
DrvSearchCallback(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR InfName,
    IN PLOADED_INF pInf,
    IN BOOL PnfWasUsed,
    IN PVOID Context
    );

BOOL
pSetupFillInHardwareAndCompatIds(
    PDEVINFO_ELEM DevInfoElem,
    HMACHINE hMachine,
    PDRVSEARCH_CONTEXT DrvSearchContext,
    PSETUP_LOG_CONTEXT LogContext
    );

LONG
pSetupGetInstalledDriverInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    PDRVSEARCH_CONTEXT  DrvSearchContext
    );

BOOL
pSetupTestIsInstalledDriver(
    IN PCTSTR Description,
    IN PCTSTR MfgName,
    IN PCTSTR ProviderName,
    IN PCTSTR InfSection,
    IN PCTSTR InfSectionExt,
    IN PDRVSEARCH_CONTEXT Context
    );

UINT
pSetupTestDevCompat(
    IN  PLOADED_INF        Inf,
    IN  PINF_LINE          InfLine,
    IN  PDRVSEARCH_CONTEXT Context,
    OUT PLONG              MatchIndex
    );

BOOL
pSetupGetDeviceIDs(
    IN OUT PDRIVER_NODE DriverNode,
    IN     PLOADED_INF  Inf,
    IN     PINF_LINE    InfLine,
    IN OUT PVOID        StringTable,
    IN     PINF_SECTION CtlFlagsSection OPTIONAL
    );

BOOL
pSetupShouldDevBeExcluded(
    IN  PCTSTR       DeviceId,
    IN  PLOADED_INF  Inf,
    IN  PINF_SECTION CtlFlagsSection,
    OUT PBOOL        ArchitectureSpecificExclude OPTIONAL
    );

BOOL
pSetupDoesInfContainDevIds(
    IN PLOADED_INF        Inf,
    IN PDRVSEARCH_CONTEXT Context
    );

VOID
pSetupMergeDriverNode(
    IN OUT PDRVSEARCH_CONTEXT Context,
    IN     PDRIVER_NODE       NewDriverNode,
    OUT    PBOOL              InsertedAtHead
    );

DWORD
BuildCompatListFromClassList(
    IN     PDRIVER_NODE       ClassDriverList,
    IN OUT PDRVSEARCH_CONTEXT Context
    );

BOOL
pSetupCalculateRankMatch(
    IN  LONG  DriverHwOrCompatId,
    IN  UINT  InfFieldIndex,
    IN  LONG  DevIdList[2][MAX_HCID_COUNT+1], // Must be same dimension as in DRVSEARCH_CONTEXT!!!
    OUT PUINT Rank
    );

BOOL
pSetupIsSimilarDriver(
    IN  PCTSTR              DriverHwOrCompatId,
    IN  UINT                InfFieldIndex,
    IN  PDRVSEARCH_CONTEXT  Context
    );

BOOL
pSetupExcludeId(
    IN PSETUP_LOG_CONTEXT   LogContext,
    IN PLOADED_INF          Inf,
    IN PCTSTR               InfName,
    IN PCTSTR               InfSection,
    IN PDRVSEARCH_CONTEXT   Context
    );

PDRIVER_NODE
DuplicateDriverNode(
    IN PDRIVER_NODE DriverNode
    );

BOOL
ExtractDrvSearchInProgressNode(
    PDRVSEARCH_INPROGRESS_NODE Node
    );


//
// Define Flags(Ex) bitmask that are inherited along with a class driver list.
//
#define INHERITED_FLAGS   ( DI_ENUMSINGLEINF     \
                          | DI_DIDCLASS          \
                          | DI_MULTMFGS          \
                          | DI_COMPAT_FROM_CLASS )

#define INHERITED_FLAGSEX ( DI_FLAGSEX_DIDINFOLIST         \
                          | DI_FLAGSEX_FILTERCLASSES       \
                          | DI_FLAGSEX_USEOLDINFSEARCH     \
                          | DI_FLAGSEX_OLDINF_IN_CLASSLIST \
                          | DI_FLAGSEX_DRIVERLIST_FROM_URL \
                          | DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS \
                          | DI_FLAGSEX_FILTERSIMILARDRIVERS \
                          | DI_FLAGSEX_INSTALLEDDRIVER)

BOOL
WINAPI
SetupDiBuildDriverInfoList(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     DWORD            DriverType
    )
/*++

Routine Description:

    This routine builds a list of drivers associated with a specified device
    instance (or with the device information set's global class driver list).
    These drivers may be either class drivers or device drivers.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set that will
        contain the driver information list (either globally for all members,
        or specifically for a single member).

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device information element to build a driver list
        for.  If this parameter is NULL, then the list will be associated
        with the device information set itself, and not with any particular
        device information element.  This is only for driver lists of type
        SPDIT_CLASSDRIVER.

        If the class of this device is updated as a result of building a
        compatible driver list, then the ClassGuid field of this structure
        will be updated upon return.

    DriverType - Specifies what type of driver list should be built.  Must be
        one of the following values:

        SPDIT_CLASSDRIVER  -- Build a list of class drivers.
        SPDIT_COMPATDRIVER -- Build a list of compatible drivers for this device.
                              DeviceInfoData must be specified if this value is
                              used.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    After this API has built the specified driver list, its constituent elements
    may be enumerated via SetupDiEnumDriverInfo.

    If the driver list is associated with a device instance (i.e., DeviceInfoData
    is specified), the resulting list will be composed of drivers that have the
    same class as the device instance with which they are associated.  If this
    is a global class driver list (i.e., DriverType is SPDIT_CLASSDRIVER and
    DeviceInfoData is not specified), then the class that will be used in
    building the list will be the class associated with the device information
    set itself.  If there is no associated class, then drivers of all classes
    will be used in building the list.

    Another thread may abort the building of a driver list by calling
    SetupDiCancelDriverInfoSearch().

    Building a driver info list invalidates and merging it with an existing list
    (e.g., via the DI_FLAGSEX_APPENDDRIVERLIST flag) invalidates the drivernode
    enumeration hint for that driver list.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem = NULL;
    HWND hwndParent;
    PDWORD pFlags, pFlagsEx;
    PTSTR TempBuffer = NULL;  // also holds other strings, but this value is largest
    ULONG TempBufferLen;
    ULONG TempBufferSize = REGSTR_VAL_MAX_HCID_LEN;
    PTSTR InfPath = NULL;
    PDRVSEARCH_CONTEXT DrvSearchContext = NULL;
    LPGUID ClassGuid;
    PDRIVER_NODE DriverNode, NextDriverNode;
    LONG MfgNameId, InfPathId = -1;
    PDRIVER_LIST_OBJECT ClassDriverListObject = NULL;
    BOOL HasDrvSearchInProgressLock = FALSE;
    DRVSEARCH_INPROGRESS_NODE DrvSearchInProgressNode;
    BOOL PartialDrvListCleanUp = FALSE;
    HKEY hKey;
    BOOL AppendingDriverLists;
    DRVLIST_TO_APPEND DrvListToAppend;
    BOOL DriverNodeInsertedAtHead;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    HINSTANCE hInstanceCDM = NULL;
    HANDLE hCDMContext = NULL;
    HSPFILEQ UserFileQ;
    SPFUSIONINSTANCE spFusionInstance;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    DrvSearchInProgressNode.SearchCancelledEvent = NULL;
    hKey = INVALID_HANDLE_VALUE;
    AppendingDriverLists = FALSE;

    TempBuffer = MyMalloc(TempBufferSize*sizeof(TCHAR));
    if(!TempBuffer) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto final;
    }
    DrvSearchContext = MyMalloc(sizeof(DRVSEARCH_CONTEXT));
    if(!DrvSearchContext) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto final;
    }

    DrvSearchContext->StringTable = NULL;
    DrvSearchContext->Flags = 0;
    DrvSearchContext->hCatAdmin = NULL;

    Err = NO_ERROR;

    try {
        //
        // Build the driver list using a duplicate of the string table for the
        // device information set.  That way, if the driver search is cancelled
        // part-way through, we can restore the original string table, without
        // all the additional (unused) strings hanging around.
        //
        if(!(DrvSearchContext->StringTable = pStringTableDuplicate(pDeviceInfoSet->StringTable))) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Store the pointer to the devinfo set in the context structure.  We
        // need this, so that we can add INF class GUIDs to the set's GUID
        // table.
        //
        DrvSearchContext->DeviceInfoSet = pDeviceInfoSet;

        if(DeviceInfoData) {
            //
            // Then we're working with a driver list for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        } else {

            //
            // If the caller did not pass in a DeviceInfoData then we can't get
            // the currently installed driver since we don't know the device.
            //
            if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_INSTALLEDDRIVER) {

                Err = ERROR_INVALID_FLAGS;
                goto clean0;
            }
        }

        LogContext = DevInfoElem ?
                            DevInfoElem->InstallParamBlock.LogContext :
                            pDeviceInfoSet->InstallParamBlock.LogContext;

        SetLogSectionName(LogContext, TEXT("Driver Install"));

        //
        // Now, fill in the rest of our context structure based on what type of
        // driver list we're creating.
        //
        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    //
                    // Retrieve the list for a particular device.
                    //
                    if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {

                        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST) {

                            AppendingDriverLists = TRUE;

                            //
                            // Merging a new driver list into an existing list
                            // invalidates our drivernode enumeration hint.
                            //
                            DevInfoElem->ClassDriverEnumHint = NULL;
                            DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                        } else {
                            //
                            // We already have a driver list, and we've not
                            // been asked to append to it, so we're done.
                            //
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't have a class driver list--we'd better not
                        // have a drivernode enumeration hint.
                        //
                        MYASSERT(DevInfoElem->ClassDriverEnumHint == NULL);
                        MYASSERT(DevInfoElem->ClassDriverEnumHintIndex == INVALID_ENUM_INDEX);

                        DrvSearchContext->pDriverListHead = &(DevInfoElem->ClassDriverHead);
                        DrvSearchContext->pDriverListTail = &(DevInfoElem->ClassDriverTail);
                        DrvSearchContext->pDriverCount    = &(DevInfoElem->ClassDriverCount);
                    }

                    pFlags   = &(DevInfoElem->InstallParamBlock.Flags);
                    pFlagsEx = &(DevInfoElem->InstallParamBlock.FlagsEx);

                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;

                    ClassGuid = &(DevInfoElem->ClassGuid);
                    InfPathId = DevInfoElem->InstallParamBlock.DriverPath;

                    //
                    // Retrieve the list of Hardware IDs (index 0) and
                    // Compatible IDs (index 1) from the device's registry properties.
                    //
                    if (!pSetupFillInHardwareAndCompatIds(DevInfoElem,
                                                          pDeviceInfoSet->hMachine,
                                                          DrvSearchContext,
                                                          LogContext
                                                          )) {
                        goto clean0;
                    }

                    //
                    // Set DRVSRCH_FILTERSIMILARDRIVERS flag if the
                    // DI_FLAGSEX_FILTERSIMILARDRIVERS FlagsEx is set.  This will
                    // cause us only to add 'similar' drivers to the class list.  A
                    // 'similar' driver is one where one of the hardware or
                    // compatible Ids in the INF partially match one of the
                    // hardware or compatible Ids of the hardware.
                    //
                    if (*pFlagsEx & DI_FLAGSEX_FILTERSIMILARDRIVERS) {

                        DrvSearchContext->Flags |= DRVSRCH_FILTERSIMILARDRIVERS;

                        //
                        // If no hardware id or compatible ids found, nothing is compatible.
                        //
                        if ((DrvSearchContext->IdList[0][0] == -1) &&
                            (DrvSearchContext->IdList[1][0] == -1)) {

                            goto clean1;
                        }
                    }

                } else {
                    //
                    // Retrieve the list for the device information set itself (globally)
                    //
                    if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {

                        if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST) {

                            AppendingDriverLists = TRUE;

                            //
                            // Merging a new driver list into an existing list
                            // invalidates our drivernode enumeration hint.
                            //
                            pDeviceInfoSet->ClassDriverEnumHint = NULL;
                            pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                        } else {
                            //
                            // We already have a driver list, and we've not been asked to append
                            // to it, so we're done.
                            //
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't have a class driver list--we'd better not
                        // have a drivernode enumeration hint.
                        //
                        MYASSERT(pDeviceInfoSet->ClassDriverEnumHint == NULL);
                        MYASSERT(pDeviceInfoSet->ClassDriverEnumHintIndex == INVALID_ENUM_INDEX);

                        DrvSearchContext->pDriverListHead = &(pDeviceInfoSet->ClassDriverHead);
                        DrvSearchContext->pDriverListTail = &(pDeviceInfoSet->ClassDriverTail);
                        DrvSearchContext->pDriverCount    = &(pDeviceInfoSet->ClassDriverCount);
                    }

                    pFlags   = &(pDeviceInfoSet->InstallParamBlock.Flags);
                    pFlagsEx = &(pDeviceInfoSet->InstallParamBlock.FlagsEx);

                    UserFileQ = pDeviceInfoSet->InstallParamBlock.UserFileQ;

                    ClassGuid = &(pDeviceInfoSet->ClassGuid);
                    InfPathId = pDeviceInfoSet->InstallParamBlock.DriverPath;
                }

                if(AppendingDriverLists) {
                    ZeroMemory(&DrvListToAppend, sizeof(DrvListToAppend));
                    DrvSearchContext->pDriverListHead = &(DrvListToAppend.DriverHead);
                    DrvSearchContext->pDriverListTail = &(DrvListToAppend.DriverTail);
                    DrvSearchContext->pDriverCount    = &(DrvListToAppend.DriverCount);
                }

                DrvSearchContext->BuildClassDrvList = TRUE;

                //
                // Class driver lists are always filtered on class.
                //
                DrvSearchContext->Flags |= DRVSRCH_FILTERCLASS;

                //
                // Set the DRVSRCH_NO_CLASSLIST_NODE_MERGE flag in the DrvSearchContext
                // if the caller set the DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE.  If this
                // flag is set then we will not remove/merge identical driver nodes.
                //
                if (*pFlagsEx & DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE) {

                    DrvSearchContext->Flags |= DRVSRCH_NO_CLASSLIST_NODE_MERGE;
                }

                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {

                    if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO) {

                        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST) {

                            AppendingDriverLists = TRUE;

                            //
                            // Merging a new driver list into an existing list
                            // invalidates our drivernode enumeration hint.
                            //
                            DevInfoElem->CompatDriverEnumHint = NULL;
                            DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

                        } else {
                            //
                            // We already have a driver list, and we've not been asked to append
                            // to it, so we're done.
                            //
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't have a compatible driver list--we'd better
                        // not have a drivernode enumeration hint.
                        //
                        MYASSERT(DevInfoElem->CompatDriverEnumHint == NULL);
                        MYASSERT(DevInfoElem->CompatDriverEnumHintIndex == INVALID_ENUM_INDEX);
                    }

                    //
                    // NOTE: The following variables must be set before retrieving the
                    // hardware/compatible ID lists, as execution may transfer to the
                    // 'clean1' label, that relies on these values.
                    //
                    pFlags   = &(DevInfoElem->InstallParamBlock.Flags);
                    pFlagsEx = &(DevInfoElem->InstallParamBlock.FlagsEx);

                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;

                    DrvSearchContext->BuildClassDrvList = FALSE;

                    //
                    // We're building a compatible driver list--retrieve the list of Hardware IDs
                    // (index 0) and Compatible IDs (index 1) from the device's registry properties.
                    //
                    if (!pSetupFillInHardwareAndCompatIds(DevInfoElem,
                                                          pDeviceInfoSet->hMachine,
                                                          DrvSearchContext,
                                                          LogContext
                                                          )) {
                        goto clean0;
                    }

                    //
                    // If no hardware id or compatible ids found, nothing is compatible.
                    //
                    if ((DrvSearchContext->IdList[0][0] == -1) &&
                        (DrvSearchContext->IdList[1][0] == -1)) {

                        goto clean1;
                    }

                    //
                    // Compatible driver lists are filtered on class only if the
                    // DI_FLAGSEX_USECLASSFORCOMPAT flag is set.
                    //
                    DrvSearchContext->Flags |= (*pFlagsEx & DI_FLAGSEX_USECLASSFORCOMPAT)
                                                 ? DRVSRCH_FILTERCLASS : 0;

                    ClassGuid = &(DevInfoElem->ClassGuid);

                    if(AppendingDriverLists) {
                        ZeroMemory(&DrvListToAppend, sizeof(DrvListToAppend));
                        DrvSearchContext->pDriverListHead   = &(DrvListToAppend.DriverHead);
                        DrvSearchContext->pDriverListTail   = &(DrvListToAppend.DriverTail);
                        DrvSearchContext->pDriverCount      = &(DrvListToAppend.DriverCount);
                    } else {
                        DrvSearchContext->pDriverListHead   = &(DevInfoElem->CompatDriverHead);
                        DrvSearchContext->pDriverListTail   = &(DevInfoElem->CompatDriverTail);
                        DrvSearchContext->pDriverCount      = &(DevInfoElem->CompatDriverCount);
                    }

                    if(*pFlags & DI_COMPAT_FROM_CLASS) {

                        PDRIVER_LIST_OBJECT TempDriverListObject;

                        //
                        // The caller wants to build the compatible driver list based on an
                        // existing class driver list--first make sure that there _is_ a class
                        // driver list.
                        //
                        if(!(*pFlagsEx & DI_FLAGSEX_DIDINFOLIST)) {
                            Err = ERROR_NO_CLASS_DRIVER_LIST;
                            goto clean0;
                        } else if(!(DevInfoElem->ClassDriverHead)) {
                            //
                            // Then the class driver list is empty.  There's no need to do
                            // any more work, just say that we succeeded.
                            //
                            Err = NO_ERROR;
                            goto clean1;
                        }

                        //
                        // When we're building a compatible driver list from an existing class
                        // driver list, we don't do any checking on INF class (i.e., to update
                        // the device's class if the most-compatible driver is of a different
                        // device class).  Because of this, we must ensure that (a) the class
                        // driver list was built for a particular class, and that (b) that class
                        // matches the current class for this device.
                        //
                        TempDriverListObject = GetAssociatedDriverListObject(
                                                   pDeviceInfoSet->ClassDrvListObjectList,
                                                   DevInfoElem->ClassDriverHead,
                                                   NULL
                                                  );

                        MYASSERT(TempDriverListObject);

                        //
                        // Everything's in order--go search through the existing
                        // class driver list for compatible drivers.
                        //
                        if((Err = BuildCompatListFromClassList(DevInfoElem->ClassDriverHead,
                                                               DrvSearchContext)) == NO_ERROR) {
                            goto clean2;
                        } else {
                            goto clean0;
                        }

                    } else {
                        InfPathId = DevInfoElem->InstallParamBlock.DriverPath;
                    }

                    break;
                }
                //
                // If no device instance specified, let fall through to error.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        if(IsEqualGUID(ClassGuid, &GUID_NULL)) {
            //
            // If there is no class GUID, then don't try to filter on it.
            //
            DrvSearchContext->Flags &= ~DRVSRCH_FILTERCLASS;
        } else {
            //
            // Copy the class GUID to the ClassGuid field in our context structure.
            //
            CopyMemory(&(DrvSearchContext->ClassGuid),
                       ClassGuid,
                       sizeof(GUID)
                      );
            DrvSearchContext->Flags |= DRVSRCH_HASCLASSGUID;

            //
            // If we are building a class list, and filtering is requested,
            // then make sure that the class doesn't have NoUseClass value
            // entries in its registry key.
            //
            // Also exclude NoInstallClass unless the
            // DI_FLAGSEX_ALLOWEXCLUDEDDRVS flag is set.
            //
            if(DrvSearchContext->BuildClassDrvList &&
               (*pFlagsEx & DI_FLAGSEX_FILTERCLASSES)) {

                if(ShouldClassBeExcluded(&(DrvSearchContext->ClassGuid), !(*pFlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

                    //
                    // If the class has been filtered out, simply return success.
                    //
                    goto clean1;
                }
            }

            //
            // If we're going to be filtering on this class, then store its
            // string representation in the context structure as well, as an
            // optimization for PreprocessInf().
            //
            if(DrvSearchContext->Flags & DRVSRCH_FILTERCLASS) {
                pSetupStringFromGuid(ClassGuid,
                                     DrvSearchContext->ClassGuidString,
                                     SIZECHARS(DrvSearchContext->ClassGuidString)
                                    );
            }
        }

        //
        // If we're supposed to do our driver search based on an alternate
        // (i.e., non-native) platform, then store that information away in our
        // context structure.
        //
        if(*pFlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {
            //
            // We must have a user-supplied file queue.
            //
            MYASSERT(*pFlags & DI_NOVCP);
            MYASSERT(UserFileQ && (UserFileQ != INVALID_HANDLE_VALUE));

            if((((PSP_FILE_QUEUE)UserFileQ)->Signature != SP_FILE_QUEUE_SIG) ||
               !(((PSP_FILE_QUEUE)UserFileQ)->Flags & FQF_USE_ALT_PLATFORM)) {

                Err = ERROR_INVALID_PARAMETER;

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_WARNING,
                    MSG_LOG_NO_QUEUE_FOR_ALTPLATFORM_DRVSEARCH,
                    NULL
                   );

                goto clean0;
            }

            DrvSearchContext->AltPlatformInfo =
                &(((PSP_FILE_QUEUE)UserFileQ)->AltPlatformInfo);

        } else {
            //
            // We're not doing a non-native driver search...
            //
            DrvSearchContext->AltPlatformInfo = NULL;
        }

        if(DrvSearchContext->BuildClassDrvList) {
            //
            // Allocate a new driver list object to store the class driver list in once
            // we've created it.  (Don't do this if we're appending driver lists.)
            //
            if(!AppendingDriverLists) {
                if(!(ClassDriverListObject = MyMalloc(sizeof(DRIVER_LIST_OBJECT)))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            //
            // If the user wants to allow legacy INFs to be searched, then we need to
            // figure out what the legacy option name is.
            //
            if(*pFlagsEx & DI_FLAGSEX_OLDINF_IN_CLASSLIST) {

                DWORD RegDataType, RegDataSize;

                //
                // Don't allow this if we don't know what class we're building the list for.
                //
                if(!(DrvSearchContext->Flags & DRVSRCH_FILTERCLASS)) {
                    Err = ERROR_NO_ASSOCIATED_CLASS;
                    goto clean0;
                }

                //
                // Check to see if there's a legacy INF option name translation stored in
                // the class key for this class.
                //
                *DrvSearchContext->LegacyClassName = TEXT('\0');

                if((hKey = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) != INVALID_HANDLE_VALUE) {

                    RegDataSize = sizeof(DrvSearchContext->LegacyClassName);
                    if((RegQueryValueEx(hKey,
                                        pszLegacyInfOption,
                                        NULL,
                                        &RegDataType,
                                        (PBYTE)DrvSearchContext->LegacyClassName,
                                        &RegDataSize) != ERROR_SUCCESS) ||
                       (RegDataType != REG_SZ) || (RegDataSize < sizeof(TCHAR))) {
                        //
                        // No luck finding a legacy option name translation--make sure
                        // this string is still empty.
                        //
                        *DrvSearchContext->LegacyClassName = TEXT('\0');
                    }

                    RegCloseKey(hKey);
                    hKey = INVALID_HANDLE_VALUE;
                }

                if(!(*DrvSearchContext->LegacyClassName)) {
                    //
                    // We didn't find a translation for the option, so assume it's the
                    // same as its Plug&Play class name.
                    //
                    if(!SetupDiClassNameFromGuid(ClassGuid,
                                                 DrvSearchContext->LegacyClassName,
                                                 SIZECHARS(DrvSearchContext->LegacyClassName),
                                                 NULL)) {
                        //
                        // We can't get the name of this class--maybe it's not installed.  In
                        // any event, we can't proceed without this information.
                        //
                        Err = ERROR_INVALID_CLASS;
                        goto clean0;
                    }
                }

                LoadString(MyDllModuleHandle,
                           IDS_LEGACYINFLANG,
                           DrvSearchContext->LegacyClassLang,
                           SIZECHARS(DrvSearchContext->LegacyClassLang)
                          );

                DrvSearchContext->Flags |= DRVSRCH_USEOLDINFS;
            }
        }

        //
        // Only include ExcludeFromSelect devices and NoInstallClass classes
        // if the DI_FLAGSEX_ALLOWEXCLUDEDDRVS flag is set.
        //
        if (*pFlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS) {

            DrvSearchContext->Flags |= DRVSRCH_ALLOWEXCLUDEDDRVS;
        }

        //
        // If the caller just wants us to get the currently installed driver then
        // we need to get the INF path of the currently installed driver.
        //
        if (*pFlagsEx & DI_FLAGSEX_INSTALLEDDRIVER) {

            DrvSearchContext->Flags |= DRVSRCH_INSTALLEDDRIVER;

            InfPathId = pSetupGetInstalledDriverInfo(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     DrvSearchContext
                                                     );

            //
            // If the InfPathId is -1 then we were unable to get the InfPath
            // for this device.  This is most likely because this is a new
            // device or the device doesn't currently have a driver installed
            // on it.  In any case there is nothing to do here so just return
            // success.
            //
            if (InfPathId == -1) {
                Err = NO_ERROR;
                goto clean1;
            }
        }

        //
        // Set up a "Driver Search In-Progress" node in the global list, that will be
        // used in case some other thread wants us to abort part-way through.
        //
        if(LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {

            HasDrvSearchInProgressLock = TRUE;

            if(DrvSearchInProgressNode.SearchCancelledEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) {
                DrvSearchInProgressNode.CancelSearch = FALSE;
                DrvSearchInProgressNode.DeviceInfoSet = DeviceInfoSet;
                DrvSearchInProgressNode.Next = GlobalDrvSearchInProgressList.DrvSearchHead;
                GlobalDrvSearchInProgressList.DrvSearchHead = &DrvSearchInProgressNode;
                Err = NO_ERROR;
            } else {
                Err = GetLastError();
            }

            UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);
            HasDrvSearchInProgressLock = FALSE;

            if(Err != NO_ERROR) {
                goto clean0;
            }

        } else {
            //
            // The only reason this should happen is if we're in the middle of DLL_PROCESS_DETACH,
            // and the list has already been destroyed.
            //
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        //
        // Now store away a pointer to the 'CancelSearch' flag in our context structure, so that
        // we can check it periodically while building the driver list (specifically, we check it
        // before examining each INF).
        //
        DrvSearchContext->CancelSearch = &(DrvSearchInProgressNode.CancelSearch);

        PartialDrvListCleanUp = TRUE;   // after this point, clean-up is necessary upon exception.

        //
        // First see if we need to get the driver package from the Internet
        //
        if (*pFlagsEx & DI_FLAGSEX_DRIVERLIST_FROM_URL) {

#ifdef UNICODE

            //
            // Currently this is not supported, but in the future we might allow
            // alternate Internet servers were users can get driver updates.
            //
            if (InfPathId != -1) {

                //
                // No InfPath was specified so we will go to the Microsoft Windows
                // Update server.
                //
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;

            } else {

                OSVERSIONINFOEX info;
                DOWNLOADINFO DownloadInfo;
                TCHAR CDMPath[MAX_PATH];
                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
                ULONG BufferLen;
                OPEN_CDM_CONTEXT_PROC pfnOpenCDMContext;
                CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;
                DOWNLOAD_UPDATED_FILES_PROC pfnDownloadUpdatedFiles;

                //
                // Search Windows Update for all SKUs except datacenter.
                //
                info.dwOSVersionInfoSize = sizeof(info);
                if (GetVersionEx((POSVERSIONINFOW)&info) &&
                    !(info.wSuiteMask & VER_SUITE_DATACENTER)) {

                    spFusionEnterContext(NULL,&spFusionInstance);
    
                    if(hInstanceCDM = LoadLibrary(TEXT("CDM.DLL"))) {
    
                        if((pfnOpenCDMContext =
                            (OPEN_CDM_CONTEXT_PROC)GetProcAddress(hInstanceCDM, "OpenCDMContext")) &&
                           (pfnCloseCDMContext =
                            (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hInstanceCDM, "CloseCDMContext")) &&
                           (pfnDownloadUpdatedFiles =
                            (DOWNLOAD_UPDATED_FILES_PROC)GetProcAddress(hInstanceCDM, "DownloadUpdatedFiles"))) {
    
                            if (hCDMContext = pfnOpenCDMContext(DevInfoElem->InstallParamBlock.hwndParent)) {
    
                                //
                                // Fill In the DOWNLOADINFO structure to pass to CDM.DLL
                                //
                                ZeroMemory(&DownloadInfo, sizeof(DOWNLOADINFO));
                                DownloadInfo.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
                                DownloadInfo.lpFile = NULL;
    
                                if(CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                                                    DeviceInstanceId,
                                                    sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                                    0,
                                                    pDeviceInfoSet->hMachine
                                                    ) != CR_SUCCESS) {
                                    //
                                    // This should never happen!
                                    //
                                    Err = ERROR_NO_SUCH_DEVINST;
                                } else {
                                    DownloadInfo.lpDeviceInstanceID = (LPCWSTR)DeviceInstanceId;
    
    
                                    GetVersionEx((OSVERSIONINFOW *)&DownloadInfo.OSVersionInfo);
    
                                    //
                                    // Set dwArchitecture to PROCESSOR_ARCHITECTURE_UNKNOWN, this
                                    // causes Windows Update to check get the architecture of the
                                    // machine itself.  You only need to explictly set the value if
                                    // you want to download drivers for a different architecture then
                                    // the machine this is running on.
                                    //
                                    DownloadInfo.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
                                    DownloadInfo.dwFlags = 0;
                                    DownloadInfo.dwClientID = 0;
                                    DownloadInfo.localid = 0;
    
                                    CDMPath[0] = TEXT('\0');
    
                                    //
                                    // Tell CDM.DLL to download any driver packages it has that match the
                                    // Hardware or Compatible IDs for this device.
                                    //
                                    if ((pfnDownloadUpdatedFiles(hCDMContext,
                                                                DevInfoElem->InstallParamBlock.hwndParent,
                                                                &DownloadInfo,
                                                                CDMPath,
                                                                sizeof(CDMPath),
                                                                &BufferLen)) &&
    
                                        (CDMPath[0] != TEXT('\0'))) {
    
                                        //
                                        // Windows Update found a driver package so enumerate all of
                                        // the INFs in the specified directory
                                        //
                                        DrvSearchContext->Flags |= (DRVSRCH_FROM_INET | DRVSRCH_CLEANUP_SOURCE_PATH);
    
                                        spFusionLeaveContext(&spFusionInstance);
                                        Err = EnumDrvInfsInDirPathList(CDMPath,
                                                                    INFINFO_INF_PATH_LIST_SEARCH,
                                                                    DrvSearchCallback,
                                                                    TRUE,
                                                                    LogContext,
                                                                    (PVOID)DrvSearchContext
                                                                   );
                                        spFusionEnterContext(NULL,&spFusionInstance);
                                    }
                                }
                                pfnCloseCDMContext(hCDMContext);
                                hCDMContext = NULL;
                            }
                        }
    
                        FreeLibrary(hInstanceCDM);
                        hInstanceCDM = NULL;
                    }
                    spFusionLeaveContext(&spFusionInstance);
                }
            }



#else
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
#endif
        }

        //
        // Now, retrieve the driver list.
        //
        else if((*pFlagsEx & DI_FLAGSEX_USEOLDINFSEARCH) || (InfPathId != -1)) {

            //
            // If this driver came from the Internet then set the
            // DRVSRCH_FROM_INET flag
            //
            if (*pFlagsEx & DI_FLAGSEX_INET_DRIVER) {

                DrvSearchContext->Flags |= DRVSRCH_FROM_INET;
            }

            InfPath = pStringTableStringFromId(DrvSearchContext->StringTable,
                                               InfPathId
                                               );


            if((*pFlags & DI_ENUMSINGLEINF) ||
               (*pFlagsEx & DI_FLAGSEX_INSTALLEDDRIVER)) {
                if(InfPath) {

                    Err = NO_ERROR;

                    if(InfPath == pSetupGetFileTitle(InfPath)) {
                        //
                        // The specified INF path is a simple filename.
                        // Search for it in the directories listed in the
                        // DevicePath search list.  The most likely scenario
                        // here is that the caller is trying to build a driver
                        // list based on the INF used previously to install
                        // the device.  In that case, they would've retrieved
                        // the InfPath value from the device's driver key, and
                        // this value is a simple filename.  INFs are always
                        // placed into the Inf directory when they're used to
                        // install a device, so the only valid place to look for
                        // this INF is in %windir%\Inf.
                        //
                        lstrcpyn(TempBuffer, InfDirectory,TempBufferSize);
                        pSetupConcatenatePaths(TempBuffer,
                                         InfPath,
                                         TempBufferSize,
                                         NULL
                                        );

                        DrvSearchContext->Flags |= DRVSRCH_TRY_PNF;

                    } else {

                        PTSTR DontCare;

                        //
                        // The specified INF filename contains more than just
                        // a filename.  Assume it's an absolute path.
                        //
                        // (We need to get the fully-qualified form of this path,
                        // because that's what EnumSingleDrvInf expects.)
                        //
                        TempBufferLen = GetFullPathName(InfPath,
                                                        TempBufferSize,
                                                        TempBuffer,
                                                        &DontCare
                                                       );

                        if(!TempBufferLen) {
                            Err = GetLastError();
                        } else if(TempBufferLen >= TempBufferSize) {
                            MYASSERT(0);
                            Err = ERROR_BUFFER_OVERFLOW;
                        }
                    }

                    if(Err == NO_ERROR) {

                        WIN32_FIND_DATA InfFileData;

                        if (FileExists(TempBuffer, &InfFileData)) {

                            Err = EnumSingleDrvInf(TempBuffer,
                                                &InfFileData,
                                                INFINFO_INF_NAME_IS_ABSOLUTE,
                                                DrvSearchCallback,
                                                LogContext,
                                                (PVOID)DrvSearchContext
                                               );
                        } else {
                            Err = GetLastError();
                        }
                    }

                } else {
                    Err = ERROR_NO_INF;
                }

            } else {
                Err = EnumDrvInfsInDirPathList(InfPath,
                                            INFINFO_INF_PATH_LIST_SEARCH,
                                            DrvSearchCallback,
                                            TRUE,
                                            LogContext,
                                            (PVOID)DrvSearchContext
                                           );
            }

        } else {
            //
            // On Win95, this code path uses an INF index scheme.  Since the Setup APIs
            // utilize precompiled INFs instead, this 'else' clause is really no different
            // than the 'if' part.  However, if in the future we decide to do indexing a`la
            // Win95, then this is the place where we'd put a call such as:
            //
            // Err = BuildDrvListFromInfIndex();
            //
            DrvSearchContext->Flags |= DRVSRCH_TRY_PNF;

            //
            // If the caller wants to exclude existing (old) Internet
            // drivers then set the DRVSRCH_EXCLUDE_OLD_INET_DRIVERS flag.
            //
            if (*pFlagsEx & DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS) {

                DrvSearchContext->Flags |= DRVSRCH_EXCLUDE_OLD_INET_DRIVERS;
            }

            Err = EnumDrvInfsInDirPathList(NULL,
                                        INFINFO_INF_PATH_LIST_SEARCH,
                                        DrvSearchCallback,
                                        TRUE,
                                        LogContext,
                                        (PVOID)DrvSearchContext
                                       );
        }

        //
        // Extract our node from the "Driver Search In-Progress" list, and signal the waiting
        // threads if an abort is pending.
        //
        if(ExtractDrvSearchInProgressNode(&DrvSearchInProgressNode)) {
            Err = ERROR_CANCELLED;
        }

        if(Err != NO_ERROR) {

            if(Err == ERROR_CANCELLED) {
                //
                // Clean up the partial list we built.
                //
                DestroyDriverNodes(*(DrvSearchContext->pDriverListHead), pDeviceInfoSet);
                *(DrvSearchContext->pDriverListHead) = *(DrvSearchContext->pDriverListTail) = NULL;
                *(DrvSearchContext->pDriverCount) = 0;
            }

            goto clean0;
        }

clean2:
        if(DrvSearchContext->BuildClassDrvList) {

            if(AppendingDriverLists) {

                DriverNode = *(DrvSearchContext->pDriverListHead);

                //
                // Now 'fix up' the driver search context so that it points to the
                // real class list fields.  That way when we merge the new driver nodes
                // into the list, everything will be updated properly.
                //
                if(DevInfoElem) {
                    DrvSearchContext->pDriverListHead = &(DevInfoElem->ClassDriverHead);
                    DrvSearchContext->pDriverListTail = &(DevInfoElem->ClassDriverTail);
                    DrvSearchContext->pDriverCount    = &(DevInfoElem->ClassDriverCount);
                } else {
                    DrvSearchContext->pDriverListHead = &(pDeviceInfoSet->ClassDriverHead);
                    DrvSearchContext->pDriverListTail = &(pDeviceInfoSet->ClassDriverTail);
                    DrvSearchContext->pDriverCount    = &(pDeviceInfoSet->ClassDriverCount);
                }

                //
                // Merge our newly-built driver list with the already-existing one.
                //
                while(DriverNode) {
                    //
                    // Store a pointer to the next driver node before merging, because
                    // the driver node we're working with may be destroyed because it's
                    // a duplicate of a driver node already in the list.
                    //
                    NextDriverNode = DriverNode->Next;
                    pSetupMergeDriverNode(DrvSearchContext, DriverNode, &DriverNodeInsertedAtHead);
                    DriverNode = NextDriverNode;
                }
            }

            if(DriverNode = *(DrvSearchContext->pDriverListHead)) {
                //
                // Look through the class driver list we just built, and see if
                // all drivers are from the same manufacturer.  If not, set the
                // DI_MULTMFGS flag.
                //
                MfgNameId = DriverNode->MfgName;

                for(DriverNode = DriverNode->Next;
                    DriverNode;
                    DriverNode = DriverNode->Next) {

                    if(DriverNode->MfgName != MfgNameId) {
                        *pFlags |= DI_MULTMFGS;
                        break;
                    }
                }
            }

        } else {

            if(AppendingDriverLists) {

                DriverNode = *(DrvSearchContext->pDriverListHead);

                //
                // Now 'fix up' the driver search context so that it points to the
                // real compatible list fields.
                //
                DrvSearchContext->pDriverListHead = &(DevInfoElem->CompatDriverHead);
                DrvSearchContext->pDriverListTail = &(DevInfoElem->CompatDriverTail);
                DrvSearchContext->pDriverCount    = &(DevInfoElem->CompatDriverCount);

                //
                // Check the rank of the best-matching driver node in our new list, and see
                // if it's better than the one at the front of the previously-existing list.
                // If so, then we'll want to update the class of this devinfo element to reflect
                // this new class.
                //
                if(DriverNode && DrvSearchContext->Flags & DRVSRCH_HASCLASSGUID) {

                    if(DevInfoElem->CompatDriverHead &&
                       (DriverNode->Rank >= DevInfoElem->CompatDriverHead->Rank)) {
                        //
                        // There was already a compatible driver with a better rank match
                        // in the list, so don't update the class.
                        //
                        DrvSearchContext->Flags &= ~DRVSRCH_HASCLASSGUID;

                    } else {
                        //
                        // The head of the new driver list is a better match than any of the
                        // entries in the existing list.  Make sure that the class of this new
                        // driver node 'fits' into the devinfo set/element.  (We do this before
                        // the actual list merging, so that we don't mess up the original list
                        // in case of error).
                        //
                        if(pDeviceInfoSet->HasClassGuid &&
                           !IsEqualGUID(ClassGuid, &(DrvSearchContext->ClassGuid))) {

                            Err = ERROR_CLASS_MISMATCH;

                            //
                            // Clean up the partial list we built.
                            //
                            DestroyDriverNodes(DriverNode, pDeviceInfoSet);

                            goto clean0;
                        }
                    }
                }

                //
                // OK, if we get to here, then it's safe to go ahead and merge the new compatible
                // driver list in with our existing one.
                //
                while(DriverNode) {
                    //
                    // Store a pointer to the next driver node before merging, because
                    // the driver node we're working with may be destroyed because it's
                    // a duplicate of a driver node already in the list.
                    //
                    NextDriverNode = DriverNode->Next;
                    pSetupMergeDriverNode(DrvSearchContext, DriverNode, &DriverNodeInsertedAtHead);
                    DriverNode = NextDriverNode;
                }
            }

            //
            // Update the class of the device information element based on the
            // class of the most-compatible driver node we retrieved.  Don't do
            // this, however, if the device already has a selected driver.
            //
            if(!DevInfoElem->SelectedDriver &&
               (DrvSearchContext->Flags & DRVSRCH_HASCLASSGUID) &&
               !IsEqualGUID(ClassGuid, &(DrvSearchContext->ClassGuid))) {
                //
                // The class GUID for this device has changed.  We need to make sure
                // that the devinfo set doesn't have an associated class.  Otherwise,
                // we will introduce an inconsistency into the set, where a device
                // contained in the set is of a different class than the set itself.
                //
                if(pDeviceInfoSet->HasClassGuid) {
                    Err = ERROR_CLASS_MISMATCH;
                } else {
                    Err = InvalidateHelperModules(DeviceInfoSet, DeviceInfoData, 0);
                }

                if(Err != NO_ERROR) {
                    //
                    // Clean up the partial list we built.
                    //
                    DestroyDriverNodes(*(DrvSearchContext->pDriverListHead), pDeviceInfoSet);
                    *(DrvSearchContext->pDriverListHead) = *(DrvSearchContext->pDriverListTail) = NULL;
                    *(DrvSearchContext->pDriverCount) = 0;

                    goto clean0;
                }

                //
                // We need to clean up any existing software keys associated with this
                // device instance before changing its class, or otherwise we'll have
                // orphaned registry keys.
                //
                pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                       DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                                       (DWORD)-1,
                                       DIREG_DRV,
                                       TRUE
                                      );
                //
                // Now delete the Driver property for this device.
                //
                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_DRIVER,
                                                 NULL,
                                                 0,
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                //
                // Update the device's class GUID, and also update the caller-supplied
                // SP_DEVINFO_DATA structure to reflect the device's new class.
                //
                CopyMemory(ClassGuid,
                           &(DrvSearchContext->ClassGuid),
                           sizeof(GUID)
                          );

                CopyMemory(&(DeviceInfoData->ClassGuid),
                           &(DrvSearchContext->ClassGuid),
                           sizeof(GUID)
                          );

                //
                // Finally, update the device's ClassGUID registry property.  Also, if the
                // INF specified a class name, update that too, since this may be a class
                // that hasn't yet been installed, thus no class name would be known.
                //
                pSetupStringFromGuid(ClassGuid, TempBuffer, TempBufferSize);
                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_CLASSGUID,
                                                 (PVOID)TempBuffer,
                                                 GUID_STRING_LEN * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                if(*DrvSearchContext->ClassName) {

                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CM_DRP_CLASS,
                                                     (PBYTE)DrvSearchContext->ClassName,
                                                     (lstrlen(DrvSearchContext->ClassName) + 1) * sizeof(TCHAR),
                                                     0,
                                                     pDeviceInfoSet->hMachine);
                }
            }
        }

clean1:
        //
        // Replace our existing string table with the new one containing the additional strings
        // used by the new driver nodes.
        //
        pStringTableDestroy(pDeviceInfoSet->StringTable);
        pDeviceInfoSet->StringTable = DrvSearchContext->StringTable;
        DrvSearchContext->StringTable = NULL;

        //
        // Set the flags to indicate that the driver list was built successfully.
        //
        *pFlagsEx |= (DriverType == SPDIT_CLASSDRIVER) ? DI_FLAGSEX_DIDINFOLIST
                                                       : DI_FLAGSEX_DIDCOMPATINFO;
        //
        // Since we aren't using partial information via a separate index, we build
        // the driver list with both basic and detailed information.
        //
        // NOTE:  If we ever use indexing like Win95, then the following flags should
        //        no longer be set here, and should only be set when the detailed
        //        driver information is actually retrieved from the INF.
        //
        *pFlags |= (DriverType == SPDIT_CLASSDRIVER) ? DI_DIDCLASS
                                                     : DI_DIDCOMPAT;

        //
        // If we built a non-empty class driver list, then create a driver list object
        // for it, and store it in the device information set's list of class driver lists.
        // (Don't worry that we're ignoring this if the list is empty--the memory allocated
        // for ClassDriverListObject will get cleaned up later.)
        //
        // (If we're merely appending to an existing class driver list, then don't create
        // a new driver list object.)
        //
        if(DrvSearchContext->BuildClassDrvList && !AppendingDriverLists &&
           (DriverNode = *(DrvSearchContext->pDriverListHead))) {

            ClassDriverListObject->RefCount = 1;
            ClassDriverListObject->ListCreationFlags   = *pFlags & INHERITED_FLAGS;
            ClassDriverListObject->ListCreationFlagsEx = *pFlagsEx & INHERITED_FLAGSEX;
            ClassDriverListObject->ListCreationDriverPath = InfPathId;
            ClassDriverListObject->DriverListHead = DriverNode;

            CopyMemory(&(ClassDriverListObject->ClassGuid), ClassGuid, sizeof(GUID));

            //
            // Now add this to the devinfo set's list, and clear the pointer, so that we won't
            // try to free it.
            //
            ClassDriverListObject->Next = pDeviceInfoSet->ClassDrvListObjectList;
            pDeviceInfoSet->ClassDrvListObjectList = ClassDriverListObject;

            ClassDriverListObject = NULL;
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Err = ERROR_INVALID_PARAMETER;

        if(HasDrvSearchInProgressLock) {
            UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);
        }

        ExtractDrvSearchInProgressNode(&DrvSearchInProgressNode);

        //
        // Clean up any driver nodes we may have created.
        //
        if(PartialDrvListCleanUp) {
            DestroyDriverNodes(*(DrvSearchContext->pDriverListHead), pDeviceInfoSet);
            *(DrvSearchContext->pDriverListHead) = *(DrvSearchContext->pDriverListTail) = NULL;
            *(DrvSearchContext->pDriverCount) = 0;
            //
            // Clean up any flags that may have been set.
            //
            if(!AppendingDriverLists && pFlags && pFlagsEx) {
                if(DriverType == SPDIT_CLASSDRIVER) {
                    *pFlags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                    *pFlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
                } else {
                    *pFlags   &= ~DI_DIDCOMPAT;
                    *pFlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;
                }
            }
        }

        if(hKey != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKey);
        }

        //
        // Access the following variables so that the compiler will respect our statement ordering
        // w.r.t. these values.
        //
        ClassDriverListObject = ClassDriverListObject;
        DrvSearchContext->StringTable = DrvSearchContext->StringTable;
    }

final:

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(ClassDriverListObject) {
        MyFree(ClassDriverListObject);
    }

    if(DrvSearchInProgressNode.SearchCancelledEvent) {
        CloseHandle(DrvSearchInProgressNode.SearchCancelledEvent);
    }

    //
    // Close the CDM context and free cdm.dll if we haven't already.
    //
    if (hInstanceCDM) {

        spFusionEnterContext(NULL,&spFusionInstance);

        if (hCDMContext) {

            CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;

            if (pfnCloseCDMContext =  (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hInstanceCDM,
                            "CloseCDMContext")) {

                pfnCloseCDMContext(hCDMContext);
            }
        }

        FreeLibrary(hInstanceCDM);

        spFusionLeaveContext(&spFusionInstance);
    }

    if(TempBuffer) {
        MyFree(TempBuffer);
    }

    if(DrvSearchContext) {
         
        if(DrvSearchContext->StringTable) {
            pStringTableDestroy(DrvSearchContext->StringTable);
        }

        if(DrvSearchContext->hCatAdmin) {
            CryptCATAdminReleaseContext(DrvSearchContext->hCatAdmin, 0);
        }

        MyFree(DrvSearchContext);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
DrvSearchCallback(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR InfName,
    IN PLOADED_INF Inf,
    IN BOOL PnfWasUsed,
    IN PVOID pContext
    )
/*++

Routine Description:

    This routine is a callback function for the INF enumeration routines
    (EnumSingleDrvInf, EnumDrvInfsInSearchPath).  It performs
    some action on the INF it's called for, then returns TRUE to continue
    enumeration, or FALSE to abort it.

Arguments:

    LogContext - Supplies information for logging purposes

    InfName - Supplies the fully-qualified pathname of the INF.

    pInf - Supplies pointer to the already loaded INF

    pContext - Supplies a pointer to an input/output storage buffer for use
        by the callback.  For this callback, this pointer supplies the address
        of a DRVSEARCH_CONTEXT structure.

Return Value:

    To continue enumeration, the function should return TRUE, otherwise, it
    should return FALSE.

Remarks:

    We never abort enumeration in case of failure, even if that
    failure is due to an out-of-memory condition!

--*/
{
    PDRVSEARCH_CONTEXT Context = (PDRVSEARCH_CONTEXT)pContext;
    PCTSTR Provider, ClassName;
    PTSTR CurMfgName, CurMfgSecName, DevDesc, InstallSecName, DrvDesc, MatchedHwID;
    PINF_SECTION MfgListSection, CurMfgSection, OptionsTextOrCtlFlagsSection;
    PINF_LINE MfgListLine, CurMfgLine, DrvDescLine;
    UINT MfgListIndex, CurMfgIndex, TempUint;
    TCHAR TempStringBuffer[MAX_SECT_NAME_LEN + MAX_INFSTR_STRKEY_LEN];
    UINT Rank;
    PDRIVER_NODE NewDriverNode;
    GUID InfClassGuid;
    BOOL InsertedAtHead;
    TCHAR OptionsTextSectionName[64];
    PCTSTR LanguageName;
    LONG MatchIndex;
    LONG InfClassGuidIndex;
    TCHAR InfSectionWithExt[MAX_SECT_NAME_LEN];
    DWORD InfSectionWithExtLength;
    PTSTR InfSectionExtension;
    BOOL InfIsDigitallySigned = FALSE;
    BOOL InfWasVerified = FALSE;
    BOOL CurMfgSecIsDecorated;
    TCHAR CurMfgSecWithExt[MAX_SECT_NAME_LEN];
    SYSTEMTIME SysTime; // we use this for logging

    //
    // caller must pass in valid data
    //
    MYASSERT(InfName);
    MYASSERT(Inf);
    MYASSERT(Context);

    //
    // Before we do anything else, check to see whether some other thread has told us
    // to abort.
    //
    if(*(Context->CancelSearch)) {
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }

    NewDriverNode = NULL;
    try {

        //
        // Skip this INF if it was from the Internet and we don't want Internet INFs
        //
        if ((Context->Flags & DRVSRCH_EXCLUDE_OLD_INET_DRIVERS) &&
            (Inf->InfSourceMediaType == SPOST_URL)) {
            goto clean0;
        }

        //
        // Process the INF differently depending on whether it's a Win95-style or a legacy INF.
        //
        if(Inf->Style & INF_STYLE_WIN4) {
            //
            // If we're building a compatible driver list, then we only care about this INF
            // if it contains the hardware/compatible IDs we're searching for.
            // Generally we wont get called unless we have any such ID's
            // sometimes we may, so an easy check to make up-front is to determine whether
            // any of the IDs exist in the loaded INF's string table.  If not, then we can
            // skip this file right now, and save a lot of time.
            //
            if((!Context->BuildClassDrvList) && (!pSetupDoesInfContainDevIds(Inf, Context))) {
                goto clean0;
            }

            //
            // Get the class GUID for this INF.
            //
            if(!ClassGuidFromInfVersionNode(&(Inf->VersionBlock), &InfClassGuid)) {
                goto clean0;
            }

            //
            // If we are building a class driver list, and there is an associated
            // class GUID, then check to see if this INF is of the same class.
            //
            if(Context->BuildClassDrvList && (Context->Flags & DRVSRCH_HASCLASSGUID)) {
                if(!IsEqualGUID(&(Context->ClassGuid), &InfClassGuid)) {
                    goto clean0;
                }
            }

            //
            // Don't allow a class that should be excluded (NoUseClass or NoDisplayClass) and the
            // DRVSRCH_ALLOWEXCLUDEDDRVS flag is not set.
            //
            if (Context->BuildClassDrvList && ShouldClassBeExcluded(&InfClassGuid, !(Context->Flags & DRVSRCH_ALLOWEXCLUDEDDRVS))) {
                goto clean0;
            }

            //
            // Retrieve the name of the provider for this INF file.
            //
            Provider = pSetupGetVersionDatum(&(Inf->VersionBlock), pszProvider);

            if(!(MfgListSection = InfLocateSection(Inf, pszManufacturer, NULL))) {
                //
                // No [Manufacturer] section--skip this INF.
                //
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_VERBOSE,  // VERBOSE since otherwise it will always log GUID-0 inf's for full iteration
                    MSG_LOG_NO_MANUFACTURER_SECTION,
                    NULL,
                    InfName);

                goto clean0;
            }

            //
            // OK, we are likely going to add some driver nodes to our list in the code below.
            // Add this INF's class GUID to our GUID table.
            //
            InfClassGuidIndex = AddOrGetGuidTableIndex(Context->DeviceInfoSet, &InfClassGuid, TRUE);
            if(InfClassGuidIndex == -1) {
                goto clean0;
            }

            //
            // Find the [ControlFlags] section (if there is one), so that we can use it
            // later to determine whether particular devices should be excluded (via
            // 'ExcludeFromSelect').
            //
            OptionsTextOrCtlFlagsSection = InfLocateSection(Inf, pszControlFlags, NULL);

            Rank = 0;  // Initialize this value for case where we're building a class driver list.

            for(MfgListIndex = 0;
                InfLocateLine(Inf, MfgListSection, NULL, &MfgListIndex, &MfgListLine);
                MfgListIndex++) {

                //
                // Initially, assume the current manufacturer has no
                // per-os-version TargetDecoration entries
                //
                CurMfgSecIsDecorated = FALSE;

                if(!(CurMfgName = InfGetField(Inf, MfgListLine, 0, NULL))) {
                    continue;
                }

                if(!(CurMfgSecName = InfGetField(Inf, MfgListLine, 1, NULL))) {
                    //
                    // Lines with a single entry are considered to contain both
                    // a field 0 and a field 1 (i.e., both key and single
                    // value).  As such, this test should never fire.  If we
                    // have a line with no key and multiple values, we
                    // should've failed above when we tried to retrieve field
                    // zero.  Note that the code that builds the INF cache
                    // relies on this observation (i.e., it doesn't care about
                    // the manufacturer's name, so it always just retrieves
                    // field 1).
                    //
                    MYASSERT(CurMfgSecName);
                    continue;

                } else {
                    //
                    // Check to see if there is an applicable TargetDecoration
                    // entry for this manufacturer's models section (if so, the
                    // models section name will be appended with that
                    // decoration).
                    //
                    if(GetDecoratedModelsSection(LogContext,
                                                 Inf,
                                                 MfgListLine,
                                                 Context->AltPlatformInfo,
                                                 CurMfgSecWithExt)) {
                        //
                        // From here on, use the decorated models section...
                        //
                        CurMfgSecName = CurMfgSecWithExt;
                        CurMfgSecIsDecorated = TRUE;
                    }
                }

                if(!(CurMfgSection = InfLocateSection(Inf, CurMfgSecName, NULL))) {
                    continue;
                }

                //
                // We have the manufacturer's section--now process all entries in it.
                //
                for(CurMfgIndex = 0;
                    InfLocateLine(Inf, CurMfgSection, NULL, &CurMfgIndex, &CurMfgLine);
                    CurMfgIndex++) {

                    MatchIndex = -1;    // initialized for case when BuildClassDrvList is TRUE, to help with logging

                    if((Context->BuildClassDrvList  && !(Context->Flags & DRVSRCH_FILTERSIMILARDRIVERS)) ||
                       (Rank = pSetupTestDevCompat(Inf, CurMfgLine, Context, &MatchIndex)) != RANK_NO_MATCH) {
                        //
                        // Get the device description.
                        //
                        if(!(DevDesc = InfGetField(Inf, CurMfgLine, 0, NULL))) {
                            continue;
                        }

                        //
                        // Get the install section name.
                        //
                        if(!(InstallSecName = InfGetField(Inf, CurMfgLine, 1, NULL))) {
                            continue;
                        }

                        //
                        // Get the actual (i.e., potentially decorated) install
                        // section name.
                        //
                        if(!SetupDiGetActualSectionToInstallEx(
                                Inf,
                                InstallSecName,
                                Context->AltPlatformInfo,
                                InfSectionWithExt,
                                SIZECHARS(InfSectionWithExt),
                                NULL,
                                &InfSectionExtension,
                                NULL)) {
                            //
                            // Should never fail, but...
                            //
                            continue;
                        }

                        //
                        // Check to see if we only want the installed driver.
                        //
                        if ((Context->Flags & DRVSRCH_INSTALLEDDRIVER) &&
                            (!pSetupTestIsInstalledDriver(DevDesc,
                                                          CurMfgName,
                                                          Provider,
                                                          InstallSecName,
                                                          InfSectionExtension,
                                                          Context))) {
                            //
                            // If we are looking only for the currently installed
                            // driver and this is not it, then skip this driver
                            // node.
                            //
                            continue;
                        }

                        //
                        // Check to see if this hardware is excluded by being
                        // in a ExcludeId field.
                        //
                        if (pSetupExcludeId(LogContext,
                                            Inf,
                                            InfName,
                                            InfSectionWithExt,
                                            Context)) {
                            //
                            // Don't create a driver node for this INF match
                            // because this hardware is excluded from this match.
                            //
                            continue;
                        }

                        //
                        // Check to see if the INF is digitally signed (if we
                        // haven't already)
                        //
                        if(!InfWasVerified) {
                            //
                            // We only want to check each INF once
                            //
                            InfWasVerified = TRUE;

                            if(PnfWasUsed && !Context->AltPlatformInfo) {
                                //
                                // Check the Inf Flags to see if this was
                                // digitally signed.
                                //
                                if(Inf->Flags & LIF_INF_DIGITALLY_SIGNED) {
                                    InfIsDigitallySigned = TRUE;
                                }

                            } else {
                                //
                                // Either:
                                //
                                // (a) This INF is in a 3rd-party location
                                //     (hence it has no PNF), or
                                // (b) We've been supplied with alternate
                                //     platform information, thus we must
                                //     disregard the cached "INF is signed"
                                //     flag in the PNF
                                //
                                // In either case, we must now call
                                // WinVerifyTrust (potentially with the
                                // appropriate alternate platform parameters)
                                // to ascertain whether the INF should be
                                // considered signed.
                                //
                                // (Woe be unto those who wouldst call this for
                                // every INF in %windir%\Inf, for great would
                                // be the delay therein.)
                                //
                                if(VerifyDeviceInfFile(
                                       LogContext,
                                       &(Context->hCatAdmin),
                                       InfName,
                                       Inf,
                                       Context->AltPlatformInfo,
                                       NULL,
                                       NULL,
                                       NULL
                                       )) {

                                    InfIsDigitallySigned = TRUE;
                                }
                            }
                        }

                        //
                        // If we're building a compatible driver list (hence
                        // ranking is important), then we need to adjust the
                        // rank values if the INF is (a) unsigned and (b)
                        // undecorated (hence calling into question whether or
                        // not the INF was even meant to be used on NT)...
                        //
                        if(!Context->BuildClassDrvList) {

                            if(!InfIsDigitallySigned) {
                                //
                                // INF isn't signed, thus the match is untrusted
                                //
                                Rank |= DRIVER_UNTRUSTED_RANK;

                                if(!CurMfgSecIsDecorated && !InfSectionExtension) {
                                    //
                                    // Not only is the INF unsigned, but there
                                    // are also no NT-specific decorations that
                                    // give us a hint that this INF was intended
                                    // for use on NT.  Thus, we have reason to
                                    // be suspicious that this INF is for
                                    // Windows 9x platforms only...
                                    //
                                    Rank |= DRIVER_W9X_SUSPECT_RANK;
                                }
                            }
                        }

                        //
                        // Form the driver description.  It is of the form,
                        // "<InstallSection>.DriverDesc", and appears in the
                        // [strings] section (if present).  (NOTE: We don't have
                        // to search for this section, since it's always the
                        // first section in the INF's SectionBlock list.
                        //
                        // If no driver description is present, use the device
                        // description.
                        //
                        wsprintf(TempStringBuffer, pszDrvDescFormat, InstallSecName);
                        TempUint = 0;
                        if(!Inf->HasStrings ||
                           !InfLocateLine(Inf, Inf->SectionBlock, TempStringBuffer,
                                          &TempUint, &DrvDescLine) ||
                           !(DrvDesc = InfGetField(Inf, DrvDescLine, 1, NULL))) {

                            DrvDesc = DevDesc;
                        }

                        if(CreateDriverNode(Rank,
                                            DevDesc,
                                            DrvDesc,
                                            Provider,
                                            CurMfgName,
                                            &(Inf->VersionBlock.LastWriteTime),
                                            Inf->VersionBlock.Filename,
                                            InstallSecName,
                                            Context->StringTable,
                                            InfClassGuidIndex,
                                            &NewDriverNode) != NO_ERROR) {
                            continue;
                        }

                        //
                        // Get which hardware ID we matched with.
                        //
                        if(!(MatchedHwID = InfGetField(Inf, CurMfgLine, MatchIndex+3, NULL))) {
                            MatchedHwID = TEXT("");
                        }

                        //
                        // Log that a driver node was created.
                        //
                        WriteLogEntry(
                            LogContext,
                            Context->BuildClassDrvList ? DRIVER_LOG_INFO1 : DRIVER_LOG_INFO,
                            MSG_LOG_FOUND_1,
                            NULL,
                            MatchedHwID,                // hardware ID
                            InfName,                    // filename
                            DevDesc,                    // Device description
                            DrvDesc,                    // Driver description
                            Provider,                   // Provider name
                            CurMfgName,                 // Manufacturer name
                            InstallSecName              // Install section name
                            );

                        //
                        // If this is an untrusted compatible driver node, make
                        // an additional log entry about that
                        //
                        if(!Context->BuildClassDrvList
                            && (Rank & DRIVER_UNTRUSTED_RANK)) {

                            WriteLogEntry(LogContext,
                                          DRIVER_LOG_INFO,
                                          MSG_LOG_RANK_UNTRUSTED,
                                          NULL,
                                          Rank & ~DRIVER_W9X_SUSPECT_RANK,
                                          Rank
                                         );
                        }

                        if(pSetupGetDeviceIDs(NewDriverNode,
                                               Inf,
                                               CurMfgLine,
                                               Context->StringTable,
                                               OptionsTextOrCtlFlagsSection)) {
                            //
                            // If we're doing a non-native driver search, then
                            // we want to disregard any ExcludeFromSelect
                            // entries in the [ControlFlags] section, as they
                            // won't be relevant to our non-native driver node
                            // anyway.
                            //
                            if(Context->AltPlatformInfo) {
                                NewDriverNode->Flags &= ~DNF_EXCLUDEFROMLIST;
                            }

                        } else {
                            //
                            // We must've encountered an out-of-memory
                            // condition--time to bail!
                            //
                            DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
                            continue;
                        }

                        if(InfIsDigitallySigned) {
                            NewDriverNode->Flags |= DNF_INF_IS_SIGNED;
                        }

                        //
                        // Look for the DriverVer date and version in the
                        // install section and if it is not there then look
                        // in the Version section
                        //
                        if (!pSetupGetDriverDate(Inf,
                                                 InfSectionWithExt,
                                                 &(NewDriverNode->DriverDate))) {

                            pSetupGetDriverDate(Inf,
                                                INFSTR_SECT_VERSION,
                                                &(NewDriverNode->DriverDate));
                        }

                        //
                        // Mark the driver node as coming from a user doing an
                        // F6 during textmode setup if that is where the INF is
                        // from.
                        //
                        if (Inf->Flags & LIF_OEM_F6_INF) {
                            NewDriverNode->Flags |= DNF_OEM_F6_INF;
                        }

                        if(!FileTimeToSystemTime(&NewDriverNode->DriverDate,&SysTime)) {
                            ZeroMemory(&SysTime, sizeof(SysTime));
                        }

                        WriteLogEntry(
                            LogContext,
                            Context->BuildClassDrvList ? DRIVER_LOG_INFO1 : DRIVER_LOG_INFO,
                            MSG_LOG_FOUND_2,
                            NULL,
                            InfSectionWithExt,
                            Rank,
                            SysTime.wMonth,
                            SysTime.wDay,
                            SysTime.wYear);

                        //
                        // Get the DriverVersion from the INF.
                        //
                        if (!pSetupGetDriverVersion(Inf,
                                                    InfSectionWithExt,
                                                    &(NewDriverNode->DriverVersion))) {

                            pSetupGetDriverVersion(Inf,
                                                   INFSTR_SECT_VERSION,
                                                   &(NewDriverNode->DriverVersion));
                        }

                        if(!(Context->BuildClassDrvList)) {
                            //
                            // Store away the index of the matching device ID in this compatible
                            // driver node.
                            //
                            NewDriverNode->MatchingDeviceId = MatchIndex;
                        }

                        //
                        // If the INF from which this driver node was built has
                        // a corresponding PNF, then mark the driver node with
                        // the Win98-compatible DNF_INDEXED_DRIVER flag.
                        //
                        if(PnfWasUsed) {
                            NewDriverNode->Flags |= DNF_INDEXED_DRIVER;
                        }

                        //
                        // If the INF is from Windows Update (the Internet) then
                        // set the DNF_INET_DRIVER bit.
                        //
                        if (Context->Flags & DRVSRCH_FROM_INET) {

                            NewDriverNode->Flags |= DNF_INET_DRIVER;
                        }

                        //
                        // If we just downloade this driver from the Internet then we need to
                        // clean it up when we destroy the driver node
                        //
                        if (Context->Flags & DRVSRCH_CLEANUP_SOURCE_PATH) {

                            NewDriverNode->Flags |= PDNF_CLEANUP_SOURCE_PATH;
                        }

                        //
                        // If the InfSourceMediaType is SPOST_URL then the
                        // Inf that this driver came from came from the Internet
                        // but now lives in the INF directory.  You should never
                        // install a driver with the DNF_OLD_INET_DRIVER flag set
                        // because we no longer have access to the sources files.
                        //
                        if (Inf->InfSourceMediaType == SPOST_URL) {

                            NewDriverNode->Flags |= DNF_OLD_INET_DRIVER;
                        }

                        //
                        // Merge the new driver node into our existing list.
                        // NOTE: Do not dereference NewDriverNode after this call,
                        // since it may have been a duplicate, in which case it
                        // will be destroyed by this routine.
                        //
                        pSetupMergeDriverNode(Context, NewDriverNode, &InsertedAtHead);
                        NewDriverNode = NULL;

                        if(!Context->BuildClassDrvList && InsertedAtHead) {
                            //
                            // Update the device instance class to that of the new
                            // lowest-rank driver.
                            //
                            CopyMemory(&(Context->ClassGuid),
                                       &InfClassGuid,
                                       sizeof(GUID)
                                      );
                            Context->Flags |= DRVSRCH_HASCLASSGUID;
                            if(ClassName = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass)) {
                                lstrcpy(Context->ClassName, ClassName);
                            } else {
                                *(Context->ClassName) = TEXT('\0');
                            }
                        }
                    }
                }
            }

        } else {

            //
            // caller may have given us an OLDNT Inf when we only want WIN4 style
            // if this is the case, skip the Inf
            //
            if (!(Context->Flags & DRVSRCH_USEOLDINFS)) {
                goto clean0;
            }
            MYASSERT(Context->BuildClassDrvList && (Context->Flags & DRVSRCH_HASCLASSGUID));

            //
            // We're dealing with a legacy INF.  First, check to see if this is the INF
            // class we're looking for.
            //
            if(lstrcmpi(pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass),
                        Context->LegacyClassName)) {

                goto clean0;
            }

            //
            // Now, retrieve the name of the provider for this INF file, and the standard
            // (localized) manufacturer name we assign to legacy driver nodes.
            //
            Provider = pSetupGetVersionDatum(&(Inf->VersionBlock), pszProvider);

            LoadString(MyDllModuleHandle,
                       IDS_ADDITIONALMODELS,
                       TempStringBuffer,
                       SIZECHARS(TempStringBuffer)
                      );
            CurMfgName = TempStringBuffer;

            //
            // Now, retrieve the options from the [Options] section, and convert each one
            // into a driver node.
            //
            if(!(CurMfgSection = InfLocateSection(Inf, pszOptions, NULL))) {
                goto clean0;
            }

            //
            // Attempt to find the corresponding OptionsText section, based on the language
            // identifier contained in the search context.
            //
            OptionsTextOrCtlFlagsSection = NULL;
            CopyMemory(OptionsTextSectionName, pszOptionsText, sizeof(pszOptionsText) - sizeof(TCHAR));
            lstrcpy((PTSTR)((PBYTE)OptionsTextSectionName + (sizeof(pszOptionsText) - sizeof(TCHAR))),
                    LanguageName = Context->LegacyClassLang
                   );
            OptionsTextOrCtlFlagsSection = InfLocateSection(Inf, OptionsTextSectionName, NULL);

            if(!OptionsTextOrCtlFlagsSection) {
                //
                // Then we couldn't retrieve the 'best' language.  Revert to picking the first
                // language listed in the [LanguagesSupported] section.  (Recycle 'MfgList*' variables
                // here.)
                //
                if(!(MfgListSection = InfLocateSection(Inf, pszLanguagesSupported, NULL))) {
                    //
                    // No such section--give up on this INF.
                    //
                    goto clean0;
                }

                MfgListIndex = 0;
                if(!InfLocateLine(Inf, MfgListSection, NULL, &MfgListIndex, &MfgListLine)) {
                    goto clean0;
                }

                lstrcpy((PTSTR)((PBYTE)OptionsTextSectionName + (sizeof(pszOptionsText) - sizeof(TCHAR))),
                        LanguageName = InfGetField(Inf, MfgListLine, 0, NULL)
                       );

                if(!(OptionsTextOrCtlFlagsSection = InfLocateSection(Inf,
                                                                     OptionsTextSectionName,
                                                                     NULL))) {
                    goto clean0;
                }
            }

            //
            // We are about to add some driver nodes to our list in the code below.
            // Add the class GUID corresponding to this legacy INF's class name to our GUID table.
            //
            InfClassGuidIndex = AddOrGetGuidTableIndex(Context->DeviceInfoSet, &(Context->ClassGuid), TRUE);
            if(InfClassGuidIndex == -1) {
                goto clean0;
            }

            //
            // OK, now we have pointers to both the [Options] and [OptionsText<lang>] sections.
            // Now, enumerate the options.
            //
            for(CurMfgIndex = 0;
                InfLocateLine(Inf, CurMfgSection, NULL, &CurMfgIndex, &CurMfgLine);
                CurMfgIndex++) {

                //
                // Get the Option name (used as the install section name).
                //
                if(!(InstallSecName = InfGetField(Inf, CurMfgLine, 0, NULL))) {
                    continue;
                }

                //
                // Now get the driver/device description (i.e., the corresponding option entry in the
                // OptionsText section).
                //
                TempUint = 0;
                if(!InfLocateLine(Inf,
                                  OptionsTextOrCtlFlagsSection,
                                  InstallSecName,
                                  &TempUint,
                                  &DrvDescLine) ||
                   !(DrvDesc = InfGetField(Inf, DrvDescLine, 1, NULL))) {
                    //
                    // Couldn't find the driver description.
                    //
                    continue;
                }

                //
                // We now have all the information we need to create a driver node.
                //
                if(CreateDriverNode(RANK_NO_MATCH,
                                    DrvDesc,
                                    DrvDesc,
                                    Provider,
                                    CurMfgName,
                                    &(Inf->VersionBlock.LastWriteTime),
                                    Inf->VersionBlock.Filename,
                                    InstallSecName,
                                    Context->StringTable,
                                    InfClassGuidIndex,
                                    &NewDriverNode) != NO_ERROR) {
                    continue;
                }

                //
                // Now, add the string ID representing the language to be used for installing
                // this driver node.
                //
                if((NewDriverNode->LegacyInfLang = pStringTableAddString(
                                                       Context->StringTable,
                                                       (PTSTR)LanguageName,
                                                       STRTAB_CASE_SENSITIVE,
                                                       NULL,0)) == -1) {
                    //
                    // Out-of-memory, can't use this driver node after all.
                    //
                    DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
                    NewDriverNode = NULL;
                    continue;
                }

                //
                // Mark this driver node as being a legacy driver node.
                //
                NewDriverNode->Flags |= DNF_LEGACYINF;

                //
                // Merge the new driver node into our existing list.
                // NOTE: Do not dereference NewDriverNode after this call,
                // since it may have been a duplicate, in which case it
                // will be destroyed by this routine.
                //
                pSetupMergeDriverNode(Context, NewDriverNode, &InsertedAtHead);
                NewDriverNode = NULL;
            }
        }
clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {

        if(NewDriverNode) {
            //
            // Make sure it didn't get partially linked into a list.
            //
            NewDriverNode->Next = NULL;
            DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
        }
    }

    return TRUE;
}


BOOL
pSetupFillInHardwareAndCompatIds(
    PDEVINFO_ELEM DevInfoElem,
    HMACHINE hMachine,
    PDRVSEARCH_CONTEXT DrvSearchContext,
    PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine fills in the PDRVSEARCH_CONTEXT->IdList with the string
    table Ids for all of the hardware and compatible Ids for the specified
    device.

Arguments:

    DevInfoElem - Supplies the address of a devinfo element.

    hMachine - Handle to the machine where the device resides that this
        API will get the hardware and compatbile Ids for.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

    LogContext - Supplies information for logging purposes


Return Value:

    TRUE if no error is encountered, FALSE otherwise.

--*/
{
    DWORD Err, i;
    CONFIGRET cr;
    LONG NumIds[2];
    TCHAR TempBuffer[REGSTR_VAL_MAX_HCID_LEN];  // also holds other strings, but this value is largest
    LPTSTR TempBufferPos;                       // for character parsing
    ULONG TempBufferLen;

    Err = ERROR_SUCCESS;

    //
    // We're building a class driver list for similar drivers only--retrieve the list
    // of Hardware IDs (index 0) and Compatible IDs (index 1) from the device's
    // registry properties.
    //
    for(i = 0; i < 2; i++) {
        DWORD slot = AllocLogInfoSlot(LogContext,TRUE);

        TempBufferLen = sizeof(TempBuffer);
        cr = CM_Get_DevInst_Registry_Property_Ex(
                DevInfoElem->DevInst,
                (i ? CM_DRP_COMPATIBLEIDS : CM_DRP_HARDWAREID),
                NULL,
                TempBuffer,
                &TempBufferLen,
                0,
                hMachine);


        switch(cr) {

            case CR_BUFFER_SMALL :
                Err = ERROR_INVALID_DATA;
                goto clean0;

            case CR_INVALID_DEVINST :
                Err = ERROR_NO_SUCH_DEVINST;
                goto clean0;

            default :  ;  // Ignore any other return code.
        }

        //
        // If we retrieved a REG_MULTI_SZ buffer, add all the strings in it
        // to the device information set's string table.
        //
        if((cr == CR_SUCCESS) && (TempBufferLen > 2 * sizeof(TCHAR))) {

            if((NumIds[i] = AddMultiSzToStringTable(DrvSearchContext->StringTable,
                                                    TempBuffer,
                                                    DrvSearchContext->IdList[i],
                                                    MAX_HCID_COUNT,
                                                    FALSE,
                                                    NULL)) == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Use a -1 end-of-list marker so that we don't have to store
            // the count in the context structure.
            //
            DrvSearchContext->IdList[i][ NumIds[i] ] = -1;

            //
            // Now that the data has been stored, it can be munged for
            // easy logging. In this, the NULLs between strings are
            // turned into commas.
            //
            for (TempBufferPos = TempBuffer; *TempBufferPos != 0; TempBufferPos = CharNext(TempBufferPos)) {
                //
                // we have a string, look for string terminator
                //
                while (*TempBufferPos != 0) {
                    TempBufferPos = CharNext(TempBufferPos);
                }
                //
                // peek to see if a non-Null character follows terminating NULL
                // can't use CharNext here, as it wont go past end of string
                // however terminating NULL always only takes up 1 TCHAR
                //
                if(*(TempBufferPos+1) != 0) {
                    //
                    // convert terminator into a comma unless last string
                    //
                    *TempBufferPos = TEXT(',');
                }
                //
                // onto next string
                //
            }

            WriteLogEntry(LogContext,
                slot,
                (i ? MSG_LOG_SEARCH_COMPATIBLE_IDS
                   : MSG_LOG_SEARCH_HARDWARE_IDS),
                NULL,
                TempBuffer);

        } else {
            NumIds[i] = 0;
            DrvSearchContext->IdList[i][0] = -1;
        }
    }

clean0:

    SetLastError(Err);
    return (Err == ERROR_SUCCESS);
}


LONG
pSetupGetInstalledDriverInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    PDRVSEARCH_CONTEXT  DrvSearchContext
    )
/*++

Routine Description:

    This routine determins the currently installed INF file for this device
    and adds it to the string table.  It will also retrieve the Description,
    MfgName, ProviderName of the currently installed driver and add those to
    the string table as well.  It will store these string table Ids in the
    appropriate entries in the DrvSearchContext parameter. It will return the
    StringTableId of the InfPath or -1 if there was an error or there wasn't
    an InfPat for this device.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure that
        this routine will get the Infpath for.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

Return Value:

    This function returns the StringTableId of the InfPath that was added to the
    string table or -1 if there was an error.

--*/
{
    HKEY hKey;
    DWORD Err;
    DWORD RegDataType, RegDataLength;
    TCHAR TempBuffer[MAX_PATH];
    LONG InfPathId = -1;
    LONG StringTableId;

    //
    // Open the device's driver key and retrieve the INF from which the device was installed.
    //
    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ
                               );

    if(hKey == INVALID_HANDLE_VALUE) {
        return -1;
    }

    RegDataLength = sizeof(TempBuffer); // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_INFPATH,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if((Err == ERROR_SUCCESS) && (RegDataType != REG_SZ)) {
        goto clean0;
    }

    if(Err != ERROR_SUCCESS) {
        goto clean0;
    }

    //
    // We got the InfPath so add it to the string table
    //
    InfPathId = pStringTableAddString(DrvSearchContext->StringTable,
                                      TempBuffer,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                      NULL,
                                      0
                                      );

    //
    // Now lets get the Provider from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_PROVIDER_NAME,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the provider to the string table.
        //
        DrvSearchContext->InstalledProviderName =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no provider specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL provider to the real provider.
        //
        DrvSearchContext->InstalledProviderName = -1;
    }

    //
    // Now lets get the InfSection from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_INFSECTION,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the InfSection to the string table.
        //
        DrvSearchContext->InstalledInfSection =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no InfSection specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL InfSection to the real InfSection.
        //
        DrvSearchContext->InstalledInfSection = -1;
    }

    //
    // Now lets get the InfSectionExt from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_INFSECTIONEXT,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the InfSection to the string table.
        //
        DrvSearchContext->InstalledInfSectionExt =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no InfSectionExt specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL InfSectionExt to the real InfSectionExt.
        //
        DrvSearchContext->InstalledInfSectionExt = -1;
    }

    //
    // Next, retrieve the manufacturer (stored in the Mfg device property).
    //
    if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_MFG,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)TempBuffer,
                                        sizeof(TempBuffer),    // in bytes
                                        NULL)) {

        //
        // Add the manufacturer to the string table.
        //
        DrvSearchContext->InstalledMfgName =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no manufacturer specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL manufacturer to the real manufacturer.
        //
        DrvSearchContext->InstalledMfgName = -1;
    }

    //
    // Finally, retrieve the device description (stored in the DeviceDesc device property).
    //
    if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_DEVICEDESC,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)TempBuffer,
                                        sizeof(TempBuffer),    // in bytes
                                        NULL)) {

        //
        // Add the device description to the string table.
        //
        DrvSearchContext->InstalledDescription =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no device description specified.  If it turns out that the
        // registry query really failed for some other reason, then this will fail later
        // on when we compare this NULL device description to the real device description.
        //
        DrvSearchContext->InstalledDescription = -1;
    }

clean0:

    RegCloseKey(hKey);

    return InfPathId;
}


BOOL
pSetupTestIsInstalledDriver(
    IN PCTSTR Description,
    IN PCTSTR MfgName,
    IN PCTSTR ProviderName,
    IN PCTSTR InfSection,
    IN PCTSTR InfSectionExt,
    IN PDRVSEARCH_CONTEXT Context
    )
{
    LONG StringId;
    BOOL bIsInstalledDriver = FALSE;
    PTSTR String;

    //
    // First test the Description:
    // Make sure we have both Descriptions or that both are NULL.
    //
    if (((Context->InstalledDescription == -1) && Description) ||
        ((Context->InstalledDescription != -1) && !Description)) {
        goto clean0;
    }

    if (Context->InstalledDescription != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledDescription);

        if (!String || lstrcmpi(String, Description)) {
            //
            // Descriptions don't match
            //
            goto clean0;
        }
    }

    //
    // Next test the MfgName:
    // Make sure we have two MfgNames or that both are NULL.
    //
    if (((Context->InstalledMfgName == -1) && MfgName) ||
        ((Context->InstalledMfgName != -1) && !MfgName)) {
        goto clean0;
    }

    if (Context->InstalledMfgName != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledMfgName);

        if (!String || lstrcmpi(String, MfgName)) {
            //
            // MfgNames don't match
            //
            goto clean0;
        }
    }

    //
    // Next test the ProviderName:
    // Make sure we have two ProviderNames or that both are NULL.
    //
    if (((Context->InstalledProviderName == -1) && ProviderName) ||
        ((Context->InstalledProviderName != -1) && !ProviderName)) {
        goto clean0;
    }

    if (Context->InstalledProviderName != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledProviderName);

        if (!String || lstrcmpi(String, ProviderName)) {
            //
            // ProviderNames don't match
            //
            goto clean0;
        }
    }

    //
    // Next, test the InfSection:
    // Make sure we have two InfSections or that both are NULL.
    //
    if (((Context->InstalledInfSection == -1) && InfSection) ||
        ((Context->InstalledInfSection != -1) && !InfSection)) {
        goto clean0;
    }

    if (Context->InstalledInfSection != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledInfSection);

        if (!String || lstrcmpi(String, InfSection)) {
            //
            // InfSections don't match
            //
            goto clean0;
        }
    }

    //
    // Finally, test the InfSectionExt:
    // Make sure we have two InfSections or that both are NULL.
    //
    if (((Context->InstalledInfSectionExt == -1) && InfSectionExt) ||
        ((Context->InstalledInfSectionExt != -1) && !InfSectionExt)) {
        goto clean0;
    }

    if (Context->InstalledInfSectionExt != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledInfSectionExt);

        if (!String || lstrcmpi(String, InfSectionExt)) {
            //
            // InfSectionExts don't match
            //
            goto clean0;
        }
    }

    //
    // Everything matches so this must be the currently installed driver.
    //
    bIsInstalledDriver = TRUE;

clean0:

    return bIsInstalledDriver;
}


UINT
pSetupTestDevCompat(
    IN  PLOADED_INF        Inf,
    IN  PINF_LINE          InfLine,
    IN  PDRVSEARCH_CONTEXT Context,
    OUT PLONG              MatchIndex
    )
/*++

Routine Description:

    This routine tests a device entry in an INF to see if it is
    compatible with the information supplied in the Context parameter.

Arguments:

    Inf - Supplies a pointer to the INF containing the device entry
        to be checked for compatibility.

    InfLine - Supplies a pointer to the line within the INF containing
        the device information to be checked for compatibility.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

    MatchIndex - Supplies the address of a variable that receives the
        index of the driver node device ID that a match was found for
        (if this routine returns RANK_NO_MATCH, then this variable is
        not filled in).

        If a match was found for the INF's hardware ID, the index is -1,
        otherwise, it is the (zero-based) index into the compatible ID
        list that will be stored for this driver node.

Return Value:

    The return value is the rank of the match (0 is best, with rank
    increasing for each successive compatible ID and/or INF line string
    field searched).  If the specified entry is not a match, then the
    routine returns RANK_NO_MATCH.

--*/
{
    UINT Rank = RANK_NO_MATCH, CurrentRank, FieldIndex;
    UINT LastMatchFieldIndex = 0; // shut up preFast
    PCTSTR DeviceIdString;
    LONG DeviceIdVal;
    DWORD DeviceIdStringLength;
    TCHAR TempString[MAX_DEVICE_ID_LEN];

    for(FieldIndex = 2;
        DeviceIdString = InfGetField(Inf, InfLine, FieldIndex, NULL);
        FieldIndex++) {

        //
        // It's OK to hit an empty string for the hardware ID, but we need to
        // bail the first time we see an empty compat ID string.
        //
        if(!(*DeviceIdString) && (FieldIndex > 2)) {
            break;
        }

        if (Context->Flags & DRVSRCH_FILTERSIMILARDRIVERS) {

            if (pSetupIsSimilarDriver(DeviceIdString,
                                      FieldIndex,
                                      Context
                                      )) {

                return 0;
            }

        } else {

            //
            // First, retrieve the string ID corresponding to this device
            // ID in our string table.  If it's not in there, then there's
            // no need to waste any time on this ID.
            //
            lstrcpyn(TempString, DeviceIdString, SIZECHARS(TempString));
            if((DeviceIdVal = pStringTableLookUpString(Context->StringTable,
                                                       TempString,
                                                       &DeviceIdStringLength,
                                                       NULL,
                                                       NULL,
                                                       STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                       NULL,0)) == -1) {
                continue;
            }

            //
            // The device ID is in our string table, so it _may_ be in
            // either our hardware id or compatible id list.
            //
            if(!pSetupCalculateRankMatch(DeviceIdVal,
                                         FieldIndex,
                                         Context->IdList,
                                         &CurrentRank)) {
                //
                // Then we had a match on a hardware ID--that's the best we're gonna get.
                //
                *MatchIndex = (LONG)FieldIndex - 3;
                return CurrentRank;

            } else if(CurrentRank < Rank) {
                //
                // This new rank is better than our current rank.
                //
                LastMatchFieldIndex = (LONG)FieldIndex - 3;
                Rank = CurrentRank;
            }
        }
    }

    if(Rank != RANK_NO_MATCH) {
        *MatchIndex = LastMatchFieldIndex;
    }

    return Rank;
}


BOOL
pSetupCalculateRankMatch(
    IN  LONG  DriverHwOrCompatId,
    IN  UINT  InfFieldIndex,
    IN  LONG  DevIdList[2][MAX_HCID_COUNT+1],
    OUT PUINT Rank
    )
/*++

Routine Description:

    This routine calculates the rank match ordinal for the specified driver
    hardware or compatible ID, if it matches one of the hardware or compatible
    IDs for a device.

Arguments:

    DriverHwOrCompatId - Supplies the string table ID for the ID we're trying to
        find a match for.

    InfFieldIndex - Supplies the index within the INF line where this ID was
        located (2 is hardware ID, 3 and greater is compatible ID).

    DevIdList - Supplies the address of a 2-dimensional array with 2 rows, each
        row containing a list of device IDs that the device has.  Each list is
        terminated by an entry containing -1.

        THIS MUST BE DIMENSIONED THE SAME AS THE 'IdList' FIELD OF THE DRVSEARCH_CONTEXT
        STRUCTURE!!!

    Rank - Supplies the address of a variable that receives the rank of the match,
        or RANK_NO_MATCH if there is no match.

Return Value:

    If there was a match on a hardware ID, then the return value is FALSE (i.e. no
    further searching is needed), otherwise it is TRUE.

--*/
{
    int i, j;

    MYASSERT(InfFieldIndex >= 2);

    for(i = 0; i < 2; i++) {

        for(j = 0; DevIdList[i][j] != -1; j++) {

            if(DevIdList[i][j] == DriverHwOrCompatId) {

                //
                // We have a match.
                //
                // The ranks are as follows:
                //
                // Device = HardwareID, INF = HardwareID        => 0x0000 - 0x0999
                // Device = HardwareID, INF = CompatID          => 0x1000 - 0x1999
                // Device = CompatID, INF = HardwareID          => 0x2000 - 0x2999
                // Device = CompatID, INF = CompatID            => 0x3000 - 0x????
                //
                if (i == 0) {

                    //
                    //We matched one of the device's HardwareIDs.
                    //
                    *Rank = ((InfFieldIndex == 2) ? RANK_HWID_INF_HWID_BASE : RANK_HWID_INF_CID_BASE) + j;

                } else {

                    //
                    //We matched one of the device's CompatibleIDs.
                    //
                    *Rank = ((InfFieldIndex == 2) ? RANK_CID_INF_HWID_BASE : RANK_CID_INF_CID_BASE + (RANK_CID_INF_CID_INC * (InfFieldIndex - 3))) + j;

                }


                return (BOOL)i;
            }
        }
    }

    //
    // No match was found.
    //
    *Rank = RANK_NO_MATCH;

    return TRUE;
}


BOOL
pSetupIsSimilarDriver(
    IN  PCTSTR              DriverHwOrCompatId,
    IN  UINT                InfFieldIndex,
    IN  PDRVSEARCH_CONTEXT  Context
    )
/*++

Routine Description:

    This routine calculates the rank match ordinal for the specified driver
    hardware or compatible ID, if it matches one of the hardware or compatible
    IDs for a device.

Arguments:

    DriverHwOrCompatId - Supplies the Hardware or Compatible ID we're trying to
        find a match for.

    InfFieldIndex - Supplies the index within the INF line where this ID was
        located (2 is hardware ID, 3 and greater is compatible ID).

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

Return Value:

    If there is a similar Hardware or Compatible Id match then return TRUE, otherwise
    return FALSE.

--*/
{
    int i, j;
    PTSTR String;

    MYASSERT(InfFieldIndex >= 2);

    for(i = 0; i < 2; i++) {

        for(j = 0; Context->IdList[i][j] != -1; j++) {

            String = pStringTableStringFromId(Context->StringTable, Context->IdList[i][j]);

            if (String &&
                _tcsnicmp(String, DriverHwOrCompatId, min(lstrlen(String), lstrlen(DriverHwOrCompatId))) == 0) {

                //
                // We have a match.
                //
                return TRUE;
            }
        }
    }

    //
    // No match was found.
    //
    return FALSE;
}

BOOL
pSetupExcludeId(
    IN PSETUP_LOG_CONTEXT   LogContext,
    IN PLOADED_INF          Inf,
    IN PCTSTR               InfName,
    IN PCTSTR               InfSection,
    IN PDRVSEARCH_CONTEXT   Context
    )
/*++

Routine Description:

    This routine looks in the decorated DDInstall section for ExcludeId values.
    If one of the ExcludeId values match one of the hardware or compatible Ids
    of this hardware then this API will return TRUE indicating that a driver
    node should not be created for this DDInstall section.

Arguments:

    LogContext - logging context

    Inf - Supplies the PLOADED_INF handle.

    InfName - name of the Inf file, used in logging.

    InfSection - Supplies the fully decorated DDInstall section.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

Return Value:

    If this inf section should be excluded based on the hardware/compatible Ids
    then return TRUE, otherwise return FALSE.

--*/
{
    BOOL bExcludeId = FALSE;
    INFCONTEXT ExcludeIdLineContext;
    DWORD FieldCount, FieldIndex;
    INT i, j;
    PCTSTR ExclDevId, DeviceId;

    //
    // If no hardware id or compatible ids then there is nothing to Exclude.
    //
    if ((Context->IdList[0][0] == -1) &&
        (Context->IdList[1][0] == -1)) {

        return FALSE;
    }


    if (SetupFindFirstLine(Inf,
                            InfSection,
                            SZ_KEY_EXCLUDEID,
                            &ExcludeIdLineContext
                            )) {

        do {

            FieldCount = SetupGetFieldCount(&ExcludeIdLineContext);
            for (FieldIndex = 1;
                 !bExcludeId && (FieldIndex <= FieldCount);
                 FieldIndex++) {

                ExclDevId = pSetupGetField(&ExcludeIdLineContext, FieldIndex);

                //
                // If the Id is NULL then don't bother going through the list
                // of IDs.
                //
                if (!ExclDevId) {
                    continue;
                }

                //
                // Enumerate through all of the hardware and compatible Ids for
                // this device and comapre them to the exclude id.
                //
                for(i = 0; !bExcludeId && (i < 2); i++) {

                    for(j = 0; Context->IdList[i][j] != -1; j++) {

                        DeviceId = pStringTableStringFromId(Context->StringTable,
                                                            Context->IdList[i][j]);

                        if(!lstrcmpi(ExclDevId, DeviceId)) {
                            //
                            // This Hardware/Compatible Id is an ExcludeId, so
                            // we will have the API return TRUE so we know
                            // to not create a driver node for this Id.
                            //
                            bExcludeId = TRUE;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_INF_EXCLUDEID,
                                NULL,
                                InfName,
                                InfSection,
                                ExclDevId);

                            break;
                        }
                    }
                }
            }

        } while (!bExcludeId && SetupFindNextMatchLine(&ExcludeIdLineContext,
                                                       SZ_KEY_EXCLUDEID,
                                                       &ExcludeIdLineContext));
    }

    return bExcludeId;
}


BOOL
pSetupGetDeviceIDs(
    IN OUT PDRIVER_NODE DriverNode,
    IN     PLOADED_INF  Inf,
    IN     PINF_LINE    InfLine,
    IN OUT PVOID        StringTable,
    IN     PINF_SECTION CtlFlagsSection OPTIONAL
    )
/*++

Routine Description:

    This routine adds INF-defined hardware device ID and compatible
    device IDs to specified DRIVER_NODE.

Arguments:

    DriverNode - Supplies a pointer to the driver node to update.

    Inf - Supplies a pointer to the INF to retrieve the device IDs from.

    InfLine - Supplies a pointer to the INF line containing the device IDs.

    StringTable - Supplies the handle of a string table to be used for
        storing the device IDs.

    CtlFlagsSection - Optionally, supplies a pointer to the INF's [ControlFlags]
        section, that should be checked to determine whether this device is in
        an 'ExcludeFromSelect' list.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE (this will fail only if
    an out-of-memory condition is encountered).

--*/
{
    PCTSTR DeviceId;
    LONG i, NumCompatIds;
    TCHAR TempString[MAX_DEVICE_ID_LEN];
    PLONG TempIdList;

    //
    // If we already had a compatible ID list, free it now.
    //
    if(DriverNode->CompatIdList) {
        MyFree(DriverNode->CompatIdList);
        DriverNode->CompatIdList = NULL;
        DriverNode->NumCompatIds = 0;
    }

    //
    // Get the hardware ID.
    //
    if(!(DeviceId = InfGetField(Inf, InfLine, 2, NULL))) {

        DriverNode->HardwareId = -1;
        return TRUE;

    } else {

        lstrcpyn(TempString, DeviceId, SIZECHARS(TempString));
        if((DriverNode->HardwareId = pStringTableAddString(StringTable,
                                                           TempString,
                                                           STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                           NULL,0)) == -1) {
            return FALSE;
        } else {
            //
            // If this INF has a [ControlFlags] section, then check to see if this
            // hardware ID is marked for exclusion
            //
            if(CtlFlagsSection && pSetupShouldDevBeExcluded(DeviceId, Inf, CtlFlagsSection, NULL)) {
                DriverNode->Flags |= DNF_EXCLUDEFROMLIST;
            }
        }
    }

    //
    // Now get the compatible IDs.
    //
    MYASSERT(HASKEY(InfLine));
    NumCompatIds = InfLine->ValueCount - 4;
    if(NumCompatIds > 0) {

        if(!(DriverNode->CompatIdList = MyMalloc(NumCompatIds * sizeof(LONG)))) {
            return FALSE;
        }
        DriverNode->NumCompatIds = (DWORD)NumCompatIds;

        for(i = 0; i < NumCompatIds; i++) {

            if(!(DeviceId = InfGetField(Inf, InfLine, i + 3, NULL)) || !(*DeviceId)) {
                //
                // Just cut the list off here, and return.
                //
                DriverNode->NumCompatIds = i;
                if(i) {
                    //
                    // Resize the buffer (since we're sizing this down, it should never fail,
                    // but it's no big deal if it does).
                    //
                    if(TempIdList = MyRealloc(DriverNode->CompatIdList, i * sizeof(LONG))) {
                        DriverNode->CompatIdList = TempIdList;
                    }
                } else {
                    MyFree(DriverNode->CompatIdList);
                    DriverNode->CompatIdList = NULL;
                }
                return TRUE;

            } else {

                lstrcpyn(TempString, DeviceId, SIZECHARS(TempString));
                if((DriverNode->CompatIdList[i] = pStringTableAddString(
                                                        StringTable,
                                                        TempString,
                                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                        NULL,0)) == -1) {
                    MyFree(DriverNode->CompatIdList);
                    DriverNode->CompatIdList = NULL;
                    DriverNode->NumCompatIds = 0;
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


BOOL
pSetupShouldDeviceBeExcluded(
    IN  PCTSTR DeviceId,
    IN  HINF   hInf,
    OUT PBOOL  ArchitectureSpecificExclude OPTIONAL
    )
/*++

Routine Description:

    This routine is a public wrapper to our private API, pSetupShouldDevBeExcluded.
    Refer to the documentation for that routine for a description of this API's
    behavior.

    WARNING!!  THIS ROUTINE DOES NOT HANDLE APPEND-LOADED INFS!!!

Arguments:

    DeviceId - Supplies the device ID to check for.  This string may
        be empty, in which case the device is excluded only if a wildcard
        ('*') is found.

    Inf - Supplies the handle of the INF to check in.

    ArchitectureSpecificExclude - Optionally, supplies the address of a variable
        that receives a boolean value indicating whether or not the exclusion was
        architecture-specific (e.g., ExcludeFromSelect.NT<Platform>).  If this
        routine returns FALSE, then the contents of this variable are undefined.

Return Value:

    Returns TRUE if the ID is in the list (i.e., it should be excluded),
    FALSE if it is not.

--*/
{
    BOOL IsExcluded;
    PINF_SECTION CtlFlagsSection;

    if(!LockInf((PLOADED_INF)hInf)) {
        return FALSE;
    }

    IsExcluded = FALSE;

    //
    // Now attempt to locate a [ControlFlags] section in this INF.
    //
    if(CtlFlagsSection = InfLocateSection((PLOADED_INF)hInf, pszControlFlags, NULL)) {
        //
        // This section is present--check to see if the specified device ID is marked
        // for exclusion.
        //
        IsExcluded = pSetupShouldDevBeExcluded(DeviceId,
                                               (PLOADED_INF)hInf,
                                               CtlFlagsSection,
                                               ArchitectureSpecificExclude
                                              );
    }

    UnlockInf((PLOADED_INF)hInf);

    return IsExcluded;
}


BOOL
pSetupShouldDevBeExcluded(
    IN  PCTSTR       DeviceId,
    IN  PLOADED_INF  Inf,
    IN  PINF_SECTION CtlFlagsSection,
    OUT PBOOL        ArchitectureSpecificExclude OPTIONAL
    )
/*++

Routine Description:

    This routine determines if a passed-in Device ID is in an
    'ExludeFromSelect' line in the specified INF's [ControlFlags] section.
    It also checks any lines of the form "ExcludeFromSelect.<OS>", where
    <OS> is either "Win" or "NT", depending on which OS we're running on
    (determined dynamically).  Finally, if we're running on NT, we append
    the platform type, and look for lines of the form
    "ExcludeFromSelect.NT<Platform>", where <Platform> is either "X86",
    "MIPS", "Alpha", or "PPC".

Arguments:

    DeviceId - Supplies the device ID to check for.  This string may
        be empty, in which case the device is excluded only if a wildcard
        ('*') is found.

    Inf - Supplies a pointer to the INF to check in.

    CtlFlagsSection - Supplies a pointer to the INF's [ControlFlags] section.

    ArchitectureSpecificExclude - Optionally, supplies the address of a variable
        that receives a boolean value indicating whether or not the exclusion was
        architecture-specific (e.g., ExcludeFromSelect.NT<Platform>).  If this
        routine returns FALSE, then the contents of this variable are undefined.

Return Value:

    Returns TRUE if the ID is in the list (i.e., it should be excluded),
    FALSE if it is not.

--*/
{
    PINF_LINE CtlFlagsLine;
    UINT CtlFlagsIndex, i, j, StringIdUb, PlatformSpecificIndex;
    PCTSTR ExclDevId;
    LONG StringIdList[3];
    LONG KeyStringId;
    DWORD StringLength;

    //
    // Retrieve the list of string IDs for the keys we should be looking for in the
    // [ControlFlags] section.
    //
    StringIdUb = 0;
    PlatformSpecificIndex = (UINT)-1; // initially, assume no "ExcludeFromSelect.NT<Platform>"

    for(i = 0; i < ExcludeFromSelectListUb; i++) {

        if((StringIdList[StringIdUb] = pStringTableLookUpString(
                                           Inf->StringTable,
                                           pszExcludeFromSelectList[i],
                                           &StringLength,
                                           NULL,
                                           NULL,
                                           STRTAB_CASE_INSENSITIVE | STRTAB_ALREADY_LOWERCASE,
                                           NULL,0)) != -1) {
            //
            // If the index is 2, then we've found architecture-specific exlude lines.
            // Record the resulting index of this element, so we can determine later
            // whether we were excluded because of what platform we're on.
            //
            if(i == 2) {
                PlatformSpecificIndex = StringIdUb;
            }
            StringIdUb++;
        }
    }

    if(StringIdUb) {
        //
        // There are some ExcludeFromSelect* lines--examine each line.
        //
        for(CtlFlagsIndex = 0;
            InfLocateLine(Inf, CtlFlagsSection, NULL, &CtlFlagsIndex, &CtlFlagsLine);
            CtlFlagsIndex++) {
            //
            // We can't use InfGetField() to retrieve the string ID of the line's key,
            // since it will give us the case-sensitive form, and we must use the
            // case-insensitive (i.e., lowercase) version for our fast matching scheme.
            //
            if((KeyStringId = pInfGetLineKeyId(Inf, CtlFlagsLine)) != -1) {
                //
                // Check the string ID of this line's key against the string IDs we're
                // interested in.
                //
                for(i = 0; i < StringIdUb; i++) {
                    if(KeyStringId == StringIdList[i]) {
                        break;
                    }
                }

                //
                // If we looked at all entries, and didn't find a match, then skip this
                // line and continue with the next one.
                //
                if(i >= StringIdUb) {
                    continue;
                }

                for(j = 1;
                    ExclDevId = InfGetField(Inf, CtlFlagsLine, j, NULL);
                    j++) {
                    //
                    // If we find a lone asterisk, treat it as a wildcard, and
                    // return TRUE.  Otherwise return TRUE only if the device IDs match.
                    //
                    if(((*ExclDevId == TEXT('*')) && (ExclDevId[1] == TEXT('\0'))) ||
                       !lstrcmpi(ExclDevId, DeviceId)) {
                        //
                        // This device ID is to be excluded.  If the caller requested it,
                        // store a boolean in their output variable indicating whether this
                        // was an architecture-specific exclusion.
                        //
                        if(ArchitectureSpecificExclude) {
                            *ArchitectureSpecificExclude = (i == PlatformSpecificIndex);
                        }
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}


VOID
pSetupMergeDriverNode(
    IN OUT PDRVSEARCH_CONTEXT Context,
    IN     PDRIVER_NODE       NewDriverNode,
    OUT    PBOOL              InsertedAtHead
    )
/*++

Routine Description:

    This routine merges a driver node into a driver node linked list.
    If the list is empty the passed in DRIVER_NODE will be inserted at the
    head of the list. If the list contains any DRIVER_NODEs, new node will
    be merged as follows:  The new node will be inserted in front of any
    nodes with a higher rank.  If the rank is the same, the new node will be
    grouped with other nodes having the same manufacturer.  The new node will
    be inserted at the end of the group.  If the node is an exact duplicate
    of an existing node, meaning that its rank, description, manufacturer,
    and provider are all the same, then the node will be deleted (unless the
    existing node is marked as excluded and the new node is not, in which case
    the existing node will be discarded instead).

Arguments:

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure containing
        the list head, list tail, and list node count.

    NewDriverNode - Supplies a pointer to the driver node to be inserted.

    InsertedAtHead - Supplies a pointer to a variable that receives a flag
        indicating if the new driver was inserted at the head of the list.

Return Value:

    None.

--*/
{
    PDRIVER_NODE PrevDrvNode, CurDrvNode, DrvNodeToDelete;
    DWORD MatchFlags = 0;
    BOOL bDeleteNewDriverNode;
    PTSTR CurDrvNodeInfFile = NULL, NewDrvNodeInfFile = NULL;

    for(CurDrvNode = *(Context->pDriverListHead), PrevDrvNode = NULL;
        CurDrvNode;
        PrevDrvNode = CurDrvNode, CurDrvNode = CurDrvNode->Next) {

        if(NewDriverNode->MfgName != CurDrvNode->MfgName) {
            if(MatchFlags & 0x2) {
                break;
            }
        } else {
            MatchFlags |= 0x2;
            if(NewDriverNode->DevDescription != CurDrvNode->DevDescription) {
                if(MatchFlags & 0x4) {
                    break;
                }
            } else {
                MatchFlags |= 0x4;
                if(NewDriverNode->ProviderName != CurDrvNode->ProviderName) {
                    //
                    // We will only set the DNF_DUPDESC flags if both drivers do not
                    // have either the DNF_OLD_INET_DRIVER or the DNF_BAD_DRIVER
                    // flags set.
                    //
                    if (!(CurDrvNode->Flags & DNF_OLD_INET_DRIVER) &&
                        !(CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                        !(NewDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
                        !(NewDriverNode->Flags & DNF_BAD_DRIVER)) {

                        NewDriverNode->Flags |= DNF_DUPDESC;
                        CurDrvNode->Flags |= DNF_DUPDESC;
                    }

                    if (MatchFlags & 0x8) {
                        break;
                    }
                } else {
                    MatchFlags |=0x8;
                    if ((NewDriverNode->DriverDate.dwLowDateTime != CurDrvNode->DriverDate.dwLowDateTime) ||
                        (NewDriverNode->DriverDate.dwHighDateTime != CurDrvNode->DriverDate.dwHighDateTime) ||
                        (NewDriverNode->DriverVersion != CurDrvNode->DriverVersion)) {
                        //
                        // We will only set the DNF_DUPPROVIDER flags if both drivers do not
                        // have either the DNF_OLD_INET_DRIVER or the DNF_BAD_DRIVER
                        // flags set.
                        //
                        if (!(CurDrvNode->Flags & DNF_OLD_INET_DRIVER) &&
                            !(CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                            !(NewDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
                            !(NewDriverNode->Flags & DNF_BAD_DRIVER)) {

                            NewDriverNode->Flags |= DNF_DUPPROVIDER;
                            CurDrvNode->Flags |= DNF_DUPPROVIDER;
                        }

                        if (MatchFlags & 0x10) {
                            break;
                        }
                    } else {
                        MatchFlags |=0x10;
                        bDeleteNewDriverNode = TRUE;

                        if ((NewDriverNode->Rank != CurDrvNode->Rank) ||
                            (Context->Flags & DRVSRCH_NO_CLASSLIST_NODE_MERGE)) {
                            //
                            // The ranks are different, or the caller wants to
                            // include all INFs in the class list, so don't
                            // delete the new driver node.
                            //
                            bDeleteNewDriverNode = FALSE;

                        } else {
                            //
                            // In order to see if the INFs are identical first
                            // check if both INFs live in the same locations
                            // (meaning both live in the INF directory or both
                            // live in an Oem location). If so then we will just
                            // compare the filenames to see if the INFs are the
                            // same. If one INF lives in the INF directory and
                            // the other lives in an Oem location then do a 
                            // binary compare on the INF files to see if they
                            // are identical.
                            //
                            BOOL bCurDrvNodeInOemDir, bNewDrvNodeInOemDir;

                            CurDrvNodeInfFile = pStringTableStringFromId(Context->StringTable,
                                                                         CurDrvNode->InfFileName
                                                                         );
                            bCurDrvNodeInOemDir = pSetupInfIsFromOemLocation(CurDrvNodeInfFile, TRUE);

                            NewDrvNodeInfFile = pStringTableStringFromId(Context->StringTable,
                                                                         NewDriverNode->InfFileName
                                                                         );
                            bNewDrvNodeInOemDir = pSetupInfIsFromOemLocation(NewDrvNodeInfFile, TRUE);


                            if ((bCurDrvNodeInOemDir && bNewDrvNodeInOemDir) ||
                                (!bCurDrvNodeInOemDir && !bNewDrvNodeInOemDir)) {
                                //
                                // Since both these INFs live in the same location
                                // the new INF will get deleted only the two
                                // INF paths are identical.
                                //
                                bDeleteNewDriverNode = (CurDrvNode->InfFileName ==
                                                        NewDriverNode->InfFileName);
                            } else {
                                //
                                // At least one of the INFs lives in the INF 
                                // directory and the other lives in an Oem
                                // location so the new INF will get deleted only
                                //  if the two INFs are identical.
                                //
                                bDeleteNewDriverNode = pCompareFilesExact(CurDrvNodeInfFile,
                                                                          NewDrvNodeInfFile);
                            }
                        }

                        if (bDeleteNewDriverNode) {
                            //
                            // This is an exact match of description, rank,
                            // provider, DriverVer date, DriverVer version, and
                            // the Infs files.  Delete the node, unless
                            // the existing node is excluded, and this one is not,
                            // or the existing node is a bad driver and the new
                            // one is not.
                            //
                            if (((CurDrvNode->Flags & DNF_EXCLUDEFROMLIST) &&
                                  !(NewDriverNode->Flags & DNF_EXCLUDEFROMLIST)) ||
                                ((CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                                  !(NewDriverNode->Flags & DNF_BAD_DRIVER))) {

                                //
                                // Remove the old driver node so we can replace it with
                                // the new one.  (Don't worry about updating the tail
                                // pointer--it will get fixed up later.)
                                //
                                // If this current node is from the Internet then do not
                                // delete it now because when we delete a driver node from
                                // the Internet we remove all of the files in the temp path
                                // and some other driver node might still need thos files.
                                //
                                if (!(CurDrvNode->Flags & DNF_INET_DRIVER)) {
                                    DrvNodeToDelete = CurDrvNode;
                                    CurDrvNode = CurDrvNode->Next;
                                    if(PrevDrvNode) {
                                        PrevDrvNode->Next = CurDrvNode;
                                    } else {
                                        *(Context->pDriverListHead) = CurDrvNode;
                                    }
                                    DrvNodeToDelete->Next = NULL;       // just want to delete this one.
                                    DestroyDriverNodes(DrvNodeToDelete, Context->DeviceInfoSet);
                                    (*(Context->pDriverCount))--;
                                }
                                break;

                            } else {

                                //
                                // Don't delete this new driver node, even though it is a dup,
                                // if if it is from the Internet
                                //
                                if (!(NewDriverNode->Flags & DNF_INET_DRIVER)) {
                                    NewDriverNode->Next = NULL;         // just want to delete this one.
                                    DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
                                    *InsertedAtHead = FALSE;
                                    return;
                                }
                            }
                        } else {
                            //
                            // We will only set the DNF_DUPDRIVERVER flag if the other driver
                            // node does not have either the DNF_OLD_INET_DRIVER or the
                            // DNF_BAD_DRIVER flag set.
                            //
                            if (!(CurDrvNode->Flags & DNF_OLD_INET_DRIVER) &&
                                !(CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                                !(NewDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
                                !(NewDriverNode->Flags & DNF_BAD_DRIVER)) {

                                NewDriverNode->Flags |= DNF_DUPDRIVERVER;
                                CurDrvNode->Flags |= DNF_DUPDRIVERVER;
                            }
                        }
                    }
                }
            }
        }
    }

    if(!(NewDriverNode->Next = CurDrvNode)) {
        *(Context->pDriverListTail) = NewDriverNode;
    }
    if(PrevDrvNode) {
        PrevDrvNode->Next = NewDriverNode;
        *InsertedAtHead = FALSE;
    } else {
        *(Context->pDriverListHead) = NewDriverNode;
        *InsertedAtHead = TRUE;
    }

    (*(Context->pDriverCount))++;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiEnumDriverInfoA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    )
{
    BOOL b;
    DWORD rc;
    SP_DRVINFO_DATA_W driverInfoData;

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA_W);

    b = SetupDiEnumDriverInfoW(
            DeviceInfoSet,
            DeviceInfoData,
            DriverType,
            MemberIndex,
            &driverInfoData
            );

    rc = GetLastError();

    if(b) {
        rc = pSetupDiDrvInfoDataUnicodeToAnsi(&driverInfoData,DriverInfoData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}

#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiEnumDriverInfoW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DriverType);
    UNREFERENCED_PARAMETER(MemberIndex);
    UNREFERENCED_PARAMETER(DriverInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiEnumDriverInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN  DWORD            DriverType,
    IN  DWORD            MemberIndex,
    OUT PSP_DRVINFO_DATA DriverInfoData
    )
/*++

Routine Description:

    This routine enumerates the members of a driver information list.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver info list to be enumerated.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver info list to be enumerated.  If this
        parameter is not specified, then the 'global' driver list owned by the
        device information set is used (this list will be of type
        SPDIT_CLASSDRIVER).

    DriverType - Specifies what type of driver list to enumerate.  Must be
        one of the following values:

        SPDIT_CLASSDRIVER  -- Enumerate a class driver list.
        SPDIT_COMPATDRIVER -- Enumerate a list of drivers for the specified
                              device.  DeviceInfoData must be specified if
                              this value is used.

    MemberIndex - Supplies the zero-based index of the driver information member
        to be retrieved.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure that will
        receive information about the enumerated driver.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    To enumerate driver information members, an application should initialy call
    the SetupDiEnumDriverInfo function with the MemberIndex parameter set to zero.
    The application should then increment MemberIndex and call the SetupDiEnumDriverInfo
    function until there are no more values (i.e., the function fails, and GetLastError
    returns ERROR_NO_MORE_ITEMS).

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    UINT DriverCount, i;
    PDRIVER_NODE DriverNode;
    PDRIVER_NODE *DriverEnumHint;
    DWORD        *DriverEnumHintIndex;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to enumerate a driver list for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    //
                    // Enumerate class driver list for a particular device.
                    //
                    DriverCount = DevInfoElem->ClassDriverCount;
                    DriverNode = DevInfoElem->ClassDriverHead;

                    DriverEnumHint      = &(DevInfoElem->ClassDriverEnumHint);
                    DriverEnumHintIndex = &(DevInfoElem->ClassDriverEnumHintIndex);

                } else {
                    //
                    // Enumerate the global class driver list.
                    //
                    DriverCount = pDeviceInfoSet->ClassDriverCount;
                    DriverNode = pDeviceInfoSet->ClassDriverHead;

                    DriverEnumHint      = &(pDeviceInfoSet->ClassDriverEnumHint);
                    DriverEnumHintIndex = &(pDeviceInfoSet->ClassDriverEnumHintIndex);
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {

                    DriverCount = DevInfoElem->CompatDriverCount;
                    DriverNode = DevInfoElem->CompatDriverHead;

                    DriverEnumHint      = &(DevInfoElem->CompatDriverEnumHint);
                    DriverEnumHintIndex = &(DevInfoElem->CompatDriverEnumHintIndex);

                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        if(MemberIndex >= DriverCount) {
            Err = ERROR_NO_MORE_ITEMS;
            goto clean0;
        }

        //
        // Find the element corresponding to the specified index (using our
        // enumeration hint optimization, if possible)
        //
        if(*DriverEnumHintIndex <= MemberIndex) {
            MYASSERT(*DriverEnumHint);
            DriverNode = *DriverEnumHint;
            i = *DriverEnumHintIndex;
        } else {
            i = 0;
        }

        for(; i < MemberIndex; i++) {
            DriverNode = DriverNode->Next;
        }

        if(!DrvInfoDataFromDriverNode(pDeviceInfoSet,
                                      DriverNode,
                                      DriverType,
                                      DriverInfoData)) {

            Err = ERROR_INVALID_USER_BUFFER;
        }

        //
        // Remember this element as our new enumeration hint.
        //
        *DriverEnumHintIndex = MemberIndex;
        *DriverEnumHint = DriverNode;

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetSelectedDriverA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    )
{
    DWORD rc;
    BOOL b;
    SP_DRVINFO_DATA_W driverInfoData;

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA_W);
    b = SetupDiGetSelectedDriverW(DeviceInfoSet,DeviceInfoData,&driverInfoData);
    rc = GetLastError();

    if(b) {
        rc = pSetupDiDrvInfoDataUnicodeToAnsi(&driverInfoData,DriverInfoData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetSelectedDriverW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DriverInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetSelectedDriver(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA DriverInfoData
    )
/*++

Routine Description:

    This routine retrieves the member of a driver list that has been selected
    as the controlling driver.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to be queried.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device information element to retrieve the selected
        driver for.  If this parameter is NULL, then the selected class driver
        for the global class driver list will be retrieved.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure that receives
        the currently selected driver.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If no driver has been selected yet, the
    error will be ERROR_NO_DRIVER_SELECTED.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, DriverType;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to retrieve the selected driver for a particular device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DeviceInfoData,
                                                       NULL)) {

                DriverNode = DevInfoElem->SelectedDriver;
                DriverType = DevInfoElem->SelectedDriverType;

            } else {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

        } else {
            DriverNode = pDeviceInfoSet->SelectedClassDriver;
            DriverType = SPDIT_CLASSDRIVER;
        }

        if(DriverNode) {

            if(!DrvInfoDataFromDriverNode(pDeviceInfoSet,
                                          DriverNode,
                                          DriverType,
                                          DriverInfoData)) {

                Err = ERROR_INVALID_USER_BUFFER;
            }

        } else {
            Err = ERROR_NO_DRIVER_SELECTED;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiSetSelectedDriverA(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_A DriverInfoData  OPTIONAL
    )
{
    SP_DRVINFO_DATA_W driverInfoData;
    DWORD rc;
    BOOL b;

    if(DriverInfoData) {
        rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    b = SetupDiSetSelectedDriverW(
            DeviceInfoSet,
            DeviceInfoData,
            DriverInfoData ? &driverInfoData : NULL
            );

    rc = GetLastError();

    if(b && DriverInfoData) {
        rc = pSetupDiDrvInfoDataUnicodeToAnsi(&driverInfoData,DriverInfoData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiSetSelectedDriverW(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_W DriverInfoData  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DriverInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiSetSelectedDriver(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA DriverInfoData  OPTIONAL
    )
/*++

Routine Description:

    This routine sets the specified member of a driver list to be the currently
    selected driver.  It also allows the driver list to be reset, so that no
    driver is currently selected.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be selected.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device information element to select a driver for.
        If this parameter is NULL, then a class driver for the global class
        driver list will be selected.

        This is an IN OUT parameter because the class GUID for the device will be
        updated to reflect the class of the driver selected.

    DriverInfoData - If this parameter is specified, then it supplies the address
        of a driver information structure indicating the driver to be selected.
        If this parameter is NULL, then the driver list is to be reset (i.e., no
        driver selected).

        If the 'Reserved' field of this structure is 0, then this signifies that
        the caller is requesting a search for a driver node with the specified
        parameters (DriverType, Description, MfgName, and ProviderName).  If a
        match is found, then that driver node will be selected, otherwise, the API
        will fail, with GetLastError() returning ERROR_INVALID_PARAMETER.

        If the 'Reserved' field is 0, and a match is found, then the 'Reserved' field
        will be updated on output to reflect the actual driver node where the match
        was found.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverListHead, DriverNode;
    PDRIVER_NODE *pSelectedDriver;
    PDWORD pSelectedDriverType;
    DWORD DriverType;
    TCHAR ClassGuidString[GUID_STRING_LEN];
    TCHAR OldClassGuidString[GUID_STRING_LEN];
    BOOL NoGuidUpdate = FALSE;
    DWORD PropType;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_section = 0;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }
    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to select a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            LogContext = DevInfoElem->InstallParamBlock.LogContext;
            pSelectedDriver = &(DevInfoElem->SelectedDriver);
            pSelectedDriverType = &(DevInfoElem->SelectedDriverType);
        } else {
            pSelectedDriver = &(pDeviceInfoSet->SelectedClassDriver);
            pSelectedDriverType = NULL;
        }

        if(!DriverInfoData) {
            //
            // Then the driver list selection is to be reset.
            //
            *pSelectedDriver = NULL;
            if(pSelectedDriverType) {
                *pSelectedDriverType = SPDIT_NODRIVER;
            }

        } else {
            //
            // Retrieve the driver type from the SP_DRVINFO_DATA structure
            // so we know which linked list to search.
            //
            if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
               (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
                DriverType = DriverInfoData->DriverType;
            } else {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            switch(DriverType) {

                case SPDIT_CLASSDRIVER :

                    if(DeviceInfoData) {
                        DriverListHead = DevInfoElem->ClassDriverHead;
                    } else {
                        DriverListHead = pDeviceInfoSet->ClassDriverHead;
                    }
                    break;

                case SPDIT_COMPATDRIVER :

                    if(DeviceInfoData) {
                        DriverListHead = DevInfoElem->CompatDriverHead;
                        break;
                    }
                    //
                    // otherwise, let fall through for error condition.
                    //

                default :
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
            }

            //
            // Find the referenced driver node in the appropriate list.
            //
            if(DriverInfoData->Reserved) {

                if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                           DriverInfoData,
                                                           NULL))) {
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
                }

            } else {
                //
                // The caller has requested that we search for a driver node
                // matching the criteria specified in this DriverInfoData.
                //
                if(!(DriverNode = SearchForDriverNode(pDeviceInfoSet->StringTable,
                                                      DriverListHead,
                                                      DriverInfoData,
                                                      NULL))) {
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
                }
            }

            //
            // If we're selecting a driver for a device information element, then update
            // that device's class to reflect the class of this new driver node.
            //
            if(DeviceInfoData) {
                if(slot_section == 0) {
                    //
                    // To aid in debugging, log inf/section for the newly selected node
                    //
                    PTSTR szInfFileName, szInfSectionName;

                    szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                             DriverNode->InfFileName
                                                            );

                    szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                DriverNode->InfSectionName
                                                               );

                    slot_section = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE);
                    //
                    // Say what section is about to be installed.
                    //
                    WriteLogEntry(LogContext,
                        slot_section,
                        MSG_LOG_SETSELECTED_SECTION,
                        NULL,
                        szInfSectionName,
                        szInfFileName);
                }

                //
                // Get the INF class GUID for this driver node in string form, because
                // this property is stored as a REG_SZ.
                //
                pSetupStringFromGuid(&(pDeviceInfoSet->GuidTable[DriverNode->GuidIndex]),
                                     ClassGuidString,
                                     SIZECHARS(ClassGuidString)
                                    );

                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_CLASSGUID,
                                                     &PropType,
                                                     (PBYTE)OldClassGuidString,
                                                     sizeof(OldClassGuidString),
                                                     NULL)) {
                    if(_tcscmp(ClassGuidString,OldClassGuidString)==0) {
                        NoGuidUpdate = TRUE;
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_INFO,
                            MSG_LOG_KEEPSELECTED_GUID,
                            NULL,
                            ClassGuidString);
                    }
                }
                if(!NoGuidUpdate) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_SETSELECTED_GUID,
                        NULL,
                        ClassGuidString);
                }

                if(!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_CLASSGUID,
                                                     (PBYTE)ClassGuidString,
                                                     sizeof(ClassGuidString))) {
                    Err = GetLastError();
                    goto clean0;
                }
            }

            *pSelectedDriver = DriverNode;
            if(pSelectedDriverType) {
                *pSelectedDriverType = DriverType;
            }

            if(!DriverInfoData->Reserved) {
                //
                // Update the caller-supplied DriverInfoData to reflect the driver node
                // where the match was found.
                //
                DriverInfoData->Reserved = (ULONG_PTR)DriverNode;
            }
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of install
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_SETSELECTED,
            NULL);
    } else {
        //
        // indicate remove failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_SETSELECTED_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }
    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDriverInfoDetailA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_A        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_A DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    DWORD requiredSize;
    SP_DRVINFO_DATA_W driverInfoData;
    PSP_DRVINFO_DETAIL_DATA_W Details;
    PSTR AnsiMultiSz;
    int i;
    int CharCount;
    unsigned StringCount;
    UCHAR SectionName[2*LINE_LEN];
    UCHAR InfFileName[2*MAX_PATH];
    UCHAR DrvDescription[2*LINE_LEN];
    PUCHAR p;

    //
    // Check parameters.
    //
    rc = NO_ERROR;
    try {
        if(DriverInfoDetailData) {
            //
            // Check signature and make sure buffer is large enough
            // to hold fixed part and at least a valid empty multi_sz.
            //
            if((DriverInfoDetailData->cbSize != sizeof(SP_DRVINFO_DETAIL_DATA_A))
            || (DriverInfoDetailDataSize < (offsetof(SP_DRVINFO_DETAIL_DATA_A,HardwareID)+sizeof(CHAR)))) {

                rc = ERROR_INVALID_USER_BUFFER;
            }
        } else {
            //
            // Doesn't want data, size has to be 0.
            //
            if(DriverInfoDetailDataSize) {
                rc = ERROR_INVALID_USER_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    //
    // Convert the driver info data to unicode.
    //
    if(rc == NO_ERROR) {
        rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
    }
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    //
    // The hardware id field in the DRVINFO_DETAIL_DATA is
    // variable length and has no maximum length.
    // We call SetupDiGetDriverInfoDetailW once to get the required
    // size and then again to actually get the data. Because
    // we're not calling CM APIs and thus not doing any really
    // slow RPC operations, etc, we hope this will be satisfactory.
    //
    b = SetupDiGetDriverInfoDetailW(
            DeviceInfoSet,
            DeviceInfoData,
            &driverInfoData,
            NULL,
            0,
            &requiredSize
            );

    //
    // If it failed for a reason besides an insufficient buffer,
    // bail now. Last error remains set.
    //
    MYASSERT(!b);
    if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return(FALSE);
    }

    //
    // Allocate a buffer to hold the details data and call the API
    // again.
    //
    Details = MyMalloc(requiredSize);
    if(!Details) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    Details->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA_W);
    b = SetupDiGetDriverInfoDetail(
            DeviceInfoSet,
            DeviceInfoData,
            &driverInfoData,
            Details,
            requiredSize,
            NULL
            );

    if(!b) {
        rc = GetLastError();
        MyFree(Details);
        SetLastError(rc);
        return(FALSE);
    }

    //
    // Now allocate a buffer that allows us to convert the unicode
    // hardware id multi_sz to ansi, assuming every unicode character would
    // translate into a double-byte char -- this is the worst-case scenario.
    //
    CharCount = (requiredSize - offsetof(SP_DRVINFO_DETAIL_DATA_W,HardwareID)) / sizeof(WCHAR);
    AnsiMultiSz = MyMalloc(2*CharCount);
    if(!AnsiMultiSz) {
        MyFree(Details);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Convert the chars in the multi_sz.
    //
    i = WideCharToMultiByte(
            CP_ACP,
            0,
            Details->HardwareID,
            CharCount,
            AnsiMultiSz,
            CharCount*2,
            NULL,
            NULL
            );

    if(!i) {
        rc = GetLastError();
        MyFree(Details);
        MyFree(AnsiMultiSz);
        SetLastError(rc);
        return(FALSE);
    }

    //
    // Now we finally know exactly how large we need the ansi structure to be
    // because we have the number of bytes in the ansi representation
    // of the multi_sz.
    //
    requiredSize = offsetof(SP_DRVINFO_DETAIL_DATA_A,HardwareID) + i;

    rc = NO_ERROR;
    try {
        if(RequiredSize) {
            *RequiredSize = requiredSize;
        }

        if(DriverInfoDetailData) {
            //
            // We know the buffer is large enough to hold the fixed part
            // because we checked this at the start of the routine.
            //

            MYASSERT(offsetof(SP_DRVINFO_DETAIL_DATA_A,SectionName) == offsetof(SP_DRVINFO_DETAIL_DATA_W,SectionName));
            CopyMemory(DriverInfoDetailData,Details,offsetof(SP_DRVINFO_DETAIL_DATA_A,SectionName));

            DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA_A);
            DriverInfoDetailData->HardwareID[0] = 0;

            //
            // Convert fixed strings and guard against overflow.
            //
            i = WideCharToMultiByte(
                    CP_ACP,0,
                    Details->SectionName,
                    -1,
                    SectionName,
                    sizeof(SectionName),
                    NULL,
                    NULL
                    );

            if(i) {
                i = WideCharToMultiByte(
                        CP_ACP,0,
                        Details->InfFileName,
                        -1,
                        InfFileName,
                        sizeof(InfFileName),
                        NULL,
                        NULL
                        );

                if(i) {
                    i = WideCharToMultiByte(
                            CP_ACP,0,
                            Details->DrvDescription,
                            -1,
                            DrvDescription,
                            sizeof(DrvDescription),
                            NULL,
                            NULL
                            );

                    if(!i) {
                        rc = GetLastError();
                    }
                } else {
                    rc = GetLastError();
                }
            } else {
                rc = GetLastError();
            }

            if(rc == NO_ERROR) {
                if(!lstrcpynA(DriverInfoDetailData->SectionName,SectionName,LINE_LEN)
                || !lstrcpynA(DriverInfoDetailData->InfFileName,InfFileName,MAX_PATH)
                || !lstrcpynA(DriverInfoDetailData->DrvDescription,DrvDescription,LINE_LEN)) {
                    //
                    // lstrcpyn faulted, the buffer went bad
                    //
                    rc = ERROR_INVALID_USER_BUFFER;
                }
            }

            if(rc == NO_ERROR) {
                //
                // Finally, we need to transfer in as much of the ansi multi_sz
                // as will fit into the caller's buffer.
                //
                CharCount = DriverInfoDetailDataSize - offsetof(SP_DRVINFO_DETAIL_DATA_A,HardwareID);
                StringCount = 0;

                for(p=AnsiMultiSz; *p; p+=i) {

                    i = lstrlenA(p) + 1;

                    if(CharCount > i) {
                        lstrcpyA(DriverInfoDetailData->HardwareID+(p - AnsiMultiSz),p);
                        StringCount++;
                        CharCount -= i;
                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                        break;
                    }
                }

                DriverInfoDetailData->HardwareID[p-AnsiMultiSz] = 0;

                //
                // Now fix up the compat ids fields in the caller's structure.
                // The first string is the hardware id and any additional ones
                // are compatible ids.
                //
                if(StringCount > 1) {
                    DriverInfoDetailData->CompatIDsOffset = lstrlenA(AnsiMultiSz)+1;
                    DriverInfoDetailData->CompatIDsLength = (DWORD)(p - AnsiMultiSz) + 1
                                                          - DriverInfoDetailData->CompatIDsOffset;
                } else {
                    DriverInfoDetailData->CompatIDsLength = 0;
                    DriverInfoDetailData->CompatIDsOffset = 0;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    MyFree(AnsiMultiSz);
    MyFree(Details);

    SetLastError(rc);
    return(rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetDriverInfoDetailW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_W        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_W DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DriverInfoData);
    UNREFERENCED_PARAMETER(DriverInfoDetailData);
    UNREFERENCED_PARAMETER(DriverInfoDetailDataSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDriverInfoDetail(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData,     OPTIONAL
    IN  DWORD                   DriverInfoDetailDataSize,
    OUT PDWORD                  RequiredSize              OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves details about a particular driver.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver information structure to retrieve details about.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver information structure to retrieve
        details about.  If this parameter is not specified, then the driver
        referenced will be a member of the 'global' class driver list owned
        by the device information set.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure
        specifying the driver for whom details are to be retrieved.

    DriverInfoDetailData - Optionally, supplies the address of a
        SP_DRVINFO_DETAIL_DATA structure that will receive detailed information
        about the specified driver.  If this parameter is not specified, then
        DriverInfoDetailDataSize must be zero (this would be done if the caller
        was only interested in finding out how large of a buffer is required).
        If this parameter is specified, the cbSize field of this structure must
        be set to the size of the structure before calling this API. NOTE:
        The 'size of the structure' on input means sizeof(SP_DRVINFO_DETAIL_DATA).
        Note that this is essentially just a signature and is entirely separate
        from DriverInfoDetailDataSize. See below.

    DriverInfoDetailDataSize - Supplies the size, in bytes, of the
        DriverInfoDetailData buffer. To be valid this buffer must be at least
        sizeof(SP_DRVINFO_DETAIL_DATA)+sizeof(TCHAR) bytes, which allows
        storage of the fixed part of the structure and a single nul to
        terminate an empty multi_sz. (Depending on structure alignment,
        character width, and the data to be returned, this may actually be
        smaller than sizeof(SP_DRVINFO_DETAIL_DATA)).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the detailed driver information.
        This value includes both the size of the structure itself, and the
        additional number of bytes required for the variable-length character
        buffer at the end of it that holds the hardware ID and compatible IDs
        multi-sz list. (Depending on structure alignment, character width,
        and the data to be returned, this may actually be smaller than
        sizeof(SP_DRVINFO_DETAIL_DATA)).

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the specified driver information member and the user-supplied buffer are
    both valid, then this function is guaranteed to fill in all static fields in
    the SP_DRVINFO_DETAIL_DATA structure, and as many IDs as possible in the
    variable-length buffer at the end (while still maintaining a multi-sz format).
    The function will return failure (FALSE) in this case, with GetLastError
    returning ERROR_INSUFFICIENT_BUFFER, and RequiredSize (if specified) will
    contain the total number of bytes required for the structure with _all_ IDs.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    DWORD DriverType;
    PDRIVER_NODE DriverListHead, DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // Retrieve the driver type from the SP_DRVINFO_DATA structure
        // so we know which linked list to search.
        //
        if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
           (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
            DriverType = DriverInfoData->DriverType;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // NOTE: If we ever decide to do indexed searching like setupx, we
        // will need to be careful here, because we may not always have detailed
        // information around like we do today.  The assertions below indicate our
        // current assumption.
        //
        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    MYASSERT(DevInfoElem->InstallParamBlock.Flags & DI_DIDCLASS);
                    DriverListHead = DevInfoElem->ClassDriverHead;
                } else {
                    MYASSERT(pDeviceInfoSet->InstallParamBlock.Flags & DI_DIDCLASS);
                    DriverListHead = pDeviceInfoSet->ClassDriverHead;
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    MYASSERT(DevInfoElem->InstallParamBlock.Flags & DI_DIDCOMPAT);
                    DriverListHead = DevInfoElem->CompatDriverHead;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Find the referenced driver node in the appropriate list.
        //
        if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                   DriverInfoData,
                                                   NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        Err = DrvInfoDetailsFromDriverNode(pDeviceInfoSet,
                                           DriverNode,
                                           DriverInfoDetailData,
                                           DriverInfoDetailDataSize,
                                           RequiredSize
                                          );

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDestroyDriverInfoList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    )
/*++

Routine Description:

    This routine destroys a driver information list.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        the driver information list to be destroyed.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains the driver information list to be destroyed.
        If this parameter is not specified, then the global class driver list
        will be destroyed.

    DriverType - Specifies what type of driver list to destroy.  Must be one of
        the following values:

        SPDIT_CLASSDRIVER  - Destroy a class driver list.
        SPDIT_COMPATDRIVER - Destroy a compatible driver list.  DeviceInfoData
                             must be specified if this value is used.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the currently selected driver is a member of the list being destroyed,
    then the selection will be reset.

    If a class driver list is being destroyed, then the DI_FLAGSEX_DIDINFOLIST
    and DI_DIDCLASS flags will be reset for the corresponding device information
    set or device information element.  The DI_MULTMFGS flag will also be reset.

    If a compatible driver list is being destroyed, then the DI_FLAGSEX_DIDCOMPATINFO
    and DI_DIDCOMPAT flags will be reset for the corresponding device information
    element.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // If the selected driver is in the list we're deleting, then
            // reset the selection.
            //
            if(DevInfoElem->SelectedDriverType == DriverType) {
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                DevInfoElem->SelectedDriver = NULL;
            }

        } else {
            pDeviceInfoSet->SelectedClassDriver = NULL;
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    //
                    // Destroy class driver list for a particular device.
                    //
                    DriverNode = DevInfoElem->ClassDriverHead;
                    DevInfoElem->ClassDriverCount = 0;
                    DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                    DevInfoElem->ClassDriverEnumHint = NULL;
                    DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                    DevInfoElem->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                    DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;

                } else {
                    //
                    // Destroy the global class driver list.
                    //
                    DriverNode = pDeviceInfoSet->ClassDriverHead;
                    pDeviceInfoSet->ClassDriverCount = 0;
                    pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                    pDeviceInfoSet->ClassDriverEnumHint = NULL;
                    pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                    pDeviceInfoSet->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                    pDeviceInfoSet->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
                }

                //
                // Dereference the class driver list.
                //
                DereferenceClassDriverList(pDeviceInfoSet, DriverNode);

                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                    DevInfoElem->CompatDriverCount = 0;
                    DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                    DevInfoElem->CompatDriverEnumHint = NULL;
                    DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;
                    DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                    DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDriverInstallParamsA(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_A    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    DWORD rc;
    SP_DRVINFO_DATA_W driverInfoData;

    rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return SetupDiGetDriverInstallParamsW(
                DeviceInfoSet,
                DeviceInfoData,
                &driverInfoData,
                DriverInstallParams
                );
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetDriverInstallParamsW(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_W    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DriverInfoData);
    UNREFERENCED_PARAMETER(DriverInstallParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDriverInstallParams(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA      DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
/*++

Routine Description:

    This routine retrieves installation parameters for the specified driver.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver information structure to retrieve installation parameters for.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver information structure to retrieve
        installation parameters for.  If this parameter is not specified, then
        the driver referenced will be a member of the 'global' class driver list
        owned by the device information set.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure
        specifying the driver for whom installation parameters are to be
        retrieved.

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS structure
        that will receive the installation parameters for this driver.  The cbSize
        field of this structure must be set to the size, in bytes, of the
        structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    DWORD DriverType;
    PDRIVER_NODE DriverListHead, DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // Retrieve the driver type from the SP_DRVINFO_DATA structure
        // so we know which linked list to search.
        //
        if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
           (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
            DriverType = DriverInfoData->DriverType;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->ClassDriverHead;
                } else {
                    DriverListHead = pDeviceInfoSet->ClassDriverHead;
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->CompatDriverHead;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Find the referenced driver node in the appropriate list.
        //
        if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                   DriverInfoData,
                                                   NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // We have the driver node, now fill in the caller's buffer with
        // its installation parameters.
        //
        Err = GetDrvInstallParams(DriverNode,
                                  DriverInstallParams
                                 );

        if(Err == NO_ERROR) {
            //
            // Fill in the Win98-compatible DNF flags indicating whether this
            // driver node is from a compatible or class driver list.
            //
            DriverInstallParams->Flags |= (DriverType == SPDIT_CLASSDRIVER)
                                              ? DNF_CLASS_DRIVER
                                              : DNF_COMPATIBLE_DRIVER;

            //
            // Hide the private PDNF_xxx flags
            //
            DriverInstallParams->Flags &= ~PDNF_MASK;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiSetDriverInstallParamsA(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_A    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    SP_DRVINFO_DATA_W driverInfoData;
    DWORD rc;

    rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return SetupDiSetDriverInstallParamsW(
                DeviceInfoSet,
                DeviceInfoData,
                &driverInfoData,
                DriverInstallParams
                );
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiSetDriverInstallParamsW(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_W    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DriverInfoData);
    UNREFERENCED_PARAMETER(DriverInstallParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiSetDriverInstallParams(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA      DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
/*++

Routine Description:

    This routine sets installation parameters for the specified driver.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver information structure to set installation parameters for.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver information structure to set
        installation parameters for.  If this parameter is not specified, then
        the driver referenced will be a member of the 'global' class driver list
        owned by the device information set.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure
        specifying the driver for whom installation parameters are to be
        set.

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS structure
        specifying what the new driver install parameters should be.  The cbSize
        field of this structure must be set to the size, in bytes, of the
        structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    DWORD DriverType;
    PDRIVER_NODE DriverListHead, DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // Retrieve the driver type from the SP_DRVINFO_DATA structure
        // so we know which linked list to search.
        //
        if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
           (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
            DriverType = DriverInfoData->DriverType;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->ClassDriverHead;
                } else {
                    DriverListHead = pDeviceInfoSet->ClassDriverHead;
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->CompatDriverHead;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Find the referenced driver node in the appropriate list.
        //
        if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                   DriverInfoData,
                                                   NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // We have the driver node, now set its installation parameters
        // based on the caller-supplied buffer.
        //
        Err = SetDrvInstallParams(DriverInstallParams,
                                  DriverNode
                                 );

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
pSetupDoesInfContainDevIds(
    IN PLOADED_INF        Inf,
    IN PDRVSEARCH_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines whether any of the hardware or compatible IDs contained
    in the context structure are in the specified INF.

Arguments:

    Inf - Supplies the address of the loaded INF structure to be searched.

    Context - Supplies the address of the context structure containing hardware ID
        and compatible ID lists.

Return Value:

    If the INF contains any of the IDs listed in the context structure, the return
    value is TRUE, otherwise, it is FALSE.

Remarks:

    This routine accesses the string table within the loaded INF structure, but
    _does not_ obtain the INF lock.  This routine should only be called if the INF
    lock has been obtained, or if there is no possibility of contention (e.g., from
    withing the driver search callback routine).

--*/
{
    PTSTR CurDevId;
    DWORD StringLength;
    LONG i;
    PLONG pDevIdNum;

    for(i = 0; i < 2; i++) {

        for(pDevIdNum = Context->IdList[i]; *pDevIdNum != -1; pDevIdNum++) {
            //
            // First, obtain the device ID string corresponding to our stored-away
            // string table ID.
            //
            CurDevId = pStringTableStringFromId(Context->StringTable, *pDevIdNum);

            //
            // Now, try to lookup this string in the INF's string table.  Since we
            // added the device IDs to our Context string table case-insensitively,
            // then we know that they're already lowercase, so we speed up the lookup
            // even further by passing the STRTAB_ALREADY_LOWERCASE flag.
            //
            MYASSERT(!(Inf->Next)); // We'd better only have one of these at this point.

            if(pStringTableLookUpString(Inf->StringTable,
                                        CurDevId,
                                        &StringLength,
                                        NULL,
                                        NULL,
                                        STRTAB_CASE_INSENSITIVE | STRTAB_ALREADY_LOWERCASE,
                                        NULL,0) != -1) {
                //
                // We found a match--return success.
                //
                return TRUE;
            }
        }
    }

    //
    // No matches found.
    //
    return FALSE;
}


DWORD
BuildCompatListFromClassList(
    IN     PDRIVER_NODE       ClassDriverList,
    IN OUT PDRVSEARCH_CONTEXT Context
    )
/*++

Routine Description:

    This routine builds a compatible driver list for the specified device
    information element based on an existing class driver list for that element.

Arguments:

    ClassDriverList - Pointer to the head of a linked list of class driver nodes.

    Context - Supplies the address of a context structure used in building the
        compatible driver list.

Return Value:

    If successful, the return code is NO_ERROR, otherwise, it is a Win32 error code.

--*/
{
    PDRIVER_NODE CompatDriverNode = NULL;
    DWORD Err = NO_ERROR;
    BOOL InsertedAtHead;
    UINT Rank, CurrentRank, i;

    try {
        //
        // Examine each node in the class driver list, and copy any compatible drivers
        // into the compatible driver list.
        //
        for(; ClassDriverList; ClassDriverList = ClassDriverList->Next) {

            if(ClassDriverList->HardwareId == -1) {
                //
                // If there's no HardwareId, then we know there are no compatible IDs,
                // we can skip this driver node
                //
                continue;
            }

            if(pSetupCalculateRankMatch(ClassDriverList->HardwareId,
                                        2,
                                        Context->IdList,
                                        &Rank)) {
                //
                // Then we didn't hit a hardware ID match, so check the compatible IDs.
                //
                for(i = 0; i < ClassDriverList->NumCompatIds; i++) {

                    if(!pSetupCalculateRankMatch(ClassDriverList->CompatIdList[i],
                                                 i + 3,
                                                 Context->IdList,
                                                 &CurrentRank)) {
                        //
                        // Then we had a match on a hardware ID--that's the best we're gonna get.
                        //
                        Rank = CurrentRank;
                        break;

                    } else if(CurrentRank < Rank) {
                        //
                        // This new rank is better than our current rank.
                        //
                        Rank = CurrentRank;
                    }
                }
            }

            if(Rank != RANK_NO_MATCH) {
                //
                // Make a copy of the class driver node for our new compatible driver node.
                //
                if(CompatDriverNode = DuplicateDriverNode(ClassDriverList)) {
                    //
                    // Update the rank of our new driver node to what we just calculated.
                    //
                    CompatDriverNode->Rank = Rank;

                    //
                    // Mask out the duplicate description flag--this will be re-computed below.
                    //
                    CompatDriverNode->Flags &= ~DNF_DUPDESC;

                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //
                // Merge the new driver node into our existing list.
                // NOTE: Do not dereference CompatDriverNode after this call,
                // since it may have been a duplicate, in which case it
                // will be destroyed by this routine.
                //
                pSetupMergeDriverNode(Context, CompatDriverNode, &InsertedAtHead);
                CompatDriverNode = NULL;

                if(InsertedAtHead) {
                    //
                    // Update the device instance class to that of the new lowest-rank driver.
                    //
                    CopyMemory(&(Context->ClassGuid),
                               &(Context->DeviceInfoSet->GuidTable[ClassDriverList->GuidIndex]),
                               sizeof(GUID)
                              );
                    Context->Flags |= DRVSRCH_HASCLASSGUID;
                    *(Context->ClassName) = TEXT('\0');
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Err = ERROR_INVALID_PARAMETER;

        if(CompatDriverNode) {
            //
            // Make sure it didn't get partially linked into a list.
            //
            CompatDriverNode->Next = NULL;
            DestroyDriverNodes(CompatDriverNode, Context->DeviceInfoSet);
        }
    }

    if(Err != NO_ERROR) {
        DestroyDriverNodes(*(Context->pDriverListHead), Context->DeviceInfoSet);
        *(Context->pDriverListHead) = *(Context->pDriverListTail) = NULL;
        *(Context->pDriverCount) = 0;
    }

    return Err;
}


PDRIVER_NODE
DuplicateDriverNode(
    IN PDRIVER_NODE DriverNode
    )
/*++

Routine Description:

    This routine makes a copy of the specified driver node.

Arguments:

    DriverNode - Supplies the address of the driver node to be copied.

Return Value:

    If successful, the return value is the address of the newly-allocated copy.
    If failure (due to out-of-memory), the return value is NULL.

--*/
{
    PDRIVER_NODE NewDriverNode;
    BOOL FreeCompatIdList;

    if(!(NewDriverNode = MyMalloc(sizeof(DRIVER_NODE)))) {
        return NULL;
    }

    FreeCompatIdList = FALSE;

    try {

        CopyMemory(NewDriverNode, DriverNode, sizeof(DRIVER_NODE));

        NewDriverNode->Next = NULL;

        if(DriverNode->NumCompatIds) {
            //
            // Then allocate an array to contain them.
            //
            if(NewDriverNode->CompatIdList = MyMalloc(DriverNode->NumCompatIds * sizeof(LONG))) {

                FreeCompatIdList = TRUE;

                CopyMemory(NewDriverNode->CompatIdList,
                           DriverNode->CompatIdList,
                           DriverNode->NumCompatIds * sizeof(LONG)
                          );

            } else {
                MyFree(NewDriverNode);
                NewDriverNode = NULL;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(FreeCompatIdList) {
            MyFree(NewDriverNode->CompatIdList);
        }
        MyFree(NewDriverNode);
        NewDriverNode = NULL;
    }

    return NewDriverNode;
}


BOOL
WINAPI
SetupDiCancelDriverInfoSearch(
    IN HDEVINFO DeviceInfoSet
    )
/*++

Routine Description:

    This routine cancels a driver list search that is currently underway in a
    different thread.  This call is synchronous, i.e., it does not return until
    the driver search thread responds to the abort request.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which
        a driver list is being built.

Return Value:

    If there was a driver list search currently underway for the specified set,
    it will be aborted, and this routine will return TRUE once the abort is
    confirmed.

    Otherwise, the return value is FALSE, and GetLastError() will return
    ERROR_INVALID_HANDLE.

--*/
{
    DWORD Err = ERROR_INVALID_HANDLE;
    PDRVSEARCH_INPROGRESS_NODE DrvSearchNode;
    HANDLE SearchCancelledEvent;

    if(!LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {
        //
        // Uh-oh!  We're going away!
        //
        goto clean0;
    }

    try {
        //
        // Step through the list, looking for a node that matches our HDEVINFO.
        //
        for(DrvSearchNode = GlobalDrvSearchInProgressList.DrvSearchHead;
            DrvSearchNode;
            DrvSearchNode = DrvSearchNode->Next) {

            if(DrvSearchNode->DeviceInfoSet == DeviceInfoSet) {
                //
                // We found the node--therefore, this devinfo set is currently
                // tied up with a driver list search.  Set the 'CancelSearch' flag,
                // to notify the other thread that it should abort.
                //
                DrvSearchNode->CancelSearch = TRUE;
                SearchCancelledEvent = DrvSearchNode->SearchCancelledEvent;
                Err = NO_ERROR;
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
    }

    //
    // Very important that we unlock this list _before_ waiting on the other thread
    // to respond!
    //
    UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);

    if(Err == NO_ERROR) {
        //
        // We've signalled the other thread to abort--now wait for it to respond.
        //
        WaitForSingleObject(SearchCancelledEvent, INFINITE);
    }

clean0:

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
InitDrvSearchInProgressList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the global "Driver Search In-Progress" list, that is
    used to allow one thread to abort a driver search operation taking place in
    another thread.

Arguments:

    None

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    ZeroMemory(&GlobalDrvSearchInProgressList, sizeof(DRVSEARCH_INPROGRESS_LIST));
    return InitializeSynchronizedAccess(&GlobalDrvSearchInProgressList.Lock);
}


BOOL
DestroyDrvSearchInProgressList(
    VOID
    )
/*++

Routine Description:

    This routine destroys the global "Driver Search In-Progress" list, that is
    used to allow one thread to abort a driver search operation taking place in
    another thread.

Arguments:

    None

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    PDRVSEARCH_INPROGRESS_NODE DriverSearchNode;

    if(LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {
        //
        // We would hope that this list is empty, but that may not be the case.
        // We will traverse this list, and signal the event for each node we find.
        // That way, any threads still waiting for driver searches to abort can
        // continue on.  We do not free the memory associated with these nodes,
        // since it is 'owned' by the HDEVINFO, and that is where the responsibility
        // lies to free it.
        //
        try {
            for(DriverSearchNode = GlobalDrvSearchInProgressList.DrvSearchHead;
                DriverSearchNode;
                DriverSearchNode = DriverSearchNode->Next)
            {
                SetEvent(DriverSearchNode->SearchCancelledEvent);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;   // nothing
        }

        DestroySynchronizedAccess(&GlobalDrvSearchInProgressList.Lock);
        return TRUE;
    }

    return FALSE;
}


BOOL
ExtractDrvSearchInProgressNode(
    PDRVSEARCH_INPROGRESS_NODE Node
    )
/*++

Routine Description:

    This routine extracts the specified node out of the global "Driver Search
    In-Progress" list, and if its 'CancelSearch' flag is set, then it signals
    all waiting threads that it has responded to their cancel request.

Arguments:

    Node - Supplies the address of the node to be extracted from the list.

Return Value:

    If the node was found in the list, and the 'CancelSearch' flag was set, then
    the return value is TRUE, otherwise, it is FALSE.

--*/
{
    PDRVSEARCH_INPROGRESS_NODE PrevNode, CurNode;
    BOOL b;

    if(!LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {
        //
        // This should only happen if we're in the middle of a DLL_PROCESS_DETACH.
        // In this case, the clean-up code in CommonProcessAttach(FALSE) will signal
        // all waiting threads, so there's nothing we need to do.
        //
        return FALSE;
    }

    b = FALSE;

    try {
        //
        // Search through the list, looking for our node.
        //
        for(CurNode = GlobalDrvSearchInProgressList.DrvSearchHead, PrevNode = NULL;
            CurNode;
            PrevNode = CurNode, CurNode = CurNode->Next) {

            if(CurNode == Node) {
                //
                // We've found the specified node in the global list.
                //
                break;
            }
        }

        if(!CurNode) {
            //
            // The node wasn't in the list--probably because some kind of exception occurred
            // before it could be linked in.  Since it wasn't in the list, no other thread
            // could be waiting on it, so again, there's nothing to do.
            //
            goto clean0;
        }

        if(CurNode->CancelSearch) {
            b = TRUE;
            SetEvent(CurNode->SearchCancelledEvent);
        }

        //
        // Remove this node from the linked list.
        //
        if(PrevNode) {
            PrevNode->Next = CurNode->Next;
        } else {
            GlobalDrvSearchInProgressList.DrvSearchHead = CurNode->Next;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Access the flag variable so the compiler will respect our statement ordering w.r.t.
        // this value.
        //
        b = b;
    }

    UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devinst.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinst.h

Abstract:

    Private header file for setup device installation routines.

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

--*/


//
// For now, define the size (in characters) of a GUID string,
// including terminating NULL.
//
#define GUID_STRING_LEN (39)

//
// Define the maximum number of IDs that may be present in an ID list
// (either HardwareID or CompatibleIDs).
//
#define MAX_HCID_COUNT (64)

//
// Global strings used by device installer routines.  Sizes are included
// so that we can do sizeof() instead of lstrlen() to determine string
// length.
//
// The content of the following strings is defined in regstr.h:
//
extern CONST TCHAR pszNoUseClass[SIZECHARS(REGSTR_VAL_NOUSECLASS)],
                   pszNoInstallClass[SIZECHARS(REGSTR_VAL_NOINSTALLCLASS)],
                   pszNoDisplayClass[SIZECHARS(REGSTR_VAL_NODISPLAYCLASS)],
                   pszDeviceDesc[SIZECHARS(REGSTR_VAL_DEVDESC)],
                   pszDevicePath[SIZECHARS(REGSTR_VAL_DEVICEPATH)],
                   pszPathSetup[SIZECHARS(REGSTR_PATH_SETUP)],
                   pszKeySetup[SIZECHARS(REGSTR_KEY_SETUP)],
                   pszPathRunOnce[SIZECHARS(REGSTR_PATH_RUNONCE)],
                   pszSourcePath[SIZECHARS(REGSTR_VAL_SRCPATH)],
                   pszSvcPackPath[SIZECHARS(REGSTR_VAL_SVCPAKSRCPATH)],
                   pszDriverCachePath[SIZECHARS(REGSTR_VAL_DRIVERCACHEPATH)],
                   pszBootDir[SIZECHARS(REGSTR_VAL_BOOTDIR)],
                   pszInsIcon[SIZECHARS(REGSTR_VAL_INSICON)],
                   pszInstaller32[SIZECHARS(REGSTR_VAL_INSTALLER_32)],
                   pszEnumPropPages32[SIZECHARS(REGSTR_VAL_ENUMPROPPAGES_32)],
                   pszInfPath[SIZECHARS(REGSTR_VAL_INFPATH)],
                   pszInfSection[SIZECHARS(REGSTR_VAL_INFSECTION)],
                   pszDrvDesc[SIZECHARS(REGSTR_VAL_DRVDESC)],
                   pszHardwareID[SIZECHARS(REGSTR_VAL_HARDWAREID)],
                   pszCompatibleIDs[SIZECHARS(REGSTR_VAL_COMPATIBLEIDS)],
                   pszDriver[SIZECHARS(REGSTR_VAL_DRIVER)],
                   pszConfigFlags[SIZECHARS(REGSTR_VAL_CONFIGFLAGS)],
                   pszMfg[SIZECHARS(REGSTR_VAL_MFG)],
                   pszService[SIZECHARS(REGSTR_VAL_SERVICE)],
                   pszProviderName[SIZECHARS(REGSTR_VAL_PROVIDER_NAME)],
                   pszFriendlyName[SIZECHARS(REGSTR_VAL_FRIENDLYNAME)],
                   pszServicesRegPath[SIZECHARS(REGSTR_PATH_SERVICES)],
                   pszLegacyInfOption[SIZECHARS(REGSTR_VAL_LEGACYINFOPT)],
                   pszInfSectionExt[SIZECHARS(REGSTR_VAL_INFSECTIONEXT)],
                   pszDeviceClassesPath[SIZECHARS(REGSTR_PATH_DEVICE_CLASSES)],
                   pszDeviceInstance[SIZECHARS(REGSTR_VAL_DEVICE_INSTANCE)],
                   pszDefault[SIZECHARS(REGSTR_VAL_DEFAULT)],
                   pszControl[SIZECHARS(REGSTR_KEY_CONTROL)],
                   pszLinked[SIZECHARS(REGSTR_VAL_LINKED)],
                   pszDeviceParameters[SIZECHARS(REGSTR_KEY_DEVICEPARAMETERS)],
                   pszLocationInformation[SIZECHARS(REGSTR_VAL_LOCATION_INFORMATION)],
                   pszCapabilities[SIZECHARS(REGSTR_VAL_CAPABILITIES)],
                   pszUiNumber[SIZECHARS(REGSTR_VAL_UI_NUMBER)],
                   pszRemovalPolicyOverride[SIZECHARS(REGSTR_VAL_REMOVAL_POLICY)],
                   pszUpperFilters[SIZECHARS(REGSTR_VAL_UPPERFILTERS)],
                   pszLowerFilters[SIZECHARS(REGSTR_VAL_LOWERFILTERS)],
                   pszMatchingDeviceId[SIZECHARS(REGSTR_VAL_MATCHINGDEVID)],
                   pszBasicProperties32[SIZECHARS(REGSTR_VAL_BASICPROPERTIES_32)],
                   pszCoInstallers32[SIZECHARS(REGSTR_VAL_COINSTALLERS_32)],
                   pszPathCoDeviceInstallers[SIZECHARS(REGSTR_PATH_CODEVICEINSTALLERS)],
                   pszSystem[SIZECHARS(REGSTR_KEY_SYSTEM)],
                   pszDrvSignPath[SIZECHARS(REGSTR_PATH_DRIVERSIGN)],
                   pszNonDrvSignPath[SIZECHARS(REGSTR_PATH_NONDRIVERSIGN)],
                   pszDrvSignPolicyPath[SIZECHARS(REGSTR_PATH_DRIVERSIGN_POLICY)],
                   pszNonDrvSignPolicyPath[SIZECHARS(REGSTR_PATH_NONDRIVERSIGN_POLICY)],
                   pszDrvSignPolicyValue[SIZECHARS(REGSTR_VAL_POLICY)],
                   pszDrvSignBehaviorOnFailedVerifyDS[SIZECHARS(REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY)],
                   pszDriverDate[SIZECHARS(REGSTR_VAL_DRIVERDATE)],
                   pszDriverDateData[SIZECHARS(REGSTR_VAL_DRIVERDATEDATA)],
                   pszDriverVersion[SIZECHARS(REGSTR_VAL_DRIVERVERSION)],
                   pszDevSecurity[SIZECHARS(REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR)],
                   pszDevType[SIZECHARS(REGSTR_VAL_DEVICE_TYPE)],
                   pszExclusive[SIZECHARS(REGSTR_VAL_DEVICE_EXCLUSIVE)],
                   pszCharacteristics[SIZECHARS(REGSTR_VAL_DEVICE_CHARACTERISTICS)],
                   pszUiNumberDescFormat[SIZECHARS(REGSTR_VAL_UI_NUMBER_DESC_FORMAT)],
                   pszReinstallPath[SIZECHARS(REGSTR_PATH_REINSTALL)],
                   pszReinstallDeviceInstanceIds[SIZECHARS(REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS)],
                   pszReinstallDisplayName[SIZECHARS(REGSTR_VAL_REINSTALL_DISPLAYNAME)],
                   pszReinstallString[SIZECHARS(REGSTR_VAL_REINSTALL_STRING)];


//
// Other misc. global strings:
//
#define DISTR_INF_WILDCARD                (TEXT("*.inf"))
#define DISTR_OEMINF_WILDCARD             (TEXT("oem*.inf"))
#define DISTR_CI_DEFAULTPROC              (TEXT("ClassInstall"))
#define DISTR_SPACE_LPAREN                (TEXT(" ("))
#define DISTR_RPAREN                      (TEXT(")"))
#define DISTR_UNIQUE_SUBKEY               (TEXT("\\%04u"))
#define DISTR_OEMINF_GENERATE             (TEXT("%s\\oem%d.inf"))
#define DISTR_OEMINF_DEFAULTPATH          (TEXT("A:\\"))
#define DISTR_DEFAULT_SERVICE             (TEXT("Default Service"))
#define DISTR_GUID_NULL                   (TEXT("{00000000-0000-0000-0000-000000000000}"))
#define DISTR_EVENTLOG                    (TEXT("\\EventLog"))
#define DISTR_GROUPORDERLIST_PATH         (REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\GroupOrderList"))
#define DISTR_SERVICEGROUPORDER_PATH      (REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\ServiceGroupOrder"))
#define DISTR_OPTIONS                     (TEXT("Options"))
#define DISTR_OPTIONSTEXT                 (TEXT("OptionsText"))
#define DISTR_LANGUAGESSUPPORTED          (TEXT("LanguagesSupported"))
#define DISTR_RUNONCE_EXE                 (TEXT("runonce"))
#define DISTR_GRPCONV                     (TEXT("grpconv -o"))
#define DISTR_GRPCONV_NOUI                (TEXT("grpconv -u"))
#define DISTR_DEFAULT_SYSPART             (TEXT("C:\\"))
#define DISTR_BASICPROP_DEFAULTPROC       (TEXT("BasicProperties"))
#define DISTR_ENUMPROP_DEFAULTPROC        (TEXT("EnumPropPages"))
#define DISTR_CODEVICEINSTALL_DEFAULTPROC (TEXT("CoDeviceInstall"))
#define DISTR_DRIVER_OBJECT_PATH_PREFIX   (TEXT("\\DRIVER\\"))      // must be uppercase!
#define DISTR_DRIVER_SIGNING_CLASSES      (TEXT("DriverSigningClasses"))
#define DISTR_PATH_EMBEDDED_NT_SECURITY   (TEXT("Software\\Microsoft\\EmbeddedNT\\Security"))
#define DISTR_VAL_MINIMIZE_FOOTPRINT      (TEXT("MinimizeFootprint"))
#define DISTR_VAL_DISABLE_SCE             (TEXT("DisableSCE"))

extern CONST TCHAR pszInfWildcard[SIZECHARS(DISTR_INF_WILDCARD)],
                   pszOemInfWildcard[SIZECHARS(DISTR_OEMINF_WILDCARD)],
                   pszCiDefaultProc[SIZECHARS(DISTR_CI_DEFAULTPROC)],
                   pszSpaceLparen[SIZECHARS(DISTR_SPACE_LPAREN)],
                   pszRparen[SIZECHARS(DISTR_RPAREN)],
                   pszUniqueSubKey[SIZECHARS(DISTR_UNIQUE_SUBKEY)],
                   pszOemInfGenerate[SIZECHARS(DISTR_OEMINF_GENERATE)],
                   pszOemInfDefaultPath[SIZECHARS(DISTR_OEMINF_DEFAULTPATH)],
                   pszDefaultService[SIZECHARS(DISTR_DEFAULT_SERVICE)],
                   pszGuidNull[SIZECHARS(DISTR_GUID_NULL)],
                   pszEventLog[SIZECHARS(DISTR_EVENTLOG)],
                   pszGroupOrderListPath[SIZECHARS(DISTR_GROUPORDERLIST_PATH)],
                   pszServiceGroupOrderPath[SIZECHARS(DISTR_SERVICEGROUPORDER_PATH)],
                   pszOptions[SIZECHARS(DISTR_OPTIONS)],
                   pszOptionsText[SIZECHARS(DISTR_OPTIONSTEXT)],
                   pszLanguagesSupported[SIZECHARS(DISTR_LANGUAGESSUPPORTED)],
                   pszRunOnceExe[SIZECHARS(DISTR_RUNONCE_EXE)],
                   pszGrpConv[SIZECHARS(DISTR_GRPCONV)],
                   pszGrpConvNoUi[SIZECHARS(DISTR_GRPCONV_NOUI)],
                   pszDefaultSystemPartition[SIZECHARS(DISTR_DEFAULT_SYSPART)],
                   pszBasicPropDefaultProc[SIZECHARS(DISTR_BASICPROP_DEFAULTPROC)],
                   pszEnumPropDefaultProc[SIZECHARS(DISTR_ENUMPROP_DEFAULTPROC)],
                   pszCoInstallerDefaultProc[SIZECHARS(DISTR_CODEVICEINSTALL_DEFAULTPROC)],
                   pszDriverObjectPathPrefix[SIZECHARS(DISTR_DRIVER_OBJECT_PATH_PREFIX)],
                   pszDriverSigningClasses[SIZECHARS(DISTR_DRIVER_SIGNING_CLASSES)],
                   pszEmbeddedNTSecurity[SIZECHARS(DISTR_PATH_EMBEDDED_NT_SECURITY)],
                   pszMinimizeFootprint[SIZECHARS(DISTR_VAL_MINIMIZE_FOOTPRINT)],
                   pszDisableSCE[SIZECHARS(DISTR_VAL_DISABLE_SCE)];


//
// Global translation array for finding CM_DRP_* ordinal
// given property name or SPDRP_* value.
//
extern STRING_TO_DATA InfRegValToDevRegProp[];
extern STRING_TO_DATA InfRegValToClassRegProp[];

//
// Define a macro that does the DI-to-CM property translation
//
#define SPDRP_TO_CMDRP(i) (InfRegValToDevRegProp[(i)].Data)
//
// Class registry translation uses the same table
//
#define SPCRP_TO_CMCRP(i) (InfRegValToClassRegProp[(i)].Data)

//
// Define a value indicating a no-match ranking.
//
#define RANK_NO_MATCH (0xFFFFFFFF)

//
// Driver ranking bases. Lower Ranks are better.  Rank 0 is the best possible Rank.
// Any Rank less than 0x00001000 is a HardwareID match that is considered a good match.
//
#define RANK_HWID_INF_HWID_BASE 0x00000000      // For match with Hardware's HardwareID and INF's HardwareID
#define RANK_HWID_INF_CID_BASE  0x00001000      // For match with Hardware's HardwareID and INF's CompatibleID
#define RANK_CID_INF_HWID_BASE  0x00002000      // For match with Hardware's CompatibleID and INF's HardwareID
#define RANK_CID_INF_CID_BASE   0x00003000      // For match with Hardware's CompatibleID and INF's CompatibleID
#define RANK_CID_INF_CID_INC    0x00000100      // added to RANK_CID_INF_CID_BASE for each CompatID location

//
// Define special value used to indicate that one of our enumeration 'hint'
// indices is invalid.
//
#define INVALID_ENUM_INDEX  (0xFFFFFFFF)

//
// Define prototype of callback function supplied by class installers.
//
typedef DWORD (CALLBACK* CLASS_INSTALL_PROC) (
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

//
// Define prototype of property sheet provider function--basically, an
// ExtensionPropSheetPageProc function with a (potentially) different name.
//
typedef BOOL (CALLBACK* PROPSHEET_PROVIDER_PROC) (
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    );

//
// Define prototype of the co-installer function.
//
typedef DWORD (CALLBACK* COINSTALLER_PROC) (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData, OPTIONAL
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );


//
// Define structure for the internal representation of a single
// driver information node.
//
typedef struct _DRIVER_NODE {

    struct _DRIVER_NODE *Next;

    UINT Rank;

    FILETIME InfDate;

    LONG DrvDescription;

    //
    // Have to have both forms of the strings below because we must have both
    // case-insensitive (i.e., atom-like) behavior, and keep the original case
    // for display.
    //
    LONG DevDescription;
    LONG DevDescriptionDisplayName;

    LONG ProviderName;
    LONG ProviderDisplayName;

    LONG MfgName;
    LONG MfgDisplayName;

    LONG InfFileName;

    LONG InfSectionName;

    //
    // The following field is only valid if this is a legacy INF driver node.  It
    // tells us what language to use when running the INF interpreter.
    //
    LONG LegacyInfLang;

    LONG HardwareId;

    DWORD NumCompatIds;

    PLONG CompatIdList;

    //
    // Store the index of the device ID that a compatible match was based on.  If
    // this was a HardwareId match, this value is -1, otherwise, it is the index
    // into the CompatIdList array of the device ID that matched.
    //
    LONG MatchingDeviceId;

    DWORD Flags;

    DWORD_PTR PrivateData;

    //
    // Store the GUID index INF's class from which this node came.  We need to do this,
    // in order to easily determine the class of the driver node (e.g., so that we
    // can change the device's class when a new driver node is selected).
    //
    LONG GuidIndex;

    FILETIME  DriverDate;
    DWORDLONG DriverVersion;

} DRIVER_NODE, *PDRIVER_NODE;


//
// Define structure to contain a co-installer entry.
//
typedef struct _COINSTALLER_NODE {
    HINSTANCE        hinstCoInstaller;
    COINSTALLER_PROC CoInstallerEntryPoint;
    HANDLE           CoInstallerFusionContext;
} COINSTALLER_NODE, *PCOINSTALLER_NODE;

//
// Define structure containing context information about co-installer
// callbacks for the duration of a DIF call.
//
typedef struct _COINSTALLER_INTERNAL_CONTEXT {
    COINSTALLER_CONTEXT_DATA Context;
    BOOL                     DoPostProcessing;
    COINSTALLER_PROC         CoInstallerEntryPoint;
    HANDLE                   CoInstallerFusionContext;
} COINSTALLER_INTERNAL_CONTEXT, *PCOINSTALLER_INTERNAL_CONTEXT;


//
// Define structure for the internal storage of device installation
// parameters.
//
typedef struct _DEVINSTALL_PARAM_BLOCK {

    //
    // Flags for controlling installation and UI functions.
    //
    DWORD Flags;
    DWORD FlagsEx;

    //
    // Specifies the window handle that will own UI related to this
    // installation.  MAY BE NULL.
    //
    HWND hwndParent;

    //
    // Installation message handling parameters.
    //
    PSP_FILE_CALLBACK InstallMsgHandler;
    PVOID             InstallMsgHandlerContext;
    BOOL              InstallMsgHandlerIsNativeCharWidth;

    //
    // Handle to a caller-supplied copy-queue.  If this handle is present,
    // then file copy/rename/delete operations will be queued to this handle
    // instead of being acted upon.  This will only happen if the DI_NOVCP
    // bit is set in the Flags field.
    // If no caller-supplied queue is present, this value is NULL
    // (_not_ INVALID_HANDLE_VALUE).
    //
    HSPFILEQ UserFileQ;

    //
    // Private DWORD reserved for Class Installer usage.
    //
    ULONG_PTR ClassInstallReserved;

    //
    // Specifies the string table index of an optional INF file
    // path.  If the string is not supplied, its index will be -1.
    //
    LONG DriverPath;

    //
    // Pointer to class installer parameters.  The first field of any class
    // installer parameter block is always a SP_CLASSINSTALL_HEADER structure.
    // The cbSize field of that structure gives the size, in bytes, of the header
    // (used for versioning), and the InstallFunction field gives the DI_FUNCTION
    // code that indicates how the parameter buffer is to be interpreted.
    // MAY BE NULL!
    //
    PSP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD ClassInstallParamsSize;

    //
    // THE FOLLOWING PARAMETERS ARE NOT EXPOSED TO CALLERS (i.e., via
    // SetupDi(Get|Set)DeviceInstallParams).
    //

    HINSTANCE hinstClassInstaller;
    CLASS_INSTALL_PROC ClassInstallerEntryPoint;
    HANDLE             ClassInstallerFusionContext;

    HINSTANCE hinstClassPropProvider;
    PROPSHEET_PROVIDER_PROC ClassEnumPropPagesEntryPoint;
    HANDLE                  ClassEnumPropPagesFusionContext;

    HINSTANCE hinstDevicePropProvider;
    PROPSHEET_PROVIDER_PROC DeviceEnumPropPagesEntryPoint;
    HANDLE                  DeviceEnumPropPagesFusionContext;

    HINSTANCE hinstBasicPropProvider;
    PROPSHEET_PROVIDER_PROC EnumBasicPropertiesEntryPoint;
    HANDLE                  EnumBasicPropertiesFusionContext;

    //
    // Maintain a list of co-installers to be called along with the class installer.
    // The count will be -1 if the list hasn't been retrieved yet.
    //
    LONG CoInstallerCount;
    PCOINSTALLER_NODE CoInstallerList;

    //
    // Logging context -- this is only here because this struct is shared
    // by both DEVINFO_ELEM and DEVINFO_SET.
    //
    PSETUP_LOG_CONTEXT LogContext;

} DEVINSTALL_PARAM_BLOCK, *PDEVINSTALL_PARAM_BLOCK;


//
// Define structures used for associating lists of interface devices with
// devinfo elements.
//
typedef struct _INTERFACE_DEVICE_NODE {

    struct _INTERFACE_DEVICE_NODE *Next;

    //
    // String table ID for this interface device's symbolic link name.
    //
    LONG SymLinkName;

    //
    // Store the interface class GUID index in each node.  We need to do this,
    // in order to easily determine the class of the node.
    //
    LONG GuidIndex;

    //
    // The Flags field contains the same flags as the client sees in their
    // SP_INTERFACE_DEVICE_DATA structure.
    //
    DWORD Flags;

    //
    // Store a back-pointer to the devinfo element, because interface devices
    // may be enumerated outside the context of a device information element, and
    // we need to know how to get back to the owning device instance.
    //
    struct _DEVINFO_ELEM *OwningDevInfoElem;

} INTERFACE_DEVICE_NODE, *PINTERFACE_DEVICE_NODE;

typedef struct _INTERFACE_CLASS_LIST {
    LONG                   GuidIndex;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    PINTERFACE_DEVICE_NODE InterfaceDeviceTruncateNode;  // used for rollback.
    DWORD                  InterfaceDeviceCount;
} INTERFACE_CLASS_LIST, *PINTERFACE_CLASS_LIST;


//
// Define flags for DiElemFlags field of DEVINFO_ELEM structure.
//
#define DIE_IS_PHANTOM      (0x00000001) // is this a phantom (not live) devinst?
#define DIE_IS_REGISTERED   (0x00000002) // has this devinst been registered?
#define DIE_IS_LOCKED       (0x00000004) // are we explicitly locked during some UI
                                         // operation (e.g., wizard)?

//
// Define structure for the internal representation of a single
// device information element.
//
typedef struct _DEVINFO_ELEM {
    //
    // Store the address of the containing devinfo set at the beginning of
    // this structure.  This is used for validation of a caller-supplied
    // SP_DEVINFO_DATA, and is more efficient than the previous method of
    // searching through all devinfo elements in the set to make sure the
    // specified element exists in the set.  This field should be zeroed
    // out when this element is destroyed.
    //
    struct _DEVICE_INFO_SET *ContainingDeviceInfoSet;

    //
    // Pointer to the next element in the set.
    //
    struct _DEVINFO_ELEM *Next;

    //
    // Specifies the device instance handle for this device.  This will
    // be a phantom device instance handle if DIE_IS_PHANTOM is set.
    //
    // This should always contain a handle, unless the device instance
    // handle could not be re-opened after a re-enumeration (in which case,
    // the DI_NEEDREBOOT flag will be set), or if the device information
    // element was globally removed or config-specific removed from the last
    // hardware profile.
    //
    DEVINST DevInst;

    //
    // Specifies the GUID for this device's class.
    //
    GUID ClassGuid;

    //
    // Specifies flags pertaining to this device information element.
    // These DIE_* flags are for internal use only.
    //
    DWORD DiElemFlags;

    //
    // List of class drivers for this element.
    //
    UINT          ClassDriverCount;
    PDRIVER_NODE  ClassDriverHead;
    PDRIVER_NODE  ClassDriverTail;

    //
    // class drivernode index 'hint' to speed up enumeration via
    // SetupDiEnumDriverInfo
    //
    PDRIVER_NODE ClassDriverEnumHint;       // may be NULL
    DWORD        ClassDriverEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // List of compatible drivers for this element.
    //
    UINT          CompatDriverCount;
    PDRIVER_NODE  CompatDriverHead;
    PDRIVER_NODE  CompatDriverTail;

    //
    // compatible drivernode index 'hint' to speed up enumeration via
    // SetupDiEnumDriverInfo
    //
    PDRIVER_NODE CompatDriverEnumHint;       // may be NULL
    DWORD        CompatDriverEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // Pointer to selected driver for this element (may be
    // NULL if none currently selected).  Whether this is a
    // class or compatible driver is specified by the
    // SelectedDriverType field.
    //
    PDRIVER_NODE  SelectedDriver;
    DWORD         SelectedDriverType;

    //
    // Installation parameter block.
    //
    DEVINSTALL_PARAM_BLOCK InstallParamBlock;

    //
    // Specifies the string table index of the device description.
    // If no description is known, this value will be -1.
    //
    // We store this string twice--once case-sensitively and once case-insensitively,
    // because we need it for displaying _and_ for fast lookup.
    //
    LONG DeviceDescription;
    LONG DeviceDescriptionDisplayName;

    //
    // Maintain an array of interface device lists.  These lists represent the interface
    // devices owned by this device instance (but only those that have been retrieved, e.g.
    // by calling SetupDiGetClassDevs(...DIGCF_INTERFACEDEVICE...)
    //
    // (This array pointer may be NULL.)
    //
    PINTERFACE_CLASS_LIST InterfaceClassList;
    DWORD                 InterfaceClassListSize;

    //
    // Extra (non-class installer) data associated with each device information element.
    // Only exposed via private API for use during GUI-mode setup.
    //
    DWORD Context;

} DEVINFO_ELEM, *PDEVINFO_ELEM;


//
// Structure containing dialog data for wizard pages.  (Amalgamation of
// DIALOGDATA structures defined in setupx and sysdm.)
//
typedef struct _SP_DIALOGDATA {

    INT             iBitmap;              // index into mini-icon bitmap

    HDEVINFO        DevInfoSet;           // DevInfo set we're working with
    PDEVINFO_ELEM   DevInfoElem;          // if DD_FLAG_USE_DEVINFO_ELEM flag set
    UINT            flags;

    HWND            hwndDrvList;          // window of the driver list
    HWND            hwndMfgList;          // window of the Manufacturer list

    BOOL            bShowCompat;

    BOOL            bKeeplpCompatDrvList;
    BOOL            bKeeplpClassDrvList;
    BOOL            bKeeplpSelectedDrv;

    LONG            iCurDesc;             // string table index for the description of currently
                                          // selected driver (or to-be-selected driver)

    BOOL            AuxThreadRunning;       // Is our class driver search thread still running?
    DWORD           PendingAction;          // What (if anything) should we do when it finishes?
    int             CurSelectionForSuccess; // If we have a pending successful return, what is the
                                            // listbox index for the successful selection?
    HIMAGELIST      hImageList;

    HFONT           hFontNormal;
    HFONT           hFontBold;

} SP_DIALOGDATA, *PSP_DIALOGDATA;

//
// Flags for SP_DIALOGDATA.flags:
//
#define DD_FLAG_USE_DEVINFO_ELEM   0x00000001
#define DD_FLAG_IS_DIALOGBOX       0x00000002
#define DD_FLAG_CLASSLIST_FAILED   0x00000004
#define DD_FLAG_SHOWSIMILARDRIVERS 0x00000008

//
// Pending Action codes used in the NEWDEVWIZ_DATA structure to indicate what
// should happen as soon as the auxilliary class driver search thread notifies us
// of its termination.
//
#define PENDING_ACTION_NONE             0
#define PENDING_ACTION_SELDONE          1
#define PENDING_ACTION_SHOWCLASS        2
#define PENDING_ACTION_CANCEL           3
#define PENDING_ACTION_OEM              4
#define PENDING_ACTION_WINDOWSUPDATE    5

//
// Icons that are associated with an item in the list view.
//
#define IMAGE_ICON_NOT_SIGNED           0
#define IMAGE_ICON_SIGNED               1

//
// Define structure used for internal state storage by Device Installer
// wizard pages.  (From NEWDEVWIZ_INSTANCE struct in Win95 sysdm.)
//
typedef struct _NEWDEVWIZ_DATA {

    SP_INSTALLWIZARD_DATA InstallData;

    SP_DIALOGDATA         ddData;

    BOOL                  bInit;
    UINT_PTR              idTimer;

} NEWDEVWIZ_DATA, *PNEWDEVWIZ_DATA;

//
// Define wizard page object structure used to ensure that wizard page
// buffer is kept as long as needed, and destroyed when no longer in use.
//
typedef struct _WIZPAGE_OBJECT {

    struct _WIZPAGE_OBJECT *Next;

    DWORD RefCount;

    PNEWDEVWIZ_DATA ndwData;

} WIZPAGE_OBJECT, *PWIZPAGE_OBJECT;


//
// Define driver list object structure used in the device information set
// to keep track of the various class driver lists that devinfo elements
// have referenced.
//
typedef struct _DRIVER_LIST_OBJECT {

    struct _DRIVER_LIST_OBJECT *Next;

    DWORD RefCount;

    //
    // We keep track of what parameters were used to create this driver
    // list, so that we can copy them to a new devinfo element during
    // inheritance.
    //
    DWORD ListCreationFlags;
    DWORD ListCreationFlagsEx;
    LONG ListCreationDriverPath;

    //
    // Also, keep track of what class this list was built for.  Although a
    // device's class may change, this GUID remains constant.
    //
    GUID ClassGuid;

    //
    // Actual driver list.  (This is also used as an ID used to find the
    // driver list object given a driver list head.  We can do this, since
    // we know that once a driver list is built, the head element never
    // changes.)
    //
    PDRIVER_NODE DriverListHead;

} DRIVER_LIST_OBJECT, *PDRIVER_LIST_OBJECT;


//
// Define node that tracks addition module handles to be unloaded when the
// device information set is destroyed.  This is used when a class installer,
// property page provider, or co-installer becomes invalid (e.g., as a result
// of a change in the device's class), but we can't unload the module yet.
//

typedef struct _MODULE_HANDLE_LIST_INSTANCE {
    HINSTANCE ModuleHandle;
    HANDLE    FusionContext;
} MODULE_HANDLE_LIST_INSTANCE,*PMODULE_HANDLE_LIST_INSTANCE;

typedef struct _MODULE_HANDLE_LIST_NODE {

    struct _MODULE_HANDLE_LIST_NODE *Next;

    DWORD ModuleCount;
    MODULE_HANDLE_LIST_INSTANCE ModuleList[ANYSIZE_ARRAY];

} MODULE_HANDLE_LIST_NODE, *PMODULE_HANDLE_LIST_NODE;

//
// Define structure for the internal representation of a
// device information set.
//
typedef struct _DEVICE_INFO_SET {

    //
    // Specifies whether there is a class GUID associated
    // with this set, and if so, what it is.
    //
    BOOL          HasClassGuid;
    GUID          ClassGuid;

    //
    // List of class drivers for this set.
    //
    UINT          ClassDriverCount;
    PDRIVER_NODE  ClassDriverHead;
    PDRIVER_NODE  ClassDriverTail;

    //
    // class drivernode index 'hint' to speed up enumeration via
    // SetupDiEnumDriverInfo
    //
    PDRIVER_NODE ClassDriverEnumHint;       // may be NULL
    DWORD        ClassDriverEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // Pointer to selected class driver for this device information
    // set (may be NULL if none currently selected).
    //
    PDRIVER_NODE  SelectedClassDriver;

    //
    // List of device information elements in the set.
    //
    UINT          DeviceInfoCount;
    PDEVINFO_ELEM DeviceInfoHead;
    PDEVINFO_ELEM DeviceInfoTail;

    //
    // devinfo element index 'hint' to speed up enumeration via
    // SetupDiEnumDeviceInfo
    //
    PDEVINFO_ELEM DeviceInfoEnumHint;       // may be NULL
    DWORD         DeviceInfoEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // Pointer to selected device for this device information set (may
    // be NULL if none currently selected).  This is used during
    // installation wizard.
    //
    PDEVINFO_ELEM SelectedDevInfoElem;

    //
    // Installation parameter block (for global class driver list, if
    // present).
    //
    DEVINSTALL_PARAM_BLOCK InstallParamBlock;

    //
    // Private string table.
    //
    PVOID StringTable;

    //
    // Maintain a list of currently-active wizard objects.  This allows us
    // to do the refcounting correctly for each object, and to keep the
    // set from being deleted until all wizard objects are destroyed.
    //
    PWIZPAGE_OBJECT WizPageList;

    //
    // Maintain a list of class driver lists that are currently being referenced
    // by various devinfo elements, as well as by the device info set itself
    // (i.e., for the current global class driver list.)
    //
    PDRIVER_LIST_OBJECT ClassDrvListObjectList;

    //
    // Maintain a reference count on how many times a thread has acquired
    // the lock on this device information set.  This indicates how deeply
    // nested we currently are in device installer calls.  The set can only
    // be deleted if this count is 1.
    //
    DWORD LockRefCount;

    //
    // Maintain a list of additional module handles we need to do a FreeLibrary
    // on when this device information set is destroyed.
    //
    PMODULE_HANDLE_LIST_NODE ModulesToFree;

    //
    // Maintain an array of class GUIDs for all driver nodes and device
    // interfaces used by members of this set.  (May be NULL.)
    //
    LPGUID GuidTable;
    DWORD  GuidTableSize;

    //
    // ConfigMgr machine name (string id) and handle, if this is a remote HDEVINFO set.
    //
    LONG     MachineName;   // -1 if local
    HMACHINE hMachine;      // NULL if local

    //
    // Synchronization
    //
    MYLOCK Lock;

} DEVICE_INFO_SET, *PDEVICE_INFO_SET;

#define LockDeviceInfoSet(d)   BeginSynchronizedAccess(&((d)->Lock))

#define UnlockDeviceInfoSet(d)          \
                                        \
    ((d)->LockRefCount)--;              \
    EndSynchronizedAccess(&((d)->Lock))


//
// Define structures for global mini-icon storage.
//
typedef struct _CLASSICON {

    CONST GUID        *ClassGuid;
    UINT               MiniBitmapIndex;
    struct _CLASSICON *Next;

} CLASSICON, *PCLASSICON;

typedef struct _MINI_ICON_LIST {

    //
    // HDC for memory containing mini-icon bitmap
    //
    HDC hdcMiniMem;

    //
    // Handle to the bitmap image for the mini-icons
    //
    HBITMAP hbmMiniImage;

    //
    // Handle to the bitmap image for the mini-icon mask.
    //
    HBITMAP hbmMiniMask;

    //
    // Number of mini-icons in the bitmap
    //
    UINT NumClassImages;

    //
    // Head of list for installer-provided class icons.
    //
    PCLASSICON ClassIconList;

    //
    // Synchronization
    //
    MYLOCK Lock;

} MINI_ICON_LIST, *PMINI_ICON_LIST;

#define LockMiniIconList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockMiniIconList(d) EndSynchronizedAccess(&((d)->Lock))

//
// Global mini-icon list.
//
extern MINI_ICON_LIST GlobalMiniIconList;




typedef struct _CLASS_IMAGE_LIST {

    //
    // Index of the "Unknown" class image
    //
    int         UnknownImageIndex;

    //
    // List of class guids
    //
    LPGUID      ClassGuidList;

    //
    // Head of linked list of class icons.
    //
    PCLASSICON  ClassIconList;

    //
    // Synchronization
    //
    MYLOCK      Lock;

} CLASS_IMAGE_LIST, *PCLASS_IMAGE_LIST;


#define LockImageList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockImageList(d) EndSynchronizedAccess(&((d)->Lock))


typedef struct _DRVSEARCH_INPROGRESS_NODE {

    struct _DRVSEARCH_INPROGRESS_NODE *Next;

    //
    // Handle of device information set for which driver list is
    // currently being built.
    //
    HDEVINFO DeviceInfoSet;

    //
    // Flag indicating that the driver search should be aborted.
    //
    BOOL CancelSearch;

    //
    // Event handle that auxiliary thread waits on once it has set
    // the 'CancelSearch' flag (and once it has release the list
    // lock).  When the thread doing the search notices the cancel
    // request, it will signal the event, thus the waiting thread
    // can ensure that the search has been cancelled before it returns.
    //
    HANDLE SearchCancelledEvent;

} DRVSEARCH_INPROGRESS_NODE, *PDRVSEARCH_INPROGRESS_NODE;

typedef struct _DRVSEARCH_INPROGRESS_LIST {

    //
    // Head of linked list containing nodes for each device information
    // set for which a driver search is currently underway.
    //
    PDRVSEARCH_INPROGRESS_NODE DrvSearchHead;

    //
    // Synchronization
    //
    MYLOCK Lock;

} DRVSEARCH_INPROGRESS_LIST, *PDRVSEARCH_INPROGRESS_LIST;

#define LockDrvSearchInProgressList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockDrvSearchInProgressList(d) EndSynchronizedAccess(&((d)->Lock))

//
// Global "Driver Search In-Progress" list.
//
extern DRVSEARCH_INPROGRESS_LIST GlobalDrvSearchInProgressList;


//
// Device Information Set manipulation routines
//
PDEVICE_INFO_SET
AllocateDeviceInfoSet(
    VOID
    );

VOID
DestroyDeviceInfoElement(
    IN HDEVINFO         hDevInfo,
    IN PDEVICE_INFO_SET pDeviceInfoSet,
    IN PDEVINFO_ELEM    DeviceInfoElement
    );

DWORD
DestroyDeviceInfoSet(
    IN HDEVINFO         hDevInfo,      OPTIONAL
    IN PDEVICE_INFO_SET pDeviceInfoSet
    );

PDEVICE_INFO_SET
AccessDeviceInfoSet(
    IN HDEVINFO DeviceInfoSet
    );

PDEVICE_INFO_SET
CloneDeviceInfoSet(
    IN HDEVINFO hDevInfo
    );

PDEVICE_INFO_SET
RollbackDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    );

PDEVICE_INFO_SET
CommitDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    );

PDEVINFO_ELEM
FindDevInfoByDevInst(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  DEVINST           DevInst,
    OUT PDEVINFO_ELEM    *PrevDevInfoElem OPTIONAL
    );

BOOL
DevInfoDataFromDeviceInfoElement(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );

PDEVINFO_ELEM
FindAssociatedDevInfoElem(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA  DeviceInfoData,
    OUT PDEVINFO_ELEM    *PreviousElement OPTIONAL
    );


//
// Driver Node manipulation routines.
//
DWORD
CreateDriverNode(
    IN  UINT          Rank,
    IN  PCTSTR        DevDescription,
    IN  PCTSTR        DrvDescription,
    IN  PCTSTR        ProviderName,   OPTIONAL
    IN  PCTSTR        MfgName,
    IN  PFILETIME     InfDate,
    IN  PCTSTR        InfFileName,
    IN  PCTSTR        InfSectionName,
    IN  PVOID         StringTable,
    IN  LONG          InfClassGuidIndex,
    OUT PDRIVER_NODE *DriverNode
    );

PDRIVER_LIST_OBJECT
GetAssociatedDriverListObject(
    IN  PDRIVER_LIST_OBJECT  ObjectListHead,
    IN  PDRIVER_NODE         DriverListHead,
    OUT PDRIVER_LIST_OBJECT *PrevDriverListObject OPTIONAL
    );

VOID
DereferenceClassDriverList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDRIVER_NODE     DriverListHead OPTIONAL
    );

VOID
DestroyDriverNodes(
    IN PDRIVER_NODE DriverNode,
    IN PDEVICE_INFO_SET pDeviceInfoSet
    );

BOOL
DrvInfoDataFromDriverNode(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDRIVER_NODE     DriverNode,
    IN  DWORD            DriverType,
    OUT PSP_DRVINFO_DATA DriverInfoData
    );

PDRIVER_NODE
FindAssociatedDriverNode(
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    );

PDRIVER_NODE
SearchForDriverNode(
    IN  PVOID             StringTable,
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    );

DWORD
DrvInfoDetailsFromDriverNode(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDRIVER_NODE            DriverNode,
    OUT PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize          OPTIONAL
    );


//
// Installation parameter manipulation routines
//
DWORD
GetDevInstallParams(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_DEVINSTALL_PARAMS   DeviceInstallParams
    );

DWORD
GetClassInstallParams(
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize        OPTIONAL
    );

DWORD
SetDevInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_DEVINSTALL_PARAMS   DeviceInstallParams,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    IN     BOOL                    MsgHandlerIsNativeCharWidth
    );

DWORD
SetClassInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN     DWORD                   ClassInstallParamsSize,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock
    );

VOID
DestroyInstallParamBlock(
    IN HDEVINFO                hDevInfo,         OPTIONAL
    IN PDEVICE_INFO_SET        pDeviceInfoSet,
    IN PDEVINFO_ELEM           DevInfoElem,      OPTIONAL
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock
    );

DWORD
GetDrvInstallParams(
    IN  PDRIVER_NODE          DriverNode,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

DWORD
SetDrvInstallParams(
    IN  PSP_DRVINSTALL_PARAMS DriverInstallParams,
    OUT PDRIVER_NODE          DriverNode
    );


//
// Device Instance manipulation routines
//

#if 0   // This functionality is performed by CM APIs.

BOOL
ValidateDeviceInstanceId(
    IN  PCTSTR DeviceInstanceId
    );

VOID
CopyFixedUpDeviceId(
    OUT PTSTR  DestinationString,
    IN  PCTSTR SourceString,
    IN  DWORD  SourceStringLen
    );

#endif   // This functionality is performed by CM APIs.


//
// String Table helper functions
//
LONG
AddMultiSzToStringTable(
    IN  PVOID   StringTable,
    IN  PTCHAR  MultiSzBuffer,
    OUT PLONG   StringIdList,
    IN  DWORD   StringIdListSize,
    IN  BOOL    CaseSensitive,
    OUT PTCHAR *UnprocessedBuffer    OPTIONAL
    );

LONG
LookUpStringInDevInfoSet(
    IN HDEVINFO DeviceInfoSet,
    IN PTSTR    String,
    IN BOOL     CaseSensitive
    );


//
// INF processing functions
//

typedef struct _DRVSEARCH_CONTEXT {
    PDRIVER_NODE           *pDriverListHead;
    PDRIVER_NODE           *pDriverListTail;
    PUINT                   pDriverCount;
    GUID                    ClassGuid;
    PDEVICE_INFO_SET        DeviceInfoSet;
    DWORD                   Flags;
    BOOL                    BuildClassDrvList;
    LONG                    IdList[2][MAX_HCID_COUNT+1];         // leave extra entry for '-1' end-of-list marker.
    PVOID                   StringTable;
    PBOOL                   CancelSearch;
    TCHAR                   ClassGuidString[GUID_STRING_LEN];
    TCHAR                   ClassName[MAX_CLASS_NAME_LEN];
    TCHAR                   LegacyClassName[MAX_CLASS_NAME_LEN];
    TCHAR                   LegacyClassLang[32];                 // e.g., "ENG", "GER", "FREN", "SPAN", etc.
    LONG                    InstalledDescription;
    LONG                    InstalledMfgName;
    LONG                    InstalledProviderName;
    LONG                    InstalledInfSection;
    LONG                    InstalledInfSectionExt;
    PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo;        // may be NULL
    HCATADMIN               hCatAdmin;              // NULL upon entry, free if non-NULL upon return via CryptCATAdminReleaseContext
} DRVSEARCH_CONTEXT, *PDRVSEARCH_CONTEXT;

//
// DRVSEARCH_CONTEXT.Flags
//
#define DRVSRCH_HASCLASSGUID                0x00000001
#define DRVSRCH_FILTERCLASS                 0x00000002
#define DRVSRCH_TRY_PNF                     0x00000004
#define DRVSRCH_USEOLDINFS                  0x00000008
#define DRVSRCH_FROM_INET                   0x00000010
#define DRVSRCH_CLEANUP_SOURCE_PATH         0x00000020
#define DRVSRCH_EXCLUDE_OLD_INET_DRIVERS    0x00000040
#define DRVSRCH_ALLOWEXCLUDEDDRVS           0x00000080
#define DRVSRCH_FILTERSIMILARDRIVERS        0x00000100
#define DRVSRCH_INSTALLEDDRIVER             0x00000200
#define DRVSRCH_NO_CLASSLIST_NODE_MERGE     0x00000400

DWORD
EnumSingleDrvInf(
    IN     PCTSTR                       InfName,
    IN OUT LPWIN32_FIND_DATA            InfFileData,
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    );

DWORD
EnumDrvInfsInDirPathList(
    IN     PCTSTR                       DirPathList, OPTIONAL
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     BOOL                         IgnoreNonCriticalErrors,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    );

BOOL
GetDecoratedModelsSection(
    IN  PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN  PLOADED_INF             Inf,
    IN  PINF_LINE               MfgListLine,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,       OPTIONAL
    OUT PTSTR                   DecoratedModelsSection OPTIONAL
    );

PTSTR
GetFullyQualifiedMultiSzPathList(
    IN PCTSTR PathList
    );

BOOL
pRemoveDirectory(
    PTSTR Path
    );

BOOL
ShouldClassBeExcluded(
    IN LPGUID ClassGuid,
    IN BOOL   ExcludeNoInstallClass
    );

BOOL
ClassGuidFromInfVersionNode(
    IN  PINF_VERSION_NODE VersionNode,
    OUT LPGUID            ClassGuid
    );

VOID
AppendLoadIncludedInfs(
    IN HINF   hDeviceInf,
    IN PCTSTR InfFileName,
    IN PCTSTR InfSectionName,
    IN BOOL   AppendLayoutInfs
    );

DWORD
InstallFromInfSectionAndNeededSections(
    IN HWND              Owner,             OPTIONAL
    IN HINF              InfHandle,
    IN PCTSTR            SectionName,
    IN UINT              Flags,
    IN HKEY              RelativeKeyRoot,   OPTIONAL
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context,           OPTIONAL
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData,    OPTIONAL
    IN HSPFILEQ          UserFileQ          OPTIONAL
    );

DWORD
MarkQueueForDeviceInstall(
    IN HSPFILEQ QueueHandle,
    IN HINF     DeviceInfHandle,
    IN PCTSTR   DeviceDesc       OPTIONAL
    );


//
// Icon list manipulation functions.
//
BOOL
InitMiniIconList(
    VOID
    );

BOOL
DestroyMiniIconList(
    VOID
    );


//
// "Driver Search In-Progress" list functions.
//
BOOL
InitDrvSearchInProgressList(
    VOID
    );

BOOL
DestroyDrvSearchInProgressList(
    VOID
    );


//
// 'helper module' manipulation functions.
//
DWORD
GetModuleEntryPoint(
    IN     HKEY                    hk,                    OPTIONAL
    IN     LPCTSTR                 RegistryValue,
    IN     LPCTSTR                 DefaultProcName,
    OUT    HINSTANCE              *phinst,
    OUT    FARPROC                *pEntryPoint,
    OUT    HANDLE                 *pFusionContext,
    OUT    BOOL                   *pMustAbort,            OPTIONAL
    IN     PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN     HWND                    Owner,                 OPTIONAL
    IN     CONST GUID             *DeviceSetupClassGuid,  OPTIONAL
    IN     SetupapiVerifyProblem   Problem,
    IN     LPCTSTR                 DeviceDesc,            OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   NoUI,
    IN OUT HCATADMIN              *hCatAdmin              OPTIONAL
    );

//
// Define flags for InvalidateHelperModules
//
#define IHM_COINSTALLERS_ONLY     0x00000001
#define IHM_FREE_IMMEDIATELY      0x00000002

DWORD
InvalidateHelperModules(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            Flags
    );

//
// Define flags for _SetupDiCallClassInstaller
//
#define CALLCI_LOAD_HELPERS     0x00000001
#define CALLCI_CALL_HELPERS     0x00000002
#define CALLCI_ALLOW_DRVSIGN_UI 0x00000004

BOOL
_SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,      OPTIONAL
    IN DWORD            Flags
    );


//
// OEM driver selection routines.
//
DWORD
SelectOEMDriver(
    IN HWND             hwndParent,     OPTIONAL
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN BOOL             IsWizard
    );


//
// Registry helper routines.
//
DWORD
pSetupDeleteDevRegKeys(
    IN DEVINST DevInst,
    IN DWORD   Scope,
    IN DWORD   HwProfile,
    IN DWORD   KeyType,
    IN BOOL    DeleteUserKeys
    );

VOID
GetRegSubkeysFromDeviceInterfaceName(
    IN OUT PTSTR  DeviceInterfaceName,
    OUT    PTSTR *SubKeyName
    );

LONG
OpenDeviceInterfaceSubKey(
    IN     HKEY   hKeyInterfaceClass,
    IN     PCTSTR DeviceInterfaceName,
    IN     REGSAM samDesired,
    OUT    PHKEY  phkResult,
    OUT    PTSTR  OwningDevInstName,    OPTIONAL
    IN OUT PDWORD OwningDevInstNameSize OPTIONAL
    );


//
// Guid table routines.
//
LONG
AddOrGetGuidTableIndex(
    IN PDEVICE_INFO_SET  DeviceInfoSet,
    IN CONST GUID       *ClassGuid,
    IN BOOL              AddIfNotPresent
    );


//
// Interface device routines.
//
PINTERFACE_CLASS_LIST
AddOrGetInterfaceClassList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDEVINFO_ELEM    DevInfoElem,
    IN LONG             InterfaceClassGuidIndex,
    IN BOOL             AddIfNotPresent
    );

BOOL
InterfaceDeviceDataFromNode(
    IN  PINTERFACE_DEVICE_NODE     InterfaceDeviceNode,
    IN  CONST GUID                *InterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  InterfaceDeviceData
    );

PDEVINFO_ELEM
FindDevInfoElemForInterfaceDevice(
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData
    );


//
// Service installation routines.
//
typedef struct _SVCNAME_NODE {
    struct _SVCNAME_NODE *Next;
    TCHAR Name[MAX_SERVICE_NAME_LEN];
    BOOL DeleteEventLog;
    TCHAR EventLogType[256];
    TCHAR EventLogName[256];
    DWORD Flags;
} SVCNAME_NODE, *PSVCNAME_NODE;

//
// Define an additional (private) SPSVCINST flag for
// InstallNtService.
//
#define SPSVCINST_NO_DEVINST_CHECK  (0x80000000)

DWORD
InstallNtService(
    IN  PDEVINFO_ELEM    DevInfoElem,        OPTIONAL
    IN  HINF             hDeviceInf,
    IN  PCTSTR                   InfFileName,            OPTIONAL
    IN  PCTSTR           szSectionName,      OPTIONAL
    OUT PSVCNAME_NODE   *ServicesToDelete,   OPTIONAL
    IN  DWORD            Flags,
    OUT PBOOL            NullDriverInstalled
    );

//
// Ansi/Unicode conversion routines.
//
DWORD
pSetupDiDevInstParamsAnsiToUnicode(
    IN  PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams
    );

DWORD
pSetupDiDevInstParamsUnicodeToAnsi(
    IN  PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams
    );

DWORD
pSetupDiSelDevParamsAnsiToUnicode(
    IN  PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams
    );

DWORD
pSetupDiSelDevParamsUnicodeToAnsi(
    IN  PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams
    );

DWORD
pSetupDiDrvInfoDataAnsiToUnicode(
    IN  PSP_DRVINFO_DATA_A AnsiDrvInfoData,
    OUT PSP_DRVINFO_DATA_W UnicodeDrvInfoData
    );

DWORD
pSetupDiDrvInfoDataUnicodeToAnsi(
    IN  PSP_DRVINFO_DATA_W UnicodeDrvInfoData,
    OUT PSP_DRVINFO_DATA_A AnsiDrvInfoData
    );

DWORD
pSetupDiDevInfoSetDetailDataUnicodeToAnsi(
    IN  PSP_DEVINFO_LIST_DETAIL_DATA_W UnicodeDevInfoSetDetails,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A AnsiDevInfoSetDetails
    );

//
// Misc. utility routines
//
DWORD
MapCrToSpError(
    IN CONFIGRET CmReturnCode,
    IN DWORD     Default
    );

VOID
SetDevnodeNeedsRebootProblemWithArg2(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET DevInfoSet,
    IN DWORD    Reason,                  OPTIONAL
    IN ULONG_PTR Arg1,                   OPTIONAL
    IN ULONG_PTR Arg2                    OPTIONAL
    );

#define SetDevnodeNeedsRebootProblemWithArg(DevInfoElem,DevInfoSet,Reason,Arg) SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,DevInfoSet,Reason,Arg,0)
#define SetDevnodeNeedsRebootProblem(DevInfoElem,DevInfoSet,Reason) SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,DevInfoSet,Reason,0,0)

BOOL
GetBestDeviceDesc(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,  OPTIONAL
    OUT PTSTR            DeviceDescBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinst.c

Abstract:

    Device Installer routines.

Author:

    Lonny McMichael (lonnym) 1-Aug-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private prototypes.
//
DWORD
pSetupDiGetCoInstallerList(
    IN     HDEVINFO                 DeviceInfoSet,
    IN     PSP_DEVINFO_DATA         DeviceInfoData,    OPTIONAL
    IN     CONST GUID              *ClassGuid,
    IN OUT PDEVINSTALL_PARAM_BLOCK  InstallParamBlock,
    IN OUT HCATADMIN               *hCatAdmin          OPTIONAL
    );


//
// Private logging data
// these must be mirrored from setupapi.h
//
static LPCTSTR pSetupDiDifStrings[] = {
    NULL, // no DIF code
    TEXT("DIF_SELECTDEVICE"),
    TEXT("DIF_INSTALLDEVICE"),
    TEXT("DIF_ASSIGNRESOURCES"),
    TEXT("DIF_PROPERTIES"),
    TEXT("DIF_REMOVE"),
    TEXT("DIF_FIRSTTIMESETUP"),
    TEXT("DIF_FOUNDDEVICE"),
    TEXT("DIF_SELECTCLASSDRIVERS"),
    TEXT("DIF_VALIDATECLASSDRIVERS"),
    TEXT("DIF_INSTALLCLASSDRIVERS"),
    TEXT("DIF_CALCDISKSPACE"),
    TEXT("DIF_DESTROYPRIVATEDATA"),
    TEXT("DIF_VALIDATEDRIVER"),
    TEXT("DIF_MOVEDEVICE"),
    TEXT("DIF_DETECT"),
    TEXT("DIF_INSTALLWIZARD"),
    TEXT("DIF_DESTROYWIZARDDATA"),
    TEXT("DIF_PROPERTYCHANGE"),
    TEXT("DIF_ENABLECLASS"),
    TEXT("DIF_DETECTVERIFY"),
    TEXT("DIF_INSTALLDEVICEFILES"),
    TEXT("DIF_UNREMOVE"),
    TEXT("DIF_SELECTBESTCOMPATDRV"),
    TEXT("DIF_ALLOW_INSTALL"),
    TEXT("DIF_REGISTERDEVICE"),
    TEXT("DIF_NEWDEVICEWIZARD_PRESELECT"),
    TEXT("DIF_NEWDEVICEWIZARD_SELECT"),
    TEXT("DIF_NEWDEVICEWIZARD_PREANALYZE"),
    TEXT("DIF_NEWDEVICEWIZARD_POSTANALYZE"),
    TEXT("DIF_NEWDEVICEWIZARD_FINISHINSTALL"),
    NULL, // DIF_UNUSED1
    TEXT("DIF_INSTALLINTERFACES"),
    TEXT("DIF_DETECTCANCEL"),
    TEXT("DIF_REGISTER_COINSTALLERS"),
    TEXT("DIF_ADDPROPERTYPAGE_ADVANCED"),
    TEXT("DIF_ADDPROPERTYPAGE_BASIC"),
    NULL, // DIF_RESERVED1
    TEXT("DIF_TROUBLESHOOTER"),
    TEXT("DIF_POWERMESSAGEWAKE"),
    TEXT("DIF_ADDREMOTEPROPERTYPAGE_ADVANCED"),
    TEXT("DIF_UPDATEDRIVER_UI"),
    TEXT("DIF_INTERFACE_TO_DEVICE")
    //
    // append new DIF codes here (don't forget comma's)
    //
};

DWORD FilterLevelOnInstallerError(
    IN DWORD PrevLevel,
    IN DWORD Err)
/*++

Routine Description:

    Allow downgrading of error level depending on returned error
    from class/co/default installer
    and current state

Arguments:

    PrevLevel - initial level
    Err       - error to check

Return Value:

    New level

--*/
{
    DWORD Level = PrevLevel;
    if(Level == DRIVER_LOG_ERROR) {
        switch(Err) {
            case ERROR_DUPLICATE_FOUND:
                //
                // not an error as such
                //
                Level = DRIVER_LOG_WARNING;
                break;

            case ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION:
                //
                // if returned during gui-setup
                // or during server-side setup
                // demote error to warning
                //
                if(GuiSetupInProgress ||
                              (GlobalSetupFlags & PSPGF_NONINTERACTIVE)) {

                    Level = DRIVER_LOG_WARNING;
                }
                break;
        }
    }
    return Level;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    )
{
    SP_DEVINSTALL_PARAMS_W deviceInstallParams;
    DWORD rc;
    BOOL b;

    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);
    b = SetupDiGetDeviceInstallParamsW(DeviceInfoSet,DeviceInfoData,&deviceInstallParams);
    rc = GetLastError();

    if(b) {
        rc = pSetupDiDevInstParamsUnicodeToAnsi(&deviceInstallParams,DeviceInstallParams);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiGetDeviceInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DeviceInstallParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDeviceInstallParams(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS DeviceInstallParams
    )
/*++

Routine Description:

    This routine retrieves installation parameters for a device information set
    (globally), or a particular device information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        installation parameters to be retrieved.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing installation parameters to be retrieved.  If this
        parameter is not specified, then the installation parameters retrieved
        will be associated with the device information set itself (for the global
        class driver list).

    DeviceInstallParams - Supplies the address of a SP_DEVINSTALL_PARAMS structure
        that will receive the installation parameters.  The cbSize field of this
        structure must be set to the size, in bytes, of a SP_DEVINSTALL_PARAMS
        structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to retrieve installation parameters for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = GetDevInstallParams(pDeviceInfoSet,
                                          &(DevInfoElem->InstallParamBlock),
                                          DeviceInstallParams
                                         );
            }
        } else {
            //
            // Retrieve installation parameters for the global class driver list.
            //
            Err = GetDevInstallParams(pDeviceInfoSet,
                                      &(pDeviceInfoSet->InstallParamBlock),
                                      DeviceInstallParams
                                     );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    DI_FUNCTION Function;
    DWORD Err;
    BOOL b;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to retrieve installation parameters for a particular
            // device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,DeviceInfoData,NULL)) {
                InstallParamBlock = &DevInfoElem->InstallParamBlock;
            } else {
                Err = ERROR_INVALID_PARAMETER;
            }
        } else {
            //
            // Retrieve installation parameters for the global class driver list.
            //
            InstallParamBlock = &pDeviceInfoSet->InstallParamBlock;
        }

        //
        // While we're in a try/except, go ahead and do some preliminary
        // validation on the caller-supplied buffer...
        //
        if(ClassInstallParams) {

            if((ClassInstallParamsSize < sizeof(SP_CLASSINSTALL_HEADER)) ||
               (ClassInstallParams->cbSize != sizeof(SP_CLASSINSTALL_HEADER))) {

                Err = ERROR_INVALID_USER_BUFFER;
            }

        } else if(ClassInstallParamsSize) {
            Err = ERROR_INVALID_USER_BUFFER;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if(Err == NO_ERROR) {
        if(InstallParamBlock->ClassInstallHeader) {
            Function = InstallParamBlock->ClassInstallHeader->InstallFunction;
        } else {
            Err = ERROR_NO_CLASSINSTALL_PARAMS;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(Err == NO_ERROR) {
        //
        // For DIF_SELECTDEVICE we need special processing since
        // the structure that goes with it is ansi/unicode specific.
        //
        if(Function == DIF_SELECTDEVICE) {

            SP_SELECTDEVICE_PARAMS_W SelectDeviceParams;

            SelectDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

            b = SetupDiGetClassInstallParamsW(
                    DeviceInfoSet,
                    DeviceInfoData,
                    (PSP_CLASSINSTALL_HEADER)&SelectDeviceParams,
                    sizeof(SP_SELECTDEVICE_PARAMS_W),
                    NULL
                    );

            if(b) {
                //
                // We successfully retrieved the Unicode form of the Select
                // Device parameters.  Store the required size for the ANSI
                // version in the output parameter (if requested).
                //
                if(RequiredSize) {
                    *RequiredSize = sizeof(SP_SELECTDEVICE_PARAMS_A);
                }

                if(ClassInstallParamsSize < sizeof(SP_SELECTDEVICE_PARAMS_A)) {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    Err = pSetupDiSelDevParamsUnicodeToAnsi(
                              &SelectDeviceParams,
                              (PSP_SELECTDEVICE_PARAMS_A)ClassInstallParams
                              );
                }

            } else {
                Err = GetLastError();
            }

        } else {
            b = SetupDiGetClassInstallParamsW(
                    DeviceInfoSet,
                    DeviceInfoData,
                    ClassInstallParams,
                    ClassInstallParamsSize,
                    RequiredSize
                    );
            if(b) {
                Err = NO_ERROR;
            } else {
                Err = GetLastError();
            }
        }
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiGetClassInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(ClassInstallParams);
    UNREFERENCED_PARAMETER(ClassInstallParamsSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
WINAPI
SetupDiGetClassInstallParams(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves class installer parameters for a device information set
    (globally), or a particular device information element.  These parameters are
    specific to a particular device installer function code (DI_FUNCTION) that will
    be stored in the ClassInstallHeader field located at the beginning of the
    parameter buffer.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        class installer parameters to be retrieved.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing class installer parameters to be retrieved.  If this
        parameter is not specified, then the class installer parameters retrieved
        will be associated with the device information set itself (for the global
        class driver list).

    ClassInstallParams - Optionally, supplies the address of a buffer containing a
        class install header structure.  This structure must have its cbSize field
        set to sizeof(SP_CLASSINSTALL_HEADER) on input, or the buffer is considered
        to be invalid.  On output, the InstallFunction field will be filled in with
        the DI_FUNCTION code for the class install parameters being retrieved, and
        if the buffer is large enough, it will receive the class installer parameters
        structure specific to that function code.

        If this parameter is not specified, then ClassInstallParamsSize must be zero.
        This would be done if the caller simply wants to determine how large a buffer
        is required.

    ClassInstallParamsSize - Supplies the size, in bytes, of the ClassInstallParams
        buffer, or zero, if ClassInstallParams is not supplied.  If the buffer is
        supplied, it must be _at least_ as large as sizeof(SP_CLASSINSTALL_HEADER).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the class installer parameters.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to retrieve installation parameters for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = GetClassInstallParams(&(DevInfoElem->InstallParamBlock),
                                            ClassInstallParams,
                                            ClassInstallParamsSize,
                                            RequiredSize
                                           );
            }
        } else {
            //
            // Retrieve installation parameters for the global class driver list.
            //
            Err = GetClassInstallParams(&(pDeviceInfoSet->InstallParamBlock),
                                        ClassInstallParams,
                                        ClassInstallParamsSize,
                                        RequiredSize
                                       );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
_SetupDiSetDeviceInstallParams(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams,
    IN BOOL                  MsgHandlerIsNativeCharWidth
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to set installation parameters for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = SetDevInstallParams(pDeviceInfoSet,
                                          DeviceInstallParams,
                                          &(DevInfoElem->InstallParamBlock),
                                          MsgHandlerIsNativeCharWidth
                                         );
            }
        } else {
            //
            // Set installation parameters for the global class driver list.
            //
            Err = SetDevInstallParams(pDeviceInfoSet,
                                      DeviceInstallParams,
                                      &(pDeviceInfoSet->InstallParamBlock),
                                      MsgHandlerIsNativeCharWidth
                                     );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiSetDeviceInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    )
{
    DWORD rc;
    SP_DEVINSTALL_PARAMS_W deviceInstallParams;

    rc = pSetupDiDevInstParamsAnsiToUnicode(DeviceInstallParams,&deviceInstallParams);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return(_SetupDiSetDeviceInstallParams(DeviceInfoSet,DeviceInfoData,&deviceInstallParams,FALSE));
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiSetDeviceInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DeviceInstallParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
WINAPI
SetupDiSetDeviceInstallParams(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams
    )
/*++

Routine Description:

    This routine sets installation parameters for a device information set
    (globally), or a particular device information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        installation parameters to be set.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing installation parameters to be set.  If this
        parameter is not specified, then the installation parameters set
        will be associated with the device information set itself (for the
        global class driver list).

    DeviceInstallParams - Supplies the address of a SP_DEVINSTALL_PARAMS structure
        containing the new values of the parameters.  The cbSize field of this
        structure must be set to the size, in bytes, of the structure before
        calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    All parameters will be validated before any changes are made, so a return
    status of FALSE indicates that no parameters were modified.

--*/

{
    return(_SetupDiSetDeviceInstallParams(DeviceInfoSet,DeviceInfoData,DeviceInstallParams,TRUE));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiSetClassInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
{
    DWORD Err;
    DI_FUNCTION Function;
    SP_SELECTDEVICE_PARAMS_W SelectParams;
    BOOL b;

    if(!ClassInstallParams) {
        //
        // Just pass it on to the unicode version since there's
        // no thunking to do. Note that the size must be 0.
        //
        if(ClassInstallParamsSize) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
        return SetupDiSetClassInstallParamsW(
                    DeviceInfoSet,
                    DeviceInfoData,
                    ClassInstallParams,
                    ClassInstallParamsSize
                    );
    }

    Err = NO_ERROR;

    try {
        if(ClassInstallParams->cbSize == sizeof(SP_CLASSINSTALL_HEADER)) {
            Function = ClassInstallParams->InstallFunction;
        } else {
            //
            // Structure is invalid.
            //
            Err = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if(Err != NO_ERROR) {
        SetLastError(Err);
        return(FALSE);
    }

    //
    // DIF_SELECTDEVICE is a special case since it has
    // an structure that needs to be translated from ansi to unicode.
    //
    // DIF_INTERFACE_TO_DEVICE has unicode structure but ansi
    // not supported (yet) - internal
    //
    // Others can just be passed on to the unicode version with
    // no changes to the parameters.
    //
    if(Function == DIF_SELECTDEVICE) {

        b = FALSE;
        if(ClassInstallParamsSize >= sizeof(SP_SELECTDEVICE_PARAMS_A)) {

            Err = pSetupDiSelDevParamsAnsiToUnicode(
                    (PSP_SELECTDEVICE_PARAMS_A)ClassInstallParams,
                    &SelectParams
                    );

            if(Err == NO_ERROR) {

                b = SetupDiSetClassInstallParamsW(
                        DeviceInfoSet,
                        DeviceInfoData,
                        (PSP_CLASSINSTALL_HEADER)&SelectParams,
                        sizeof(SP_SELECTDEVICE_PARAMS_W)
                        );

                Err = GetLastError();
            }
        } else {
            Err = ERROR_INVALID_PARAMETER;
        }
    } else if(Function == DIF_INTERFACE_TO_DEVICE) {
        b = FALSE;
        Err = ERROR_INVALID_PARAMETER;
    } else {
        b = SetupDiSetClassInstallParamsW(
                DeviceInfoSet,
                DeviceInfoData,
                ClassInstallParams,
                ClassInstallParamsSize
                );

        Err = GetLastError();
    }

    SetLastError(Err);
    return(b);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiSetClassInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(ClassInstallParams);
    UNREFERENCED_PARAMETER(ClassInstallParamsSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
WINAPI
SetupDiSetClassInstallParams(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
/*++

Routine Description:

    This routine sets (or clears) class installer parameters for a device
    information set (globally), or a particular device information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        class installer parameters to be set.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing class installer parameters to be set.  If this
        parameter is not specified, then the class installer parameters to be
        set will be associated with the device information set itself (for the
        global class driver list).

    ClassInstallParams - Optionally, supplies the address of a buffer containing
        the class installer parameters to be used.    The SP_CLASSINSTALL_HEADER
        structure at the beginning of the buffer must have its cbSize field set to
        be sizeof(SP_CLASSINSTALL_HEADER), and the InstallFunction field must be
        set to the DI_FUNCTION code reflecting the type of parameters supplied in
        the rest of the buffer.

        If this parameter is not supplied, then the current class installer parameters
        (if any) will be cleared for the specified device information set or element.

    ClassInstallParamsSize - Supplies the size, in bytes, of the ClassInstallParams
        buffer.  If the buffer is not supplied (i.e., the class installer parameters
        are to be cleared), then this value must be zero.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    All parameters will be validated before any changes are made, so a return
    status of FALSE indicates that no parameters were modified.

    A side effect of setting class installer parameters is that the DI_CLASSINSTALLPARAMS
    flag is set.  If for some reason, it is desired to set the parameters, but disable
    their use, then this flag must be cleared via SetupDiSetDeviceInstallParams.

    If the class installer parameters are cleared, then the DI_CLASSINSTALLPARAMS flag
    is reset.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to set class installer parameters for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = SetClassInstallParams(pDeviceInfoSet,
                                            ClassInstallParams,
                                            ClassInstallParamsSize,
                                            &(DevInfoElem->InstallParamBlock)
                                           );
            }
        } else {
            //
            // Set class installer parameters for the global class driver list.
            //
            Err = SetClassInstallParams(pDeviceInfoSet,
                                        ClassInstallParams,
                                        ClassInstallParamsSize,
                                        &(pDeviceInfoSet->InstallParamBlock)
                                       );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine calls the appropriate class installer with the specified
    installer function.

    Before calling the class installer, this routine will call any registered
    co-device installers (registration is either per-class or per-device;
    per-class installers are called first).  Any co-installer wishing to be
    called back once the class installer has finished installation may return
    ERROR_DI_POSTPROCESSING_REQUIRED.  Returning NO_ERROR will also allow
    installation to continue, but without a post-processing callback.  Returning
    any other error code will cause the install action to be aborted (any
    co-installers already called that have requested post-processing will be
    called back, with InstallResult indicating the cause of failure).

    After the class installer has performed the installation (or we've done the
    default if ERROR_DI_DO_DEFAULT is returned), then we'll call any co-installers
    who have requested postprocessing.  The list of co-installers is treated
    like a stack, so the co-installers called last 'on the way in' are called
    first 'on the way out'.

Arguments:

    InstallFunction - Class installer function to call.  This can be one
        of the following values, or any other (class-specific) value:

        DIF_SELECTDEVICE - Select a driver to be installed.
        DIF_INSTALLDEVICE - Install the driver for the device.  (DeviceInfoData
            must be specified.)
        DIF_ASSIGNRESOURCES - ** PRESENTLY UNUSED ON WINDOWS NT **
        DIF_PROPERTIES - Display a properties dialog for the device.
            (DeviceInfoData must be specified.)
        DIF_REMOVE - Remove the device.  (DeviceInfoData must be specified.)
        DIF_FIRSTTIMESETUP - Perform first time setup initialization.  This
            is used only for the global class information associated with
            the device information set (i.e., DeviceInfoData not specified).
        DIF_FOUNDDEVICE - ** UNUSED ON WINDOWS NT **
        DIF_SELECTCLASSDRIVERS - Select drivers for all devices of the class
            associated with the device information set or element.
        DIF_VALIDATECLASSDRIVERS - Ensure all devices of the class associated
            with the device information set or element are ready to be installed.
        DIF_INSTALLCLASSDRIVERS - Install drivers for all devices of the
            class associated with the device information set or element.
        DIF_CALCDISKSPACE - Compute the amount of disk space required by
            drivers.
        DIF_DESTROYPRIVATEDATA - Destroy any private date referenced by
            the ClassInstallReserved installation parameter for the specified
            device information set or element.
        DIF_VALIDATEDRIVER - ** UNUSED ON WINDOWS NT **
        DIF_MOVEDEVICE - The device is being moved to a new location in the
            Enum branch.  This means that the device instance name will change.
            (DeviceInfoData must be specified.)
        DIF_DETECT - Detect any devices of class associated with the device
            information set.
        DIF_INSTALLWIZARD - Add any pages necessary to the New Device Wizard
            for the class associated with the device information set or element.
            ** OBSOLETE--use DIF_NEWDEVICEWIZARD method instead **
        DIF_DESTROYWIZARDDATA - Destroy any private data allocated due to
            a DIF_INSTALLWIZARD message.
            ** OBSOLETE--not needed for DIF_NEWDEVICEWIZARD method **
        DIF_PROPERTYCHANGE - The device's properties are changing. The device
            is being enabled, disabled, or has had a resource change.
            (DeviceInfoData must be specified.)
        DIF_ENABLECLASS - ** UNUSED ON WINDOWS NT **
        DIF_DETECTVERIFY - The class installer should verify any devices it
            previously detected.  Non verified devices should be removed.
        DIF_INSTALLDEVICEFILES - The class installer should only install the
            driver files for the selected device.  (DeviceInfoData must be
            specified.)
        DIF_UNREMOVE - Unremoves a device from the system.  (DeviceInfoData must
            be specified.)
        DIF_SELECTBESTCOMPATDRV - Select the best driver from the device
            information element's compatible driver list.  (DeviceInfoData must
            be specified.)
        DIF_ALLOW_INSTALL - Determine whether or not the selected driver should
            be installed for the device.  (DeviceInfoData must be specified.)
        DIF_REGISTERDEVICE - The class installer should register the new,
            manually-installed, device information element (via
            SetupDiRegisterDeviceInfo) including, potentially, doing duplicate
            detection via the SPRDI_FIND_DUPS flag.  (DeviceInfoData must be
            specified.)
        DIF_NEWDEVICEWIZARD_PRESELECT - Allows class-/co-installers to supply
            wizard pages to be displayed before the Select Device page during
            "Add New Hardware" wizard.
        DIF_NEWDEVICEWIZARD_SELECT - Allows class-/co-installers to supply
            wizard pages to replace the default Select Device wizard page, as
            retrieved by SetupDiGetWizardPage(...SPWPT_SELECTDEVICE...)
        DIF_NEWDEVICEWIZARD_PREANALYZE - Allows class-/co-installers to supply
            wizard pages to be displayed before the analyze page.
        DIF_NEWDEVICEWIZARD_POSTANALYZE - Allows class-/co-installers to supply
            wizard pages to be displayed after the analyze page.
        DIF_NEWDEVICEWIZARD_FINISHINSTALL - Allows class-/co-installers (including
            device-specific co-installers) to supply wizard pages to be displayed
            after installation of the device has been performed (i.e., after
            DIF_INSTALLDEVICE has been processed), but prior to the wizard's finish
            page.  This message is sent not only for the "Add New Hardware" wizard,
            but also for the autodetection and "New Hardware Found" scenarios as
            well.
        DIF_UNUSED1 - ** PRESENTLY UNUSED ON WINDOWS NT **
        DIF_INSTALLINTERFACES - The class installer should create (and/or,
            potentially remove) interface devices for this device information
            element.
        DIF_DETECTCANCEL - After the detection is stopped, if the class
            installer was invoked for DIF_DETECT, then it is invoked for
            DIF_DETECTCANCEL. This gives the class installer a chance to clean
            up anything it did during DIF_DETECT such as drivers setup to do
            detection at reboot, and private data. It is passed the same
            HDEVINFO as it was for DIF_DETECT.
        DIF_REGISTER_COINSTALLERS - Register device-specific co-installers so
            that they can be involved in the rest of the installation.
            (DeviceInfoData must be specified.)
        DIF_ADDPROPERTYPAGE_ADVANCED - Allows class-/co-installers to supply
            advanced property pages for a device.
        DIF_ADDPROPERTYPAGE_BASIC - Allows class-/co-installers to supply
            basic property pages for a device.
        DIF_TROUBLESHOOTER - Allows class-/co-installers to launch a troubleshooter
            for this device or to return CHM and HTM troubleshooter files that will
            get launched with a call to the HtmlHelp() API. If the class-/co-installer
            launches its own troubleshooter then it should return NO_ERROR, it should
            return ERROR_DI_DO_DEFAULT regardless of if it sets the CHM and HTM values.
        DIF_POWERMESSAGEWAKE - Allows class-/co-installers to specify text that will be
            displayed on the power tab in device manager. The class-/co-installer
            should return NO_ERROR if it specifies any text and ERROR_DI_DO_DEFAULT
            otherwise.
        DIF_ADDREMOTEPROPERTYPAGE_ADVANCED - Allows class-/co-installers to supply
            advanced proerty pages for a device that is on a remote machine.
        DIF_UPDATEDRIVER_UI - Allows a class-/co-installer to display their own
            UI when the user presses the update driver button in device manager.
            The only real reason to do this is when the default update driver
            behavior could cause the device and/or machine not to work. We don't
            want IHVs providing their own UI for random reasons.
        DIF_INTERFACE_TO_DEVICE - For SWENUM device co-installers, get device for
            interface if it's different. Return NO_ERROR if handled ERROR_DI_DO_DEFAULT
            otherwise.

        (Note: remember to add new DIF_xxxx to pSetupDiDifStrings at start of file)

    DeviceInfoSet - Supplies a handle to the device information set to
        perform installation for.

    DeviceInfoData - Optionally, specifies a particular device information
        element whose class installer is to be called.  If this parameter
        is not specified, then the class installer for the device information
        set itself will be called (if the set has an associated class).

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This function will attempt to load and call the class installer for the
    class associated with the device information element or set specified.
    If there is no class installer, or the class installer returns
    ERR_DI_DO_DEFAULT, then this function will call a default procedure for
    the specified class installer function.

--*/

{
    return _SetupDiCallClassInstaller(InstallFunction,
                                      DeviceInfoSet,
                                      DeviceInfoData,
                                      CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS
                                     );
}


BOOL
_SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,      OPTIONAL
    IN DWORD            Flags
    )
/*++

Routine Description:

    Worker routine for SetupDiCallClassInstaller that allows the caller to
    control what actions are taken when handling this install request.  In
    addition to the first three parameters (refer to the documentation for
    SetupDiCallClassInstaller for details), the following flags may be
    specified in the Flags parameter:

    CALLCI_LOAD_HELPERS - If helper modules (class installer, co-installers)
        haven't been loaded, load them so they can participate in handling
        this install request.

    CALLCI_CALL_HELPERS - Call the class installer/co-installers to give them
        a chance to handle this install request.  If this flag is not specified,
        then only the default action will be taken.

    CALLCI_ALLOW_DRVSIGN_UI - If an unsigned class installer or co-installer is
        encountered, perform standard non-driver signing behavior.  (WHQL
        doesn't have a certification program for class-/co-installers!)

        NTRAID#166000-2000/08/18-JamieHun Driver signing policy for class installers?
        (lonnym): We should probably employ driver signing policy
        (instead of non-driver signing policy) for class installers of
        WHQL-approved classes.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    BOOL b, MustAbort;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    HKEY hk;
    CONST GUID *ClassGuid;
    BOOL bRestoreMiniIconUsage = FALSE;
    BOOL bRestoreDiQuietInstall = FALSE;
    BOOL MuteError = FALSE;
    PCOINSTALLER_INTERNAL_CONTEXT CoInstallerInternalContext;
    LONG i;
    HWND hwndParent;
    TCHAR DescBuffer[LINE_LEN];
    PTSTR DeviceDesc;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_dif_code = 0;
    BOOL ChangedThreadLogContext = FALSE;
    PSETUP_LOG_CONTEXT SavedLogContext = NULL;
    DWORD LastErr;
    DWORD ErrorLevel = DRIVER_LOG_ERROR;
    SPFUSIONINSTANCE spFusionInstance;
    HCATADMIN hCatAdmin = NULL;

    ASSERT_HEAP_IS_VALID();

#ifdef _X86_
    if(IsWow64) {
        //
        // this API not allowed in Wow64, class/co installers must/will be native
        //
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }
#endif
    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = ERROR_DI_DO_DEFAULT;
    CoInstallerInternalContext = NULL;
    i = 0;
    DevInfoElem = NULL;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to call the class installer for a particular
            // device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DeviceInfoData,
                                                       NULL)) {

                InstallParamBlock = &(DevInfoElem->InstallParamBlock);
                ClassGuid = &(DevInfoElem->ClassGuid);
            } else {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

        } else {
            InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
            ClassGuid = pDeviceInfoSet->HasClassGuid ? &(pDeviceInfoSet->ClassGuid)
                                                     : NULL;
        }

        //
        // set the local log context before it gets used.
        //
        LogContext = InstallParamBlock->LogContext;

        //
        // If we are processing DIF_ALLOW_INSTALL then we need to make sure that the
        // DI_QUIETINSTALL flag is only set if we are doing a non-interactive (server-side)
        // install or we are in GUI mode setup.  In any other case we need to remove the
        // DI_QUIETINSTALL flag otherwise class installers might think they can't display
        // any UI and fail the DIF_ALLOW_INSTALL.
        //
        if ((InstallFunction == DIF_ALLOW_INSTALL) &&
            (InstallParamBlock->Flags & DI_QUIETINSTALL) &&
            !(InstallParamBlock->FlagsEx & DI_FLAGSEX_IN_SYSTEM_SETUP) &&
            !(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {

            InstallParamBlock->Flags &= ~DI_QUIETINSTALL;
            bRestoreDiQuietInstall = TRUE;
        }

        if(Flags & CALLCI_LOAD_HELPERS) {
            //
            // Retrieve the parent window handle, as we may need it below if we
            // need to popup UI due to unsigned class-/co-installers.
            //
            if(hwndParent = InstallParamBlock->hwndParent) {
               if(!IsWindow(hwndParent)) {
                    hwndParent = NULL;
               }
            }

            //
            // Retrieve a device description to use in case we need to give a
            // driver signing warn/block popup.
            //
            if(GetBestDeviceDesc(DeviceInfoSet, DeviceInfoData, DescBuffer)) {
                DeviceDesc = DescBuffer;
            } else {
                DeviceDesc = NULL;
            }

            //
            // If the class installer has not been loaded, then load it and
            // get the function address for the ClassInstall function.
            //
            if(!InstallParamBlock->hinstClassInstaller) {

                if(ClassGuid &&
                   (hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) != INVALID_HANDLE_VALUE) {
                    DWORD slot = AllocLogInfoSlot(LogContext,FALSE);

                    WriteLogEntry(
                        LogContext,
                        slot,
                        MSG_LOG_CI_MODULE,
                        NULL,
                        DeviceDesc?DeviceDesc:TEXT(""));

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszInstaller32,
                                                  pszCiDefaultProc,
                                                  &(InstallParamBlock->hinstClassInstaller),
                                                  &((FARPROC)InstallParamBlock->ClassInstallerEntryPoint),
                                                  &(InstallParamBlock->ClassInstallerFusionContext),
                                                  &MustAbort,
                                                  LogContext,
                                                  hwndParent,
                                                  ClassGuid,
                                                  SetupapiVerifyClassInstProblem,
                                                  DeviceDesc,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  &hCatAdmin
                                                 );
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        Err = ERROR_INVALID_CLASS_INSTALLER;
                        InstallParamBlock->ClassInstallerEntryPoint = NULL;
                    }

                    if (slot) {
                        ReleaseLogInfoSlot(LogContext,slot);
                    }


                    RegCloseKey(hk);

                    if((Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {

                        if(!(InstallParamBlock->FlagsEx & DI_FLAGSEX_CI_FAILED)) {

                            TCHAR ClassName[MAX_GUID_STRING_LEN];
                            TCHAR Title[MAX_TITLE_LEN];

                            if(!SetupDiClassNameFromGuid(ClassGuid,
                                                         ClassName,
                                                         SIZECHARS(ClassName),
                                                         NULL)) {
                                //
                                // Use the ClassName buffer to hold the class
                                // GUID string (it's better than nothin')
                                //
                                pSetupStringFromGuid(ClassGuid,
                                                     ClassName,
                                                     SIZECHARS(ClassName)
                                                    );
                            }

                            //
                            // Write out an event log entry about this.
                            //
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_CI_LOADFAIL_ERROR,
                                NULL,
                                ClassName);
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                Err);
                            MuteError = TRUE;

                            if(!(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {

                                if(!LoadString(MyDllModuleHandle,
                                               IDS_DEVICEINSTALLER,
                                               Title,
                                               SIZECHARS(Title))) {
                                    *Title = TEXT('\0');
                                }
                                FormatMessageBox(MyDllModuleHandle,
                                                 InstallParamBlock->hwndParent,
                                                 MSG_CI_LOADFAIL_ERROR,
                                                 Title,
                                                 MB_OK,
                                                 ClassName
                                                );
                            }

                            InstallParamBlock->FlagsEx |= DI_FLAGSEX_CI_FAILED;
                        }

                        Err = ERROR_INVALID_CLASS_INSTALLER;
                        goto clean0;
                    }
                }
            }

            //
            // If we haven't retrieved a list of co-installers to call,
            // retrieve the list now.
            //
            if(InstallParamBlock->CoInstallerCount == -1) {

                DWORD slot = AllocLogInfoSlot(LogContext,FALSE);

                WriteLogEntry(
                    LogContext,
                    slot,
                    MSG_LOG_COINST_MODULE,
                    NULL,
                    DeviceDesc);

                Err = pSetupDiGetCoInstallerList(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 ClassGuid,
                                                 InstallParamBlock,
                                                 &hCatAdmin
                                                );

                if (slot) {
                    ReleaseLogInfoSlot(LogContext,slot);
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }

                MYASSERT(InstallParamBlock->CoInstallerCount >= 0);
            }
        }

        slot_dif_code = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE1,FALSE);
        if (slot_dif_code) {
            //
            // this is skipped if we know we would never log anything
            //
            // pass a string which we may log with an error
            // or will log at VERBOSE1 level
            //
            if ((InstallFunction >= (sizeof(pSetupDiDifStrings)/sizeof(pSetupDiDifStrings[0])))
                    || (pSetupDiDifStrings[InstallFunction]==NULL)) {
                //
                // I would like to think this could be bad and should be logged at DRIVER_LOG_ERROR
                // however function header alludes to user defined DIF_xxxx codes
                //
                WriteLogEntry(
                    LogContext,
                    slot_dif_code,
                    MSG_LOG_DI_UNUSED_FUNC,
                    NULL,
                    InstallFunction);
            } else {
                //
                // use the string version of the DIF code
                //
                WriteLogEntry(
                    LogContext,
                    slot_dif_code,
                    MSG_LOG_DI_FUNC,
                    NULL,
                    pSetupDiDifStrings[InstallFunction]);
            }
        }

        //
        // do any pre DIF cleanup
        //

        switch (InstallFunction) {

            case DIF_REGISTER_COINSTALLERS : {
                LONG r;
                HKEY hKey = NULL;

                hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_WRITE
                                );

                if (hKey != INVALID_HANDLE_VALUE && hKey != NULL) {
                    //
                    // Clean up device SW key
                    //  remove CoInstallers32 - can introduce unwanted co-installers
                    //  remove EnumPropPages32 - can introduce unwanted property pages
                    //

                    r = RegDeleteValue(hKey,pszCoInstallers32);
                    r = RegDeleteValue(hKey,pszEnumPropPages32);

                    RegCloseKey(hKey);
                }
                break;
            }

            case DIF_INSTALLDEVICE: {
                BOOL f;

                f = SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_UPPERFILTERS,
                                                     NULL,
                                                     0);
                f = SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_LOWERFILTERS,
                                                     NULL,
                                                     0);
            }

        }

        if(Flags & CALLCI_CALL_HELPERS) {

            //
            // push log context as thread's default
            // this will cause orphened log sections
            // to be merged
            //
            MYASSERT(!ChangedThreadLogContext);
            ChangedThreadLogContext = SetThreadLogContext(LogContext,&SavedLogContext);
            if (ChangedThreadLogContext) {
                //
                // add one more ref to protext log context against thread freeing DeviceInfoSet
                //
                RefLogContext(LogContext);
            }

            if(InstallParamBlock->CoInstallerCount > 0) {
                //
                // Allocate an array of co-installer context structures to be used when
                // calling (and potentially, re-calling) the entry points.
                //
                CoInstallerInternalContext = MyMalloc(sizeof(COINSTALLER_INTERNAL_CONTEXT) * InstallParamBlock->CoInstallerCount);
                if(!CoInstallerInternalContext) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

                ZeroMemory(CoInstallerInternalContext,
                           sizeof(COINSTALLER_INTERNAL_CONTEXT) * InstallParamBlock->CoInstallerCount
                          );

                //
                // Call each co-installer.  We must unlock the devinfo set first, to avoid deadlocks.
                //
                UnlockDeviceInfoSet(pDeviceInfoSet);
                pDeviceInfoSet = NULL;

                for(i = 0; i < InstallParamBlock->CoInstallerCount; i++) {
                    //
                    // Store entry point in our context array, because the class installer may destroy
                    // this devinfo element and we wouldn't know who to callback otherwise.
                    //
                    CoInstallerInternalContext[i].CoInstallerEntryPoint = InstallParamBlock->CoInstallerList[i].CoInstallerEntryPoint;

                    WriteLogEntry(
                              LogContext,
                              DRIVER_LOG_TIME,
                              MSG_LOG_COINST_START,
                              NULL,
                              i+1,InstallParamBlock->CoInstallerCount);

                    spFusionEnterContext(CoInstallerInternalContext[i].CoInstallerFusionContext,
                                         &spFusionInstance);
                    try {
                        Err = CoInstallerInternalContext[i].CoInstallerEntryPoint(
                                  InstallFunction,
                                  DeviceInfoSet,
                                  DeviceInfoData,
                                  &(CoInstallerInternalContext[i].Context)
                                 );
                    } finally {
                        spFusionLeaveContext(&spFusionInstance);
                    }

                    ASSERT_HEAP_IS_VALID();

                    if(Err != NO_ERROR && Err != ERROR_DI_POSTPROCESSING_REQUIRED) {
                        ErrorLevel = FilterLevelOnInstallerError(ErrorLevel,Err);
                        WriteLogEntry(
                                  LogContext,
                                  ErrorLevel | SETUP_LOG_BUFFER,
                                  MSG_LOG_COINST_END_ERROR,
                                  NULL,
                                  i+1,InstallParamBlock->CoInstallerCount);
                        WriteLogError(
                                  LogContext,
                                  ErrorLevel,
                                  Err);
                        MuteError = TRUE; // already logged it
                        goto clean0;
                    } else {
                        WriteLogEntry(
                                  LogContext,
                                  DRIVER_LOG_VERBOSE1,
                                  MSG_LOG_COINST_END,
                                  NULL,
                                  i+1,InstallParamBlock->CoInstallerCount);
                        if(Err == ERROR_DI_POSTPROCESSING_REQUIRED) {
                            CoInstallerInternalContext[i].DoPostProcessing = TRUE;
                        }
                    }
                }
            }

            //
            // If there is a class installer entry point, then call it.
            //
            if(InstallParamBlock->ClassInstallerEntryPoint) {
                //
                // Make sure we don't have the HDEVINFO locked.
                //
                if(pDeviceInfoSet) {
                    UnlockDeviceInfoSet(pDeviceInfoSet);
                    pDeviceInfoSet = NULL;
                }

                WriteLogEntry(
                          LogContext,
                          DRIVER_LOG_TIME,
                          MSG_LOG_CI_START,
                          NULL);
                spFusionEnterContext(InstallParamBlock->ClassInstallerFusionContext,
                                     &spFusionInstance);
                try {
                    Err = InstallParamBlock->ClassInstallerEntryPoint(InstallFunction,
                                                                  DeviceInfoSet,
                                                                  DeviceInfoData
                                                                 );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }
                ASSERT_HEAP_IS_VALID();
                if((Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {
                    ErrorLevel = FilterLevelOnInstallerError(ErrorLevel,Err);
                    WriteLogEntry(
                              LogContext,
                              ErrorLevel | SETUP_LOG_BUFFER,
                              MSG_LOG_CI_END_ERROR,
                              NULL);
                    WriteLogError(
                              LogContext,
                              ErrorLevel,
                              Err);
                    MuteError = TRUE; // already logged it
                } else {
                    WriteLogEntry(
                              LogContext,
                              DRIVER_LOG_VERBOSE1,
                              MSG_LOG_CI_END,
                              NULL);
                }

                if (Err != ERROR_DI_DO_DEFAULT) {
                    //
                    // class installer handled
                    //
                    goto clean0;
                }

            } else {
                Err = ERROR_DI_DO_DEFAULT;
            }
        }

        //
        // Now we need to retrieve the parameter block all over again (we don't
        // know what the class installer function might have done).
        //
        // First, re-acquire the lock on the HDEVINFO, if we released it above in order
        // to call the class installer.
        //
        if(!pDeviceInfoSet) {
            if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
                Err = ERROR_INVALID_HANDLE;
                goto clean0;
            }
        }

        if(DeviceInfoData) {
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DeviceInfoData,
                                                       NULL)) {

                InstallParamBlock = &(DevInfoElem->InstallParamBlock);
            } else {
                //
                // The device information element appears to have been
                // destroyed--treat this as if the DI_NODI_DEFAULTACTION
                // flag was set.
                //
                goto clean0;
            }
        } else {
            InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
        }

        if(InstallParamBlock->Flags & DI_NODI_DEFAULTACTION) {
            //
            // We shouldn't provide a default action--just return the class installer result.
            //
            goto clean0;
        }

        Err = NO_ERROR;

        if((InstallFunction == DIF_SELECTDEVICE) && !(InstallParamBlock->Flags & DI_NOSELECTICONS)) {
            //
            // We don't want to display mini-icons in the default Select Device case.
            // Temporarily set the flag that prevents this.
            //
            InstallParamBlock->Flags |= DI_NOSELECTICONS;
            bRestoreMiniIconUsage = TRUE;
        }

        //
        // Now, release the HDEVINFO lock before calling the appropriate handler routine.
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        WriteLogEntry(
                  LogContext,
                  DRIVER_LOG_VERBOSE1,
                  MSG_LOG_CI_DEF_START,
                  NULL);

        switch(InstallFunction) {

            case DIF_SELECTDEVICE :

                b = SetupDiSelectDevice(DeviceInfoSet, DeviceInfoData);

                //
                // If we need to reset the DI_NOSELECTICONS flag we set above, then re-acquire
                // the lock and do that now.
                //
                if(bRestoreMiniIconUsage &&
                   (pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {

                    if(DeviceInfoData) {
                        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                                   DeviceInfoData,
                                                                   NULL)) {

                            InstallParamBlock = &(DevInfoElem->InstallParamBlock);
                        } else {
                            InstallParamBlock = NULL;
                        }
                    } else {
                        InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
                    }

                    if(InstallParamBlock) {
                        InstallParamBlock->Flags &= ~DI_NOSELECTICONS;
                    }
                }
                break;

            case DIF_SELECTBESTCOMPATDRV :

                b = SetupDiSelectBestCompatDrv(DeviceInfoSet, DeviceInfoData);
                if(!b && (GetLastError() == ERROR_NO_COMPAT_DRIVERS)) {
                    ErrorLevel = DRIVER_LOG_WARNING;
                }
                break;

            case DIF_INSTALLDEVICE :

                b = SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_INSTALLDEVICEFILES :

                b = SetupDiInstallDriverFiles(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_INSTALLINTERFACES :

                b = SetupDiInstallDeviceInterfaces(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_REGISTER_COINSTALLERS :

                b = SetupDiRegisterCoDeviceInstallers(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_REMOVE :

                b = SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_UNREMOVE :

                b = SetupDiUnremoveDevice(DeviceInfoSet, DeviceInfoData);
                break;

            //
            // These are new messages for class installers such as the Network, where the
            // class installer will do all of the work.  If no action is taken, ie, the
            // class installer return ERROR_DI_DO_DEFAULT, then we return OK, since there
            // is no default action for these cases.
            //
            case DIF_SELECTCLASSDRIVERS:
            case DIF_VALIDATECLASSDRIVERS:
            case DIF_INSTALLCLASSDRIVERS:

                b = TRUE;
                Err = ERROR_DI_DO_DEFAULT;
                break;

            case DIF_MOVEDEVICE :

                b = SetupDiMoveDuplicateDevice(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_PROPERTYCHANGE :

                b = SetupDiChangeState(DeviceInfoSet, DeviceInfoData);
                break;

            case DIF_REGISTERDEVICE :

                b = SetupDiRegisterDeviceInfo(DeviceInfoSet,
                                              DeviceInfoData,
                                              0,
                                              NULL,
                                              NULL,
                                              NULL
                                             );
                break;

            //
            // If the DIF_ message is not one of the above, and it is not handled,
            // then let the caller handle it in a default manner.
            //
            default :
                b = TRUE;
                Err = ERROR_DI_DO_DEFAULT;
                break;
        }

        if(!b) {
            Err = GetLastError();
        }
        if(!MuteError) {
            if(Err != NO_ERROR && Err != ERROR_DI_DO_DEFAULT) {
                ErrorLevel = FilterLevelOnInstallerError(ErrorLevel,Err);
                WriteLogEntry(
                          LogContext,
                          ErrorLevel | SETUP_LOG_BUFFER,
                          MSG_LOG_CI_DEF_END_ERROR,
                          NULL);
                WriteLogError(
                          LogContext,
                          ErrorLevel,
                          Err);
                MuteError = TRUE; // already logged it
            } else {
                WriteLogEntry(
                          LogContext,
                          DRIVER_LOG_VERBOSE1,
                          MSG_LOG_CI_DEF_END,
                          NULL);
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variables, so that the compiler will respect our statement
        // ordering w.r.t. assignment.
        //
        pDeviceInfoSet = pDeviceInfoSet;
        CoInstallerInternalContext = CoInstallerInternalContext;
        i = i;
        DevInfoElem = DevInfoElem;
    }

    //
    // If we remove the DI_QUIETINSTALL flag up above then we need to put it back now.
    //
    if (bRestoreDiQuietInstall) {
        InstallParamBlock->Flags |= DI_QUIETINSTALL;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    ASSERT_HEAP_IS_VALID();

    //
    // Do a post-processing callback to any of the co-installers that requested one.
    //
    for(i--; i >= 0; i--) {

        if(CoInstallerInternalContext[i].DoPostProcessing) {

            CoInstallerInternalContext[i].Context.PostProcessing = TRUE;
            CoInstallerInternalContext[i].Context.InstallResult = Err;
            LastErr = Err;

            try {

                WriteLogEntry(
                          LogContext,
                          DRIVER_LOG_TIME,
                          MSG_LOG_COINST_POST_START,
                          NULL,
                          i+1);
                spFusionEnterContext(CoInstallerInternalContext[i].CoInstallerFusionContext,
                                     &spFusionInstance);
                try {
                    Err = CoInstallerInternalContext[i].CoInstallerEntryPoint(
                          InstallFunction,
                          DeviceInfoSet,
                          DevInfoElem ? DeviceInfoData : NULL,
                          &(CoInstallerInternalContext[i].Context)
                         );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }

                ASSERT_HEAP_IS_VALID();

                if((Err != LastErr) &&
                   ((LastErr != ERROR_DI_DO_DEFAULT) || (Err != NO_ERROR))) {
                    //
                    // If error status has changed (even to success)
                    // log this as an error
                    //
                    if(((LastErr == NO_ERROR) || (LastErr == ERROR_DI_DO_DEFAULT))
                        && (Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {
                        WriteLogEntry(
                                  LogContext,
                                  ErrorLevel | SETUP_LOG_BUFFER,
                                  MSG_LOG_COINST_POST_END_ERROR,
                                  NULL,
                                  i+1);

                        WriteLogError(
                                  LogContext,
                                  ErrorLevel,
                                  Err);
                    } else {
                        WriteLogEntry(
                                  LogContext,
                                  DRIVER_LOG_WARNING | SETUP_LOG_BUFFER,
                                  MSG_LOG_COINST_POST_CHANGE_ERROR,
                                  NULL,
                                  i+1);

                        WriteLogError(
                                  LogContext,
                                  DRIVER_LOG_WARNING,
                                  Err);
                    }
                } else {
                    WriteLogEntry(
                              LogContext,
                              DRIVER_LOG_VERBOSE1,
                              MSG_LOG_COINST_POST_END,
                              NULL,
                              i+1);
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                ;   // ignore any co-installer that generates an exception during post-processing.
            }
        }
    }

    if(CoInstallerInternalContext) {
        MyFree(CoInstallerInternalContext);
    }

    //
    // If we just did a DIF_REGISTER_COINSTALLERS, then we invalidated our current list of
    // co-installers.  Clear our list, so it will be retrieved next time.
    // (NOTE:  Normally, the default action will be taken (i.e., SetupDiRegisterCoDeviceInstallers),
    // which will have already invalidated the list.  The class installer may have handled
    // this themselves, however, so we'll invalidate the list here as well just to be safe.)
    //
    if(InstallFunction == DIF_REGISTER_COINSTALLERS) {
        InvalidateHelperModules(DeviceInfoSet, DeviceInfoData, IHM_COINSTALLERS_ONLY);
    }

    if(!MuteError && Err != NO_ERROR && Err != ERROR_DI_DO_DEFAULT) {
        ErrorLevel = FilterLevelOnInstallerError(ErrorLevel,Err);
        WriteLogEntry(
                  LogContext,
                  ErrorLevel | SETUP_LOG_BUFFER,
                  MSG_LOG_CCI_ERROR,
                  NULL,
                  i+1);
        WriteLogError(
                  LogContext,
                  ErrorLevel,
                  Err);
    }

    if(slot_dif_code) {
        ReleaseLogInfoSlot(LogContext,slot_dif_code);
    }

    if (ChangedThreadLogContext) {
        //
        // restore thread log context
        //
        SetThreadLogContext(SavedLogContext,NULL);
        DeleteLogContext(LogContext); // counter RefLogContext
    }

    if(hCatAdmin) {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiInstallClassExA(
    IN HWND        hwndParent,         OPTIONAL
    IN PCSTR       InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    )
{
    PCWSTR inf;
    DWORD rc;
    BOOL b;

    if(InfFileName) {
        rc = pSetupCaptureAndConvertAnsiArg(InfFileName,&inf);
    } else {
        rc = NO_ERROR;
        inf = NULL;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupDiInstallClassExW(hwndParent,inf,Flags,FileQueue,InterfaceClassGuid,Reserved1,Reserved2);
    rc = GetLastError();

    if(inf) {
        MyFree(inf);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiInstallClassExW(
    IN HWND        hwndParent,         OPTIONAL
    IN PCWSTR      InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(InfFileName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(FileQueue);
    UNREFERENCED_PARAMETER(InterfaceClassGuid);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiInstallClassEx(
    IN HWND        hwndParent,         OPTIONAL
    IN PCTSTR      InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    )
/*++

Routine Description:

    This routine either:

        a) Installs a class installer by running the [ClassInstall32] section
           of the specified INF, or
        b) Installs an interface class specified in the InterfaceClassGuid
           parameter, running the install section for this class as listed in
           the [InterfaceInstall32] of the specified INF (if there is no entry,
           then installation simply involves creating the interface class subkey
           under the DeviceClasses key.

    If the InterfaceClassGuid parameter is specified, then we're installing an
    interface class (case b), otherwise, we're installing a class installer
    (case a).

Arguments:

    hwndParent - Optionally, supplies the handle of the parent window for any
        UI brought up as a result of installing this class.

    InfFileName - Optionally, supplies the name of the INF file containing a
        [ClassInstall32] section (if we're installing a class installer), or
        an [InterfaceInstall32] section with an entry for the specified interface
        class (if we're installing an interface class).  If installing a class
        installer, this parameter _must_ be supplied.

    Flags - Flags that control the installation.  May be a combination of the following:

        DI_NOVCP - This flag should be specified if HSPFILEQ is supplied.  This
            instructs SetupInstallFromInfSection to not create a queue of its
            own, and instead to use the caller-supplied one.  If this flag is
            specified, then no file copying will be done.

        DI_NOBROWSE - This flag should be specified if no file browsing should
            be allowed in the event a copy operation cannot find a specified
            file.  If the user supplies their own file queue, then this flag is
            ignored.

        DI_FORCECOPY - This flag should be specified if the files should always
            be copied, even if they're already present on the user's machine
            (i.e., don't ask the user if they want to keep their existing files).
            If the user supplies their own file queue, then this flag is ignored.

        DI_QUIETINSTALL - This flag should be specified if UI should be suppressed
            unless absolutely necessary (i.e., no progress dialog).  If the user
            supplies their own queue, then this flag is ignored.

            (NOTE:  During GUI-mode setup on Windows NT, quiet-install behavior
            is always employed in the absence of a user-supplied file queue.)

    FileQueue - If the DI_NOVCP flag is specified, then this parameter supplies a handle
        to a file queue where file operations are to be queued (but not committed).

    InterfaceClassGuid - Optionally, specifies the interface class to be installed.
        If this parameter is not specified, then we are installing a class installer
        whose class is the class of the INF specified by InfFileName.

    Reserved1, Reserved2 - Reserved for future use.  Must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This API is generally called by the Device Manager when it installs a device
    of a new (setup) class.

    Class installers may also use this API to install new interface classes.  Note
    that interface class installation can also happen automatically as a result of
    installing interface devices for a device instance (via SetupDiInstallInterfaceDevices).

--*/

{
    HINF hInf;
    DWORD Err, ScanQueueResult;
    TCHAR ClassInstallSectionName[MAX_SECT_NAME_LEN];
    GUID ClassGuid;
    HKEY hKey;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL KeyNewlyCreated;
    PCTSTR GuidString, ClassName;
    BOOL CloseFileQueue;
    PTSTR SectionExtension;
    INFCONTEXT InterfaceClassInstallLine;
    PCTSTR UndecoratedInstallSection;
    DWORD InstallFlags;
    HMACHINE hMachine;
    REGMOD_CONTEXT RegContext;
    BOOL NoProgressUI;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;

    //
    // Validate the flags.
    //
    if(Flags & ~(DI_NOVCP | DI_NOBROWSE | DI_FORCECOPY | DI_QUIETINSTALL)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // If the caller didn't specify an interface class GUID (i.e., we're installing a
    // class installer), then they'd better have supplied us with an INF filename.
    // Also, they have to pass NULL for the Reserved argument.
    //
    if((!InterfaceClassGuid && !InfFileName) || Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure that the caller supplied us with a file queue, if necessary.
    //
    if((Flags & DI_NOVCP) && (!FileQueue || (FileQueue == INVALID_HANDLE_VALUE))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(hwndParent && !IsWindow(hwndParent)) {
        hwndParent = NULL;
    }

    //
    //Take reserved field to be a hMachine. Since it is spec'd
    //to be NULL that will translate to the local machine, which is all we currently
    //support. Or do we want to make Reserved 1 a structure, and hMachine part of it?
    //This is for future expansion
    //
    hMachine = (HMACHINE) Reserved1;


    if(InfFileName) {

        if((hInf = SetupOpenInfFile(InfFileName,
                                    NULL,
                                    INF_STYLE_WIN4,
                                    NULL)) == INVALID_HANDLE_VALUE) {
            //
            // Last error is already set--just return failure.
            //
            return FALSE;
        }
        Err = InheritLogContext(((PLOADED_INF) hInf)->LogContext,&LogContext);
    } else {
        hInf = INVALID_HANDLE_VALUE;
        Err = CreateLogContext(NULL,TRUE,&LogContext);
    }
    if (Err != NO_ERROR) {
        SetupCloseInfFile(hInf);
        SetLastError(Err);
        return FALSE;
    }
    //
    // we will look at ClassGuid at the end to give more error context
    // give it a zero-value so that we don't get random data
    // if we haven't initialized it before then
    //
    ZeroMemory(&ClassGuid,sizeof(ClassGuid));

    Err = NO_ERROR;
    MsgHandlerContext = NULL;
    hKey = NULL;
    KeyNewlyCreated = FALSE;
    CloseFileQueue = FALSE;

    try {

        if(InterfaceClassGuid) {
            TCHAR ClassGuidBuffer[GUID_STRING_LEN];
            //
            // Copy this GUID into our ClassGuid variable, which is used for
            // both installer and device interface classes.
            //
            CopyMemory(&ClassGuid, InterfaceClassGuid, sizeof(ClassGuid));

            //
            // Legacy (compatibility) class name is not needed for device
            // interface classes.
            //
            ClassName = NULL;

            if(pSetupStringFromGuid(&ClassGuid, ClassGuidBuffer, GUID_STRING_LEN) != NO_ERROR) {
                ClassGuidBuffer[0]=TEXT('*');
                ClassGuidBuffer[1]=TEXT('\0');
            }
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_INFO,
                MSG_LOG_DO_INTERFACE_CLASS_INSTALL,
                NULL,       // text message
                ClassGuidBuffer);

        } else {
            //
            // Retrieve the class GUID from the INF.  If it has no class GUID, then
            // we can't install from it (even if it specifies the class name).
            //
            // We utilize the fact that an INF handle is really a LOADED_INF pointer,
            // combined with the fact that no one else will ever access this handle
            // (hence no synchronization issues).  This permits us to retrieve this
            // version datum much more efficiently.
            //
            if(!(GuidString = pSetupGetVersionDatum(&((PLOADED_INF)hInf)->VersionBlock,
                                                    pszClassGuid))
               || (pSetupGuidFromString(GuidString, &ClassGuid) != NO_ERROR)) {

                Err = ERROR_INVALID_CLASS;
                goto clean0;
            }

            //
            // We'll need to get the class name out of the INF as well.
            //
            if(!(ClassName = pSetupGetVersionDatum(&((PLOADED_INF)hInf)->VersionBlock,
                                                   pszClass))) {
                Err = ERROR_INVALID_CLASS;
                goto clean0;
            }
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_INFO,
                MSG_LOG_DO_CLASS_INSTALL,
                NULL,       // text message
                (GuidString?GuidString:TEXT("*")),
                (ClassName?ClassName:TEXT("*")));
        }

        //
        // First, attempt to open the key (i.e., not create it).  If that fails,
        // then we'll try to create it.  That way, we can keep track of whether
        // clean-up is required if an error occurs.
        //
        if(CR_SUCCESS != CM_Open_Class_Key_Ex(&ClassGuid,
                                              ClassName,
                                              KEY_ALL_ACCESS,
                                              RegDisposition_OpenExisting,
                                              &hKey,
                                              InterfaceClassGuid ? CM_OPEN_CLASS_KEY_INTERFACE
                                                                 : CM_OPEN_CLASS_KEY_INSTALLER,
                                              hMachine))
        {
            //
            // The key doesn't already exist--we've got to create it.
            //
            if(CR_SUCCESS != CM_Open_Class_Key_Ex(&ClassGuid,
                                                  ClassName,
                                                  KEY_ALL_ACCESS,
                                                  RegDisposition_OpenAlways,
                                                  &hKey,
                                                  InterfaceClassGuid ? CM_OPEN_CLASS_KEY_INTERFACE
                                                                     : CM_OPEN_CLASS_KEY_INSTALLER,
                                                  hMachine))
            {
                hKey = NULL;    // make sure it's still NULL
                Err = ERROR_INVALID_DATA;
                goto clean0;
            }

            KeyNewlyCreated = TRUE;
        }

        if(hInf == INVALID_HANDLE_VALUE) {
            //
            // We've done all we need to do to install this interface device.
            //
            goto clean0;

        } else {
            //
            // Append the layout INF, if necessary.
            //
            SetupOpenAppendInfFile(NULL, hInf, NULL);
        }

        if(InterfaceClassGuid) {
            //
            // Look for an entry for this interface class in the [InterfaceInstall32] section
            // of the INF.
            //
            TCHAR GuidStringBuffer[GUID_STRING_LEN];

            pSetupStringFromGuid(InterfaceClassGuid, GuidStringBuffer, SIZECHARS(GuidStringBuffer));

            if(!SetupFindFirstLine(hInf,
                                   pszInterfaceInstall32,
                                   GuidStringBuffer,
                                   &InterfaceClassInstallLine)) {
                //
                // No install entry in this INF--we're done.
                //
                goto clean0;
            }

            //
            // Make sure the Flags field is zero.
            //
            if(SetupGetIntField(&InterfaceClassInstallLine, 2, (PINT)&InstallFlags) && InstallFlags) {
                Err = ERROR_BAD_INTERFACE_INSTALLSECT;
                goto clean0;
            }

            if((!(UndecoratedInstallSection = pSetupGetField(&InterfaceClassInstallLine, 1)))
               || !(*UndecoratedInstallSection))
            {
                //
                // No install section was given--we're done.
                //
                goto clean0;
            }

        } else {
            UndecoratedInstallSection = pszClassInstall32;

            ZeroMemory(&RegContext, sizeof(RegContext));
            RegContext.Flags |= INF_PFLAG_CLASSPROP;
            RegContext.ClassGuid = &ClassGuid;
            RegContext.hMachine = hMachine;
        }

        //
        // Get the 'real' (potentially OS/architecture-specific) class install
        // section name.
        //
        if(!SetupDiGetActualSectionToInstall(hInf,
                                             UndecoratedInstallSection,
                                             ClassInstallSectionName,
                                             SIZECHARS(ClassInstallSectionName),
                                             NULL,
                                             &SectionExtension
                                             )) {
            Err = GetLastError();
            goto clean0;
        }
        //
        // Also say what section is about to be installed.
        //
        WriteLogEntry(LogContext,
            DRIVER_LOG_VERBOSE,
            MSG_LOG_CLASS_SECTION,
            NULL,
            ClassInstallSectionName);
        //
        // If this is the undecorated name, then make sure that the section actually exists.
        //
        if(!SectionExtension && (SetupGetLineCount(hInf, ClassInstallSectionName) == -1)) {
            Err = ERROR_SECTION_NOT_FOUND;
            WriteLogEntry(LogContext,
                DRIVER_LOG_ERROR,
                MSG_LOG_NOSECTION,
                NULL,
                ClassInstallSectionName);
            goto clean0;
        }

        if(!(Flags & DI_NOVCP)) {
            //
            // Since we may need to check the queued files to determine whether file copy
            // is necessary, we have to open our own queue, and commit it ourselves.
            //
            if((FileQueue = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                CloseFileQueue = TRUE;
            } else {
                //
                // SetupOpenFileQueue sets actual error
                //
                Err = GetLastError();
                goto clean0;
            }

            NoProgressUI = (GuiSetupInProgress ||
                            (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ||
                            (Flags & DI_QUIETINSTALL));

            if(!(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                         hwndParent,
                                         (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                         0,
                                         0,
                                         NULL))) {

                Err = ERROR_NOT_ENOUGH_MEMORY;
                SetupCloseFileQueue(FileQueue);
                CloseFileQueue = FALSE;
                goto clean0;
            }
            MsgHandler = SetupDefaultQueueCallback;
        }
        //
        // Replace the file queue's log context with current, if it's never been used
        //
        InheritLogContext(LogContext,&((PSP_FILE_QUEUE) FileQueue)->LogContext);

        Err = pSetupInstallFiles(hInf,
                                 NULL,
                                 ClassInstallSectionName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                     ((Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                 NULL,
                                 FileQueue,
                                 //
                                 // This flag is ignored by pSetupInstallFiles
                                 // because we don't pass a callback here and we
                                 // pass a user-defined file queue. (In other words
                                 // we're not committing the queue so there's no
                                 // callback function to deal with, and the callback
                                 // would be the guy who would care about ansi vs unicode.)
                                 //
                                 TRUE
                                );

        if(CloseFileQueue) {
            //
            // Call _SetupVerifyQueuedCatalogs separately (i.e., don't let it
            // happen automatically as a result of scanning/committing the
            // queue that happens below).  We do this beforehand so that we
            // know what unique name was generated when an OEM INF was
            // installed into %windir%\Inf (in case we need to delete the
            // INF/PNF/CAT files later if we encounter an error).
            //
            if(Err == NO_ERROR) {
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_INSTCLASS_VERIFY_CAT_TIME,
                    NULL);       // text message

                //
                // (NOTE: We don't have the context in this routine to
                // determine whether or not the INF is from the internet.  For
                // now, just assume it isn't.)
                //
                Err = _SetupVerifyQueuedCatalogs(
                          hwndParent,
                          FileQueue,
                          VERCAT_INSTALL_INF_AND_CAT,
                          szNewName,
                          &OemInfFileToCopy
                         );

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_END_INSTCLASS_VERIFY_CAT_TIME,
                    NULL);       // text message
            }

            if(Err == NO_ERROR) {
                //
                // We successfully queued up the file operations--now we need
                // to commit the queue.  First off, though, we should check to
                // see if the files are already there.  (If the 'force copy'
                // flag is set, then we don't care if the files are already
                // there--we always need to copy them in that case.)
                //
                if(Flags & DI_FORCECOPY) {
                    //
                    // always copy the files.
                    //
                    ScanQueueResult = 0;
                } else {
                    //
                    // Determine whether the queue actually needs to be committed.
                    //
                    // ScanQueueResult can have 1 of 3 values:
                    //
                    // 0: Some files were missing or invalid (i.e., digital
                    //    signatures weren't verified;
                    //    Must commit queue.
                    //
                    // 1: All files to be copied are already present/valid, and
                    //    the queue is empty;
                    //    Can skip committing queue.
                    //
                    // 2: All files to be copied are already present/valid, but
                    //    del/ren queues not empty.  Must commit queue. The
                    //    copy queue will have been emptied, so only del/ren
                    //    functions will be performed.
                    //
                    //
                    if(!SetupScanFileQueue(FileQueue,
                                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                                           hwndParent,
                                           NULL,
                                           NULL,
                                           &ScanQueueResult)) {
                        //
                        // SetupScanFileQueue should really never
                        // fail when you don't ask it to call a
                        // callback routine, but if it does, just
                        // go ahead and commit the queue.
                        //
                        ScanQueueResult = 0;
                    }
                }

                if(ScanQueueResult != 1) {
                    //
                    // Copy enqueued files. In this case the callback is
                    // SetupDefaultQueueCallback, so we know it's native char width.
                    //
                    if(!_SetupCommitFileQueue(hwndParent,
                                              FileQueue,
                                              MsgHandler,
                                              MsgHandlerContext,
                                              TRUE)) {
                        Err = GetLastError();
                    }
                }
            }

            //
            // Close our file queue handle.
            //
            SetupCloseFileQueue(FileQueue);
            CloseFileQueue = FALSE;
        }

        //
        // Terminate the default queue callback, if it was created.  (Do this before
        // checking the return status of the file copying.)
        //
        if(MsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
            MsgHandlerContext = NULL;
        }

        if(Err != NO_ERROR) {
            goto clean0;
        }

        //
        // If we get to here, then the file copying was successful--now we can perform
        // the rest of the installation. We don't pass a callback so we don't worry
        // about ansi vs unicode issues here.
        //
        if(!_SetupInstallFromInfSection(NULL,
                                        hInf,
                                        ClassInstallSectionName,
                                        SPINST_INIFILES
                                        | SPINST_REGISTRY
                                        | SPINST_INI2REG
                                        | SPINST_BITREG
                                        | SPINST_REGSVR
                                        | SPINST_UNREGSVR
                                        | SPINST_PROFILEITEMS,
                                        hKey,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL,
                                        INVALID_HANDLE_VALUE,
                                        NULL,
                                        TRUE,
                                        (InterfaceClassGuid ? NULL : &RegContext)
                                       )) {
            Err = GetLastError();
            goto clean0;
        }
        //
        // the class installer might want to install a Services section, allow that here
        // only if running on NT
        // this allows a class installer to install a class-wide driver
        //
        if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {

            TCHAR ClassInstallServicesSectionName[SIZECHARS(ClassInstallSectionName)+SIZECHARS(pszServicesSectionSuffix)];
            BOOL NullDriverInstall = FALSE;

            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_SERVICE_TIME,
                NULL);       // text message

            //
            // The install section name is of the form:
            //
            //     ClassInstall32[.<ext>].Services
            //
            lstrcpy(ClassInstallServicesSectionName,ClassInstallSectionName);
            lstrcat(ClassInstallServicesSectionName,pszServicesSectionSuffix);

            Err = InstallNtService(NULL,
                                   hInf,
                                   InfFileName,
                                   ClassInstallServicesSectionName,
                                   NULL,
                                   SPSVCINST_NO_DEVINST_CHECK,
                                   &NullDriverInstall
                                  );
        }


clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(MsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseFileQueue) {
            SetupCloseFileQueue(FileQueue);
        }

        //
        // Reference the following variables so that the compiler will respect
        // our statement order w.r.t. assignment.
        //
        hKey = hKey;
        KeyNewlyCreated = KeyNewlyCreated;
        OemInfFileToCopy = OemInfFileToCopy;
    }

    if(hKey) {
        RegCloseKey(hKey);
        if((Err != NO_ERROR) && KeyNewlyCreated && !InterfaceClassGuid) {
            //
            // We hit an error, and the class installer key didn't previously exist,
            // so we want to remove it.
            //
            CM_Delete_Class_Key_Ex(&ClassGuid, CM_DELETE_CLASS_SUBKEYS,hMachine);
        }
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if (Err == NO_ERROR) {
        //
        // if we're >= DRIVER_LOG_INFO, give a +ve affirmation of install
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_CLASS_INSTALLED,
            NULL,
            NULL);
    } else {
        //
        // indicate install failed, display error
        // we make an extra effort here to log the guid
        //
        TCHAR ClassGuidBuffer[GUID_STRING_LEN];

        if(pSetupStringFromGuid(&ClassGuid, ClassGuidBuffer, GUID_STRING_LEN) != NO_ERROR) {
            ClassGuidBuffer[0]=TEXT('*');
            ClassGuidBuffer[1]=TEXT('\0');
        }

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_CLASS_ERROR_ENCOUNTERED,
            NULL,
            ClassGuidBuffer);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);

        //
        // If we copied the OEM INF into the INF directory under a
        // newly-generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    if (LogContext) {
        DeleteLogContext(LogContext);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiInstallClassA(
    IN HWND     hwndParent,  OPTIONAL
    IN PCSTR    InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    )
{
    PCWSTR inf;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(InfFileName,&inf);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    b = SetupDiInstallClassExW(hwndParent,inf,Flags,FileQueue,NULL,NULL,NULL);
    rc = GetLastError();

    MyFree(inf);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiInstallClassW(
    IN HWND     hwndParent,  OPTIONAL
    IN PCWSTR   InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(InfFileName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(FileQueue);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiInstallClass(
    IN HWND     hwndParent,  OPTIONAL
    IN PCTSTR   InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    )
/*++

Routine Description:

    This routine installs the [ClassInstall32] section of the specified INF.

Arguments:

    hwndParent - Optionally, supplies the handle of the parent window for any
        UI brought up as a result of installing this class.

    InfFileName - Supplies the name of the INF file containing a [ClassInstall32]
        section

    Flags - Flags that control the installation.  May be a combination of the following:

        DI_NOVCP - This flag should be specified if HSPFILEQ is supplied.  This
            instructs SetupInstallFromInfSection to not create a queue of its
            own, and instead to use the caller-supplied one.  If this flag is
            specified, then no file copying will be done.

        DI_NOBROWSE - This flag should be specified if no file browsing should
            be allowed in the event a copy operation cannot find a specified
            file.  If the user supplies their own file queue, then this flag is
            ignored.

        DI_FORCECOPY - This flag should be specified if the files should always
            be copied, even if they're already present on the user's machine
            (i.e., don't ask the user if they want to keep their existing files).
            If the user supplies their own file queue, then this flag is ignored.

        DI_QUIETINSTALL - This flag should be specified if UI should be suppressed
            unless absolutely necessary (i.e., no progress dialog).  If the user
            supplies their own queue, then this flag is ignored.

            (NOTE:  During GUI-mode setup on Windows NT, quiet-install behavior
            is always employed in the absence of a user-supplied file queue.)

    FileQueue - If the DI_NOVCP flag is specified, then this parameter supplies a handle
        to a file queue where file operations are to be queued (but not committed).

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This API is generally called by the Device Manager when it installs a device
    of a new class.

--*/
{
    return SetupDiInstallClassEx(hwndParent,
                                 InfFileName,
                                 Flags,
                                 FileQueue,
                                 NULL,
                                 NULL,
                                 NULL
                                );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    return SetupDiGetHwProfileFriendlyNameExA(HwProfile,
                                              FriendlyName,
                                              FriendlyNameSize,
                                              RequiredSize,
                                              NULL,
                                              NULL
                                             );
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameW(
    IN  DWORD  HwProfile,
    OUT PWSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(HwProfile);
    UNREFERENCED_PARAMETER(FriendlyName);
    UNREFERENCED_PARAMETER(FriendlyNameSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetHwProfileFriendlyName(
    IN  DWORD  HwProfile,
    OUT PTSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
/*++

Routine Description:

    See SetupDiGetHwProfileFriendlyNameEx for details.

--*/

{
    return SetupDiGetHwProfileFriendlyNameEx(HwProfile,
                                             FriendlyName,
                                             FriendlyNameSize,
                                             RequiredSize,
                                             NULL,
                                             NULL
                                            );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCSTR  MachineName,      OPTIONAL
    IN  PVOID  Reserved
    )
{
    WCHAR UnicodeName[MAX_PROFILE_LEN];
    PSTR nameA;
    BOOL b;
    DWORD rc;
    DWORD requiredSize;
    PCWSTR UnicodeMachineName;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
    } else {
        UnicodeMachineName = NULL;
    }

    b = SetupDiGetHwProfileFriendlyNameExW(HwProfile,
                                           UnicodeName,
                                           SIZECHARS(UnicodeName),
                                           &requiredSize,
                                           UnicodeMachineName,
                                           Reserved
                                          );
    rc = GetLastError();

    if(b) {

        if(nameA = pSetupUnicodeToAnsi(UnicodeName)) {

            requiredSize = lstrlenA(nameA) + 1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(b) {
                if(requiredSize > FriendlyNameSize) {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                } else {
                    if(!lstrcpyA(FriendlyName,nameA)) {
                        //
                        // lstrcpy faulted, caller passed in bogus buffer.
                        //
                        rc = ERROR_INVALID_USER_BUFFER;
                        b = FALSE;
                    }
                }
            }

            MyFree(nameA);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExW(
    IN  DWORD  HwProfile,
    OUT PWSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCWSTR MachineName,      OPTIONAL
    IN  PVOID  Reserved
    )
{
    UNREFERENCED_PARAMETER(HwProfile);
    UNREFERENCED_PARAMETER(FriendlyName);
    UNREFERENCED_PARAMETER(FriendlyNameSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameEx(
    IN  DWORD  HwProfile,
    OUT PTSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCTSTR MachineName,      OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This routine retrieves the friendly name associated with a hardware profile ID.

Arguments:

    HwProfile - Supplies the hardware profile ID whose friendly name is to be
        retrieved.  If this parameter is 0, then the friendly name for the
        current hardware profile is retrieved.

    FriendlyName - Supplies the address of a character buffer that receives the
        friendly name of the hardware profile.

    FriendlyNameSize - Supplies the size, in characters, of the FriendlyName buffer.

    RequiredSize - Optionally, supplies the address of a variable that receives the
        number of characters required to store the friendly name (including
        terminating NULL).

    MachineName - Optionally, supplies the name of the remote machine containing the
        hardware profile whose friendly name is to be retrieved.  If this parameter
        is not specified, the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = ERROR_INVALID_HWPROFILE;
    HWPROFILEINFO HwProfInfo;
    ULONG i;
    CONFIGRET cr = CR_SUCCESS;
    DWORD NameLen;
    HMACHINE hMachine;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the caller specified a remote machine name, connect to that machine
    //
    if(MachineName) {
        cr = CM_Connect_Machine(MachineName, &hMachine);
        if(cr != CR_SUCCESS) {
            SetLastError(MapCrToSpError(cr, ERROR_INVALID_DATA));
            return FALSE;
        }
    } else {
        hMachine = NULL;
    }

    //
    // If a hardware profile ID of 0 is specified, then retrieve information
    // about the current hardware profile, otherwise, enumerate the hardware
    // profiles, looking for the one specified.
    //
    if(HwProfile) {
        i = 0;
    } else {
        i = 0xFFFFFFFF;
    }

    do {

        if((cr = CM_Get_Hardware_Profile_Info_Ex(i, &HwProfInfo, 0, hMachine)) == CR_SUCCESS) {
            //
            // Hardware profile info retrieved--see if it's what we're looking for.
            //
            if(!HwProfile || (HwProfInfo.HWPI_ulHWProfile == HwProfile)) {

                try {

                    NameLen = lstrlen(HwProfInfo.HWPI_szFriendlyName) + 1;

                    if(RequiredSize) {
                        *RequiredSize = NameLen;
                    }

                    if(NameLen > FriendlyNameSize) {
                        Err = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        Err = NO_ERROR;
                        CopyMemory(FriendlyName,
                                   HwProfInfo.HWPI_szFriendlyName,
                                   NameLen * sizeof(TCHAR)
                                  );
                    }

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Err = ERROR_INVALID_PARAMETER;
                }

                break;
            }
            //
            // This wasn't the profile we wanted--go on to the next one.
            //
            i++;

        } else if(!HwProfile || (cr != CR_NO_SUCH_VALUE)) {
            //
            // We should abort on any error other than CR_NO_SUCH_VALUE, otherwise
            // we might loop forever!
            //
            Err = ERROR_INVALID_DATA;
            break;
        }

    } while(cr != CR_NO_SUCH_VALUE);

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetHwProfileList(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves a list of all currently-defined hardware profile IDs.

Arguments:

    HwProfileList - Supplies the address of an array of DWORDs that will receive
        the list of currently defined hardware profile IDs.

    HwProfileListSize - Supplies the number of DWORDs in the HwProfileList array.

    RequiredSize - Supplies the address of a variable that receives the number
        of hardware profiles currently defined.  If this number is larger than
        HwProfileListSize, then the list will be truncated to fit the array size,
        and this value will indicate the array size that would be required to store
        the entire list (the function will fail, with GetLastError returning
        ERROR_INSUFFICIENT_BUFFER in that case).

    CurrentlyActiveIndex - Optionally, supplies the address of a variable that
        receives the index within the HwProfileList array of the currently active
        hardware profile.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    return SetupDiGetHwProfileListEx(HwProfileList,
                                     HwProfileListSize,
                                     RequiredSize,
                                     CurrentlyActiveIndex,
                                     NULL,
                                     NULL
                                    );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetHwProfileListExA(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCSTR  MachineName,          OPTIONAL
    IN  PVOID  Reserved
    )
{
    PCWSTR UnicodeMachineName;
    DWORD rc;
    BOOL b;

    b = FALSE;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
    } else {
        UnicodeMachineName = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        b = SetupDiGetHwProfileListExW(HwProfileList,
                                       HwProfileListSize,
                                       RequiredSize,
                                       CurrentlyActiveIndex,
                                       UnicodeMachineName,
                                       Reserved
                                      );
        rc = GetLastError();
        if(UnicodeMachineName) {
            MyFree(UnicodeMachineName);
        }
    }

    SetLastError(rc);
    return b;
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiGetHwProfileListExW(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCWSTR MachineName,          OPTIONAL
    IN  PVOID  Reserved
    )
{
    UNREFERENCED_PARAMETER(HwProfileList);
    UNREFERENCED_PARAMETER(HwProfileListSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(CurrentlyActiveIndex);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetHwProfileListEx(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCTSTR MachineName,          OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This routine retrieves a list of all currently-defined hardware profile IDs.

Arguments:

    HwProfileList - Supplies the address of an array of DWORDs that will receive
        the list of currently defined hardware profile IDs.

    HwProfileListSize - Supplies the number of DWORDs in the HwProfileList array.

    RequiredSize - Supplies the address of a variable that receives the number
        of hardware profiles currently defined.  If this number is larger than
        HwProfileListSize, then the list will be truncated to fit the array size,
        and this value will indicate the array size that would be required to store
        the entire list (the function will fail, with GetLastError returning
        ERROR_INSUFFICIENT_BUFFER in that case).

    CurrentlyActiveIndex - Optionally, supplies the address of a variable that
        receives the index within the HwProfileList array of the currently active
        hardware profile.

    MachineName - Optionally, specifies the name of the remote machine to retrieve
        a list of hardware profiles for.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR;
    DWORD CurHwProfile;
    HWPROFILEINFO HwProfInfo;
    ULONG i;
    CONFIGRET cr = CR_SUCCESS;
    HMACHINE hMachine;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the caller specified a remote machine name, connect to that machine now.
    //
    if(MachineName) {
        cr = CM_Connect_Machine(MachineName, &hMachine);
        if(cr != CR_SUCCESS) {
            SetLastError(MapCrToSpError(cr, ERROR_INVALID_DATA));
            return FALSE;
        }
    } else {
        hMachine = NULL;
    }

    //
    // First retrieve the currently active hardware profile ID, so we'll know what
    // to look for when we're enumerating all profiles (only need to do this if the
    // user wants the index of the currently active hardware profile).
    //
    if(CurrentlyActiveIndex) {

        if((cr = CM_Get_Hardware_Profile_Info_Ex(0xFFFFFFFF, &HwProfInfo, 0, hMachine)) == CR_SUCCESS) {
            //
            // Store away the hardware profile ID.
            //
            CurHwProfile = HwProfInfo.HWPI_ulHWProfile;

        } else {
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            goto clean0;
        }
    }

    try {
        //
        // Enumerate the hardware profiles, retrieving the ID for each.
        //
        i = 0;
        do {

            if((cr = CM_Get_Hardware_Profile_Info_Ex(i, &HwProfInfo, 0, hMachine)) == CR_SUCCESS) {
                if(i < HwProfileListSize) {
                    HwProfileList[i] = HwProfInfo.HWPI_ulHWProfile;
                }
                if(CurrentlyActiveIndex && (HwProfInfo.HWPI_ulHWProfile == CurHwProfile)) {
                    *CurrentlyActiveIndex = i;
                    //
                    // Clear the CurrentlyActiveIndex pointer, so we once we find the
                    // currently active profile, we won't have to keep comparing.
                    //
                    CurrentlyActiveIndex = NULL;
                }
                i++;
            }

        } while(cr == CR_SUCCESS);

        if(cr == CR_NO_MORE_HW_PROFILES) {
            //
            // Then we enumerated all hardware profiles.  Now see if we had enough
            // buffer to hold them all.
            //
            *RequiredSize = i;
            if(i > HwProfileListSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            //
            // Something else happened (probably a key not present).
            //
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

clean0:

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupDiGetCoInstallerList(
    IN     HDEVINFO                 DeviceInfoSet,
    IN     PSP_DEVINFO_DATA         DeviceInfoData,    OPTIONAL
    IN     CONST GUID              *ClassGuid,
    IN OUT PDEVINSTALL_PARAM_BLOCK  InstallParamBlock,
    IN OUT HCATADMIN               *hCatAdmin          OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the list of co-installers (both class- and
    device-specific) and stores the entry points and module handles in
    the supplied install param block.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to retrieve
        co-installers into.  If DeviceInfoSet is not specified, then the
        InstallParamBlock specified below will be that of the set itself.

    DeviceInfoData - Optionally, specifies the device information element
        for which a list of co-installers is to be retrieved.

    ClassGuid - Supplies the address of the (install) class GUID for which
        class-specific co-installers are to be retrieved.

    InstallParamBlock - Supplies the address of the install param block where
        the co-installer list is to be stored.  This will either be the param
        block of the set itself (if DeviceInfoData isn't specified), or of
        the specified device information element.

    hCatAdmin - optionally, supplies the address of an HCATADMIN handle.  If
        the handle pointed to is NULL, a handle will be acquired (if possible)
        via CryptCATAdminAcquireContext and returned to the caller.  If the
        handle pointed to is non-NULL, then that handle will be used for any
        validation done via this routine.  If the pointer itself is NULL, then
        an hCatAdmin will be acquired for the duration of this call, and
        released before returning.

        NOTE: it is the caller's responsibility to free the crypto context
        handle returned by this routine by calling CryptCATAdminReleaseContext.
        This handle may be opened in either success or failure cases, so the
        caller must check for non-NULL returned handle in both cases.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise it is
    a Win32 error code indicating the cause of failure.

--*/
{
    HKEY hk[2];
    DWORD Err, RegDataType, KeyIndex;
    LONG i;
    PTSTR CoInstallerBuffer;
    DWORD CoInstallerBufferSize;
    PTSTR CurEntry;
    PCOINSTALLER_NODE CoInstallerList, TempCoInstallerList;
    DWORD CoInstallerListSize;
    TCHAR GuidString[GUID_STRING_LEN];
    TCHAR DescBuffer[LINE_LEN];
    PTSTR DeviceDesc;
    HWND hwndParent;
    BOOL MustAbort;

    //
    // If there is already a list, then return success immediately.
    //
    if(InstallParamBlock->CoInstallerCount != -1) {
        return NO_ERROR;
    }

    //
    // Retrieve the parent window handle, as we may need it below if we need to
    // popup UI due to unsigned class-/co-installers.
    //
    if(hwndParent = InstallParamBlock->hwndParent) {
       if(!IsWindow(hwndParent)) {
            hwndParent = NULL;
       }
    }

    //
    // Retrieve a device description to use in case we need to give a driver
    // signing warn/block popup.
    //
    if(GetBestDeviceDesc(DeviceInfoSet, DeviceInfoData, DescBuffer)) {
        DeviceDesc = DescBuffer;
    } else {
        DeviceDesc = NULL;
    }

    //
    // Get the string form of the class GUID, because that will be the name of
    // the multi-sz value entry under HKLM\System\CCS\Control\CoDeviceInstallers
    // where class-specific co-installers will be registered
    //
    if (ClassGuid) {
        pSetupStringFromGuid(ClassGuid, GuidString, SIZECHARS(GuidString));
    } else {
        lstrcpy(GuidString,pszGuidNull);
    }

    //
    // Open the CoDeviceInstallers key, as well as the device's driver key (if a devinfo
    // element is specified).
    //
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszPathCoDeviceInstallers, 0, KEY_READ, &(hk[0]));

    if(Err != ERROR_SUCCESS) {
        hk[0] = INVALID_HANDLE_VALUE;
    }

    if(DeviceInfoData) {

        hk[1] = SetupDiOpenDevRegKey(DeviceInfoSet,
                                     DeviceInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DRV,
                                     KEY_READ
                                    );

    } else {
        hk[1] = INVALID_HANDLE_VALUE;
    }

    CoInstallerBuffer = NULL;
    CoInstallerBufferSize = 256 * sizeof(TCHAR);    // start out with 256-character buffer
    CoInstallerList = NULL;
    i = 0;

    try {

        for(KeyIndex = 0; KeyIndex < 2; KeyIndex++) {
            //
            // If we couldn't open a key for this location, move on to the next one.
            //
            if(hk[KeyIndex] == INVALID_HANDLE_VALUE) {
                continue;
            }

            //
            // Retrieve the multi-sz value containing the co-installer entries.
            //
            while(TRUE) {

                if(!CoInstallerBuffer) {
                    if(!(CoInstallerBuffer = MyMalloc(CoInstallerBufferSize))) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                }

                Err = RegQueryValueEx(hk[KeyIndex],
                                      (KeyIndex ? pszCoInstallers32
                                                : GuidString),
                                      NULL,
                                      &RegDataType,
                                      (PBYTE)CoInstallerBuffer,
                                      &CoInstallerBufferSize
                                     );

                if(Err == ERROR_MORE_DATA) {
                    //
                    // Buffer wasn't large enough--free current one and try again with new size.
                    //
                    MyFree(CoInstallerBuffer);
                    CoInstallerBuffer = NULL;
                } else {
                    break;
                }
            }

            //
            // Only out-of-memory errors are treated as fatal here.
            //
            if(Err == ERROR_NOT_ENOUGH_MEMORY) {
                goto cleanClass0;
            } else if(Err == ERROR_SUCCESS) {
                //
                // Make sure the buffer we got back looks valid.
                //
                if((RegDataType != REG_MULTI_SZ) || (CoInstallerBufferSize < sizeof(TCHAR))) {
                    Err = ERROR_INVALID_COINSTALLER;
                    goto cleanClass0;
                }

                //
                // Count the number of entries in this multi-sz list.
                //
                for(CoInstallerListSize = 0, CurEntry = CoInstallerBuffer;
                    *CurEntry;
                    CoInstallerListSize++, CurEntry += (lstrlen(CurEntry) + 1)
                   );

                if(!CoInstallerListSize) {
                    //
                    // List is empty, move on to next one.
                    //
                    continue;
                }

                //
                // Allocate (or reallocate) an array large enough to hold this many co-installer entries.
                //
                if(CoInstallerList) {
                    TempCoInstallerList = MyRealloc(CoInstallerList,
                                                    (CoInstallerListSize + i) * sizeof(COINSTALLER_NODE)
                                                   );
                } else {
                    MYASSERT(i == 0);
                    TempCoInstallerList = MyMalloc(CoInstallerListSize * sizeof(COINSTALLER_NODE));
                }

                if(TempCoInstallerList) {
                    CoInstallerList = TempCoInstallerList;
                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanClass0;
                }

                //
                // Now loop through the list and get the co-installer for each entry.
                //
                for(CurEntry = CoInstallerBuffer; *CurEntry; CurEntry += (lstrlen(CurEntry) + 1)) {
                    //
                    // Initialize the hinstance to NULL, so we'll know whether or not we need to free
                    // the module if we hit an exception here.
                    //
                    CoInstallerList[i].hinstCoInstaller = NULL;

                    Err = GetModuleEntryPoint(INVALID_HANDLE_VALUE,
                                              CurEntry,
                                              pszCoInstallerDefaultProc,
                                              &(CoInstallerList[i].hinstCoInstaller),
                                              &((FARPROC)CoInstallerList[i].CoInstallerEntryPoint),
                                              &(CoInstallerList[i].CoInstallerFusionContext),
                                              &MustAbort,
                                              InstallParamBlock->LogContext,
                                              hwndParent,
                                              ClassGuid,
                                              SetupapiVerifyCoInstProblem,
                                              DeviceDesc,
                                              DRIVERSIGN_NONE,
                                              TRUE,
                                              hCatAdmin
                                             );

                    if(Err == NO_ERROR) {
                        i++;
                    } else {
                        //
                        // If the error we encountered above causes us to abort
                        // (e.g., due to a driver signing problem), then get
                        // out now.  Otherwise, just skip this failed entry and
                        // move on to the next.
                        //
                        if(MustAbort) {
                            goto cleanClass0;
                        }
                    }
                }
            }
        }

        //
        // If we get to here then we've successfully retrieved the co-installer
        // list(s)
        //
        Err = NO_ERROR;

cleanClass0:
        ;       // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_COINSTALLER;
        //
        // Reference the following variables so the compiler will respect our
        // statement ordering w.r.t. assignment.
        //
        CoInstallerBuffer = CoInstallerBuffer;
        CoInstallerList = CoInstallerList;
    }

    if(CoInstallerBuffer) {
        MyFree(CoInstallerBuffer);
    }

    for(KeyIndex = 0; KeyIndex < 2; KeyIndex++) {
        if(hk[KeyIndex] != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk[KeyIndex]);
        }
    }

    if(Err == NO_ERROR) {
        InstallParamBlock->CoInstallerList  = CoInstallerList;
        InstallParamBlock->CoInstallerCount = i;
    } else if(CoInstallerList) {
        MyFree(CoInstallerList);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devinfo.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    devinfo.c

Abstract:

    Device Installer routines dealing with device information sets

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define the context structure used by the default device comparison
// callback (used by SetupDiRegisterDeviceInfo).
//
typedef struct _DEFAULT_DEVCMP_CONTEXT {

    PCS_RESOURCE NewDevCsResource;
    PCS_RESOURCE CurDevCsResource;
    ULONG        CsResourceSize;    // applies to both buffers.

} DEFAULT_DEVCMP_CONTEXT, *PDEFAULT_DEVCMP_CONTEXT;


//
// Private routine prototypes.
//
DWORD
pSetupOpenAndAddNewDevInfoElem(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PCTSTR           DeviceInstanceId,
    IN  BOOL             AllowPhantom,
    IN  CONST GUID      *ClassGuid,              OPTIONAL
    IN  HWND             hwndParent,             OPTIONAL
    OUT PDEVINFO_ELEM   *DevInfoElem,
    IN  BOOL             CheckIfAlreadyThere,
    OUT PBOOL            AlreadyPresent,         OPTIONAL
    IN  BOOL             OpenExistingOnly,
    IN  ULONG            CmLocateFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet
    );

DWORD
pSetupAddNewDeviceInfoElement(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  DEVINST          DevInst,
    IN  CONST GUID      *ClassGuid,
    IN  PCTSTR           Description,             OPTIONAL
    IN  HWND             hwndParent,              OPTIONAL
    IN  DWORD            DiElemFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet,
    OUT PDEVINFO_ELEM   *DeviceInfoElement
    );

DWORD
pSetupClassGuidFromDevInst(
    IN  DEVINST DevInst,
    IN  HMACHINE hMachine,
    OUT LPGUID  ClassGuid
    );

DWORD
pSetupDupDevCompare(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA NewDeviceData,
    IN PSP_DEVINFO_DATA ExistingDeviceData,
    IN PVOID            CompareContext
    );

DWORD
pSetupAddInterfaceDeviceToDevInfoElem(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINFO_ELEM           DevInfoElem,
    IN  CONST GUID             *ClassGuid,
    IN  PTSTR                   InterfaceDeviceName,
    IN  BOOL                    IsActive,
    IN  BOOL                    IsDefault,
    IN  BOOL                    StoreTruncateNode,
    IN  BOOL                    OpenExistingOnly,
    OUT PINTERFACE_DEVICE_NODE *InterfaceDeviceNode  OPTIONAL
    );

DWORD
_SetupDiOpenInterfaceDevice(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PTSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData OPTIONAL
    );

DWORD
pSetupGetDevInstNameAndStatusForInterfaceDevice(
    IN  HKEY   hKeyInterfaceClass,
    IN  PCTSTR InterfaceDeviceName,
    OUT PTSTR  OwningDevInstName,     OPTIONAL
    IN  DWORD  OwningDevInstNameSize,
    OUT PBOOL  IsActive,              OPTIONAL
    OUT PBOOL  IsDefault              OPTIONAL
    );

BOOL
pSetupDiGetOrSetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            InContext,
    OUT PDWORD           OutContext      OPTIONAL
    );


HDEVINFO
WINAPI
SetupDiCreateDeviceInfoList(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN HWND        hwndParent OPTIONAL
    )
/*++

Routine Description:

    This API creates an empty device information set that will contain device
    device information member elements.  This set may be associated with an
    optionally-specified class GUID.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the class GUID that is to be
        associated with this set.

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installation of a class driver contained
        in this set's global class driver list (if it has one).

Return Value:

    If the function succeeds, the return value is a handle to an empty device
    information set.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

--*/
{
    return SetupDiCreateDeviceInfoListEx(ClassGuid, hwndParent, NULL, NULL);
}


#ifdef UNICODE
//
// ANSI version
//
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExA(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCSTR       MachineName, OPTIONAL
    IN PVOID       Reserved
    )
{
    PCWSTR UnicodeMachineName;
    DWORD rc;
    HDEVINFO hDevInfo;

    hDevInfo = INVALID_HANDLE_VALUE;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
    } else {
        UnicodeMachineName = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        hDevInfo = SetupDiCreateDeviceInfoListExW(ClassGuid,
                                                  hwndParent,
                                                  UnicodeMachineName,
                                                  Reserved
                                                 );
        rc = GetLastError();
        if(UnicodeMachineName) {
            MyFree(UnicodeMachineName);
        }
    }

    SetLastError(rc);
    return hDevInfo;
}
#else
//
// Unicode version
//
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExW(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCWSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListEx(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCTSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    )
/*++

Routine Description:

    This API creates an empty device information set that will contain device
    device information member elements.  This set may be associated with an
    optionally-specified class GUID.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the class GUID that is to be
        associated with this set.

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installation of a class driver contained
        in this set's global class driver list (if it has one).

    MachineName - Optionally, supplies the name of the machine for which this
        device information set is to be related.  Only devices on that machine
        may be opened/created.  If this parameter is NULL, then the local machine
        is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is a handle to an empty device
    information set.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET DeviceInfoSet;
    DWORD Err = NO_ERROR;
    CONFIGRET cr;

    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if(DeviceInfoSet = AllocateDeviceInfoSet()) {

        try {
            //
            // If the user specified the name of a remote machine, connect to
            // that machine now.
            //
            if(MachineName) {

                if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &(DeviceInfoSet->hMachine)))) {
                    //
                    // Make sure hMachine is still NULL, so we won't try to disconnect later.
                    //
                    DeviceInfoSet->hMachine = NULL;
                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                    goto clean0;
                }

                //
                // Store the machine name in the string table, so it can be
                // retrieved later via SetupDiGetDeviceInfoListDetail.
                //
                if(-1 == (DeviceInfoSet->MachineName = pStringTableAddString(DeviceInfoSet->StringTable,
                                                                             (PTSTR)MachineName,
                                                                             STRTAB_CASE_SENSITIVE,
                                                                             NULL,
                                                                             0))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            if(ClassGuid) {
                //
                // If a class GUID was specified, then store it away in
                // the device information set.
                //
                CopyMemory(&(DeviceInfoSet->ClassGuid),
                           ClassGuid,
                           sizeof(GUID)
                          );
                DeviceInfoSet->HasClassGuid = TRUE;
            }

            DeviceInfoSet->InstallParamBlock.hwndParent = hwndParent;

clean0:     ;   // nothing to do.

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_PARAMETER;
            //
            // Reference the following variable so the compiler will respect statement ordering
            // w.r.t. assignment.
            //
            DeviceInfoSet->hMachine = DeviceInfoSet->hMachine;
        }

        if(Err != NO_ERROR) {
            DestroyDeviceInfoSet(NULL, DeviceInfoSet);
        }

    } else {
        Err = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(Err);

    return (Err == NO_ERROR) ? (HDEVINFO)DeviceInfoSet
                             : (HDEVINFO)INVALID_HANDLE_VALUE;
}


BOOL
WINAPI
SetupDiGetDeviceInfoListClass(
    IN  HDEVINFO DeviceInfoSet,
    OUT LPGUID   ClassGuid
    )
/*++

Routine Description:

    This API retrieves the class GUID associated with a device information
    set (if it has an associated class).

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set whose associated
        class is being queried.

    ClassGuid - Supplies a pointer to a variable that receives the GUID for the
        associated class.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If the set has no associated class, then
    GetLastError will return ERROR_NO_ASSOCIATED_CLASS.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(pDeviceInfoSet->HasClassGuid) {
            //
            // Copy the GUID to the user-supplied buffer.
            //
            CopyMemory(ClassGuid,
                       &(pDeviceInfoSet->ClassGuid),
                       sizeof(GUID)
                      );
        } else {
            Err = ERROR_NO_ASSOCIATED_CLASS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailA(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A DeviceInfoSetDetailData
    )
{
    DWORD rc;
    BOOL b;
    SP_DEVINFO_LIST_DETAIL_DATA_W UnicodeDevInfoSetDetails;

    UnicodeDevInfoSetDetails.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA_W);

    b = SetupDiGetDeviceInfoListDetailW(DeviceInfoSet, &UnicodeDevInfoSetDetails);
    rc = GetLastError();

    if(b) {
        rc = pSetupDiDevInfoSetDetailDataUnicodeToAnsi(&UnicodeDevInfoSetDetails, DeviceInfoSetDetailData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailW(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_W DeviceInfoSetDetailData
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoSetDetailData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDeviceInfoListDetail(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA   DeviceInfoSetDetailData
    )
/*++

Routine Description:

    This routine retrieves information about the specified device information set,
    such as its associated class (if any), and the remote machine it was opened for
    (if this is a remoted HDEVINFO).  This API supercedes SetupDiGetDeviceInfoListClass.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to retrieve
        detailed information for.

    DeviceInfoSetDetailData - Supplies the address of a structure that receives
        information about the specified device information set.  This structure is
        defined as follows:

            typedef struct _SP_DEVINFO_LIST_DETAIL_DATA {
                DWORD  cbSize;
                GUID   ClassGuid;
                HANDLE RemoteMachineHandle;
                TCHAR  RemoteMachineName[SP_MAX_MACHINENAME_LENGTH];
            } SP_DEVINFO_LIST_DETAIL_DATA, *PSP_DEVINFO_LIST_DETAIL_DATA;

        where:

            ClassGuid specifies the class associated with the device information
                set, or GUID_NULL if there is no associated class.

            RemoteMachineHandle is the ConfigMgr32 machine handle used to access
                the remote machine, if this is a remoted HDEVINFO (i.e., a
                MachineName was specified when the set was created via
                SetupDiCreateDeviceInfoListEx or SetupDiGetClassDevsEx).  All
                DevInst handles stored in SP_DEVINFO_DATA structures for elements
                of this set are relative to this handle, and must be used in
                combination with this handle when calling any CM_*_Ex APIs.

                If this is not a device information set for a remote machine, this
                field will be NULL.

                NOTE:  DO NOT destroy this handle via CM_Disconnect_Machine.  This
                handle will be cleaned up when the device information set is destroyed
                via SetupDiDestroyDeviceInfoList.

            RemoteMachineName specifies the name used to connect to the remote
                machine whose handle is stored in RemoteMachineHandle.  If this is
                not a device information set for a remote machine, this will be an
                empty string.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The cbSize field of the output structure must be set to
    sizeof(SP_DEVINFO_LIST_DETAIL_DATA) or the  call will fail with
    ERROR_INVALID_USER_BUFFER.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PCTSTR MachineName;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoSetDetailData->cbSize != sizeof(SP_DEVINFO_LIST_DETAIL_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Store the set's associated class GUID, or GUID_NULL if there isn't one.
        //
        if(pDeviceInfoSet->HasClassGuid) {
            CopyMemory(&(DeviceInfoSetDetailData->ClassGuid),
                       &(pDeviceInfoSet->ClassGuid),
                       sizeof(GUID)
                      );
        } else {
            CopyMemory(&(DeviceInfoSetDetailData->ClassGuid), &GUID_NULL, sizeof(GUID));
        }

        DeviceInfoSetDetailData->RemoteMachineHandle = pDeviceInfoSet->hMachine;

        //
        // If this is a remoted HDEVINFO, store the machine name in the caller's buffer,
        // otherwise store an empty string.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
            lstrcpyn(DeviceInfoSetDetailData->RemoteMachineName,
                     MachineName,
                     SIZECHARS(DeviceInfoSetDetailData->RemoteMachineName)
                    );
        } else {
            MYASSERT(pDeviceInfoSet->MachineName == -1);
            *(DeviceInfoSetDetailData->RemoteMachineName) = TEXT('\0');
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDestroyDeviceInfoList(
    IN  HDEVINFO DeviceInfoSet
    )
/*++

Routine Description:

    This API destroys a device information set, freeing all associated memory.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set to be destroyed.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err;
    PDEVICE_INFO_SET pDeviceInfoSet;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    try {
        Err = DestroyDeviceInfoSet(DeviceInfoSet, pDeviceInfoSet);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiCreateDeviceInfoA(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCSTR             DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCSTR             DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    PCWSTR deviceName,deviceDescription;
    DWORD rc;
    BOOL b;

    b = FALSE;
    rc = pSetupCaptureAndConvertAnsiArg(DeviceName,&deviceName);
    if(rc == NO_ERROR) {

        if(DeviceDescription) {
            rc = pSetupCaptureAndConvertAnsiArg(DeviceDescription,&deviceDescription);
        } else {
            deviceDescription = NULL;
        }

        if(rc == NO_ERROR) {

            b = SetupDiCreateDeviceInfoW(
                    DeviceInfoSet,
                    deviceName,
                    ClassGuid,
                    deviceDescription,
                    hwndParent,
                    CreationFlags,
                    DeviceInfoData
                    );

            rc = GetLastError();

            if(deviceDescription) {
                MyFree(deviceDescription);
            }
        }

        MyFree(deviceName);

    } else {
        //
        // The DeviceName parameter was bad--return the same error the unicode API does.
        //
        rc = ERROR_INVALID_DEVINST_NAME;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiCreateDeviceInfoW(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCWSTR            DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCWSTR            DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceName);
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(DeviceDescription);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(CreationFlags);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiCreateDeviceInfo(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCTSTR            DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCTSTR            DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
/*++

Routine Description:

    This API creates a new device information element, and adds it as a new member
    to the specified set.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set to which this
        new device information element is to be added.

    DeviceName - Supplies either a full device instance ID (e.g., Root\*PNP0500\0000)
        or a Root-enumerated device ID, minus enumerator branch prefix and instance
        ID suffix (e.g., *PNP0500).  The latter may only be specified if the
        DICD_GENERATE_ID flag is specified in the CreationFlags parameter.

    ClassGuid - Supplies a pointer to the GUID for this device's class.  If the
        class is not yet known, this value should be GUID_NULL.

    DeviceDescription - Optionally, supplies a textual description of the device.

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installing the device.

    CreationFlags - Supplies flags controlling how the device information element
        is to be created.  May be a combination of the following values:

        DICD_GENERATE_ID -       If this flag is specified, then DeviceName contains only
                                 a Root-enumerated device ID, and needs to have a unique
                                 device instance key created for it.  This unique device
                                 instance key will be generated as:

                                     Enum\Root\<DeviceName>\<InstanceID>

                                 where <InstanceID> is a 4-digit, base-10 number that
                                 is unique among all subkeys under Enum\Root\<DeviceName>.
                                 The API, SetupDiGetDeviceInstanceId, may be called to
                                 find out what ID was generated for this device information
                                 element.

        DICD_INHERIT_CLASSDRVS - If this flag is specified, then the resulting device
                                 information element will inherit the class driver list (if any)
                                 associated with the device information set itself.  In addition,
                                 if there is a selected driver for the device information set,
                                 that same driver will be selected for the new device information
                                 element.

    DeviceInfoData - Optionaly, supplies a pointer to the variable that receives
        a context structure initialized for this new device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If this device instance is being added to a set that has an associated class,
    then the device class must be the same, or the call will fail, and GetLastError
    will return ERROR_CLASS_MISMATCH.

    If the specified device instance is the same as an existing device instance key in
    the registry, the call will fail with ERROR_DEVINST_ALREADY_EXISTS.  (This only
    applies if DICD_GENERATE_ID is not specified.)

    The specified class GUID will be written out to the ClassGUID device instance
    value entry.  If the class name can be retrieved (via SetupDiClassNameFromGuid),
    then it will be written to the Class value entry as well.

    If the new device information element was successfully created, but the
    user-supplied DeviceInfoData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The device information element
    _will_ have been added as a new member of the set, however.

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, StringLen;
    PDEVINFO_ELEM DevInfoElem, PrevTailDevInfoElem;
    DEVINST DevInst, RootDevInst;
    CONFIGRET cr;
    ULONG CmFlags;
    TCHAR TempString[GUID_STRING_LEN];
    PDRIVER_LIST_OBJECT CurDrvListObject;

    //
    // We use the TempString buffer both for the string representation of
    // a Class GUID, and for the Class name.  The following assert ensures
    // that our assumptions about the relative lengths of these two strings
    // continues to be valid.
    //
    MYASSERT(GUID_STRING_LEN >= MAX_CLASS_NAME_LEN);

    if(CreationFlags & ~(DICD_GENERATE_ID | DICD_INHERIT_CLASSDRVS)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    DevInst = 0;
    DevInfoElem = NULL;

    try {
        //
        // Get a pointer to the current tail of the devinfo element list for this
        // set, so that we can easily lop off the new node if we encounter an error
        // after insertion.
        //
        PrevTailDevInfoElem = pDeviceInfoSet->DeviceInfoTail;

        //
        // Get a handle to the root device instance, to be used as the parent
        // for the phantom device instance we're about to create.
        //
        if(CM_Locate_DevInst_Ex(&RootDevInst, NULL, CM_LOCATE_DEVINST_NORMAL,
                                pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            //
            // We're really hosed if we can't get a handle to the root device
            // instance!
            //
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        //
        // Create a handle to a phantom device instance.
        //
        CmFlags = CM_CREATE_DEVINST_PHANTOM;

        if(CreationFlags & DICD_GENERATE_ID) {
            CmFlags |= CM_CREATE_DEVINST_GENERATE_ID;
        }

        if((cr = CM_Create_DevInst_Ex(&DevInst,
                                   (DEVINSTID)DeviceName,
                                   RootDevInst,
                                   CmFlags,
                                   pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
            //
            // Make sure DevInst handle is still invalid, so we won't try to
            // delete it later.
            //
            DevInst = 0;
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            goto clean0;
        }

        if(NO_ERROR != (Err = pSetupAddNewDeviceInfoElement(pDeviceInfoSet,
                                                            DevInst,
                                                            ClassGuid,
                                                            DeviceDescription,
                                                            hwndParent,
                                                            DIE_IS_PHANTOM,
                                                            pDeviceInfoSet,
                                                            &DevInfoElem))) {
            //
            // Make sure DevInfoElem is still NULL, so we won't try to free it later.
            //
            DevInfoElem = NULL;
            goto clean0;
        }

        //
        // Now, set the Class and ClassGUID properties for the new device instance.
        //
        pSetupStringFromGuid(ClassGuid, TempString, SIZECHARS(TempString));
        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                         CM_DRP_CLASSGUID,
                                         (PVOID)TempString,
                                         GUID_STRING_LEN * sizeof(TCHAR),
                                         0,pDeviceInfoSet->hMachine);


        if(!IsEqualGUID(ClassGuid, &GUID_NULL) &&
           SetupDiClassNameFromGuid(ClassGuid,
                                    TempString,
                                    SIZECHARS(TempString),
                                    &StringLen)) {

            CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                             CM_DRP_CLASS,
                                             (PVOID)TempString,
                                             StringLen * sizeof(TCHAR),
                                             0,pDeviceInfoSet->hMachine);
        }

        //
        // If the caller wants the newly-created devinfo element to inherit the global
        // class driver list, do that now.
        //
        if((CreationFlags & DICD_INHERIT_CLASSDRVS) && (pDeviceInfoSet->ClassDriverHead)) {
            //
            // Find the global class driver list in the devinfo set's list of driver lists.
            //
            CurDrvListObject = GetAssociatedDriverListObject(pDeviceInfoSet->ClassDrvListObjectList,
                                                             pDeviceInfoSet->ClassDriverHead,
                                                             NULL
                                                            );
            MYASSERT(CurDrvListObject && (CurDrvListObject->RefCount > 0));

            //
            // We found the driver list object, now do the inheritance, and increment the refcount.
            //
            DevInfoElem->ClassDriverCount = pDeviceInfoSet->ClassDriverCount;
            DevInfoElem->ClassDriverHead  = pDeviceInfoSet->ClassDriverHead;
            DevInfoElem->ClassDriverTail  = pDeviceInfoSet->ClassDriverTail;

            if(DevInfoElem->SelectedDriver = pDeviceInfoSet->SelectedClassDriver) {
                DevInfoElem->SelectedDriverType = SPDIT_CLASSDRIVER;
            }

            DevInfoElem->InstallParamBlock.Flags   |= CurDrvListObject->ListCreationFlags;
            DevInfoElem->InstallParamBlock.FlagsEx |= CurDrvListObject->ListCreationFlagsEx;
            DevInfoElem->InstallParamBlock.DriverPath = CurDrvListObject->ListCreationDriverPath;

            CurDrvListObject->RefCount++;
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so the compiler will respect our statement ordering
        // w.r.t. assignment.
        //
        DevInst = DevInst;
        DevInfoElem = DevInfoElem;
        PrevTailDevInfoElem = PrevTailDevInfoElem;
    }

    if(Err == NO_ERROR) {

        if(DeviceInfoData) {
            //
            // The user supplied a buffer to receive a SP_DEVINFO_DATA
            // structure, so fill that in now.
            //
            try {

                if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                      DevInfoElem,
                                                      DeviceInfoData))) {
                    Err = ERROR_INVALID_USER_BUFFER;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                Err = ERROR_INVALID_USER_BUFFER;
            }
        }

    } else if(DevInst) {

        //
        // This should never fail.
        //
        cr = CM_Uninstall_DevInst(DevInst, 0);
        MYASSERT(cr == CR_SUCCESS);

        if(DevInfoElem) {
            //
            // An error occurred after we created the device information element--clean it up now.
            //
            try {

                MYASSERT(!DevInfoElem->Next);
                if(PrevTailDevInfoElem) {
                    MYASSERT(PrevTailDevInfoElem->Next == DevInfoElem);
                    PrevTailDevInfoElem->Next = NULL;
                    pDeviceInfoSet->DeviceInfoTail = PrevTailDevInfoElem;
                } else {
                    pDeviceInfoSet->DeviceInfoHead = pDeviceInfoSet->DeviceInfoTail = NULL;
                }

                MYASSERT(pDeviceInfoSet->DeviceInfoCount > 0);
                pDeviceInfoSet->DeviceInfoCount--;

                MyFree(DevInfoElem);

            } except(EXCEPTION_EXECUTE_HANDLER) {
                ;   // nothing to do.
            }
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiOpenDeviceInfoA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCSTR            DeviceInstanceId,
    IN  HWND             hwndParent,        OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData     OPTIONAL
    )
{
    PCWSTR deviceInstanceId;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(DeviceInstanceId,&deviceInstanceId);
    if(rc == NO_ERROR) {

        b = SetupDiOpenDeviceInfoW(
                DeviceInfoSet,
                deviceInstanceId,
                hwndParent,
                OpenFlags,
                DeviceInfoData
                );

        rc = GetLastError();

        MyFree(deviceInstanceId);

    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiOpenDeviceInfoW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,        OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData     OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInstanceId);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(OpenFlags);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiOpenDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCTSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    )
/*++

Routine Description:

    This API retrieves information about an existing device instance, and adds
    it to the specified device information set.  If a device information element
    already exists for this device instance, the existing element is returned.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set to which the
        opened device information element is to be added.

    DeviceInstanceId - Supplies the ID of the device instance.  This is the
        registry path (relative to the Enum branch) of the device instance key.
        (E.g., Root\*PNP0500\0000)

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installing the device.

    OpenFlags - Supplies flags controlling how the device information element
        is to be opened.  May be a combination of the following values:

        DIOD_INHERIT_CLASSDRVS - If this flag is specified, then the resulting device
                                 information element will inherit the class driver
                                 list (if any) associated with the device information
                                 set itself.  In addition, if there is a selected
                                 driver for the device information set, that same
                                 driver will be selected for the new device information
                                 element.

                                 If the device information element was already present,
                                 its class driver list (if any) will be replaced with
                                 this new, inherited, list.

        DIOD_CANCEL_REMOVE     - If this flag is set, a device that was marked for removal
                                 will be have its pending removal cancelled.

    DeviceInfoData - Optionally, supplies a pointer to the variable that receives
        a context structure initialized for the opened device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If this device instance is being added to a set that has an associated class,
    then the device class must be the same, or the call will fail, and GetLastError
    will return ERROR_CLASS_MISMATCH.

    If the new device information element was successfully opened, but the
    user-supplied DeviceInfoData buffer is invalid, this API will return FALSE,
    with GetLastError returning ERROR_INVALID_USER_BUFFER.  The device information
    element _will_ have been added as a new member of the set, however.

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_LIST_OBJECT CurDrvListObject;
    BOOL AlreadyPresent;

    if(OpenFlags & ~(DIOD_INHERIT_CLASSDRVS | DIOD_CANCEL_REMOVE)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                             DeviceInstanceId,
                                             TRUE,
                                             NULL,
                                             hwndParent,
                                             &DevInfoElem,
                                             TRUE,
                                             &AlreadyPresent,
                                             FALSE,
                                             ((OpenFlags & DIOD_CANCEL_REMOVE)
                                                 ? CM_LOCATE_DEVNODE_CANCELREMOVE : 0),
                                             pDeviceInfoSet
                                            );

        if(Err != NO_ERROR) {
            goto clean0;
        }

        //
        // If the caller wants the newly-opened devinfo element to inherit the global
        // class driver list, do that now.
        //
        if(OpenFlags & DIOD_INHERIT_CLASSDRVS) {
            //
            // If this devinfo element already existed, then it may already have a class
            // driver list.  Destroy that list before inheriting from the global class
            // driver list.
            //
            if(AlreadyPresent) {
                //
                // If the selected driver is a class driver, then reset the selection.
                //
                if(DevInfoElem->SelectedDriverType == SPDIT_CLASSDRIVER) {
                    DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                    DevInfoElem->SelectedDriver = NULL;
                }

                //
                // Destroy the existing class driver list for this device.
                //
                DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                DevInfoElem->ClassDriverCount = 0;
                DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                DevInfoElem->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
            }

            if(pDeviceInfoSet->ClassDriverHead) {
                //
                // Find the global class driver list in the devinfo set's list of driver lists.
                //
                CurDrvListObject = GetAssociatedDriverListObject(pDeviceInfoSet->ClassDrvListObjectList,
                                                                 pDeviceInfoSet->ClassDriverHead,
                                                                 NULL
                                                                );
                MYASSERT(CurDrvListObject && (CurDrvListObject->RefCount > 0));

                //
                // We found the driver list object, now increment its refcount, and do the
                // inheritance.
                //
                CurDrvListObject->RefCount++;

                DevInfoElem->ClassDriverCount = pDeviceInfoSet->ClassDriverCount;
                DevInfoElem->ClassDriverHead  = pDeviceInfoSet->ClassDriverHead;
                DevInfoElem->ClassDriverTail  = pDeviceInfoSet->ClassDriverTail;

                if(pDeviceInfoSet->SelectedClassDriver) {
                    DevInfoElem->SelectedDriver = pDeviceInfoSet->SelectedClassDriver;
                    DevInfoElem->SelectedDriverType = SPDIT_CLASSDRIVER;
                }

                DevInfoElem->InstallParamBlock.Flags   |= CurDrvListObject->ListCreationFlags;
                DevInfoElem->InstallParamBlock.FlagsEx |= CurDrvListObject->ListCreationFlagsEx;
                DevInfoElem->InstallParamBlock.DriverPath = CurDrvListObject->ListCreationDriverPath;
            }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if((Err == NO_ERROR) && DeviceInfoData) {
        //
        // The user supplied a buffer to receive a SP_DEVINFO_DATA
        // structure, so fill that in now.
        //
        try {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  DevInfoElem,
                                                  DeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
HDEVINFO
WINAPI
SetupDiGetClassDevsA(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCSTR       Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    PCWSTR enumerator;
    DWORD rc;
    HDEVINFO h;

    if(Enumerator) {
        rc = pSetupCaptureAndConvertAnsiArg(Enumerator,&enumerator);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return INVALID_HANDLE_VALUE;
        }
    } else {
        enumerator = NULL;
    }

    h = SetupDiGetClassDevsExW(ClassGuid,
                               enumerator,
                               hwndParent,
                               Flags,
                               NULL,
                               NULL,
                               NULL
                              );
    rc = GetLastError();

    if(enumerator) {
        MyFree(enumerator);
    }

    SetLastError(rc);
    return h;
}
#else
//
// Unicode version
//
HDEVINFO
WINAPI
SetupDiGetClassDevsW(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCWSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(Enumerator);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif

HDEVINFO
WINAPI
SetupDiGetClassDevs(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCTSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
/*++

Routine Description:

    See SetupDiGetClassDevsEx for details.

--*/
{
    return SetupDiGetClassDevsEx(ClassGuid,
                                 Enumerator,
                                 hwndParent,
                                 Flags,
                                 NULL,
                                 NULL,
                                 NULL
                                );
}


#ifdef UNICODE
//
// ANSI version
//
HDEVINFO
WINAPI
SetupDiGetClassDevsExA(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCSTR       Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCSTR       MachineName,   OPTIONAL
    IN PVOID       Reserved
    )
{
    PCWSTR UnicodeEnumerator, UnicodeMachineName;
    DWORD rc;
    HDEVINFO h;

    h = INVALID_HANDLE_VALUE;

    if(Enumerator) {
        rc = pSetupCaptureAndConvertAnsiArg(Enumerator, &UnicodeEnumerator);
        if(rc != NO_ERROR) {
            goto clean0;
        }
    } else {
        UnicodeEnumerator = NULL;
    }

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName,&UnicodeMachineName);
        if(rc != NO_ERROR) {
            goto clean1;
        }
    } else {
        UnicodeMachineName = NULL;
    }

    h = SetupDiGetClassDevsExW(ClassGuid,
                               UnicodeEnumerator,
                               hwndParent,
                               Flags,
                               DeviceInfoSet,
                               UnicodeMachineName,
                               Reserved
                              );
    rc = GetLastError();

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

clean1:
    if(UnicodeEnumerator) {
        MyFree(UnicodeEnumerator);
    }

clean0:
    SetLastError(rc);
    return h;
}
#else
//
// Unicode version
//
HDEVINFO
WINAPI
SetupDiGetClassDevsExW(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCWSTR      Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCWSTR      MachineName,   OPTIONAL
    IN PVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(ClassGuid);
    UNREFERENCED_PARAMETER(Enumerator);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Reserved);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif

HDEVINFO
WINAPI
SetupDiGetClassDevsEx(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCTSTR      Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCTSTR      MachineName,   OPTIONAL
    IN PVOID       Reserved
    )
/*++

Routine Description:

    This routine returns a device information set containing all installed
    devices of the specified class.

Arguments:

    ClassGuid - Optionally, supplies the address of the class GUID to use
        when creating the list of devices.  If the DIGCF_ALLCLASSES flag is
        set, then this parameter is ignored, and the resulting list will
        contain all classes of devices (i.e., every installed device).

        If the DIGCF_DEVICEINTERFACE flag _is not_ set, then this class GUID
        represents a setup class.

        If the DIGCF_DEVICEINTERFACE flag _is_ set, then this class GUID
        represents an interface class.

    Enumerator - Optional parameter that filters the members of the returned
        device information set based on their enumerator (i.e., provider).

        If the DIGCF_DEVICEINTERFACE flag _is not_ set in the Flags parameter,
        then this string represents the name of the key under the Enum branch
        containing devices instances for which information is to be retrieved.
        If this parameter is not specified, then device information will be
        retrieved for all device instances in the entire Enum tree.

        If the DIGCF_DEVICEINTERFACE flag _is_ set, then this string represents
        the PnP name of a particular device for which interfaces are to be
        retrieved.  In this case, the resulting device information set will
        consist of a single device information element--the device whose name
        was specified as the enumerator.  The interface devices provided by this
        PnP device can then be enumerated via SetupDiEnumInterfaceDevice.

    hwndParent - Optionally, supplies the handle of the top-level window to be
        used for any UI relating to the members of this set.

    Flags - Supplies control options used in building the device information set.
        May be a combination of the following values:

        DIGCF_PRESENT         - Return only devices that are currently present.
        DIGCF_ALLCLASSES      - Return a list of installed devices for all classes.
                                If set, this flag will cause ClassGuid to be ignored.
        DIGCF_PROFILE         - Return only devices that are a part of the current
                                hardware profile.
        DIGCF_DEVICEINTERFACE - Return a list of all devices that expose interfaces
                                of the class specified by ClassGUID (NOTE: in this
                                context, ClassGuid is an interface class, _not_ a
                                setup class).  The interface devices exposed by the
                                members of the resulting set may be enumerated via
                                SetupDiEnumInterfaceDevice.
        DIGCF_DEFAULT         - When used with DIGCF_DEVICEINTERFACE, this flag
                                results in a list that contains only one device
                                information element.  Enumerating that device will
                                return exactly one interface device--the one that has
                                been marked as the system default interface device for
                                that particular interface class.  If there is no default
                                interface device for the specified class, the API will
                                fail, and GetLastError will return
                                ERROR_NO_DEFAULT_DEVICE_INTERFACE.

    DeviceInfoSet - Optionally, supplies the handle of an existing device
        information set into which these new device information elements (and,
        if DIGCF_DEVICEINTERFACE is specified, device interfaces) will be added.
        If this parameter is specified, then this same HDEVINFO will be returned
        upon success, with the retrieved device information/device interface
        elements added.  If this parameter is not specified, then a new device
        information set will be created, and its handle returned.

        NOTE: if this parameter is specified, then the associated class of this
        device information set (if any) must match the ClassGuid specified, if
        that class GUID is a setup class (i.e., the DIGCF_DEVICEINTERFACE flag
        isn't set).  If the DIGCF_DEVICEINTERFACE flag is set, then the device
        interfaces retrieved will be filtered based on whether or not their
        corresponding device's setup class matches that of the device
        information set.  This trick can be used, for example, to retrieve a
        list of device interfaces of a particular interface class, but only if
        those interfaces are exposed by devices of a particular setup class.
        E.g.,

            1.  Create a device information set (via SetupDiCreateDeviceInfoList)
                whose associated setup class is "Volume".
            2.  Call SetupDiGetClassDevsEx to retrieve a list of all device
                interfaces of interface class "mounted device", passing in the
                HDEVINFO retrieved in step 1.

        The result of the above steps would be a device information set
        containing all device interfaces of (interface) class "mounted device"
        that are exposed by devnodes of (setup) class "Volume".

        Note that retrieval of new device information elements into an existing
        HDEVINFO set doesn't invalidate our devinfo enumeration hint, since new
        devinfo elements are always added onto the end of the list.

    MachineName - Optionally, supplies the name of a remote machine for which a
        device information set is to be retrieved.  If this parameter is NULL,
        then the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is a handle to a device
    information set containing all installed devices matching the specified
    parameters.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

--*/
{
    HDEVINFO hDevInfo;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD Err;
    CONFIGRET cr;
    PTCHAR DevIdBuffer;
    ULONG DevIdBufferLen, CSConfigFlags;
    PTSTR CurDevId, DeviceInstanceToOpen;
    HKEY hKeyDevClassRoot, hKeyCurDevClass;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    BOOL GetInterfaceList, GetNextInterfaceClass;
    DWORD InterfaceClassKeyIndex;
    FILETIME LastWriteTime;
    GUID GuidBuffer;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    DWORD RegDataType, DataBufferSize;
    BOOL DevInfoAlreadyPresent, IsActive, IsDefault;
    SP_DEVINFO_DATA DeviceInfoData;
    CONST GUID * ExistingClassGuid;

    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Unless the caller wants a list of all classes, they'd better supply a class GUID.
    //
    if(!(Flags & DIGCF_ALLCLASSES) && !ClassGuid) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // DIGCF_DEFAULT can only be used in conjunction with DIGCF_DEVICEINTERFACE.
    //
    if((Flags & (DIGCF_DEFAULT | DIGCF_DEVICEINTERFACE)) == DIGCF_DEFAULT) {
        SetLastError(ERROR_INVALID_FLAGS);
        return INVALID_HANDLE_VALUE;
    }

    if(!DeviceInfoSet || (DeviceInfoSet == INVALID_HANDLE_VALUE)) {
        //
        // The caller didn't supply us with a device information set in which
        // to add our newly-retrieved elements, so we need to create our own.
        //
        if((hDevInfo = SetupDiCreateDeviceInfoListEx((Flags & (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE))
                                                          ? NULL
                                                          : ClassGuid,
                                                     hwndParent,
                                                     MachineName,
                                                     NULL)) == INVALID_HANDLE_VALUE) {
            //
            // Last error already set.
            //
            MYASSERT(GetLastError());
            return INVALID_HANDLE_VALUE;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(hDevInfo))) {
            //
            // this should not happen
            //
            MYASSERT(pDeviceInfoSet);
            SetLastError(ERROR_INVALID_HANDLE);
            return INVALID_HANDLE_VALUE;
        }

    } else {
        //
        // The caller wants us to use an existing device information set.  Make
        // a copy of it, and work with that one, so that if something fails, we
        // haven't messed up the original one.
        //
        // NOTE:  DO NOT do anything with the DeviceInfoSet after this point,
        // as doing so will get the original out-of-sync with the current copy
        // we're working with.
        //
        hDevInfo = NULL;
        pDeviceInfoSet = CloneDeviceInfoSet(DeviceInfoSet);
        if(!pDeviceInfoSet) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
    }

    Err = NO_ERROR;
    DevIdBuffer = NULL;
    hKeyDevClassRoot = hKeyCurDevClass = INVALID_HANDLE_VALUE;

    try {
        //
        // If the caller supplied us with a previously-existing devinfo set in
        // which to add new elements, we need to make sure that the setup class
        // GUID associated with this devinfo set (if any) matches the setup
        // class GUID that the caller supplied.
        //
        if(hDevInfo) {
            //
            // We always want the ExistingClassGuid pointer to be NULL when we
            // haven't been passed in a previously-existing device information
            // set.
            //
            ExistingClassGuid = NULL;

        } else {

            if(pDeviceInfoSet->HasClassGuid) {
                //
                // Remember the devinfo set's associated setup class GUID, to
                // be used later in filtering device interfaces based on the
                // setup class of their underlying devnode.
                //
                ExistingClassGuid = &(pDeviceInfoSet->ClassGuid);

                if(ClassGuid && !(Flags & (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE))) {

                    if(!IsEqualGUID(ExistingClassGuid, ClassGuid)) {
                        Err = ERROR_CLASS_MISMATCH;
                        goto clean0;
                    }
                }

            } else {
                //
                // The caller-supplied devinfo set had no associated setup
                // class.  Remember that fact, so that we won't try to filter
                // device interfaces based on the underlying devices' setup
                // class.
                //
                ExistingClassGuid = NULL;
            }
        }

        if(GetInterfaceList = (Flags & DIGCF_DEVICEINTERFACE)) {  // yes, we want an assignment here.
            //
            // Open the root of the DeviceClasses registry branch
            //
            hKeyDevClassRoot = SetupDiOpenClassRegKeyEx(NULL,
                                                        KEY_READ,
                                                        DIOCR_INTERFACE,
                                                        MachineName,
                                                        NULL
                                                       );

            if(hKeyDevClassRoot == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            if(Flags & DIGCF_ALLCLASSES) {
                InterfaceClassKeyIndex = 0;
                ClassGuid = &GuidBuffer;
            }

            if(Flags & DIGCF_PRESENT) {
                //
                // Since we're only going to be retrieving a list of device
                // interfaces that are currently 'active', we can set the
                // 'IsActive' flag to always be TRUE.
                //
                IsActive = TRUE;
            }
        }

        //
        // As an optimization, start out with a 16K (character) buffer, in the hopes of avoiding
        // two scans through the hardware tree (once to get the size, and again to get the data).
        //
        DevIdBufferLen = 16384;

        do {

            if(GetInterfaceList) {

                if(Flags & DIGCF_ALLCLASSES) {
                    //
                    // We have to enumerate through all interface device classes, and retrieve
                    // a list of device interfaces for each one.
                    //
                    DataBufferSize = SIZECHARS(InterfaceGuidString);

                    switch(RegEnumKeyEx(hKeyDevClassRoot,
                                        InterfaceClassKeyIndex,
                                        InterfaceGuidString,
                                        &DataBufferSize,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &LastWriteTime)) {

                        case ERROR_SUCCESS :
                            GetNextInterfaceClass = TRUE;
                            InterfaceClassKeyIndex++;
                            break;

                        case ERROR_NO_MORE_ITEMS :
                            //
                            // We've processed all of the interface class GUIDs--we're done.
                            //
                            GetNextInterfaceClass = FALSE;
                            continue;

                        default :
                            //
                            // Some other error occurred.  Skip this subkey, and continue
                            // with the next one.
                            //
                            GetNextInterfaceClass = TRUE;
                            InterfaceClassKeyIndex++;
                            continue;
                    }

                    //
                    // Convert the GUID string retrieved above into its binary form, for use
                    // below.
                    //
                    if(pSetupGuidFromString(InterfaceGuidString, &GuidBuffer) != NO_ERROR) {
                        //
                        // The subkey we enumerated is not a valid GUID string--skip this
                        // subkey, and continue on with the next one.
                        //
                        continue;
                    }

                } else {
                    //
                    // We're just retrieving devices for a single interface class (which the
                    // caller specified).  All we need to do is initialize the GUID string
                    // buffer with the textual form of the GUID.
                    //
                    pSetupStringFromGuid(ClassGuid,
                                         InterfaceGuidString,
                                         SIZECHARS(InterfaceGuidString)
                                        );
                    //
                    // We only need to go through this list once.
                    //
                    GetNextInterfaceClass = FALSE;
                }

                //
                // We'll be using the same character buffer to store each device instance ID
                // we're opening below.
                //
                DeviceInstanceToOpen = DeviceInstanceId;

            } else {
                //
                // We're not retrieving a list of interface devices, so we'll never go through
                // this loop more than once.
                //
                GetNextInterfaceClass = FALSE;
            }

            //
            // Retrieve a list of device names.
            //
            while(TRUE) {

                if(!DevIdBuffer) {

                    if(!(DevIdBuffer = MyMalloc(DevIdBufferLen * sizeof(TCHAR)))) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }

                if(GetInterfaceList) {
                    cr = CM_Get_Device_Interface_List_Ex((LPGUID)ClassGuid,
                                                         (DEVINSTID)Enumerator,
                                                         DevIdBuffer,
                                                         DevIdBufferLen,
                                                         (Flags & DIGCF_PRESENT)
                                                             ? CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                                                             : CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES,
                                                         pDeviceInfoSet->hMachine
                                                        );
                } else {
                    cr = CM_Get_Device_ID_List_Ex(Enumerator,
                                                  DevIdBuffer,
                                                  DevIdBufferLen,
                                                  Enumerator ? CM_GETIDLIST_FILTER_ENUMERATOR
                                                             : CM_GETIDLIST_FILTER_NONE,
                                                  pDeviceInfoSet->hMachine
                                                 );
                }

                if(cr == CR_SUCCESS) {
                    //
                    // Device list successfully retrieved!
                    //
                    break;

                } else {
                    //
                    // Free the current buffer before determining what error occurred.
                    //
                    MyFree(DevIdBuffer);
                    DevIdBuffer = NULL;

                    if(cr == CR_BUFFER_SMALL) {
                        //
                        // OK, so our buffer wasn't big enough--just how big
                        // does it need to be?
                        //
                        if(GetInterfaceList) {

                            if(CM_Get_Device_Interface_List_Size_Ex(&DevIdBufferLen,
                                                                    (LPGUID)ClassGuid,
                                                                    (DEVINSTID)Enumerator,
                                                                    (Flags & DIGCF_PRESENT)
                                                                        ? CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                                                                        : CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES,
                                                                    pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                                //
                                // Couldn't retrieve the list size--this should
                                // never happen.
                                //
                                Err = ERROR_INVALID_DATA;
                                goto clean0;
                            }

                        } else {

                            if(CM_Get_Device_ID_List_Size_Ex(&DevIdBufferLen,
                                                          Enumerator,
                                                          Enumerator ? CM_GETIDLIST_FILTER_ENUMERATOR
                                                                     : CM_GETIDLIST_FILTER_NONE,
                                                          pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                                //
                                // Couldn't retrieve the list size--this should
                                // never happen.
                                //
                                Err = ERROR_INVALID_DATA;
                                goto clean0;
                            }
                        }

                    } else {
                        //
                        // An error occurred, and it wasn't because we supplied
                        // too small a buffer.
                        //
                        Err = ERROR_INVALID_DATA;
                        goto clean0;
                    }
                }
            }

            //
            // We have now retrieved a list of all the specified devices.  If
            // these are device interfaces, we need to open the key for this
            // interface class underneath the DeviceClasses key.
            //
            if(GetInterfaceList) {

                if(RegOpenKeyEx(hKeyDevClassRoot,
                                InterfaceGuidString,
                                0,
                                KEY_READ,
                                &hKeyCurDevClass) != ERROR_SUCCESS) {
                    //
                    // Make sure hKeyCurDevClass is still set to
                    // INVALID_HANDLE_VALUE, so that we'll know not to close it.
                    //
                    hKeyCurDevClass = INVALID_HANDLE_VALUE;

                    //
                    // Skip this interface class.
                    //
                    continue;
                }
            }

            //
            // Now create device information elements from the members of this
            // list.
            //
            for(CurDevId = DevIdBuffer;
                *CurDevId;
                CurDevId += lstrlen(CurDevId) + 1) {

                //
                // If this is a device interface, we must retrieve the
                // associated device instance name.
                //
                if(GetInterfaceList) {

                    if(NO_ERROR != pSetupGetDevInstNameAndStatusForInterfaceDevice(
                                       hKeyCurDevClass,
                                       CurDevId,
                                       DeviceInstanceId,
                                       SIZECHARS(DeviceInstanceId),
                                       (Flags & DIGCF_PRESENT) ? NULL : &IsActive,
                                       &IsDefault)) {
                        //
                        // Couldn't retrieve the name of the owning device
                        // instance--skip this device interface.
                        //
                        continue;
                    }

                    if ((Flags & DIGCF_DEFAULT) && !IsDefault) {
                        //
                        // The caller only wants the default device interface.
                        // Since CM_Get_Device_Interface_List places the default
                        // device interface first in the list (if there is one),
                        // and we stop searching the list when we find it, we
                        // know that if we get here, there is no default device
                        // interface for this interface class.
                        //
                        Err = ERROR_NO_DEFAULT_DEVICE_INTERFACE;
                        goto clean0;
                    }

                } else {
                    DeviceInstanceToOpen = CurDevId;
                }

                if(Flags & DIGCF_PROFILE) {
                    //
                    // Verify that this device instance is part of the current
                    // hardware profile.
                    //
                    if(CM_Get_HW_Prof_Flags_Ex(DeviceInstanceToOpen,
                                               0,
                                               &CSConfigFlags,
                                               0,
                                               pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                        if(CSConfigFlags & CSCONFIGFLAG_DO_NOT_CREATE) {
                            continue;
                        }
                    }
                }

                //
                // Note the last parameter in the following call to
                // pSetupOpenAndAddNewDevInfoElem--in the case where we're
                // adding to an existing caller-supplied HDEVINFO set (i.e.,
                // hDevInfo is NULL), we cast the HDEVINFO to a DEVICE_INFO_SET
                // pointer, since that's what ends up getting stored in the
                // ContainingDeviceInfoSet field of a devinfo element structure.
                // That field is used for quick validation that a caller-
                // supplied device information element is valid.
                //
                // If we ever decide to change the internal implementation of
                // how an HDEVINFO translates into its underlying
                // DEVICE_INFO_SET, then we'll need to update the code below
                // accordingly.  (See also the comments under
                // AccessDeviceInfoSet, CloneDeviceInfoSet, and
                // RollbackDeviceInfoSet.)
                //
                Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                                     DeviceInstanceToOpen,
                                                     !(Flags & DIGCF_PRESENT),
                                                     ((Flags & (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE))
                                                        ? ExistingClassGuid
                                                        : ClassGuid),
                                                     hwndParent,
                                                     &DevInfoElem,
                                                     (GetInterfaceList || !hDevInfo),
                                                     &DevInfoAlreadyPresent,
                                                     FALSE,
                                                     0,
                                                     (hDevInfo ? pDeviceInfoSet : (PDEVICE_INFO_SET)DeviceInfoSet)
                                                    );

                if(Err != NO_ERROR) {

                    if(Err == ERROR_NOT_ENOUGH_MEMORY) {
                        goto clean0;
                    }

                    Err = NO_ERROR;
                    continue;
                }

                if(GetInterfaceList) {
                    //
                    // Now that we've successfully opened up the device instance that 'owns'
                    // this device interface, add a new interface device node onto this
                    // devinfo element's list.
                    //
                    if(NO_ERROR != (Err = pSetupAddInterfaceDeviceToDevInfoElem(pDeviceInfoSet,
                                                                                DevInfoElem,
                                                                                ClassGuid,
                                                                                CurDevId,
                                                                                IsActive,
                                                                                IsDefault,
                                                                                !hDevInfo,
                                                                                FALSE,
                                                                                NULL))) {
                        //
                        // The only error we should be getting back from this routine is
                        // out-of-memory, which is always a fatal error.
                        //
                        goto clean0;
                    }

                    if ((Flags & DIGCF_DEFAULT) && IsDefault) {
                        //
                        // The caller only wants the default device interface,
                        // and this is it.
                        //
                        if ((Flags & DIGCF_PRESENT) && !IsActive) {
                            //
                            // The caller doesn't want to know about a
                            // non-present default device interface.
                            //
                            Err = ERROR_NO_DEFAULT_DEVICE_INTERFACE;
                        }
                        RegCloseKey(hKeyCurDevClass);
                        hKeyCurDevClass = INVALID_HANDLE_VALUE;
                        goto clean0;
                    }
                }
            }

            //
            // If we're working with interface devices, we need to close the interface
            // class key we opened above.
            //
            if(GetInterfaceList) {
                RegCloseKey(hKeyCurDevClass);
                hKeyCurDevClass = INVALID_HANDLE_VALUE;
            }

        } while(GetNextInterfaceClass);

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hKeyCurDevClass != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyCurDevClass);
        }

        //
        // Access the following variables, so the compiler will respect
        // the statement ordering in the try clause.
        //
        DevIdBuffer = DevIdBuffer;
        hKeyDevClassRoot = hKeyDevClassRoot;
    }

    if(DevIdBuffer) {
        MyFree(DevIdBuffer);
    }

    if(hKeyDevClassRoot != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyDevClassRoot);
    }

    if(Err != NO_ERROR) {
        if(hDevInfo) {
            DestroyDeviceInfoSet(hDevInfo, pDeviceInfoSet);
        } else {
            if(!(pDeviceInfoSet = RollbackDeviceInfoSet(DeviceInfoSet, pDeviceInfoSet))) {
                MYASSERT(pDeviceInfoSet);
            } else {
                UnlockDeviceInfoSet(pDeviceInfoSet);
            }
        }
        SetLastError(Err);
        hDevInfo = INVALID_HANDLE_VALUE;
    } else {
        if(!hDevInfo) {
            //
            // We retrieved additional elements into an existing device
            // information set.  Replace the existing device information set
            // with the new one (i.e., into the same handle), and return the
            // same HDEVINFO handle that the caller passed in as the
            // DeviceInfoSet parameter.
            //
            pDeviceInfoSet = CommitDeviceInfoSet(DeviceInfoSet, pDeviceInfoSet);
            MYASSERT(pDeviceInfoSet);

            //
            // Set hDevInfo to be the same as the DeviceInfoSet handle we were
            // passed in, so that we can return it to the caller.
            //
            hDevInfo = DeviceInfoSet;
            MYASSERT(hDevInfo);
        }
        if (pDeviceInfoSet) {
            UnlockDeviceInfoSet(pDeviceInfoSet);
        }
        MYASSERT(hDevInfo != INVALID_HANDLE_VALUE);
    }

    return hDevInfo;
}


BOOL
WINAPI
SetupDiSetDeviceInterfaceDefault(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD Flags,
    IN PVOID Reserved
    )
/*++

Routine Description:

    This routine sets the specified device interface as the default device
    interface for its class.

Arguments:

    DeviceInfoSet - Points to the device information set containing the device
        interface for which to set as the default device interface. This handle
        is typically returned by SetupDiGetClassDevs.

    DeviceInterfaceData - Points to a structure that identifies the device
        interface within the device information set. This pointer is typically
        returned by SetupDiEnumDeviceInterfaces.  If successful, this routine
        will update the information contained in this structure.

    Flags - Not used, must be zero.

    Reserved - Reserved for future use, must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The caller must have the appropriate permission to set the default device
    interface.

--*/
{
    DWORD Err;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    PCTSTR MachineName, InterfaceDeviceName;
    HKEY hKeyInterfaceClass = INVALID_HANDLE_VALUE;
    BOOL IsActive, IsDefault;


    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(Flags & ~(0x0)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // First, find the devinfo element that owns this interface device (for validation).
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }


        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                   pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // The Reserved field contains a pointer to the underlying interface device node.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(DeviceInterfaceData->Reserved);

        //
        // Retrieve the device path (symbolic link name) for this interface device.
        //
        InterfaceDeviceName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                       InterfaceDeviceNode->SymLinkName);

        //
        // Open this interface class key under the DeviceClasses registry branch.
        //
        hKeyInterfaceClass = SetupDiOpenClassRegKeyEx(&DeviceInterfaceData->InterfaceClassGuid,
                                                      KEY_READ | KEY_WRITE,
                                                      DIOCR_INTERFACE,
                                                      MachineName,
                                                      NULL);
        if(hKeyInterfaceClass == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Get the current status of this device interface.
        //
        Err = pSetupGetDevInstNameAndStatusForInterfaceDevice(hKeyInterfaceClass,
                                                              InterfaceDeviceName,
                                                              NULL,
                                                              0,
                                                              &IsActive,
                                                              &IsDefault);
        if (Err != NO_ERROR) {
            goto clean0;
        }

        //
        // If this interface is already the default, then we're done.
        //
        if (IsDefault) {
            goto clean1;
        }

        //
        // Set the "Default" value under this interface class key to this device
        // interface.
        //
        Err = RegSetValueEx(hKeyInterfaceClass,
                            pszDefault,
                            0,
                            REG_SZ,
                            (PBYTE)InterfaceDeviceName,
                            (lstrlen(InterfaceDeviceName) + 1) * sizeof(TCHAR));
        if (Err != NO_ERROR) {
            goto clean0;
        }

        //
        // This interface was successfully set as the default device interface
        // for this interface class.
        //
        IsDefault = TRUE;

    clean1:
        //
        // Update the flags for this interface.
        //
        InterfaceDeviceNode->Flags = (InterfaceDeviceNode->Flags & ~SPINT_ACTIVE)  | (IsActive  ? SPINT_ACTIVE  : 0);
        InterfaceDeviceNode->Flags = (InterfaceDeviceNode->Flags & ~SPINT_DEFAULT) | (IsDefault ? SPINT_DEFAULT : 0);

        //
        // Finally, update the flags in the caller-supplied buffer to indicate the new status
        // of this interface device.
        //
        DeviceInterfaceData->Flags = InterfaceDeviceNode->Flags;

    clean0:

        if(hKeyInterfaceClass != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyInterfaceClass);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupAddNewDeviceInfoElement(
    IN  PDEVICE_INFO_SET pDeviceInfoSet,
    IN  DEVINST          DevInst,
    IN  CONST GUID      *ClassGuid,
    IN  PCTSTR           Description,             OPTIONAL
    IN  HWND             hwndParent,              OPTIONAL
    IN  DWORD            DiElemFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet,
    OUT PDEVINFO_ELEM   *DeviceInfoElement
    )
/*++

Routine Description:

    This routine creates a new device information element based on the
    supplied information, and adds it to the specified device information set.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    pDeviceInfoSet - Device information set to add this new element to.

    DevInst - Supplies the device instance handle of the element to be added.

    ClassGuid - Class GUID of the element to be added.

    Description - Optionally, supplies the description of the element to
        be added.

    hwndParent - Optionally, supplies the handle to the top level window for
        UI relating to this element.

    DiElemFlags - Specifies flags pertaining to the device information element
        being created.

    ContainingDeviceInfoSet - Supplies a pointer to the device information set
        structure with which this element is to be associated.  This may be
        different from the pDeviceInfoSet parameter if we're working against a
        cloned devinfo set (i.e., to facilitate rollback).

    DeviceInfoElement - Supplies the address of the variable that receives a
        pointer to the newly-allocated device information element.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise the
    ERROR_* code is returned.

Remarks:

    Since the new element is added onto the end of the existing list, our
    enumeration hint isn't invalidated.

--*/
{
    DWORD Err = NO_ERROR;
    TCHAR TempString[LINE_LEN];

    *DeviceInfoElement = NULL;


    try {
        //
        // If there is a class associated with this device information set,
        // verify that it is the same as that of the new element.
        //
        if(pDeviceInfoSet->HasClassGuid &&
           !IsEqualGUID(&(pDeviceInfoSet->ClassGuid), ClassGuid)) {

            Err = ERROR_CLASS_MISMATCH;
            goto clean0;

        }

        //
        // Allocate storage for the element.
        //
        if(!(*DeviceInfoElement = MyMalloc(sizeof(DEVINFO_ELEM)))) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        ZeroMemory(*DeviceInfoElement, sizeof(DEVINFO_ELEM));

        //
        // Store the address of the containing devinfo set in the structure
        // for this element.  This is used for efficient validation of a
        // caller-supplied SP_DEVINFO_DATA.
        //
        (*DeviceInfoElement)->ContainingDeviceInfoSet = ContainingDeviceInfoSet;

        //
        // Initialize the element with the specified information
        //
        CopyMemory(&((*DeviceInfoElement)->ClassGuid),
                   ClassGuid,
                   sizeof(GUID)
                  );
        (*DeviceInfoElement)->InstallParamBlock.hwndParent = hwndParent;

        if(Description) {
            //
            // Set the device instance's DeviceDesc property to the specified
            // description.
            //
            CM_Set_DevInst_Registry_Property_Ex(DevInst,
                                             CM_DRP_DEVICEDESC,
                                             Description,
                                             (lstrlen(Description) + 1) * sizeof(TCHAR),
                                             0,
                                             pDeviceInfoSet->hMachine);

            //
            // Store two versions of the description--one case-sensitive (for display)
            // and the other case-insensitive (for fast lookup).
            //
            lstrcpyn(TempString, Description, SIZECHARS(TempString));

            if((((*DeviceInfoElement)->DeviceDescriptionDisplayName =
                      pStringTableAddString(pDeviceInfoSet->StringTable,
                                            TempString,
                                            STRTAB_CASE_SENSITIVE,
                                            NULL,0)) == -1) ||
               (((*DeviceInfoElement)->DeviceDescription =
                      pStringTableAddString(pDeviceInfoSet->StringTable,
                                            TempString,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0)) == -1)) {

                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

        } else {
            (*DeviceInfoElement)->DeviceDescription =
                (*DeviceInfoElement)->DeviceDescriptionDisplayName = -1;
        }

        (*DeviceInfoElement)->DevInst = DevInst;
        (*DeviceInfoElement)->DiElemFlags = DiElemFlags;
        (*DeviceInfoElement)->InstallParamBlock.DriverPath = -1;
        (*DeviceInfoElement)->InstallParamBlock.CoInstallerCount = -1;

        //
        // If we're in GUI-mode setup on Windows NT, we'll automatically set
        // the DI_FLAGSEX_IN_SYSTEM_SETUP flag in the devinstall parameter
        // block for this devinfo element.
        //
        if(GuiSetupInProgress) {
            (*DeviceInfoElement)->InstallParamBlock.FlagsEx |= DI_FLAGSEX_IN_SYSTEM_SETUP;
        }

        //
        // If we're in non-interactive mode, set the "be quiet" bits.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            (*DeviceInfoElement)->InstallParamBlock.Flags   |= DI_QUIETINSTALL;
            (*DeviceInfoElement)->InstallParamBlock.FlagsEx |= DI_FLAGSEX_NOUIONQUERYREMOVE;
        }

        //
        // Initialize our enumeration 'hints'
        //
        (*DeviceInfoElement)->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
        (*DeviceInfoElement)->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

        //
        // Create a log context separate from the parent.
        //
        if(CreateLogContext(NULL, FALSE, &(*DeviceInfoElement)->InstallParamBlock.LogContext) != NO_ERROR) {
            //
            // if it failed, we will inheret the log context, since it's better than nothing
            // in theory, this should never happen, or if it does, other things will fail too
            //
            (*DeviceInfoElement)->InstallParamBlock.LogContext = NULL;

            Err = InheritLogContext(pDeviceInfoSet->InstallParamBlock.LogContext, &(*DeviceInfoElement)->InstallParamBlock.LogContext);
            if (Err != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // Now, insert the new element at the end of the device
        // information set's list of elements.
        //
        if(pDeviceInfoSet->DeviceInfoHead) {
            pDeviceInfoSet->DeviceInfoTail->Next = *DeviceInfoElement;
            pDeviceInfoSet->DeviceInfoTail = *DeviceInfoElement;
        } else {
            pDeviceInfoSet->DeviceInfoHead =
            pDeviceInfoSet->DeviceInfoTail = *DeviceInfoElement;
        }
        pDeviceInfoSet->DeviceInfoCount++;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if((Err != NO_ERROR) && *DeviceInfoElement) {

        MyFree(*DeviceInfoElement);
        *DeviceInfoElement = NULL;
    }

    return Err;
}


DWORD
pSetupClassGuidFromDevInst(
    IN  DEVINST DevInst,
    IN  HMACHINE hMachine,
    OUT LPGUID  ClassGuid
    )
/*++

Routine Description:

    This routine attempts to retrieve the class GUID for the specified device
    instance from its device registry key.  If it cannot retrieve one, it
    returns GUID_NULL.

Arguments:

    DevInst - Supplies the handle of the device instance whose class GUID is
        to be retrieved.

        hMachine - Machine context to operate in

    ClassGuid - Supplies the address of the variable that receives the class
        GUID, or GUID_NULL if no class GUID can be retrieved.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.  (Presently, the only
    failure condition returned is ERROR_NOT_ENOUGH_MEMORY.)

--*/
{
    DWORD NumGuids;
    TCHAR TempString[GUID_STRING_LEN];
    DWORD StringSize;

    StringSize = sizeof(TempString);
    if(CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                        CM_DRP_CLASSGUID,
                                        NULL,
                                        TempString,
                                        &StringSize,
                                        0,
                                        hMachine) == CR_SUCCESS) {
        //
        // We retrieved the class GUID (in string form) for this device
        // instance--now, convert it into its binary representation.
        //
        return pSetupGuidFromString(TempString, ClassGuid);
    }

    //
    // We couldn't retrieve a ClassGUID--let's see if there's a Class name we can
    // work with.
    //
    StringSize = sizeof(TempString);
    if(CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                        CM_DRP_CLASS,
                                        NULL,
                                        TempString,
                                        &StringSize,
                                        0,
                                        hMachine) == CR_SUCCESS) {
        //
        // OK, we found out the class name.  Now see if we can find a
        // single class GUID to match it.
        //
        if(SetupDiClassGuidsFromName(TempString, ClassGuid, 1, &NumGuids) && NumGuids) {
            //
            // We found exactly one, so we're happy.
            //
            return NO_ERROR;
        }
    }

    //
    // We have no idea what class of device this is, so use GUID_NULL.
    //
    CopyMemory(ClassGuid, &GUID_NULL, sizeof(GUID));

    return NO_ERROR;
}


BOOL
WINAPI
SetupDiDeleteDeviceInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine deletes a member from the specified device information set.
    THIS DOES NOT DELETE ACTUAL DEVICES!

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element to be deleted.

    DeviceInfoData - Supplies a pointer to the SP_DEVINFO_DATA structure for
        the device information element to be deleted.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the specified device information element is explicitly in use by a wizard
    page, then the call will fail, and GetLastError will return
    ERROR_DEVINFO_DATA_LOCKED.  This will happen if a handle to a wizard page was
    retrieved via SetupDiGetWizardPage, and this element was specified, along with
    the DIWP_FLAG_USE_DEVINFO_DATA flag.  In order to be able to delete this element,
    the wizard HPROPSHEETPAGE handle must be closed (either explicitly, or after a
    call to PropertySheet() completes).

    Since we don't track where this devinfo element lives in relation to our
    current enumeration hint, we just invalidate the hint, so that next
    enumeration must scan from the beginning of the list.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM ElemToDelete, PrevElem, NextElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element we are to delete.
        //
        ElemToDelete = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                 DeviceInfoData,
                                                 &PrevElem
                                                );
        if(ElemToDelete) {
            //
            // Make sure that this element isn't currently locked by
            // a wizard page.
            //
            if(ElemToDelete->DiElemFlags & DIE_IS_LOCKED) {
                Err = ERROR_DEVINFO_DATA_LOCKED;
                goto clean0;
            }

            NextElem = ElemToDelete->Next;

            //
            // Destroy the devinfo element.  We need to do this before
            // altering the list, because we will be calling the class
            // installer with DIF_DESTROYPRIVATEDATA, and it needs to
            // be able to access this element (obviously).
            //
            DestroyDeviceInfoElement(DeviceInfoSet, pDeviceInfoSet, ElemToDelete);

            //
            // Now remove the element from the list.
            //
            if(PrevElem) {
                PrevElem->Next = NextElem;
            } else {
                pDeviceInfoSet->DeviceInfoHead = NextElem;
            }

            if(!NextElem) {
                pDeviceInfoSet->DeviceInfoTail = PrevElem;
            }

            MYASSERT(pDeviceInfoSet->DeviceInfoCount > 0);
            pDeviceInfoSet->DeviceInfoCount--;

            //
            // If this element was the currently selected device for this
            // set, then reset the device selection.
            //
            if(pDeviceInfoSet->SelectedDevInfoElem == ElemToDelete) {
                pDeviceInfoSet->SelectedDevInfoElem = NULL;
            }

            //
            // Invalidate our enumeration hint for this devinfo element list.
            //
            pDeviceInfoSet->DeviceInfoEnumHint = NULL;
            pDeviceInfoSet->DeviceInfoEnumHintIndex = INVALID_ENUM_INDEX;

        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiEnumDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This API enumerates the members of the specified device information set.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set whose members
        are to be enumerated.

    MemberIndex - Supplies the zero-based index of the device information member
        to be retreived.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure that will
        receive information about this member.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    To enumerate device information members, an application should initially call
    the SetupDiEnumDeviceInfo function with the MemberIndex parameter set to zero.
    The application should then increment MemberIndex and call the
    SetupDiEnumDeviceInfo function until there are no more values (i.e., the
    function fails, and GetLastError returns ERROR_NO_MORE_ITEMS).

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(MemberIndex >= pDeviceInfoSet->DeviceInfoCount) {
            Err = ERROR_NO_MORE_ITEMS;
            goto clean0;
        }

        //
        // Find the element corresponding to the specified index (using our
        // enumeration hint optimization, if possible)
        //
        if(pDeviceInfoSet->DeviceInfoEnumHintIndex <= MemberIndex) {
            MYASSERT(pDeviceInfoSet->DeviceInfoEnumHint);
            DevInfoElem = pDeviceInfoSet->DeviceInfoEnumHint;
            i = pDeviceInfoSet->DeviceInfoEnumHintIndex;
        } else {
            DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
            i = 0;
        }
        for(; i < MemberIndex; i++) {
            DevInfoElem = DevInfoElem->Next;
        }

        if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                              DevInfoElem,
                                              DeviceInfoData))) {
            Err = ERROR_INVALID_USER_BUFFER;
        }

        //
        // Remember this element as our new enumeration hint.
        //
        pDeviceInfoSet->DeviceInfoEnumHintIndex = MemberIndex;
        pDeviceInfoSet->DeviceInfoEnumHint = DevInfoElem;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiRegisterDeviceInfo(
    IN     HDEVINFO           DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA   DeviceInfoData,
    IN     DWORD              Flags,
    IN     PSP_DETSIG_CMPPROC CompareProc,      OPTIONAL
    IN     PVOID              CompareContext,   OPTIONAL
    OUT    PSP_DEVINFO_DATA   DupDeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This API registers a device instance with the Plug & Play Manager.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set that contains
        the device information element for this device instance.

    DeviceInfoData - Supplies a pointer to the SP_DEVINFO_DATA structure for the
        device instance being registered.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

    Flags - Controls how the device is to be registered.  May be a combination of
        the following values:

            SPRDI_FIND_DUPS - Search for a previously-existing device instance
                              corresponding to this device information.  If this
                              flag is not specified, the device instance will be
                              registered, regardless of whether a device instance
                              already exists for it.

    CompareProc - Optionally, supplies a comparison callback function to be used in
        duplicate detection.  If specified, the function will be called for each
        device instance that is of the same class as the device instance being
        registered.  The prototype of the callback function is as follows:

            typedef DWORD (CALLBACK* PSP_DETSIG_CMPPROC)(
                IN HDEVINFO         DeviceInfoSet,
                IN PSP_DEVINFO_DATA NewDeviceData,
                IN PSP_DEVINFO_DATA ExistingDeviceData,
                IN PVOID            CompareContext      OPTIONAL
                );

        The compare function must return ERROR_DUPLICATE_FOUND if it finds the two
        devices to be duplicates of each other, and NO_ERROR otherwise.  If some
        other error (e.g., out-of-memory) is encountered, the callback should return
        the appropriate ERROR_* code indicating the failure that occurred.

        If a CompareProc is not supplied, and duplicate detection is requested, then a
        default comparison behavior will be used.  (See pSetupDupDevCompare for details.)

    CompareContext - Optionally, supplies the address of a caller-supplied context
        buffer that will be passed into the compare callback routine.  This parameter
        is ignored if CompareProc is not supplied.

    DupDeviceInfoData - Optionally, supplies a pointer to a device information
        element that will be initialized for the duplicate device instance, if any,
        discovered as a result of attempting to register this device.  This will
        be filled in if the function returns FALSE, and GetLastError returns
        ERROR_DUPLICATE_FOUND.  This device information element will be added as
        a member of the specified DeviceInfoSet (if it wasn't already a member).
        If DupDeviceInfoData is not supplied, then the duplicate WILL NOT be added
        to the device information set.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    After registering a device information element, the caller should refresh any
    stored copies of the devinst handle associated with this device, as the handle
    value may have changed during registration.  The caller need not re-retrieve
    the SP_DEVINFO_DATA structure, because the devinst field of the DeviceInfoData
    structure will be updated to reflect the current handle value.

    This API may invalidate our devinfo element enumeration hint.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem, CurDevInfoElem;
    CONFIGRET cr;
    ULONG DevIdBufferLen, ulStatus, ulProblem;
    PTCHAR DevIdBuffer = NULL;
    PTSTR CurDevId;
    DEVINST ParentDevInst;
    BOOL AlreadyPresent;
    SP_DEVINFO_DATA CurDevInfoData;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    DEFAULT_DEVCMP_CONTEXT DevCmpContext;
    LOG_CONF NewDevLogConfig;
    RES_DES NewDevResDes;

    if(Flags & ~SPRDI_FIND_DUPS) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    //
    // Initialize the following variables so we'll know whether we need to free any of their
    // associated resources.
    //
    ZeroMemory(&DevCmpContext, sizeof(DevCmpContext));
    NewDevLogConfig = (LOG_CONF)NULL;
    NewDevResDes = (RES_DES)NULL;

    try {

        DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                DeviceInfoData,
                                                NULL
                                               );
        if(!DevInfoElem) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        } else if(DevInfoElem->DiElemFlags & DIE_IS_REGISTERED) {
            //
            // Nothing to do--it's already been registered.
            //
            goto clean0;
        }

        //
        // If the caller requested duplicate detection then retrieve
        // all device instances of this class, and compare each one
        // with the device instance being registered.
        //
        if(Flags & SPRDI_FIND_DUPS) {

            do {

                if(CM_Get_Device_ID_List_Size_Ex(&DevIdBufferLen, NULL, CM_GETIDLIST_FILTER_NONE,
                                                 pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                } else if(!DevIdBufferLen) {
                    break;
                }

                if(!(DevIdBuffer = MyMalloc(DevIdBufferLen * sizeof(TCHAR)))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

                cr = CM_Get_Device_ID_List_Ex(NULL,
                                           DevIdBuffer,
                                           DevIdBufferLen,
                                           CM_GETIDLIST_FILTER_NONE,
                                           pDeviceInfoSet->hMachine);
                if(cr == CR_BUFFER_SMALL) {
                    //
                    // This will only happen if a device instance was added between
                    // the time that we calculated the size, and when we attempted
                    // to retrieve the list.  In this case, we'll simply retrieve
                    // the size again, and re-attempt to retrieve the list.
                    //
                    MyFree(DevIdBuffer);
                    DevIdBuffer = NULL;
                } else if(cr != CR_SUCCESS) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }

            } while(cr == CR_BUFFER_SMALL);

            if(!DevIdBufferLen) {
                goto NoDups;
            }

            //
            // Initialize the structure to be used during duplicate comparison callback.
            //
            CurDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            //
            // We have retrieved a list of every device instance in the system--now
            // do the comparison for each one that matches the class of the device
            // being registered.
            //

            if(!CompareProc) {
                //
                // We are supposed to do the comparisons, so set up to do our default comparison.
                //
                if((cr = CM_Get_First_Log_Conf_Ex(&NewDevLogConfig,
                                               DevInfoElem->DevInst,
                                               BOOT_LOG_CONF,
                                               pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
                    //
                    // Ensure that our NewDevLogConfig handle is still NULL, so we won't try
                    // to free it.
                    //
                    NewDevLogConfig = (LOG_CONF)NULL;

                    if(cr == CR_INVALID_DEVINST) {
                        Err = ERROR_INVALID_PARAMETER;
                        goto clean0;
                    } else {
                        //
                        // The only value we should get here is CR_NO_MORE_LOG_CONF.
                        // In this case, there is no comparison data, so we assume there is
                        // no possibility of duplication.
                        //
                        goto NoDups;
                    }
                }

                if(CM_Get_Next_Res_Des_Ex(&NewDevResDes,
                                       NewDevLogConfig,
                                       ResType_ClassSpecific,
                                       NULL,
                                       0,
                                       pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    //
                    // Ensure that our NewDevResDes is still NULL, so we won't try to free it.
                    //
                    NewDevResDes = (RES_DES)NULL;

                    //
                    // Since we can't retrieve the ResDes handle, assume there are no duplicates.
                    //
                    goto NoDups;
                }

                //
                // Now retrieve the actual data for the ResDes.
                //
                do {

                    if((CM_Get_Res_Des_Data_Size_Ex(&DevCmpContext.CsResourceSize,
                                                 NewDevResDes,
                                                 0,
                                                 pDeviceInfoSet->hMachine) != CR_SUCCESS) ||
                       !DevCmpContext.CsResourceSize) {
                        //
                        // Can't find out the size of the data, or there is none--assume no dups.
                        //
                        goto NoDups;
                    }

                    if(DevCmpContext.NewDevCsResource = MyMalloc(DevCmpContext.CsResourceSize)) {

                        if((cr = CM_Get_Res_Des_Data_Ex(NewDevResDes,
                                                     DevCmpContext.NewDevCsResource,
                                                     DevCmpContext.CsResourceSize,
                                                     0,
                                                     pDeviceInfoSet->hMachine)) != CR_SUCCESS) {

                            if(cr == CR_BUFFER_SMALL) {
                                //
                                // Then someone increased the size of the resource data before we
                                // got a chance to read it.  Free our buffer and try again.
                                //
                                MyFree(DevCmpContext.NewDevCsResource);
                                DevCmpContext.NewDevCsResource = NULL;
                            } else {
                                //
                                // Some other error occurred (highly unlikely).  Assume no dups.
                                //
                                goto NoDups;
                            }
                        }

                    } else {
                        //
                        // not enough memory--this is bad enough for us to abort.
                        //
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }

                } while(cr != CR_SUCCESS);

                //
                // We have successfully retrieved the class-specific resource data for the new
                // device's boot LogConfig.  Now allocate a buffer of the same size to store the
                // corresponding resource data for each device instance we're comparing against.
                // We don't have to worry about devices whose resource data is larger, because
                // CM_Get_Res_Des_Data_Ex will do a partial fill to a buffer that's not large enough
                // to contain the entire structure.  Since our default comparison only compares
                // the PnP detect signature (i.e., it ignores the legacy data at the very end of
                // the buffer, we're guaranteed that we have enough data to make the determination.
                //
                if(!(DevCmpContext.CurDevCsResource = MyMalloc(DevCmpContext.CsResourceSize))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

                CompareProc = pSetupDupDevCompare;
                CompareContext = &DevCmpContext;
            }

            for(CurDevId = DevIdBuffer;
                *CurDevId;
                CurDevId += lstrlen(CurDevId) + 1) {

                Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                                     CurDevId,
                                                     TRUE,
                                                     &(DevInfoElem->ClassGuid),
                                                     pDeviceInfoSet->InstallParamBlock.hwndParent,
                                                     &CurDevInfoElem,
                                                     TRUE,
                                                     &AlreadyPresent,
                                                     FALSE,
                                                     0,
                                                     pDeviceInfoSet
                                                    );

                if(Err == ERROR_NOT_ENOUGH_MEMORY) {
                    //
                    // Out-of-memory error is the only one bad enough to get us to abort.
                    //
                    goto clean0;
                } else if(Err != NO_ERROR) {
                    //
                    // Just ignore this device instance, and move on to the next.
                    //
                    Err = NO_ERROR;
                    continue;
                }

                DevInfoDataFromDeviceInfoElement(pDeviceInfoSet, CurDevInfoElem, &CurDevInfoData);

                //
                // We now have the possible duplicate in our set.  Call the comparison callback
                // routine.
                //
                Err = CompareProc(DeviceInfoSet, DeviceInfoData, &CurDevInfoData, CompareContext);

                //
                // If the device instance was created temporarily for the comparison, then it
                // may need to be destroyed.  It should be destroyed if it wasn't a duplicate,
                // or if the duplicate output parameter wasn't supplied.
                //
                if(!AlreadyPresent) {
                    if((Err != ERROR_DUPLICATE_FOUND) || !DupDeviceInfoData) {
                        SetupDiDeleteDeviceInfo(DeviceInfoSet, &CurDevInfoData);
                    }
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }
            }
        }

NoDups:

        //
        // To turn this phantom device instance into a 'live' device instance, we simply call
        // CM_Create_DevInst_Ex, which does the right thing (without reenumerating the whole
        // hardware tree!).
        //
        if(CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                         DeviceInstanceId,
                         SIZECHARS(DeviceInstanceId),
                         0,
                         pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            //
            // This should never happen!
            //
            Err = ERROR_NO_SUCH_DEVINST;
        } else if(CM_Get_Parent_Ex(&ParentDevInst, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            //
            // This should never happen!
            //
            Err = ERROR_NO_SUCH_DEVINST;
        } else if(CM_Create_DevInst_Ex(&(DevInfoElem->DevInst),
                             DeviceInstanceId,
                             ParentDevInst,
                             CM_CREATE_DEVINST_NORMAL |
                             CM_CREATE_DEVINST_DO_NOT_INSTALL,
                             pDeviceInfoSet->hMachine) == CR_SUCCESS) {
            //
            // Device is no longer a phantom!
            //
            DevInfoElem->DiElemFlags &= ~DIE_IS_PHANTOM;
        } else {
            //
            // This should never happen!
            //
            Err = ERROR_NO_SUCH_DEVINST;
            goto clean0;
        }

        DevInfoElem->DiElemFlags |= DIE_IS_REGISTERED;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variables so the compiler will respect our statement
        // ordering in the try clause.
        //
        DevIdBuffer = DevIdBuffer;
        DevCmpContext.NewDevCsResource = DevCmpContext.NewDevCsResource;
        DevCmpContext.CurDevCsResource = DevCmpContext.CurDevCsResource;
        NewDevLogConfig = NewDevLogConfig;
        NewDevResDes = NewDevResDes;
    }

    if(DevIdBuffer) {
        MyFree(DevIdBuffer);
    }

    if(DevCmpContext.NewDevCsResource) {
        MyFree(DevCmpContext.NewDevCsResource);
    }

    if(DevCmpContext.CurDevCsResource) {
        MyFree(DevCmpContext.CurDevCsResource);
    }

    if(NewDevResDes) {
        CM_Free_Res_Des_Handle(NewDevResDes);
    }

    if(NewDevLogConfig) {
        CM_Free_Log_Conf_Handle(NewDevLogConfig);
    }

    if((Err == ERROR_DUPLICATE_FOUND) && DupDeviceInfoData) {
        //
        // The user supplied a buffer to receive the SP_DEVINFO_DATA
        // structure for the duplicate.
        //
        try {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  CurDevInfoElem,
                                                  DupDeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupOpenAndAddNewDevInfoElem(
    IN  PDEVICE_INFO_SET pDeviceInfoSet,
    IN  PCTSTR           DeviceInstanceId,
    IN  BOOL             AllowPhantom,
    IN  CONST GUID      *ClassGuid,              OPTIONAL
    IN  HWND             hwndParent,             OPTIONAL
    OUT PDEVINFO_ELEM   *DevInfoElem,
    IN  BOOL             CheckIfAlreadyPresent,
    OUT PBOOL            AlreadyPresent,         OPTIONAL
    IN  BOOL             OpenExistingOnly,
    IN  ULONG            CmLocateFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet
    )
/*++

Routine Description:

    This routine opens a DEVINST handle to an existing device instance, and
    creates a new device information element for it.  This element is added
    to the specified device information set.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    DeviceInfoSet - Device information set to add the new element to.

    DeviceInstanceId - Supplies the name of the device instance to be opened.

    AllowPhantom - Specifies whether or not phantom device instances should be
        allowed.  If this flag is not set, and the specified device instance is
        not currently active, then the routine will fail with ERROR_NO_SUCH_DEVINST.

    ClassGuid - Optionally, supplies the class that the specified device instance
        must be in order to be added to the set.  If the device instance is found
        to be of some class other than the one specified, then the call will fail with
        ERROR_CLASS_MISMATCH.  If this parameter is not specified, then the only check
        that will be done on the device's class is to make sure that it matches the
        class of the set (if the set has an associated class).

    hwndParent - Optionally, supplies the handle to the top level window for
        UI relating to this element.

    DevInfoElem - Optionally, supplies the address of the variable that
        receives a pointer to the newly-allocated device information element.

    CheckIfAlreadyPresent - Specifies whether this routine should check to see whether
        the device instance is already in the specified devinfo set.

    AlreadyPresent - Optionally, supplies the address of a boolean variable
        that is set to indicate whether or not the specified device instance
        was already in the device information set.  If CheckIfAlreadyThere is FALSE,
        then this parameter is ignored.

    OpenExistingOnly - If this flag is non-zero, then only succeed if the device
        information element is already in the set.  If this flag is TRUE, then
        the CheckIfAlreadyPresent flag must also be TRUE.

    CmLocateFlags - Supplies additional flags to be passed to CM_Locate_DevInst.

    ContainingDeviceInfoSet - Supplies a pointer to the device information set
        structure with which this element is to be associated.  This may be
        different from the pDeviceInfoSet parameter if we're working against a
        cloned devinfo set (i.e., to facilitate rollback).

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise the
    ERROR_* code is returned.

Remarks:

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    CONFIGRET cr;
    DEVINST DevInst;
    DWORD Err, DiElemFlags;
    GUID GuidBuffer;

    if((cr = CM_Locate_DevInst_Ex(&DevInst,
                                 (DEVINSTID)DeviceInstanceId,
                                 CM_LOCATE_DEVINST_NORMAL | CmLocateFlags,
                                 pDeviceInfoSet->hMachine)) == CR_SUCCESS) {

        DiElemFlags = DIE_IS_REGISTERED;

    } else {

        if(cr == CR_INVALID_DEVICE_ID) {
            return ERROR_INVALID_DEVINST_NAME;
        } else if(!AllowPhantom) {
            return ERROR_NO_SUCH_DEVINST;
        }

        //
        // It could be that the device instance is present in the registry, but
        // not currently 'live'.  If this is the case, we'll be able to get a
        // handle to it by locating it as a phantom device instance.
        //
        if(CM_Locate_DevInst_Ex(&DevInst,
                                (DEVINSTID)DeviceInstanceId,
                                CM_LOCATE_DEVINST_PHANTOM | CmLocateFlags,
                                pDeviceInfoSet->hMachine) != CR_SUCCESS) {

            return ERROR_NO_SUCH_DEVINST;
        }

        DiElemFlags = DIE_IS_REGISTERED | DIE_IS_PHANTOM;
    }

    //
    // If requested, search through the current list of device information elements
    // to see if this element already exists.
    //
    if(CheckIfAlreadyPresent) {

        if(*DevInfoElem = FindDevInfoByDevInst(pDeviceInfoSet, DevInst, NULL)) {
            //
            // Make sure that this device instance is of the proper class, if a class GUID
            // filter was supplied.
            //
            if(ClassGuid && !IsEqualGUID(ClassGuid, &((*DevInfoElem)->ClassGuid))) {
                return ERROR_CLASS_MISMATCH;
            }

            if(AlreadyPresent) {
                *AlreadyPresent = TRUE;
            }
            return NO_ERROR;

        } else if(AlreadyPresent) {
            *AlreadyPresent = FALSE;
            if(OpenExistingOnly) {
                //
                // The requested device information element isn't in the set,
                // so we must fail the call.
                //
                return ERROR_NO_SUCH_DEVICE_INTERFACE;
            }
        }
    }

    //
    // Retrieve the class GUID for this device instance.
    //
    if((Err = pSetupClassGuidFromDevInst(DevInst, pDeviceInfoSet->hMachine,&GuidBuffer)) != NO_ERROR) {
        return Err;
    }

    //
    // If a class GUID filter was specified, then make sure that it matches the
    // class GUID for this device instance.
    //
    if(ClassGuid && !IsEqualGUID(ClassGuid, &GuidBuffer)) {
        return ERROR_CLASS_MISMATCH;
    }

    return pSetupAddNewDeviceInfoElement(pDeviceInfoSet,
                                         DevInst,
                                         &GuidBuffer,
                                         NULL,
                                         hwndParent,
                                         DiElemFlags,
                                         ContainingDeviceInfoSet,
                                         DevInfoElem
                                        );
}


DWORD
pSetupDupDevCompare(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA NewDeviceData,
    IN PSP_DEVINFO_DATA ExistingDeviceData,
    IN PVOID            CompareContext
    )
/*++

Routine Description:

    This routine is the default comparison routine for SetupDiRegisterDeviceInfo.
    It is used to determine whether the new device (i.e., the one being registered) is
    a duplicate of an existing device.

    The current algorithm for duplicate detection is as follows:

        Compare the BOOT_LOG_CONF logical configurations for the two devices.  Two
        resource types are used in this comparison--ResType_IO and ResType_ClassSpecific.
        The IO ranges, if any, for the two devices will be compared to see if they're
        identical.  Also, if the devices have a class-specific resource, then the
        CSD_ClassGuid, and the Plug&Play detect signature in CSD_Signature will be
        binary-compared.

        (lonnym): presently, the LogConfig only supports the class-specific resource,
        so I/O resource comparison is not done.

Arguments:

    DeviceInfoSet - Supplies the handle of the device information set containing both devices
        being compared.

    NewDeviceData - Supplies the address of the SP_DEVINFO_DATA for the device being registered.

    ExistingDeviceData - Supplies the address of the SP_DEVINFO_DATA for the existing device with
        which the new device is being compared.

    CompareContext - Supplies the address of a context buffer used during the comparison.  This
        buffer is actually a DEFAULT_DEVCMP_CONTEXT structure, defined as follows:

            typedef struct _DEFAULT_DEVCMP_CONTEXT {

                PCS_RESOURCE NewDevCsResource;
                PCS_RESOURCE CurDevCsResource;
                ULONG        CsResourceSize;

            } DEFAULT_DEVCMP_CONTEXT, *PDEFAULT_DEVCMP_CONTEXT;

        NewDevCsResource points to the class-specific resource buffer for the new device.
        CurDevCsResource points to a working buffer that should be used to retrieve the
            class-specific resource for the existing device.
        CsResourceSize supplies the size in bytes of these two buffers (they're both the
            same size).

Return Value:

    If the two devices are not duplicates of each other, the return value is NO_ERROR.
    If the two devices are duplicates of each other, the return value is ERROR_DUPLICATE_FOUND.

--*/
{
    LOG_CONF ExistingDeviceLogConfig;
    RES_DES ExistingDeviceResDes;
    CONFIGRET cr;
    PDEFAULT_DEVCMP_CONTEXT DevCmpContext;
    PCS_DES NewCsDes, ExistingCsDes;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    HMACHINE hMachine;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    hMachine = pDeviceInfoSet->hMachine;

    UnlockDeviceInfoSet(pDeviceInfoSet);


    //
    // First, retrieve the boot LogConfig for the existing device.
    //
    if(CM_Get_First_Log_Conf_Ex(&ExistingDeviceLogConfig,
                             ExistingDeviceData->DevInst,
                             BOOT_LOG_CONF,
                             hMachine) != CR_SUCCESS) {
        //
        // Couldn't get the boot LogConfig--assume this device isn't a duplicate.
        //
        return NO_ERROR;
    }

    //
    // Assume there are no duplicates.
    //
    Err = NO_ERROR;

    //
    // Now, retrieve the the ResDes handle for the class-specific resource.
    //
    if(CM_Get_Next_Res_Des_Ex(&ExistingDeviceResDes,
                           ExistingDeviceLogConfig,
                           ResType_ClassSpecific,
                           NULL,
                           0,
                           hMachine) != CR_SUCCESS) {
        //
        // Couldn't get the class-specific ResDes handle--assume this device isn't a duplicate
        //
        goto clean0;
    }

    //
    // Now, retrieve the actual data associated with this ResDes.  Note that we don't care if
    // we get a CR_BUFFER_SMALL error, because we are guaranteed that we got back at least the
    // amount of data that we have for the new device.  That's all we need to do our comparison.
    //
    DevCmpContext = (PDEFAULT_DEVCMP_CONTEXT)CompareContext;

    cr = CM_Get_Res_Des_Data_Ex(ExistingDeviceResDes,
                             DevCmpContext->CurDevCsResource,
                             DevCmpContext->CsResourceSize,
                             0,
                             hMachine);

    if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {
        //
        // We got _at least_ enough of the buffer to do the comparison.
        //
        NewCsDes = &(DevCmpContext->NewDevCsResource->CS_Header);
        ExistingCsDes = &(DevCmpContext->CurDevCsResource->CS_Header);

        //
        //  First, see if the Plug&Play detect signatures are both the same size.
        //
        if(NewCsDes->CSD_SignatureLength == ExistingCsDes->CSD_SignatureLength) {
            //
            // See if the class GUIDs are the same.
            //
            if(IsEqualGUID(&(NewCsDes->CSD_ClassGuid), &(ExistingCsDes->CSD_ClassGuid))) {
                //
                // Finally, see if the PnP detect signatures are identical
                //
                if(!memcmp(NewCsDes->CSD_Signature,
                           ExistingCsDes->CSD_Signature,
                           NewCsDes->CSD_SignatureLength)) {
                    //
                    // We have ourselves a duplicate!
                    //
                    Err = ERROR_DUPLICATE_FOUND;
                }
            }
        }
    }

    CM_Free_Res_Des_Handle(ExistingDeviceResDes);

clean0:
    CM_Free_Log_Conf_Handle(ExistingDeviceLogConfig);

    return Err;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInstanceIdA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
{
    WCHAR deviceInstanceId[MAX_DEVICE_ID_LEN];
    PSTR deviceInstanceIdA;
    DWORD AnsiLength;
    BOOL b;
    DWORD rc;
    DWORD requiredSize;

    b = SetupDiGetDeviceInstanceIdW(
            DeviceInfoSet,
            DeviceInfoData,
            deviceInstanceId,
            MAX_DEVICE_ID_LEN,
            &requiredSize
            );

    if(!b) {
        return(FALSE);
    }

    rc = GetLastError();

    if(deviceInstanceIdA = pSetupUnicodeToAnsi(deviceInstanceId)) {

        AnsiLength = lstrlenA(deviceInstanceIdA) + 1;

        if(RequiredSize) {
            try {
                *RequiredSize = AnsiLength;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
                b = FALSE;
            }
        }

        if(DeviceInstanceIdSize >= AnsiLength) {

            if(!lstrcpyA(DeviceInstanceId,deviceInstanceIdA)) {
                //
                // lstrcpy faulted; assume caller's pointer invalid
                //
                rc = ERROR_INVALID_USER_BUFFER;
                b = FALSE;
            }
        } else {
            rc = ERROR_INSUFFICIENT_BUFFER;
            b = FALSE;
        }

        MyFree(deviceInstanceIdA);

    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiGetDeviceInstanceIdW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PWSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(DeviceInstanceId);
    UNREFERENCED_PARAMETER(DeviceInstanceIdSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDeviceInstanceId(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PTSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the device instance ID associated with a device
    information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element whose ID is to be retrieved.

    DeviceInfoData - Supplies a pointer to the SP_DEVINFO_DATA structure for
        the device information element whose ID is to be retrieved.

    DeviceInstanceId - Supplies the address of a character buffer that will
        receive the ID for the specified device information element.

    DeviceInstanceIdSize - Supplies the size, in characters, of the DeviceInstanceId
        buffer.

    RequiredSize - Optionally, supplies the address of a variable that receives the
        number of characters required to store the device instance ID.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG ulLen;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element whose ID we are to retrieve.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Find out how large the buffer needs to be.  We always have to
        // make this call first, because CM_Get_Device_ID_Ex doesn't return
        // a CR_BUFFER_SMALL error if there isn't room for the terminating
        // NULL.
        //
        if((cr = CM_Get_Device_ID_Size_Ex(&ulLen,
                                       DevInfoElem->DevInst,
                                       0,
                                       pDeviceInfoSet->hMachine)) == CR_SUCCESS) {
            //
            // The size returned from CM_Get_Device_ID_Size doesn't include
            // the terminating NULL.
            //
            ulLen++;

        } else {

            Err = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                             : ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(RequiredSize) {
            *RequiredSize = ulLen;
        }

        if(DeviceInstanceIdSize < ulLen) {
            Err = ERROR_INSUFFICIENT_BUFFER;
            goto clean0;
        }

        //
        // Now retrieve the ID.
        //
        if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                                  DeviceInstanceId,
                                  DeviceInstanceIdSize,
                                  0,
                                  pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
            switch(cr) {

                case CR_INVALID_POINTER :
                    Err = ERROR_INVALID_USER_BUFFER;
                    break;

                default :
                    //
                    // Should never hit this!
                    //
                    Err = ERROR_INVALID_DATA;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupAddInterfaceDeviceToDevInfoElem(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINFO_ELEM           DevInfoElem,
    IN  CONST GUID             *InterfaceClassGuid,
    IN  PTSTR                   InterfaceDeviceName,
    IN  BOOL                    IsActive,
    IN  BOOL                    IsDefault,
    IN  BOOL                    StoreTruncateNode,
    IN  BOOL                    OpenExistingOnly,
    OUT PINTERFACE_DEVICE_NODE *InterfaceDeviceNode  OPTIONAL
    )
/*++

Routine Description:

    This routine adds the specified interface device onto a device information
    element's list of interface devices.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        containing the specified element.

    DevInfoElem - Supplies a pointer to the DEVINFO_ELEM structure whose
        interface device list is being added to.

    InterfaceClassGuid - Supplies a pointer to a GUID representing the class
        that this interface device is a member of.

    InterfaceDeviceName - Supplies the symbolic link name of the interface device
        being added.

    IsActive - Specifies whether or not the interface device is presently active.

    IsDefault - Specifies whether or not the interface device is presently the
        default device interface for this device interface class.

    StoreTruncateNode - If non-zero, then store the address of this device
        interface node (if newly-added) when this is the first such node added
        to the device information elements device interface node list (i.e.,
        the interface class list's InterfaceDeviceTruncateNode field is NULL).

    OpenExistingOnly - If non-zero, then only succeed if the requested device
        interface is already in the device information set.

    InterfaceDeviceNode - Optionally, supplies the address of an interface device
        node pointer to be filled in with the node created for this interface device.

Return Value:

    If success, the return value is NO_ERROR.
    If failure, the return value is ERROR_NOT_ENOUGH_MEMORY.

--*/
{
    LONG GuidIndex;
    PINTERFACE_CLASS_LIST InterfaceClassList;
    PINTERFACE_DEVICE_NODE NewInterfaceDeviceNode, CurInterfaceDevice, PrevInterfaceDevice;
    LONG SymLinkNameId;

    //
    // First, get a reference (i.e., pointer) to this interface class guid (create one
    // if it's not already present for this set).
    //
    GuidIndex = AddOrGetGuidTableIndex(DeviceInfoSet, InterfaceClassGuid, TRUE);

    if(GuidIndex == -1) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now, get the interface class list for this class from the relevant
    // devinfo element (again, we will create a new (empty) list if it doesn't
    // already exist).
    //
    if(!(InterfaceClassList = AddOrGetInterfaceClassList(DeviceInfoSet,
                                                         DevInfoElem,
                                                         GuidIndex,
                                                         TRUE))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now we will add a new device interface node to this list (making sure
    // that the node isn't already there).
    //
    SymLinkNameId = pStringTableAddString(DeviceInfoSet->StringTable,
                                          InterfaceDeviceName,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                          NULL,
                                          0
                                         );

    if(SymLinkNameId == -1) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(CurInterfaceDevice = InterfaceClassList->InterfaceDeviceNode, PrevInterfaceDevice = NULL;
        CurInterfaceDevice;
        PrevInterfaceDevice = CurInterfaceDevice, CurInterfaceDevice = CurInterfaceDevice->Next) {

        if(CurInterfaceDevice->SymLinkName == SymLinkNameId) {
            //
            // The node is already in our list, we don't want to add it again.
            // Update the flags for this interface device to reflect whether
            // the device is presently active, and whether it is the default
            // interface for this class.
            //
            CurInterfaceDevice->Flags = (CurInterfaceDevice->Flags & ~SPINT_ACTIVE) | (IsActive ? SPINT_ACTIVE : 0);
            CurInterfaceDevice->Flags = (CurInterfaceDevice->Flags & ~SPINT_DEFAULT) | (IsDefault ? SPINT_DEFAULT : 0);

            //
            // Return this node to the caller.
            //
            if(InterfaceDeviceNode) {
                *InterfaceDeviceNode = CurInterfaceDevice;
            }
            return NO_ERROR;
        }
    }

    //
    // The device interface node wasn't already in our list--add it (unless
    // we've been told not to)
    //
    if(OpenExistingOnly) {
        return ERROR_NO_SUCH_DEVICE_INTERFACE;
    }

    if(!(NewInterfaceDeviceNode = MyMalloc(sizeof(INTERFACE_DEVICE_NODE)))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(NewInterfaceDeviceNode, sizeof(INTERFACE_DEVICE_NODE));

    NewInterfaceDeviceNode->SymLinkName = SymLinkNameId;

    if(PrevInterfaceDevice) {
        PrevInterfaceDevice->Next = NewInterfaceDeviceNode;
    } else {
        InterfaceClassList->InterfaceDeviceNode = NewInterfaceDeviceNode;
    }
    InterfaceClassList->InterfaceDeviceCount++;

    //
    // If this is the first device interface node added to this list, then
    // remember it so we can truncate the list at this point if we later find
    // that we need to rollback (because we encountered some error).
    //
    if(StoreTruncateNode && !InterfaceClassList->InterfaceDeviceTruncateNode) {
        InterfaceClassList->InterfaceDeviceTruncateNode = NewInterfaceDeviceNode;
    }

    //
    // Store the interface class GUID index in the node, so that we can easily
    // determine the class of the node later.
    //
    NewInterfaceDeviceNode->GuidIndex = GuidIndex;

    //
    // Setup the flags for this interface device (these are the same flags that
    // the caller sees in the SP_INTERFACE_DEVICE_DATA structure).
    //
    NewInterfaceDeviceNode->Flags = IsActive ? SPINT_ACTIVE : 0;
    NewInterfaceDeviceNode->Flags |= IsDefault ? SPINT_DEFAULT : 0;

    //
    // Store a back-pointer in the device interface node, so that we can get
    // back to the devinfo element that owns it (there are circumstances when
    // we will be given a device interface data buffer outside of the context
    // of any devinfo element).
    //
    NewInterfaceDeviceNode->OwningDevInfoElem = DevInfoElem;

    if(InterfaceDeviceNode) {
        *InterfaceDeviceNode = NewInterfaceDeviceNode;
    }

    return NO_ERROR;
}


BOOL
WINAPI
SetupDiEnumDeviceInterfaces(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    )
/*++

Routine Description:

    This API enumerates device interfaces of the specified class that are
    contained in the devinfo set (optionally, filtered based on DeviceInfoData).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        device interfaces to be enumerated.

    DeviceInfoData - Optionally, supplies a pointer to a device information
        element for whom device interfaces are to be enumerated.

    InterfaceClassGuid - Supplies a pointer to the interface class GUID whose
        members are to be enumerated.

    MemberIndex - Supplies the zero-based index of the device interface to be
        retrieved.  If DeviceInfoData is specified, then this is relative to
        all device interfaces of the specified class owned by that device
        information element.  If DeviceInfoData is not specified, then this
        index is relative to all device interfaces contained in the device
        information set.

    InterfaceDeviceData - Supplies a pointer to a device interface data buffer
        that receives information about the specified device interface.  The
        cbSize field of this structure must be filled in with
        sizeof(SP_DEVICE_INTERFACE_DATA), or the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    To enumerate device interface members, an application should initially call
    the SetupDiEnumDeviceInterfaces function with the MemberIndex parameter set
    to zero.  The application should then increment MemberIndex and call the
    SetupDiEnumDeviceInterfaces function until there are no more values (i.e.,
    the function fails, and GetLastError returns ERROR_NO_MORE_ITEMS).

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem;
    LONG InterfaceClassGuidIndex;
    PINTERFACE_CLASS_LIST InterfaceClassList;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Retrieve the index of this interface class GUID.
        //
        if((InterfaceClassGuidIndex = AddOrGetGuidTableIndex(pDeviceInfoSet,
                                                             InterfaceClassGuid,
                                                             FALSE)) == -1) {
            Err = ERROR_NO_MORE_ITEMS;
            goto clean0;
        }

        //
        // Find the requested interface device.
        //
        if(DeviceInfoData) {
            //
            // Then we're enumerating only those interface devices that are owned
            // by a particular devinfo element.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            if(!(InterfaceClassList = AddOrGetInterfaceClassList(pDeviceInfoSet,
                                                                 DevInfoElem,
                                                                 InterfaceClassGuidIndex,
                                                                 FALSE))
               || (MemberIndex >= InterfaceClassList->InterfaceDeviceCount))
            {
                Err = ERROR_NO_MORE_ITEMS;
                goto clean0;
            }

        } else {
            //
            // We're enumerating across all devinfo elements. Find the appropriate devinfo
            // element, and adjust the member index accordingly.
            //
            for(DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
                DevInfoElem;
                DevInfoElem = DevInfoElem->Next) {

                if(InterfaceClassList = AddOrGetInterfaceClassList(pDeviceInfoSet,
                                                                   DevInfoElem,
                                                                   InterfaceClassGuidIndex,
                                                                   FALSE)) {

                    if(MemberIndex < InterfaceClassList->InterfaceDeviceCount) {
                        //
                        // We've found the devinfo element containing the interface device
                        // we're looking for.
                        //
                        break;

                    } else {
                        //
                        // The interface device we're looking for isn't associated with
                        // this devinfo element.  Adjust our index to eliminate the interface
                        // devices for this element, and continue searching.
                        //
                        MemberIndex -= InterfaceClassList->InterfaceDeviceCount;
                    }
                }
            }

            if(!DevInfoElem) {
                //
                // Then the specified index was higher than the count of interface devices
                // in this devinfo set.
                //
                Err = ERROR_NO_MORE_ITEMS;
                goto clean0;
            }
        }

        //
        // If we reach this point, we've found the devinfo element that contains the requested
        // interface device, and we have a pointer to the relevant interface class list.  Now
        // all we need to do is retrieve the correct member of this list, and fill in the caller's
        // interface device data buffer with the appropriate information.
        //
        InterfaceDeviceNode = InterfaceClassList->InterfaceDeviceNode;

        for(i = 0; i < MemberIndex; i++) {
            InterfaceDeviceNode = InterfaceDeviceNode->Next;
        }

        if(!InterfaceDeviceDataFromNode(InterfaceDeviceNode, InterfaceClassGuid, DeviceInterfaceData)) {
            Err = ERROR_INVALID_USER_BUFFER;
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailA(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    //
    // Since the maximum length for both the symbolic link and refstring components
    // of the interface device name is 255 characters (excluding NULL), the maximum
    // length of the entire interface device name is 512 characters
    // (255 + 255 + 1 backslash + 1 NULL character).
    //
    // Thus, we will retrieve the unicode form of this information using a maximally-
    // sized buffer, then convert it to ANSI, and store it in the caller's buffer, if
    // the caller's buffer is large enough.
    //
    BYTE UnicodeBuffer[offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_W, DevicePath) + (512 * sizeof(WCHAR))];
    PCHAR AnsiBuffer;
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W UnicodeDetailData;
    DWORD rc, UnicodeRequiredSize, ReturnBufferRequiredSize;
    int AnsiStringSize;

    //
    // Check parameters.
    //
    rc = NO_ERROR;
    try {
        if(DeviceInterfaceDetailData) {
            //
            // Check signature and make sure buffer is large enough
            // to hold fixed part and at least a valid empty string.
            //
            if((DeviceInterfaceDetailData->cbSize != sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A))
            || (DeviceInterfaceDetailDataSize < (offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_A,DevicePath)+sizeof(CHAR)))) {

                rc = ERROR_INVALID_USER_BUFFER;
            }
        } else {
            //
            // Doesn't want data, size has to be 0.
            //
            if(DeviceInterfaceDetailDataSize) {
                rc = ERROR_INVALID_USER_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    UnicodeDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)UnicodeBuffer;
    UnicodeDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

    if(!SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet,
                                         DeviceInterfaceData,
                                         UnicodeDetailData,
                                         sizeof(UnicodeBuffer),
                                         &UnicodeRequiredSize,
                                         DeviceInfoData)) {
        return FALSE;
    }

    //
    // We successfully retrieved the (unicode) device interface details.  Now convert it
    // to ANSI, and store it in the caller's buffer.
    //
    UnicodeRequiredSize -= offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_W, DevicePath);
    UnicodeRequiredSize /= sizeof(WCHAR);

    //
    // Allocate an ANSI buffer to be used during the conversion.  The maximum size the buffer
    // would need to be would be 2 * NumUnicodeChars.
    //
    if(!(AnsiBuffer = MyMalloc(UnicodeRequiredSize * 2))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    try {

        AnsiStringSize = WideCharToMultiByte(CP_ACP,
                                             0,
                                             UnicodeDetailData->DevicePath,
                                             UnicodeRequiredSize,
                                             AnsiBuffer,
                                             UnicodeRequiredSize * 2,
                                             NULL,
                                             NULL
                                             );

        if(!AnsiStringSize) {
            //
            // This should never happen!
            //
            rc = GetLastError();
            goto clean0;
        }

        ReturnBufferRequiredSize = AnsiStringSize + offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_A, DevicePath);

        if(RequiredSize) {
            *RequiredSize = ReturnBufferRequiredSize;
        }

        if(ReturnBufferRequiredSize > DeviceInterfaceDetailDataSize) {
            rc = ERROR_INSUFFICIENT_BUFFER;
            goto clean0;
        }

        //
        // OK, so we've determined that the caller's buffer is big enough.  Now, copy the
        // ANSI data into their buffer.
        //
        CopyMemory(DeviceInterfaceDetailData->DevicePath,
                   AnsiBuffer,
                   AnsiStringSize
                  );

clean0:
        ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    MyFree(AnsiBuffer);

    SetLastError(rc);
    return (rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailW(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInterfaceData);
    UNREFERENCED_PARAMETER(DeviceInterfaceDetailData);
    UNREFERENCED_PARAMETER(DeviceInterfaceDetailDataSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiGetDeviceInterfaceDetail(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA   DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves details about a particular device interface (i.e., what
    it's "name" is that you can do a CreateFile on).

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a device interface to retrieve details about.

    DeviceInterfaceData - Supplies a device interface information structure
        for which details are to be retrieved.

    DeviceInterfaceDetailData - Optionally, supplies the address of a device
        interface detail data structure that will receive additional information
        about the specified device interface.  If this parameter is not specified,
        then DeviceInterfaceDetailDataSize must be zero (this would be done if the
        caller was only interested in finding out how large of a buffer is required).
        If this parameter is specified, the cbSize field of this structure must
        be set to the size of the structure before calling this API. NOTE:
        The 'size of the structure' on input means sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA).
        Note that this is essentially just a signature and is entirely separate
        from DeviceInterfaceDetailDataSize.  See below.

    DeviceInterfaceDetailDataSize - Supplies the size, in bytes, of the
        DeviceInterfaceDetailData buffer. To be valid this buffer must be at least
        offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath) + sizeof(TCHAR) bytes,
        which allows storage of the fixed part of the structure and a single nul to
        terminate an empty multi_sz. (Depending on structure alignment,
        character width, and the data to be returned, this may actually be
        smaller than sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the detailed device interface
        information.  This value includes both the size of the structure itself,
        and the additional number of bytes required for the variable-length
        character buffer at the end of it that holds the device path.

    DeviceInfoData - Optionally, supplies a pointer to a SP_DEVINFO_DATA structure
        that will receive information about the device information element that
        owns this device interface.  Callers that only want to retrieve this parameter
        may pass NULL for DeviceInterfaceDetailData, and pass 0 for
        DeviceInterfaceDetailDataSize.  Assuming the specified device interface is
        valid, the API will fail, with GetLastError returning ERROR_INSUFFICIENT_BUFFER.
        However, DeviceInfoData will have been correctly filled in with the
        associated device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    PCTSTR DevicePath;
    DWORD DevicePathLength, BufferLengthNeeded;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // First, find the devinfo element that owns this interface device.  This
        // is used as a form of validation, and also may be needed later on, if the
        // user supplied us with a DeviceInfoData buffer to be filled in.
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying interface device node.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(DeviceInterfaceData->Reserved);

        DevicePath = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                              InterfaceDeviceNode->SymLinkName
                                             );

        DevicePathLength = (lstrlen(DevicePath) + 1) * sizeof(TCHAR);

        //
        // Before attempting to store the device path in the caller's buffer, check to see
        // whether they requested that the associated devinfo element be returned.  If so,
        // do that first.
        //
        if(DeviceInfoData) {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  DevInfoElem,
                                                  DeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
                goto clean0;
            }
        }

        //
        // Validate the caller's buffer.
        //
        if(DeviceInterfaceDetailData) {

            if((DeviceInterfaceDetailDataSize <
                (offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath) + sizeof(TCHAR))) ||
               (DeviceInterfaceDetailData->cbSize != sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA))) {

                Err = ERROR_INVALID_USER_BUFFER;
                goto clean0;
            }

        } else if(DeviceInterfaceDetailDataSize) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Compute the buffer size required.
        //
        BufferLengthNeeded = offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath) + DevicePathLength;

        if(RequiredSize) {
            *RequiredSize = BufferLengthNeeded;
        }

        if(BufferLengthNeeded > DeviceInterfaceDetailDataSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
            goto clean0;
        }

        CopyMemory(DeviceInterfaceDetailData->DevicePath, DevicePath, DevicePathLength);

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiOpenDeviceInterfaceA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
{
    PCWSTR UnicodeDevicePath;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(DevicePath, &UnicodeDevicePath);
    if(rc == NO_ERROR) {

        rc = _SetupDiOpenInterfaceDevice(DeviceInfoSet,
                                         (PWSTR)UnicodeDevicePath,
                                         OpenFlags,
                                         DeviceInterfaceData
                                        );

        MyFree(UnicodeDevicePath);

    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupDiOpenDeviceInterfaceW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCWSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DevicePath);
    UNREFERENCED_PARAMETER(OpenFlags);
    UNREFERENCED_PARAMETER(DeviceInterfaceData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiOpenDeviceInterface(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCTSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
/*++

Routine Description:

    This routine opens up the device information element that exposes the
    specified device interface (if it's not already in the device information
    set), and then adds this device interface to the set.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set into which this
        new device interface element is to be opened.

        NOTE:  The class of the underlying device instance must match the class
        of the set (or the set should have no associated class).  If this is not
        the case, the call will fail, and GetLastError will return ERROR_CLASS_MISMATCH.

    DevicePath - Supplies the name of the device interface to be opened.  This name
        is a Win32 device path of the form "\\?\<InterfaceDeviceName>[\<RefString>]",
        and is returned via a previous enumeration of device interface (i.e., via
        SetupDiGetClassDevs(...DIGCF_INTERFACEDEVICE) or by notification via
        RegisterDeviceNotification).

    OpenFlags - Supplies flags controlling how the device interface element is
        to be opened.  May be a combination of the following values:

        DIODI_NO_ADD - Only succeed the call (and optionally return the device
                       interface data) if the device interface already exists
                       in the device information set.  This flag may be used to
                       get a device interface data context buffer back given a
                       device interface name, without causing that interface to
                       be opened if it's not already in the set.

                       This is useful, for example, when an app receives a
                       device interface removal notification.  Such an app will
                       want to remove the corresponding device interface data
                       from the device information they're using as a container,
                       but they wouldn't want to open up a device interface
                       element not already in the set just so they can close it.

    DeviceInterfaceData - Optionally, supplies a pointer to a device interface data
        buffer that receives information about the specified device interface.  The
        cbSize field of this structure must be filled in with sizeof(SP_DEVICE_INTERFACE_DATA)
        or the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the new device interface was successfully opened, but the user-supplied
    DeviceInterfaceData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The device interface
    element _will_ have been added as a new member of the set, however.

    If the device interface already exists in the set, the flags will be updated
    to reflect the current state of the device.  Thus, for example, if a device
    was not active when originally opened into the set, but has since become
    active, this API may be used to 'refresh' the flags on that device interface
    element, so that the SPINT_ACTIVE bit is once again in sync with reality.

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    PCTSTR WritableDevicePath;
    DWORD rc;

    rc = CaptureStringArg(DevicePath, &WritableDevicePath);
    if(rc == NO_ERROR) {

        rc = _SetupDiOpenInterfaceDevice(DeviceInfoSet,
                                         (PTSTR)WritableDevicePath,
                                         OpenFlags,
                                         DeviceInterfaceData
                                        );

        MyFree(WritableDevicePath);
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


DWORD
_SetupDiOpenInterfaceDevice(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PTSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA InterfaceDeviceData OPTIONAL
    )
/*++

Routine Description:

    Worker routine for SetupDiOpenInterfaceDevice(A|W).  This is a separate routine
    so that both A and W versions can capture their DevicePath argument into a
    writable buffer, because we need this for adding the case-insensitive form to
    the string table.

Arguments:

    See SetupDiOpenInterfaceDevice for details.

Return Value:

    If the function succeeds, the return value is NO_ERROR.  Otherwise, it is a
    Win32 error code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, DevicePathLen;
    PCTSTR p;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    GUID InterfaceGuid;
    HKEY hKey;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    PCTSTR MachineName;
    BOOL DevInfoAlreadyPresent, IsActive, IsDefault;
    PDEVINFO_ELEM DevInfoElem;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;

    if(OpenFlags & ~DIODI_NO_ADD) {
        return ERROR_INVALID_FLAGS;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return ERROR_INVALID_HANDLE;
    }

    Err = NO_ERROR;
    hKey = INVALID_HANDLE_VALUE;
    DevInfoElem = NULL;

    try {
        //
        // Retrieve the interface class of this device.  Since the device path is of
        // the form "\\?\MungedDevInstName#{InterfaceClassGuid}[\RefString]", we can
        // retrieve the GUID from the name.
        //
        // NOTE: The algorithm about how this name is generated must be kept in sync
        // with the kernel-mode implementation of IoRegisterDeviceClassAssocation, et. al.
        //
        DevicePathLen = lstrlen(DevicePath);

        //
        // Move past "\\?\" prefix (also allow "\\.\" until Memphis fixes their code)
        //
        if((DevicePathLen < 4) ||
           (DevicePath[0] != TEXT('\\')) ||
           (DevicePath[1] != TEXT('\\')) ||
           ((DevicePath[2] != TEXT('?')) && (DevicePath[2] != TEXT('.'))) ||
           (DevicePath[3] != TEXT('\\')))
        {
            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        p = _tcschr(&(DevicePath[4]), TEXT('\\'));

        if(!p) {
            //
            // This name has no refstring--set the pointer to the end of the string
            //
            p = DevicePath + DevicePathLen;
        }

        //
        // Make sure there are enough characters preceding the current position for a
        // GUID to fit.
        //
        if(p < (DevicePath + 3 + GUID_STRING_LEN)) {
            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        lstrcpyn(InterfaceGuidString, p - (GUID_STRING_LEN - 1), SIZECHARS(InterfaceGuidString));

        if(pSetupGuidFromString(InterfaceGuidString, &InterfaceGuid) != NO_ERROR) {
            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // OK, now we know that we retrieved a valid GUID from an (apparently) valid device path.
        // Go open up this interface device key under the DeviceClasses registry branch.
        //
        hKey = SetupDiOpenClassRegKeyEx(&InterfaceGuid,
                                        KEY_READ,
                                        DIOCR_INTERFACE,
                                        MachineName,
                                        NULL
                                       );

        if(hKey == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            goto clean0;
        }

        if(NO_ERROR != (Err = pSetupGetDevInstNameAndStatusForInterfaceDevice(
                                  hKey,
                                  DevicePath,
                                  DeviceInstanceId,
                                  SIZECHARS(DeviceInstanceId),
                                  &IsActive,
                                  &IsDefault)))
        {
            goto clean0;
        }

        if(NO_ERROR != (Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                                             DeviceInstanceId,
                                                             TRUE,
                                                             NULL,
                                                             NULL,
                                                             &DevInfoElem,
                                                             TRUE,
                                                             &DevInfoAlreadyPresent,
                                                             (OpenFlags & DIODI_NO_ADD),
                                                             0,
                                                             pDeviceInfoSet)))
        {
            //
            // Make sure DevInfoElem is still NULL, so we won't try to delete it.
            //
            DevInfoElem = NULL;

            goto clean0;
        }

        //
        // Now that we've successfully opened up the device instance that 'owns'
        // this interface device, add a new interface device node onto this
        // devinfo element's list.
        //
        if((NO_ERROR == (Err = pSetupAddInterfaceDeviceToDevInfoElem(pDeviceInfoSet,
                                                                     DevInfoElem,
                                                                     &InterfaceGuid,
                                                                     DevicePath,
                                                                     IsActive,
                                                                     IsDefault,
                                                                     FALSE,
                                                                     (OpenFlags & DIODI_NO_ADD),
                                                                     &InterfaceDeviceNode)))
           || DevInfoAlreadyPresent)
        {
            //
            // Either we successfully added the interface device or the owning devinfo element
            // was already in the set.  In either case, we want to reset the DevInfoElem pointer
            // to NULL so we won't try to delete it from the set.
            //
            DevInfoElem = NULL;
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so the compiler will respect statement ordering
        // w.r.t. assignment.
        //
        DevInfoElem = DevInfoElem;
        hKey = hKey;
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    if(Err != NO_ERROR) {

        if(DevInfoElem) {

            SP_DEVINFO_DATA DeviceInfoData;

            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet, DevInfoElem, &DeviceInfoData);
            SetupDiDeleteDeviceInfo(DeviceInfoSet, &DeviceInfoData);
        }

    } else if(InterfaceDeviceData) {

        try {

            if(!InterfaceDeviceDataFromNode(InterfaceDeviceNode, &InterfaceGuid, InterfaceDeviceData)) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


BOOL
WINAPI
SetupDiGetDeviceInterfaceAlias(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData,
    IN  CONST GUID                *AliasInterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  AliasDeviceInterfaceData
    )
/*++

Routine Description:

    This routine retrieves the device interface of a particular class that 'aliases'
    the specified device interface.  Two device interfaces are considered aliases of
    each other if the following to criteria are met:

        1.  Both device interfaces are exposed by the same device instance.
        2.  Both device interfaces share the same RefString.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing the
        device interface for which an alias is to be retrieved.

    DeviceInterfaceData - Specifies the device interface whose alias is to be
        retrieved.

    AliasInterfaceClassGuid - Supplies a pointer to the GUID representing the interface
        class for which the alias is to be retrieved.

    AliasDeviceInterfaceData - Supplies a pointer to a device interface data buffer
        that receives information about the alias device interface.  The cbSize field
        of this structure must be filled in with sizeof(SP_DEVICE_INTERFACE_DATA) or
        the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

    Remarks:

    If the alias device interface was successfully opened, but the user-supplied
    AliasDeviceInterfaceData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The alias device interface
    element _will_ have been added as a new member of the set, however.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem, DevInfoElem2;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    PCTSTR DevicePath;
    PTSTR AliasPath;
    ULONG AliasPathLength;
    CONFIGRET cr;
    SP_DEVICE_INTERFACE_DATA TempInterfaceDevData;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    AliasPath = NULL;

    try {
        //
        // First, find the devinfo element that owns this interface device (for validation).
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying interface device node.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(DeviceInterfaceData->Reserved);

        //
        // Get the device path for this interface device.
        //
        DevicePath = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                              InterfaceDeviceNode->SymLinkName
                                             );

        //
        // Choose a buffer size that should always be large enough (we know this is the
        // case today, but since there is no defined maximum length on this path, we leave
        // the capability for it to grow in the future).
        //
        AliasPathLength = 512;

        while(TRUE) {

            if(!(AliasPath = MyMalloc(AliasPathLength * sizeof(TCHAR)))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Now retrieve the name of this interface device's alias in the specified class.
            //
            cr = CM_Get_Device_Interface_Alias_Ex(DevicePath,
                                               (LPGUID)AliasInterfaceClassGuid,
                                               AliasPath,
                                               &AliasPathLength,
                                               0,
                                               pDeviceInfoSet->hMachine);

            if(cr == CR_SUCCESS) {
                break;
            } else {
                //
                // If our buffer was too small, then free it, and try again with a larger buffer.
                //
                if(cr == CR_BUFFER_SMALL) {
                    MyFree(AliasPath);
                    AliasPath = NULL;
                } else {
                    Err = MapCrToSpError(cr, ERROR_NO_SUCH_DEVICE_INTERFACE);
                    goto clean0;
                }
            }
        }

        //
        // If we get to here then we've successfully retrieved the alias name.  Now open this
        // interface device in our device information set.
        //
        TempInterfaceDevData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        if(!SetupDiOpenDeviceInterface(DeviceInfoSet,
                                       AliasPath,
                                       0,
                                       &TempInterfaceDevData)) {
            //
            // This should never happen.
            //
            Err = GetLastError();
            goto clean0;
        }

        //
        // Retrieve the device information element for this alias interface device (this has to succeed).
        //
        DevInfoElem2 = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData);

        //
        // Since these two interface devices are aliases of each other, they'd better be owned by
        // the same devinfo element!
        //
        MYASSERT(DevInfoElem == DevInfoElem2);

        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(TempInterfaceDevData.Reserved);

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variable so the compiler will respect our statement ordering
        // w.r.t. assignment.
        //
        AliasPath = AliasPath;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(AliasPath) {
        MyFree(AliasPath);
    }

    if(Err == NO_ERROR) {

        try {

            if(!InterfaceDeviceDataFromNode(InterfaceDeviceNode,
                                            AliasInterfaceClassGuid,
                                            AliasDeviceInterfaceData)) {

                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

}


DWORD
pSetupGetDevInstNameAndStatusForInterfaceDevice(
    IN  HKEY   hKeyInterfaceClass,
    IN  PCTSTR InterfaceDeviceName,
    OUT PTSTR  OwningDevInstName,     OPTIONAL
    IN  DWORD  OwningDevInstNameSize,
    OUT PBOOL  IsActive,              OPTIONAL
    OUT PBOOL  IsDefault              OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the name of the device instance that exposes the specified
    interface device and whether or not that interface device is currently active,
    or is the default interface for the interface class to which it belongs.

Arguments:

    hKeyInterfaceClass - Supplies a handle to the registry key for the interface class
        of which this interface device is a member.  E.g.,

        HKLM\SYSTEM\CurrentControlSet\Control\DeviceClasses\{InterfaceClassGuid}

    InterfaceDeviceName - Supplies the name of the interface device.

    OwningDevInstName - Optionally, supplies the address of a character buffer that
        receives the name of the device instance that exposes this interface device.
        This buffer should be at least MAX_DEVICE_ID_LEN characters long.

    OwningDevInstNameSize - Supplies the size, in characters, of the OwningDevInstName
        buffer.

    IsActive - Optionally, supplies the address of a boolean variable that is set upon
        return to indicate whether this interface is presently exposed.

    IsDefault - Optionally, supplies the address of a boolean variable that is set upon
        return to indicate whether this interface is presently the default
        device interface for its device class.

Return Value:

    If the function succeeds, the return value is NO_ERROR.  Otherwise, it is a Win32
    error code.

--*/
{
    DWORD Err, DataBufferSize, RegDataType;
    HKEY hKeyInterfaceDevice, hKeyControl;
    TCHAR InterfaceClassDefault[(2 * MAX_PATH) + 1];  // 2 max-sized regkey names + terminating NULL.

    hKeyInterfaceDevice = hKeyControl = INVALID_HANDLE_VALUE;

    try {

        DataBufferSize = OwningDevInstNameSize * sizeof(TCHAR);

        Err = OpenDeviceInterfaceSubKey(hKeyInterfaceClass,
                                        InterfaceDeviceName,
                                        KEY_READ,
                                        &hKeyInterfaceDevice,
                                        OwningDevInstName,
                                        &DataBufferSize
                                       );

        if(Err != ERROR_SUCCESS) {
            //
            // Make sure the key handle is still invalid, so we'll know not to
            // close it.
            //
            hKeyInterfaceDevice = INVALID_HANDLE_VALUE;
            goto clean0;
        }

        if(IsActive) {
            //
            // The user wants to find out whether this interface device is currently active.
            // Check the 'Linked' value entry under the volatile 'Control' subkey to find
            // this out.
            //
            *IsActive = FALSE;

            if(ERROR_SUCCESS == RegOpenKeyEx(hKeyInterfaceDevice,
                                             pszControl,
                                             0,
                                             KEY_READ,
                                             &hKeyControl)) {

                DataBufferSize = sizeof(*IsActive);
                if(ERROR_SUCCESS != RegQueryValueEx(hKeyControl,
                                                    pszLinked,
                                                    NULL,
                                                    NULL,
                                                    (PBYTE)IsActive,
                                                    &DataBufferSize)) {
                    *IsActive = FALSE;
                }
            }
        }

        if(IsDefault) {
            //
            // The user wants to find out whether this interface device is the
            // default device interface for its device class.  Check the
            // 'Default' value entry under the interface class key to find this
            // out.
            //
            *IsDefault = FALSE;

            DataBufferSize = sizeof(InterfaceClassDefault);
            if(ERROR_SUCCESS == RegQueryValueEx(hKeyInterfaceClass,
                                                pszDefault,
                                                NULL,
                                                NULL,
                                                (PBYTE)InterfaceClassDefault,
                                                &DataBufferSize)) {
                if (lstrcmpi(InterfaceClassDefault, InterfaceDeviceName) == 0) {
                    *IsDefault = TRUE;
                }
            }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        hKeyInterfaceDevice = hKeyInterfaceDevice;
        hKeyControl = hKeyControl;
    }

    if(hKeyControl != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyControl);
    }

    if(hKeyInterfaceDevice != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyInterfaceDevice);
    }

    return Err;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupDiCreateDeviceInterfaceA(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCSTR                      ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    )
{
    PCWSTR UnicodeRefString;
    DWORD rc;
    BOOL b;

    b = FALSE;

    if(ReferenceString) {
        rc = pSetupCaptureAndConvertAnsiArg(ReferenceString, &UnicodeRefString);
    } else {
        UnicodeRefString = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        b = SetupDiCreateDeviceInterfaceW(DeviceInfoSet,
                                          DeviceInfoData,
                                          InterfaceClassGuid,
                                          UnicodeRefString,
                                          CreationFlags,
                                          DeviceInterfaceData
                                         );
        rc = GetLastError();

        if(UnicodeRefString) {
            MyFree(UnicodeRefString);
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode version
//
BOOL
WINAPI
SetupDiCreateDeviceInterfaceW(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCWSTR                     ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(InterfaceClassGuid);
    UNREFERENCED_PARAMETER(ReferenceString);
    UNREFERENCED_PARAMETER(CreationFlags);
    UNREFERENCED_PARAMETER(DeviceInterfaceData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupDiCreateDeviceInterface(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCTSTR                     ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    )
/*++

Routine Description:

    This API creates (registers) a device interface for the specified device
    information element, and adds this device interface to the device information
    set.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing the
        device information element for which a new device interface is being added.

    DeviceInfoData - Supplies the device information element for whom a device
        interface is being added.

    InterfaceClassGuid - Supplies the address of a GUID containing the class
        for this new device interface.

    ReferenceString - Optionally, supplies the reference string to be passed to the
        driver when opening this device interface.  This string becomes part of the
        device interface's name (as an additional path component).

    CreationFlags - Reserved for future use, must be set to 0.

    DeviceInterfaceData - Optionally, supplies a pointer to a device interface data
        buffer that receives information about the newly-created device interface.
        The cbSize field of this structure must be filled in with sizeof(SP_DEVICE_INTERFACE_DATA)
        or the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the new device interface was successfully created, but the user-supplied
    DeviceInterfaceData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The device interface
    element _will_ have been added as a new member of the set, however.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    TCHAR InterfaceDeviceName[(2 * MAX_PATH) + 1];  // 2 max-sized regkey names + terminating NULL.
    ULONG InterfaceDeviceNameSize;
    PCTSTR MachineName;
    CONFIGRET cr;
    BOOL IsActive, IsDefault;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    HKEY hKey;

    if(CreationFlags) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    hKey = INVALID_HANDLE_VALUE;

    try {
        //
        // Get a pointer to the device information element we're registering an
        // interface device for.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Register the interface device.
        //
        InterfaceDeviceNameSize = SIZECHARS(InterfaceDeviceName);
        cr = CM_Register_Device_Interface_Ex(DevInfoElem->DevInst,
                                          (LPGUID)InterfaceClassGuid,
                                          ReferenceString,
                                          InterfaceDeviceName,
                                          &InterfaceDeviceNameSize,
                                          0,
                                          pDeviceInfoSet->hMachine);

        if(cr != CR_SUCCESS) {
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            goto clean0;
        }

        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // This interface device might have already been registered, in which case it
        // could already be active.  We must check the 'Linked' registry value to see
        // whether this device is active.
        //
        hKey = SetupDiOpenClassRegKeyEx(InterfaceClassGuid,
                                        KEY_READ,
                                        DIOCR_INTERFACE,
                                        MachineName,
                                        NULL
                                       );

        if(hKey != INVALID_HANDLE_VALUE) {

            if(NO_ERROR != pSetupGetDevInstNameAndStatusForInterfaceDevice(
                               hKey,
                               InterfaceDeviceName,
                               NULL,
                               0,
                               &IsActive,
                               &IsDefault))
            {
                //
                // This shouldn't fail, but if it does, then just assume that the
                // interface device's status is non-active, and it is not the default.
                //
                IsActive = FALSE;
                IsDefault = FALSE;
            }

        } else {
            //
            // This should never happen--if it does, assume that the interface device
            // isn't active.
            //
            IsActive = FALSE;
            IsDefault = FALSE;
        }

        //
        // The interface device was successfully registered, now add it to the list of
        // interface devices associated with this device information element.
        //
        Err = pSetupAddInterfaceDeviceToDevInfoElem(pDeviceInfoSet,
                                                    DevInfoElem,
                                                    InterfaceClassGuid,
                                                    InterfaceDeviceName,
                                                    IsActive,
                                                    IsDefault,
                                                    FALSE,
                                                    FALSE,
                                                    &InterfaceDeviceNode
                                                   );

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variable so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        hKey = hKey;
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    if((Err == NO_ERROR) && DeviceInterfaceData) {

        try {
            if(!InterfaceDeviceDataFromNode(InterfaceDeviceNode, InterfaceClassGuid, DeviceInterfaceData)) {
                Err = ERROR_INVALID_USER_BUFFER;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDeleteDeviceInterfaceData(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
/*++

Routine Description:

    This API deletes the specified device interface element from the device
    information set.  It _does not_ remove (unregister) the device interface
    from the system (to do that, use SetupDiRemoveDeviceInterface).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        device interface to be deleted.

    DeviceInterfaceData - Specifies the device interface to be deleted.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    After a device interface is deleted, the device interface enumeration index
    is invalid, and enumeration should be re-started at index 0.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode, CurInterfaceDeviceNode, PrevInterfaceDeviceNode;
    PINTERFACE_CLASS_LIST InterfaceClassList;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // First, find the devinfo element that owns this interface device.
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying interface device node.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(DeviceInterfaceData->Reserved);

        //
        // Find this devinfo element's interface device list for this class.
        //
        if(!(InterfaceClassList = AddOrGetInterfaceClassList(pDeviceInfoSet,
                                                             DevInfoElem,
                                                             InterfaceDeviceNode->GuidIndex,
                                                             FALSE)))
        {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Find this interface device node in the list of interface devices for this device
        // information element.
        //
        for(CurInterfaceDeviceNode = InterfaceClassList->InterfaceDeviceNode, PrevInterfaceDeviceNode = NULL;
            CurInterfaceDeviceNode;
            PrevInterfaceDeviceNode = CurInterfaceDeviceNode, CurInterfaceDeviceNode = CurInterfaceDeviceNode->Next)
        {
            if(CurInterfaceDeviceNode == InterfaceDeviceNode) {
                break;
            }
        }

        if(!CurInterfaceDeviceNode) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        MYASSERT(InterfaceClassList->InterfaceDeviceCount);

        if(PrevInterfaceDeviceNode) {
            PrevInterfaceDeviceNode->Next = CurInterfaceDeviceNode->Next;
        } else {
            InterfaceClassList->InterfaceDeviceNode = CurInterfaceDeviceNode->Next;
        }

        MyFree(InterfaceDeviceNode);
        InterfaceClassList->InterfaceDeviceCount--;

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiRemoveDeviceInterface(
    IN     HDEVINFO                  DeviceInfoSet,
    IN OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
/*++

Routine Description:

    This API removes (unregisters) the specified device interface.  It _does not_
    delete the device interface element from the device information set (thus
    enumeration is not affected).  Instead, it marks the device interface element
    as invalid, so that it cannot be used in any subsequent API calls except
    SetupDiDeleteDeviceInterfaceData.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        device interface to be removed.

    DeviceInterfaceData - Specifies the device interface to be removed.  All
        traces of this device will be removed from the registry.

        Upon return, the Flags field of this structure will be updated to reflect
        the new state of this device interface.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    There is no way to unregister a device interface while it is active.  Thus,
    this API will fail with ERROR_DEVICE_INTERFACE_ACTIVE in this case.  If this
    happens, you can do one of the following things in an attempt to remove the
    device interface:

        1.  If there is some defined mechanism of communication to the device
            interface/underlying device instance (e.g., an IOCTL) that causes the
            driver to un-expose the device interface, then this method may be used,
            and _then_ SetupDiRemoveDeviceInterface may be called.

        2.  If there is no mechanism as described in method (1), then the owning
            device instance must be stopped (e.g., via SetupDiChangeState), which
            will cause all device interfaces owned by that device instance to go
            inactive.  After that is done, then SetupDiRemoveDeviceInterface may
            be called.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    PCTSTR DevicePath, MachineName;
    TCHAR InterfaceClassDefault[(2 * MAX_PATH) + 1];  // 2 max-sized regkey names + terminating NULL.
    DWORD DataBufferSize;
    HKEY hKeyInterfaceClass;
    CONFIGRET cr;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the device information element for the specified
        // interface device.
        //
        if(!(DevInfoElem = FindDevInfoElemForInterfaceDevice(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying interface device node.
        //
        InterfaceDeviceNode = (PINTERFACE_DEVICE_NODE)(DeviceInterfaceData->Reserved);

        //
        // OK, now open the interface device's root storage key.
        //
        DevicePath = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                              InterfaceDeviceNode->SymLinkName
                                             );

        cr = CM_Unregister_Device_Interface_Ex(DevicePath, 0,pDeviceInfoSet->hMachine);

        if(cr != CR_SUCCESS) {

            switch(cr) {

                case CR_NO_SUCH_DEVICE_INTERFACE :
                    //
                    // The device interface was deleted after it was enumerated/opened
                    // by this client.  In this case, we'll go ahead and succeed this
                    // call.
                    //
                    break;

                case CR_DEVICE_INTERFACE_ACTIVE :
                    Err = ERROR_DEVICE_INTERFACE_ACTIVE;
                    //
                    // If our SPINT_ACTIVE flag isn't set, then that means that the device
                    // wasn't active the last time we looked.  Update our flag to indicate
                    // the device's new state.
                    //
                    InterfaceDeviceNode->Flags |= SPINT_ACTIVE;
                    goto clean1;

                default :
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
            }
        }

        //
        // The interface device was successfully removed.  Now, mark the interface device
        // node to reflect that it's now invalid.
        //
        InterfaceDeviceNode->Flags |= SPINT_REMOVED;

        //
        // Also, clear the SPINT_ACTIVE flag, in case it's set.  It's possible that we thought
        // the device was active, even though it was deactivated since the last time we looked.
        //
        InterfaceDeviceNode->Flags &= ~SPINT_ACTIVE;


        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // Open this interface class key under the DeviceClasses registry
        // branch.
        //
        hKeyInterfaceClass = SetupDiOpenClassRegKeyEx(&DeviceInterfaceData->InterfaceClassGuid,
                                                      KEY_READ | KEY_WRITE,
                                                      DIOCR_INTERFACE,
                                                      MachineName,
                                                      NULL);
        if(hKeyInterfaceClass == INVALID_HANDLE_VALUE) {
            goto clean1;
        }

        //
        // Check if this interface is specified in the registry as the default
        // device interface.
        //
        DataBufferSize = sizeof(InterfaceClassDefault);
        if(ERROR_SUCCESS == RegQueryValueEx(hKeyInterfaceClass,
                                            pszDefault,
                                            NULL,
                                            NULL,
                                            (PBYTE)InterfaceClassDefault,
                                            &DataBufferSize)) {
            if (lstrcmpi(InterfaceClassDefault, DevicePath) == 0) {
                //
                // Delete the "Default" value under this interface class key.
                //
                if(ERROR_SUCCESS == RegDeleteValue(hKeyInterfaceClass,
                                                   pszDefault)) {
                    //
                    // This interface has been successfully removed as the
                    // "Default" interface for this class.  Clear the
                    // SPINT_DEFAULT flag.
                    //
                    InterfaceDeviceNode->Flags &= ~SPINT_DEFAULT;
                }
            } else {
                //
                // This interface is not listed in the registry as the
                // current default device interface for this class, so clear
                // the SPINT_DEFAULT flag.
                //
                InterfaceDeviceNode->Flags &= ~SPINT_DEFAULT;
            }
        } else {
            //
            // We could not retrieve the "Default" value, but we should still
            // make sure to clear the SPINT_DEFAULT flag on this interface.
            //
            InterfaceDeviceNode->Flags &= ~SPINT_DEFAULT;
        }

        RegCloseKey(hKeyInterfaceClass);

clean1:
        //
        // Finally, updated the flags in the caller-supplied buffer to indicate the new status
        // of this interface device.
        //
        DeviceInterfaceData->Flags = InterfaceDeviceNode->Flags;

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
pSetupDiSetDeviceInfoContext(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Context
    )
/*++

Routine Description:

    This API stores a context value into the specified device information element
    for later retrieval via pSetupDiGetDeviceInfoContext.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element with which the context data is to be
        associated.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure indicating
        which element the context data should be associated with.

    Context - Specifies the data value to be stored for this device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    return pSetupDiGetOrSetDeviceInfoContext(DeviceInfoSet,
                                             DeviceInfoData,
                                             Context,
                                             NULL
                                            );
}


BOOL
pSetupDiGetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PDWORD           Context
    )
/*++

Routine Description:

    This API retrieves a context value from the specified device information element
    (stored there via pSetupDiSetDeviceInfoContext).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element with which the context data is associated.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure indicating
        which element the context data is associated with.

    Context - Supplies the address of a variable that receives the context value
        stored for the device information element in a prior call to
        pSetupDiSetDeviceInfoContext.  If no context data has previously been stored
        for this element, this variable will be filled in with zero upon return.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    //
    // If we let a NULL context pointer go through to the worker routine, it will
    // think this is a 'set' instead of a 'get'.  Make sure that doesn't happen.
    //
    if(!Context) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return pSetupDiGetOrSetDeviceInfoContext(DeviceInfoSet,
                                             DeviceInfoData,
                                             0,               // ignored
                                             Context
                                            );
}


BOOL
pSetupDiGetOrSetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            InContext,
    OUT PDWORD           OutContext      OPTIONAL
    )
/*++

Routine Description:

    This API retrieves or sets a context value from the specified device information
    element (stored there via pSetupDiSetDeviceInfoContext).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element with which the context data is associated.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure indicating
        which element the context data is associated with.

    InContext - Specifies the data value to be stored for this device information element.
        If OutContext is specified, then this is a 'get' instead of a 'set', and
        this parameter is ignored.

    OutContext - Optionally, supplies the address of a variable that receives the
        context value stored for the device information element in a prior call to
        pSetupDiSetDeviceInfoContext.  If no context data has previously been stored
        for this element, this variable will be filled in with zero upon return.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD Err;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR; // assume success.

    try {

        DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                DeviceInfoData,
                                                NULL
                                               );
        if(!DevInfoElem) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(OutContext) {
            //
            // Store the context in the caller-supplied buffer.
            //
            *OutContext = DevInfoElem->Context;
        } else {
            //
            // Set the context to the caller-supplied value.
            //
            DevInfoElem->Context = InContext;
        }

clean0:
        ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\devinstd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinstd.c

Abstract:

    Default install handlers for SetupDiCallClassInstaller DIF_* functions.

Author:

    Lonny McMichael (lonnym) 1-Aug-1995

Revision History:

    Jamie Hunter (jamiehun) 20-January-1998 Added backup functionality in
        _SetupDiInstallDevice - DI_FLAGSEX_BACKUPOLDFILES

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global strings for use inside this file only.
//
CONST TCHAR pszDisplayName[]    = INFSTR_KEY_DISPLAYNAME,
            pszServiceType[]    = INFSTR_KEY_SERVICETYPE,
            pszStartType[]      = INFSTR_KEY_STARTTYPE,
            pszErrorControl[]   = INFSTR_KEY_ERRORCONTROL,
            pszServiceBinary[]  = INFSTR_KEY_SERVICEBINARY,
            pszLoadOrderGroup[] = INFSTR_KEY_LOADORDERGROUP,
            pszDependencies[]   = INFSTR_KEY_DEPENDENCIES,
            pszStartName[]      = INFSTR_KEY_STARTNAME,
            pszSystemRoot[]     = TEXT("%SystemRoot%\\"),
            pszSecurity[]       = INFSTR_KEY_SECURITY,
            pszDescription[]    = INFSTR_KEY_DESCRIPTION;

//
// Define function prototype for legacy INF interpreter supplied
// by setupdll.dll
//
typedef BOOL (WINAPI *LEGACY_INF_INTERP_PROC)(
    IN  HWND   OwnerWindow,
    IN  PCSTR  InfFilename,
    IN  PCSTR  InfSection,
    IN  PCHAR  ExtraVariables,
    OUT PSTR   InfResult,
    IN  DWORD  BufferSize,
    OUT INT   *InterpResult,
    IN  PCSTR  InfSourceDir      OPTIONAL
    );

//
// Define the various copy scenarios that can be returned from GetNewInfName().
//
typedef enum _NEWINF_COPYTYPE {
    NewInfCopyYes,       // new INF placeholder created--need to copy real INF
    NewInfCopyNo,        // no need to copy--INF already present in destination
    NewInfCopyZeroLength // previously-existing zero-length INF match found
} NEWINF_COPYTYPE, *PNEWINF_COPYTYPE;

//
// Define function prototype for legacy INF routine that returns a list
// of all services modified during an INF 'run' via LegacyInfInterpret().
//
typedef DWORD (WINAPI *LEGACY_INF_GETSVCLIST_PROC)(
    IN  LPSTR SvcNameBuffer,
    IN  UINT  SvcNameBufferSize,
    OUT PUINT RequiredSize
    );


//
// Define the legacy INF interpreter exit codes (copied from setup\legacy\dll\_shell.h
//
#define SETUP_ERROR_SUCCESS    0
#define SETUP_ERROR_USERCANCEL 1
#define SETUP_ERROR_GENERAL    2


//
// Define a list node to hold an interface class to be installed.
//
typedef struct _INTERFACE_CLASS_TO_INSTALL {

    struct _INTERFACE_CLASS_TO_INSTALL *Next;

    GUID  InterfaceGuid;
    DWORD Flags;
    TCHAR InstallSection[MAX_SECT_NAME_LEN];

} INTERFACE_CLASS_TO_INSTALL, *PINTERFACE_CLASS_TO_INSTALL;


//
// Define a list node to hold an INF that has been newly-installed during
// SetupDiInstallDevice, hence must be cleaned up if SetupDiInstallDevice
// subsequently encounters a failure.
//
typedef struct _INSTALLED_INF_CLEANUP {
    struct _INSTALLED_INF_CLEANUP *Next;
    TCHAR InfName[MAX_PATH];
} INSTALLED_INF_CLEANUP, *PINSTALLED_INF_CLEANUP;


//
// Private function prototypes
//
BOOL
_SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     BOOL             DoFullInstall
    );

DWORD
InstallHW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  HINF             hDeviceInf,
    IN  PCTSTR           szSectionName,
    OUT PBOOL            DeleteDevKey
    );

BOOL
AssociateDevInstWithDefaultService(
    IN     PDEVINFO_ELEM DevInfoElem,
    OUT    PTSTR         ServiceName,
    IN OUT PDWORD        ServiceNameSize
    );

BOOL
CheckIfDevStarted(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET pDeviceInfoSet
    );

DWORD
pSetupAddService(
    IN  PINFCONTEXT        LineContext,
    OUT PSVCNAME_NODE *    SvcListHead,
    IN  DWORD              Flags,
    IN  DEVINST            DevInst,            OPTIONAL
    OUT PBOOL              NullDriverInstalled,
    IN  PSETUP_LOG_CONTEXT LogContext
    );

DWORD
pSetupDeleteService(
    IN PINFCONTEXT         LineContext,
    IN DWORD               Flags,
    IN PSETUP_LOG_CONTEXT  LogContext
    );

DWORD
DeleteServicesInList(
    IN PSVCNAME_NODE ServicesToDelete,
    IN PSETUP_LOG_CONTEXT  LogContext
    );

BOOL
IsDevRemovedFromAllHwProfiles(
    IN PCTSTR DeviceInstanceId,
    IN HMACHINE hMachine
    );

DWORD
GetDevInstConfigFlags(
    IN DEVINST DevInst,
    IN DWORD   Default,
    IN HMACHINE hMachine
    );

DWORD
pSetupRunLegacyInf(
    IN DEVINST DevInst,
    IN HWND    OwnerWindow,
    IN PCTSTR  InfFileName,
    IN PCTSTR  InfOptionName,
    IN PCTSTR  InfLanguageName,
    IN HINF    InfHandle
    );

PTSTR
pSetupCmdLineAppendString(
    IN     PTSTR  CmdLine,
    IN     PCTSTR Key,
    IN     PCTSTR Value,   OPTIONAL
    IN OUT PUINT  StrLen,
    IN OUT PUINT  BufSize
    );

PTSTR
DoServiceModsForLegacyInf(
    IN PTSTR ServiceList
    );

BOOL
_SetupDiInstallInterfaceDevices(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    );

BOOL
_SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    );

BOOL
RetrieveAllDevNodesSharingDriversWithDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *Drivers,
    OUT PDEVNODE       *DevNodes,
    OUT ULONG          *NumberOfDevNodes,
    IN  HMACHINE       hMachine
    );

VOID
RestartSingleDevice(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    );

VOID
RestartAllDevicesUsingDrivers(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    );

DWORD
GetNewInfName(
    IN     HWND                    Owner,                  OPTIONAL
    IN     PCTSTR                  OemInfName,
    IN     PCTSTR                  OemInfOriginalName,
    IN     PCTSTR                  OemInfCatName,          OPTIONAL
    OUT    PTSTR                   NewInfName,
    IN     DWORD                   NewInfNameSize,
    OUT    PDWORD                  RequiredSize,
    OUT    PNEWINF_COPYTYPE        CopyNeeded,
    IN     BOOL                    ReplaceOnly,
    IN     PCTSTR                  DeviceDesc,             OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,         OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT    PDWORD                  DriverSigningError,     OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin               OPTIONAL
    );

VOID
_WriteVetoLogEntry(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN DWORD              Level,
    IN DWORD              MessageId,
    IN PCTSTR             szDevID,
    IN PCTSTR             szVetoName,
    IN PNP_VETO_TYPE      dwVetoType
    )
{
    static LPCTSTR VetoMap[] = {
        TEXT("PNP_VetoTypeUnknown"),
        TEXT("PNP_VetoLegacyDevice"),
        TEXT("PNP_VetoPendingClose"),
        TEXT("PNP_VetoWindowsApp"),
        TEXT("PNP_VetoWindowsService"),
        TEXT("PNP_VetoOutstandingOpen"),
        TEXT("PNP_VetoDevice"),
        TEXT("PNP_VetoDriver"),
        TEXT("PNP_VetoIllegalDeviceRequest"),
        TEXT("PNP_VetoInsufficientPower"),
        TEXT("PNP_VetoNonDisableable"),
        TEXT("PNP_VetoLegacyDriver"),
        TEXT("PNP_VetoInsufficientRights")
    };
    MYASSERT(dwVetoType < ARRAYSIZE(VetoMap));

    WriteLogEntry(
        LogContext,
        Level,
        MessageId,
        NULL,
        szDevID,
        szVetoName,
        dwVetoType,
        dwVetoType < ARRAYSIZE(VetoMap) ? VetoMap[dwVetoType] : TEXT("????")
        );
}

LPCTSTR
_MapCmProbToString(
    IN DWORD prob
    )
{

#define PROBLEM_MAP_SIZE    0x32
#if PROBLEM_MAP_SIZE != NUM_CM_PROB
#error Add new problem code to ProbMap and update PROBLEM_MAP_SIZE.
#endif

    static LPCTSTR ProbMap [PROBLEM_MAP_SIZE] = {
        NULL,
        TEXT("CM_PROB_NOT_CONFIGURED"),
        TEXT("CM_PROB_DEVLOADER_FAILED"),
        TEXT("CM_PROB_OUT_OF_MEMORY"),
        TEXT("CM_PROB_ENTRY_IS_WRONG_TYPE"),
        TEXT("CM_PROB_LACKED_ARBITRATOR"),
        TEXT("CM_PROB_BOOT_CONFIG_CONFLICT"),
        TEXT("CM_PROB_FAILED_FILTER"),
        TEXT("CM_PROB_DEVLOADER_NOT_FOUND"),
        TEXT("CM_PROB_INVALID_DATA"),
        TEXT("CM_PROB_FAILED_START"),
        TEXT("CM_PROB_LIAR"),
        TEXT("CM_PROB_NORMAL_CONFLICT"),
        TEXT("CM_PROB_NOT_VERIFIED"),
        TEXT("CM_PROB_NEED_RESTART"),
        TEXT("CM_PROB_REENUMERATION"),
        TEXT("CM_PROB_PARTIAL_LOG_CONF"),
        TEXT("CM_PROB_UNKNOWN_RESOURCE"),
        TEXT("CM_PROB_REINSTALL"),
        TEXT("CM_PROB_REGISTRY"),
        NULL,
        TEXT("CM_PROB_WILL_BE_REMOVED"),
        TEXT("CM_PROB_DISABLED"),
        TEXT("CM_PROB_DEVLOADER_NOT_READY"),
        TEXT("CM_PROB_DEVICE_NOT_THERE"),
        TEXT("CM_PROB_MOVED"),
        TEXT("CM_PROB_TOO_EARLY"),
        TEXT("CM_PROB_NO_VALID_LOG_CONF"),
        TEXT("CM_PROB_FAILED_INSTALL"),
        TEXT("CM_PROB_HARDWARE_DISABLED"),
        TEXT("CM_PROB_CANT_SHARE_IRQ"),
        TEXT("CM_PROB_FAILED_ADD"),
        TEXT("CM_PROB_DISABLED_SERVICE"),
        TEXT("CM_PROB_TRANSLATION_FAILED"),
        TEXT("CM_PROB_NO_SOFTCONFIG"),
        TEXT("CM_PROB_BIOS_TABLE"),
        TEXT("CM_PROB_IRQ_TRANSLATION_FAILED"),
        TEXT("CM_PROB_FAILED_DRIVER_ENTRY"),
        TEXT("CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD"),
        TEXT("CM_PROB_DRIVER_FAILED_LOAD"),
        TEXT("CM_PROB_DRIVER_SERVICE_KEY_INVALID"),
        TEXT("CM_PROB_LEGACY_SERVICE_NO_DEVICES"),
        TEXT("CM_PROB_DUPLICATE_DEVICE"),
        TEXT("CM_PROB_FAILED_POST_START"),
        TEXT("CM_PROB_HALTED"),
        TEXT("CM_PROB_PHANTOM"),
        TEXT("CM_PROB_SYSTEM_SHUTDOWN"),
        TEXT("CM_PROB_HELD_FOR_EJECT"),
        TEXT("CM_PROB_DRIVER_BLOCKED"),
        TEXT("CM_PROB_REGISTRY_TOO_LARGE")
    };
    LPCTSTR ProbText = NULL;

    MYASSERT(ARRAYSIZE(ProbMap)==NUM_CM_PROB);
    MYASSERT(prob<NUM_CM_PROB);

    if(prob < ARRAYSIZE(ProbMap)) {
        ProbText = ProbMap[prob];
    }
    if(!ProbText) {
        ProbText = TEXT("????");
    }
    return ProbText;
}

LPCTSTR
_MapCmRetToString(
    IN DWORD cr
    )
{
    LPCTSTR RetText = NULL;
    static LPCTSTR RetMap [] = {
        TEXT("CR_SUCCESS"),
        TEXT("CR_DEFAULT"),
        TEXT("CR_OUT_OF_MEMORY"),
        TEXT("CR_INVALID_POINTER"),
        TEXT("CR_INVALID_FLAG"),
        TEXT("CR_INVALID_DEVNODE"),
        TEXT("CR_INVALID_RES_DES"),
        TEXT("CR_INVALID_LOG_CONF"),
        TEXT("CR_INVALID_ARBITRATOR"),
        TEXT("CR_INVALID_NODELIST"),
        TEXT("CR_DEVNODE_HAS_REQS"),
        TEXT("CR_INVALID_RESOURCEID"),
        TEXT("CR_DLVXD_NOT_FOUND"),
        TEXT("CR_NO_SUCH_DEVNODE"),
        TEXT("CR_NO_MORE_LOG_CONF"),
        TEXT("CR_NO_MORE_RES_DES"),
        TEXT("CR_ALREADY_SUCH_DEVNODE"),
        TEXT("CR_INVALID_RANGE_LIST"),
        TEXT("CR_INVALID_RANGE"),
        TEXT("CR_FAILURE"),
        TEXT("CR_NO_SUCH_LOGICAL_DEV"),
        TEXT("CR_CREATE_BLOCKED"),
        TEXT("CR_NOT_SYSTEM_VM"),
        TEXT("CR_REMOVE_VETOED"),
        TEXT("CR_APM_VETOED"),
        TEXT("CR_INVALID_LOAD_TYPE"),
        TEXT("CR_BUFFER_SMALL"),
        TEXT("CR_NO_ARBITRATOR"),
        TEXT("CR_NO_REGISTRY_HANDLE"),
        TEXT("CR_REGISTRY_ERROR"),
        TEXT("CR_INVALID_DEVICE_ID"),
        TEXT("CR_INVALID_DATA"),
        TEXT("CR_INVALID_API"),
        TEXT("CR_DEVLOADER_NOT_READY"),
        TEXT("CR_NEED_RESTART"),
        TEXT("CR_NO_MORE_HW_PROFILES"),
        TEXT("CR_DEVICE_NOT_THERE"),
        TEXT("CR_NO_SUCH_VALUE"),
        TEXT("CR_WRONG_TYPE"),
        TEXT("CR_INVALID_PRIORITY"),
        TEXT("CR_NOT_DISABLEABLE"),
        TEXT("CR_FREE_RESOURCES"),
        TEXT("CR_QUERY_VETOED"),
        TEXT("CR_CANT_SHARE_IRQ"),
        TEXT("CR_NO_DEPENDENT"),
        TEXT("CR_SAME_RESOURCES"),
        TEXT("CR_NO_SUCH_REGISTRY_KEY"),
        TEXT("CR_INVALID_MACHINENAME"),
        TEXT("CR_REMOTE_COMM_FAILURE"),
        TEXT("CR_MACHINE_UNAVAILABLE"),
        TEXT("CR_NO_CM_SERVICES"),
        TEXT("CR_ACCESS_DENIED"),
        TEXT("CR_CALL_NOT_IMPLEMENTED"),
        TEXT("CR_INVALID_PROPERTY"),
        TEXT("CR_DEVICE_INTERFACE_ACTIVE"),
        TEXT("CR_NO_SUCH_DEVICE_INTERFACE"),
        TEXT("CR_INVALID_REFERENCE_STRING"),
        TEXT("CR_INVALID_CONFLICT_LIST"),
        TEXT("CR_INVALID_INDEX"),
        TEXT("CR_INVALID_STRUCTURE_SIZE")
    };
    MYASSERT(ARRAYSIZE(RetMap)==NUM_CR_RESULTS);
    MYASSERT(cr<NUM_CR_RESULTS);

    if(cr < ARRAYSIZE(RetMap)) {
        RetText = RetMap[cr];
    }
    if(!RetText) {
        RetText = TEXT("????");
    }
    return RetText;
}

BOOL
WINAPI
SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_INSTALLDEVICE

    This routine will install a device by performing a SetupInstallFromInfSection
    for the install section of the selected driver for the specified device
    information element.  The device will then be started (if possible).

    NOTE:  This API actually supports an OS/architecture-specific extension that
    may be used to specify multiple installation behaviors for a single device,
    based on the environment we're running under.  The algorithm is as follows:

    We take the install section name, as specified in the driver node (for this
    example, it's "InstallSec"), and attempt to find one of the following INF
    sections (searched for in the order specified):

    If we're running under Windows 95:

        1. InstallSec.Win
        2. InstallSec

    If we're running under Windows NT:

        1. InstallSec.NT<platform>  (platform is "x86", "MIPS", "Alpha", or "PPC")
        2. InstallSec.NT
        3. InstallSec

    The first section that we find is the one we'll use to do the installation.  This
    section name is also what we'll base our ".Hw" and ".Services" installation against.
    (E.g., if we match on "InstallSec.NTAlpha", then the service install section must be
    named "InstallSec.NTAlpha.Services".)

    The original install section name (i.e., the one specified in the driver node), will
    be written as-is to the driver key's "InfSection" value entry, just as it was in the
    past.  The extension that we use (if any) will be stored in the device's driver key
    as the REG_SZ value, "InfSectionExt".  E.g.,

        InfSection    : REG_SZ : "InstallSec"
        InfSectionExt : REG_SZ : ".NTMIPS"

    If we successfully install the device, we'll kick off RunOnce.  NOTE: We
    must do this _regardless_ of whether or not the device was dynamically
    brought on-line with its newly-installed driver/settings.  This is because,
    for server-side device installations, the RunOnce processing is done by the
    user-mode PnP manager.  We can't put this off until 'later'.  Also, since
    anyone can kick off a RunOnce at any time, you really would have no
    assurance that the RunOnce would be postponed until after reboot anyway.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        a driver is to be installed.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If no driver is selected for the specified device information element, then a
    NULL driver will be installed.

    Upon return, the install parameters Flags will indicate whether the system
    needs to be rebooted or restarted in order for the device to be started.

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    return _SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData, TRUE);
}


BOOL
_SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     BOOL             DoFullInstall
    )
/*++

Routine Description:

    Worker routine for both SetupDiInstallDevice and SetupDiInstallDriverFiles.

    See the description of SetupDiInstallDevice for more information.

    (jamiehun) If backups are enabled (DI_FLAGSEX_BACKUPOLDFILES or DI_FLAGSEX_BACKUPONREPLACE)
    then old inf file is backed up.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        a driver is to be installed.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

    DoFullInstall - If TRUE, then an entire device installation is performed,
        otherwise, only the driver files are copied.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, ScanQueueResult;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PTSTR szInfFileName, szInfSectionName;
    PTSTR szInfSectionExt = NULL;
    TCHAR InfSectionWithExt[MAX_PATH];
    DWORD InfSectionWithExtLength;
    HINF hDeviceInf = INVALID_HANDLE_VALUE;
    HKEY hkDrv = INVALID_HANDLE_VALUE;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth;
    HSPFILEQ UserFileQ;
    INFCONTEXT InfContext;
    DWORD dwConfigFlags=0;
    ULONG cbData;
    PTSTR DevIdBuffer = NULL;
    PCTSTR TempString;
    ULONG ulStatus, ulProblem;
    DEVINST dnReenum = 0;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;
    BOOL InfFromOemPath = FALSE;
    BOOL DeleteDevKey = FALSE;
    PSVCNAME_NODE DeleteServiceList = NULL;
    BOOL FreeMsgHandlerContext = FALSE;
    BOOL CloseUserFileQ = FALSE;
    HWND hwndParent;
    BOOL DoFileCopying;
    DWORD DevInstCapabilities;
    TCHAR DeviceFullID[MAX_DEVICE_ID_LEN];
    DWORD BackupFlags = 0;
    BOOL NullDriverInstall = FALSE;
    PINSTALLED_INF_CLEANUP InfsToCleanUp = NULL;
    INT FileQueueNeedsReboot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_deviceID = 0;
    DWORD slot_section = 0;
    DWORD FileQueueFlags;
    BOOL NoProgressUI;
    TCHAR className[MAX_CLASS_NAME_LEN];
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;
#ifndef UNICODE
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
#endif

#if MAX_SECT_NAME_LEN > MAX_PATH
#error MAX_SECT_NAME_LEN is larger than MAX_PATH--fix InfSectionWithExt!
#endif

    ASSERT_HEAP_IS_VALID();

    //
    // We can only install a device if a device was specified.
    //
    if(!DeviceInfoData) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Make sure we're local
    //
    if(NULL != pDeviceInfoSet->hMachine ) {   //&& !g_ReadOnlyRemote ??
        //
        // hDevInfo may be valid, but it's not for this machine
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't install a non-native driver
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // Make sure we only use the devinfo element's window if it's valid.
        //
        if(hwndParent = DevInfoElem->InstallParamBlock.hwndParent) {
           if(!IsWindow(hwndParent)) {
                hwndParent = NULL;
           }
        }

        //
        // set the local log context before it gets used.
        //
        LogContext = DevInfoElem->InstallParamBlock.LogContext;

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_INSTALL_TIME,
            NULL);       // text message

        //
        // obtain the full id of the device we are (re)installing
        //
        if( CM_Get_Device_ID(DevInfoElem->DevInst,
                         DeviceFullID,
                         SIZECHARS(DeviceFullID),
                         0
                        ) != CR_SUCCESS ) {
                Err = ERROR_INVALID_HANDLE;
                goto clean0;
        }

        //
        // If we are installing a driver, then the selected driver pointer will be
        // non-NULL, otherwise we are actually removing the driver (i.e., installing the
        // NULL driver)
        //
        if(DevInfoElem->SelectedDriver) {
            if(DoFullInstall) {
                if(slot_deviceID == 0) {
                    slot_deviceID = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE);
                }
                WriteLogEntry(
                    LogContext,
                    slot_deviceID,
                    MSG_LOG_DO_FULL_INSTALL,
                    NULL,       // text message
                    DeviceFullID);
                //
                // Create the Driver Reg Key.
                //
                if((hkDrv = SetupDiCreateDevRegKey(DeviceInfoSet,
                                                   DeviceInfoData,
                                                   DICS_FLAG_GLOBAL,
                                                   0,
                                                   DIREG_DRV,
                                                   NULL,
                                                   NULL)) == INVALID_HANDLE_VALUE) {
                    Err = GetLastError();
                    goto clean0;
                }

            } else {
                DWORD slot = slot_deviceID;
                if(slot_deviceID == 0) {
                    if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                        slot = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE,TRUE); // may be being copied for someone else - keep this around
                    } else {
                        slot_deviceID = slot = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE); // we do copy ourselves
                    }
                }
                WriteLogEntry(
                    LogContext,
                    slot,
                    MSG_LOG_DO_COPY_INSTALL,
                    NULL,       // text message
                    DeviceFullID);
                //
                // Make sure we aren't trying to do a copy-only install on a legacy
                // driver--we don't know how to do that!
                //
                if(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF) {
                    Err = ERROR_WRONG_INF_STYLE;
                    goto clean0;
                }
            }

            szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                     DevInfoElem->SelectedDriver->InfFileName
                                                    );

            szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                        DevInfoElem->SelectedDriver->InfSectionName
                                                       );

            if((hDeviceInf = SetupOpenInfFile(szInfFileName,
                                              NULL,
                                              ((DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)
                                               ? INF_STYLE_OLDNT
                                               : INF_STYLE_WIN4),
                                              NULL)) == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            //
            // Give the INF whatever the local log context is.
            //
            InheritLogContext(LogContext, &((PLOADED_INF) hDeviceInf)->LogContext);
            SetLogSectionName(LogContext, TEXT("Driver Install"));

            //
            // Figure out whether we need to copy files. (Ignore the DI_NOFILECOPY flag if we're
            // doing a copy-only installation--that's what setupx does.)
            //
            DoFileCopying = (!(DevInfoElem->InstallParamBlock.Flags & DI_NOFILECOPY) || !DoFullInstall);

            //
            // Unless we happen to be installing from a legacy INF, we want to find out the 'real'
            // install section we should be using (i.e., the potentially OS/architecture-specific
            // one.
            //
            if(!(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)) {

                if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                                     szInfSectionName,
                                                     InfSectionWithExt,
                                                     SIZECHARS(InfSectionWithExt),
                                                     &InfSectionWithExtLength,
                                                     &szInfSectionExt
                                                     )) {
                    Err = GetLastError();
                    goto clean0;
                }

                //
                // Append the layout INF, if necessary.
                //
                if(DoFileCopying) {
                    SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
                }

                //
                // Append-load any included INFs specified in an "include=" line in our
                // install section.
                //
                AppendLoadIncludedInfs(hDeviceInf, szInfFileName, InfSectionWithExt, DoFileCopying);
            }

            ASSERT_HEAP_IS_VALID();

            //
            // Now perform file installation activities...
            //
            if(!DoFileCopying || (DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)) {
                //
                // We're not supposed to do any file copying, or we're installing
                // from a legacy INF (where file copying is handled differently).
                // In either case, we still need to have the INF copied to the
                // INF directory (along with its associated catalog, if any).
                //
                if(pSetupInfIsFromOemLocation(szInfFileName, TRUE)) {

                    TCHAR CatalogName[MAX_PATH];
                    TCHAR OriginalInfName[MAX_PATH];
                    TCHAR CatalogFilenameOnSystem[MAX_PATH];
                    BOOL DifferentOriginalName, UseOriginalInfName;
                    DWORD PolicyToUse;

                    //
                    // Retrieve (potentially decorated) CatalogFile= entry, if
                    // present, from [version] section.
                    //
                    // Note: We're safe in casting our INF handle straight to a
                    // PLOADED_INF (without even locking it), since this INF
                    // handle will never be seen outside of this routine.
                    //
                    Err = pGetInfOriginalNameAndCatalogFile(
                              (PLOADED_INF)hDeviceInf,
                              NULL,
                              &DifferentOriginalName,
                              OriginalInfName,
                              SIZECHARS(OriginalInfName),
                              CatalogName,
                              SIZECHARS(CatalogName),
                              NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                             );

                    if(Err == NO_ERROR) {
                        if(*CatalogName) {
                            TempString = CatalogName;
                        } else {
                            TempString = NULL;
                        }
                    } else {
                        goto clean0;
                    }

                    PolicyToUse = GetCodeSigningPolicyForInf(LogContext,
                                                             hDeviceInf,
                                                             &ValidationPlatform,
                                                             &UseOriginalInfName
                                                            );

                    //
                    // An exception INF can't be used in a device installation!
                    //
                    if(UseOriginalInfName) {
                        Err = ERROR_INVALID_CLASS;
                        goto clean0;
                    }

                    //
                    // If this is a legacy INF, then we _do_ want to copy it if
                    // it doesn't already exist ('cause this is the only chance
                    // we get!).  However, if this is not a legacy INF, that
                    // means we aren't supposed to be copying files, hence we
                    // want to fail if the INF doesn't already exist in the
                    // Inf directory.
                    //
                    if(_SetupCopyOEMInf(szInfFileName,
                                        NULL, // default source location to where INF presently is
                                        (DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                            ? SPOST_URL : SPOST_PATH,
                                        ((DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)
                                            ? SP_COPY_NOOVERWRITE
                                            : SP_COPY_REPLACEONLY),
                                        szNewName,
                                        SIZECHARS(szNewName),
                                        NULL,
                                        NULL,
                                        (DifferentOriginalName ? OriginalInfName
                                                               : pSetupGetFileTitle(szInfFileName)),
                                        TempString,
                                        hwndParent,
                                        pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                 DevInfoElem->SelectedDriver->DrvDescription),
                                        PolicyToUse,
                                        SCOI_TRY_UPDATE_PNF // not fatal if existing PNF locked
                                        | ((DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)
                                            ? 0 : SCOI_NO_UI_ON_SIGFAIL),
                                        NULL,
                                        ValidationPlatform,
                                        NULL,
                                        CatalogFilenameOnSystem,
                                        LogContext,
                                        NULL)) {
                        //
                        // If this was a legacy INF, we successfully copied this
                        // INF to a new filename in the INF directory--set a
                        // flag that to let us know if we need to clean it up
                        // later in case we encounter an error.
                        //
                        if(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF) {
                            OemInfFileToCopy = TRUE;
                        }

                    } else {
                        Err = GetLastError();
                        if(Err == ERROR_FILE_EXISTS) {
                            //
                            // We couldn't copy the legacy INF because it
                            // already exists in the %windir%\Inf directory.
                            // Since it probably has better source path
                            // information than we do, it's best to leave the
                            // PNF alone.  We also need this information about
                            // the INF's existence to that we know whether or
                            // not to blow away the INF later in case we hit a
                            // failure.
                            //
                            MYASSERT(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF);
                            Err = NO_ERROR;
                        } else {
                            //
                            // SetupCopyOEMInf failed for some reason other than
                            // file-already-exists (most likely, because we were
                            // dealing with a new-style device INF that didn't
                            // already exist in the Inf directory).  Bail now.
                            //
                            goto clean0;
                        }
                    }
                }

                if(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF) {

                    PTSTR szLegacyInfLangName;

                    //
                    // We're doing a script-driven install using a legacy INF.
                    // Since we can't control what takes place when this INF
                    // gets run, we can't split this out into various phases
                    // (file copying, registry modification, etc.).  So we
                    // consider the legacy INF installation action to be a file
                    // copy action.  No other actions are performed with this
                    // INF throughout the rest of the installation.
                    //
                    szLegacyInfLangName = pStringTableStringFromId(
                                              pDeviceInfoSet->StringTable,
                                              DevInfoElem->SelectedDriver->LegacyInfLang
                                             );

                    Err = pSetupRunLegacyInf(DevInfoElem->DevInst,
                                             hwndParent,
                                             szInfFileName,
                                             szInfSectionName,
                                             szLegacyInfLangName,
                                             hDeviceInf
                                            );
                    if(Err != NO_ERROR) {
                        goto clean0;
                    }
                }

            } else {
                //
                // If the DI_NOVCP flag is set, then just queue up the file
                // copy/rename/delete operations.  Otherwise, perform the
                // actions.
                //
                if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                    //
                    // We must have a user-supplied file queue.
                    //
                    MYASSERT(DevInfoElem->InstallParamBlock.UserFileQ);
                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;
                } else {
                    //
                    // Since we may need to check the queued files to determine
                    // whether file copy is necessary, we have to open our own
                    // queue, and commit it ourselves.
                    //
                    if((UserFileQ = SetupOpenFileQueue()) != INVALID_HANDLE_VALUE) {
                        CloseUserFileQ = TRUE;
                    } else {
                        //
                        // SetupOpenFileQueue sets actual error
                        //
                        Err = GetLastError();
                        goto clean0;
                    }
                }
                //
                // Maybe replace the file queue's log context with the Inf's
                //
                if (LogContext) {
                    InheritLogContext(LogContext,
                        &((PSP_FILE_QUEUE) UserFileQ)->LogContext);
                }

                if(slot_section == 0) {
                    //
                    // we haven't done anything about logging section yet...
                    //
                    slot_section = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE,FALSE);
                    //
                    // Say what section is about to be installed.
                    //
                    WriteLogEntry(LogContext,
                        slot_section,
                        MSG_LOG_INSTALLING_SECTION_FROM,
                        NULL,
                        InfSectionWithExt,
                        szInfFileName);
                }

                //
                // DI_FLAGSEX_PREINSTALLBACKUP has precedence over DI_FLAGSEX_BACKUPONREPLACE
                //
                if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_PREINSTALLBACKUP) {
                    BackupFlags |= SP_BKFLG_PREBACKUP | SP_BKFLG_CALLBACK;
                } else if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_BACKUPONREPLACE) {
                    BackupFlags |= SP_BKFLG_LATEBACKUP | SP_BKFLG_CALLBACK;
                }

                if(BackupFlags != 0) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_PREP_BACKUP_TIME,
                        NULL);       // text message

                    pSetupGetBackupQueue(DeviceFullID, UserFileQ, BackupFlags);
                    //
                    // We don't care about errors here
                    //
                }

                ASSERT_HEAP_IS_VALID();

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_INSTALL_FROM_INF_TIME,
                    NULL);       // text message

                Err = InstallFromInfSectionAndNeededSections(NULL,
                                                             hDeviceInf,
                                                             InfSectionWithExt,
                                                             SPINST_FILES,
                                                             NULL,
                                                             NULL,
                                                             SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                                                 ((DevInfoElem->InstallParamBlock.Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                                             NULL,
                                                             NULL,
                                                             INVALID_HANDLE_VALUE,
                                                             NULL,
                                                             UserFileQ
                                                            );

                //
                // If we're not doing a full install (i.e., file copy-only), then we also want to
                // queue up any file operations for co-installer registration and device interface
                // installation.
                //
                if(!DoFullInstall && (Err == NO_ERROR)) {

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_CO_INSTALLER_COPY_TIME,
                        NULL);       // text message

                    if(!_SetupDiRegisterCoDeviceInstallers(DeviceInfoSet, DeviceInfoData, FALSE, hDeviceInf, UserFileQ) ||
                       !_SetupDiInstallInterfaceDevices(DeviceInfoSet, DeviceInfoData, FALSE, hDeviceInf, UserFileQ)) {

                        Err = GetLastError();
                    }
                }

                //
                // Mark the queue as a device install queue (and make sure
                // there's a catalog node representing our device INF in the
                // queue).
                //
                Err = MarkQueueForDeviceInstall(UserFileQ,
                                                hDeviceInf,
                                                pStringTableStringFromId(
                                                    pDeviceInfoSet->StringTable,
                                                    DevInfoElem->SelectedDriver->DrvDescription)
                                               );

                if(CloseUserFileQ) {

                    if(Err == NO_ERROR) {
                        //
                        // If the parameter block contains an install message handler, then use it,
                        // otherwise, initialize our default one.
                        //
                        if(DevInfoElem->InstallParamBlock.InstallMsgHandler) {
                            MsgHandler = DevInfoElem->InstallParamBlock.InstallMsgHandler;
                            MsgHandlerContext = DevInfoElem->InstallParamBlock.InstallMsgHandlerContext;
                            MsgHandlerIsNativeCharWidth = DevInfoElem->InstallParamBlock.InstallMsgHandlerIsNativeCharWidth;
                        } else {

                            NoProgressUI = (GuiSetupInProgress || (DevInfoElem->InstallParamBlock.Flags & DI_QUIETINSTALL));

                            MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                    hwndParent,
                                                    (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                                    0,
                                                    0,
                                                    NULL
                                                   );

                            if(MsgHandlerContext) {
                                FreeMsgHandlerContext = TRUE;
                                MsgHandler = SetupDefaultQueueCallback;
                                MsgHandlerIsNativeCharWidth = TRUE;
                            } else {
                                Err = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }

                        //
                        // Call _SetupVerifyQueuedCatalogs separately (i.e.,
                        // don't let it happen automatically as a result of
                        // scanning/committing the queue that happens below).
                        // We do this beforehand so that we know what unique
                        // name was generated when an OEM INF was installed into
                        // %windir%\Inf (in case we need to delete the
                        // INF/PNF/CAT files later if we encounter an error).
                        //
                        if(Err == NO_ERROR) {
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_BEGIN_VERIFY_CAT_TIME,
                                NULL);       // text message

                            Err = _SetupVerifyQueuedCatalogs(
                                      hwndParent,
                                      UserFileQ,
                                      (VERCAT_INSTALL_INF_AND_CAT |
                                       ((DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER) ? VERCAT_PRIMARY_DEVICE_INF_FROM_INET : 0)),
                                      szNewName,
                                      &OemInfFileToCopy
                                     );

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_END_VERIFY_CAT_TIME,
                                NULL);       // text message
                        }

                        ASSERT_HEAP_IS_VALID();

                        if (Err == NO_ERROR) {

                            //
                            // We successfully queued up the file operations and
                            // we have a message handler to use--now we need to
                            // commit the queue.  First off, though, we should
                            // check to see if the files are already there.
                            //
                            // ScanQueueResult can have 1 of 3 values:
                            //
                            // 0: Some files were missing or not valid--must
                            //    commit queue.
                            //
                            // 1: All files to be copied are already present and
                            //    valid, and the queue is empty--skip committing
                            //    queue.
                            //
                            // 2: All files to be copied are present and valid,
                            //    but del/ren/backup queues not empty--must
                            //    commit queue. The copy queue will have been
                            //    emptied, so only del/ren/backup functions will
                            //    be performed.
                            //
                            // (jamiehun) If DI_FLAGSEX_PREINSTALLBACKUP is
                            // specified and there are items to be backed up, it
                            // is covered in (2) the inf file will have already
                            // been backed up
                            //
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_BEGIN_PRESCAN_TIME,
                                NULL);       // text message

                            if(!SetupScanFileQueue(UserFileQ,
                                                   SPQ_SCAN_FILE_VALIDITY |
                                                   SPQ_SCAN_PRUNE_COPY_QUEUE,
                                                   hwndParent,
                                                   NULL,
                                                   NULL,
                                                   &ScanQueueResult)) {
                                //
                                // SetupScanFileQueue should really never
                                // fail when you don't ask it to call a
                                // callback routine, but if it does, just
                                // go ahead and commit the queue.
                                //
                                ScanQueueResult = 0;
                            }

                            if(ScanQueueResult != 1) {
                                //
                                // Copy enqueued files.
                                //
                                WriteLogEntry(
                                    LogContext,
                                    DRIVER_LOG_TIME,
                                    MSG_LOG_BEGIN_COMMIT_TIME,
                                    NULL);       // text message

                                if(_SetupCommitFileQueue(hwndParent,
                                                         UserFileQ,
                                                         MsgHandler,
                                                         MsgHandlerContext,
                                                         MsgHandlerIsNativeCharWidth
                                                         )) {
                                    //
                                    // Check to see whether a reboot is required
                                    // as a result of committing the queue (i.e.,
                                    // because files were in use, or the INF
                                    // requested a reboot).
                                    //
                                    FileQueueNeedsReboot = SetupPromptReboot(UserFileQ, NULL, TRUE);
                                    //
                                    // This should never fail...
                                    //
                                    MYASSERT(FileQueueNeedsReboot != -1);

                                    if(FileQueueNeedsReboot) {
                                        SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet, MSG_LOG_REBOOT_REASON_INUSE);
                                    }

                                } else {
                                    Err = GetLastError();
                                }
                            }

                            //
                            // If no files were modified as a result of commiting
                            // the file queue, then set the DI_FLAGSEX_RESTART_DEVICE_ONLY
                            // flag so that we only restart this one device, as opposed
                            // to restarting this device and all other device that
                            // are sharing a driver or filter with this device.
                            //
                            if (SetupGetFileQueueFlags(UserFileQ, &FileQueueFlags) &&
                                !(FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {

                                DevInfoElem->InstallParamBlock.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
                            }

                            //
                            // Terminate the default queue callback, if it was created.
                            //
                            if(FreeMsgHandlerContext) {
                                SetupTermDefaultQueueCallback(MsgHandlerContext);
                                FreeMsgHandlerContext = FALSE;
                            }
                        }
                    }

                    //
                    // Close our file queue handle.
                    //
                    SetupCloseFileQueue(UserFileQ);
                    CloseUserFileQ = FALSE;
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }
            }

            //
            // If the copy succeeded (or in setup's case was queued), then
            // it's time to update the registry and ini files.
            //
            if(Err == NO_ERROR) {
                //
                // We've got some registry modifications to do, but we don't want to
                // do them if this is a copy-only installation.
                //
                if(DoFullInstall) {
                    //
                    // Do every thing left over (but only if we're not installing from a
                    // legacy INF).
                    //
                    if(!(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)) {
                        //
                        // Skip installation of basic log configs if this is an enumerated device.
                        //
                        if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) != CR_SUCCESS) ||
                           (ulStatus & DN_ROOT_ENUMERATED)) {

                            LOG_CONF LogConf;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_BEGIN_WRITE_BASIC_CFGS_TIME,
                                NULL);       // text message

                            //
                            // Clean out all existing BASIC_LOG_CONF LogConfigs before writing out new ones from
                            // the INF.
                            //
                            while(CM_Get_First_Log_Conf_Ex(&LogConf, DevInfoElem->DevInst, BASIC_LOG_CONF,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                                CM_Free_Log_Conf(LogConf, 0);
                                CM_Free_Log_Conf_Handle(LogConf);
                            }

                            //
                            // Now write out the new basic log configs.
                            //
                            Err = InstallFromInfSectionAndNeededSections(NULL,
                                                                         hDeviceInf,
                                                                         InfSectionWithExt,
                                                                         SPINST_LOGCONFIG,
                                                                         NULL,
                                                                         NULL,
                                                                         0,
                                                                         NULL,
                                                                         NULL,
                                                                         DeviceInfoSet,
                                                                         DeviceInfoData,
                                                                         NULL
                                                                        );

                        } else {
                            //
                            // For non-root-enumerated devices, check to see if there's an [<InstallSec>.LogConfigOverride]
                            // section, and if so, run it.
                            //
                            CopyMemory(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                       pszLogConfigOverrideSectionSuffix,
                                       sizeof(pszLogConfigOverrideSectionSuffix)
                                      );

                            if(SetupFindFirstLine(hDeviceInf, InfSectionWithExt, NULL, &InfContext)) {

                                LOG_CONF LogConf;

                                WriteLogEntry(
                                    LogContext,
                                    DRIVER_LOG_TIME,
                                    MSG_LOG_BEGIN_WRITE_OVERRIDE_CFGS_TIME,
                                    NULL);       // text message

                                //
                                // Clean out all existing OVERRIDE_LOG_CONF LogConfigs before writing out new ones from
                                // the INF.
                                //
                                while(CM_Get_First_Log_Conf_Ex(&LogConf, DevInfoElem->DevInst,
                                                               OVERRIDE_LOG_CONF,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                                    CM_Free_Log_Conf(LogConf, 0);
                                    CM_Free_Log_Conf_Handle(LogConf);
                                }

                                //
                                // Now write out the new override log configs.
                                //
                                Err = InstallFromInfSectionAndNeededSections(NULL,
                                                                             hDeviceInf,
                                                                             InfSectionWithExt,
                                                                             SPINST_LOGCONFIG | SPINST_LOGCONFIGS_ARE_OVERRIDES,
                                                                             NULL,
                                                                             NULL,
                                                                             0,
                                                                             NULL,
                                                                             NULL,
                                                                             DeviceInfoSet,
                                                                             DeviceInfoData,
                                                                             NULL
                                                                            );
                            }

                            //
                            // Make sure we strip off the ".LogConfigOverride" we added above.
                            //
                            InfSectionWithExt[InfSectionWithExtLength - 1] = TEXT('\0');
                        }

                        if((Err == NO_ERROR) && !(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NO_DRVREG_MODIFY)) {
                            //
                            // (Don't pass devinfo set and element here, because we're writing
                            // to the _driver_ key, not the _device_ key.)
                            //
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_TIME,
                                MSG_LOG_BEGIN_INSTALL_REG_TIME,
                                NULL);       // text message

                            Err = InstallFromInfSectionAndNeededSections(NULL,
                                                                         hDeviceInf,
                                                                         InfSectionWithExt,
                                                                         SPINST_INIFILES
                                                                         | SPINST_REGISTRY
                                                                         | SPINST_INI2REG
                                                                         | SPINST_BITREG
                                                                         | SPINST_REGSVR
                                                                         | SPINST_UNREGSVR
                                                                         | SPINST_PROFILEITEMS,
                                                                         hkDrv,
                                                                         NULL,
                                                                         0,
                                                                         NULL,
                                                                         NULL,
                                                                         INVALID_HANDLE_VALUE,
                                                                         NULL,
                                                                         NULL
                                                                        );
                            if(Err == NO_ERROR) {
                                //
                                // Install extra HardWare registry section (if any).
                                //
                                Err = InstallHW(DeviceInfoSet,
                                                DeviceInfoData,
                                                hDeviceInf,
                                                InfSectionWithExt,
                                                &DeleteDevKey
                                               );
                            }
                        }

                        //
                        //  Set appropriate flags if we need to reboot or restart after
                        //  this installation.
                        //
                        if(SetupFindFirstLine(hDeviceInf, InfSectionWithExt, pszReboot, &InfContext)) {
                            SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,pDeviceInfoSet,
                                                                 MSG_LOG_REBOOT_REASON_KEY,
                                                                 (ULONG_PTR)pszReboot,
                                                                 (ULONG_PTR)InfSectionWithExt);
                        } else if(SetupFindFirstLine(hDeviceInf, InfSectionWithExt, pszRestart, &InfContext)) {
                            //
                            // NOTE: This behavior is taken from setupx.  In both "Reboot"
                            // and "Restart" cases, it sets the DI_NEEDREBOOT flag.
                            //
                            SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,pDeviceInfoSet,
                                                                 MSG_LOG_REBOOT_REASON_KEY,
                                                                 (ULONG_PTR)pszRestart,
                                                                 (ULONG_PTR)InfSectionWithExt);
                        }
                    }

                    //
                    // Set the value to write for the config flags, only if there
                    // are no config flags yet.  If they exist, i.e., we are updating
                    // an existing device, just clear the re-install flag.
                    //
                    dwConfigFlags = GetDevInstConfigFlags(
                                        DevInfoElem->DevInst,
                                        (DevInfoElem->InstallParamBlock.Flags & DI_INSTALLDISABLED)
                                            ? CONFIGFLAG_DISABLED
                                            : 0,
                                        pDeviceInfoSet->hMachine
                                       );

                    //
                    // Always clear the REINSTALL bit and the FAILEDINSTALL bit
                    // when installing a device.
                    // (Also, clear the CONFIGFLAG_FINISH_INSTALL bit, which is used for
                    // Raw and driver-detected devnodes.)
                    //
                    dwConfigFlags &= ~(CONFIGFLAG_REINSTALL | CONFIGFLAG_FAILEDINSTALL | CONFIGFLAG_FINISH_INSTALL);
                }

                //
                // If we're doing a copy-only installation, then we're done.
                //
                if(!DoFullInstall) {
                    goto clean0;
                }

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_TIME,
                    MSG_LOG_BEGIN_WRITE_REG_TIME,
                    NULL);       // text message

                //
                // Insert Driver Specific strings into the registry.
                //
                if(InfFromOemPath = pSetupInfIsFromOemLocation(szInfFileName, TRUE)) {
                    TempString = pSetupGetFileTitle(szNewName);
                } else {
                    TempString = pSetupGetFileTitle(szInfFileName);
                }

                RegSetValueEx(hkDrv,
                              pszInfPath,
                              0,
                              REG_SZ,
                              (PBYTE)TempString,
                              (lstrlen(TempString) + 1) * sizeof(TCHAR)
                             );

                RegSetValueEx(hkDrv,
                              pszInfSection,
                              0,
                              REG_SZ,
                              (PBYTE)szInfSectionName,
                              (lstrlen(szInfSectionName) + 1) * sizeof(TCHAR)
                             );

                if(szInfSectionExt) {

                    RegSetValueEx(hkDrv,
                                  pszInfSectionExt,
                                  0,
                                  REG_SZ,
                                  (PBYTE)szInfSectionExt,
                                  (lstrlen(szInfSectionExt) + 1) * sizeof(TCHAR)
                                 );
                } else {
                    //
                    // This wasn't an OS/architecture-specific install section, _or_ we are
                    // installing from a legacy INF.  Make sure there's no value hanging
                    // around from a previous installation.
                    //
                    RegDeleteValue(hkDrv, pszInfSectionExt);
                }

                if(DevInfoElem->SelectedDriver->ProviderDisplayName == -1) {
                    //
                    // No provider specified--delete any previously existing value entry.
                    //
                    RegDeleteValue(hkDrv, pszProviderName);

                } else {
                    //
                    // Retrieve the Provider name, and store it in the driver key.
                    //
                    TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                          DevInfoElem->SelectedDriver->ProviderDisplayName
                                                         );
                    RegSetValueEx(hkDrv,
                                  pszProviderName,
                                  0,
                                  REG_SZ,
                                  (PBYTE)TempString,
                                  (lstrlen(TempString) + 1) * sizeof(TCHAR)
                                 );
                }

                if (DevInfoElem->SelectedDriver->DriverDate.dwLowDateTime != 0 ||
                    DevInfoElem->SelectedDriver->DriverDate.dwHighDateTime != 0) {

                    SYSTEMTIME SystemTime;
                    TCHAR Date[20];

                    //
                    // Save the driver date in binary (FILETIME) format in the registry
                    // so it can be localized by other components.
                    //
                    RegSetValueEx(hkDrv,
                                  pszDriverDateData,
                                  0,
                                  REG_BINARY,
                                  (LPBYTE)&DevInfoElem->SelectedDriver->DriverDate,
                                  sizeof(DevInfoElem->SelectedDriver->DriverDate)
                                  );

                    //
                    // Save the driver date in string format for compatibility.
                    //
                    if (FileTimeToSystemTime(&(DevInfoElem->SelectedDriver->DriverDate), &SystemTime)) {

                        wsprintf(Date, TEXT("%d-%d-%d"), SystemTime.wMonth, SystemTime.wDay,
                            SystemTime.wYear);

                        RegSetValueEx(hkDrv,
                                      pszDriverDate,
                                      0,
                                      REG_SZ,
                                      (PBYTE)Date,
                                      (lstrlen(Date) + 1) * sizeof(TCHAR)
                                      );
                    }

                } else {
                    //
                    //No driver date for this driver--delete any previously existing value entry.
                    //
                    RegDeleteValue(hkDrv, pszDriverDateData);
                    RegDeleteValue(hkDrv, pszDriverDate);
                }

                if (DevInfoElem->SelectedDriver->DriverVersion != 0) {

                    ULARGE_INTEGER Version;
                    TCHAR VersionString[LINE_LEN];

                    Version.QuadPart = DevInfoElem->SelectedDriver->DriverVersion;

                    wsprintf(VersionString, TEXT("%0d.%0d.%0d.%0d"),
                        HIWORD(Version.HighPart), LOWORD(Version.HighPart),
                        HIWORD(Version.LowPart), LOWORD(Version.LowPart));

                    RegSetValueEx(hkDrv,
                                  pszDriverVersion,
                                  0,
                                  REG_SZ,
                                  (PBYTE)VersionString,
                                  (lstrlen(VersionString) + 1) * sizeof(TCHAR)
                                  );

                } else {
                    //
                    //No driver version for this driver--delete any previously existing value entry.
                    //
                    RegDeleteValue(hkDrv, pszDriverVersion);
                }

                //
                // Set the Class property for this device.
                //
                SetupDiClassNameFromGuid(&DevInfoElem->ClassGuid, className, MAX_CLASS_NAME_LEN, NULL);
                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_CLASS,
                                                 className,
                                                 (lstrlen(className) + 1) * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                //
                // Set the MFG device registry property.
                //
                TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                      DevInfoElem->SelectedDriver->MfgDisplayName
                                                     );

                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_MFG,
                                                 TempString,
                                                 (lstrlen(TempString) + 1) * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                //
                // Add hardware and compatible IDs to the hardware key if they exist
                // in the driver node and don't already exist in the registry.  This
                // sets up an ID for manually installed devices.
                //
                if(!(DevInfoElem->InstallParamBlock.Flags & DI_NOWRITE_IDS) &&     // Want IDs written?
                   (DevInfoElem->SelectedDriver->HardwareId != -1))                // ID in driver node?
                {
                    //
                    // Don't write IDs if either Hardware or Compatible IDs already
                    // exist in the registry.  Note that I use cbData as an IN/OUT parameter
                    // to both CM calls.  This is OK, however, since cbSize will not be modified
                    // on a CR_NO_SUCH_VALUE return, and I won't try to re-use it otherwise.
                    //
                    cbData = 0;
                    if((DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALWAYSWRITEIDS) ||
                       ((CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                          CM_DRP_HARDWAREID,
                                                          NULL,
                                                          NULL,
                                                          &cbData,
                                                          0,
                                                          pDeviceInfoSet->hMachine) == CR_NO_SUCH_VALUE) &&
                        (CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                          CM_DRP_COMPATIBLEIDS,
                                                          NULL,
                                                          NULL,
                                                          &cbData,
                                                          0,
                                                          pDeviceInfoSet->hMachine) == CR_NO_SUCH_VALUE)))
                    {
                        DWORD CurStringLen, TotalStringLen, i;

                        //
                        // Compute the maximum buffer size needed to hold our REG_MULTI_SZ
                        // ID lists.
                        //
                        TotalStringLen = (((DevInfoElem->SelectedDriver->NumCompatIds) ?
                                            DevInfoElem->SelectedDriver->NumCompatIds  : 1)
                                            * MAX_DEVICE_ID_LEN) + 1;

                        if(!(DevIdBuffer = MyMalloc(TotalStringLen * sizeof(TCHAR)))) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }

                        //
                        // Build a multi-sz list of the (single) HardwareID, and set it.
                        //
                        TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                              DevInfoElem->SelectedDriver->HardwareId
                                                             );

                        TotalStringLen = lstrlen(TempString) + 1;

                        CopyMemory(DevIdBuffer, TempString, TotalStringLen * sizeof(TCHAR));

                        DevIdBuffer[TotalStringLen++] = TEXT('\0');  // Add extra terminating NULL;

                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         CM_DRP_HARDWAREID,
                                                         DevIdBuffer,
                                                         TotalStringLen * sizeof(TCHAR),
                                                         0,
                                                         pDeviceInfoSet->hMachine );

                        //
                        // Build a multi-sz list of the zero or more CompatibleIDs, and set it
                        //
                        TotalStringLen = 0;
                        for(i = 0; i < DevInfoElem->SelectedDriver->NumCompatIds; i++) {

                            TempString = pStringTableStringFromId(
                                            pDeviceInfoSet->StringTable,
                                            DevInfoElem->SelectedDriver->CompatIdList[i]);

                            CurStringLen = lstrlen(TempString) + 1;

                            CopyMemory(&(DevIdBuffer[TotalStringLen]),
                                       TempString,
                                       CurStringLen * sizeof(TCHAR));

                            TotalStringLen += CurStringLen;
                        }

                        if(TotalStringLen) {

                            DevIdBuffer[TotalStringLen++] = TEXT('\0');  // Add extra terminating NULL;

                            CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                             CM_DRP_COMPATIBLEIDS,
                                                             DevIdBuffer,
                                                             TotalStringLen * sizeof(TCHAR),
                                                             0,
                                                             pDeviceInfoSet->hMachine);
                        }
                    }
                }

                //
                // Write out the 'MatchingDeviceId' value entry to the driver key that indicates which
                // device ID (hardware or compatible) was used to pick this driver.  For a compatible
                // driver, this is the device ID that the compatible match was based on.  For a class
                // driver, this is the driver node's HardwareId (if present), or best CompatibleId.  If
                // the class driver node didn't specify a hardware or compatible IDs, then this value
                // will not be written (we'll actually delete it to make sure it doesn't exist from a
                // previous driver installation).
                //
                TempString = NULL;
                if(DevInfoElem->SelectedDriverType == SPDIT_COMPATDRIVER) {

                    if(DevInfoElem->SelectedDriver->MatchingDeviceId == -1) {
                        //
                        // We have a HardwareID match.
                        //
                        TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                              DevInfoElem->SelectedDriver->HardwareId
                                                             );
                    } else {
                        //
                        // We have a CompatibleID match.
                        //
                        MYASSERT((DevInfoElem->SelectedDriver->MatchingDeviceId >= 0) &&
                                 ((DWORD)(DevInfoElem->SelectedDriver->MatchingDeviceId) < DevInfoElem->SelectedDriver->NumCompatIds));

                        TempString = pStringTableStringFromId(
                                         pDeviceInfoSet->StringTable,
                                         DevInfoElem->SelectedDriver->CompatIdList[DevInfoElem->SelectedDriver->MatchingDeviceId]
                                        );
                    }

                } else if(DevInfoElem->SelectedDriver->HardwareId != -1) {
                    //
                    // There's no notion of compatibility for class drivers--pick the device ID with the
                    // highest order of preference.
                    //
                    TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                          DevInfoElem->SelectedDriver->HardwareId
                                                         );
                    if(!(*TempString)) {
                        //
                        // The HardwareID was an empty string--use the first CompatibleID.
                        //
                        if(DevInfoElem->SelectedDriver->NumCompatIds) {
                            TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                  DevInfoElem->SelectedDriver->CompatIdList[0]
                                                                 );
                        } else {
                            TempString = NULL;
                        }
                    }
                }

                if(TempString) {
                    RegSetValueEx(hkDrv,
                                  pszMatchingDeviceId,
                                  0,
                                  REG_SZ,
                                  (PBYTE)TempString,
                                  (lstrlen(TempString) + 1) * sizeof(TCHAR)
                                 );
                } else {
                    //
                    // We have an override situation where the user picked a class driver that didn't
                    // specify any hardware or compatible IDs.  Make sure there's no value hanging
                    // around from a previous installation.
                    //
                    RegDeleteValue(hkDrv, pszMatchingDeviceId);
                }

                //
                // If we're running under Windows NT, and we've successfully installed the device instance,
                // then we need to install any required services.
                //
                if((Err == NO_ERROR) && (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {

                    PTSTR pServiceInstallSection;

                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_TIME,
                        MSG_LOG_BEGIN_SERVICE_TIME,
                        NULL);       // text message

                    if(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF) {
                        pServiceInstallSection = NULL;
                    } else {
                        //
                        // The install section name is of the form:
                        //
                        //     <InfSectionWithExt>.Services
                        //
                        CopyMemory(&(InfSectionWithExt[InfSectionWithExtLength - 1]),
                                   pszServicesSectionSuffix,
                                   sizeof(pszServicesSectionSuffix)
                                  );
                        pServiceInstallSection = InfSectionWithExt;
                    }

                    Err = InstallNtService(DevInfoElem,
                                           hDeviceInf,
                                           szInfFileName,
                                           pServiceInstallSection,
                                           &DeleteServiceList,
                                           0,
                                           &NullDriverInstall
                                          );
                }
                if ((Err == NO_ERROR)
                    && DoFullInstall
                    && !(DevInfoElem->SelectedDriver->Flags & DNF_LEGACYINF)) {
                    InfSectionWithExt[InfSectionWithExtLength - 1] = TEXT('\0');
                    pSetupCopyRelatedInfs(hDeviceInf,
                                          szInfFileName,
                                          InfSectionWithExt,
                                          (DevInfoElem->SelectedDriver->Flags & DNF_INET_DRIVER)
                                              ? SPOST_URL : SPOST_PATH,
                                          LogContext);
                }
            }

        } else {
            //
            // Installing the NULL driver.
            // This means to set the Config flags, and nothing else.
            // Config Flags get set to enabled in this case, so the device
            // gets assigned the correct config. (Win95 bug 26320)
            //

            WriteLogEntry(
                LogContext,
                DRIVER_LOG_INFO,
                MSG_LOG_INSTALL_NULL,
                NULL,       // text message
                DeviceFullID);

            NullDriverInstall = TRUE;

            if(DoFullInstall) {

                BOOL NullDrvInstallOK = FALSE;

                //
                // Check to see if the devnode is raw-capable, or if it already has a controlling
                // service.  If neither of those conditions are met, then we should fail this call
                // unless the caller has explicitly passed us the DI_FLAGSEX_SETFAILEDINSTALL flag.
                //
                cbData = sizeof(DevInstCapabilities);
                if(CR_SUCCESS == CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                                  CM_DRP_CAPABILITIES,
                                                                  NULL,
                                                                  &DevInstCapabilities,
                                                                  &cbData,
                                                                  0,
                                                                  pDeviceInfoSet->hMachine))
                {
                    NullDrvInstallOK = (DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK);
                }

                if(!NullDrvInstallOK) {
                    //
                    // The devnode isn't raw-capable.  Check to see if it already has a
                    // controlling service (e.g., because it was created as a result of
                    // a driver's call to IoReportDetectedDevice).
                    //
                    cbData = 0;
                    if(CR_BUFFER_SMALL == CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                                           CM_DRP_SERVICE,
                                                                           NULL,
                                                                           NULL,
                                                                           &cbData,
                                                                           0,
                                                                           pDeviceInfoSet->hMachine))
                    {
                        NullDrvInstallOK = TRUE;
                    }
                }

                if(!NullDrvInstallOK &&
                   !(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL)) {

                    Err = ERROR_NO_ASSOCIATED_SERVICE;

                } else {

                    dwConfigFlags = GetDevInstConfigFlags(DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) &
                                        ~(CONFIGFLAG_DISABLED | CONFIGFLAG_REINSTALL | CONFIGFLAG_FINISH_INSTALL);

                    //
                    // Delete all driver (software) keys associated with the device, and clear
                    // the "Driver" registry property.
                    //
                    SetupDiDeleteDevRegKey(DeviceInfoSet,
                                           DeviceInfoData,
                                           DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                                           0,
                                           DIREG_DRV
                                          );

                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_DRIVER,
                                                        NULL, 0, 0,pDeviceInfoSet->hMachine);

                    //
                    // Delete the controlling (FDO) Service property, as well as the UpperFilters and
                    // LowerFilters properties.  Only do this if the devnode is not root-enumerated,
                    // however, since NT can have root-enumerated devnodes reported by drivers via
                    // IoReportDetectedDevice for which there's no corresponding INF (hence, the user
                    // must do a null-driver install in order to silence the "New Hardware Found" popups
                    // for these devices.
                    //
                    if((CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst,
                                                 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                       !(ulStatus & DN_ROOT_ENUMERATED)) {

                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_SERVICE,
                                                            NULL, 0, 0,pDeviceInfoSet->hMachine);
                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_UPPERFILTERS,
                                                            NULL, 0, 0,pDeviceInfoSet->hMachine);
                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_LOWERFILTERS,
                                                            NULL, 0, 0,pDeviceInfoSet->hMachine);
                    }
                }

            } else {
                //
                // It is an error to not have a selected driver in the copy-only case.
                //
                Err = ERROR_NO_DRIVER_SELECTED;
            }
        }

        //
        // If all went well above, then write some configflags, and re-enumerate
        // the parent device instance if necessary
        //
        if(Err == NO_ERROR) {
            //
            // Write the Driver Description to the Registry, if there
            // is an lpSelectedDriver, and the Device Description also
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_WRITE_REG2_TIME,
                NULL);       // text message

            if(DevInfoElem->SelectedDriver) {

                TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                      DevInfoElem->SelectedDriver->DrvDescription
                                                     );

                RegSetValueEx(hkDrv,
                              pszDrvDesc,
                              0,
                              REG_SZ,
                              (PBYTE)TempString,
                              (lstrlen(TempString) + 1) * sizeof(TCHAR)
                             );

                //
                // (setupx BUG 12721) always update the DevDesc in the registry with the
                // value from the INF (ie only do this if we have a SELECTED driver)
                // The semantics are weird, but the SelectedDriver NODE contains the
                // INF Device description, and DRV description
                //
                TempString = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                      DevInfoElem->SelectedDriver->DevDescriptionDisplayName
                                                     );

                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_DEVICEDESC,
                                                 TempString,
                                                 (lstrlen(TempString) + 1) * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);
            } else {
                //
                // No driver is selected, so use the description stored with the device
                // information element itself for the device description.  However, only set this
                // if it isn't already present.
                //
                cbData = 0;
                if(CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                    CM_DRP_DEVICEDESC,
                                                    NULL,
                                                    NULL,
                                                    &cbData,
                                                    0,
                                                    pDeviceInfoSet->hMachine) == CR_NO_SUCH_VALUE) {

                    if(DevInfoElem->DeviceDescriptionDisplayName != -1) {

                        TempString = pStringTableStringFromId(
                                         pDeviceInfoSet->StringTable,
                                         DevInfoElem->DeviceDescriptionDisplayName
                                        );

                        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         CM_DRP_DEVICEDESC,
                                                         TempString,
                                                         (lstrlen(TempString) + 1) * sizeof(TCHAR),
                                                         0,
                                                         pDeviceInfoSet->hMachine);
                    }
                }
            }

            //
            // Unless the caller explicitly requested that this device be installed disabled, clear
            // the CONFIGFLAG_DISABLED bit.
            //
            if(!(DevInfoElem->InstallParamBlock.Flags & DI_INSTALLDISABLED)) {
                dwConfigFlags &= ~CONFIGFLAG_DISABLED;
            }

            //
            // Write the config flags. If no selected driver means we should mark the install
            // as a failure, then do so.
            //
            if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL) {
                dwConfigFlags |= CONFIGFLAG_FAILEDINSTALL;
            }


            CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                             CM_DRP_CONFIGFLAGS,
                                             &dwConfigFlags,
                                             sizeof(dwConfigFlags),
                                             0,
                                             pDeviceInfoSet->hMachine);


            if(!(DevInfoElem->InstallParamBlock.Flags & (DI_DONOTCALLCONFIGMG | DI_NEEDREBOOT | DI_NEEDRESTART))) {

                if (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_RESTART_DEVICE_ONLY) {
                    //
                    // Restart this device only.
                    //
                    // This should only be done if no files were copied during
                    // DIF_INSTALLDEVICEFILES.
                    //
                    RestartSingleDevice(DevInfoElem,
                                        pDeviceInfoSet,
                                        NullDriverInstall,
                                        LogContext);
                } else {
                    //
                    // Restart this device as well as any other device that is
                    // using one of the same drivers as this device. This
                    // includes the function driver as well as the device and
                    // class upper and lower filter drivers.
                    //
                    // This only needs to be used if files were copied during
                    // DIF_INSTALLDEVICEFILES.
                    //
                    RestartAllDevicesUsingDrivers(DevInfoElem,
                                                  pDeviceInfoSet,
                                                  NullDriverInstall,
                                                  LogContext);
                }
            }
        }

        if((Err == NO_ERROR) && !GuiSetupInProgress) {

            MYASSERT(DoFullInstall);

            //
            // Kick off RunOnce.
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_BEGIN_INSTALLSTOP_TIME,
                NULL);       // text message

            Err = pSetupInstallStopEx(TRUE, INSTALLSTOP_NO_GRPCONV, LogContext);
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error,
        // otherwise, assume it was an inpage error dealing with a mapped-in
        // file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;

        if(FreeMsgHandlerContext) {
            SetupTermDefaultQueueCallback(MsgHandlerContext);
        }
        if(CloseUserFileQ) {
            SetupCloseFileQueue(UserFileQ);
        }

        //
        // Access the following variables so that the compiler will respect our
        // statement ordering w.r.t. these values.  Otherwise, we may not be
        // able to know with certainty whether or not we should release their
        // corresponding resources.
        //
        DevInfoElem = DevInfoElem;
        hDeviceInf = hDeviceInf;
        hkDrv = hkDrv;
        DevIdBuffer = DevIdBuffer;
        DeleteServiceList = DeleteServiceList;
        OemInfFileToCopy = OemInfFileToCopy;
    }

    //
    // Clean up the registry if the install didn't go well.  Along with other
    // error paths, this handles the case where the user cancels the install
    // while copying files
    //
    if(Err != NO_ERROR) {

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_CLEANUP_TIME,
            NULL);       // text message

        if(DevInfoElem && DoFullInstall) {
            //
            // Disable the device if the error wasn't a user cancel.
            //
            if(Err != ERROR_CANCELLED) {

                DWORD dwConfigFlagsSize;

                //
                // The device is in an unknown state.  Disable it by setting the
                // CONFIGFLAG_DISABLED config flag.
                //
                dwConfigFlagsSize = sizeof(DWORD);
                if(CM_Get_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                    CM_DRP_CONFIGFLAGS,
                                                    NULL,
                                                    &dwConfigFlags,
                                                    &dwConfigFlagsSize,
                                                    0,
                                                    pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    dwConfigFlags |= (CONFIGFLAG_DISABLED | CONFIGFLAG_REINSTALL);
                    //
                    // Also, make sure we clear the finish-install flag.
                    //
                    dwConfigFlags &= ~CONFIGFLAG_FINISH_INSTALL;

                } else {
                    dwConfigFlags = CONFIGFLAG_DISABLED;
                }

                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_CONFIGFLAGS,
                                                 &dwConfigFlags,
                                                 sizeof(dwConfigFlags),
                                                 0,
                                                 pDeviceInfoSet->hMachine);
                //
                // Delete the Driver= entry from the Dev Reg Key and delete the
                // DrvRegKey (as well as the DevRegKey if it didn't previously exist).
                //
                if(DevInfoElem->SelectedDriver) {

                    SetupDiDeleteDevRegKey(DeviceInfoSet,
                                           DeviceInfoData,
                                           DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGGENERAL,
                                           0,
                                           (DeleteDevKey ? DIREG_BOTH : DIREG_DRV)
                                          );

                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst, CM_DRP_DRIVER,
                                                        NULL, 0, 0,pDeviceInfoSet->hMachine);
                }

                //
                // If necessary, delete any service entries created for this device instance.
                //
                if(DeleteServiceList) {
                    DeleteServicesInList(DeleteServiceList,LogContext);
                }
            }
        }

        //
        // If we copied the OEM INF into the INF directory under a
        // newly-generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName, LogContext, SUOI_FORCEDELETE, NULL);
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(hDeviceInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hDeviceInf);
    }
    if(hkDrv != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkDrv);
    }
    if(DevIdBuffer) {
        MyFree(DevIdBuffer);
    }
    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }
    if(DeleteServiceList) {

        PSVCNAME_NODE TmpSvcNode;

        for(TmpSvcNode = DeleteServiceList; TmpSvcNode; TmpSvcNode = DeleteServiceList) {
            DeleteServiceList = DeleteServiceList->Next;
            MyFree(TmpSvcNode);
        }
    }

    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of install
        // if copy install, only do in Verbose-Logging, else do for standard Info-Logging
        //
        WriteLogEntry(
            LogContext,
            DoFullInstall?DRIVER_LOG_INFO:DRIVER_LOG_VERBOSE,
            MSG_LOG_INSTALLED,
            NULL,
            DeviceFullID);
    } else {
        //
        // indicate install failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTALL_ERROR_ENCOUNTERED,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    if (slot_deviceID) {
        ReleaseLogInfoSlot(LogContext,slot_deviceID);
    }
    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }
    WriteLogEntry(
        LogContext,
        DRIVER_LOG_TIME,
        MSG_LOG_END_INSTALL_TIME,
        NULL);       // text message
    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiInstallDriverFiles(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_INSTALLDEVICEFILES

    This routine is similiar to a combination of SetupDiRegisterCoDeviceInstallers,
    SetupDiInstallDeviceInterfaces, and SetupDiInstallDevice, but it only performs
    the file copy commands in the install sections, and will not attempt to
    configure the device in any way.  This API is useful for pre-copying a device's
    driver files.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        a device information element to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        a driver is to be installed.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    A driver must be selected for the specified device information element before
    calling this API.

--*/

{
    return _SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData, FALSE);
}


BOOL
WINAPI
SetupDiRemoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_REMOVE

    This routine removes a device from the system.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        device is to be removed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for
        which a device is to be removed.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.  (If this is a global removal, or the last hardware profile-specific
        removal, then all traces of the devinst are removed from the registry, and
        the handle becomes NULL at that point.)

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This routine will remove the device from the system, deleting both of its
    registry keys, and dynamically stopping the device if its DevInst is 'live'.
    If the device cannot be dynamically stopped, then flags will be set in the
    install parameter block that will eventually cause the user to be prompted
    to shut the system down.  The removal is either global to all hardware
    profiles, or specific to one hardware profile depending on the contents of
    the ClassInstallParams field.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, ConfigFlags;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    PSP_REMOVEDEVICE_PARAMS RemoveDevParams;
    BOOL IsCurrentHwProfile = FALSE;
    ULONG HwProfFlags;
    DWORD HwProfileToRemove;
    HWPROFILEINFO HwProfileInfo;
    BOOL RemoveDevInst = FALSE, NukeDevInst = FALSE;
    BOOL RemoveGlobally;
    DEVINST DevNodeRemoved = 0;
    DWORD i;
    PINTERFACE_DEVICE_NODE InterfaceDeviceNode;
    CONFIGRET cr;
    ULONG ulStatus;
    ULONG ulProblem;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_deviceID = 0;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }
    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;

    try {
        //
        // Locate the devinfo element to be removed.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            dipb = &(DevInfoElem->InstallParamBlock);
            LogContext = dipb->LogContext;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future uninstall will involve running one or more INF "uninstall"
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        if(CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS &&
           (ulStatus & DN_ROOT_ENUMERATED) &&
            !(ulStatus & DN_DISABLEABLE)) {
           //
           // we cannot remove a root enumerated non-disableable device
           //
           Err = ERROR_NOT_DISABLEABLE;
           goto clean0;
        }

        //
        // Retrieve the name of the device instance.  This is necessary, because
        // we're about to remove the DEVINST, but we need to be able to locate it
        // again, as a phantom.  This should never fail.
        //
        if(CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                               DeviceInstanceId,
                               SIZECHARS(DeviceInstanceId),
                               0,
                               pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            MYASSERT(!CR_SUCCESS);
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        if(slot_deviceID == 0) {
            slot_deviceID = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE);
        }
        WriteLogEntry(
            LogContext,
            slot_deviceID,
            MSG_LOG_DO_REMOVE,
            NULL,       // text message
            DeviceInstanceId);

        //
        // See if there's a SP_REMOVEDEVICE_PARAMS structure we need to pay
        // attention to.
        //
        if((dipb->Flags & DI_CLASSINSTALLPARAMS) &&
           (dipb->ClassInstallHeader->InstallFunction == DIF_REMOVE)) {

            RemoveDevParams = (PSP_REMOVEDEVICE_PARAMS)(dipb->ClassInstallHeader);

            if(RemoveGlobally = (RemoveDevParams->Scope == DI_REMOVEDEVICE_GLOBAL)) {
                //
                // We are doing a global removal.  We still want to set CSCONFIGFLAG_DO_NOT_CREATE
                // for this device in the current hardware profile, so that someone else happening
                // to do an enumeration won't turn this guy back on before we get a chance to
                // remove it.
                //
                HwProfileToRemove = 0;

            } else {
                //
                // Remove device from a particular hardware profile.
                //
                HwProfileToRemove = RemoveDevParams->HwProfile;

                //
                // Set the CSCONFIGFLAG_DO_NOT_CREATE flag for the specified hardware profile.
                //
                if(CM_Get_HW_Prof_Flags_Ex(DeviceInstanceId,
                                        HwProfileToRemove,
                                        &HwProfFlags,
                                        0,
                                        pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    HwProfFlags |= CSCONFIGFLAG_DO_NOT_CREATE;
                } else {
                    HwProfFlags = CSCONFIGFLAG_DO_NOT_CREATE;
                }

                Err = MapCrToSpError(
                          CM_Set_HW_Prof_Flags_Ex(DeviceInstanceId, HwProfileToRemove,
                                                  HwProfFlags, 0,pDeviceInfoSet->hMachine),
                          ERROR_INVALID_DATA
                          );

                if(Err != NO_ERROR) {
                    goto clean0;
                }

                //
                // Determine if we are deleting the device from the current hw profile.
                //
                if((HwProfileToRemove == 0) ||
                   ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                                      0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                    (HwProfileInfo.HWPI_ulHWProfile == HwProfileToRemove))) {

                    IsCurrentHwProfile = TRUE;
                }

            }

            //
            // Is this the current hardware profile or a global removal AND
            // is there a present device?
            //
            if((IsCurrentHwProfile || RemoveGlobally) &&
               !(DevInfoElem->DiElemFlags & DIE_IS_PHANTOM) &&
               !(dipb->Flags & DI_DONOTCALLCONFIGMG)) {

                RemoveDevInst = TRUE;
            }

        } else {
            //
            // No device removal params given, so do a global removal.
            //
            RemoveGlobally = TRUE;
            HwProfileToRemove = 0;

            if(!(dipb->Flags & DI_DONOTCALLCONFIGMG)) {
                RemoveDevInst = TRUE;
            }
        }

        //
        // If this is a global removal, or the last hardware profile-specific one, then clean up
        // the registry.
        //
        if(RemoveGlobally || IsDevRemovedFromAllHwProfiles(DeviceInstanceId,pDeviceInfoSet->hMachine)) {
            NukeDevInst = TRUE;
        }

        if(RemoveDevInst) {

            TCHAR VetoName[MAX_PATH];
            PNP_VETO_TYPE VetoType;

#ifdef UNICODE
            cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                                &VetoType,
                                                VetoName,
                                                SIZECHARS(VetoName),
                                                CM_REMOVE_NO_RESTART |
                                                (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                    ? CM_REMOVE_UI_NOT_OK
                                                    : CM_REMOVE_UI_OK,
                                                pDeviceInfoSet->hMachine
                                               );

            if(cr == CR_SUCCESS) {
                //
                // Device instance successfully removed--now locate it as a phantom.
                //
                CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                  (DEVINSTID)DeviceInstanceId,
                                  CM_LOCATE_DEVINST_PHANTOM,
                                  pDeviceInfoSet->hMachine);

                DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;

                //
                // Set the DevNodeRemoved DevNode so that we know we need to
                // call CM_Setup_DevInst with the CM_SETUP_DEVNODE_RESET flag
                // to allow this devnode to come back online on the next
                // enumeration.
                //
                DevNodeRemoved = DevInfoElem->DevInst;

            } else {
                //
                // If the failure was due to a veto, then log information about
                // who vetoed us.
                //
                // SPLOG--write out an entry with real logging.
                //
                if(cr == CR_REMOVE_VETOED) {
                    //
                    // get the LogContext from dipb which should be a pointer
                    // to the appropriate DevInstallParamBlock
                    //
                    _WriteVetoLogEntry(
                        dipb->LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REMOVE_VETOED_IN_UNINSTALL,
                        DeviceInstanceId,
                        VetoName,
                        VetoType);
                }

                if (cr != CR_INVALID_DEVNODE) {
                    SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                         pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_QR_VETOED_UNINSTALL,
                                                         cr,
                                                         (ULONG_PTR)_MapCmRetToString(cr)
                                                         );
                }
            }
#else
            //
            // It appears that some people (who are broken)
            // do rely on setupapi to install devices
            // so old code conditionally re-introduced to try and fix them
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR,
                MSG_LOG_NOT_FOR_THIS_OS,
                NULL);


            if((CM_Query_Remove_SubTree(DevInfoElem->DevInst, CM_QUERY_REMOVE_UI_OK) == CR_SUCCESS) &&
               (CM_Remove_SubTree(DevInfoElem->DevInst, CM_REMOVE_UI_OK) == CR_SUCCESS)) {
                //
                // Device instance successfully removed--now locate it as a phantom.
                //
                CM_Locate_DevInst(&(DevInfoElem->DevInst),
                                  (DEVINSTID)DeviceInstanceId,
                                  CM_LOCATE_DEVINST_PHANTOM
                                 );
                DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
            } else {
                dipb->Flags |= DI_NEEDREBOOT;
            }

#endif
        }

        if(NukeDevInst) {

            //
            // Remove all traces of this device from the registry.
            //
            pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                   DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                                   (DWORD)-1,
                                   DIREG_BOTH,
                                   TRUE
                                  );

            cr = CM_Uninstall_DevInst_Ex(DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine);
            if (cr != CR_SUCCESS) {
                //
                // we try to catch this earlier
                //
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                goto clean0;
            }

            //
            // The above API will also remove all interface devices associated with this
            // device instance.  Now we need to mark every interface device node that we
            // are tracking for this devinfo element to indicate that they have been removed.
            //
            for(i = 0; i < DevInfoElem->InterfaceClassListSize; i++) {

                for(InterfaceDeviceNode = DevInfoElem->InterfaceClassList[i].InterfaceDeviceNode;
                    InterfaceDeviceNode;
                    InterfaceDeviceNode = InterfaceDeviceNode->Next) {

                    InterfaceDeviceNode->Flags |= SPINT_REMOVED;
                }
            }

            //
            // Mark this device information element as unregistered, and set its
            // devinst handle to NULL.
            //
            DevInfoElem->DiElemFlags &= ~DIE_IS_REGISTERED;
            DevInfoElem->DevInst = (DEVINST)0;
        }

        //
        // Now update the DevInst field of the DeviceInfoData structure with the new
        // value of the devinst handle (possibly NULL).
        //
        DeviceInfoData->DevInst = DevInfoElem->DevInst;

clean0: ;   // nothing to do.

    //
    // If the DevNode was really removed then we need to call CM_Setup_DevInst
    // with the CM_SETUP_DEVNODE_RESET flag to allow the devnode to come back
    // on the next enumeration.
    //
    if (DevNodeRemoved) {
        CM_Setup_DevInst_Ex(DevNodeRemoved,
                            CM_SETUP_DEVNODE_RESET,
                            pDeviceInfoSet->hMachine
                            );
    }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

clean1:
    if (slot_deviceID) {
        if (Err == NO_ERROR) {
            //
            // give a +ve affirmation of remove
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_INFO,
                MSG_LOG_REMOVED,
                NULL);
        } else {
            //
            // indicate remove failed, display error
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_REMOVE_ERROR,
                NULL);
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        ReleaseLogInfoSlot(LogContext,slot_deviceID);
    }
    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiUnremoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_UNREMOVE

    This routine unremoves a device from the system.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        device is to be unremoved.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for
        which a device is to be unremoved.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

        This device must contain class install parameters for DIF_UNREMOVE
        or the API will fail with ERROR_NO_CLASSINSTALL_PARAMS.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This function will unremove the the device on the system, dynamically starting
    the device if possible.  If the device cannot be dynamically started, then flags
    will be set in the device install parameters that will eventually cause the user
    to be prompted to shut the system down.

    The unremoval is specific to one configuration, specified in the HwProfile field
    of the SP_UNREMOVEDEVICE_PARAMS class install parameters associated with this
    device information element.  (The Scope field of this structure must be set to
    DI_UNREMOVEDEVICE_CONFIGSPECIFIC.)

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    PSP_UNREMOVEDEVICE_PARAMS UnremoveDevParams;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    ULONG HwProfFlags;
    HWPROFILEINFO HwProfileInfo;
    DEVINST dnRoot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    CONFIGRET cr;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }
    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;

    try {
        //
        // Locate the devinfo element to be unremoved.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            dipb = &(DevInfoElem->InstallParamBlock);
            LogContext = dipb->LogContext;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future this operation could involve running one or more INF
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // We'd better have DIF_UNREMOVE class install params
        //
        if(!(dipb->Flags & DI_CLASSINSTALLPARAMS) ||
           (dipb->ClassInstallHeader->InstallFunction != DIF_UNREMOVE)) {

            Err = ERROR_NO_CLASSINSTALL_PARAMS;
            goto clean0;
        }

        UnremoveDevParams = (PSP_UNREMOVEDEVICE_PARAMS)(dipb->ClassInstallHeader);

        //
        // This only works in a hardware profile-specific manner.
        //
        MYASSERT(UnremoveDevParams->Scope == DI_UNREMOVEDEVICE_CONFIGSPECIFIC);

        //
        // Retrieve the name of the device instance.  We need to do this because
        // accessing hardware profile-specific config flags is done via name instead
        // of devnode handle.  (Also, we'll need this later after re-enumerating
        // this device's parent.)
        //
        if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                                     DeviceInstanceId,
                                     SIZECHARS(DeviceInstanceId),
                                     0,
                                     pDeviceInfoSet->hMachine)) != CR_SUCCESS) {

            Err = MapCrToSpError(cr,ERROR_INVALID_DATA);
            goto clean0;
        }
        if(CM_Get_HW_Prof_Flags_Ex(DeviceInstanceId,
                                   UnremoveDevParams->HwProfile,
                                   &HwProfFlags,
                                   0,
                                   pDeviceInfoSet->hMachine) == CR_SUCCESS) {

            HwProfFlags &= ~CSCONFIGFLAG_DO_NOT_CREATE;

            Err = MapCrToSpError(
                      CM_Set_HW_Prof_Flags_Ex(DeviceInstanceId, UnremoveDevParams->HwProfile,
                                              HwProfFlags, 0,pDeviceInfoSet->hMachine),
                      ERROR_INVALID_DATA
                      );

            if(Err != NO_ERROR) {
                goto clean0;
            }
        }

        //
        // Determine if we are trying to un-remove the device in the current
        // hardware profile.
        //
        if((UnremoveDevParams->HwProfile == 0) ||
           ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                             0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
            (HwProfileInfo.HWPI_ulHWProfile == UnremoveDevParams->HwProfile))) {
            //
            // Make sure the device has started correctly.
            //
            if(CM_Locate_DevInst_Ex(&dnRoot, NULL, CM_LOCATE_DEVINST_NORMAL,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                //
                // Try to get this device enumerated
                //
                CM_Reenumerate_DevInst_Ex(dnRoot, CM_REENUMERATE_SYNCHRONOUS,pDeviceInfoSet->hMachine);

                if(CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                     (DEVINSTID)DeviceInstanceId,
                                     CM_LOCATE_DEVINST_NORMAL,
                                     pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                    CheckIfDevStarted(DevInfoElem, pDeviceInfoSet);

                } else {
                    //
                    // We couldn't locate the devnode.  We don't need to
                    // request a reboot, because if the devnode ever shows up
                    // again, we should be able to bring it back on-line just
                    // fine.
                    //
                    // Retrieve the devnode as a phantom
                    //
                    CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                         (DEVINSTID)DeviceInstanceId,
                                         CM_LOCATE_DEVINST_PHANTOM,
                                         pDeviceInfoSet->hMachine
                                        );

                    DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                }

                //
                // Update the caller's buffer to reflect the new device instance handle
                //
                DeviceInfoData->DevInst = DevInfoElem->DevInst;

            } else {
                //
                // We couldn't locate the root of the hardware tree!  This should never happen...
                //
                Err = ERROR_INVALID_DATA;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of unremove
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_UNREMOVED,
            NULL);
    } else {
        //
        // indicate unremove failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_UNREMOVE_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiMoveDuplicateDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DestinationDeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_MOVEDEVICE

    This routine moves a device to a new location in the Enum branch.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which
        a device is to be moved.

    DestinationDeviceInfoData - Supplies the address of a SP_DEVINFO_DATA
        structure for the device instance that is the destination of the move.

        This device must contain class install parameters for DIF_MOVEDEVICE,
        or the API will fail with ERROR_NO_CLASSINSTALL_PARAMS.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM SourceDevInfoElem, DestDevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb;
    PSP_MOVEDEV_PARAMS MoveDevParams;
    BOOL bUnlockDestDevInfoElem, bUnlockSourceDevInfoElem, bRestoreConfigMgrBehavior;
    DWORD ConfigFlags;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    BOOL RemoveSucceeded;
    CONFIGRET cr;
    PSETUP_LOG_CONTEXT LogContext = NULL;

    //
    // A device information element must be specified for this routine.
    //
    if(!DestinationDeviceInfoData) {
        Err = ERROR_INVALID_PARAMETER;
        goto clean1;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }
    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;
    bUnlockDestDevInfoElem = bUnlockSourceDevInfoElem = bRestoreConfigMgrBehavior = FALSE;

    try {
        //
        // Locate the destination devinfo element.
        //
        if(DestDevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DestinationDeviceInfoData,
                                                       NULL)) {

            dipb = &(DestDevInfoElem->InstallParamBlock);
            LogContext = dipb->LogContext;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future this operation could involve running one or more INF
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(dipb->FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // We'd better have DIF_MOVEDEVICE class install params
        //
        if(!(dipb->Flags & DI_CLASSINSTALLPARAMS) ||
           (dipb->ClassInstallHeader->InstallFunction != DIF_MOVEDEVICE)) {

            Err = ERROR_NO_CLASSINSTALL_PARAMS;
            goto clean0;
        }

        MoveDevParams = (PSP_MOVEDEV_PARAMS)(dipb->ClassInstallHeader);

        //
        // Find the source device.
        //
        if(!(SourceDevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                           &(MoveDevParams->SourceDeviceInfoData),
                                                           NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // We're about to call the class installer to handle device install (and possibly
        // device selection as well).  We don't want the class installer to do something
        // slimy like delete the devices out from under us, so we'll lock 'em down.
        //
        if(!(DestDevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
            DestDevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
            bUnlockDestDevInfoElem = TRUE;
        }
        if(!(SourceDevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
            SourceDevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
            bUnlockSourceDevInfoElem = TRUE;
        }

        //
        // We don't want the following calls to cause the ConfigMgr to do re-enumeration, etc.
        //
        if(!(dipb->Flags & DI_DONOTCALLCONFIGMG)) {
            dipb->Flags |= DI_DONOTCALLCONFIGMG;
            bRestoreConfigMgrBehavior = TRUE;
        }

        //
        // We need to unlock the HDEVINFO before calling the class installer.
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        pDeviceInfoSet = NULL;

        //
        // If the destination device doesn't have a selected driver, then get one.
        //
        if(!DestDevInfoElem->SelectedDriver) {

            if(!_SetupDiCallClassInstaller(DIF_SELECTDEVICE,
                                           DeviceInfoSet,
                                           DestinationDeviceInfoData,
                                           CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS)) {
                Err = GetLastError();
                goto clean0;
            }
        }

        if(!_SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                       DeviceInfoSet,
                                       DestinationDeviceInfoData,
                                       CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS)) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Re-acquire the HDEVINFO lock.
        //
        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            //
            // we should never hit this code path
            //
            MYASSERT(pDeviceInfoSet);
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // Retrieve the name of the device instance.  This is necessary, because
        // we may attempt to remove the DEVINST, but we need to be able to locate
        // it again, as a phantom.  This should never fail.
        //
        if(CM_Get_Device_ID_Ex(SourceDevInfoElem->DevInst,
                               DeviceInstanceId,
                               SIZECHARS(DeviceInstanceId),
                               0,
                               pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            MYASSERT(!CR_SUCCESS);
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        //
        // Delete all the user-accessible registry keys associated with the source
        // device in preparation for the move.
        //
        pSetupDeleteDevRegKeys(SourceDevInfoElem->DevInst,
                               DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                               (DWORD)-1,
                               DIREG_BOTH,
                               TRUE
                              );

        //
        // Check to see if we can remove the source device dynamically.
        //
        // NOTE: The ConfigFlags of the _destination_ device are retrieved, and checked
        // for the presence of the CONFIGFLAG_CANTSTOPACHILD flag.  PierreYs assures me
        // that this is the correct behavior.
        //
        ConfigFlags = GetDevInstConfigFlags(DestDevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine);

        if(ConfigFlags & CONFIGFLAG_CANTSTOPACHILD) {
            RemoveSucceeded = FALSE;
        } else {

            TCHAR VetoName[MAX_PATH];
            PNP_VETO_TYPE VetoType;

#ifdef UNICODE
            cr = CM_Query_And_Remove_SubTree_Ex(SourceDevInfoElem->DevInst,
                                                &VetoType,
                                                VetoName,
                                                SIZECHARS(VetoName),
                                                (SourceDevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                    ? CM_REMOVE_UI_NOT_OK
                                                    : CM_REMOVE_UI_OK,
                                                pDeviceInfoSet->hMachine
                                               );

            if(cr == CR_SUCCESS) {
                RemoveSucceeded = TRUE;
            } else {
                //
                // If the failure was due to a veto, then log information about
                // who vetoed us.
                //
                // SPLOG--write out a log entry
                //
                if(cr == CR_REMOVE_VETOED) {
                    //
                    // get the LogContext from dipb which should be a pointer
                    // to the appropriate DevInstallParamBlock
                    //
                    _WriteVetoLogEntry(
                        dipb->LogContext,
                        DRIVER_LOG_WARNING,
                        MSG_LOG_REMOVE_VETOED_IN_MOVE,
                        DeviceInstanceId,
                        VetoName,
                        VetoType);
                }

                RemoveSucceeded = FALSE;
            }
#else
            //
            // It appears that some people (who are broken)
            // do rely on setupapi to install devices
            //
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR,
                MSG_LOG_NOT_FOR_THIS_OS,
                NULL);

            RemoveSucceeded = FALSE;
#endif
        }

        if(RemoveSucceeded) {
            //
            // Source device instance successfully removed--now locate it as a phantom.
            //
            CM_Locate_DevInst_Ex(&(SourceDevInfoElem->DevInst),
                              (DEVINSTID)DeviceInstanceId,
                              CM_LOCATE_DEVINST_PHANTOM,
                              pDeviceInfoSet->hMachine);

            SourceDevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;

            //
            // Totally remove the source device from the system.
            //
            cr = CM_Uninstall_DevInst_Ex(SourceDevInfoElem->DevInst, 0, pDeviceInfoSet->hMachine);
            if (cr != CR_SUCCESS) {
                //
                // we try to catch this earlier
                //
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                goto clean0;
            }

            //
            // Tell ConfigMgr to start the new (destination) device instance.
            //
            CM_Setup_DevInst_Ex(DestDevInfoElem->DevInst, CM_SETUP_DEVINST_READY, pDeviceInfoSet->hMachine);
            CheckIfDevStarted(DestDevInfoElem, pDeviceInfoSet);

        } else {
            //
            // Can't remove the device.  Since we don't have a working
            // CM_Move_DevNode, we're stuck.  Fail the call, and write out a
            // log entry indicating the cause of the failure.
            //
            WriteLogEntry(dipb->LogContext,
                          DRIVER_LOG_ERROR,
                          MSG_LOG_MOVE_FAILED_CANT_REMOVE,
                          NULL
                         );

            Err = ERROR_CANT_REMOVE_DEVINST;
            goto clean0;
        }

        //
        // Mark the source device instance as unregistered, and clear its DevInst
        // handle.
        //
        SourceDevInfoElem->DiElemFlags &= ~DIE_IS_REGISTERED;
        SourceDevInfoElem->DevInst = (DEVINST)0;

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so that the compiler will respect our statement
        // ordering w.r.t. assignment.
        //
        pDeviceInfoSet = pDeviceInfoSet;
        bUnlockDestDevInfoElem = bUnlockDestDevInfoElem;
        bUnlockSourceDevInfoElem = bUnlockSourceDevInfoElem;
    }

    if(bUnlockDestDevInfoElem || bUnlockSourceDevInfoElem || bRestoreConfigMgrBehavior) {

        if(!pDeviceInfoSet) {
            if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
                //
                // we should never hit this code path
                //
                MYASSERT(pDeviceInfoSet);
                if (Err == NO_ERROR) {
                    Err = ERROR_INVALID_HANDLE;
                }
            }
        }
        try {
            if(bUnlockDestDevInfoElem) {
                DestDevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
            }
            if(bUnlockSourceDevInfoElem) {
                SourceDevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
            }
            if(bRestoreConfigMgrBehavior) {
                dipb->Flags &= ~DI_DONOTCALLCONFIGMG;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;   // nothing to do
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of move
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_MOVED,
            NULL);
    } else {
        //
        // indicate move failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_MOVE_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiChangeState(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_PROPERTYCHANGE

    This routine is used to change the state of an installed device.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        device's state is to be changed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure identifying
        the device whose state is to be changed.  This is an IN OUT parameter, since
        the DevInst field of the structure may be updated with a new handle value upon
        return.

Return Value:

    If the function succeeds, and there are files to be copied, the return value is TRUE.
    If the function fails, the return value is FALSE, and GetLastError returns the cause
    of failure.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK dipb = NULL;
    DWORD   dwConfigFlags;
    HKEY    hk;
    DEVINST dnToReenum;
    DWORD   dwStateChange;
    DWORD   dwFlags;
    ULONG   lParam;
    TCHAR   szDevID[MAX_DEVICE_ID_LEN];
    DWORD   dwHWProfFlags;
    HWPROFILEINFO HwProfileInfo;
    CONFIGRET cr;
    DWORD   slot_deviceID = 0;
    DWORD   action = MSG_LOG_PROPERTYCHANGE_ERROR;
    DWORD   actionerr = MSG_LOG_PROPERTYCHANGE_ERROR;
#ifndef UNICODE
    ULONG ulStatus;
    ULONG ulProblem;
#endif

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Locate the devinfo element whose state is to be changed.
        //
        if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                   DeviceInfoData,
                                                   NULL)) {

            dipb = &(DevInfoElem->InstallParamBlock);
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                         szDevID,
                         SIZECHARS(szDevID),
                         0,
                         pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
            //
            // this should never fail
            //
            MYASSERT(!CR_SUCCESS);
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }
        slot_deviceID = AllocLogInfoSlotOrLevel(dipb->LogContext,DRIVER_LOG_INFO,FALSE);
        if(slot_deviceID) {
            WriteLogEntry(
                dipb->LogContext,
                slot_deviceID,
                MSG_LOG_DO_PROPERTYCHANGE,
                NULL,       // text message
                szDevID);
        }

        //
        // This routine can't be called if non-native drivers are involved.
        // (Note: while presently this doesn't matter, it's possible that in
        // the future this operation could involve running one or more INF
        // sections, and I don't want to limit that possibility by introducing
        // the complication of non-native driver nodes.)
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        if(!(dipb->Flags & DI_CLASSINSTALLPARAMS) ||
           (dipb->ClassInstallHeader->InstallFunction != DIF_PROPERTYCHANGE)) {
            //
            // Don't have any class install parameters to tell us what needs to be done!
            //
            Err = ERROR_NO_CLASSINSTALL_PARAMS;
            goto clean0;
        }

        if(!DevInfoElem->DevInst) {
            Err = ERROR_NO_SUCH_DEVINST;
            goto clean0;
        }

        dwStateChange = ((PSP_PROPCHANGE_PARAMS)(dipb->ClassInstallHeader))->StateChange;
        dwFlags       = ((PSP_PROPCHANGE_PARAMS)(dipb->ClassInstallHeader))->Scope;
        lParam        = ((PSP_PROPCHANGE_PARAMS)(dipb->ClassInstallHeader))->HwProfile;

        //
        // DICS_FLAG_CONFIGGENERAL is allowed below and is ignored
        // people are relying on this broken behaviour
        //

        switch(dwStateChange) {

            case DICS_ENABLE:

                if(dwFlags == DICS_FLAG_GLOBAL) {
                    action = MSG_LOG_PROPERTYCHANGE_ENABLE_GLOBAL;
                    actionerr = MSG_LOG_PROPERTYCHANGE_ENABLE_GLOBAL_ERR;

                    //
                    // Clear the Disabled config flag, and attempt to enumerate the
                    // device.  Presumably it has a device node, it is just dormant (ie
                    // prob 80000001).
                    //
                    dwConfigFlags = GetDevInstConfigFlags(DevInfoElem->DevInst,
                                                          0,pDeviceInfoSet->hMachine) & ~CONFIGFLAG_DISABLED;

                    //
                    // Set the New config flags value
                    //
                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CM_DRP_CONFIGFLAGS,
                                                     &dwConfigFlags,
                                                     sizeof(dwConfigFlags),
                                                     0,
                                                     pDeviceInfoSet->hMachine);

                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

                        if(CM_Enable_DevNode_Ex(DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                            //
                            // Find the parent of this devnode and reenumerate it to bring this devnode online.
                            //
                            if (CM_Get_Parent_Ex(&dnToReenum, DevInfoElem->DevInst, 0, pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                                //
                                // Process this devnode now.
                                //
                                CM_Reenumerate_DevNode_Ex(dnToReenum, CM_REENUMERATE_SYNCHRONOUS,pDeviceInfoSet->hMachine);
                            }

                            //
                            // See if we sucessfully started dynamically.
                            //
                            CheckIfDevStarted(DevInfoElem, pDeviceInfoSet);

                        } else {
                            //
                            // We could not enable so we should restart
                            //
                            SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_ENABLE_FAILED);
                        }
                    }

                } else {
                    action = MSG_LOG_PROPERTYCHANGE_ENABLE_PROFILE;
                    actionerr = MSG_LOG_PROPERTYCHANGE_ENABLE_PROFILE_ERR;

                    //
                    // Get the hardware profile-specific flags
                    //
                    if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam, &dwHWProfFlags, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                        //
                        // Clear the Disabled bit.
                        //
                        dwHWProfFlags &= ~CSCONFIGFLAG_DISABLED;
                    } else {
                        dwHWProfFlags = 0;
                    }

                    //
                    // Set the profile Flags for this device to Enabled.  Setting the flags will
                    // also bring the devnode on-line, if we're modifying the current hardware
                    // profile.
                    //
                    cr = CM_Set_HW_Prof_Flags_Ex(szDevID, lParam, dwHWProfFlags, 0, pDeviceInfoSet->hMachine);

                    if(cr == CR_NEED_RESTART) {

                        SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_REASON_HW_PROF_ENABLE_FAILED);

                    } else if(cr != CR_SUCCESS) {

                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        goto clean0;
                    }
                }
                break;

            case DICS_DISABLE:

                if(dwFlags == DICS_FLAG_GLOBAL) {

                    BOOL disabled = FALSE;

                    action = MSG_LOG_PROPERTYCHANGE_DISABLE_GLOBAL;
                    actionerr = MSG_LOG_PROPERTYCHANGE_DISABLE_GLOBAL_ERR;

                    //
                    // we try to dynamically disable a device
                    // if it fails with anything but CR_NOT_DISABLEABLE
                    // then we set flag to try to disable it on reboot
                    //

                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

                        cr = CM_Disable_DevNode_Ex(DevInfoElem->DevInst,
                                                   CM_DISABLE_POLITE | CM_DISABLE_UI_NOT_OK,
                                                   pDeviceInfoSet->hMachine
                                                   );

                        if (cr == CR_SUCCESS) {

                            //
                            // we managed to disable it immediately
                            //
                            disabled = TRUE;

                        } else if (cr == CR_NOT_DISABLEABLE) {

                            //
                            // we couldn't and shouldn't try to disable it
                            //
                            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                            goto clean0;

                        } else {

                            //
                            // set flag to indicate a reboot is required to disable this
                            //
                            SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_DISABLE_FAILED);
                        }
                    }

                    //
                    // Note: There is a case where reboot-disabled device becomes non-disableable
                    // nothing we can do about this!
                    //
                    // Try and set the Disabled config flag if not already set, even if we managed to disable it
                    //
                    dwConfigFlags = GetDevInstConfigFlags(DevInfoElem->DevInst,
                                                          0,pDeviceInfoSet->hMachine);


                    if ((dwConfigFlags & CONFIGFLAG_DISABLED) == 0) {
                        dwConfigFlags |= CONFIGFLAG_DISABLED;
                        //
                        // Set the New config flags value
                        //

                        cr = CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                         CM_DRP_CONFIGFLAGS,
                                                         &dwConfigFlags,
                                                         sizeof(dwConfigFlags),
                                                         0,
                                                         pDeviceInfoSet->hMachine);

                        if (cr != CR_SUCCESS) {
                            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                            goto clean0;
                        }
                    }

                } else {
                    action = MSG_LOG_PROPERTYCHANGE_DISABLE_PROFILE;
                    actionerr = MSG_LOG_PROPERTYCHANGE_DISABLE_PROFILE_ERR;

                    //
                    // Get the hardware profile-specific flags
                    //
                    if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam,
                                               &dwHWProfFlags, 0,pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                        dwHWProfFlags = 0;
                    }

                    //
                    // Set the Disabled bit.
                    //
                    dwHWProfFlags |= CSCONFIGFLAG_DISABLED;

                    //
                    // Set the profile Flags for this device to Disabled.  Setting this
                    // flag will also take this device off-line, if we're modifying the
                    // current hardware profile.
                    //
                    cr = CM_Set_HW_Prof_Flags_Ex(szDevID,
                                                 lParam,
                                                 dwHWProfFlags,
                                                 CM_SET_HW_PROF_FLAGS_UI_NOT_OK,
                                                 pDeviceInfoSet->hMachine
                                                 );

                    if(cr == CR_NEED_RESTART) {

                        SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_REASON_HW_PROF_DISABLE_FAILED);

                    } else if(cr != CR_SUCCESS) {

                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        goto clean0;
                    }
                }
                break;

            case DICS_PROPCHANGE:
                //
                // Properties have changed, so we need to remove the Devnode, and
                // re-enumerate its parent.
                //
                // Don't remove/reenumerate if reboot/restart is required, or if DI_DONOTCALLCONFIGMG
                // is set (the device may implement some form of 'non-stop' property change mechanism).
                //
                if(dipb->Flags & (DI_DONOTCALLCONFIGMG | DI_NEEDREBOOT | DI_NEEDRESTART)) {
                    action = MSG_LOG_PROPERTYCHANGE_NORESTART;
                } else {
                    TCHAR VetoName[MAX_PATH];
                    PNP_VETO_TYPE VetoType;

                    action = MSG_LOG_PROPERTYCHANGE_RESTART;
                    actionerr = MSG_LOG_PROPERTYCHANGE_RESTART_ERR;

                    CM_Get_Parent_Ex(&dnToReenum, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine);

#ifdef UNICODE
                    cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                                        &VetoType,
                                                        VetoName,
                                                        SIZECHARS(VetoName),
                                                        (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                            ? CM_REMOVE_UI_NOT_OK
                                                            : CM_REMOVE_UI_OK,
                                                        pDeviceInfoSet->hMachine
                                                       );

                    if(cr == CR_SUCCESS) {

                        CM_Reenumerate_DevInst_Ex(dnToReenum, CM_REENUMERATE_SYNCHRONOUS,pDeviceInfoSet->hMachine);
                        DevInfoElem->DevInst = 0;

                        if(CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                                (DEVINSTID)szDevID,
                                                CM_LOCATE_DEVINST_NORMAL,
                                                pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                            //
                            // Make sure the device instance started OK
                            //
                            if(!CheckIfDevStarted(DevInfoElem,pDeviceInfoSet)) {
                                action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                            }

                        } else {
                            //
                            // We couldn't locate the devnode.  We don't need
                            // to request a reboot, because if the devnode ever
                            // shows up again, we should be able to bring it
                            // back on-line just fine.
                            //
                            // Retrieve the devnode as a phantom
                            //
                            CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                                 (DEVINSTID)szDevID,
                                                 CM_LOCATE_DEVINST_PHANTOM,
                                                 pDeviceInfoSet->hMachine
                                                );

                            DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                        }

                        //
                        // Update the caller's buffer to reflect the new device instance handle
                        //
                        DeviceInfoData->DevInst = DevInfoElem->DevInst;


                    } else {
                        //
                        // If the failure was due to a veto, then log
                        // information about who vetoed us.
                        //
                        // SPLOG--write a log entry
                        //
                        if(cr == CR_REMOVE_VETOED) {
                            //
                            // get the LogContext from dipb which should be a pointer
                            // to the appropriate DevInstallParamBlock
                            //
                            _WriteVetoLogEntry(
                                dipb->LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_REMOVE_VETOED_IN_PROPCHANGE,
                                szDevID,
                                VetoName,
                                VetoType);
                        }

                        SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                     MSG_LOG_REBOOT_VETOED_IN_PROPCHANGE);
                        action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                    }
#else
                    //
                    // It appears that some people (who are broken)
                    // do rely on setupapi to install devices
                    // so old code conditionally re-introduced to try and fix them
                    //

                    WriteLogEntry(
                        dipb->LogContext,
                        DRIVER_LOG_ERROR,
                        MSG_LOG_NOT_FOR_THIS_OS,
                        NULL);

                    if(CM_Query_Remove_SubTree(DevInfoElem->DevInst, 0) == CR_SUCCESS) {

                        CM_Get_Parent(&dnToReenum, DevInfoElem->DevInst, 0);
                        CM_Remove_SubTree(DevInfoElem->DevInst, 0);
                        CM_Reenumerate_DevInst(dnToReenum, CM_REENUMERATE_SYNCHRONOUS);
                        DevInfoElem->DevInst = 0;

                        if(CM_Locate_DevInst(&(DevInfoElem->DevInst),
                                             (DEVINSTID)szDevID,
                                             CM_LOCATE_DEVINST_NORMAL) != CR_SUCCESS) {

                            dipb->Flags |= DI_NEEDREBOOT;
                            action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                            //
                            // Retrieve the devinst as a phantom
                            //
                            CM_Locate_DevInst(&(DevInfoElem->DevInst),
                                              (DEVINSTID)szDevID,
                                              CM_LOCATE_DEVINST_PHANTOM
                                             );
                            DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                            //
                            // Update the caller's buffer to reflect the new device instance handle
                            //
                            DeviceInfoData->DevInst = DevInfoElem->DevInst;
                        }

                        //
                        // Make Sure the device instance started OK
                        //
                        if((CM_Get_DevNode_Status(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0) == CR_SUCCESS) && !(ulStatus & DN_STARTED)) {

                            dipb->Flags |= DI_NEEDREBOOT;
                            action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                        }

                    } else {
                        dipb->Flags |= DI_NEEDREBOOT;
                        action = MSG_LOG_PROPERTYCHANGE_RESTART_FAILED;
                    }
#endif
                }
                break;

            case DICS_START:
                action = MSG_LOG_PROPERTYCHANGE_START;
                actionerr = MSG_LOG_PROPERTYCHANGE_START_ERR;

                //
                // DICS_START is always config specific (we enforce this in SetupDiSetClassInstallParams).
                //
                MYASSERT(dwFlags == DICS_FLAG_CONFIGSPECIFIC);

                //
                // Get the Profile Flags.
                //
                if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam, &dwHWProfFlags, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {
                    //
                    // Clear the "don't start" bit.
                    //
                    dwHWProfFlags &= ~CSCONFIGFLAG_DO_NOT_START;
                } else {
                    dwHWProfFlags = 0;
                }

                cr = CM_Set_HW_Prof_Flags_Ex(szDevID, lParam, dwHWProfFlags, 0, pDeviceInfoSet->hMachine);

                if(cr == CR_NEED_RESTART) {
                    //
                    // Since setting/clearing the CSCONFIGFLAG_DO_NOT_START doesn't
                    // automatically effect a change, we should never get here.
                    //
                    SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                 MSG_LOG_REBOOT_REASON_CLEAR_CSCONFIGFLAG_DO_NOT_START);
                    action = MSG_LOG_PROPERTYCHANGE_START_FAILED;

                } else if(cr != CR_SUCCESS) {

                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                    goto clean0;
                }

                //
                // Start the device instance if this is for the current config (ie dwConfigID/lparam == 0)
                //
                if((lParam == 0) ||
                   ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                                      0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                    (HwProfileInfo.HWPI_ulHWProfile == lParam)))
                {
                    //
                    // Try to start the devnode.
                    //
                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {
                        CM_Setup_DevNode_Ex(DevInfoElem->DevInst, CM_SETUP_DEVNODE_READY,pDeviceInfoSet->hMachine);
                        if(!CheckIfDevStarted(DevInfoElem, pDeviceInfoSet)) {
                            action = MSG_LOG_PROPERTYCHANGE_START_FAILED;
                        }
                    } else {
                        action = MSG_LOG_PROPERTYCHANGE_START_FAILED;
                    }
                }
                break;

            case DICS_STOP:
                action = MSG_LOG_PROPERTYCHANGE_STOP;
                actionerr = MSG_LOG_PROPERTYCHANGE_STOP_ERR;

                //
                // DICS_STOP is always config specific (we enforce this in SetupDiSetClassInstallParams).
                //
                MYASSERT(dwFlags == DICS_FLAG_CONFIGSPECIFIC);

                //
                // Get the Profile Flags.
                //
                if(CM_Get_HW_Prof_Flags_Ex(szDevID, lParam, &dwHWProfFlags,
                                           0,pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    dwHWProfFlags = 0;
                }

                //
                // Set the "don't start" bit.
                //
                dwHWProfFlags |= CSCONFIGFLAG_DO_NOT_START;

                cr = CM_Set_HW_Prof_Flags_Ex(szDevID,
                                             lParam,
                                             dwHWProfFlags,
                                             CM_SET_HW_PROF_FLAGS_UI_NOT_OK,
                                             pDeviceInfoSet->hMachine
                                             );

                if(cr == CR_NEED_RESTART) {
                    //
                    // Since setting/clearing the CSCONFIGFLAG_DO_NOT_START doesn't
                    // automatically effect a change, we should never get here.
                    //
                    SetDevnodeNeedsRebootProblem(DevInfoElem,pDeviceInfoSet,
                                                 MSG_LOG_REBOOT_REASON_SET_CSCONFIGFLAG_DO_NOT_START);
                    action = MSG_LOG_PROPERTYCHANGE_STOP_FAILED;

                } else if(cr != CR_SUCCESS) {

                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                    goto clean0;
                }

                //
                // Stop the device instance if this is for the current config (ie dwConfigID/lparam == 0)
                //
                if((lParam == 0) ||
                   ((CM_Get_Hardware_Profile_Info_Ex((ULONG)-1, &HwProfileInfo,
                                                     0,pDeviceInfoSet->hMachine) == CR_SUCCESS) &&
                    (HwProfileInfo.HWPI_ulHWProfile == lParam)))
                {
                    //
                    // Try to stop the devnode.
                    //
                    if(!(dipb->Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

                        TCHAR VetoName[MAX_PATH];
                        PNP_VETO_TYPE VetoType;

                        //
                        // Remove the device instance in order to stop the device.
                        //
#ifdef UNICODE
                        cr = CM_Query_And_Remove_SubTree_Ex(DevInfoElem->DevInst,
                                                            &VetoType,
                                                            VetoName,
                                                            SIZECHARS(VetoName),
                                                            (DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_NOUIONQUERYREMOVE)
                                                                ? CM_REMOVE_UI_NOT_OK
                                                                : CM_REMOVE_UI_OK,
                                                            pDeviceInfoSet->hMachine
                                                           );

                        if(cr == CR_SUCCESS) {
                            //
                            // Device instance successfully removed--now locate it as a phantom.
                            //
                            CM_Locate_DevInst_Ex(&(DevInfoElem->DevInst),
                                              (DEVINSTID)szDevID,
                                              CM_LOCATE_DEVINST_PHANTOM,
                                              pDeviceInfoSet->hMachine);

                            DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                            //
                            // Update the caller's buffer to reflect the new device instance handle.
                            //
                            DeviceInfoData->DevInst = DevInfoElem->DevInst;

                        } else {
                            //
                            // If the failure was due to a veto, then log
                            // information about who vetoed us.
                            //
                            // SPLOG--write out a real log entry
                            //
                            if(cr == CR_REMOVE_VETOED) {
                                //
                                // get the LogContext from dipb which should be a pointer
                                // to the appropriate DevInstallParamBlock
                                //
                                _WriteVetoLogEntry(
                                    dipb->LogContext,
                                    DRIVER_LOG_WARNING,
                                    MSG_LOG_REMOVE_VETOED_IN_STOP,
                                    szDevID,
                                    VetoName,
                                    VetoType);
                            }

                            SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                                 pDeviceInfoSet,
                                                                 MSG_LOG_REBOOT_QR_VETOED_IN_STOP,
                                                                 cr,
                                                                 (ULONG_PTR)_MapCmRetToString(cr)
                                                                 );
                        }
#else
                        //
                        // It appears that some people (who are broken)
                        // do rely on setupapi to install devices
                        // so old code remains for Win9x version of setupapi.dll
                        //
                        WriteLogEntry(
                            dipb->LogContext,
                            DRIVER_LOG_ERROR,
                            MSG_LOG_NOT_FOR_THIS_OS,
                            NULL);

                        //
                        // Remove the device instance in order to stop the device.
                        //
                        if((CM_Query_Remove_SubTree(DevInfoElem->DevInst, CM_QUERY_REMOVE_UI_OK) == CR_SUCCESS) &&
                           (CM_Remove_SubTree(DevInfoElem->DevInst, CM_REMOVE_UI_OK) == CR_SUCCESS)) {
                            //
                            // Device instance successfully removed--now locate it as a phantom.
                            //
                            CM_Locate_DevInst(&(DevInfoElem->DevInst),
                                              (DEVINSTID)szDevID,
                                              CM_LOCATE_DEVINST_PHANTOM
                                             );
                            DevInfoElem->DiElemFlags |= DIE_IS_PHANTOM;
                            //
                            // Update the caller's buffer to reflect the new device instance handle.
                            //
                            DeviceInfoData->DevInst = DevInfoElem->DevInst;

                        } else {
                            dipb->Flags |= DI_NEEDREBOOT;
                            action = MSG_LOG_PROPERTYCHANGE_STOP_FAILED;
                        }
#endif
                    } else {
                        action = MSG_LOG_PROPERTYCHANGE_STOP_FAILED;
                    }
                }
                break;

            default:
                action = actionerr = MSG_LOG_PROPERTYCHANGE_UNKNOWN;
                Err = ERROR_DI_DO_DEFAULT;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if(slot_deviceID) {
        if ((Err == NO_ERROR) || (Err == ERROR_DI_DO_DEFAULT)) {
            //
            // give a +ve affirmation of property change
            //
            WriteLogEntry(
                dipb->LogContext,
                Err ? DRIVER_LOG_ERROR : DRIVER_LOG_INFO,
                action,
                NULL,
                dwStateChange,
                dwFlags,
                lParam
                );
        } else {
            //
            // indicate property change failed, display error
            //
            WriteLogEntry(
                dipb->LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                actionerr,
                NULL,
                dwStateChange,
                dwFlags,
                lParam
                );
            WriteLogError(
                dipb->LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        ReleaseLogInfoSlot(dipb->LogContext,slot_deviceID);
    }
    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
GetNewInfName(
    IN     HWND                    Owner,                  OPTIONAL
    IN     PCTSTR                  OemInfName,
    IN     PCTSTR                  OemInfOriginalName,
    IN     PCTSTR                  OemInfCatName,          OPTIONAL
    OUT    PTSTR                   NewInfName,
    IN     DWORD                   NewInfNameSize,
    OUT    PDWORD                  RequiredSize,
    OUT    PNEWINF_COPYTYPE        CopyNeeded,
    IN     BOOL                    ReplaceOnly,
    IN     PCTSTR                  DeviceDesc,             OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,         OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT    PDWORD                  DriverSigningError,     OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin               OPTIONAL
    )
/*++

Routine Description:

    This routine finds a unique INF name of the form "<systemroot>\Inf\OEM<n>.INF",
    and returns it in the supplied buffer.  It leaves an (empty) file of that
    name in the INF directory, so that anyone else who attempts to generate a
    unique filename won't pick the same name.

    NOTE:  We will search the INF directory to determine if the specified INF is
    already present there based on the criteria outlined for SetupCopyOEMInf.
    If so, then we will return the existing name.  This name may be an
    OEM<n>.INF form, or it may be the same name as the source INF.

Arguments:

    Owner - supplies window to own any signature verification problem dialogs
        that must be displayed.

    OemInfName - Supplies the full pathname of the OEM INF that needs to be
        copied into the Inf directory (under a unique name).

    OemInfOriginalName - Supplies the original (simple) filename of the INF, to
        be used for digital signature verification (i.e., the INF is only known
        to the catalog under its original name).

    OemInfCatName - Optionally, supplies the simple filename of the catalog file
        specified by the OEM INF via a CatalogFile= entry in its [Version]
        section.

    NewInfName - supplies the address of a character buffer to store the unique
        name in.

    NewInfNameSize - Specifies the size, in characters, of the NewInfName buffer.

    RequiredSize - supplies the address of a variable that receives the size, in
        characters, required to store the full new filename.

    CopyNeeded - Supplies the address of an enum variable that is set upon
        successful return to indicate whether or not the OEM INF actually needs
        to be copied (and whether or not the previously-existing INF, if found,
        is zero-length.  This variable will be set to one of the following
        values:

        NewInfCopyNo         - no need to copy--INF already present in destination
        NewInfCopyYes,       - new INF placeholder created--need to copy real INF
        NewInfCopyZeroLength - previously-existing zero-length INF match found

    ReplaceOnly - If this flag is set, then this routine will fail if it doesn't
        find that the INF/CAT is already installed.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  Used when calling pSetupHandleFailedVerification, if necessary.

    Flags - supplies flags which alter the behavior of the routine.  May be a
        combination of the following values:

        SCOI_NO_UI_ON_SIGFAIL - indicates whether user should be prompted (per
                                DriverSigningPolicy) if a digital signature
                                failure is encountered.  Used when calling
                                pSetupHandleFailedVerification, if necessary.

        SCOI_NO_ERRLOG_ON_MISSING_CATALOG - if there's a signature verification
                                            failure due to the INF lacking a
                                            CatalogFile= entry, then that error
                                            will be ignored if this flag is set
                                            (no UI will be given, and no log
                                            entry will be generated).

        SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES - Install the INF and CAT under
                                               their original (current) names
                                               (i.e., don't generate a unique
                                               oem<n>.inf/cat name).  Used only
                                               for exception INFs.

        SCOI_ABORT_IF_UNSIGNED - If the INF is unsigned (and user wants to copy
                                 it anyway, or policy is Ignore), then _don't_
                                 copy the INF and instead return the error
                                 ERROR_SET_SYSTEM_RESTORE_POINT.  This gives
                                 the caller a chance to set a system restore
                                 point prior to installing the unsigned package.

        SCOI_TRY_UPDATE_PNF    - If an existing PNF cannot be updated, don't
                                 consider it fatal.

    AltCatalogFile - Optionally, supplies the full pathname of a catalog file to
        be installed and used for verification of the INF in cases where the INF
        doesn't specify a CatalogFile= entry (i.e., when the OemInfCatName
        parameter is not specified.

        If this parameter is specified (and OemInfCatName isn't specified), then
        this catalog will be used to validate the INF, and if successful, the
        catalog will be installed into the system using its current name (thus
        overwriting any existing catalog having that name).  Nothing more will
        be done with the INF--we won't even create a zero-length placeholder for
        it in this case.

    AltPlatformInfo - Optionally, supplies alternate platform information to be
        used in digital signature verification instead of the default (native)
        platform info.

    DriverSigningError - Optionally, supplies the address of a variable that
        receives the error encountered when attempting to verify the digital
        signature of either the INF or associated catalog.  If no digital
        signature problems were encountered, this is set to NO_ERROR.  (Note
        that this value can come back as NO_ERROR, yet GetNewInfName still
        failed for some other reason).

    CatalogFilenameOnSystem - receives the fully-qualified path of the catalog
        file within the catalog store where this INF's catalog file was
        installed to. This buffer should be at least MAX_PATH bytes (ANSI
        version) or chars (Unicode version).

    LogContext - supplies a LogContext to be used throughout the function.

    hCatAdmin - optionally, supplies the address of an HCATADMIN handle.  If
        the handle pointed to is NULL, a handle will be acquired (if possible)
        via CryptCATAdminAcquireContext and returned to the caller.  If the
        handle pointed to is non-NULL, then that handle will be used for any
        validation done via this routine.  If the pointer itself is NULL, then
        an hCatAdmin will be acquired for the duration of this call, and
        released before returning.

        NOTE: it is the caller's responsibility to free the crypto context
        handle returned by this routine by calling CryptCATAdminReleaseContext.
        This handle may be opened in either success or failure cases, so the
        caller must check for non-NULL returned handle in both cases.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise, it is a
    Win32 error code.

--*/
{
    INT i;
    HANDLE h;
    DWORD Err, SavedErr;
    TCHAR lpszNewName[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    PTSTR FilenamePart;
    DWORD OemInfFileSize, CatalogFileSize;
    HANDLE OemInfFileHandle, OemInfMappingHandle;
    HANDLE CatalogFileHandle, CatalogMappingHandle;
    PVOID OemInfBaseAddress, CatalogBaseAddress;
    DWORD CurInfFileSize;
    HANDLE CurInfFileHandle, CurInfMappingHandle;
    PVOID CurInfBaseAddress;
    BOOL FileOfSameNameExists, MoreInfsToCheck;
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    BOOL FoundMatchingInf;
    TCHAR PathBuffer[MAX_PATH];
    TCHAR CatalogName[MAX_PATH];
    SetupapiVerifyProblem Problem = SetupapiVerifyNoProblem;
    PCTSTR ProblemFile;
    DWORD NumCatalogsConsidered;
    PTSTR LastResortInf;
    BOOL FileNewlyCreated;

    //
    // Initially, assume that the specified INF isn't already present in the Inf
    // directory.
    //
    *CopyNeeded = NewInfCopyYes;

    //
    // Initialize the driver signing error output parameter to success, and set
    // the CatalogFilenameOnSystem character buffer to an empty string.
    //
    if(DriverSigningError) {
        *DriverSigningError = NO_ERROR;
    }
    *CatalogFilenameOnSystem = TEXT('\0');

    if(OemInfCatName || !AltCatalogFile) {
        //
        // The INF has a CatalogFile= entry, or we don't have an override.  This
        // means we want to do the 'normal' behavior of looking for an existing
        // match in the INF directory, using default rules for which catalog
        // files we'll consider during validation, etc.
        //
        // Examine all the existing OEM INFs in the Inf directory, to see if
        // this INF already exists there.  If so, we'll just return the name of
        // the  previously-existing file.
        //
        lstrcpyn(lpszNewName, InfDirectory, SIZECHARS(lpszNewName));
        pSetupConcatenatePaths(lpszNewName, pszOemInfWildcard, SIZECHARS(lpszNewName), NULL);

        //
        // If we're supposed to install the INF and CAT under their original
        // names, then we don't want to look at any of the oem<n>.inf files.
        //
        if(Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
            FindHandle = INVALID_HANDLE_VALUE;
        } else {
            FindHandle = FindFirstFile(lpszNewName, &FindData);
        }

        //
        // Now reuse our buffer to look for an INF in the Inf directory having
        // the same name as our OEM INF's original name.
        //
        FilenamePart = (PTSTR)pSetupGetFileTitle(lpszNewName);
        lstrcpy(FilenamePart, OemInfOriginalName);

        FileOfSameNameExists = GetFileAttributesEx (lpszNewName, GetFileExInfoStandard, &FileAttribData);

        if(FileOfSameNameExists && !OemInfCatName) {
            //
            // We can try to match up an OEM INF with a system INF having the same
            // name even if the INF doesn't specify a CatalogFile= entry, but _not_
            // if the system INF is zero-length!
            //
            if(!FileAttribData.nFileSizeLow) {
                FileOfSameNameExists = FALSE;
            }
        }

        if((FindHandle != INVALID_HANDLE_VALUE) || FileOfSameNameExists) {
            //
            // We have at least one INF to compare against, so open our source INF in preparation.
            //
            if(pSetupOpenAndMapFileForRead(OemInfName,
                                     &OemInfFileSize,
                                     &OemInfFileHandle,
                                     &OemInfMappingHandle,
                                     &OemInfBaseAddress) == NO_ERROR) {

                if(OemInfCatName) {
                    //
                    // INF has an associated catalog--map it into memory for
                    // subsequent comparisons with existing installed catalogs.
                    //
                    lstrcpy(CatalogName, OemInfName);
                    lstrcpy((PTSTR)pSetupGetFileTitle(CatalogName), OemInfCatName);

                    if(pSetupOpenAndMapFileForRead(CatalogName,
                                             &CatalogFileSize,
                                             &CatalogFileHandle,
                                             &CatalogMappingHandle,
                                             &CatalogBaseAddress) != NO_ERROR) {
                        //
                        // Act as if the INF specified no CatalogFile.  This
                        // will allow us to match up with any OEM<n>.INF that
                        // binary-compares with this one.  We will consider
                        // this a digital signature verification failure,
                        // however.  (Refer to code below that explicitly fails
                        // OEM<n>.INF files that don't have a CatalogFile
                        // entry.)
                        //
                        // Note, also, in this case we don't want to consider
                        // a previously-existing INF in the Inf directory that
                        // has this OEM INF's original name.  That's because
                        // this would trip us up later because we'd believe we
                        // could do global validation on it (i.e., we'd think
                        // it was a system INF).
                        //

                        CatalogBaseAddress = NULL; // don't try to unmap and close later

                        if(FindHandle == INVALID_HANDLE_VALUE) {
                            //
                            // There are no OEM<n>.INF files to check--go ahead
                            // and bail.
                            //
                            goto FinishedCheckingOemInfs;
                        }

                        //
                        // There are some OEM<n>.INF files to check--make sure
                        // we _don't_ consider the originally-named file in
                        // %windir%\Inf, if it happens to exist.
                        //
                        FileOfSameNameExists = FALSE;

                        //
                        // Now make it look like the INF had no CatalogFile=
                        // entry in the first place.
                        //
                        OemInfCatName = NULL;
                        CatalogFileSize = 0;
                    }

                } else {
                    //
                    // INF didn't have a CatalogFile= entry in its version
                    // section.  This means we'll do global validation if we
                    // find an existing INF having this name that binary-compares
                    // identical.  If the verification succeeds, then we'll consider
                    // this a match.  Basically, this means you'll be able to
                    // re-install from system INFs, even if you point at them
                    // elsewhere (e.g., you point back at system.inf on the
                    // distribution media, but system.inf is already installed in
                    // your %windir%\Inf directory).
                    //
                    // If our INF doesn't specify a CatalogFile= entry, then
                    // we'll drop back to our pre-driver-signing behavior where
                    // we'll simply check to see if the INF's binary compare.
                    // If they do, then we know that there is no INF installed
                    // based on that matching INF's OEM name, thus we'll just
                    // drop out of the search loop and consider this a driver
                    // signing failure (which it is).
                    //
                    CatalogBaseAddress = NULL;
                    CatalogFileSize = 0;
                }

                LastResortInf = NULL;

                do {
                    if(FileOfSameNameExists) {
                        if(FileAttribData.nFileSizeHigh) {
                            goto CheckNextOemInf;
                        }
                        if(FileAttribData.nFileSizeLow &&
                           (FileAttribData.nFileSizeLow != OemInfFileSize)) {

                            goto CheckNextOemInf;
                        }
                        //
                        // Note:  We will consider a zero-length system INF that has
                        // the same name as our OEM INF, even if our OEM INF doesn't
                        // have a CatalogFile= entry in its version section.  This
                        // allows us to re-use this name as long as we find our
                        // catalog is already installed.
                        //
                        CurInfFileSize = FileAttribData.nFileSizeLow;

                    } else {
                        if(FindData.nFileSizeHigh) {
                            goto CheckNextOemInf;
                        }
                        if(FindData.nFileSizeLow &&
                           (FindData.nFileSizeLow != OemInfFileSize)) {

                            goto CheckNextOemInf;
                        }
                        CurInfFileSize = FindData.nFileSizeLow;

                        //
                        // Build the fully-qualified path to the INF being compared.
                        //
                        lstrcpy(FilenamePart, FindData.cFileName);
                    }

                    //
                    // If the INF isn't zero-length, then map it into memory to
                    // see if it matches our OEM INF.
                    //
                    if(CurInfFileSize) {

                        if(pSetupOpenAndMapFileForRead(lpszNewName,
                                                 &CurInfFileSize,
                                                 &CurInfFileHandle,
                                                 &CurInfMappingHandle,
                                                 &CurInfBaseAddress) == NO_ERROR) {

                            //
                            // Surround the following in try/except, in case we get an inpage error.
                            //
                            try {
                                //
                                // We've found a potential match.
                                //
                                FoundMatchingInf = !memcmp(OemInfBaseAddress,
                                                           CurInfBaseAddress,
                                                           OemInfFileSize
                                                          );

                            } except(EXCEPTION_EXECUTE_HANDLER) {
                                FoundMatchingInf = FALSE;
                            }

                            pSetupUnmapAndCloseFile(CurInfFileHandle,
                                              CurInfMappingHandle,
                                              CurInfBaseAddress
                                             );
                        } else {
                            FoundMatchingInf = FALSE;
                        }

                        if(!FoundMatchingInf) {
                            goto CheckNextOemInf;
                        }

                        //
                        // If this is an OEM*.INF name and the INF has no
                        // CatalogFile= entry, then we've found our match.  Set
                        // up our driver signing problem variables to indicate
                        // that there was an INF failure (since there was no
                        // catalog.
                        //
                        if(!OemInfCatName && !FileOfSameNameExists) {
                            *CopyNeeded = NewInfCopyNo;
                            Problem = SetupapiVerifyInfProblem;
                            ProblemFile = OemInfName;
                            Err = ERROR_NO_CATALOG_FOR_OEM_INF;
                            //
                            // go to end of loop (we'll drop out since we've
                            // found a match).
                            //
                            goto CheckNextOemInf;
                        }

                    } else {
                        //
                        // The current INF we're considering for a match is
                        // zero-length.  This won't work for us if the INF we're
                        // searching for doesn't have a CatalogFile= entry, and
                        // this isn't an INF having the same name.
                        //
                        if(!OemInfCatName && !FileOfSameNameExists) {
                            goto CheckNextOemInf;
                        }
                    }

                    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                        //
                        // We aren't using crypto, so if the file we found
                        // isn't zero-length, we've found our match.
                        //
                        if(CurInfFileSize) {
                            Err = NO_ERROR;
                        } else {
                            //
                            // File is zero-length.  Keep looking.
                            //
                            goto CheckNextOemInf;
                        }

                    } else {
                        //
                        // OK, the files binary compare OK (unless the one
                        // we're currently examining is zero length!), but
                        // we're not out of the woods yet!  If the INF we're
                        // examining had a CatalogFile= entry, then generate
                        // the catalog name to be used for verification (based
                        // on the filename of the INF we're examining).
                        //
                        if(OemInfCatName) {
                            lstrcpy(CatalogName, FilenamePart);
                            lstrcpy(_tcsrchr(CatalogName, TEXT('.')), pszCatSuffix);
                        }

                        //
                        // Now verify the INF's signature against the specified
                        // catalog (or globally if the INF doesn't specify a
                        // catalog).
                        //
                        Err = _VerifyFile(LogContext,
                                          hCatAdmin,
                                          NULL,
                                          (OemInfCatName ? CatalogName : NULL),
                                          CatalogBaseAddress,
                                          CatalogFileSize,
                                          OemInfOriginalName,
                                          OemInfName,
                                          &Problem,
                                          PathBuffer,
                                          FALSE,
                                          AltPlatformInfo,
                                          (VERIFY_FILE_IGNORE_SELFSIGNED
                                           | VERIFY_FILE_USE_OEM_CATALOGS
                                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                          CatalogFilenameOnSystem,
                                          &NumCatalogsConsidered,
                                          NULL,
                                          NULL
                                         );
                    }

                    if(Err == NO_ERROR) {
                        //
                        // We've found this INF/CAT combination already installed,
                        // and the signatures check out!
                        //
                        *CopyNeeded = CurInfFileSize ? NewInfCopyNo
                                                     : NewInfCopyZeroLength;

                        Problem = SetupapiVerifyNoProblem;

                    } else {
                        //
                        // If we failed because of SetupapiVerifyCatalogProblem,
                        // then our supplied catalog image must've matched up with
                        // an installed catalog (albeit, a bogus one), and PathBuffer
                        // will tell us that catalog's name.
                        //
                        // If we failed because of SetupapiVerifyFileProblem, then
                        // there are two possibilities:
                        // 1. Our catalog was fine (it's just the INF that's messed
                        //    up), and CatalogFilenameOnSystem will be filled in
                        //    with the name of the installed catalog that matches
                        //    ours.
                        // 2. We didn't find our catalog among the ones
                        //    enumerated based on the OEM INF's hash.  In that
                        //    case, CatalogFilenameOnSystem will be an empty
                        //    string.
                        //
                        if((Problem == SetupapiVerifyFileProblem) &&
                           !(*CatalogFilenameOnSystem)) {
                            //
                            // We didn't find a catalog match--move on to the next
                            // INF (note: there still might be a match later on,
                            // because if the INF specified a CatalogFile= entry, we
                            // must match on _both_ the catalog filename _and_ the
                            // catalog's image.
                            //
                            // However, if the number of catalogs we considered when
                            // examining this INF/CAT combination was zero, that
                            // means that there is no installed catalog for this
                            // INF, thus we can use it if we don't find anything
                            // better.  The reason why we'd rather not use this INF
                            // is that it obviously wasn't properly installed, hence
                            // the original source name and location info is almost
                            // certainly bogus.  (One more thing--make sure the
                            // catalog isn't zero length.  If it is, then that
                            // definitely implies that this was being used as a
                            // placeholder by setupapi, and we don't want to touch
                            // it!)
                            //
                            if(!NumCatalogsConsidered &&
                               !LastResortInf &&
                               CurInfFileSize)
                            {
                                LastResortInf = DuplicateString(lpszNewName);
                                SavedErr = Err;
                            }
                            goto CheckNextOemInf;
                        }

                        //
                        // At this point, we know that the INF and CAT are installed
                        // on the user's system, but that one of them has a problem
                        // (indicated by our Problem value).
                        // Drop out of the search here, and then handle any warnings
                        // that need to go to the user.
                        //
                        ProblemFile = PathBuffer;
                        *CopyNeeded = CurInfFileSize ? NewInfCopyNo
                                                     : NewInfCopyZeroLength;

                    }

CheckNextOemInf:

                    if(FileOfSameNameExists) {
                        FileOfSameNameExists = FALSE;
                        MoreInfsToCheck = (FindHandle != INVALID_HANDLE_VALUE);
                    } else {
                        MoreInfsToCheck = FindNextFile(FindHandle, &FindData);
                    }

                } while((*CopyNeeded == NewInfCopyYes) && MoreInfsToCheck);

                if(LastResortInf) {

                    if(*CopyNeeded == NewInfCopyYes) {
                        //
                        // We didn't find any better INF, so we'll try to use the
                        // incorrectly-installed INF.
                        //
                        // If this INF doesn't specify a CatalogFile= entry, then
                        // we'll just automatically set up the digital signature
                        // verification failure parameters, because that's the state
                        // we're in.
                        //
                        if(!OemInfCatName) {
                            Err = SavedErr;
                            Problem = SetupapiVerifyInfProblem;
                            lstrcpy(PathBuffer, OemInfName);
                            ProblemFile = PathBuffer;
                        } else {
                            //
                            // Attempt to verify our OEM INF's catalog, and if
                            // it verifies, then install it.  We clear the
                            // problem set earlier, since we really don't have
                            // a problem (yet).  If we do encounter a failure
                            // below, we'll set the failure as appropriate.
                            //
                            Problem = SetupapiVerifyNoProblem;

                            lstrcpy(CatalogName, OemInfName);
                            *((PTSTR)pSetupGetFileTitle(CatalogName)) = TEXT('\0');
                            pSetupConcatenatePaths(CatalogName,
                                             OemInfCatName,
                                             SIZECHARS(CatalogName),
                                             NULL
                                            );

                            Err = _VerifyFile(LogContext,
                                              hCatAdmin,
                                              NULL,
                                              CatalogName,
                                              NULL,
                                              0,
                                              OemInfOriginalName,
                                              OemInfName,
                                              &Problem,
                                              PathBuffer,
                                              FALSE,
                                              AltPlatformInfo,
                                              (VERIFY_FILE_IGNORE_SELFSIGNED
                                               | VERIFY_FILE_USE_OEM_CATALOGS
                                               | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL
                                             );

                            if(Err != NO_ERROR) {

                                if(Problem != SetupapiVerifyCatalogProblem) {

                                    MYASSERT(Problem != SetupapiVerifyNoProblem);
                                    //
                                    // If the problem was not a catalog problem,
                                    // then it's an INF problem (the _VerifyFile
                                    // routine doesn't know the file we passed
                                    // it is an INF).
                                    //
                                    Problem = SetupapiVerifyInfProblem;
                                }
                                ProblemFile = PathBuffer;

                            } else {
                                //
                                // Only attempt to install a catalog if we're
                                // not running in "minimal embedded" mode...
                                //
                                if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {
                                    //
                                    // Take the INF's new, unique name and
                                    // generate a unique catalog filename under
                                    // setupapi's namespace by simply replacing
                                    // ".INF" with ".CAT".
                                    //
                                    lstrcpy(PathBuffer, pSetupGetFileTitle(LastResortInf));
                                    lstrcpy(_tcsrchr(PathBuffer, TEXT('.')),
                                            pszCatSuffix
                                           );

                                    //
                                    // At this point, PathBuffer contains the
                                    // basename to be used for the catalog on
                                    // the system, and CatalogName is the fully-
                                    // qualified path of the catalog file in
                                    // the oem location.
                                    //
                                    Err = pSetupInstallCatalog(
                                              CatalogName,
                                              PathBuffer,
                                              CatalogFilenameOnSystem
                                              );

                                    if(Err != NO_ERROR) {
                                        Problem = SetupapiVerifyCatalogProblem;
                                        ProblemFile = CatalogName;
                                    }
                                }
                            }
                        }

                        lstrcpy(lpszNewName, LastResortInf);

                        //
                        // We will never consider a zero-length INF as a last-resort
                        // candidate, thus if we get here we know the previously-
                        // existing INF wasn't zero-length.
                        //
                        *CopyNeeded = NewInfCopyNo;
                    }
                    MyFree(LastResortInf);
                }

FinishedCheckingOemInfs:
                if(CatalogBaseAddress) {
                    pSetupUnmapAndCloseFile(CatalogFileHandle, CatalogMappingHandle, CatalogBaseAddress);
                }
                pSetupUnmapAndCloseFile(OemInfFileHandle, OemInfMappingHandle, OemInfBaseAddress);
            }

            if(FindHandle != INVALID_HANDLE_VALUE) {
                FindClose(FindHandle);
            }
        }

    } else {
        //
        // The INF has no CatalogFile= entry, and we have an alternate catalog
        // to use.  Validate our INF using the specified alternate catalog.
        //
        Err = _VerifyFile(LogContext,
                          hCatAdmin,
                          NULL,
                          AltCatalogFile,
                          NULL,
                          0,
                          OemInfOriginalName,
                          OemInfName,
                          &Problem,
                          PathBuffer,
                          FALSE,
                          AltPlatformInfo,
                          (VERIFY_FILE_IGNORE_SELFSIGNED
                           | VERIFY_FILE_USE_OEM_CATALOGS
                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                          NULL,
                          NULL,
                          NULL,
                          NULL
                         );

        if(Err != NO_ERROR) {

            if(Problem != SetupapiVerifyCatalogProblem) {

                MYASSERT(Problem != SetupapiVerifyNoProblem);
                //
                // If the problem was not a catalog problem,
                // then it's an INF problem (the _VerifyFile
                // routine doesn't know the file we passed
                // it is an INF).
                //
                Problem = SetupapiVerifyInfProblem;
            }
            ProblemFile = PathBuffer;

        } else {
            //
            // Only attempt to install a catalog if we're not running in
            // "minimal embedded" mode...
            //
            if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {

                Err = pSetupInstallCatalog(
                          AltCatalogFile,
                          pSetupGetFileTitle(AltCatalogFile),
                          CatalogFilenameOnSystem
                          );

                if(Err != NO_ERROR) {
                    Problem = SetupapiVerifyCatalogProblem;
                    ProblemFile = AltCatalogFile;
                }
            }
        }

        //
        // An INF copy is never needed when we're using an alternate catalog.
        //
        *CopyNeeded = NewInfCopyNo;

        //
        // Setup lpszNewName to be the same as the INF's present full pathname.
        // Since we didn't copy this into the INF directory (or even create a
        // zero-length placeholder), the only reasonable path to return is the
        // INF's current full pathname.
        //
        lstrcpy(lpszNewName, OemInfName);
    }

    if(*CopyNeeded != NewInfCopyYes) {
        //
        // Then this INF already exists in the Inf directory (or at least its
        // zero-length placeholder does), and its associated catalog (if it has
        // one) is already installed, too.  If either of these files had a
        // signature verification problem, then inform the user now (based on
        // policy).
        //
        if(Problem != SetupapiVerifyNoProblem) {
            BOOL result;

            MYASSERT(Err != NO_ERROR);
            if(DriverSigningError) {
                *DriverSigningError = Err;
            }

            if(((Err == ERROR_NO_CATALOG_FOR_OEM_INF) && (Flags & SCOI_NO_ERRLOG_ON_MISSING_CATALOG)) ||
               (Flags & SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT)) {
                //
                // We shouldn't do any UI/logging because of one of the two
                // following reasons:
                //
                // 1.  This may be a valid INF after all (i.e., if it uses
                //     layout.inf for source media info, or doesn't copy any
                //     files at all).
                //
                // 2.  We were asked not to.  The public API, SetupCopyOEMInf
                //     doesn't want/need anything to happen here, because the
                //     INF is already present, and we haven't really done
                //     anything (except potentially update the source path
                //     information contained in the PNF), thus there's no
                //     reason to make noise about this.
                //
                result = TRUE;

            } else {
                result = pSetupHandleFailedVerification(
                             Owner,
                             Problem,
                             ProblemFile,
                             DeviceDesc,
                             DriverSigningPolicy,
                             (Flags & SCOI_NO_UI_ON_SIGFAIL),
                             Err,
                             LogContext,
                             NULL,
                             NULL
                            );

                if(result) {
                    //
                    // The user wants to proceed with the unsigned installation
                    // (or policy is Ignore, so they weren't even informed).
                    // If the caller wants a chance to set a system restore
                    // point prior to doing any unsigned installations, then we
                    // abort now with a "special" error code that tells them
                    // what to do...
                    //
                    if(Flags & SCOI_ABORT_IF_UNSIGNED) {
                        return ERROR_SET_SYSTEM_RESTORE_POINT;
                    }
                }
            }

            if (!result) {
                return Err;
            }
        }

        //
        // There was no problem, or the user elected to install in spite of a
        // problem, so return the INF name we found.
        //
        *RequiredSize = lstrlen(lpszNewName) + 1;

        if(*RequiredSize < NewInfNameSize) {
            CopyMemory(NewInfName, lpszNewName, *RequiredSize * sizeof(TCHAR));
            return NO_ERROR;
        } else {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    //
    // If we're in 'replace only' mode, then the fact that we didn't find the
    // INF/CAT already installed above means we should fail with
    // ERROR_FILE_NOT_FOUND.
    //
    if(ReplaceOnly) {
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // OK, so the INF isn't presently in the Inf directory--find a unique name
    // for it.  (Note: We'll go into the loop below even if we're meant to be
    // installing the INF and CAT under their original names.  We'll just skip
    // the auto-generation part, and then we'll break out of the loop once
    // we've made the attempt at INF/CAT installation.)
    //
    for(i = 0; i < 100000; i++) {

        if(Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
            lstrcpyn(lpszNewName, InfDirectory, MAX_PATH);
            pSetupConcatenatePaths(lpszNewName, OemInfOriginalName, SIZECHARS(lpszNewName), NULL);
        } else {
            wsprintf(lpszNewName, pszOemInfGenerate, InfDirectory, i);
        }

        if((h = CreateFile(lpszNewName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) != INVALID_HANDLE_VALUE) {
            //
            // Then we either opened an existing file (that we need to leave
            // alone, unless we're replacing it with a new exception INF), or
            // we created a new file (in which case, we've found our unique
            // name).  These two cases are identified by the value of
            // GetLastError().
            //
            Err = GetLastError();

            //
            // Before we decide what to do, close the file handle.
            //
            CloseHandle(h);

            FileNewlyCreated = (Err != ERROR_ALREADY_EXISTS);

            if(FileNewlyCreated || (Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES)) {
                //
                // We've either (a) created a new file, or (b) found that we
                // can replace an existing exception INF.  Determine whether
                // the filename fits in the caller-supplied buffer.
                //
                *RequiredSize = lstrlen(lpszNewName) + 1;

                if(*RequiredSize < NewInfNameSize) {
                    //
                    // OK, we have a unique filename, and the caller-
                    // supplied buffer is large enough to hold that name.
                    //
                    // get LastKnownGood in on the loop
                    // if this is a newly created file, it will get deleted on revert
                    //

                    pSetupDoLastKnownGoodBackup(NULL,
                                                lpszNewName,
                                                SP_LKG_FLAG_FORCECOPY|SP_LKG_FLAG_DELETEIFNEW|(FileNewlyCreated?SP_LKG_FLAG_DELETEEXISTING:0),
                                                LogContext);

                    //
                    // Now we need to verify the INF and its associated
                    // CAT.
                    //
                    if(!OemInfCatName) {
                        //
                        // An OEM INF without a CatalogFile= entry is
                        // automatically a digital signature failure!
                        //
                        Err = ERROR_NO_CATALOG_FOR_OEM_INF;
                        Problem = SetupapiVerifyInfProblem;
                        ProblemFile = OemInfName;
                    } else {
                        //
                        // Now verify the catalog file and INF, which must
                        // both be in the same directory.
                        //
                        lstrcpy(CatalogName, OemInfName);
                        *((PTSTR)pSetupGetFileTitle(CatalogName)) = TEXT('\0');
                        pSetupConcatenatePaths(CatalogName, OemInfCatName, SIZECHARS(CatalogName), NULL);

                        Err = _VerifyFile(LogContext,
                                          hCatAdmin,
                                          NULL,
                                          CatalogName,
                                          NULL,
                                          0,
                                          OemInfOriginalName,
                                          OemInfName,
                                          &Problem,
                                          PathBuffer,
                                          FALSE,
                                          AltPlatformInfo,
                                          (VERIFY_FILE_IGNORE_SELFSIGNED
                                           | VERIFY_FILE_USE_OEM_CATALOGS
                                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL
                                         );

                        if(Err != NO_ERROR) {

                            if(Problem != SetupapiVerifyCatalogProblem) {

                                MYASSERT(Problem != SetupapiVerifyNoProblem);
                                //
                                // If the problem was not a catalog problem,
                                // then it's an INF problem (the _VerifyFile
                                // routine doesn't know the file we passed
                                // it is an INF).
                                //
                                Problem = SetupapiVerifyInfProblem;
                            }

                            ProblemFile = PathBuffer;

                        } else {
                            //
                            // Only attempt to install a catalog if we're not
                            // running in "minimal embedded" mode...
                            //
                            if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {
                                //
                                // Take the INF's new, unique name and generate
                                // a unique catalog filename under setupapi's
                                // namespace by simply replacing ".INF" with
                                // ".CAT".
                                //
                                lstrcpy(PathBuffer, pSetupGetFileTitle(lpszNewName));
                                lstrcpy(_tcsrchr(PathBuffer, TEXT('.')),
                                        pszCatSuffix
                                       );

                                //
                                // At this point, PathBuffer contains the
                                // basename to be used for the catalog on the
                                // system, and CatalogName is the fully-
                                // qualified path of the catalog file in the oem
                                // location.
                                //
                                Err = pSetupInstallCatalog(
                                          CatalogName,
                                          PathBuffer,
                                          CatalogFilenameOnSystem
                                          );

                                if(Err != NO_ERROR) {
                                    Problem = SetupapiVerifyCatalogProblem;
                                    ProblemFile = CatalogName;
                                }
                            }
                        }
                    }

                    //
                    // At this point if Err isn't NO_ERROR, then we
                    // encountered some signature verification failure (or
                    // were unable to install the catalog).  Prompt the
                    // user (based on policy) about what they want to do.
                    //
                    if(Err != NO_ERROR) {

                        if(DriverSigningError) {
                            *DriverSigningError = Err;
                        }

                        //
                        // Unless the error was due to missing CatalogFile=
                        // entry in the INF (and we were instructed to ignore
                        // such errors), then we need to handle the verification
                        // failure.
                        //
                        if((Err != ERROR_NO_CATALOG_FOR_OEM_INF) ||
                           !(Flags & SCOI_NO_ERRLOG_ON_MISSING_CATALOG)) {

                            if(!pSetupHandleFailedVerification(
                                    Owner,
                                    Problem,
                                    ProblemFile,
                                    DeviceDesc,
                                    DriverSigningPolicy,
                                    (Flags & SCOI_NO_UI_ON_SIGFAIL),
                                    Err,
                                    LogContext,
                                    NULL,
                                    NULL))
                            {
                                if(FileNewlyCreated) {
                                    //
                                    // Delete the INF (and PNF and CAT, if they
                                    // exist).
                                    //
                                    pSetupUninstallOEMInf(lpszNewName,
                                                          LogContext,
                                                          SUOI_FORCEDELETE,
                                                          NULL
                                                         );
                                }
                                return Err;
                            }

                            //
                            // The user wants to proceed with the unsigned
                            // installation (or policy is Ignore, so they
                            // weren't even informed).  If the caller wants a
                            // chance to set a system restore point prior to
                            // doing any unsigned installations, then we abort
                            // now with a "special" error code that tells them
                            // what to do...
                            //
                            if(Flags & SCOI_ABORT_IF_UNSIGNED) {

                                if(FileNewlyCreated) {
                                    //
                                    // Delete the INF (and PNF and CAT, if they
                                    // exist)--we don't want these files to be
                                    // present when the system restore point is
                                    // created.
                                    //
                                    pSetupUninstallOEMInf(lpszNewName,
                                                          LogContext,
                                                          SUOI_FORCEDELETE,
                                                          NULL
                                                         );
                                }
                                return ERROR_SET_SYSTEM_RESTORE_POINT;
                            }
                        }
                    }

                    //
                    // Either there was no problem, or the user opted to
                    // ignore the problem (or was never told, in the case of
                    // the 'ignore' policy).
                    //
                    CopyMemory(NewInfName, lpszNewName, *RequiredSize * sizeof(TCHAR));

                    //
                    // If we're installing an unsigned INF, then clean out any
                    // existing CAT that might've previously been installed.
                    //
                    if(Err != NO_ERROR) {
                        lstrcpy(_tcsrchr(lpszNewName, TEXT('.')), pszCatSuffix);
                        pSetupUninstallCatalog(pSetupGetFileTitle(lpszNewName));
                    }

                    return NO_ERROR;
                } else {
                    //
                    // The caller's buffer isn't large enough.  We have to
                    // delete the file we created.  We don't want to delete the
                    // file, however, if it already existed (i.e., for the
                    // exception INF case).
                    //
                    if(FileNewlyCreated) {
                        pSetupUninstallOEMInf(lpszNewName, LogContext, SUOI_FORCEDELETE, NULL);
                    }
                    return ERROR_INSUFFICIENT_BUFFER;
                }
            }

        } else {
            //
            // We failed to open/create this oem inf.  Check to see if the
            // failure was access-denied.  If so, then it's possible that the
            // INF directory is ACL'ed such that we can't write to it.  We want
            // to bail in this case, otherwise we're going to spend a bunch of
            // time trying all 100,000 oem<n>.inf filenames (with each one
            // failing) before we give up.
            //
            // We check for this case by seeing if the file we were trying to
            // create/open already exists.  If so, then we want to keep going
            // (e.g., maybe the individual file was ACL'ed, etc.).  If, however,
            // the file doesn't exist, then this indicates that we can't create
            // files in the directory, and we should bail now.
            //
            Err = GetLastError();

            if(Flags & SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
                //
                // If we're installing an exception INF, we don't care what the
                // error is--we gotta bail.
                //
                return Err;

            } else if((Err == ERROR_ACCESS_DENIED) && !FileExists(lpszNewName, NULL)) {

                return ERROR_ACCESS_DENIED;
            }
        }
    }

    //
    // We didn't find a unique OEM INF name to use!
    //
    return ERROR_FILE_NOT_FOUND;
}


DWORD
InstallHW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  HINF             hDeviceInf,
    IN  PCTSTR           szSectionName,
    OUT PBOOL            DeleteDevKey
    )
/*++

Routine Description:

    This routine appends a ".Hw" to the end of the install section name for the
    specified device, and attempts to find that section name in the specified INF.
    If found, it does a performs a registry installation against it.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to call
        SetupInstallFromInfSection for.

    DeviceInfoData - Supplies the address of a device information element structure
        for which the installation action is to be performed.

    hDeviceInf - Supplies a handle to the opened INF containing the device install
        section.

    szSectionName - Supplies the address of a string specifying the install section
        name for this device.  This string will be appended with ".Hw" to create
        the corresponding hardware section name.

    DeleteDevKey - Supplies the address of a variable that receives a boolean value
        indicating whether or not a user-accessible device key was created as a
        result of calling this routine.  This output may be used to indicate whether
        or not the key should be destroyed if the caller encounters some error later
        on that requires clean-up.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise it is an
    ERROR_* code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    HKEY hKey;
    DWORD Err;
    TCHAR szHwSection[MAX_SECT_NAME_LEN];
    INFCONTEXT InfContext;
    PTSTR szInfFileName;
    PTSTR NeedsSectionList, CurInstallSection;
    BOOL b;
    REGMOD_CONTEXT RegContext;

    //
    // Initially, assume the device key is already there, and therefore shouldn't be
    // deleted during error clean-up.
    //
    *DeleteDevKey = FALSE;

    //
    // Form the hardware INF section name, and see if that section exists in the INF.
    //
    wsprintf(szHwSection, pszHwSectionFormat, szSectionName);

    if(!SetupFindFirstLine(hDeviceInf, szHwSection, NULL, &InfContext)) {
        return NO_ERROR;
    }

    if((hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS)) == INVALID_HANDLE_VALUE) {
        //
        // Open failed--try create.
        //
        if((hKey = SetupDiCreateDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          NULL,
                                          NULL)) == INVALID_HANDLE_VALUE) {
            return GetLastError();

        } else {
            *DeleteDevKey = TRUE;
        }
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {

        MYASSERT(pDeviceInfoSet);
        RegCloseKey(hKey);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    NeedsSectionList = NULL;

    try {

        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

                szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                 DevInfoElem->SelectedDriver->InfFileName
                                                     );

        //
        // Append-load any included INFs specified in an "include=" line in our
        // ".Hw" section.
        //
        AppendLoadIncludedInfs(hDeviceInf, szInfFileName, szHwSection, FALSE);

        NeedsSectionList = GetMultiSzFromInf(hDeviceInf, szHwSection, TEXT("needs"), &b);

        if(!NeedsSectionList && b) {
            //
            // Out of memory!
            //
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        ZeroMemory(&RegContext, sizeof(RegContext));
        RegContext.Flags = INF_PFLAG_DEVPROP;
        RegContext.UserRootKey = hKey;
        RegContext.DevInst = DeviceInfoData->DevInst;

        //
        // Process the registry lines ("AddReg" and "DelReg") in this section, as well as
        // those contained with any sections referenced in the "needs=" entry in this section.
        //
        for(CurInstallSection = szHwSection;
            (CurInstallSection && *CurInstallSection);
            CurInstallSection = (CurInstallSection == szHwSection)
                                ? NeedsSectionList
                                : (CurInstallSection + lstrlen(CurInstallSection) + 1))
        {
            if((Err = pSetupInstallRegistry(hDeviceInf, CurInstallSection, &RegContext)) != NO_ERROR) {
                //
                //Stop if we encounter an error while processing one of the section's registry entries
                //
                break;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
        // an inpage error dealing with a mapped-in file.
        //
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    RegCloseKey(hKey);

    if(NeedsSectionList) {
        MyFree(NeedsSectionList);
    }

    return Err;
}


BOOL
CheckIfDevStarted(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET pDeviceInfoSet
    )
/*++

Routine Description:

    This routine calls CM_Get_DevInst_Status to see if the specified device
    instance has been started.  If the device hasn't been started, and it has
    either the CM_PROB_NEED_RESTART or CM_PROB_NORMAL_CONFLICT problem codes,
    the DI_NEEDREBOOT flag is set in the device information element.  We also
    set the CM_PROB_NEED_RESTART problem on the devnode.

Arguments:

    DevInfoElem - Supplies the address of the device information element to
        check.

    pDeviceInfoSet - Supplies the address of the device info set

    LogContext - Supplies a log context for logging the reason if a reboot is
        needed.

Return Value:

    None.

--*/
{
    ULONG ulStatus, ulProblem;
    BOOL restarted = FALSE;

    if(CM_Get_DevInst_Status_Ex(&ulStatus, &ulProblem, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) == CR_SUCCESS) {

        if(ulStatus & DN_STARTED) {
            restarted = TRUE;
        } else {
            if (ulStatus & DN_HAS_PROBLEM) {
                if((ulProblem == CM_PROB_NEED_RESTART) ||
                   (ulProblem == CM_PROB_NORMAL_CONFLICT) ||
                   (ulProblem == CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD) ||
                   (ulProblem == CM_PROB_HELD_FOR_EJECT)) {
                    //
                    // The device either has the problem CM_PROB_NEED_RESTART or
                    // CM_PROB_NORMAL_CONFLICT. - change into need reboot
                    // and log what problem code was
                    //
                    SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,
                                                         pDeviceInfoSet,
                                                         MSG_LOG_REBOOT_REASON_DEVHASPROBLEM,
                                                         (DWORD)ulProblem,
                                                         (ULONG_PTR)_MapCmProbToString((DWORD)ulProblem)
                                                         );
                } else {
                    //
                    // The device has some other problem so we won't prompt for a reboot
                    // however these are interesting things to log
                    //
                    WriteLogEntry(
                        DevInfoElem->InstallParamBlock.LogContext,
                        DRIVER_LOG_INFO,  // not worth a warning
                        MSG_LOG_NOTSTARTED_REASON_DEVHASPROBLEM,
                        NULL,
                        (DWORD)ulProblem,
                        _MapCmProbToString((DWORD)ulProblem)
                        );
                }
            } else if (ulStatus & DN_PRIVATE_PROBLEM) {
                //
                // some private problem, change into need reboot
                // and log private problem
                //
                SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                             MSG_LOG_REBOOT_REASON_PRIVATEPROBLEM);
            } else {
                //
                // not started for some other reason
                // indicate reboot required and log this issue
                //
                SetDevnodeNeedsRebootProblem(DevInfoElem, pDeviceInfoSet,
                                             MSG_LOG_REBOOT_REASON_NOTSTARTED);
            }
        }
    }
    return restarted;
}


DWORD
InstallNtService(
    IN  PDEVINFO_ELEM    DevInfoElem,        OPTIONAL
    IN  HINF             hDeviceInf,
    IN  PCTSTR           InfFileName,            OPTIONAL
    IN  PCTSTR           szSectionName,      OPTIONAL
    OUT PSVCNAME_NODE   *ServicesToDelete,   OPTIONAL
    IN  DWORD            Flags,
    OUT PBOOL            NullDriverInstalled
    )
/*++

Routine Description:

    This routine looks for the specified INF section, and if found, it deletes
    any services specified in "DelService" entries, then installs any services
    specified in "AddService" entries.  These entries have the following form:

    AddService = [<ServiceName>], [<Flags>], <ServiceInstallSection>[, <EventLogInstallSection>[, [<EventLogType>] [, <EventName>]]]
    DelService = <ServiceName>[, [<flags>] [, [<EventLogType>] [, <EventName>]]]

    (<ServiceName> is only optional for an AddService entry if the
    SPSVCINST_ASSOCSERVICE flag is set.  This indicates that we're explicitly
    installing a NULL driver for this device, even though the underlying bus
    didn't report the device as being raw-capable.  This is used for device such
    as the BIOS-reported PIC, DMA controller, etc. devnodes that don't need a
    driver (since the HAL runs them), yet need to have a NULL driver installed
    so that they don't show up as yellow-banged in Device Manager.)

    A linked list is built of newly-created services, and optionally returned to the
    caller (in case a subsequent installation failure requires all modifications to
    be undone).

    After all service modifications are complete, this routine checks to see if we're
    in the context of a device installation.  If so, then it checks to see if the device
    instance specifies a valid controlling service, and that the service is not disabled
    (disabled services are assumed to be uninstalled).  If the device's 'RawDeviceOK'
    capability bit is set, then a device with no controlling service will be allowed.

Arguments:

    DevInfoElem - Optionally, supplies the device information element for whom the
        service installation is being performed.  If this parameter is not specified,
        then the service is not being installed in relation to a device instance.

    hDeviceInf - Supplies a handle to the opened INF containing the service install
        section.

        InfFileName - Optionally, supplies the full path of the INF file containing the
                service install section.  If this parameter is NULL, the no Include= or Needs=
                values will be processed in this section.

    szSectionName - Optionally, supplies the name of the service install section in a
        Win95-style device INF.  If this parameter is NULL, then no AddService or
        DelService lines will be processed.

    ServicesToDelete - Optionally, supplies the address of a linked list head pointer,
        that receives a list of services that were newly-created by this routine, and
        as such, should be deleted if the installation fails later on.  The caller must
        free the memory allocated for the nodes in this list by calling MyFree() on each
        one.

    Flags - Supplies flags controlling how the services are to be installed.  May be a
        combination of the following values:

        SPSVCINST_TAGTOFRONT - For every kernel or filesystem driver installed (that
            has an associated LoadOrderGroup), always move this service's tag to the
            front of the ordering list.

        SPSVCINST_ASSOCSERVICE - This flag may only be specified if a device information
            element is specified.  If set, this flag specifies that the service being
            installed is the owning service (i.e., function driver) for this device instance.

        SPSVCINST_DELETEEVENTLOGENTRY - For every service specified in a DelService entry,
            delete the associated event log entry (if there is one).

        SPSVCINST_NOCLOBBER_DISPLAYNAME - If this flag is specified, then we will
            not overwrite the service's display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE - If this flag is specified, then we will
            not overwrite the service's start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL - If this flag is specified, then we
            will not overwrite the service's error control value if the service
            already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP - If this flag is specified, then we
            will not overwrite the service's load order group if it already
            exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES - If this flag is specified, then we
            will not overwrite the service's dependencies list if it already
            exists.

        SPSVCINST_NO_DEVINST_CHECK - If this flag is specified, then we will not check
            to ensure that a function driver is installed for the specified devinfo
            element after running the service install section.  This is a private flag
            used only by SetupInstallServicesFromInfSection(Ex) and InstallHinfSection.

        SPSVCINST_STOPSERVICE - If this flag is specified, then we will stop the service
            before removing the service.

        SPSVCINST_CLOBBER_SECURITY - If this flag is specified, security may be
            overridden.

    NullDriverInstalled - Supplies the address of a boolean variable that
        indicates whether or not an explicit null driver installation was done
        for this device.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise it is an
    ERROR_* code.
    If NO_ERROR is returned, GetLastError may return ERROR_SUCCESS_REBOOT_REQUIRED

--*/
{
    CONFIGRET cr;
    TCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    ULONG ServiceNameSize;
    DWORD Err = NO_ERROR, i;
    SC_HANDLE SCMHandle, ServiceHandle, FilterServiceHandle;
    LPQUERY_SERVICE_CONFIG ServiceConfig, FilterServiceConfig;
    DWORD ServiceConfigSize;
    PCTSTR Key;
    INFCONTEXT LineContext;
    PSVCNAME_NODE SvcListHead = NULL;
    PSVCNAME_NODE TmpSvcNode;
    SC_LOCK SCLock;
    DWORD NewTag;
    BOOL AssociatedService;
    DWORD DevInstCapabilities;
    ULONG DevInstCapabilitiesSize;
    PTSTR FilterDrivers, CurFilterDriver;
    BOOL FilterNeedsTag;
    BOOL NullFunctionDriverAdded;
    PTSTR NeedsSectionList, CurInstallSection;
    BOOL b;
    BOOL NeedsReboot;
    DWORD slot_section = 0;
    PSETUP_LOG_CONTEXT LogContext;

    try {
        LogContext = ((PLOADED_INF) hDeviceInf)->LogContext;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogContext = NULL;
        Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
        goto FinalClean0;
    }

    //
    // Initially, assume this is not a null driver install.
    //
    *NullDriverInstalled = FALSE;
    NeedsReboot = FALSE;

    if(szSectionName) {
        //
        // Surround the following in try/except, in case we get an inpage error.
        //
        try {

            NeedsSectionList = NULL;

            if (InfFileName) {

                AppendLoadIncludedInfs(hDeviceInf, InfFileName, szSectionName, FALSE);

                NeedsSectionList = GetMultiSzFromInf(hDeviceInf, szSectionName, TEXT("needs"), &b);

                if(!NeedsSectionList && b) {
                    //
                    // Out of memory!
                    //
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            if (slot_section == 0) {
                slot_section = AllocLogInfoSlot(LogContext,FALSE);
            }

            //
            // Make two passes through the section--once for deletions, and a
            // second time for additions.
            //
            for(i = 0; i < 2; i++) {
                //
                // Find the relevent line (if there is one) in the given install section.
                //
                Key = (i) ? pszAddService : pszDelService;

                //
                // Process the service lines in this section, as well as
                // those contained with any sections referenced in the "needs=" entry in this section.
                //
                for(CurInstallSection = (PTSTR)szSectionName;
                    (CurInstallSection && *CurInstallSection);
                    CurInstallSection = (CurInstallSection == szSectionName)
                                        ? NeedsSectionList
                                        : (CurInstallSection + lstrlen(CurInstallSection) + 1))
                {

                    if(!SetupFindFirstLine(hDeviceInf, CurInstallSection, Key, &LineContext)) {
                        continue;
                    }
                    //
                    // Log which section we're installing if we log anything else
                    //
                    WriteLogEntry(
                        LogContext,
                        slot_section,
                        MSG_LOG_PROCESS_SERVICE_SECTION,
                        NULL,
                        CurInstallSection);


                    do {
                        //
                        // We have a line to act upon.
                        //
                        Err = (i) ? pSetupAddService(&LineContext,
                                                     &SvcListHead,
                                                     Flags,
                                                     (DevInfoElem ? DevInfoElem->DevInst : 0),
                                                     &NullFunctionDriverAdded,
                                                     LogContext)
                                  : pSetupDeleteService(&LineContext,
                                                        Flags,
                                                        LogContext);

                        if(Err != NO_ERROR) {
                            //
                            // Log that an error occurred
                            //
                            WriteLogError(
                                LogContext,
                                // we don't know if it's a driver or not,
                                // so just allow both to work
                                SETUP_LOG_ERROR | DRIVER_LOG_ERROR,
                                Err);

                            goto clean0;
                        } else if(i) {
                            //
                            // We're processing AddService entries, so check to see
                            // if we just installed a null service (thus having no
                            // function driver on a non-raw-capable PDO should be
                            // allowed).
                            //
                            *NullDriverInstalled |= NullFunctionDriverAdded;
                            if (GetLastError() == ERROR_SUCCESS_REBOOT_REQUIRED) {
                                NeedsReboot |= TRUE;
                            }
                        }

                    } while(SetupFindNextMatchLine(&LineContext, Key, &LineContext));
                }
            }

clean0: ; // nothing to do

        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
            // an inpage error dealing with a mapped-in file.
            //
            Err = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
        }

        if (NeedsSectionList) {
            MyFree(NeedsSectionList);
        }

        if((Err != NO_ERROR) || (Flags & SPSVCINST_NO_DEVINST_CHECK)) {
            goto FinalClean0;
        }
    }

    MYASSERT(DevInfoElem);

    //
    // Find out if the device instance already has an associated service.
    //
    ServiceNameSize = sizeof(ServiceName);
    if(CR_SUCCESS == (cr = CM_Get_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                            CM_DRP_SERVICE,
                                                            NULL,
                                                            ServiceName,
                                                            &ServiceNameSize,
                                                            0)))
    {
        AssociatedService = TRUE;
        //
        // Make sure that the NullDriverInstalled output parameter is still FALSE.
        // It typically would be, but might not be in the case where there are
        // multiple AddService entries that specify SPSVCINST_ASSOCSERVICE (e.g.,
        // when additional service install sections are pulled in via include=/needs=.
        //
        *NullDriverInstalled = FALSE;

    } else {
        //
        // For the moment, there is no associated service.
        //
        AssociatedService = FALSE;

        //
        // Either the device instance has gone sour (in which case we return an error),
        // or we couldn't retrieve an associated service name.  In the latter case, we
        // will make the association based on the default service for the class.
        //
        if(cr == CR_INVALID_DEVINST) {

            Err = ERROR_NO_SUCH_DEVINST;

        } else if(!*NullDriverInstalled) {

            ServiceNameSize = sizeof(ServiceName);
            AssociatedService = AssociateDevInstWithDefaultService(DevInfoElem,
                                                                   ServiceName,
                                                                   &ServiceNameSize
                                                                  );
            if(!AssociatedService) {
                //
                // If the device's capabilities report that it can be driven 'raw', then
                // not having a function driver is OK.  Otherwise, we have an error.
                //
                DevInstCapabilitiesSize = sizeof(DevInstCapabilities);
                if(CR_SUCCESS != CM_Get_DevInst_Registry_Property(DevInfoElem->DevInst,
                                                                  CM_DRP_CAPABILITIES,
                                                                  NULL,
                                                                  &DevInstCapabilities,
                                                                  &DevInstCapabilitiesSize,
                                                                  0))
                {
                    DevInstCapabilities = 0;
                }

                if(!(DevInstCapabilities & CM_DEVCAP_RAWDEVICEOK)) {
                    Err = ERROR_NO_ASSOCIATED_SERVICE;
                }
            }
        }

        if(!AssociatedService) {
            //
            // Either we hit an error, or the device can be driven 'raw'.  In either case, we
            // can skip the service controller checks that lie ahead.
            //
            goto FinalClean0;
        }
    }

    //
    // At this point, we have the name of the service with which the device instance is
    // associated.  Attempt to locate this service in the SCM database.
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTSERVSCM_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
        goto FinalClean0;
    }

    if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
        //
        // We couldn't access the service--either because it doesn't exist, or because
        // this is a detected device reported by a 'disembodied' driver object (e.g., the
        // one the HAL creates for its driver object it got via IoCreateDriver).
        //
        // The former case is an error, the latter case is just fine.
        //
        Err = GetLastError();
        if((lstrlen(ServiceName) > CSTRLEN(pszDriverObjectPathPrefix)) &&
           CharUpper(ServiceName) &&
           !memcmp(ServiceName, pszDriverObjectPathPrefix, CSTRLEN(pszDriverObjectPathPrefix)))
        {
            //
            // The "service name" is actually a driver name (e.g., "\Driver\PCI_HAL"), so it's OK.
            //
            Err = NO_ERROR;
        }
        if(Err) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_INSTSERVOPEN_ERROR,
                NULL,
                ServiceName
                );
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        goto FinalClean1;
    }

    //
    // The service exists.  Make sure that it's not disabled.
    //
    if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig)) == NO_ERROR) {

        if(ServiceConfig->dwStartType == SERVICE_DISABLED) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR,
                MSG_LOG_INSTSERV_DISABLED,
                NULL,
                ServiceName
                );

            Err = ERROR_SERVICE_DISABLED;
        } else {
            //
            // If this service has a load order group, and is a kernel or filesystem
            // driver, then make sure that it has a tag.
            //
            // NOTE: We have to do this here, even though we ensure that all new services we install
            // have their tags set up properly in pSetupAddService().  The reason is that the device may
            // using an existing service that wasn't installed via a Win95-style INF.
            //
            if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup) &&
               (ServiceConfig->dwServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER))) {
                //
                // This service needs a tag--does it have one???
                //
                if(!(NewTag = ServiceConfig->dwTagId)) {
                    //
                    // Attempt to lock the service database before generating a tag.  We'll go ahead
                    // and make the change, even if this fails.
                    //
                    pAcquireSCMLock(SCMHandle, &SCLock, LogContext);

                    if(!ChangeServiceConfig(ServiceHandle,
                                            SERVICE_NO_CHANGE,
                                            SERVICE_NO_CHANGE,
                                            SERVICE_NO_CHANGE,
                                            NULL,
                                            ServiceConfig->lpLoadOrderGroup,  // have to specify this to generate new tag.
                                            &NewTag,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL)) {
                        DWORD LastErr = GetLastError();
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_WARNING | SETUP_LOG_BUFFER,
                            MSG_LOG_INSTSERVTAG_WARN,
                            NULL,
                            ServiceName
                            );
                        WriteLogError(
                            LogContext,
                            DRIVER_LOG_WARNING,
                            LastErr);

                        NewTag = 0;
                    }

                    if(SCLock) {
                        UnlockServiceDatabase(SCLock);
                    }
                }

                //
                // Make sure that the tag exists in the service's corresponding GroupOrderList entry.
                //
                if(NewTag) {
                    pSetupAddTagToGroupOrderListEntry(ServiceConfig->lpLoadOrderGroup,
                                                NewTag,
                                                Flags & SPSVCINST_TAGTOFRONT
                                               );
                }
            }

            //
            // If the function driver is marked as boot-start, then make sure that all
            // associated upper- and lower-filters (both class- and device-specific) are
            // also boot-start drivers.
            //
            if((ServiceConfig->dwStartType == SERVICE_BOOT_START) &&
               RetrieveAllDriversForDevice(DevInfoElem, &FilterDrivers,RADFD_FLAG_ALL_FILTERS,NULL)) {
                //
                // If FilterDrivers is NULL, then we hit an out-of-memory error.
                //
                if(!FilterDrivers) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_VERBOSE,
                        MSG_LOG_INSTSERV_BOOT,
                        NULL,
                        ServiceName
                        );

                    //
                    // Check each filter driver.
                    //
                    for(CurFilterDriver = FilterDrivers;
                        *CurFilterDriver;
                        CurFilterDriver += (lstrlen(CurFilterDriver) + 1)) {

                        if(!(FilterServiceHandle = OpenService(SCMHandle, CurFilterDriver, SERVICE_ALL_ACCESS))) {
                            //
                            // We couldn't access the service--probably because it doesn't exist.
                            // Bail now.
                            //
                            Err = GetLastError();
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_LOG_BOOTFILTSERVOPEN_ERROR,
                                NULL,
                                CurFilterDriver);
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                Err);
                            break;
                        }

                        //
                        // The service exists.  Make sure that it's not disabled.
                        //
                        Err = pSetupRetrieveServiceConfig(FilterServiceHandle, &FilterServiceConfig);
                        if(Err != NO_ERROR) {
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_LOG_BOOTFILTSERVCONFIG_ERROR,
                                NULL,
                                CurFilterDriver);
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                Err);
                            goto CloseFilterSvcAndContinue;
                        }

                        if(FilterServiceConfig->dwStartType == SERVICE_DISABLED) {
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                MSG_LOG_BOOTFILTSERV_DISABLED,
                                NULL,
                                CurFilterDriver);
                            Err = ERROR_SERVICE_DISABLED;
                        } else {
                            //
                            // Ensure that this service is a boot-start kernel driver, and that it has
                            // a tag if necessary.
                            //
                            if(FilterServiceConfig->dwServiceType & SERVICE_KERNEL_DRIVER) {

                                if(FilterServiceConfig->lpLoadOrderGroup &&
                                   *(FilterServiceConfig->lpLoadOrderGroup)) {

                                    FilterNeedsTag = TRUE;
                                    NewTag = FilterServiceConfig->dwTagId;
                                }

                                if((FilterNeedsTag && !NewTag) ||
                                   (FilterServiceConfig->dwStartType != SERVICE_BOOT_START)) {
                                    //
                                    // Lock the service database before modifying this service.
                                    //
                                    Err = pAcquireSCMLock(SCMHandle, &SCLock, LogContext);

                                    if(Err == NO_ERROR) {
                                        //
                                        // Make the modifications to the service (NOTE:  Because the
                                        // service controller is really bad when it comes to driver paths,
                                        // we must explicitly pass the lpBinaryPathName in, even though we
                                        // aren't changing it.  Otherwise, the service controller will complain
                                        // because it thinks all paths have to begin with \SystemRoot\.)
                                        //
                                        if(!ChangeServiceConfig(FilterServiceHandle,
                                                                SERVICE_NO_CHANGE,
                                                                (FilterServiceConfig->dwStartType != SERVICE_BOOT_START)
                                                                    ? SERVICE_BOOT_START
                                                                    : SERVICE_NO_CHANGE,
                                                                SERVICE_NO_CHANGE,
                                                                (FilterServiceConfig->dwStartType != SERVICE_BOOT_START)
                                                                    ? FilterServiceConfig->lpBinaryPathName
                                                                    : NULL,
                                                                (FilterNeedsTag && !NewTag)
                                                                    ? FilterServiceConfig->lpLoadOrderGroup
                                                                    : NULL,
                                                                (FilterNeedsTag && !NewTag)
                                                                    ? &NewTag
                                                                    : NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                NULL)) {

                                            Err = GetLastError();

                                            WriteLogEntry(
                                                LogContext,
                                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                                MSG_LOG_BOOTFILTSERVCHANGE_ERROR,
                                                NULL,
                                                CurFilterDriver);
                                            WriteLogError(
                                                LogContext,
                                                DRIVER_LOG_ERROR,
                                                Err);

                                        } else {
                                            WriteLogEntry(
                                                LogContext,
                                                DRIVER_LOG_VERBOSE,
                                                MSG_LOG_BOOTFILTSERVCHANGE_OK,
                                                NULL,
                                                CurFilterDriver);
                                        }

                                        UnlockServiceDatabase(SCLock);
                                    } else {
                                        WriteLogEntry(
                                            LogContext,
                                            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                            MSG_LOG_BOOTFILTSERVSCM_ERROR,
                                            NULL,
                                            CurFilterDriver);
                                        WriteLogError(
                                            LogContext,
                                            DRIVER_LOG_ERROR,
                                            Err);
                                    }

                                    if((Err == NO_ERROR) && FilterNeedsTag) {
                                        //
                                        // Make sure that the tag exists in the service's corresponding GroupOrderList entry.
                                        //
                                        MYASSERT(NewTag);
                                        pSetupAddTagToGroupOrderListEntry(FilterServiceConfig->lpLoadOrderGroup,
                                                                    NewTag,
                                                                    FALSE
                                                                   );
                                    }
                                }

                            } else {
                                //
                                // This is not a kernel driver.  This is an error.
                                //
                                WriteLogEntry(
                                    LogContext,
                                    DRIVER_LOG_ERROR,
                                    MSG_LOG_BOOTFILTSERV_KERN,
                                    NULL,
                                    CurFilterDriver);
                                Err = ERROR_INVALID_FILTER_DRIVER;
                            }
                        }
                        MyFree(FilterServiceConfig);

CloseFilterSvcAndContinue:
                        CloseServiceHandle(FilterServiceHandle);

                        if(Err) {
                            break;
                        }
                    }
                    MyFree(FilterDrivers);
                }
            }
        }

        MyFree(ServiceConfig);
    } else {
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_INSTSERVCONFIG_ERROR,
            NULL,
            ServiceName
            );
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }

    CloseServiceHandle(ServiceHandle);

FinalClean1:
    CloseServiceHandle(SCMHandle);

FinalClean0:
    if(Err == NO_ERROR) {
        //
        // If requested, store the linked-list of newly-created service nodes in the output
        // parameter, otherwise, delete the list.
        //
        if(ServicesToDelete) {
            *ServicesToDelete = SvcListHead;
        } else {
            for(TmpSvcNode = SvcListHead; TmpSvcNode; TmpSvcNode = SvcListHead) {
                SvcListHead = SvcListHead->Next;
                MyFree(TmpSvcNode);
            }
        }

        if (NeedsReboot) {
            //
            // this is intentional - return NO_ERROR but GetLastError = ERROR_SUCCESS_REBOOT_REQUIRED
            //
            SetLastError(ERROR_SUCCESS_REBOOT_REQUIRED);
        }
    } else {
        //
        // Something failed along the way, so we need to clean up any newly-created
        // services.
        //
        if(Err && LogContext) {
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                MSG_LOG_INSTSERV_ERROR,
                NULL
                );
            WriteLogError(
                LogContext,
                DRIVER_LOG_ERROR,
                Err);
        }
        if(SvcListHead) {
            DeleteServicesInList(SvcListHead,LogContext);
            for(TmpSvcNode = SvcListHead; TmpSvcNode; TmpSvcNode = SvcListHead) {
                SvcListHead = SvcListHead->Next;
                MyFree(TmpSvcNode);
            }
        }
    }

    if (slot_section != 0) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    return Err;
}


BOOL
AssociateDevInstWithDefaultService(
    IN     PDEVINFO_ELEM DevInfoElem,
    OUT    PTSTR         ServiceName,
    IN OUT PDWORD        ServiceNameSize
    )
/*++

Routine Description:

    This routine attempts to find out the default service with which to associate
    the specified device.  The default service (if there is one) is associated with
    the device's class.  If a default is found, the device instance is associated
    with that service.

Arguments:

    DeviceInfoData - Specifies the device information element to create a default
        service association for.

    ServiceName - Supplies the address of a character buffer that receives the name
        of the service with which the device instance was associated (if this routine
        is successful).

    ServiceNameSize - Supplies the address of a variable containing the size, in bytes,
        of the ServiceName buffer.  On output, this variable receives the number of
        bytes actually stored in ServiceName.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    HKEY hClassKey;
    DWORD RegDataType;
    BOOL Success;

    //
    // Open up the class key for this device's class.
    //
    if((hClassKey = SetupDiOpenClassRegKey(&(DevInfoElem->ClassGuid),
                                           KEY_READ)) == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    Success = FALSE; // assume failure

    try {
        //
        // Retrieve the "Default Service" value from the class key.  If present, this value entry
        // indicates what service to associate the device with, when one isn't specified during
        // installation.
        //
        if(RegQueryValueEx(hClassKey,
                           pszDefaultService,
                           NULL,
                           &RegDataType,
                           (PBYTE)ServiceName,
                           ServiceNameSize) != ERROR_SUCCESS) {
            goto clean0;
        }

        if((RegDataType != REG_SZ) || (*ServiceNameSize < sizeof(TCHAR)) || !(*ServiceName)) {
            goto clean0;
        }

        //
        // We have successfully retrieved the default service name to be associated with this
        // device instance.  Perform the association now by setting the Service device registry
        // property.
        //
        if(CM_Set_DevInst_Registry_Property(DevInfoElem->DevInst,
                                            CM_DRP_SERVICE,
                                            ServiceName,
                                            *ServiceNameSize,
                                            0) == CR_SUCCESS) {
            Success = TRUE;
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }

    RegCloseKey(hClassKey);

    return Success;
}


DWORD
DeleteServicesInList(
    IN PSVCNAME_NODE ServicesToDelete,
    IN PSETUP_LOG_CONTEXT  LogContext
    )
/*++

Routine Description:

    This routine deletes each service entry in the supplied linked list. This is
    typically called to clean up if something goes wrong during a device's installation.
    If the 'DeleteEventLog' flag for a particular node is TRUE, then the corresponding
    event log entry under HKLM\System\CurrentControlSet\Services\EventLog\<EventLogType> is
    also deleted.

Arguments:

    ServicesToDelete - supplies a pointer to the head of a linked list of service names
        to be deleted.

    LogContext - context for logging failures

Return Value:

    Error if we could not open service manager or acquire lock.
    Note that we do not return error for individual services.

--*/
{
    SC_HANDLE SCMHandle, ServiceHandle;
    SC_LOCK SCLock;
    HKEY hKeyEventLog = NULL, hKeyEventLogType;
    TCHAR RegistryPath[SIZECHARS(REGSTR_PATH_SERVICES) + SIZECHARS(DISTR_EVENTLOG) + (2 * 256)];
    DWORD Result = NO_ERROR;
    DWORD LastErr;

    if(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)) {

        Result = pAcquireSCMLock(SCMHandle, &SCLock, LogContext);
        if(Result == NO_ERROR) {

            for(; ServicesToDelete; ServicesToDelete = ServicesToDelete->Next) {

                LastErr = NO_ERROR;

                if(ServiceHandle = OpenService(SCMHandle,
                                               ServicesToDelete->Name,
                                               SERVICE_ALL_ACCESS)) {

                    //
                    // stop the service first if we're supposed to
                    //  wait awhile for the service to stop before deleting the
                    //  service, since we don't want the service to be in use when
                    //  delete the service or the service binaries
                    if (ServicesToDelete->Flags & SPSVCINST_STOPSERVICE) {
                        SERVICE_STATUS ssStatus;

                        if (ControlService( ServiceHandle,
                                            SERVICE_CONTROL_STOP ,
                                            &ssStatus)
                            || (LastErr = GetLastError()) == ERROR_SERVICE_NOT_ACTIVE) {

                            #define SLEEP_TIME 4000
                            #define LOOP_COUNT 30
                            DWORD loopCount = 0;
                            do {

                                BOOL b;

                                b = QueryServiceStatus( ServiceHandle, &ssStatus);
                                if ( !b ) {
                                    LastErr = GetLastError();
                                    //
                                    // query failed for some reason, but let's
                                    // just delete the service anyway
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                        MSG_LOG_DELSERVSTAT_ERROR,
                                        NULL,
                                        ServicesToDelete->Name
                                        );
                                    WriteLogError(
                                        LogContext,
                                        DRIVER_LOG_ERROR,
                                        LastErr);
                                    break;
                                }
                                if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {

                                    if ( loopCount++ == LOOP_COUNT ) {
                                        // still pending after LOOP_COUNT iterations...
                                        // just delete the service anyway
                                        //
                                        WriteLogEntry(
                                            LogContext,
                                            DRIVER_LOG_ERROR,
                                            MSG_LOG_DELSERVPEND_ERROR,
                                            NULL,
                                            ServicesToDelete->Name
                                            );
                                        break;
                                    }
                                    Sleep( SLEEP_TIME );
                                } else {
                                    loopCount++;
                                }
                            } while ( ssStatus.dwCurrentState != SERVICE_STOPPED
                                      && loopCount < LOOP_COUNT );
                        } else {
                            // control service failed for some reason...
                            // let's just continue on and try to delete the
                            // service anyway
                            //
                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                MSG_LOG_DELSERVCTRL_ERROR,
                                NULL,
                                ServicesToDelete->Name
                                );
                            WriteLogError(
                                LogContext,
                                DRIVER_LOG_ERROR,
                                LastErr);
                        }
                    }
                    if(DeleteService(ServiceHandle) ||
                        ((LastErr = GetLastError()) == ERROR_SERVICE_MARKED_FOR_DELETE)) {
                        //
                        // Delete succeeded, or we don't care
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_VERBOSE,
                            MSG_LOG_DELSERV_OK,
                            NULL,
                            ServicesToDelete->Name
                            );

                    } else {
                        // delete service failed for some reason...
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                            MSG_LOG_DELSERV_ERROR,
                            NULL,
                            ServicesToDelete->Name
                            );
                        WriteLogError(
                            LogContext,
                            DRIVER_LOG_ERROR,
                            LastErr);
                    }
                    CloseServiceHandle(ServiceHandle);
                } else {
                    LastErr = GetLastError();
                    if(LastErr == ERROR_SERVICE_DOES_NOT_EXIST) {
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_VERBOSE,
                            MSG_LOG_DELSERVNOSERV,
                            NULL,
                            ServicesToDelete->Name
                            );
                    } else {
                        //
                        // open service failed for some reason
                        //
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                            MSG_LOG_DELSERVOPEN_ERROR,
                            NULL,
                            ServicesToDelete->Name
                            );
                        WriteLogError(
                            LogContext,
                            DRIVER_LOG_ERROR,
                            LastErr);
                    }
                }

                //
                // Delete the event log entry (if required) if either (a) we succeeded in deleting
                // the service, or (b) the service didn't exist.
                //
                if(ServicesToDelete->DeleteEventLog) {

                    if(ServiceHandle || (LastErr == ERROR_SERVICE_DOES_NOT_EXIST)) {
                        //
                        // We need to delete the associated event log for this service.
                        //
                        if(!hKeyEventLog) {
                            //
                            // We haven't opened up the EventLog registry key yet, so do that now.
                            //
                            CopyMemory(RegistryPath, pszServicesRegPath, sizeof(pszServicesRegPath));
                            CopyMemory(RegistryPath + CSTRLEN(REGSTR_PATH_SERVICES),
                                       pszEventLog,
                                       sizeof(pszEventLog)
                                      );

                            if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            RegistryPath,
                                            0,
                                            KEY_READ,
                                            &hKeyEventLog) != ERROR_SUCCESS) {

                                hKeyEventLog = NULL; // make sure this value is still NULL!
                                continue;
                            }
                        }

                        //
                        // Now open up the event log type key.
                        //
                        if(RegOpenKeyEx(hKeyEventLog,
                                        ServicesToDelete->EventLogType,
                                        0,
                                        KEY_READ | KEY_WRITE,
                                        &hKeyEventLogType) == ERROR_SUCCESS) {

                            pSetupRegistryDelnode(hKeyEventLogType, ServicesToDelete->EventLogName);
                            RegCloseKey(hKeyEventLogType);
                        }
                    }
                }
            }

            if(hKeyEventLog) {
                RegCloseKey(hKeyEventLog);
            }
            UnlockServiceDatabase(SCLock);
        }

        CloseServiceHandle(SCMHandle);
    } else {
        Result = GetLastError();
    }

    if (Result != NO_ERROR) {
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_DELSERVSCM_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Result);
    }
    return Result;
}


BOOL
IsDevRemovedFromAllHwProfiles(
    IN PCTSTR DeviceInstanceId,
    IN HMACHINE hMachine
    )
/*++

Routine Description:

    This routine determines whether the specified device instance has been removed from
    every hardware profile.  The device has been removed from a particular profile if
    its corresponding CsConfigFlags has the CSCONFIGFLAG_DO_NOT_CREATE bit set.

Arguments:

    DeviceInstanceId - Supplies the name of the device instance to check.

Return Value:

    If the device exists in only the specified profile, the return value is TRUE,
    otherwise, it is FALSE.

--*/
{
    CONFIGRET cr;
    ULONG i = 0;
    HWPROFILEINFO HwProfileInfo;
    ULONG HwProfFlags;

    //
    // Enumerate all the hardware profiles.
    //
    do {

        if((cr = CM_Get_Hardware_Profile_Info_Ex(i, &HwProfileInfo, 0,hMachine)) == CR_SUCCESS) {

            if((CM_Get_HW_Prof_Flags_Ex((DEVINSTID)DeviceInstanceId,
                                     HwProfileInfo.HWPI_ulHWProfile,
                                     &HwProfFlags,
                                     0,
                                     hMachine) != CR_SUCCESS) ||
               !(HwProfFlags & CSCONFIGFLAG_DO_NOT_CREATE))
            {
                //
                // If we couldn't retrieve the CSConfigFlags, or if the
                // CSCONFIGFLAG_DO_NOT_CREATE bit was not set, then we've found
                // a profile where the device still exists, so we can bail here.
                //
                return FALSE;
            }
        }

        i++;

    } while(cr != CR_NO_MORE_HW_PROFILES);

    //
    // We didn't find any hardware profile where the device wasn't removed.
    //
    return TRUE;
}


DWORD
GetDevInstConfigFlags(
    IN DEVINST DevInst,
    IN DWORD   Default,
    IN HMACHINE hMachine
    )
/*++

Routine Description:

    This routine retrieves the ConfigFlags for the specified device instance.  If the
    value can not be retrieved, the specified default is returned.

Arguments:

    DevInst - Supplies the handle of the device instance for which the ConfigFlags value
        is to be retrieved.

    Default - Supplies the default value that should be returned if for some reason the
        ConfigFlags cannot be retrieved.

Return Value:

    The ConfigFlags value for the specified device instance.

Notes:
        This is used for device install, and doesn't need to be remotable for 5.0

--*/
{
    DWORD ConfigFlags;
    ULONG ConfigFlagsSize = sizeof(ConfigFlags);

    if(CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                        CM_DRP_CONFIGFLAGS,
                                        NULL,
                                        &ConfigFlags,
                                        &ConfigFlagsSize,
                                        0,
                                        hMachine) != CR_SUCCESS) {
        ConfigFlags = Default;
    }

    return ConfigFlags;
}


DWORD
pSetupDeleteService(
    IN PINFCONTEXT LineContext,
    IN DWORD       Flags,
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine processes the specified DelService line in an INF's Service
    install section.  The line has the form:

    DelService = <ServiceName>[, [<flags>] [, [<EventLogType>] [, <EventName>]]]

    Flags :

        SPSVCINST_DELETEEVENTLOGENTRY - delete the associated event log entry
                                        for this service (if there is one).
                                        If the EventLogType field isn't specified,
                                        then it is assumed to be "System".  If
                                        the EventName field isn't specified, then
                                        it is assumed to be the same as the service
                                        name.

        SPSVCINST_DELETEEVENTLOGENTRY - stop the service before deleting it

Arguments:

    LineContext - Supplies the context of the DelService line to be processed.

    Flags - specifies one or more SPSVCINST_* flags

    LogContext - Supplies a pointer to a log context to be used for logging.

Return Value:

    If field 1 on the specified line could not be retrieved, then an error
    is returned.  Otherwise, the routine returns NO_ERROR (i.e., the routine
    is considered successful regardless of whether the service to delete
    actually existed).

--*/
{
    SVCNAME_NODE TempSvcNode;
    DWORD DelServiceFlags;
    PCTSTR EventLogType, EventLogName;
    BOOL DeleteEventLogEntry;
    DWORD Result = NO_ERROR;

    //
    // Initialize a service name node for a call to DeleteServicesInList.
    //
    if(!SetupGetStringField(LineContext,
                            1,
                            TempSvcNode.Name,
                            SIZECHARS(TempSvcNode.Name),
                            NULL)) {
        return GetLastError();
    }

    //
    // Get the flags field.
    //
    if(!SetupGetIntField(LineContext, 2, (PINT)&DelServiceFlags)) {
        DelServiceFlags = 0;
    }

    DeleteEventLogEntry = (Flags & SPSVCINST_DELETEEVENTLOGENTRY);

    //
    // If the caller specified that the associated event log entry should be
    // deleted, then make sure that flag is set.
    //
    if(DeleteEventLogEntry) {
        DelServiceFlags |= SPSVCINST_DELETEEVENTLOGENTRY;
    }

    if(TempSvcNode.DeleteEventLog = (DelServiceFlags & SPSVCINST_DELETEEVENTLOGENTRY)) {
        //
        // Retrieve the event log type (default is "System") and the event log name
        // (default is the service name).
        //
        if(!(EventLogType = pSetupGetField(LineContext, 3)) || !(*EventLogType)) {
            EventLogType = pszSystem;
        }

        if(!(EventLogName = pSetupGetField(LineContext, 4)) || !(*EventLogName)) {
            EventLogName = TempSvcNode.Name;
        }

        lstrcpy(TempSvcNode.EventLogType, EventLogType);
        lstrcpy(TempSvcNode.EventLogName, EventLogName);
    }

    TempSvcNode.Next = NULL;
    TempSvcNode.Flags = DelServiceFlags | Flags;

    Result = DeleteServicesInList(&TempSvcNode,LogContext);

    return Result;
}

#ifdef UNICODE
BOOL
IsNativeDriver(
    PCTSTR FullPath
    )
/*++

Routine Description:

    determines if a kernel-mode driver binary is valid
    helps avoid bugchecks and catch problems earlier

Arguments:

    FullPath - Fully qualified path to the binary to be processed


Return Value:

    TRUE indicates that the file is a native driver

--*/
{
    LOADED_IMAGE LoadedImage;
    BOOL RetVal = FALSE;
    PSTR FullPathCopy;
    WORD WantedImage;
    BOOL locked = FALSE;

#if defined(_IA64_)
    WantedImage = IMAGE_FILE_MACHINE_IA64;
#elif defined(_AMD64_)
    WantedImage = IMAGE_FILE_MACHINE_AMD64;
#elif defined(_X86_)
    if(IsWow64) {
        //
        // we don't support installing drivers if in Wow64
        //
        return FALSE;
    }
    WantedImage = IMAGE_FILE_MACHINE_I386;
#else
#error Unknown platform
#endif
    //
    // imagehlp takes a non-const ANSI string, so convert it.
    //
    FullPathCopy = pSetupUnicodeToMultiByte(FullPath, CP_ACP);

    if (!FullPathCopy) {
        return(FALSE);
    }

    RtlZeroMemory(
        &LoadedImage,
        sizeof(LoadedImage) );

    //
    // get the image headers
    //
    try {
        EnterCriticalSection(&ImageHlpMutex);
        locked = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        MyFree(FullPathCopy);
        return FALSE;
    }
    if (MapAndLoad(
            FullPathCopy,
            NULL,
            &LoadedImage,
            FALSE, // assume it's an exe if there isn't any file extension
            TRUE /* read only */ )) {


        if ((LoadedImage.FileHeader->Signature == IMAGE_NT_SIGNATURE)
            && (LoadedImage.FileHeader->FileHeader.Machine == WantedImage)
            && (LoadedImage.FileHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
            RetVal = TRUE;
        }

        UnMapAndLoad(&LoadedImage);
    }
    LeaveCriticalSection(&ImageHlpMutex);

    MyFree(FullPathCopy);

    return(RetVal);
}
#endif

DWORD
pSetupAddService(
    IN  PINFCONTEXT    LineContext,
    OUT PSVCNAME_NODE *SvcListHead,
    IN  DWORD          Flags,
    IN  DEVINST        DevInst,            OPTIONAL
    OUT PBOOL          NullDriverInstalled,
    IN  PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine processes the specified AddService line in an INF's Service
    install section.  The line has the form:

    AddService = <ServiceName>, [<Flags>], <ServiceInstallSection>[, <EventLogInstallSection>[, [<EventLogType>] [, <EventName>]]]

    Currently, the following flags are defined:

        SPSVCINST_TAGTOFRONT   (0x1) - Move the tag for this service to the front of its
                                       group order list

        SPSVCINST_ASSOCSERVICE (0x2) - Associate this service with the device instance
                                       being installed (only used if DevInst is non-zero)

        SPSVCINST_NOCLOBBER_DISPLAYNAME     (0x8) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE      (0x10) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL   (0x20) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    error control value if the service
                                                    already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP (0x40) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    load order group if it already
                                                    exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES   (0x80) - If this flag is specified, then
                                                    we will not overwrite the service's
                                                    dependencies list if it already
                                                    exists.

        SPSVCINST_CLOBBER_SECURITY        (0x400) - If this flag is specified, then
                                                    security may be overridden.

    A service with the name <ServiceName> is created.  The parameters used in the
    call to CreateService are retrieved from the <ServiceInstallSection>, and are
    in the following format (lines not marked as optional must be present or the
    routine will fail):

    DisplayName    = <string>                  ; (optional) 'Friendly name' for the service
    ServiceType    = <number>                  ; one of the SERVICE_* type codes
    StartType      = <number>                  ; one of the SERVICE_* start codes
    ErrorControl   = <number>                  ; one of the SERVICE_ERROR_* error control codes
    ServiceBinary  = <string>                  ; path to binary
    LoadOrderGroup = <string>                  ; (optional) group to which this service belongs
    Dependencies   = <string>[[, <string>]...] ; (optional) list of groups (prefixed with '+')
                                               ; and services this service depends on
    StartName      = <string>                  ; (optional) driver object name used to load the
                                               ; driver--only used for drivers & filesystems
    Security       = <string>                  ; (optional) SDS specifying security

    SetupInstallFromInfSection is then called for the <ServiceInstallSection>, which may
    also contain registry modifications (SPINST_REGISTRY is the only flag used).  HKR is
    the service entry key.

    Finally, if <EventLogInstallSection> is specified, then a key for this service is
    created under HKLM\System\CurrentControlSet\Services\EventLog, and SetupInstallFromInfSection
    is invoked to do registry modifications specified in that section, with HKR being the event log
    entry (again, only SPINST_REGISTRY is used).  By default, the event log type is "System" and the
    event log name is the same as the service name.

Arguments:

    LineContext - Supplies the context of the AddService line to be processed.

    SvcListHead - Supplies the address of the linked-list head containing a list of
        all services newly created as a result of the current installation.  This
        routine first checks for the presence of the service, and if it already exists,
        then it simply modifies the existing one.  If the service doesn't already exist,
        then this routine creates a new SVCNAME_NODE, and fills it in with the name of
        the newly-created service.  Likewise, if an EventLog entry is given, then the
        presence of an existing one is checked first, and the service node's
        'DeleteEventLog' field is set to TRUE only if the event log entry didn't
        previously exist.  This list is kept to allow for proper clean-up in case
        of a later failure.

    Flags - Specifies how the service should be installed.  These flags are basically
        overrides of what the AddService flags field specifies, as described above.

    DevInst - If specified (i.e., non-zero), and if the SPSVCINST_ASSOCSERVICE flag is
        set in either the Flags parameter or the AddService flags INF field, then we will
        store this service name in the device instance's 'Service' registry property.

    NullDriverInstalled - Supplies a pointer to a boolean variable that is set
        upon successful return to indicate whether or not the service install
        specified a null service (i.e., the service name field in the INF AddService
        entry was empty).

    LogContext - Supplies a pointer to a log context so that info may be logged.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    Note that we don't do anything special for SERVICE_ADAPTER and SERVICE_RECOGNIZER_DRIVER
    service types.  These types are invalid as far as the service contoller is concerned, so
    we just let the create/change service APIs do the validation on them.

--*/
{
    PCTSTR ServiceName, InstallSection, EventLogType, EventLogName;
    HINF hInf;
    INFCONTEXT InstallSectionContext;
    DWORD ServiceType, StartType, ErrorControl, ServiceInstallFlags;
    PCTSTR ServiceBinary;
    PCTSTR ActualBinary = NULL;
    TCHAR ServiceBinaryBuffer[MAX_PATH];
    PCTSTR DisplayName = NULL, LoadOrderGroup = NULL,
           StartName = NULL, Security = NULL, Description = NULL;
    PTSTR DependenciesBuffer;
    DWORD TagId;
    PDWORD NewTag;
    DWORD Err;
    SC_HANDLE SCMHandle, ServiceHandle;
    SC_LOCK SCLock;
    HKEY hKeyService, hKeyEventLog;
    TCHAR RegistryPath[SIZECHARS(REGSTR_PATH_SERVICES) + SIZECHARS(DISTR_EVENTLOG) + (2 * 256)];
    DWORD EventLogKeyDisposition;
    SVCNAME_NODE NewSvcNameNode;
    PSVCNAME_NODE TmpNode;
    BOOL NewService;
    INT PathLen;
    BOOL b, BinaryInSysRoot, ServiceHasTag;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    REGMOD_CONTEXT RegContext;
    BOOL NeedsReboot;

    //
    // Initially, assume we're not doing a null service install.
    //
    *NullDriverInstalled = FALSE;
    NeedsReboot = FALSE;

    //
    // Get the AddService flags.
    //
    if(!SetupGetIntField(LineContext, 2, (PINT)&ServiceInstallFlags)) {
        ServiceInstallFlags = 0;
    }

    //
    // Allow the caller-supplied flags to override the INF.
    //
    ServiceInstallFlags |= Flags;

    //
    // Now get the service name.
    //
    if(!(ServiceName = pSetupGetField(LineContext, 1)) || !(*ServiceName)) {
        //
        // This is only allowed if the SPSVCINST_ASSOCSERVICE flag is set.  That
        // indicates to PnP that a null driver installation is allowed, even
        // though the underlying bus didn't report the device as raw-capable.
        //
        if(ServiceInstallFlags & SPSVCINST_ASSOCSERVICE) {

            if(DevInst) {

                CM_Set_DevInst_Registry_Property(DevInst,
                                                 CM_DRP_SERVICE,
                                                 NULL,
                                                 0,
                                                 0
                                                );
            }

            *NullDriverInstalled = TRUE;
            WriteLogEntry(
                LogContext,
                DRIVER_LOG_VERBOSE,
                MSG_LOG_ADDSERV_NULL,
                NULL);
            return NO_ERROR;

        } else {
            return GetLastError();
        }
    }

    //
    // Next, get the name of the