 DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusResLogEventWithName2(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusResLogEventWithName3(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );

#define ClusResLogSystemEventByKey(_hKey_, _level_, _msgid_)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

#define ClusResLogSystemEventByKey1(_hKey_, _level_, _msgid_, _arg1_)       \
    ClusResLogEventWithName1(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_)

#define ClusResLogSystemEventByKey2(_hKey_, _level_, _msgid_, _arg1_, _arg2_)       \
    ClusResLogEventWithName2(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_,                         \
                             _arg2_)

#define ClusResLogSystemEventByKey3(_hKey_, _level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusResLogEventWithName3(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_,                         \
                             _arg2_,                         \
                             _arg3_)

#define ClusResLogSystemEventByKeyData(_hKey_, _level_, _msgid_, dwBytes, pData)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData)

#define ClusResLogSystemEventByKeyData1(_hKey_, _level_, _msgid_, dwBytes, pData, _arg1_)       \
    ClusResLogEventWithName1(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData,                          \
                             _arg1_)

#define ClusResLogSystemEventByKeyData2(_hKey_, _level_, _msgid_, dwBytes, pData, _arg1_, _arg2_)       \
    ClusResLogEventWithName2(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData,                          \
                             _arg1_,                         \
                             _arg2_)

#define ClusResLogSystemEventByKeyData3(_hKey_, _level_, _msgid_, dwBytes, pData, _arg1_, _arg2_, _arg3_)       \
    ClusResLogEventWithName3(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData,                          \
                             _arg1_,                         \
                             _arg2_,                         \
                             _arg3_)

#define ClusResLogSystemEvent0(_level_, _msgid_)           \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL)

#define ClusResLogSystemEvent1(_level_, _msgid_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define ClusResLogSystemEvent2(_level_, _msgid_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogSystemEvent3(_level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

#define ClusResLogSystemEventData(_level_, _msgid_, _dwBytes_, _pData_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_))

#define ClusResLogSystemEventData1(_level_, _msgid_, _dwBytes_, _pData_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_))

#define ClusResLogSystemEventData2(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogSystemEventData3(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

//
// interfaces for GENAPP
//
extern CLRES_FUNCTION_TABLE GenAppFunctionTable;

BOOLEAN
WINAPI
GenAppDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for GENSVC
//
extern CLRES_FUNCTION_TABLE GenSvcFunctionTable;

BOOLEAN
WINAPI
GenSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for DISKS and FTSET
//
extern CLRES_FUNCTION_TABLE DisksFunctionTable;
extern CLRES_FUNCTION_TABLE FtSetFunctionTable;

BOOLEAN
WINAPI
DisksDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

BOOLEAN
WINAPI
FtSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for NETNAME
//
extern CLRES_FUNCTION_TABLE NetNameFunctionTable;

BOOLEAN
WINAPI
NetNameDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for IPADDR
//
extern CLRES_FUNCTION_TABLE IpAddrFunctionTable;

BOOLEAN
WINAPI
IpAddrDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for File Shares
//
extern CLRES_FUNCTION_TABLE SmbShareFunctionTable;

BOOLEAN
WINAPI
SmbShareDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Spool Service
//
extern CLRES_FUNCTION_TABLE SplSvcFunctionTable;

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for Local Quorum
//
extern CLRES_FUNCTION_TABLE LkQuorumFunctionTable;

BOOLEAN
WINAPI
LkQuorumDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE DhcpFunctionTable;

BOOLEAN
WINAPI
DhcpDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for MSMQ Server
//
extern CLRES_FUNCTION_TABLE MsMQFunctionTable;

BOOLEAN
WINAPI
MsMQDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DTC Server
//
extern CLRES_FUNCTION_TABLE MsDTCFunctionTable;

BOOLEAN
WINAPI
MsDTCDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Time Service
//
extern CLRES_FUNCTION_TABLE TimeSvcFunctionTable;

BOOLEAN
WINAPI
TimeSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for WINS Server
//
extern CLRES_FUNCTION_TABLE WinsFunctionTable;

BOOLEAN
WINAPI
WinsDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Generic Script
//
extern CLRES_FUNCTION_TABLE GenScriptFunctionTable;

BOOLEAN
WINAPI
GenScriptDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Majority Node Set
//
extern CLRES_FUNCTION_TABLE MajorityNodeSetFunctionTable;

BOOLEAN
WINAPI
MajorityNodeSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\inc\clusstrs.h ===
#define RES_NETNAME_COMPUTER_ACCOUNT_DESCRIPTION    12000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ipaddr\ipaddr.c ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    ipaddr.c

Abstract:

    Resource DLL for an IP address.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

#define UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include <winsock.h>
#include <ipexport.h>
#include <icmpapi.h>
#include "util.h"
#include "nteapi.h"
#include <dnsapi.h>


//
// Private Constants
//
#define LOG_CURRENT_MODULE LOG_MODULE_IPADDR

#define INVALID_NTE_CONTEXT  0xFFFFFFFF

#define MAX_NODE_ID_LENGTH       5
#define NETINTERFACE_ID_LENGTH  36   // size of a guid
#define NETWORK_ID_LENGTH       36

#define PROP_NAME__NETWORK         CLUSREG_NAME_IPADDR_NETWORK
#define PROP_NAME__ADDRESS         CLUSREG_NAME_IPADDR_ADDRESS
#define PROP_NAME__SUBNETMASK      CLUSREG_NAME_IPADDR_SUBNET_MASK
#define PROP_NAME__ENABLENETBIOS   CLUSREG_NAME_IPADDR_ENABLE_NETBIOS


//
// Private Macros
//
#define IpaLogEvent           ClusResLogEvent
#define IpaSetResourceStatus  ClusResSetResourceStatus

#define ARGUMENT_PRESENT( ArgumentPointer )   (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

#define IpaAcquireGlobalLock()  \
            {  \
                DWORD status;  \
                status = WaitForSingleObject(IpaGlobalMutex, INFINITE);  \
            }

#define IpaReleaseGlobalLock()  \
            { \
                BOOL    released;  \
                released = ReleaseMutex(IpaGlobalMutex);  \
            }

#define IpaAcquireResourceLock(_res)   EnterCriticalSection(&((_res)->Lock))
#define IpaReleaseResourceLock(_res)   LeaveCriticalSection(&((_res)->Lock))

#define DBG_PRINT printf


//
// Private Types.
//
typedef struct _IPA_PRIVATE_PROPS {
    PWSTR     NetworkString;
    PWSTR     AddressString;
    PWSTR     SubnetMaskString;
    DWORD     EnableNetbios;
} IPA_PRIVATE_PROPS, *PIPA_PRIVATE_PROPS;

typedef struct _IPA_LOCAL_PARAMS {
    LPWSTR             InterfaceId;
    LPWSTR             InterfaceName;
    LPWSTR             AdapterName;
    LPWSTR             AdapterId;
    IPAddr             NbtPrimaryWinsAddress;
    IPAddr             NbtSecondaryWinsAddress;
} IPA_LOCAL_PARAMS, *PIPA_LOCAL_PARAMS;

typedef struct {
    LIST_ENTRY                    Linkage;
    CLUSTER_RESOURCE_STATE        State;
    DWORD                         FailureStatus;
    RESOURCE_HANDLE               ResourceHandle;
    BOOLEAN                       InternalParametersInitialized;
    IPAddr                        Address;
    IPMask                        SubnetMask;
    DWORD                         EnableNetbios;
    IPA_PRIVATE_PROPS             InternalPrivateProps;
    IPA_LOCAL_PARAMS              LocalParams;
    HNETINTERFACE                 InterfaceHandle;
    DWORD                         NteContext;
    DWORD                         NteInstance;
    LPWSTR                        NbtDeviceName;
    DWORD                         NbtDeviceInstance;
    CLUS_WORKER                   OnlineThread;
    HKEY                          ResourceKey;
    HKEY                          ParametersKey;
    HKEY                          NodeParametersKey;
    HKEY                          NetworksKey;
    HKEY                          InterfacesKey;
    WCHAR                         NodeId[MAX_NODE_ID_LENGTH + 1];
    CRITICAL_SECTION              Lock;
} IPA_RESOURCE, *PIPA_RESOURCE;


//
// Private Data
//
HANDLE               IpaGlobalMutex = NULL;
USHORT               IpaResourceInstance = 0;
HCLUSTER             IpaClusterHandle = NULL;
HCHANGE              IpaClusterNotifyHandle = NULL;
HANDLE               IpaWorkerThreadHandle = NULL;
DWORD                IpaOpenResourceCount = 0;
DWORD                IpaOnlineResourceCount = 0;
LIST_ENTRY           IpaResourceList = {NULL, NULL};
WCHAR                NbtDevicePrefix[] = L"\\Device\\NetBT_Tcpip_{";
WCHAR                NbtDeviceSuffix[] = L"}";
DWORD                IpaMaxIpAddressStringLength = 0;


RESUTIL_PROPERTY_ITEM
IpaResourcePrivateProperties[] = {
    { PROP_NAME__NETWORK,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0, RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,NetworkString)
    },
    { PROP_NAME__ADDRESS,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0, RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,AddressString)
    },
    { PROP_NAME__SUBNETMASK,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0, RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,SubnetMaskString)
    },
    { PROP_NAME__ENABLENETBIOS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      1, 0, 0xFFFFFFFF, 0,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,EnableNetbios)
    },
    { 0 }
};


//
// External Data
//
extern CLRES_FUNCTION_TABLE IpAddrFunctionTable;


//
// Private Routine Headers
//
DWORD
IpaGetPrivateResProperties(
    IN OUT  PIPA_RESOURCE   ResourceEntry,
    OUT     PVOID           OutBuffer,
    IN      DWORD           OutBufferSize,
    OUT     LPDWORD         BytesReturned
    );

DWORD
IpaValidatePrivateResProperties(
    IN OUT PIPA_RESOURCE       ResourceEntry,
    IN     PVOID               InBuffer,
    IN     DWORD               InBufferSize,
    OUT    PIPA_PRIVATE_PROPS  Props
    );

DWORD
IpaSetPrivateResProperties(
    IN OUT PIPA_RESOURCE  ResourceEntry,
    IN     PVOID          InBuffer,
    IN     DWORD          InBufferSize
    );

DWORD
IpaWorkerThread(
    LPVOID   Context
    );

VOID
WINAPI
IpaClose(
    IN RESID Resource
    );


//
// Utility functions
//
BOOLEAN
IpaInit(
    VOID
    )
/*++

Routine Description:

    Process attach initialization routine.

Arguments:

    None.

Return Value:

    TRUE if initialization succeeded. FALSE otherwise.

--*/
{
    INT      err;
    WSADATA  WsaData;


    InitializeListHead(&IpaResourceList);

    ClRtlQueryTcpipInformation(&IpaMaxIpAddressStringLength, NULL, NULL);

    err = WSAStartup(0x0101, &WsaData);

    if (err) {
        return(FALSE);
    }

    IpaGlobalMutex = CreateMutex(NULL, FALSE, NULL);

    if (IpaGlobalMutex == NULL) {
        WSACleanup();
        return(FALSE);
    }

    return(TRUE);

}  // IpaInit


VOID
IpaCleanup(
    VOID
    )
/*++

Routine Description:

    Process detach cleanup routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IpaGlobalMutex != NULL) {
        CloseHandle(IpaGlobalMutex);
        IpaGlobalMutex = NULL;
    }

    WSACleanup();

    return;
}



LPWSTR
IpaGetNameOfNetwork(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN LPCWSTR NetworkId
    )

/*++

Routine Description:

    Get the name of a network from its GUID.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    NetworkId - Supplies the ID of the network.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD       status;
    DWORD       ival;
    DWORD       type;
    DWORD       nameLength;
    WCHAR       name[256];
    LPWSTR      networkName = NULL;
    HKEY        networkKey = NULL;
    FILETIME    fileTime;

    //
    // Enumerate the networks, looking for the specified GUID.
    //
    for ( ival = 0 ; ; ival++ ) {
        nameLength = sizeof(name);
        status = ClusterRegEnumKey( ResourceEntry->NetworksKey,
                                    ival,
                                    name,
                                    &nameLength,
                                    &fileTime );
        if ( status == ERROR_MORE_DATA ) {
            continue;
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If we found a match, open the key and read the name.
        //
        if ( lstrcmpiW( name, NetworkId ) == 0 ) {
            status = ClusterRegOpenKey( ResourceEntry->NetworksKey,
                                        name,
                                        KEY_READ,
                                        &networkKey );
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            //
            // Get the size of the name value.
            //
            status = ClusterRegQueryValue( networkKey,
                                           CLUSREG_NAME_NET_NAME,
                                           &type,
                                           NULL,
                                           &nameLength );
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            //
            // Allocate memory for the network name.
            //
            networkName = LocalAlloc( LMEM_FIXED, nameLength );
            if ( networkName == NULL ) {
                status = GetLastError();
                goto error_exit;
            }

            //
            // Read the name value.
            //
            status = ClusterRegQueryValue( networkKey,
                                           CLUSREG_NAME_NET_NAME,
                                           &type,
                                           (LPBYTE) networkName,
                                           &nameLength );
            if ( status != ERROR_SUCCESS ) {
                LocalFree( networkName );
                networkName = NULL;
                goto error_exit;
            }

            break;
        }
    }

error_exit:
    if ( networkKey != NULL ) {
        ClusterRegCloseKey( networkKey );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }
    return(networkName);

} // IpaGetNameOfNetwork


PWCHAR
WcsDup(
    IN PWCHAR str
    )

/*++

Routine Description:

    Duplicates the string.
    It does the same as _wcsdup, except that
    it uses LocalAlloc for allocation

Arguments:

    str - string to be copied

Return Value:

    String allocated using LocalAlloc() containing the copy
        of str.

    NULL - not enough memory

--*/
{
    UINT   n = (wcslen(str) + 1) * sizeof(WCHAR);
    PWCHAR result = LocalAlloc( LMEM_FIXED , n );

    if (result) {
        CopyMemory( result, str, n );
    }

    return result;
}


DWORD
IpaPatchNetworkGuidIfNecessary(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN OUT PIPA_PRIVATE_PROPS props
    )

/*++

Routine Description:

    Check whether network GUID exists in cluster registry
    If there is no such network,
    it will try to find a compatible network

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    props - Supplies IP address properties.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       ival;
    DWORD       type;
    DWORD       bufLength;
    WCHAR       buf[256];
    DWORD       nameLength;
    WCHAR       name[256];
    PWCHAR      match = NULL;

    ULONG       networkAddr;
    ULONG       networkMask;
    ULONG       ipAddr;
    ULONG       ipAddrMask;

    BOOLEAN     guidFound = FALSE;

    HKEY        networkKey = NULL;
    FILETIME    fileTime;

    if (props == NULL) {
        return ERROR_SUCCESS;
    }

    if ( props->NetworkString == NULL ) {
        return ERROR_SUCCESS;
    }

    if ( props->AddressString == NULL
       || !UnicodeInetAddr(props->AddressString, &ipAddr) )
    {
        return ERROR_SUCCESS;
    }

    if ( props->SubnetMaskString == NULL
        || !UnicodeInetAddr(props->SubnetMaskString, &ipAddrMask) )
    {
        return ERROR_SUCCESS;
    }

    //
    // Enumerate the networks, looking for the specified GUID.
    //
    for ( ival = 0 ; ; ival++ ) {
        nameLength = sizeof(name);
        status = ClusterRegEnumKey( ResourceEntry->NetworksKey,
                                    ival,
                                    name,
                                    &nameLength,
                                    &fileTime );
        if ( status == ERROR_MORE_DATA ) {
            continue;
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If we found a match, then we don't have to do anything
        //
        if ( lstrcmpiW( name, props->NetworkString ) == 0 ) {
            guidFound = TRUE;
            break;
        }

        if ( networkKey != NULL ) {
            ClusterRegCloseKey( networkKey );
            networkKey = NULL;
        }
        //
        // Check whether ip address fit this network
        //
        status = ClusterRegOpenKey( ResourceEntry->NetworksKey,
                                    name,
                                    KEY_READ,
                                    &networkKey );

        if ( status != ERROR_SUCCESS ) {
            continue;
        }

        //
        // Get the network address
        //
        bufLength = sizeof(buf);
        status = ClusterRegQueryValue( networkKey,
                                       CLUSREG_NAME_NET_ADDRESS,
                                       &type,
                                       (LPBYTE)buf,
                                       &bufLength );
        if ( status != ERROR_SUCCESS
         || !UnicodeInetAddr(buf, &networkAddr) )
        {
            continue;
        }

        //
        // Get subnet mask
        //
        bufLength = sizeof(buf);
        status = ClusterRegQueryValue( networkKey,
                                       CLUSREG_NAME_NET_ADDRESS_MASK,
                                       &type,
                                       (LPBYTE)buf,
                                       &bufLength );
        if ( status != ERROR_SUCCESS
         || !UnicodeInetAddr(buf, &networkMask) )
        {
            continue;
        }

        (IpaLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Checking if resource is orphaned: network masks %1!08X!=%2!08X! "
            L"and addresses %3!08X!^%4!08X!.\n",
            ipAddrMask, networkMask,
            ipAddr, networkAddr
            );

        if ( networkMask != ipAddrMask) {
            continue;
        }

        if ( ((ipAddr ^ networkAddr) & networkMask) != 0 ) {
            continue;
        }
        //
        // Okay we've found a suitable network
        // create a string with its name
        //

        match = WcsDup( name );
        break;

    }

    if ( !guidFound && match ) {
        //
        // We need to patch network information
        //
        LocalFree(props->NetworkString);
        props->NetworkString = match;

        status = ClusterRegSetValue(
                     ResourceEntry->ParametersKey,
                     CLUSREG_NAME_IPADDR_NETWORK,
                     REG_SZ,
                     (LPBYTE) match,
                     (wcslen(match) + 1) * sizeof(WCHAR)
                     );

        (IpaLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"Patch with network GUID %2!ws!, status %1!u!.\n",
            status,
            match
            );

        match = NULL;
    }

    if ( networkKey != NULL ) {
        ClusterRegCloseKey( networkKey );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    if (match != NULL) {
        LocalFree(match);
    }

    return(status);

} // IpaPatchNetworkGuidIfNecessary

LPWSTR
IpaGetNameOfNetworkPatchGuidIfNecessary(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN OUT PIPA_PRIVATE_PROPS props
    )

/*++

Routine Description:

    Get the name of a network from its GUID.
    If the guid cannot be found, it will try to find
    appropriate network using IpaPatchNetworkGuidIfNecessary routine

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    props - Supplies IP address properties.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD status;
    LPWSTR result = IpaGetNameOfNetwork(ResourceEntry, props->NetworkString);
    if (result) {
        return result;
    }

    status = IpaPatchNetworkGuidIfNecessary(ResourceEntry, props);
    if (status != ERROR_SUCCESS) {
        SetLastError( status );
        return 0;
    }

    return IpaGetNameOfNetwork(ResourceEntry, props->NetworkString);
} // IpaGetNameOfNetworkPatchGuidIfNecessary


LPWSTR
IpaGetIdOfNetwork(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN LPCWSTR NetworkName
    )

/*++

Routine Description:

    Get the ID of a network from its name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    NetworkName - Supplies the name of the network.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD       status;
    DWORD       networkIdLength;
    LPWSTR      networkId = NULL;
    HCLUSTER    hcluster = NULL;
    HNETWORK    hnetwork = NULL;

    //
    // Open the cluster.
    //
    hcluster = OpenCluster( NULL );
    if ( hcluster == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Open the network.
    //
    hnetwork = OpenClusterNetwork( hcluster, NetworkName );
    if ( hnetwork == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Get the network ID length.
    //
    networkIdLength = 0;
    status = GetClusterNetworkId( hnetwork,
                                  NULL,
                                  &networkIdLength );
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Allocate a string buffer.
    //
    networkId = LocalAlloc( LMEM_FIXED, (networkIdLength + 1) * sizeof(WCHAR) );
    if ( networkId == NULL ) {
        status = GetLastError();
        goto error_exit;
    }
    networkIdLength++;

    //
    // Get the network ID.
    //
    status = GetClusterNetworkId( hnetwork,
                                  networkId,
                                  &networkIdLength );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( networkId );
        networkId = NULL;
    }

error_exit:
    if ( hnetwork != NULL ) {
        CloseClusterNetwork( hnetwork );
    }
    if ( hcluster != NULL ) {
        CloseCluster( hcluster );
    }

    return( networkId );

} // IpaGetIdOfNetwork


VOID
IpaDeleteNte(
    IN OUT LPDWORD          NteContext,
    IN     HKEY             NodeParametersKey,
    IN     RESOURCE_HANDLE  ResourceHandle
    )
/*++

Routine Description:

    Deletes a previously created NTE.

Arguments:

    NteContext - A pointer to a variable containing the context value
                 identifying the NTE to delete.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

Return Value:

    None.

--*/
{
    DWORD status;


    ASSERT(*NteContext != INVALID_NTE_CONTEXT);
    ASSERT(ResourceHandle != NULL);

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Deleting IP interface %1!u!.\n",
        *NteContext
        );

    status = TcpipDeleteNTE(*NteContext);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"Failed to delete IP interface %1!u!, status %2!u!.\n",
            *NteContext,
            status
            );
    }

    *NteContext = INVALID_NTE_CONTEXT;

    //
    // Clear the NTE information from the registry
    //
    if (NodeParametersKey != NULL) {
        status = ClusterRegDeleteValue(
                     NodeParametersKey,
                     L"InterfaceContext"
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Failed to delete IP interface information from database, status %1!u!.\n",
                status
                );
        }
    }

    return;

}  // IpaDeleteNte


DWORD
IpaCreateNte(
    IN  LPWSTR           AdapterId,
    IN  HKEY             NodeParametersKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    OUT LPDWORD          NteContext,
    OUT LPDWORD          NteInstance
    )
/*++

Routine Description:

    Creates a new NTE to hold an IP address.

Arguments:

    AdapterId - A pointer to a buffer containing the unicode name
                  of the adapter on which the NTE is to be created.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

    NteContext - A pointer to a variable into which to place the context value
                 which identifies the new NTE.

    NteInstance - A pointer to a variable into which to place the instance value
                  which identifies the new NTE.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD status;


    *NteContext = INVALID_NTE_CONTEXT;

    status = TcpipAddNTE(
                 AdapterId,
                 0,
                 0,
                 NteContext,
                 NteInstance
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create new IP interface, status %1!u!\n",
            status);
        return(status);
    }

    //
    // Write the NTE information to the registry
    //
    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"InterfaceContext",
                 REG_DWORD,
                 (LPBYTE) NteContext,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write IP interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"InterfaceInstance",
                 REG_DWORD,
                 (LPBYTE) NteInstance,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write IP interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Created IP interface %1!u! (instance 0x%2!08X!).\n",
        *NteContext,
        *NteInstance
        );

    return(ERROR_SUCCESS);


error_exit:

    if (*NteContext != INVALID_NTE_CONTEXT) {
        IpaDeleteNte(
            NteContext,
            NodeParametersKey,
            ResourceHandle
            );
    }

    return(status);
}


VOID
IpaDeleteNbtInterface(
    IN OUT LPWSTR *         NbtDeviceName,
    IN     HKEY             NodeParametersKey,
    IN     RESOURCE_HANDLE  ResourceHandle
    )
/*++

Routine Description:

    Deletes an NBT device (interface).

Arguments:

    NbtDeviceName - A pointer to a buffer containing the unicode name
                    of the NBT device to delete.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

Return Value:

    None.

--*/
{
    DWORD status;


    ASSERT(*NbtDeviceName != NULL);
    ASSERT(ResourceHandle != NULL);

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Deleting NBT interface %1!ws!.\n",
        *NbtDeviceName
        );

    status = NbtDeleteInterface(*NbtDeviceName);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"Failed to delete NBT interface %1!ws!, status %2!u!.\n",
            *NbtDeviceName,
            status
            );
    }

    LocalFree(*NbtDeviceName);
    *NbtDeviceName = NULL;

    //
    // Clear the interface information from the registry
    //
    if (NodeParametersKey != NULL) {
        status = ClusterRegDeleteValue(
                     NodeParametersKey,
                     L"NbtDeviceName"
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Failed to delete NBT interface information from database, status %1!u!.\n",
                status
                );
        }
    }

    return;

} // IpaDeleteNbtInterface


DWORD
IpaCreateNbtInterface(
    IN  HKEY             NodeParametersKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    OUT LPWSTR *         NbtDeviceName,
    OUT LPDWORD          NbtDeviceInstance
    )
/*++

Routine Description:

    Creates a new NBT device (interface) to be bound to an IP address.

Arguments:

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

    NbtDeviceName - A pointer to a buffer into which to place the unicode name
                    of the new NBT device.

    NbtDeviceInstance - A pointer to a variable into which to place the instance
                        value which identifies the new NBT device.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD status;
    DWORD deviceNameSize = 38;  // size of L"\\Device\\NetBt_Ifxx\0"


    *NbtDeviceName = NULL;

    do {
        if (*NbtDeviceName != NULL) {
            LocalFree(*NbtDeviceName);
            *NbtDeviceName = NULL;
        }

        *NbtDeviceName = LocalAlloc(LMEM_FIXED, deviceNameSize);

        if (*NbtDeviceName == NULL) {
            (IpaLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate memory.\n");
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        status = NbtAddInterface(
                     *NbtDeviceName,
                     &deviceNameSize,
                     NbtDeviceInstance
                     );

    } while (status == STATUS_BUFFER_TOO_SMALL);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create new NBT interface, status %1!u!\n",
            status
            );

        if (*NbtDeviceName != NULL) {
            LocalFree(*NbtDeviceName);
            *NbtDeviceName = NULL;
        }

        return(status);
    }

    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"NbtDeviceName",
                 REG_SZ,
                 (LPBYTE) *NbtDeviceName,
                 (lstrlenW(*NbtDeviceName) + 1) * sizeof(WCHAR)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write NBT interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"NbtDeviceInstance",
                 REG_DWORD,
                 (LPBYTE) NbtDeviceInstance,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write NBT interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Created NBT interface %1!ws! (instance 0x%2!08X!).\n",
        *NbtDeviceName,
        *NbtDeviceInstance
        );

    return(ERROR_SUCCESS);


error_exit:

    if (*NbtDeviceName != NULL) {
        IpaDeleteNbtInterface(
            NbtDeviceName,
            NodeParametersKey,
            ResourceHandle
            );
    }

    return(status);
}


VOID
IpaLastOfflineCleanup(
    VOID
    )
/*++

Notes:

    Called with IpaGlobalLock held.
    Returns with IpaGlobalLock released.

--*/
{
    HCHANGE   notifyHandle = IpaClusterNotifyHandle;
    HANDLE    workerThreadHandle = IpaWorkerThreadHandle;


    if (!IsListEmpty(&IpaResourceList)) {
        PIPA_RESOURCE   resource;

        resource = CONTAINING_RECORD(
                       IpaResourceList.Flink,
                       IPA_RESOURCE,
                       Linkage
                       );

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"All resources offline - cleaning up\n"
            );
    }

    IpaClusterNotifyHandle = NULL;
    IpaWorkerThreadHandle = NULL;

    IpaReleaseGlobalLock();

    if (notifyHandle != NULL) {
        CloseClusterNotifyPort(notifyHandle);
    }

    if (workerThreadHandle != NULL) {
        WaitForSingleObject(workerThreadHandle, INFINITE);
        CloseHandle(workerThreadHandle);
    }

    return;

}  // IpaLastOfflineCleanup


DWORD
IpaFirstOnlineInit(
    IN  RESOURCE_HANDLE      ResourceHandle
    )
/*++

Notes:

    Called with IpaGlobalLock held.
    Returns with IpaGlobalLock released.

--*/
{
    DWORD     status = ERROR_SUCCESS;
    DWORD     threadId;


    IpaClusterNotifyHandle = CreateClusterNotifyPort(
                                 INVALID_HANDLE_VALUE,
                                 IpaClusterHandle,
                                 CLUSTER_CHANGE_HANDLE_CLOSE,
                                 0
                                 );

    if (IpaClusterNotifyHandle == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create cluster notify port, status %1!u!.\n",
            status
            );
        goto error_exit;
    }
    else {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Created cluster notify port.\n"
            );
    }

    IpaWorkerThreadHandle = CreateThread(
                                NULL,
                                0,
                                IpaWorkerThread,
                                NULL,
                                0,
                                &threadId
                                );

    if (IpaWorkerThreadHandle == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create worker thread, status %1!u!.\n",
            status
            );
        goto error_exit;
    }
    else {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Created worker thread.\n"
            );
    }

    IpaReleaseGlobalLock();

    return(ERROR_SUCCESS);


error_exit:

    IpaLastOfflineCleanup();
    //
    // The lock was released.
    //

    return(status);

} // IpaFirstOnlineInit


PIPA_RESOURCE
IpaFindResourceInList(
    PVOID  Key
    )
{
    PIPA_RESOURCE   resource;
    PLIST_ENTRY     entry;


    for ( entry = IpaResourceList.Flink;
          entry != &IpaResourceList;
          entry = entry->Flink
        )
    {
        resource = CONTAINING_RECORD(
                       entry,
                       IPA_RESOURCE,
                       Linkage
                       );

        if (resource == Key) {
            return(resource);
        }
    }

    return(NULL);

} // IpaFindResourceInList


VOID
IpaValidateAndOfflineInterfaces(
    IN PIPA_RESOURCE   Resource
    )
{
    DWORD        status;


    //
    // Take care of NBT first.
    //
    if (Resource->NbtDeviceName != NULL) {
        DWORD  instance;
        IPAddr boundAddress;

        //
        // Make sure that this is still our interface.
        //
        status = NbtGetInterfaceInfo(
                     Resource->NbtDeviceName,
                     &boundAddress,
                     &instance
                     );

        if ( (status == ERROR_SUCCESS) &&
             (Resource->NbtDeviceInstance == instance)
           )
        {
            //
            // Clear the WINS addresses
            //
            status = NbtSetWinsAddrInterface(Resource->NbtDeviceName, 0, 0);

            if (status != NO_ERROR) {
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_WARNING,
                    L"Failed to clear WINS addresses for NBT device %1!ws!, status %2!u!.\n",
                    Resource->NbtDeviceName,
                    status
                    );
            }

            //
            // Unbind the interface from IP if necessary
            //
            if (boundAddress != 0) {
                status = NbtBindInterface(Resource->NbtDeviceName, 0, 0);

                if (status != ERROR_SUCCESS) {
                    //
                    // Delete the interface, since it is misbehaving.
                    //
                    (IpaLogEvent)(
                        Resource->ResourceHandle,
                        LOG_WARNING,
                        L"Failed to unbind NBT device %1!ws!, status %2!u!.\n",
                        Resource->NbtDeviceName,
                        status
                        );
                    IpaDeleteNbtInterface(
                        &(Resource->NbtDeviceName),
                        Resource->NodeParametersKey,
                        Resource->ResourceHandle
                        );
                }
            }
        }
        else {
            //
            // Querying the NBT interface failed. See if we can determine
            // why.
            //
            if (status == ERROR_WORKING_SET_QUOTA
                || status == ERROR_NO_SYSTEM_RESOURCES) {

                //
                // The NBT ioctl probably failed due to low resources.
                // Leave record of the NBT interface in our database. We
                // will clean it up next time we try to bring this resource
                // on-line or (via clusnet) when the cluster service shuts
                // down.
                //
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_INFORMATION,
                    L"NBT interface %1!ws! (instance 0x%2!08X!) could not be queried, status %3!u!.\n",
                    Resource->NbtDeviceName,
                    Resource->NbtDeviceInstance,
                    status
                    );
            }
            else {
                
                //
                // The interface is no longer valid or it isn't ours.
                // Forget about it.
                //
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_INFORMATION,
                    L"NBT interface %1!ws! (instance 0x%2!08X!) is no longer valid, status %3!u!.\n",
                    Resource->NbtDeviceName,
                    Resource->NbtDeviceInstance,
                    status
                    );
                LocalFree(Resource->NbtDeviceName);
                Resource->NbtDeviceName = NULL;

                if (Resource->NodeParametersKey != NULL) {
                    status = ClusterRegDeleteValue(
                                 Resource->NodeParametersKey,
                                 L"NbtDeviceName"
                                 );

                    if (status != ERROR_SUCCESS) {
                        (IpaLogEvent)(
                            Resource->ResourceHandle,
                            LOG_WARNING,
                            L"Failed to delete NBT interface information from database, status %1!u!.\n",
                            status
                            );
                    }
                }
            }
        }
    }

    //
    // Now take care of IP
    //
    if (Resource->NteContext != INVALID_NTE_CONTEXT) {
        TCPIP_NTE_INFO  nteInfo;

        //
        // Make sure that this is still our interface.
        //
        status = TcpipGetNTEInfo(
                     Resource->NteContext,
                     &nteInfo
                     );

        if ( (status == ERROR_SUCCESS) &&
             (nteInfo.Instance == Resource->NteInstance)
           )
        {

            //
            // In Windows 2000, TCP/IP ignores requests to set the address
            // of an NTE if the underlying interface is disconnected.
            // This can result in the same IP address being brought online
            // on two different nodes. In order to workaround this bug
            // in TCP/IP, we now delete the NTE during offline processing
            // instead of reusing it.
            //
            // Note that IpaDeleteNte() invalidates the value
            // of Resource->NteContext.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

#if 0
            //
            // If the NTE is still online, take care of that.
            //
            if (nteInfo.Address != 0) {
                status = TcpipSetNTEAddress(Resource->NteContext, 0, 0);

                if (status != ERROR_SUCCESS) {
                    //
                    // Delete the interface, since it is misbehaving.
                    //
                    (IpaLogEvent)(
                        Resource->ResourceHandle,
                        LOG_WARNING,
                        L"Failed to clear address for IP Interface %1!u!, status %2!u!.\n",
                        Resource->NteContext,
                        status
                        );

                    IpaDeleteNte(
                        &(Resource->NteContext),
                        Resource->NodeParametersKey,
                        Resource->ResourceHandle
                        );
                }
            }
#endif
        }
        else {
            //
            // The NTE is no longer valid or isn't ours. Forget about it.
            //
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_INFORMATION,
                L"IP interface %1!u! (instance 0x%2!08X!) is no longer valid.\n",
                Resource->NteContext,
                Resource->NteInstance
                );

            Resource->NteContext = INVALID_NTE_CONTEXT;

            if (Resource->NodeParametersKey != NULL) {
                status = ClusterRegDeleteValue(
                             Resource->NodeParametersKey,
                             L"InterfaceContext"
                             );

                if (status != ERROR_SUCCESS) {
                    (IpaLogEvent)(
                        Resource->ResourceHandle,
                        LOG_WARNING,
                        L"Failed to delete IP interface information from database, status %1!u!.\n",
                        status
                        );
                }
            }
        }
        
        //
        // Tell the DNS resolver to update its list of local ip addresses.
        //
        // BUGBUG - The DNS resolver should do this automatically based
        //          on PnP events in the Whistler release. Remove this code 
        //          after verifiying that functionality.
        //
        //          This issue is tracked with bug 97134.
        // DnsNotifyResolver(0, 0);
        DnsNotifyResolverClusterIp((IP_ADDRESS)Resource->Address, FALSE);
    }

    return;

}  // IpaValidateAndOfflineInterfaces


DWORD
IpaGetNodeParameters(
    PIPA_RESOURCE   Resource,
    BOOL            OkToCreate
    )

/*++

Routine Description:

    get any node based parameters from the registry. We can't call create
    during IpaOpen so this won't do much for the first open of a new resource.

Arguments:

    Resource - pointer to IP internal resource data block

    OkToCreate - true if we can use ClusterRegCreateKey instead of
                 ClusterRegOpenKey

Return Value:

    success if everything worked ok

--*/

{
    DWORD status;

    if (Resource->NodeParametersKey == NULL) {
        //
        // create or open the resource's node-specific parameters key.
        //
        if ( OkToCreate ) {
            status = ClusterRegCreateKey(Resource->ParametersKey,
                                         Resource->NodeId,
                                         0,
                                         KEY_READ,
                                         NULL,
                                         &(Resource->NodeParametersKey),
                                         NULL);
        }
        else {
            status = ClusterRegOpenKey(Resource->ParametersKey,
                                       Resource->NodeId,
                                       KEY_READ,
                                       &(Resource->NodeParametersKey));
        }

        if (status != NO_ERROR) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to %1!ws! node parameters key, status %2!u!.\n",
                OkToCreate ? L"create" : L"open",
                status
                );

            if ( !OkToCreate ) {
                //
                // we still need to init some values in the resource data
                // block if open fails
                //
                Resource->NteContext = INVALID_NTE_CONTEXT;
                Resource->NteInstance = 0;
                Resource->NbtDeviceName = NULL;
                Resource->NbtDeviceInstance = 0;
            }

            return(status);
        }
    }

    //
    // Read the old TCP/IP and NBT parameters.
    //
    status = ResUtilGetDwordValue(
                 Resource->NodeParametersKey,
                 L"InterfaceContext",
                 &(Resource->NteContext),
                 INVALID_NTE_CONTEXT
                 );

    if (status == ERROR_SUCCESS) {
        status = ResUtilGetDwordValue(
                     Resource->NodeParametersKey,
                     L"InterfaceInstance",
                     &(Resource->NteInstance),
                     0
                     );

        if (status != ERROR_SUCCESS) {
            Resource->NteContext = INVALID_NTE_CONTEXT;
        }
    }

    Resource->NbtDeviceName = ResUtilGetSzValue(
                                  Resource->NodeParametersKey,
                                  L"NbtDeviceName"
                                  );

    if (Resource->NbtDeviceName != NULL) {
        status = ResUtilGetDwordValue(
                     Resource->NodeParametersKey,
                     L"NbtDeviceInstance",
                     &(Resource->NbtDeviceInstance),
                     0
                     );

        if (status != ERROR_SUCCESS) {
            LocalFree(Resource->NbtDeviceName);
            Resource->NbtDeviceName = NULL;
        }
    }

    return status;
}

DWORD
IpaInitializeInternalParameters(
    PIPA_RESOURCE   Resource
    )
{
    DWORD   status;


    ASSERT(Resource->ResourceKey != NULL);
    ASSERT(Resource->ResourceHandle != NULL);

    if (Resource->ParametersKey == NULL) {
        //
        // Open the resource's parameters key.
        //
        status = ClusterRegOpenKey(
                     Resource->ResourceKey,
                     CLUSREG_KEYNAME_PARAMETERS,
                     KEY_READ,
                     &(Resource->ParametersKey)
                     );

        if (status != NO_ERROR) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to open parameters key, status %1!u!.\n",
                status
                );
            return(status);
        }
    }

    if (Resource->NodeParametersKey == NULL) {
        status = IpaGetNodeParameters( Resource, FALSE );
    }

    Resource->InternalParametersInitialized = TRUE;

    return(ERROR_SUCCESS);

}  // IpaInitializeInternalParameters


VOID
IpaFreePrivateProperties(
    IN PIPA_PRIVATE_PROPS  PrivateProps
    )
{
    if (PrivateProps->NetworkString != NULL) {
        LocalFree(PrivateProps->NetworkString);
        PrivateProps->NetworkString = NULL;
    }

    if (PrivateProps->AddressString != NULL) {
        LocalFree(PrivateProps->AddressString);
        PrivateProps->AddressString = NULL;
    }

    if (PrivateProps->SubnetMaskString != NULL) {
        LocalFree(PrivateProps->SubnetMaskString);
        PrivateProps->SubnetMaskString = NULL;
    }

    return;

}  // IpaFreePrivateProperties


VOID
IpaFreeLocalParameters(
    IN PIPA_LOCAL_PARAMS  LocalParams
    )
{
    if (LocalParams->InterfaceId != NULL) {
        LocalFree(LocalParams->InterfaceId);
        LocalParams->InterfaceId = NULL;
    }

    if (LocalParams->InterfaceName != NULL) {
        LocalFree(LocalParams->InterfaceName);
        LocalParams->InterfaceName = NULL;
    }

    if (LocalParams->AdapterName != NULL) {
        LocalFree(LocalParams->AdapterName);
        LocalParams->AdapterName = NULL;
    }

    if (LocalParams->AdapterId != NULL) {
        LocalFree(LocalParams->AdapterId);
        LocalParams->AdapterId = NULL;
    }

    return;

} // IpaFreeLocalParameters


DWORD
IpaGetLocalParameters(
    IN      PIPA_RESOURCE       Resource,
    IN OUT  PIPA_LOCAL_PARAMS   LocalParams
    )
/*++

Routine Description:

    Reads the local parameters needed to bring an IP address resource online.

Arguments:

    Resource - Resource structure for the resource.

    LocalParams - A pointer to a structure to fill in with the new
                  local parameters.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD    status;
    DWORD    valueType;
    LPWSTR   deviceName;
    DWORD    deviceNameLength;
    HKEY     interfaceKey = NULL;
    WCHAR    networkId[NETWORK_ID_LENGTH + 1];
    WCHAR    nodeId[MAX_NODE_ID_LENGTH];
    DWORD    i;
    DWORD    valueLength;
    DWORD    type;
    DWORD    interfaceIdSize = (NETINTERFACE_ID_LENGTH + 1 ) * sizeof(WCHAR);


    ZeroMemory(LocalParams, sizeof(IPA_LOCAL_PARAMS));

    LocalParams->InterfaceId = LocalAlloc(LMEM_FIXED, interfaceIdSize);

    if (LocalParams->InterfaceId == NULL) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to allocate memory for netinterface ID.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Enumerate the interface keys looking for the right one for this
    // node/network.
    //
    for (i=0; ;i++) {
        if (interfaceKey != NULL) {
            ClusterRegCloseKey(interfaceKey); interfaceKey = NULL;
        }

        valueLength = interfaceIdSize;

        status = ClusterRegEnumKey(
                     Resource->InterfacesKey,
                     i,
                     LocalParams->InterfaceId,
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            if ( status == ERROR_NO_MORE_ITEMS ) {
                status = ERROR_NETWORK_NOT_AVAILABLE;
            }

            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Open: Unable to find netinterface for node %1!ws! on network %2!ws!, status %3!u!.\n",
                Resource->NodeId,
                Resource->InternalPrivateProps.NetworkString,
                status
                );
            goto error_exit;
        }

        //
        // Open the enumerated interface key
        //
        status = ClusterRegOpenKey(
                     Resource->InterfacesKey,
                     LocalParams->InterfaceId,
                     KEY_READ,
                     &interfaceKey
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Open: Unable to open key for network interface %1!ws!, status %2!u!.\n",
                LocalParams->InterfaceId,
                status
                );
            continue;
        }

        //
        // Read the node value.
        //
        valueLength = sizeof(nodeId);

        status = ClusterRegQueryValue(
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_NODE,
                     &type,
                     (LPBYTE) &(nodeId[0]),
                     &valueLength
                     );

        if ( status != ERROR_SUCCESS ) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Open: Unable to read node value for netinterface %1!ws!, status %2!u!.\n",
                LocalParams->InterfaceId,
                status
                );
            continue;
        }

        if (wcscmp(Resource->NodeId, nodeId) != 0) {
            continue;
        }

        //
        // Read the network value.
        //
        valueLength = sizeof(networkId);

        status = ClusterRegQueryValue(
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_NETWORK,
                     &type,
                     (LPBYTE) &(networkId[0]),
                     &valueLength
                     );

        if ( status != ERROR_SUCCESS ) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Open: Unable to read network value for netinterface %1!ws!, status %2!u!.\n",
                LocalParams->InterfaceId,
                status
                );
            continue;
        }

        if (wcscmp(
                Resource->InternalPrivateProps.NetworkString,
                networkId
                ) == 0
           )
        {
            //
            // Found the right interface key.
            //
            break;
        }
    }

    //
    // Read the adapter name for the interface.
    //
    LocalParams->AdapterName = ResUtilGetSzValue(
                                   interfaceKey,
                                   CLUSREG_NAME_NETIFACE_ADAPTER_NAME
                                   );

    if (LocalParams->AdapterName == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read adapter name parameter for interface %1!ws!, status %2!u!.\n",
            LocalParams->InterfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Read the adapter Id for the interface.
    //
    LocalParams->AdapterId = ResUtilGetSzValue(
                                   interfaceKey,
                                   CLUSREG_NAME_NETIFACE_ADAPTER_ID
                                   );

    if (LocalParams->AdapterId == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read adapter Id parameter for interface %1!ws!, status %2!u!.\n",
            LocalParams->InterfaceId,
            status
            );
        goto error_exit;
    }

    LocalParams->InterfaceName = ResUtilGetSzValue(
                                     interfaceKey,
                                     CLUSREG_NAME_NETIFACE_NAME
                                     );

    if (LocalParams->InterfaceName == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read name for netinterface %1!ws!, status %2!u!.\n",
            LocalParams->InterfaceId,
            status
            );
        goto error_exit;
    }

    ClusterRegCloseKey(interfaceKey); interfaceKey = NULL;

    //
    // Get the WINS addresses for this interface.
    //
    deviceNameLength = sizeof(WCHAR) * ( lstrlenW(NbtDevicePrefix) +
                                         lstrlenW(LocalParams->AdapterId) +
                                         lstrlenW(NbtDeviceSuffix) + 1
                                       );

    deviceName = LocalAlloc(LMEM_FIXED, deviceNameLength);

    if (deviceName == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory for NBT device name.\n"
            );
        goto error_exit;
    }

    lstrcpyW(deviceName, NbtDevicePrefix);
    lstrcatW(deviceName, LocalParams->AdapterId);
    lstrcatW(deviceName, NbtDeviceSuffix);

    status = NbtGetWinsAddresses(
                 deviceName,
                 &(LocalParams->NbtPrimaryWinsAddress),
                 &(LocalParams->NbtSecondaryWinsAddress)
                 );

    LocalFree(deviceName);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_WARNING,
            L"Unable to determine WINS server addresses for adapter %1!ws!, status %2!u!\n",
            LocalParams->AdapterName,
            status
            );

        //
        // NBT sets the WINS server addresses to loopback by default.
        //
        LocalParams->NbtPrimaryWinsAddress = inet_addr("127.0.0.1");
        LocalParams->NbtSecondaryWinsAddress =
            LocalParams->NbtPrimaryWinsAddress;
    }

    status = ERROR_SUCCESS;

error_exit:

    if (interfaceKey != NULL) {
        ClusterRegCloseKey(interfaceKey);
    }

    if (status != ERROR_SUCCESS) {
        IpaFreeLocalParameters(LocalParams);
    }

    return(status);

} // IpaGetLocalParameters


//
// Primary Resource Functions
//
BOOLEAN
WINAPI
IpAddrDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD     Reason,
    IN LPVOID    Reserved
    )
{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        return(IpaInit());
        break;

    case DLL_PROCESS_DETACH:
        IpaCleanup();
        break;

    default:
        break;
    }

    return(TRUE);
}



RESID
WINAPI
IpaOpen(
    IN LPCWSTR          ResourceName,
    IN HKEY             ResourceKey,
    IN RESOURCE_HANDLE  ResourceHandle
    )

/*++

Routine Description:

    Open routine for IP Address resource

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - a registry key for access registry information for this
            resource.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    NULL on failure

--*/

{
    DWORD           status;
    PIPA_RESOURCE   resource = NULL;
    DWORD           nodeIdSize = MAX_NODE_ID_LENGTH + 1;
    HKEY            clusterKey = NULL;


    IpaAcquireGlobalLock();

    if (IpaOpenResourceCount == 0) {
        ASSERT(IpaClusterHandle == NULL);

        IpaClusterHandle = OpenCluster(NULL);

        if (IpaClusterHandle == NULL) {
            status = GetLastError();
            IpaReleaseGlobalLock();
            (IpaLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to open cluster handle, status %1!u!.\n",
                status
                );
            return(0);
        }
    }

    IpaOpenResourceCount++;

    IpaReleaseGlobalLock();

    resource = LocalAlloc(
                   (LMEM_FIXED | LMEM_ZEROINIT),
                   sizeof(IPA_RESOURCE)
                   );

    if (resource == NULL) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Resource allocation failed.\n"
            );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(0);
    }

    //
    // Initialize known fields.
    //
    InitializeCriticalSection(&(resource->Lock));
    resource->ResourceHandle = ResourceHandle;
    resource->State = ClusterResourceOffline;
    resource->NteContext = INVALID_NTE_CONTEXT;

    //
    // Initialize the Linkage field as a list head. This
    // prevents an AV in IpaClose if IpaOpen fails before
    // the resource is added to IpaResourceList.
    //
    InitializeListHead(&(resource->Linkage));

    //
    // Allocate an address string buffer.
    //
    resource->InternalPrivateProps.AddressString =
        LocalAlloc(
            LMEM_FIXED,
            ( (IpaMaxIpAddressStringLength + 1) *
                sizeof(WCHAR)
            ));

    if (resource->InternalPrivateProps.AddressString == NULL) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Resource allocation failed.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    lstrcpyW(resource->InternalPrivateProps.AddressString, L"[Unknown]");

    //
    // Figure out what node we're running on.
    //
    status = GetCurrentClusterNodeId(
                 &(resource->NodeId[0]),
                 &nodeIdSize
                 );

    if ( status != ERROR_SUCCESS ) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get local node ID, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open a private handle to our resource key so that we can get our
    // name later if we need to log an event.
    //
    status = ClusterRegOpenKey(
                 ResourceKey,
                 L"",
                 KEY_READ,
                 &(resource->ResourceKey)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open resource key. Error: %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open a key to the networks portion of the cluster registry.
    //
    clusterKey = GetClusterKey(IpaClusterHandle, KEY_READ);

    if (clusterKey == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open cluster registry key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClusterRegOpenKey(
                 clusterKey,
                 L"Networks",
                 KEY_READ,
                 &(resource->NetworksKey)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open networks registry key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open a key to the interfaces portion of the cluster registry.
    //
    status = ClusterRegOpenKey(
                 clusterKey,
                 L"NetworkInterfaces",
                 KEY_READ,
                 &(resource->InterfacesKey)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open network interfaces registry key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClusterRegCloseKey(clusterKey); clusterKey = NULL;

    status = IpaInitializeInternalParameters(resource);

    if (status == ERROR_SUCCESS) {
        //
        // Validate our TCP/IP and NBT parameters and clean up any old
        // interfaces we left hanging around from the last run.
        //
        IpaValidateAndOfflineInterfaces(resource);
    }

    //
    // Link the resource onto the global list.
    //
    IpaAcquireGlobalLock();

    InsertTailList(&IpaResourceList, &(resource->Linkage));

    IpaReleaseGlobalLock();

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Resource open, resource ID = %1!u!.\n",
        resource
        );

    return(resource);

error_exit:

    IpaClose((RESID) resource);

    if (clusterKey != NULL) {
        ClusterRegCloseKey(clusterKey);
    }

    SetLastError( status );

    return(0);

} // IpaOpen



VOID
WINAPI
IpaDoOfflineProcessing(
    IN PIPA_RESOURCE      Resource,
    IN RESOURCE_STATUS *  ResourceStatus
    )

/*++

Routine Description:

    Final offline processing for IP Address resource.

Arguments:

    Resource - supplies the resource it to be taken offline

Return Value:

    None.

Notes:

    Called with the resource lock held.
    Returns with the resource lock released.

--*/

{
    DWORD          status = ERROR_SUCCESS;
    ULONG          address = 0, mask = 0;
    HNETINTERFACE  ifHandle;


    ASSERT(Resource->State == ClusterResourceOfflinePending);

    IpaValidateAndOfflineInterfaces(Resource);

    //
    // Make local copies of external resource handles
    //
    ifHandle = Resource->InterfaceHandle;
    Resource->InterfaceHandle = NULL;

    Resource->State = ClusterResourceOffline;

    if (ResourceStatus != NULL) {
        ResourceStatus->CheckPoint++;
        ResourceStatus->ResourceState = ClusterResourceOffline;
        (IpaSetResourceStatus)(Resource->ResourceHandle, ResourceStatus);
    }

    (IpaLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Address %1!ws! on adapter %2!ws! offline.\n",
        Resource->InternalPrivateProps.AddressString,
        ( (Resource->LocalParams.AdapterName != NULL) ?
          Resource->LocalParams.AdapterName : L"[Unknown]"
        ));

    IpaReleaseResourceLock(Resource);

    //
    // Free external resources.
    //
    if (ifHandle != NULL) {
        CloseClusterNetInterface(ifHandle);
    }

    IpaAcquireGlobalLock();

    //
    // If this is the last resource, cleanup the global state.
    //
    ASSERT(IpaOnlineResourceCount > 0);

    if (--IpaOnlineResourceCount == 0) {
        IpaLastOfflineCleanup();
        //
        // The lock was released.
        //
    }
    else {
        IpaReleaseGlobalLock();
    }

    return;

}  // IpaDoOfflineProcessing



VOID
WINAPI
IpaInternalOffline(
    IN PIPA_RESOURCE Resource
    )

/*++

Routine Description:

    Internal offline routine for IP Address resource.

Arguments:

    Resource - supplies the resource it to be taken offline

Return Value:

    None.

--*/

{
    //
    // Terminate the online thread, if it is running.
    //
    ClusWorkerTerminate(&(Resource->OnlineThread));

    //
    // Synchronize IpaOffline, IpaTerminate, and IpaWorkerThread.
    //
    IpaAcquireResourceLock(Resource);

    if (Resource->State == ClusterResourceOffline) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource is already offline.\n"
            );
        IpaReleaseResourceLock(Resource);
        return;
    }

    Resource->State = ClusterResourceOfflinePending;

    IpaDoOfflineProcessing(Resource, NULL);
    //
    // The lock was released.
    //

    return;

}  // IpaInternalOffline



DWORD
WINAPI
IpaOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be taken offline.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD           status;
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) Resource;


    if (resource != NULL) {
        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Taking resource offline...\n"
            );
        IpaInternalOffline(resource);
        status = ERROR_SUCCESS;
    }
    else {
        status = ERROR_RESOURCE_NOT_FOUND;
    }

    return(status);

} // IpaOffline



VOID
WINAPI
IpaTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) Resource;


    if (resource != NULL) {
        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Terminating resource...\n"
            );
        IpaInternalOffline(resource);
    }

    return;

} // IpaTerminate



DWORD
IpaOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PIPA_RESOURCE Resource
    )

/*++

Routine Description:

    Brings an IP address resource online.

Arguments:

    pWorker - Supplies the worker structure

    Resource - A pointer to the IPA_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD                        status = ERROR_SUCCESS;
    DWORD                        i;
    RESOURCE_EXIT_STATE          exit;
    RESOURCE_STATUS              resourceStatus;
    BOOL                         retried;
    IPA_LOCAL_PARAMS             newParams;
    PIPA_LOCAL_PARAMS            localParams = NULL;
    PIPA_PRIVATE_PROPS           privateProps = NULL;
    LPWSTR                       nameOfPropInError = NULL;
    CLUSTER_NETINTERFACE_STATE   state;
    BOOL                         firstOnline = FALSE;
    DWORD                        numTries;


    ZeroMemory(&newParams, sizeof(newParams));

    (IpaLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Online thread running.\n",
        Resource
        );

    IpaAcquireGlobalLock();

    IpaAcquireResourceLock(Resource);

    if (IpaOnlineResourceCount++ == 0) {
        firstOnline = TRUE;
    }

    ResUtilInitializeResourceStatus(&resourceStatus);
    resourceStatus.CheckPoint = 1;
    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        IpaReleaseGlobalLock();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    //
    // If this is the first resource to go online in this process,
    // initialize the global state.
    //
    if (firstOnline) {
        status = IpaFirstOnlineInit(Resource->ResourceHandle);
        //
        // The global lock was released.
        //
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }
    else {
        IpaReleaseGlobalLock();
    }

    resourceStatus.CheckPoint++;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    //
    // Check to see if the online operation was aborted while this thread
    // was starting up.
    //
    if (ClusWorkerCheckTerminate(pWorker)) {
        status = ERROR_OPERATION_ABORTED;
        Resource->State = ClusterResourceOfflinePending;
        goto error_exit;
    }

    if (!Resource->InternalParametersInitialized) {
        status = IpaInitializeInternalParameters(Resource);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }
    else {
        status = IpaGetNodeParameters( Resource, TRUE );
    }

    //
    // Make sure the old interfaces are valid and offline.
    //
    IpaValidateAndOfflineInterfaces(Resource);

    //
    // Read and verify the resource's private properties.
    //
    privateProps = &(Resource->InternalPrivateProps);

    status = ResUtilGetPropertiesToParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 (LPBYTE) privateProps,
                 TRUE, // CheckForRequiredProperties
                 &nameOfPropInError
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status
            );
        goto error_exit;
    }

    Resource->EnableNetbios = privateProps->EnableNetbios;

    //
    // Convert the address and subnet mask strings to binary.
    //
    status = ClRtlTcpipStringToAddress(
                 privateProps->AddressString,
                 &(Resource->Address)
                 );

    if (status != ERROR_SUCCESS) {
        status = ERROR_INVALID_PARAMETER;
        ClusResLogSystemEventByKeyData(
            Resource->ResourceKey,
            LOG_CRITICAL,
            RES_IPADDR_INVALID_ADDRESS,
            sizeof(Resource->Address),
            &(Resource->Address)
            );
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Invalid address %1!ws!.\n",
            privateProps->AddressString
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 privateProps->SubnetMaskString,
                 &(Resource->SubnetMask)
                 );

    if (status != ERROR_SUCCESS) {
        status = ERROR_INVALID_PARAMETER;
        ClusResLogSystemEventByKeyData(
            Resource->ResourceKey,
            LOG_CRITICAL,
            RES_IPADDR_INVALID_SUBNET,
            sizeof(Resource->SubnetMask),
            &(Resource->SubnetMask)
            );
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Invalid subnet mask %1!ws!.\n",
            privateProps->SubnetMaskString
            );
        goto error_exit;
    }

    status = IpaPatchNetworkGuidIfNecessary(Resource, privateProps);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_WARNING,
            L"IpaPatchNetworkGuidIfNecessary failed, status %1!d!.\n",
            status
            );
    }

    //
    // Fetch the resource's parameters for the local node.
    //
    status = IpaGetLocalParameters(Resource, &newParams);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    localParams = &(Resource->LocalParams);

    //
    // Update the interface name.
    //
    if (localParams->InterfaceName != NULL) {
        LocalFree(localParams->InterfaceName);
    }

    localParams->InterfaceName = newParams.InterfaceName;
    newParams.InterfaceName = NULL;

    //
    // Update the interface ID.
    //
    if ( (localParams->InterfaceId != NULL)  &&
         (lstrcmp(localParams->InterfaceId, newParams.InterfaceId) != 0)
       )
    {
        LocalFree(localParams->InterfaceId);
        localParams->InterfaceId = NULL;

        if (Resource->InterfaceHandle != NULL) {
            CloseClusterNetInterface(Resource->InterfaceHandle);
            Resource->InterfaceHandle = NULL;
        }
    }

    if (localParams->InterfaceId == NULL) {
        localParams->InterfaceId = newParams.InterfaceId;
        newParams.InterfaceId = NULL;
    }

    //
    // Update the interface handle.
    //
    if (Resource->InterfaceHandle == NULL) {
        Resource->InterfaceHandle = OpenClusterNetInterface(
                                        IpaClusterHandle,
                                        localParams->InterfaceName
                                        );

        if (Resource->InterfaceHandle == NULL) {
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Online: Unable to open object for netinterface %1!ws!, status %2!u!.\n",
                localParams->InterfaceId,
                status
                );
            goto error_exit;
        }
        else {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_INFORMATION,
                L"Online: Opened object handle for netinterface %1!ws!.\n",
                localParams->InterfaceId
                );
        }
    }

    //
    // Register for state change notifications for the interface.
    //
    status = RegisterClusterNotify(
                 IpaClusterNotifyHandle,
                 ( CLUSTER_CHANGE_NETINTERFACE_STATE |
                   CLUSTER_CHANGE_NETINTERFACE_DELETED
                 ),
                 Resource->InterfaceHandle,
                 (DWORD_PTR) Resource
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to register notification for netinterface %1!ws!, status %2!u!.\n",
            localParams->InterfaceId,
            status
            );
        goto error_exit;
    }
    else {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Online: Registered notification for netinterface %1!ws!.\n",
            localParams->InterfaceId
            );
    }

    //
    // Check if the interface has failed already. We will sleep for a while
    // and retry under certain conditions. The network state can take a few
    // seconds to settle.
    //
    numTries = 0;

    for (;;) {

        resourceStatus.CheckPoint++;
        exit = (IpaSetResourceStatus)(
                   Resource->ResourceHandle,
                   &resourceStatus
                   );

        if ( exit == ResourceExitStateTerminate ) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Online thread aborted.\n"
                );
            status = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        state = GetClusterNetInterfaceState(
                    Resource->InterfaceHandle
                    );

        if (state == ClusterNetInterfaceUp) {
            break;
        }
        else if (state == ClusterNetInterfaceUnavailable ||
                 state == ClusterNetInterfaceUnreachable )
        {
            PWCHAR stateName = ( state == ClusterNetInterfaceUnavailable ?
                                 L"available" : L"reachable" );

            if (++numTries <= 5) {
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_WARNING,
                    L"NetInterface %1!ws! is not %2!ws!. Wait & retry.\n",
                    Resource->LocalParams.InterfaceId,
                    stateName
                    );
                Sleep(1000);
                continue;
            }
            else {
                status = ERROR_IO_DEVICE;
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Timed out waiting for NetInterface %1!ws! to be available. Failing resource.\n",
                    Resource->LocalParams.InterfaceId
                    );
                goto error_exit;
            }
        }
        else if (state == ClusterNetInterfaceFailed) {
            status = ERROR_IO_DEVICE;
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"NetInterface %1!ws! has failed.\n",
                Resource->LocalParams.InterfaceId
                );
            goto error_exit;
        }
        else if (state == ClusterNetInterfaceStateUnknown) {
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Failed to get state for netinterface %1!ws!, status %2!u!.\n",
                Resource->LocalParams.InterfaceId,
                status
                );
                goto error_exit;
        }
        else {
            ASSERT(FALSE);
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unrecognized state for netinterface %1!ws!, state %2!u!.\n",
                Resource->LocalParams.InterfaceId,
                state
                );
            status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }
    }

    Resource->FailureStatus = ERROR_SUCCESS;

    //
    // Update the adapter name parameter.
    //
    if (localParams->AdapterName != NULL) {
        LocalFree(localParams->AdapterName);
    }

    localParams->AdapterName = newParams.AdapterName;
    newParams.AdapterName = NULL;

    //
    // Update the adapter Id parameter.
    //
    if ((localParams->AdapterId == NULL) ||
        (lstrcmpiW(localParams->AdapterId, newParams.AdapterId) != 0)) {

        if (localParams->AdapterId != NULL) {
            LocalFree(localParams->AdapterId);
        }

        localParams->AdapterId = newParams.AdapterId;
        newParams.AdapterId = NULL;

        if (Resource->NteContext != INVALID_NTE_CONTEXT) {
            //
            // Delete the old NTE.
            //
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_INFORMATION,
                L"Adapter Id has changed to %1!ws!.\n",
                localParams->AdapterId
                );

            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );
        }
    }

    //
    // Create a new NTE if we need one.
    //
    if (Resource->NteContext == INVALID_NTE_CONTEXT) {

        status = IpaCreateNte(
                     localParams->AdapterId,
                     Resource->NodeParametersKey,
                     Resource->ResourceHandle,
                     &(Resource->NteContext),
                     &(Resource->NteInstance)
                     );

        if (status != ERROR_SUCCESS) {
            ClusResLogSystemEventByKeyData(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_NTE_CREATE_FAILED,
                sizeof(status),
                &status
                );
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Failed to created new IP interface, status %1!u!.\n",
                status
                );
            goto error_exit;
        }
    }

    //
    // Create a new NBT interface if we need one.
    //
    if (privateProps->EnableNetbios) {
        if (Resource->NbtDeviceName == NULL) {
            status = IpaCreateNbtInterface(
                         Resource->NodeParametersKey,
                         Resource->ResourceHandle,
                         &(Resource->NbtDeviceName),
                         &(Resource->NbtDeviceInstance)
                         );

            if (status != ERROR_SUCCESS) {
                ClusResLogSystemEventByKeyData(
                    Resource->ResourceKey,
                    LOG_CRITICAL,
                    RES_IPADDR_NBT_INTERFACE_CREATE_FAILED,
                    sizeof(status),
                    &status
                    );
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Failed to created new NBT interface, status %1!u!.\n",
                    status
                    );
                goto error_exit;
            }
        }
    }
    else {
        if (Resource->NbtDeviceName != NULL) {
            IpaDeleteNbtInterface(
                &(Resource->NbtDeviceName),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );
        }
    }

    //
    // Update the resource's WINS parameters
    //
    localParams->NbtPrimaryWinsAddress = newParams.NbtPrimaryWinsAddress;
    localParams->NbtSecondaryWinsAddress = newParams.NbtSecondaryWinsAddress;

    //
    // We have valid, offline interfaces to work with. Send out a few ICMP
    // Echo requests to see if any other machine has this address online.
    // If one does, we'll abort this online operation.
    //
    resourceStatus.CheckPoint++;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    retried = FALSE;

    while (TRUE) {
        status = TcpipSetNTEAddress(
                    Resource->NteContext,
                    Resource->Address,
                    Resource->SubnetMask
                    );
        
        if(status == ERROR_SUCCESS)
            break;

        if (!retried ) {
            //
            // Check to see if the online operation was aborted while
            // this thread was blocked.
            //
            if (ClusWorkerCheckTerminate(pWorker)) {
                status = ERROR_OPERATION_ABORTED;
                Resource->State = ClusterResourceOfflinePending;
                goto error_exit;
            }

            //
            // Wait 5 secs to give the holder of the address a
            // chance to let go
            //
            Sleep(5000);

            //
            // Check to see if the online operation was aborted while
            // this thread was blocked.
            //
            if (ClusWorkerCheckTerminate(pWorker)) {
                status = ERROR_OPERATION_ABORTED;
                Resource->State = ClusterResourceOfflinePending;
                goto error_exit;
            }

            retried = TRUE;
        }
        else {
            //
            // Delete the failed NTE.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

            status = ERROR_CLUSTER_IPADDR_IN_USE;
            ClusResLogSystemEventByKey1(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_IN_USE,
                Resource->InternalPrivateProps.AddressString
                );
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"IP address %1!ws! is already in use on the network, status %2!u!.\n",
                Resource->InternalPrivateProps.AddressString,
                status
                );
            goto error_exit;
        }
    }

    //
    // Check to see if the online operation was aborted while this thread
    // was blocked.
    //
    if (ClusWorkerCheckTerminate(pWorker)) {
        status = ERROR_OPERATION_ABORTED;
        Resource->State = ClusterResourceOfflinePending;
        goto error_exit;
    }

    resourceStatus.CheckPoint++;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    if (Resource->EnableNetbios) {
        //
        // Bind NBT to the NTE
        //
        status = NbtBindInterface(
                     Resource->NbtDeviceName,
                     Resource->Address,
                     Resource->SubnetMask
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
               Resource->ResourceHandle,
               LOG_ERROR,
               L"Failed to bind NBT interface %1!ws! to IP address %2!ws!, status %3!u!.\n",
               Resource->NbtDeviceName,
               Resource->InternalPrivateProps.AddressString,
               status
               );

            //
            // Delete the failed NBT interface.
            //
            IpaDeleteNbtInterface(
                &(Resource->NbtDeviceName),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

            //
            // Take the IP address offline
            //
            // In Windows 2000, TCP/IP ignores requests to set the address
            // of an NTE if the underlying interface is disconnected.
            // This can result in the same IP address being brought online
            // on two different nodes. In order to workaround this bug
            // in TCP/IP, we now delete the NTE during offline processing
            // instead of reusing it.
            //
            // Note that IpaDeleteNte() invalidates the value
            // of Resource->NteContext.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );
#if 0
            TcpipSetNTEAddress(Resource->NteContext, 0, 0);
#endif

            goto error_exit;
        }

        //
        // Set the WINS addresses
        //
        status = NbtSetWinsAddrInterface(
                     Resource->NbtDeviceName,
                     localParams->NbtPrimaryWinsAddress,
                     localParams->NbtSecondaryWinsAddress
                     );

        if (status != ERROR_SUCCESS) {
            ClusResLogSystemEventByKeyData1(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_WINS_ADDRESS_FAILED,
                sizeof(status),
                &status,
                Resource->NbtDeviceName
                );

            (IpaLogEvent)(
               Resource->ResourceHandle,
               LOG_ERROR,
               L"Failed to set WINS addresses on NBT interface %1!ws!, status %2!u!.\n",
               Resource->NbtDeviceName,
               status
               );

            //
            // Delete the failed NBT interface.
            //
            IpaDeleteNbtInterface(
                &(Resource->NbtDeviceName),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

            //
            // Take the IP address offline
            //
            // In Windows 2000, TCP/IP ignores requests to set the address
            // of an NTE if the underlying interface is disconnected.
            // This can result in the same IP address being brought online
            // on two different nodes. In order to workaround this bug
            // in TCP/IP, we now delete the NTE during offline processing
            // instead of reusing it.
            //
            // Note that IpaDeleteNte() invalidates the value
            // of Resource->NteContext.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

#if 0
            TcpipSetNTEAddress(Resource->NteContext, 0, 0);
#endif

            goto error_exit;
        }
    }

    //
    // Tell the DNS resolver to update its list of local ip addresses.
    //
    // BUGBUG - The DNS resolver should do this automatically based
    //          on PnP events in the Whistler release. Remove this code 
    //          after verifiying that functionality.
    //
    //          This issue is tracked with bug 97134.
    // DnsNotifyResolver(0, 0);
    DnsNotifyResolverClusterIp((IP_ADDRESS)Resource->Address, TRUE);
    
    Resource->State = ClusterResourceOnline;

    resourceStatus.CheckPoint++;
    resourceStatus.ResourceState = ClusterResourceOnline;
    (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    (IpaLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"IP Address %1!ws! on adapter %2!ws! online\n",
        Resource->InternalPrivateProps.AddressString,
        localParams->AdapterName
        );

    IpaReleaseResourceLock(Resource);

    IpaFreeLocalParameters(&newParams);

    return(ERROR_SUCCESS);


error_exit:

    ASSERT(status != ERROR_SUCCESS);

    if (Resource->State == ClusterResourceOfflinePending) {
        IpaDoOfflineProcessing(Resource, &resourceStatus);
        //
        // The resource lock was released.
        //
    }
    else {
        Resource->State = ClusterResourceFailed;

        resourceStatus.CheckPoint++;
        resourceStatus.ResourceState = ClusterResourceFailed;
        (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

        IpaReleaseResourceLock(Resource);
    }

    IpaFreeLocalParameters(&newParams);

    return(status);

} // IpaOnlineThread



DWORD
WINAPI
IpaOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PIPA_RESOURCE          resource = (PIPA_RESOURCE)Resource;
    DWORD                  status;


    if (resource != NULL) {
        IpaAcquireResourceLock(resource);

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Bringing resource online...\n",
            Resource
            );

        ASSERT(resource->OnlineThread.hThread == NULL);
        ASSERT(
            (resource->State == ClusterResourceOffline) ||
            (resource->State == ClusterResourceFailed)
            );

        resource->State = ClusterResourceOnlinePending;

        status = ClusWorkerCreate(
                     &(resource->OnlineThread),
                     IpaOnlineThread,
                     resource
                     );

        if (status != ERROR_SUCCESS) {
            resource->State = ClusterResourceOffline;
            (IpaLogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to start online thread, status %1!u!.\n",
                status
                );
        } else {
            status = ERROR_IO_PENDING;
        }

        IpaReleaseResourceLock(resource);

    } else {
        status = ERROR_RESOURCE_NOT_FOUND;
    }

    return(status);

}  // IpaOnline


DWORD
IpaWorkerThread(
    LPVOID   Context
    )
{
    DWORD                        status;
    DWORD                        dwFilter;
    DWORD_PTR                    key;
    DWORD                        event;
    PIPA_RESOURCE                resource;
    CLUSTER_NETINTERFACE_STATE   state;
    HCHANGE                      notifyHandle;


    IpaAcquireGlobalLock();

    notifyHandle = IpaClusterNotifyHandle;

    if (notifyHandle == NULL) {
        if (!IsListEmpty(&IpaResourceList)) {
            resource = CONTAINING_RECORD(
                           IpaResourceList.Flink,
                           IPA_RESOURCE,
                           Linkage
                           );

            (IpaLogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"WorkerThread aborted.\n"
                );
        }

        IpaReleaseGlobalLock();

        return(ERROR_INVALID_PARAMETER);
    }

    if (!IsListEmpty(&IpaResourceList)) {
        resource = CONTAINING_RECORD(
                       IpaResourceList.Flink,
                       IPA_RESOURCE,
                       Linkage
                       );

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"WorkerThread running\n"
            );
    }

    IpaReleaseGlobalLock();

    do {
        status = GetClusterNotify(
                     notifyHandle,
                     &key,
                     &event,
                     NULL,
                     NULL,
                     INFINITE
                     );

        if (status == ERROR_SUCCESS) {
            if ( (event == CLUSTER_CHANGE_NETINTERFACE_STATE) ||
                 (event == CLUSTER_CHANGE_NETINTERFACE_DELETED)
               )
            {

                IpaAcquireGlobalLock();

                resource = IpaFindResourceInList((PVOID) key);

                if (resource != NULL) {

                    IpaAcquireResourceLock(resource);

                    IpaReleaseGlobalLock();

                    if( (resource->State == ClusterResourceOnline) ||
                        (resource->State == ClusterResourceOnlinePending)
                      )
                    {
                        //
                        // Process the event.
                        //
                        if (event == CLUSTER_CHANGE_NETINTERFACE_STATE) {

                            resource->FailureStatus = ERROR_SUCCESS;

                            state = GetClusterNetInterfaceState(
                                        resource->InterfaceHandle
                                        );

                            if (state == ClusterNetInterfaceStateUnknown) {
                                status = GetLastError();
                                (IpaLogEvent)(
                                    resource->ResourceHandle,
                                    LOG_ERROR,
                                    L"WorkerThread: Failed to get state for netinterface %1!ws!, status %2!u!.\n",
                                    resource->LocalParams.InterfaceId,
                                    status
                                    );
                            }
                            else if ((state == ClusterNetInterfaceFailed) ||
                                     (state == ClusterNetInterfaceUnavailable)
                                    )
                            {
                                resource->FailureStatus = ERROR_IO_DEVICE;
                                (IpaLogEvent)(
                                    resource->ResourceHandle,
                                    LOG_WARNING,
                                    L"WorkerThread: NetInterface %1!ws! has failed. Failing resource.\n",
                                    resource->LocalParams.InterfaceId
                                    );
                            }
                            else {
                                (IpaLogEvent)(
                                    resource->ResourceHandle,
                                    LOG_WARNING,
                                    L"WorkerThread: NetInterface %1!ws! changed to state %2!u!.\n",
                                    resource->LocalParams.InterfaceId,
                                    state
                                    );
                            }
                        }
                        else {
                            ASSERT(
                                event == CLUSTER_CHANGE_NETINTERFACE_DELETED
                                );
                            resource->FailureStatus = ERROR_DEV_NOT_EXIST;
                            (IpaLogEvent)(
                                resource->ResourceHandle,
                                LOG_ERROR,
                                L"WorkerThread: NetInterface %1!ws! was deleted. Failing resource.\n",
                                resource->LocalParams.InterfaceId
                                );
                        }
                    }

                    IpaReleaseResourceLock(resource);
                }
                else {
                    IpaReleaseGlobalLock();
                }
            }
            else if (event == CLUSTER_CHANGE_HANDLE_CLOSE) {
                //
                // Time to exit.
                //
                break;
            }
            else {
                IpaAcquireGlobalLock();

                if (!IsListEmpty(&IpaResourceList)) {
                    resource = CONTAINING_RECORD(
                                   IpaResourceList.Flink,
                                   IPA_RESOURCE,
                                   Linkage
                                   );

                    (IpaLogEvent)(
                        resource->ResourceHandle,
                        LOG_WARNING,
                        L"WorkerThread: Received unknown event %1!u!.\n",
                        event
                        );
                }

                IpaReleaseGlobalLock();

                ASSERT(event);
            }
        }
        else {
            IpaAcquireGlobalLock();

            if (!IsListEmpty(&IpaResourceList)) {
                resource = CONTAINING_RECORD(
                               IpaResourceList.Flink,
                               IPA_RESOURCE,
                               Linkage
                               );

                (IpaLogEvent)(
                    resource->ResourceHandle,
                    LOG_ERROR,
                    L"WorkerThread: GetClusterNotify failed with status %1!u!.\n",
                    status
                    );
            }

            IpaReleaseGlobalLock();

            break;
        }

    } while (status == ERROR_SUCCESS);

    IpaAcquireGlobalLock();

    if (!IsListEmpty(&IpaResourceList)) {
        resource = CONTAINING_RECORD(
                       IpaResourceList.Flink,
                       IPA_RESOURCE,
                       Linkage
                       );

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"WorkerThread terminating\n"
            );
    }

    IpaReleaseGlobalLock();

    return(status);

}  // IpaWorkerThread



BOOL
WINAPI
IpaInternalLooksAlive(
    IN RESID Resource,
    IN LPWSTR Mode
    )

/*++

Routine Description:

    LooksAlive routine for IP Address resource.

Arguments:

    Resource - supplies the resource id to be polled.

    Mode - string indicating "Looks" or "Is"

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) Resource;
    BOOLEAN         returnValue = TRUE;
    TCPIP_NTE_INFO  nteInfo;
    DWORD           status;
    IPAddr          address;
    DWORD           instance;


    if (resource != NULL) {

        IpaAcquireResourceLock(resource);

        if (resource->FailureStatus == ERROR_SUCCESS) {
            status = TcpipGetNTEInfo(resource->NteContext, &nteInfo);

            if (status != ERROR_SUCCESS) {
                returnValue = FALSE;
            }
            else if (nteInfo.Instance == resource->NteInstance) {
                if (resource->EnableNetbios) {
                    status = NbtGetInterfaceInfo(
                                 resource->NbtDeviceName,
                                 &address,
                                 &instance
                                 );

                    if (status != ERROR_SUCCESS) {
                        returnValue = FALSE;
                    }
                    else if (instance != resource->NbtDeviceInstance) {
                        status = ERROR_DEV_NOT_EXIST;
                        returnValue = FALSE;
                    }
                }
            }
            else {
                status = ERROR_DEV_NOT_EXIST;
                returnValue = FALSE;
            }
        }
        else {
            status = resource->FailureStatus;
            returnValue = FALSE;
        }

        if (!returnValue) {
            ClusResLogSystemEventByKeyData(
                resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_NTE_INTERFACE_FAILED,
                sizeof(status),
                &status
                );
            (IpaLogEvent)(
                resource->ResourceHandle,
                LOG_WARNING,
                L"IP Interface %1!u! (address %2!ws!) failed %3!ws!Alive check, status %4!u!, address 0x%5!lx!, instance 0x%6!lx!.\n",
                resource->NteContext,
                resource->InternalPrivateProps.AddressString,
                Mode,
                status,
                address,
                resource->NteInstance
                );
        }

        IpaReleaseResourceLock(resource);
    }

    return(returnValue);

}  // IpaInternalLooksAliveCheck


BOOL
WINAPI
IpaLooksAlive(
    IN RESID Resource
    )

/*++
Routine Description:

    LooksAlive routine for IP Address resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    return(IpaInternalLooksAlive(Resource, L"Looks"));
}



BOOL
WINAPI
IpaIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for IP Address resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return(IpaInternalLooksAlive(Resource, L"Is"));
}



VOID
WINAPI
IpaClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PIPA_RESOURCE   resource = (PIPA_RESOURCE)Resource;
    PLIST_ENTRY     entry;
    TCPIP_NTE_INFO  nteInfo;
    DWORD           status;


    if (resource != NULL) {
        //
        // First, terminate the online thread without the lock.
        //
        ClusWorkerTerminate(&(resource->OnlineThread));

        IpaAcquireGlobalLock();

        IpaAcquireResourceLock(resource);

        //
        // Remove the resource from the global list
        //
        RemoveEntryList(&(resource->Linkage));

        IpaReleaseResourceLock(resource);

        IpaOpenResourceCount--;

        if ((IpaOpenResourceCount == 0) && (IpaClusterHandle != NULL)) {
            HCLUSTER  handle = IpaClusterHandle;


            IpaClusterHandle = NULL;

            IpaReleaseGlobalLock();

            CloseCluster(handle);
        }
        else {
            IpaReleaseGlobalLock();
        }

        //
        // Delete the resource's parameters
        //
        if (resource->NbtDeviceName != NULL) {
            //
            // Try to delete it.
            //
            IpaDeleteNbtInterface(
                &(resource->NbtDeviceName),
                resource->NodeParametersKey,
                resource->ResourceHandle
                );
        }

        if (resource->NteContext != INVALID_NTE_CONTEXT) {
            //
            // Try to delete it.
            //
            IpaDeleteNte(
                &(resource->NteContext),
                resource->NodeParametersKey,
                resource->ResourceHandle
                );
        }

        IpaFreePrivateProperties(&(resource->InternalPrivateProps));
        IpaFreeLocalParameters(&(resource->LocalParams));

        if (resource->ResourceKey != NULL) {
            ClusterRegCloseKey(resource->ResourceKey);
        }

        if (resource->ParametersKey != NULL) {
            ClusterRegCloseKey(resource->ParametersKey);
        }

        if (resource->NodeParametersKey != NULL) {
            ClusterRegCloseKey(resource->NodeParametersKey);
        }

        if (resource->NetworksKey != NULL) {
            ClusterRegCloseKey(resource->NetworksKey);
        }

        if (resource->InterfacesKey != NULL) {
            ClusterRegCloseKey(resource->InterfacesKey);
        }

        DeleteCriticalSection(&(resource->Lock));

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource closed.\n"
            );

        LocalFree(resource);
    }

    return;

} // IpaClose



DWORD
IpaResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Application resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD           status;
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) ResourceId;
    DWORD           resourceIndex;
    DWORD           required;


    if ( resource == NULL ) {
        DBG_PRINT( "IPAddress: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( IpaResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties(
                         IpaResourcePrivateProperties,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned,
                         &required
                         );

            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }

            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = IpaGetPrivateResProperties(
                         resource,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned
                         );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = IpaValidatePrivateResProperties(
                         resource,
                         InBuffer,
                         InBufferSize,
                         NULL
                         );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = IpaSetPrivateResProperties(
                         resource,
                         InBuffer,
                         InBufferSize
                         );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IpaResourceControl



DWORD
IpaResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Application resources.

    Perform the control request specified by ControlCode on this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD           status;
    DWORD           required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( IpaResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties(
                         IpaResourcePrivateProperties,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned,
                         &required
                         );

            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }

            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IpaResourceTypeControl



DWORD
IpaGetPrivateResProperties(
    IN OUT PIPA_RESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type IP Address.

Arguments:

    Resource - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD                   status;
    DWORD                   statusReturn = ERROR_SUCCESS;
    DWORD                   required;
    IPA_PRIVATE_PROPS       props;
    LPWSTR                  networkName;
    LPWSTR                  nameOfPropInError;


    ZeroMemory(&props, sizeof(props));

    status = ResUtilGetPropertiesToParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 (LPBYTE) &props,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        statusReturn = status;
        goto error_exit;
    }

    //
    // Find the name of the network if we read the network GUID.
    //
    if ( props.NetworkString != NULL ) {
        networkName = IpaGetNameOfNetworkPatchGuidIfNecessary(Resource, &props);

        if ( networkName == NULL ) {
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Error getting name of network whose GUID is '%1' property. Error: %2!u!.\n",
                props.NetworkString,
                status
                );
            status = ERROR_SUCCESS;
        } else {
            LocalFree( props.NetworkString );
            props.NetworkString = networkName;
        }
    }

    //
    // Construct a property list from the parameter block.
    //
    status = ResUtilPropertyListFromParameterBlock(
                 IpaResourcePrivateProperties,
                 OutBuffer,
                 &OutBufferSize,
                 (LPBYTE) &props,
                 BytesReturned,
                 &required
                 );

    //
    // Add unknown properties to the property list.
    //
    if ( (status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA ) ) {
        statusReturn = status;
        status = ResUtilAddUnknownProperties(
                     Resource->ParametersKey,
                     IpaResourcePrivateProperties,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     &required
                     );
        if ( status != ERROR_SUCCESS ) {
            statusReturn = status;
        }

        if ( statusReturn == ERROR_MORE_DATA ) {
            *BytesReturned = required;
        }
    }

error_exit:

    ResUtilFreeParameterBlock(
        (LPBYTE) &props,
        NULL,
        IpaResourcePrivateProperties
        );

    return(statusReturn);

} // IpaGetPrivateResProperties



DWORD
IpaValidatePrivateResProperties(
    IN OUT PIPA_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PIPA_PRIVATE_PROPS Props
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type IP Address.

Arguments:

    Resource - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Props - Supplies the property block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD                  status;
    DWORD                  required;
    IPA_PRIVATE_PROPS      currentProps;
    LPWSTR                 networkId;
    LPWSTR                 networkName;
    LPWSTR                 nameOfPropInError;
    IPA_PRIVATE_PROPS      newProps;
    PIPA_PRIVATE_PROPS     pNewProps = NULL;


    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) || (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Capture the current set of private properties from the registry.
    //
    ZeroMemory(&currentProps, sizeof(currentProps));

    IpaAcquireResourceLock(Resource);

    status = ResUtilGetPropertiesToParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    IpaReleaseResourceLock(Resource);

    if ( status != ERROR_SUCCESS ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }

    //
    // Find the name of the network if we read the network GUID.
    //
    if ( currentProps.NetworkString != NULL ) {
        networkName = IpaGetNameOfNetworkPatchGuidIfNecessary(
                          Resource,
                          &currentProps
                          );

        if ( networkName == NULL ) {

            //
            // this is not necessarily an error. Changing the network of the
            // NIC on which this resource is dependent will cause the old
            // network GUID in the registry to be invalid. If the user has
            // specified a new network, we'll discover later on in this
            // routine and get the correct GUID.
            //
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Error getting name of network whose GUID is '%1' property. Error: %2!u!.\n",
                currentProps.NetworkString,
                status
                );
        }

        LocalFree( currentProps.NetworkString );
        currentProps.NetworkString = networkName;
    }

    //
    // Duplicate the current parameter block.
    //
    if ( Props == NULL ) {
        pNewProps = &newProps;
    } else {
        pNewProps = Props;
    }

    ZeroMemory( pNewProps, sizeof(IPA_PRIVATE_PROPS) );

    status = ResUtilDupParameterBlock(
                 (LPBYTE) pNewProps,
                 (LPBYTE) &currentProps,
                 IpaResourcePrivateProperties
                 );

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Parse and validate the new properties.
    //
    status = ResUtilVerifyPropertyTable(
                 IpaResourcePrivateProperties,
                 NULL,
                 TRUE,    // Allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) pNewProps
                 );

    if ( status == ERROR_SUCCESS ) {
        ULONG newIpAddress = 0;
        //
        // Validate the parameter values.
        //
        if (pNewProps->NetworkString != NULL) {
            //
            // Get the network ID for the specified network.
            //
            networkId = IpaGetIdOfNetwork(
                            Resource,
                            pNewProps->NetworkString
                            );

            if ( networkId == NULL ) {
                status = GetLastError();
                goto error_exit;
            }

            LocalFree( pNewProps->NetworkString );
            pNewProps->NetworkString = networkId;
        }

        if (pNewProps->AddressString != NULL) {
            //
            // Validate the IP address.
            //
            ULONG   nAddress;

            status = ClRtlTcpipStringToAddress(
                         pNewProps->AddressString,
                         &nAddress
                         );

            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            if ( ClRtlIsValidTcpipAddress( nAddress ) == FALSE ) {
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }

            newIpAddress = nAddress;

            //
            // if the address is changed, make sure it is not a duplicate
            //
            if (lstrcmpW(
                    pNewProps->AddressString,
                    currentProps.AddressString
                    ) != 0
               )
            {
                BOOL isDuplicate;

                isDuplicate = ClRtlIsDuplicateTcpipAddress(nAddress);

                if (isDuplicate) {
                    //
                    // If this isn't the address we currently have online,
                    // then it is a duplicate.
                    //
                    IpaAcquireResourceLock(Resource);

                    if (!( ((Resource->State == ClusterResourceOnlinePending)
                            ||
                            (Resource->State == ClusterResourceOnline)
                            ||
                            (Resource->State == ClusterResourceOfflinePending)
                           )
                           &&
                           (lstrcmpW(
                               pNewProps->AddressString,
                               Resource->InternalPrivateProps.AddressString
                               ) == 0
                           )
                         )
                       )
                    {
                        status = ERROR_CLUSTER_IPADDR_IN_USE;
                        IpaReleaseResourceLock(Resource);
                        goto error_exit;
                    }

                    IpaReleaseResourceLock(Resource);
                }
            }
        }

        if (pNewProps->SubnetMaskString != NULL) {
            //
            // Validate the subnet mask.
            //
            ULONG   nAddress;

            status = ClRtlTcpipStringToAddress(
                         pNewProps->SubnetMaskString,
                         &nAddress
                         );

            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            if ( ClRtlIsValidTcpipSubnetMask( nAddress ) == FALSE ) {
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }

            if (newIpAddress &&
                (ClRtlIsValidTcpipAddressAndSubnetMask(newIpAddress, nAddress) == FALSE) ) {
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
    }

error_exit:

    //
    // Cleanup our parameter block.
    //
    if (
        ( status != ERROR_SUCCESS && pNewProps != NULL )
        ||
        ( pNewProps == &newProps )
       )
    {
        ResUtilFreeParameterBlock(
            (LPBYTE) pNewProps,
            (LPBYTE) &currentProps,
            IpaResourcePrivateProperties
            );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        IpaResourcePrivateProperties
        );

    return(status);

} // IpaValidatePrivateResProperties



DWORD
IpaSetPrivateResProperties(
    IN OUT PIPA_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type IP Address.

Arguments:

    Resource - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs. The asynchronous OnlineThread
    isn't a problem because we captured its properties during the IpaOnline
    routine.

--*/

{
    DWORD                  status;
    IPA_PRIVATE_PROPS      props;


    ZeroMemory( &props, sizeof(IPA_PRIVATE_PROPS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = IpaValidatePrivateResProperties(
                 Resource,
                 InBuffer,
                 InBufferSize,
                 &props
                 );

    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    IpaAcquireResourceLock(Resource);

    //
    // Save the parameter values.
    //
    status = ResUtilSetPropertyParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 NULL,
                 (LPBYTE) &props,
                 InBuffer,
                 InBufferSize,
                 NULL
                 );

    //
    // If the resource is online, return a non-success status.
    //
    // Note that we count on the fact that 32-bit reads are atomic.
    //
    if (status == ERROR_SUCCESS) {
        DWORD state = Resource->State;

        if ( (state == ClusterResourceOnline) ||
             (state == ClusterResourceOnlinePending)
           )
        {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    IpaReleaseResourceLock(Resource);

    ResUtilFreeParameterBlock(
        (LPBYTE) &props,
        NULL,
        IpaResourcePrivateProperties
        );

    return status;

} // IpaSetPrivateResProperties



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( IpAddrFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         Ipa,                  // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         IpaResourceControl,   // ResControl
                         IpaResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ipaddr\nteapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nteapi.c

Abstract:

    Routines for manipulating dynamic IP Network Table Entries (NTEs)
    and NBT devices (interfaces).

Author:

    Mike Massa (mikemas)  18-Mar-1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include "clusres.h"
#include <winsock2.h>
#include <ipexport.h>
#include <ntddip.h>
#include <nteapi.h>
#include <nbtioctl.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <clusrtl.h>

//
// Public Routines
//
DWORD
TcpipAddNTE(
    IN LPWSTR  AdapterId,
    IN IPAddr  Address,
    IN IPMask  SubnetMask,
    OUT PULONG  NTEContext,
    OUT PULONG  NTEInstance
    )
/*++

Routine Description:

    Adds a new NTE to a specified IP interface. The target IP interface is
    identified by the name of the adapter associated with it.

Arguments:

    AdapterId - A unicode string identifying the adapter/interface to which
                to add the new NTE.

    Address - The IP address to assign to the new NTE.

    SubnetMask - The IP subnet mask to assign to the new NTE.

    NTEContext - On output, contains the context value identifying the new NTE.

    NTEInstance - On output, contains the instance ID of the new NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    PCLRTL_NET_ADAPTER_INFO      adapterInfo;
    PCLRTL_NET_ADAPTER_ENUM      adapterEnum;
    HANDLE                       handle;
    IP_ADD_NTE_REQUEST           requestBuffer;
    PIP_ADD_NTE_RESPONSE         responseBuffer =
                                 (PIP_ADD_NTE_RESPONSE) &requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = sizeof(*responseBuffer);


    adapterEnum = ClRtlEnumNetAdapters();

    if (adapterEnum != NULL) {
        adapterInfo = ClRtlFindNetAdapterById(adapterEnum, AdapterId);

        if (adapterInfo != NULL) {
            status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

            if ( status == ERROR_SUCCESS ) {
                requestBuffer.InterfaceContext = adapterInfo->Index;
                requestBuffer.Address = Address;
                requestBuffer.SubnetMask = SubnetMask;

                requestBuffer.InterfaceName.Length = 0;
                requestBuffer.InterfaceName.MaximumLength = 0;
                requestBuffer.InterfaceName.Buffer = NULL;

                status = ClusResDoIoctl(
                             handle,
                             IOCTL_CLUSNET_ADD_NTE,
                             &requestBuffer,
                             requestBufferSize,
                             responseBuffer,
                             &responseBufferSize
                             );

                if (NT_SUCCESS(status)) {
                    *NTEContext = (ULONG) responseBuffer->Context;
                    *NTEInstance = responseBuffer->Instance;
                    status = ERROR_SUCCESS;
                }

                CloseHandle(handle);
            }
        }
        else {
            status = ERROR_INVALID_PARAMETER;
        }

        ClRtlFreeNetAdapterEnum(adapterEnum);
    }
    else {
        status = GetLastError();
    }

    return(status);
}


DWORD
TcpipDeleteNTE(
    IN ULONG  NTEContext
    )
/*++

Routine Description:

    Deletes a specified NTE. The target NTE must have been added using
    TcpipAddNTE.

Arguments:

    NTEContext - The context value identifying the NTE to delete.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IP_DELETE_NTE_REQUEST        requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.Context = (unsigned short) NTEContext;

    status = ClusResDoIoctl(
                 handle,
                 IOCTL_CLUSNET_DELETE_NTE,
                 &requestBuffer,
                 requestBufferSize,
                 NULL,
                 &responseBufferSize
                 );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
TcpipSetNTEAddress(
    DWORD   NTEContext,
    IPAddr  Address,
    IPMask  SubnetMask
    )
/*++

Routine Description:

    Sets the address of a specified NTE.

Arguments:

    NTEContext - The context value identifying the target NTE.

    Address - The IP address to assign to the NTE. Assigning 0.0.0.0
              invalidates the NTE.

    SubnetMask - The IP subnet mask to assign to the NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IP_SET_ADDRESS_REQUEST       requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.Context = (unsigned short) NTEContext;
    requestBuffer.Address = Address;
    requestBuffer.SubnetMask = SubnetMask;

    status = ClusResDoIoctl(
                 handle,
                 IOCTL_CLUSNET_SET_NTE_ADDRESS,
                 &requestBuffer,
                 requestBufferSize,
                 NULL,
                 &responseBufferSize
                 );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
TcpipGetNTEInfo(
    IN  ULONG            NTEContext,
    OUT PTCPIP_NTE_INFO  NTEInfo
    )
/*++

Routine Description:

    Gathers information about a specified NTE.

Arguments:

    NTEContext - The context value identifying the NTE to query.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IP_GET_NTE_INFO_REQUEST      requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    IP_GET_NTE_INFO_RESPONSE     responseBuffer;
    DWORD                        responseBufferSize = sizeof(responseBuffer);


    status = ClusResOpenDriver(&handle, L"\\Device\\Ip");

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.Context = (unsigned short) NTEContext;

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_IP_GET_NTE_INFO,
                        &requestBuffer,
                        requestBufferSize,
                        &responseBuffer,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        NTEInfo->Instance = responseBuffer.Instance;
        NTEInfo->Address = responseBuffer.Address;
        NTEInfo->SubnetMask = responseBuffer.SubnetMask;
        NTEInfo->Flags = responseBuffer.Flags;

        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
NbtAddInterface(
    OUT    LPWSTR   DeviceName,
    IN OUT LPDWORD  DeviceNameSize,
    OUT    PULONG   DeviceInstance
    )
/*++

Routine Description:

    Adds a new NBT interface.

Arguments:

    DeviceName - A unicode string identifying the new NBT interface.

    DeviceNameSize - On input, the size of theh device name buffer.
                     On output, the size of the device name string, or
                     the size needed to accomodate the string.

    DeviceInstance - A pointer to a variable into which to place the
                     instance ID associated with the new interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       nbthandle = (HANDLE) NULL;
    HANDLE                       cnhandle = (HANDLE) NULL;
    PNETBT_ADD_DEL_IF            requestBuffer = NULL;
    DWORD                        requestBufferSize = 0;
    PNETBT_ADD_DEL_IF            responseBuffer = NULL;
    DWORD                        responseBufferSize = 0;
    HKEY                         key = NULL;
    LPWSTR                       NBTDeviceName;
    LPWSTR                       exportString = NULL;
    DWORD                        exportStringSize = 0;
    LONG                         valueType;


    //
    // get a handle to NetBT's Linkage key, query the size of the
    // export value, allocate a buffer large enough to hold it and
    // read it in
    //

    status = RegOpenKeyExW(
                 HKEY_LOCAL_MACHINE,
                 L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Linkage",
                 0,
                 KEY_READ,
                 &key);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = RegQueryValueExW(
                 key,
                 L"Export",
                 NULL,
                 &valueType,
                 NULL,
                 &exportStringSize
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    exportString = LocalAlloc( LMEM_FIXED, exportStringSize );
    if ( exportString == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = RegQueryValueExW(
                 key,
                 L"Export",
                 NULL,
                 &valueType,
                 (LPBYTE)exportString,
                 &exportStringSize
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Export is a multi-sz; loop through all the interfaces
    // until we find one that we can open successfully.
    //
    // Hold the handle until we are done with the ioctl so 
    // that the NBT device doesn't go away.
    //

    NBTDeviceName = exportString;
    do {

        status = ClusResOpenDriver(&nbthandle, NBTDeviceName);

        if ( status == ERROR_FILE_NOT_FOUND ) {

            //
            // get the next device name from the export string
            //

            NBTDeviceName += ( lstrlenW( NBTDeviceName ) + 1 );
            if ( *NBTDeviceName == 0 ) {
                status = ERROR_FILE_NOT_FOUND;
                break;
            }
        }
    } while ( status == ERROR_FILE_NOT_FOUND );

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    requestBufferSize = FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0])
                        + lstrlenW( NBTDeviceName ) * sizeof(WCHAR)
                        + sizeof(UNICODE_NULL);

    if (requestBufferSize < sizeof(NETBT_ADD_DEL_IF)) {
        requestBufferSize = sizeof(NETBT_ADD_DEL_IF);
    }

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    RtlZeroMemory( requestBuffer, requestBufferSize );

    requestBuffer->Length = lstrlenW( NBTDeviceName ) * sizeof(WCHAR)
        + sizeof(UNICODE_NULL);
    
    RtlCopyMemory( 
        &requestBuffer->IfName[0], 
        NBTDeviceName, 
        requestBuffer->Length 
        );

    responseBufferSize = FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0]) +
                         *DeviceNameSize;

    if (responseBufferSize < sizeof(NETBT_ADD_DEL_IF)) {
        responseBufferSize = sizeof(NETBT_ADD_DEL_IF);
    }

    responseBuffer = LocalAlloc(LMEM_FIXED, responseBufferSize);

    if (responseBuffer == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = ClusResOpenDriver(&cnhandle, DD_CLUSNET_DEVICE_NAME);

    if ( status == ERROR_SUCCESS ) {
    
        status = ClusResDoIoctl(
                     cnhandle,
                     IOCTL_CLUSNET_ADD_NBT_INTERFACE,
                     requestBuffer,
                     requestBufferSize,
                     responseBuffer,
                     &responseBufferSize
                     );
    
        if (NT_SUCCESS(status)) {
            *DeviceNameSize = responseBuffer->Length;
    
            if (NT_SUCCESS(responseBuffer->Status)) {
                wcscpy(DeviceName, &(responseBuffer->IfName[0]));
                *DeviceInstance = responseBuffer->InstanceNumber;
                status = ERROR_SUCCESS;
            }
            else {
               status = responseBuffer->Status;
            }
        }
        else {
            status = RtlNtStatusToDosError(status);
        }
    }

error_exit:
    if ( key ) {
        RegCloseKey( key );
    }

    if ( requestBuffer ) {
        LocalFree( requestBuffer );
    }

    if ( responseBuffer ) {
        LocalFree( responseBuffer );
    }

    if ( nbthandle ) {
        CloseHandle( nbthandle );
    }

    if ( cnhandle ) {
        CloseHandle( cnhandle );
    }

    return(status);
}


DWORD
NbtDeleteInterface(
    IN LPWSTR   DeviceName
    )
/*++

Routine Description:

    Deletes an NBT interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle = (HANDLE) NULL;
    DWORD                        responseBufferSize = 0;
    PNETBT_ADD_DEL_IF            requestBuffer = NULL;
    DWORD                        requestBufferSize = 0;


    requestBufferSize = FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0])
                        + lstrlenW( DeviceName ) * sizeof(WCHAR)
                        + sizeof(UNICODE_NULL);

    if (requestBufferSize < sizeof(NETBT_ADD_DEL_IF)) {
        requestBufferSize = sizeof(NETBT_ADD_DEL_IF);
    }

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    RtlZeroMemory( requestBuffer, requestBufferSize );

    requestBuffer->Length = lstrlenW( DeviceName ) * sizeof(WCHAR)
                            + sizeof(UNICODE_NULL);
    
    RtlCopyMemory( 
        &requestBuffer->IfName[0], 
        DeviceName, 
        requestBuffer->Length 
        );

    status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_CLUSNET_DEL_NBT_INTERFACE,
                        requestBuffer,
                        requestBufferSize,
                        NULL,
                        &responseBufferSize
                        );

    if (NT_SUCCESS(status)) {
            status = ERROR_SUCCESS;
    }
    else {
        status = RtlNtStatusToDosError(status);
    }

error_exit:

    if (requestBuffer) {
        LocalFree(requestBuffer);
    }

    if (handle) {
        CloseHandle(handle);        
    }

    return(status);
}


DWORD
NbtBindInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  Address,
    IN IPMask  SubnetMask
    )
/*++

Routine Description:

    Binds a specified NBT interface to a specified IP address.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - The IP address to which bind the interface. Assigning 0.0.0.0
              invalidates the interface.

    SubnetMask - The subnet mask of the IP interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    tNEW_IP_ADDRESS              requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.IpAddress = Address;
    requestBuffer.SubnetMask = SubnetMask;

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_NEW_IPADDRESS,
                        &requestBuffer,
                        requestBufferSize,
                        NULL,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}

DWORD
NbtSetWinsAddrInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  PrWinsAddress,
    IN IPAddr  SecWinsAddress
    )
/*++

Routine Description:

    Sets the WINS addrs for a given Nbt Interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrWinsAddress - Primary WINS addr

    SecWinsAddress - Secondary WINS addr

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    NETBT_SET_WINS_ADDR          requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.PrimaryWinsAddr = ntohl(PrWinsAddress);
    requestBuffer.SecondaryWinsAddr = ntohl(SecWinsAddress);

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_SET_WINS_ADDRESS,
                        &requestBuffer,
                        requestBufferSize,
                        NULL,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
NbtGetWinsAddresses(
    IN  LPWSTR    DeviceName,
    OUT IPAddr *  PrimaryWinsServer,
    OUT IPAddr *  SecondaryWinsServer
    )
/*++

Routine Description:

    Returns the addresses of the WINS servers for which the specified device
    is configured.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrimaryWinsServer - A pointer to a variable into which to place the address
                        of the primary WINS server.

    SecondaryWinsServer - A pointer to a variable into which to place the address
                          of the primary WINS server.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    tWINS_ADDRESSES              responseBuffer;
    DWORD                        responseBufferSize = sizeof(responseBuffer);


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_GET_WINS_ADDR,
                        NULL,
                        0,
                        &responseBuffer,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        *PrimaryWinsServer = htonl(responseBuffer.PrimaryWinsServer);
        *SecondaryWinsServer = htonl(responseBuffer.BackupWinsServer);
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
NbtGetInterfaceInfo(
    IN LPWSTR    DeviceName,
    OUT IPAddr * Address,
    OUT PULONG   DeviceInstance
    )
/*++

Routine Description:

    Returns the IP address to which an NBT interface is bound and the interface
    instance ID.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - A pointer to the location in which to store the address of the
              interface.

    DeviceInstance - A pointer to the location in which to store the instance ID
                     associated with the interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IPAddr                       address;
    NETBT_ADD_DEL_IF             responseBuffer;
    DWORD                        responseBufferSize;


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    responseBufferSize = sizeof(address);

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_GET_IP_ADDRS,
                        NULL,
                        0,
                        &address,
                        &responseBufferSize
                        );

    if (!((status == STATUS_SUCCESS) || (status == STATUS_BUFFER_OVERFLOW))) {
        CloseHandle(handle);
        return(RtlNtStatusToDosError(status));
    }

    *Address = htonl(address);

    responseBufferSize = sizeof(responseBuffer);

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_QUERY_INTERFACE_INSTANCE,
                        NULL,
                        0,
                        &responseBuffer,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (status == STATUS_SUCCESS) {
        if (responseBuffer.Status == STATUS_SUCCESS) {
            *DeviceInstance = responseBuffer.InstanceNumber;
        }
        else {
            status = RtlNtStatusToDosError(responseBuffer.Status);
        }
    }
    else {
        status = RtlNtStatusToDosError(status);
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ipaddr\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for IP Address resource.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>

#define IP_ADDRESS_STRING_LENGTH  16


BOOLEAN
UnicodeInetAddr(
    PWCHAR  AddressString,
    PULONG  Address
    )
{
    UNICODE_STRING  uString;
    STRING          aString;
    UCHAR           addressBuffer[IP_ADDRESS_STRING_LENGTH];
    NTSTATUS        status;


    aString.Length = 0;
    aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
    aString.Buffer = addressBuffer;

    RtlInitUnicodeString(&uString, AddressString);

    status = RtlUnicodeStringToAnsiString(
                 &aString,
                 &uString,
                 FALSE
                 );

    if (!NT_SUCCESS(status)) {
        return(FALSE);
    }

    *Address = inet_addr(addressBuffer);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ipaddr\nteapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nteapi.h

Abstract:

    Definitions of routines for manipulating dynamic IP Network Table
    Entries (NTEs) and NBT devices (interfaces).

Author:

    Mike Massa (mikemas)  18-Mar-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NTEAPI_INCLUDED_
#define _NTEAPI_INCLUDED_


//
// Types
//
typedef struct {
    unsigned long   Instance;
    IPAddr          Address;
    IPMask          SubnetMask;
    unsigned long   Flags;
} TCPIP_NTE_INFO, *PTCPIP_NTE_INFO;

#define TCPIP_NTE_DYNAMIC 0x00000010


//
// APIs
//
DWORD
TcpipAddNTE(
    IN  LPWSTR  AdapterName,
    IN  IPAddr  Address,
    IN  IPMask  SubnetMask,
    OUT PULONG  NTEContext,
    OUT PULONG  NTEInstance
    );
/*++

Routine Description:

    Adds a new NTE to a specified IP interface. The target IP interface is
    identified by the name of the adapter associated with it.

Arguments:

    AdapterName - A unicode string identifying the adapter/interface to which
                  to add the new NTE.

    Address - The IP address to assign to the new NTE.

    SubnetMask - The IP subnet mask to assign to the new NTE.

    NTEContext - On output, contains the context value identifying the new NTE.

    NTEInstance - On output, contains the instance ID of the new NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
TcpipDeleteNTE(
    IN ULONG  NTEContext
    );
/*++

Routine Description:

    Deletes a specified NTE. The target NTE must have been added using
    TcpipAddNTE.

Arguments:

    NTEContext - The context value identifying the NTE to delete.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
TcpipSetNTEAddress(
    IN DWORD   NTEContext,
    IN IPAddr  Address,
    IN IPMask  SubnetMask
    );
/*++

Routine Description:

    Sets the address of a specified NTE.

Arguments:

    NTEContext - The context value identifying the target NTE.

    Address - The IP address to assign to the NTE. Assigning 0.0.0.0
              invalidates the NTE.

    SubnetMask - The IP subnet mask to assign to the NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
TcpipGetNTEInfo(
    IN  ULONG            NTEContext,
    OUT PTCPIP_NTE_INFO  NTEInfo
    );
/*++

Routine Description:

    Gathers information about a specified NTE.

Arguments:

    NTEContext - The context value identifying the NTE to query.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtAddInterface(
    OUT    LPWSTR   DeviceName,
    IN OUT LPDWORD  DeviceNameSize,
    OUT    PULONG   DeviceInstance
    );
/*++

Routine Description:

    Adds a new NBT interface.

Arguments:

    DeviceName - A unicode string identifying the new NBT interface.

    DeviceNameSize - On input, the size of theh device name buffer.
                     On output, the size of the device name string, or
                     the size needed to accomodate the string.

    DeviceInstance - A pointer to a variable into which to place the
                     instance ID associated with the new interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtDeleteInterface(
    IN LPWSTR   DeviceName
    );
/*++

Routine Description:

    Deletes an NBT interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtBindInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  Address,
    IN IPMask  SubnetMask
    );
/*++

Routine Description:

    Binds a specified NBT interface to a specified IP address.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - The IP address to which bind the interface. Assigning 0.0.0.0
              invalidates the interface.

    SubnetMask - The subnet mask of the IP interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/

DWORD
NbtSetWinsAddrInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  PrWinsAddress,
    IN IPAddr  SecWinsAddress
    );
/*++

Routine Description:

    Sets the WINS addrs for a given Nbt Interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrWinsAddress - Primary WINS addr

    SecWinsAddress - Secondary WINS addr

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/

DWORD
NbtGetInterfaceInfo(
    IN LPWSTR    DeviceName,
    OUT IPAddr * Address,
    OUT PULONG   DeviceInstance
    );
/*++

Routine Description:

    Returns the IP address to which an NBT interface is bound and the interface
    instance ID.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - A pointer to the location in which to store the address of the
              interface.

    DeviceInstance - A pointer to the location in which to store the instance ID
                     associated with the interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtGetWinsAddresses(
    IN  LPWSTR    DeviceName,
    OUT IPAddr *  PrimaryWinsServer,
    OUT IPAddr *  SecondaryWinsServer
    );

/*++

Routine Description:

    Returns the addresses of the WINS servers for which the specified device
    is configured.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrimaryWinsServer - A pointer to a variable into which to place the address
                        of the primary WINS server.

    SecondaryWinsServer - A pointer to a variable into which to place the address
                          of the primary WINS server.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


#endif // ifndef _NTEAPI_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ipaddr\util.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Utility functions for IP Address resource.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

BOOLEAN
UnicodeInetAddr(
    PWCHAR  AddressString,
    PULONG  Address
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\msmq\localsvc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    localsvc.h

Abstract:

    Header file for definitions and structure for the NT Cluster
    Special generic services.

Author:

    John Vert (jvert) 23-May-1997

Revision History:

--*/

#ifndef _LOCALSVC_INCLUDED_
#define _LOCALSVC_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


#define SERVICE_NAME    L"MSMQ"

#define SYNC_VALUE_COUNT 2
#define REG_SYNC_VALUE1 L"Software\\Microsoft\\Cryptography\\MachineKeys\\MSMQ"
#define REG_SYNC_VALUE2 L"Software\\Microsoft\\MSMQ\\Parameters"

#define CRYPTO_VALUE_COUNT 1
#define CRYPTO_SYNC_VALUE1 L"1\\Microsoft Base Cryptographic Provider v1.0\\MSMQ"

#define DOMESTIC_CRYPTO_VALUE_COUNT 1
#define DOMESTIC_CRYPTO_SYNC_VALUE1 L"1\\Microsoft Enhanced Cryptographic Provider v1.0\\MSMQ_128"

#define ENVIRONMENT 1   // Need GetComputerName to lie.

#define COMMON_SEMAPHORE L"Cluster$MSMQSemaphore" // Limit of one resource of this type

#define LOG_CURRENT_MODULE LOG_MODULE_MSMQ

static DWORD   RegSyncCount = SYNC_VALUE_COUNT;
static LPWSTR  RegSync[SYNC_VALUE_COUNT] = {
    REG_SYNC_VALUE1,
    REG_SYNC_VALUE2 };

static DWORD   CryptoSyncCount = CRYPTO_VALUE_COUNT;
static LPWSTR  CryptoSync[CRYPTO_VALUE_COUNT] = {
    CRYPTO_SYNC_VALUE1 };

static DWORD   DomesticCryptoSyncCount = DOMESTIC_CRYPTO_VALUE_COUNT;
static LPWSTR  DomesticCryptoSync[DOMESTIC_CRYPTO_VALUE_COUNT] = {
    DOMESTIC_CRYPTO_SYNC_VALUE1 };

#define CommonReadParameters MsMQReadParameters

DWORD
MsMQReadParametersEx(
    IN OUT PVOID pvResourceEntry,
    IN BOOL bCheckForRequiredProperties
    );

_inline
DWORD
MsMQReadParameters(
    IN OUT PVOID pvResourceEntry
    )
{
    return MsMQReadParametersEx( pvResourceEntry, FALSE /* bCheckForRequiredProperties */ );
}


#define COMMON_CONTROL  1           // Need control functions

typedef struct _COMMON_DEPEND_DATA {
    CLUSPROP_RESOURCE_CLASS storageEntry;
    CLUSPROP_SZ_DECLARE( networkEntry, sizeof(CLUS_RESTYPE_NAME_NETNAME) / sizeof(WCHAR) );
    CLUSPROP_SZ_DECLARE( msdtcEntry, sizeof(CLUS_RESTYPE_NAME_MSDTC) / sizeof(WCHAR) );
    CLUSPROP_SYNTAX endmark;
} COMMON_DEPEND_DATA, *PCOMMON_DEPEND_DATA;


static COMMON_DEPEND_SETUP CommonDependSetup[] = {
    { FIELD_OFFSET(COMMON_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)(ULONGLONG)CLUS_RESCLASS_STORAGE },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(CLUS_RESTYPE_NAME_NETNAME), CLUS_RESTYPE_NAME_NETNAME },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, msdtcEntry), CLUSPROP_SYNTAX_NAME, sizeof(CLUS_RESTYPE_NAME_MSDTC), CLUS_RESTYPE_NAME_MSDTC },
    { 0, 0 }
};

#define COMMON_PARAMS_DEFINED 1     // Define private parameters
typedef struct _COMMON_PARAMS {
    DWORD   dwVersion;
} COMMON_PARAMS, * PCOMMON_PARAMS;

#ifdef _cplusplus
}
#endif


#endif // ifndef _LOCALSVC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\crs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crs.h

Abstract:

    Consistency replica set data structures and API

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef _CRS_DEF
#define _CRS_DEF

#include <windows.h>
#include <assert.h>

#include <stdio.h>
#include <stdlib.h>

#define	CRS_VERSION	1
#define	CRS_TAG		( (CRS_VERSION << 24) | ('crs'))

// sizes must be power of 2
#define CRS_RECORD_SZ 64
#define	CRS_SECTOR_SZ	512
#define	CRS_RECORDS_PER_SECTOR	(CRS_SECTOR_SZ / CRS_RECORD_SZ)
#define	CRS_SECTOR_MASK	(CRS_RECORDS_PER_SECTOR - 1)
#define	CRS_MAX_GROUP_SZ       16

#define CRS_QUORUM(sz, total)   ((sz == total) || (sz > total/2) || ((DWORD)sz > CrsForcedQuorumSize)? 1: 0)

#define	CRS_PREPARE	0x1
#define	CRS_COMMIT	0x2
#define	CRS_ABORT	0x4
#define	CRS_EPOCH	0x8
#define	CRS_DUBIOUS	0x10

typedef ULONGLONG	crs_id_t[2];

typedef ULONGLONG	crs_epoch_t;
typedef ULONGLONG	crs_seq_t;

typedef struct {
    crs_epoch_t	epoch;
    crs_seq_t	seq;
    UINT	state;
    UINT	tag;
}CrsHdr_t;

typedef struct {
    CrsHdr_t	hdr;
    char	data[CRS_RECORD_SZ - sizeof(CrsHdr_t)];
}CrsRecord_t;


typedef NTSTATUS (WINAPI *crs_callback_t)(PVOID hd, int nid,
				       CrsRecord_t *singlerec, 
				       int action, int mid);

#define CRS_STATE_INIT		0
#define CRS_STATE_RECOVERY	1
#define CRS_STATE_READ		2
#define CRS_STATE_WRITE		3

typedef struct {
    CRITICAL_SECTION	lock;

    // log file handle
    HANDLE	fh;

    crs_epoch_t	epoch;		// current epoch
    crs_seq_t	seq;		// current sequence
    CrsRecord_t	*buf;		// current sector
    int		last_record;    // last record in this sector
    int		max_records;	// max number of records in update file

    USHORT	refcnt;
    USHORT	leader_id;
    USHORT	lid;
    USHORT	state; 	// write, read, recovery, init
    BOOLEAN	pending;

    // client call back routine
    crs_callback_t	callback;
    PVOID		callback_arg;

}CrsInfo_t;


typedef struct _CrsRecoveryBlk_t {
    CrsInfo_t	*info, *minfo;
    int		nid, mid;
}CrsRecoveryBlk_t;

#if defined(QFS_DBG)
extern void WINAPI debug_log(char *, ...);
#define CrsLog(_x_)	debug_log _x_
#else
#define CrsLog(_x_)
#endif

#define	CRS_ACTION_REPLAY	0x0	// apply record on specified node
#define	CRS_ACTION_UNDO		0x1	// undo update record
#define	CRS_ACTION_COPY		0x2	// copy one replica to other
#define	CRS_ACTION_QUERY	0x3	// ask about outcome of specified record
#define	CRS_ACTION_DONE		0x4	// signal send of recovery

extern DWORD CrsForcedQuorumSize;

void
WINAPI
CrsSetForcedQuorumSize(DWORD size);

DWORD
WINAPI
CrsOpen(crs_callback_t callback, PVOID callback_arg, USHORT lid,
	WCHAR *log_name, int max_logsectors, HANDLE *hdl);

void
WINAPI
CrsClose(PVOID hd);

void
WINAPI
CrsFlush(PVOID hd);

DWORD
WINAPI
CrsStart(PVOID hd[], ULONG aset, int cluster_sz,
	 ULONG *wset, ULONG *rset, ULONG *fset);

PVOID
WINAPI
CrsPrepareRecord(PVOID hd, PVOID lrec, crs_id_t id);

int
WINAPI
CrsCommitOrAbort(PVOID hd, PVOID lrec, int commit);

int
WINAPI
CrsCanWrite(PVOID hd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\fs.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fs.c

Abstract:

    Implements filesystem operations

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "crs.h"
#include "fsp.h"
#include "fsutil.h"

// Locking order: ulock followed by qlock

////////////////////////////////////////////////////////////////////////////
UINT32
get_attributes(DWORD a)
{
    UINT32 attr = 0;
    if (a & FILE_ATTRIBUTE_READONLY) attr |= ATTR_READONLY;
    if (a & FILE_ATTRIBUTE_HIDDEN)   attr |= ATTR_HIDDEN;
    if (a & FILE_ATTRIBUTE_SYSTEM)   attr |= ATTR_SYSTEM;
    if (a & FILE_ATTRIBUTE_ARCHIVE)  attr |= ATTR_ARCHIVE;
    if (a & FILE_ATTRIBUTE_DIRECTORY) attr |= ATTR_DIRECTORY;
    if (a & FILE_ATTRIBUTE_COMPRESSED) attr |= ATTR_COMPRESSED;
    if (a & FILE_ATTRIBUTE_OFFLINE) attr |= ATTR_OFFLINE;
    return attr;
}


DWORD
unget_attributes(UINT32 attr)
{
    DWORD a = 0;
    if (attr & ATTR_READONLY)  a |= FILE_ATTRIBUTE_READONLY;
    if (attr & ATTR_HIDDEN)    a |= FILE_ATTRIBUTE_HIDDEN;
    if (attr & ATTR_SYSTEM)    a |= FILE_ATTRIBUTE_SYSTEM;
    if (attr & ATTR_ARCHIVE)   a |= FILE_ATTRIBUTE_ARCHIVE;
    if (attr & ATTR_DIRECTORY) a |= FILE_ATTRIBUTE_DIRECTORY;
    if (attr & ATTR_COMPRESSED) a |= FILE_ATTRIBUTE_COMPRESSED;
    if (attr & ATTR_OFFLINE) a |= FILE_ATTRIBUTE_OFFLINE;
    return a;
}


DWORD
unget_disp(UINT32 flags)
{
    switch (flags & FS_DISP_MASK) {
    case DISP_DIRECTORY:
    case DISP_CREATE_NEW:        return FILE_CREATE;
    case DISP_CREATE_ALWAYS:     return FILE_OPEN_IF;
    case DISP_OPEN_EXISTING:     return FILE_OPEN;
    case DISP_OPEN_ALWAYS:       return FILE_OPEN_IF;
    case DISP_TRUNCATE_EXISTING: return FILE_OVERWRITE;
    default: return 0;
    }
}

DWORD
unget_access(UINT32 flags)
{
    DWORD win32_access = (flags & FS_DISP_MASK) == DISP_DIRECTORY ? 
	FILE_GENERIC_READ|FILE_GENERIC_WRITE :  FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;
    if (flags & ACCESS_READ)  win32_access |= FILE_GENERIC_READ;
    if (flags & ACCESS_WRITE) win32_access |= FILE_GENERIC_WRITE;
    win32_access |= FILE_READ_EA | FILE_WRITE_EA;
    return win32_access;
}

DWORD
unget_share(UINT32 flags)
{
    // we always open read shared because this simplifies recovery.
    DWORD win32_share = FILE_SHARE_READ;
    if (flags & SHARE_READ)  win32_share |= FILE_SHARE_READ;
    if (flags & SHARE_WRITE) win32_share |= FILE_SHARE_WRITE;
    return win32_share;
}


DWORD
unget_flags(UINT32 flags)
{
    DWORD x;

    x = 0;
    if ((flags & FS_DISP_MASK) == DISP_DIRECTORY) {
	x = FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT;
    } else {
	// I don't think I can tell without doing a query first, so don't!
//	x = FILE_NON_DIRECTORY_FILE;
    }


    if ((flags & FS_CACHE_MASK) == CACHE_WRITE_THROUGH) {
	x |= FILE_WRITE_THROUGH;
    }
    if ((flags & FS_CACHE_MASK) == CACHE_NO_BUFFERING) {
	x |= FILE_NO_INTERMEDIATE_BUFFERING;
    }

    return x;
}


void
DecodeCreateParam(UINT32 uflags, UINT32 *flags, UINT32 *disp, UINT32 *share, UINT32 *access)
{
    *flags = unget_flags(uflags);
    *disp = unget_disp(uflags);
    *share = unget_share(uflags);
    *access = unget_access(uflags);

}
/********************************************************************/

NTSTATUS
FspAllocatePrivateHandle(UserInfo_t *p, fhandle_t *fid)
{
    int i;
    NTSTATUS err = STATUS_NO_MORE_FILES;

    LockEnter(p->Lock);

    for (i = 0; i < FsTableSize; i++) {
	if (p->Table[i].Flags == 0) {
	    p->Table[i].Flags = ATTR_SYMLINK; // place marker
	    err = STATUS_SUCCESS;
	    break;
	}
    }

    LockExit(p->Lock);

    *fid = (fhandle_t) i;

    return err;
}

void
FspFreeHandle(UserInfo_t *p, fhandle_t fnum)
{

    FsLog(("FreeHandle %d\n", fnum));

    ASSERT(fnum != INVALID_FHANDLE_T);
    LockEnter(p->Lock);
    p->Table[fnum].Flags = 0;
    LockExit(p->Lock);
    
}

/*********************************************************** */

void
FspEvict(VolInfo_t *p, ULONG mask, BOOLEAN flag)
{
    DWORD err;
    void FspCloseVolume(VolInfo_t *vol, ULONG AliveSet);
    ULONG set;

    // must be called with update lock held

    while (mask != 0) {
	FsArbLog(("FspEvict Entry: WSet %x Rset %x ASet %x set %x\n",
	       p->WriteSet, p->ReadSet, p->AliveSet, mask));


	if (flag == FALSE) {
	    // we just need to close the volume and return since
	    // these replicas are not yet added to the aliveset and crs doesn't know
	    // about them
	    FspCloseVolume(p, mask);
	    break;
	}

	LockEnter(p->qLock);
	// clear nid
	p->AliveSet &= ~mask;
	set = p->AliveSet;
	LockExit(p->qLock);

	//  close nid handles <crs, vol, open files>
	FspCloseVolume(p, mask);

	mask = 0;

	err = CrsStart(p->CrsHdl, set, p->DiskListSz,
		       &p->WriteSet, &p->ReadSet, &mask);

	if (mask == 0 && err == ERROR_WRITE_PROTECT) {
	    // we have no quorum
	    if (p->Event) {
		SetEvent(p->Event);
	    }
	}
    }

    FsArbLog(("FspEvict Exit: vol %S WSet %x RSet %x ASet %x\n",
	   p->Root, p->WriteSet, p->ReadSet, p->AliveSet));
}

void
FspJoin(VolInfo_t *p, ULONG mask)
{	
    DWORD err;
    ULONG set = 0;

    // must be called with update lock

    if (mask != 0) {
	FsArbLog(("FspJoin Entry: WSet %x Rset %x ASet %x set %x\n",
	       p->WriteSet, p->ReadSet, p->AliveSet, mask));

	// grab lock now
	LockEnter(p->qLock);
	p->AliveSet |= mask;
	set = p->AliveSet;
	LockExit(p->qLock);

	mask = 0;
	err = CrsStart(p->CrsHdl, set, p->DiskListSz, 
		       &p->WriteSet, &p->ReadSet, &mask);

	if (mask != 0) {
	    // we need to evict dead members
	    FspEvict(p, mask, TRUE);
	}
	if (err == ERROR_WRITE_PROTECT) {
	    // we have no quorum
	    if (p->Event) {
		SetEvent(p->Event);
	    }
	}
    }

    FsArbLog(("FspJoin Exit: WSet %x Rset %x ASet %x\n",
	   p->WriteSet, p->ReadSet, set));
}

void
FspInitAnswers(IO_STATUS_BLOCK *ios, PVOID *rbuf, char *r, int sz)
{

    int i;

    for (i = 0; i < FsMaxNodes; i++) {
	ios[i].Status = STATUS_HOST_UNREACHABLE;
	if (rbuf) {
	    rbuf[i] = r;
	    r += sz;
	}
    }
}


int
FspCheckAnswers(VolInfo_t *vol, IO_STATUS_BLOCK *ios, PVOID *rbuf, UINT32 sz)
{
    int i;
    int nums, numf, lasts;
    ULONG masks, maskf;

    lasts = 0;
    nums = numf = 0;
    masks = maskf = 0;
    for (i = 0; i < FsMaxNodes; i++) {
	if (ios[i].Status == STATUS_HOST_UNREACHABLE) {
	    continue;
	}

	if (lasts == 0) {
	    lasts = i;
	}

	if (ios[i].Status == STATUS_SUCCESS) {
	    nums++;
	    masks |= (1 << i);
	    if (ios[lasts].Information != ios[i].Information) {
		FsLog(("Success node %d inconsistent with node %d!!!\n",
		       lasts, i));
	    }
	} else if (ios[i].Status == STATUS_CONNECTION_DISCONNECTED ||
		   ios[i].Status == STATUS_BAD_NETWORK_PATH ||
		   // this maps to may network errors
		   RtlNtStatusToDosError(ios[i].Status) == ERROR_UNEXP_NET_ERR ||
		   ios[i].Status == STATUS_VOLUME_DISMOUNTED) {
	    ios[i].Status = STATUS_MEDIA_WRITE_PROTECTED;
	    // evict any replica that lost connectivity
	    FspEvict(vol, (ULONG)(1 << i), TRUE);
	    if (lasts == i) {
		lasts = 0;
	    }
	} else {
	    numf++;
	    maskf |= (1 << i);
	}
    }
    if (numf == 0 || nums == 0) {
	return lasts;
    }

    FsLog(("Nodes inconsistency success %x,%d failure %x,%d!!!\n",
	   masks, nums, maskf, numf));

    // We need to evict whomever is smaller
    if (numf > nums) {
	FspEvict(vol, masks, TRUE);
	for (i = 0; i < FsMaxNodes; i++) {
	    if (maskf & (1 << i)) {
		lasts = i;
		break;
	    }
	}
    } else {
	FspEvict(vol, maskf, TRUE);
	for (i = 0; i < FsMaxNodes; i++) {
	    if (masks & (1 << i)) {
		lasts = i;
		break;
	    }
	}
    }

    FsLog(("Take result of node %d\n", lasts));

    return lasts;
}


//////////////////////////////////////////////////////////////////////////////////////

NTSTATUS
FspCreate(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	  PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{

    // each file has a name stream that contains its crs log. We first
    // must open the parent crs log, issue a prepare on it. Create the new file
    // and then issuing a commit or abort on parent crs log. We also, have
    // to issue joins for each new crs handle that we get for the new file or
    // opened file. Note, this open may cause the file to enter recovery
    fs_create_msg_t *msg = (fs_create_msg_t *)args;
    NTSTATUS err, status;
    UINT32 disp, share, access, flags;
    fs_log_rec_t	lrec;
    PVOID seq;
    fs_ea_t x;
    HANDLE fd;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    fs_create_reply_t *rmsg = (fs_create_reply_t *)rbuf;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    fs_id_t	*fid;

    DecodeCreateParam(msg->flags, &flags, &disp, &share, &access);

    FsInitEa(&x);

    memset(&lrec.fs_id, 0, sizeof(lrec.fs_id));
    lrec.command = FS_CREATE;
    lrec.flags = msg->flags;
    lrec.attrib = msg->attr;
    seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid);
    if (seq == 0) {
	FsLog(("create: Unable to prepare log record!, open readonly\n"));
	return STATUS_MEDIA_WRITE_PROTECTED;
    }
    // set fid 
    {
	fs_log_rec_t	*p = (PVOID) seq;

	memcpy(p->fs_id, p->id, sizeof(fs_id_t));

	FsInitEaFid(&x, fid);
	memcpy(fid, p->id, sizeof(fs_id_t));
    }

    err = xFsCreate(&fd, vfd, msg->name, msg->name_len,
		   flags, msg->attr, share, &disp, access,
		   (PVOID) &x, sizeof(x));

    xFsLog(("create: %S err %x access %x disp %x\n", msg->name, 
	   err, access, disp));

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS &&
		     (disp == FILE_CREATED || 
		      disp == FILE_OVERWRITTEN));

    if (err == STATUS_SUCCESS) {
	// we need to get the file id, no need to do this, for debug only
	err = xFsQueryObjectId(fd, (PVOID) fid);
	if (err != STATUS_SUCCESS) {
	    FsLog(("Failed to get fileid %x\n", err));
	    err = STATUS_SUCCESS;
	}
    }


#ifdef FS_ASYNC
    BindNotificationPort(comport, fd, (PVOID) fdnum);
#endif	    

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T) {
	FS_SET_USER_HANDLE(uinfo, nid, msg->fnum, fd);
    } else {
	xFsClose(fd);
    }

    ASSERT(rmsg != NULL);

    memcpy(&rmsg->fid, fid, sizeof(fs_id_t));
    rmsg->action = (USHORT)disp;
    rmsg->access = (USHORT)access;
    *rlen = sizeof(*rmsg);

    FsLog(("Create '%S' nid %d fid %d handle %x oid %I64x:%I64x\n",
	   msg->name,
	   nid, msg->fnum, fd,
	   rmsg->fid[0], rmsg->fid[1]));

    return err;
}

NTSTATUS
FspOpen(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    // same as create except disp is allows open only and
    // no crs logging
    fs_create_msg_t *msg = (fs_create_msg_t *)args;
    NTSTATUS err, status;
    UINT32 disp, share, access, flags;
    HANDLE fd;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    fs_create_reply_t *rmsg = (fs_create_reply_t *)rbuf;

    ASSERT(rmsg != NULL);

    DecodeCreateParam(msg->flags, &flags, &disp, &share, &access);

    disp = FILE_OPEN;
    err = xFsCreate(&fd, vfd, msg->name, msg->name_len,
		   flags, msg->attr, share, &disp, access,
		   NULL, 0);

    xFsLog(("open: %S err %x access %x disp %x\n", msg->name, 
	   err, access, disp));

    if (err == STATUS_SUCCESS) {
	ASSERT(disp != FILE_CREATED && disp != FILE_OVERWRITTEN);
	// we need to get the file id, no need to do this, for debug only
	err = xFsQueryObjectId(fd, (PVOID) &rmsg->fid);
	if (err != STATUS_SUCCESS) {
	    FsLog(("Open '%S' failed to get fileid %x\n",
			msg->name, err));
	    err = STATUS_SUCCESS;
	}
    }


#ifdef FS_ASYNC
    BindNotificationPort(comport, fd, (PVOID) fdnum);
#endif	    

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T) {
	FS_SET_USER_HANDLE(uinfo, nid, msg->fnum, fd);
    } else {
	xFsClose(fd);
    }

    rmsg->action = (USHORT)disp;
    rmsg->access = (USHORT)access;
    *rlen = sizeof(*rmsg);

    FsLog(("Open '%S' nid %d fid %d handle %x oid %I64x:%I64x\n",
	   msg->name,
	   nid, msg->fnum, fd,
	   rmsg->fid[0], rmsg->fid[1]));

    return err;
}


NTSTATUS
FspSetAttr(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	   PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_setattr_msg_t *msg = (fs_setattr_msg_t *)args;
    NTSTATUS err;
    fs_log_rec_t	lrec;
    PVOID seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE fd = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);

    lrec.command = FS_SETATTR;
    memcpy((PVOID) lrec.fs_id, (PVOID) msg->fs_id, sizeof(fs_id_t));
    lrec.attrib = msg->attr.FileAttributes;

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid)) == 0) {
	return STATUS_MEDIA_WRITE_PROTECTED;
    }
    
    // can be async ?
    err = xFsSetAttr(fd, &msg->attr);

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

    return err;

}


NTSTATUS
FspSetAttr2(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	    PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_setattr_msg_t *msg = (fs_setattr_msg_t *)args;
    HANDLE fd = INVALID_HANDLE_VALUE;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    NTSTATUS err;
    fs_log_rec_t	lrec;
    PVOID seq;

    assert(len == sizeof(*msg));

    // must be sync in order to close file
    err = xFsOpenWA(&fd, vfd, msg->name, msg->name_len);
    if (err == STATUS_SUCCESS) {
	err = xFsQueryObjectId(fd, (PVOID) &lrec.fs_id);
    }

    if (err == STATUS_SUCCESS) {

	lrec.command = FS_SETATTR;
	lrec.attrib = msg->attr.FileAttributes;

	if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid)) != 0) {

	    err = xFsSetAttr(fd, &msg->attr);

	    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);
	} else {
	    return STATUS_MEDIA_WRITE_PROTECTED;
	}
    }

    if (fd != INVALID_HANDLE_VALUE)
	xFsClose(fd);

    xFsLog(("setattr2 nid %d '%S' err %x\n", nid, msg->name, err));

    return err;

}

NTSTATUS
FspLookup(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	  PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_lookup_msg_t *msg = (fs_lookup_msg_t *) args;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    FILE_NETWORK_OPEN_INFORMATION *attr = (FILE_NETWORK_OPEN_INFORMATION *)rbuf;
    
    ASSERT(*rlen == sizeof(*attr));

    return xFsQueryAttrName(vfd, msg->name, msg->name_len, attr);

}

NTSTATUS
FspGetAttr(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	   PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fhandle_t handle = *(fhandle_t *) args;
    HANDLE fd = FS_GET_USER_HANDLE(uinfo, nid, handle);
    FILE_NETWORK_OPEN_INFORMATION *attr = (FILE_NETWORK_OPEN_INFORMATION *)rbuf;

    ASSERT(*rlen == sizeof(*attr));

    return xFsQueryAttr(fd, attr);
}


NTSTATUS
FspClose(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	 PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fhandle_t handle = *(fhandle_t *) args;
    HANDLE fd;
    NTSTATUS err;

    if (uinfo != NULL && handle != INVALID_FHANDLE_T)
	fd = FS_GET_USER_HANDLE(uinfo, nid, handle);
    else
	fd = FS_GET_VOL_HANDLE(vinfo, nid);

    FsLog(("Closing nid %d fid %d handle %x\n", nid, handle, fd));
    err = xFsClose(fd);
    if (err != STATUS_SUCCESS)
//	return err;
	err = STATUS_SUCCESS; // don't evict a node due to this

    if (uinfo != NULL && handle != INVALID_FHANDLE_T) {
	FS_SET_USER_HANDLE(uinfo, nid, handle, INVALID_HANDLE_VALUE);
    } else {
	FS_SET_VOL_HANDLE(vinfo, nid, INVALID_HANDLE_VALUE);
    }

    return err;
}


NTSTATUS
FspReadDir(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	   PVOID args, ULONG len, PVOID rbuf,
	   ULONG_PTR *entries_found)
{
    fs_io_msg_t *msg = (fs_io_msg_t *)args;
    int i;
    NTSTATUS e = STATUS_SUCCESS;
    int size = (int) msg->size;
    int cookie = (int) msg->cookie;
    HANDLE dir; 
    dirinfo_t *buffer = (dirinfo_t *)msg->buf;

    xFsLog(("DirLoad: size %d\n", size));

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T)
	dir = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    else
	dir = FS_GET_VOL_HANDLE(vinfo, nid);

    *entries_found = 0;
    for(i = 0; size >= sizeof(dirinfo_t) ; i+=PAGESIZE) {
	// this must come from the source if we are to do async readdir
	char buf[PAGESIZE];
	int sz;

	sz = min(PAGESIZE, size);
	e = xFsReadDir(dir, buf, &sz, (cookie == 0) ? TRUE : FALSE);
	if (e == STATUS_SUCCESS) {
	    PFILE_DIRECTORY_INFORMATION p;

	    p = (PFILE_DIRECTORY_INFORMATION) buf;
	    while (size >= sizeof(dirinfo_t)) {
		char *foo;
		int k;

		k = p->FileNameLength/2;
		p->FileName[k] = L'\0';
		wcscpy(buffer->name, p->FileName);
		buffer->attribs.file_size = p->EndOfFile.QuadPart;
		buffer->attribs.alloc_size = p->AllocationSize.QuadPart;
		buffer->attribs.create_time = p->CreationTime.QuadPart;
		buffer->attribs.access_time = p->LastAccessTime.QuadPart;
		buffer->attribs.mod_time = p->LastWriteTime.QuadPart;
		buffer->attribs.attributes = p->FileAttributes;
		buffer->cookie = ++cookie;
		buffer++;
		size -= sizeof(dirinfo_t);
		(*entries_found)++;

		if (p->NextEntryOffset == 0)
		    break;

		foo = (char *) p;
		foo += p->NextEntryOffset;
		p = (PFILE_DIRECTORY_INFORMATION) foo;
	    }
	}
	else {
	    break;
	}
    }

    return e;

}

NTSTATUS
FspMkDir(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	 PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_create_msg_t	*msg = (fs_create_msg_t *)args;
    NTSTATUS err;
    HANDLE fd;
    fs_log_rec_t	lrec;
    PVOID seq;
    fs_ea_t x;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    fs_id_t *fid;
    UINT32 disp, share, access, flags;

    FsInitEa(&x);

    memset(&lrec.fs_id, 0, sizeof(lrec.fs_id));
    lrec.command = FS_MKDIR;
    lrec.attrib = msg->attr;
    lrec.flags = msg->flags;

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid)) == 0) {
	return STATUS_MEDIA_WRITE_PROTECTED;
    }

    // set fid 
    {
	fs_log_rec_t	*p = (PVOID) seq;

	memcpy(p->fs_id, p->id, sizeof(fs_id_t));

	FsInitEaFid(&x, fid);
	// set fs_id of the file
	memcpy(fid, p->id, sizeof(fs_id_t));
    }

    // decode attributes
    DecodeCreateParam(msg->flags, &flags, &disp, &share, &access);

    // always sync call
    err = xFsCreate(&fd, vfd, msg->name, msg->name_len, flags,
		   msg->attr, share, &disp, access,
		   (PVOID) &x, sizeof(x));

    FsLog(("Mkdir '%S' %x: cflags %x flags:%x attr:%x share:%x disp:%x access:%x\n",
	   msg->name, err, msg->flags,
	   flags, msg->attr, share, disp, access));


    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS &&
		     (disp == FILE_CREATED || 
		      disp == FILE_OVERWRITTEN));

    if (err == STATUS_SUCCESS) {
	// return fid
	if (rbuf != NULL) {
	    ASSERT(*rlen == sizeof(fs_id_t));
	    memcpy(rbuf, fid, sizeof(fs_id_t));
	}
	xFsClose(fd);
    }

    return err;

}

NTSTATUS
FspRemove(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	  PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_remove_msg_t	*msg = (fs_remove_msg_t *)args;
    NTSTATUS err;
    fs_log_rec_t	lrec;
    PVOID	seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    HANDLE fd;

    *rlen = 0;

    // next three statements to obtain name -> fs_id
    err = xFsOpenRA(&fd, vfd, msg->name, msg->name_len); 
    if (err != STATUS_SUCCESS) {
	return err;
    }

    // get object id
    err = xFsQueryObjectId(fd, (PVOID) &lrec.fs_id);

    xFsClose(fd);

    lrec.command = FS_REMOVE;

    if (err != STATUS_SUCCESS) {
	return err;
    }

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid)) == 0) {
	return STATUS_MEDIA_WRITE_PROTECTED;
    }

    err = xFsDelete(vfd, msg->name, msg->name_len);

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

    xFsLog(("Rm nid %d '%S' %x\n", nid, msg->name, err));

    return err;

}

NTSTATUS
FspRename(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	  PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_rename_msg_t	*msg = (fs_rename_msg_t *)args;
    NTSTATUS err;
    fs_log_rec_t	lrec;
    PVOID	seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    HANDLE fd;

    lrec.command = FS_RENAME;

    err = xFsOpen(&fd, vfd, msg->sname, msg->sname_len,
		  STANDARD_RIGHTS_REQUIRED| SYNCHRONIZE |
		  FILE_READ_EA |
		  FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		  0);

    if (err != STATUS_SUCCESS) {
	return err;
    }

    // get file id
    err = xFsQueryObjectId(fd, (PVOID) &lrec.fs_id); 

    if (err == STATUS_SUCCESS) {
	if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid)) != 0) {
	    err = xFsRename(fd, vfd, msg->dname, msg->dname_len);
	    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);
	} else {
	    err = STATUS_MEDIA_WRITE_PROTECTED;
	}
    } else {
	xFsLog(("Failed to obtain fsid %x\n", err));
    }

    xFsClose(fd);

    xFsLog(("Mv nid %d %S -> %S err %x\n", nid, msg->sname, msg->dname,
	   err));

    return err;

}

NTSTATUS
FspWrite(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	 PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER off;
    ULONG key;
    fs_io_msg_t *msg = (fs_io_msg_t *)args;
    fs_log_rec_t	lrec;
    PVOID seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE fd;

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T)
	fd = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    else
	fd = (HANDLE) msg->context;

    lrec.command = FS_WRITE;
    memcpy(lrec.fs_id, (PVOID) msg->fs_id, sizeof(fs_id_t));
    lrec.offset = msg->offset;
    lrec.length = msg->size;

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid)) == 0) {
	return STATUS_MEDIA_WRITE_PROTECTED;
    }

    // Write ops
    xFsLog(("Write %d len %d off %d\n", nid, msg->size, msg->offset));

    off.LowPart = msg->offset;
    off.HighPart = 0;	
    key = FS_BUILD_LOCK_KEY((uinfo ? uinfo->Uid : 0), nid, msg->fnum);

    if (msg->size > 0) {
	err = NtWriteFile(fd, NULL, NULL, (PVOID) NULL, &ios,
			  msg->buf, msg->size, &off, &key);
    } else {
	FILE_END_OF_FILE_INFORMATION x;

	x.EndOfFile = off;

	err = NtSetInformationFile(fd, &ios,
				   (char *) &x, sizeof(x),
				   FileEndOfFileInformation);
    }

    if (err == STATUS_PENDING) {
	EventWait(fd);
	err = ios.Status;
    }

    *rlen = ios.Information;

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

    return err;

}

NTSTATUS
FspRead(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_io_msg_t	*msg = (fs_io_msg_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER off;
    HANDLE fd = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    ULONG key;

    assert(sz == sizeof(*msg));

    // Read ops
    off.LowPart = msg->offset;
    off.HighPart = 0;	
    key = FS_BUILD_LOCK_KEY(uinfo->Uid, nid, msg->fnum);

    ios.Information = 0;
    err = NtReadFile(fd, NULL, NULL, NULL,
		     &ios, msg->buf, msg->size, &off, &key);

    if (err == STATUS_PENDING) {
	EventWait(fd);
	err = ios.Status;
    }

    *rlen = ios.Information;

    xFsLog(("fs_read err %x sz %d\n", err, *rlen));

    return err;
}


NTSTATUS
FspFlush(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	 PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fhandle_t fnum = *(fhandle_t *)args;
    IO_STATUS_BLOCK ios;
    HANDLE fd;

    ASSERT(sz == sizeof(fhandle_t));
    *rlen = 0;

    if (uinfo != NULL && fnum != INVALID_FHANDLE_T) {
	fd = FS_GET_USER_HANDLE(uinfo, nid, fnum);
    } else {
	fd = FS_GET_VOL_HANDLE(vinfo, nid);
    }
    return NtFlushBuffersFile(fd, &ios);
}

NTSTATUS
FspLock(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_lock_msg_t *msg = (fs_lock_msg_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER offset, len;
    BOOLEAN wait, shared;
    ULONG key = FS_BUILD_LOCK_KEY(uinfo->Uid, nid, msg->fnum);

    assert(sz == sizeof(*msg));

    // xxx: need to log

    FsLog(("Lock %d off %d len %d flags %x\n", msg->fnum, msg->offset, msg->length,
	   msg->flags));

    offset.LowPart = msg->offset;
    offset.HighPart = 0;
    len.LowPart = msg->length;
    len.HighPart = 0;

    // todo: need to be async, if we are the owner node and failnow is false, then
    // we should pass in the context and the completion port responses back
    // to the user
    wait = (BOOLEAN) ((msg->flags & FS_LOCK_WAIT) ? TRUE : FALSE);
    // todo: this can cause lots of headache, never wait.
    wait = FALSE;
    shared = (BOOLEAN) ((msg->flags & FS_LOCK_SHARED) ? FALSE : TRUE);
    
    err = NtLockFile(uinfo->Table[msg->fnum].Fd[nid],
		     NULL, NULL, (PVOID) NULL, &ios,
		     &offset, &len,
		     key, wait, shared);

    // xxx: Need to log in software only

    *rlen = 0;
    FsLog(("Lock err %x\n", err));
    return err;
}

NTSTATUS
FspUnlock(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	  PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_lock_msg_t *msg = (fs_lock_msg_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER offset, len;
    ULONG key = FS_BUILD_LOCK_KEY(uinfo->Uid, nid, msg->fnum);

    assert(sz == sizeof(*msg));

    // xxx: need to log

    xFsLog(("Unlock %d off %d len %d\n", msg->fnum, msg->offset, msg->length));

    offset.LowPart = msg->offset;
    offset.HighPart = 0;
    len.LowPart = msg->length;
    len.HighPart = 0;

    // always sync I think
    err = NtUnlockFile(uinfo->Table[msg->fnum].Fd[nid], &ios, &offset, &len, key);

    // xxx: need to log in software only

    FsLog(("Unlock err %x\n", err));

    *rlen = 0;
    return err;
}

NTSTATUS
FspStatFs(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	  PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_attr_t *msg = (fs_attr_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    FILE_FS_SIZE_INFORMATION fsinfo;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);

    assert(sz == sizeof(*msg));

    // xxx: need to log
    lstrcpyn(msg->fs_name, "FsCrs", MAX_FS_NAME_LEN);

    err = NtQueryVolumeInformationFile(vfd, &ios,
				       (PVOID) &fsinfo,
				       sizeof(fsinfo),
				       FileFsSizeInformation);
    if (err == STATUS_SUCCESS) {
	msg->total_units = fsinfo.TotalAllocationUnits.QuadPart;
	msg->free_units = fsinfo.AvailableAllocationUnits.QuadPart;
	msg->sectors_per_unit = fsinfo.SectorsPerAllocationUnit;
	msg->bytes_per_sector = fsinfo.BytesPerSector;
    }

    *rlen = 0;
    return err;
}

NTSTATUS
FspCheckFs(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	   PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    FILE_FS_SIZE_INFORMATION fsinfo;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    PVOID crshdl = FS_GET_CRS_HANDLE(vinfo, nid);

    err = NtQueryVolumeInformationFile(vfd, &ios,
				       (PVOID) &fsinfo,
				       sizeof(fsinfo),
				       FileFsSizeInformation);

    // We need to issue crsflush to flush last write
    CrsFlush(crshdl);

    if (err == STATUS_SUCCESS) {
	HANDLE notifyfd = FS_GET_VOL_NOTIFY_HANDLE(vinfo, nid);
	if (WaitForSingleObject(notifyfd, 0) == WAIT_OBJECT_0) {
	    // reload notification again
	    FindNextChangeNotification(notifyfd);
	}
    } else {
	FsLog(("FsReserve failed nid %d err %x\n", nid, err));
    }

    *rlen = 0;
    return err;
}

NTSTATUS
FspGetRoot(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
	   PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    LPWSTR vname = FS_GET_VOL_NAME(vinfo, nid);

    swprintf(rbuf, L"\\\\?\\%s\\%s",vname,vinfo->Root);

    FsLog(("FspGetRoot '%S'\n", rbuf));

    return STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////////////
BOOLEAN FsReadOnly = FALSE;

int
SendAvailRequest(fs_handler_t callback, VolInfo_t *vol, UserInfo_t *uinfo,
	    PVOID msg, ULONG len, PVOID *rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
{
    ULONG mask;
    int i;
    DWORD count = 0;

    if (vol == NULL)
	return ERROR_INVALID_HANDLE;

    // lock volume for update
    LockEnter(vol->uLock);

    // issue update for each replica
    i = 0;
    for (mask = vol->ReadSet; mask != 0; mask = mask >> 1, i++) {
	if (mask & 0x1) {
	    count++;
	    ios[i].Information = rsz;
	    ios[i].Status = callback(vol, uinfo, i, 
				     msg, len,
				     rbuf ? rbuf[i] : NULL,
				     &ios[i].Information);
	}
    }

    // process ios and evict replicas that don't agree with majority
    if ((!FsReadOnly && CRS_QUORUM(count, vol->DiskListSz)) || (FsReadOnly && vol->ReadSet != 0))
	i = FspCheckAnswers(vol, ios, rbuf, rsz);
    else {
	i = 0;
	ios[0].Status = STATUS_MEDIA_WRITE_PROTECTED;
	ios[0].Information = count;	// return number in current read set
    }

    // unlock volume
    LockExit(vol->uLock);

    return i;
}

int
SendRequest(fs_handler_t callback, UserInfo_t *uinfo,
	    PVOID msg, ULONG len, PVOID *rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
{
    ULONG mask;
    int i;
    VolInfo_t *vol = uinfo->VolInfo;

    if (vol == NULL)
	return ERROR_INVALID_HANDLE;

    // lock volume for update
    LockEnter(vol->uLock);

    // issue update for each replica
    i = 0;
    for (mask = vol->WriteSet; mask != 0; mask = mask >> 1, i++) {
	if (mask & 0x1) {
	    ios[i].Information = rsz;
	    ios[i].Status = callback(vol, uinfo, i, 
				     msg, len,
				     rbuf ? rbuf[i] : NULL,
				     &ios[i].Information);
	}
    }

    // process ios and evict replicas that don't agree with majority
    if (vol->WriteSet != 0)
	i = FspCheckAnswers(vol, ios, rbuf, rsz);
    else {
	i = 0;
	ios[0].Status = STATUS_MEDIA_WRITE_PROTECTED;
	ios[0].Information = 0;
    }

    // unlock volume
    LockExit(vol->uLock);

    return i;
}

NTSTATUS
SendReadRequest(fs_handler_t callback, UserInfo_t *uinfo,
	    PVOID msg, ULONG len, PVOID rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
{
    ULONG mask;
    int i;
    VolInfo_t *vol = uinfo->VolInfo;

    if (vol == NULL)
	return ERROR_INVALID_HANDLE;

    // lock volume for update
    LockEnter(vol->uLock);

    // issue update for each replica
    i = 0;
    for (mask = vol->ReadSet; mask != 0; mask = mask >> 1, i++) {
	if (mask & 0x1) {
	    ios->Information = rsz;
	    ios->Status = callback(vol, uinfo, i, 
				   msg, len, rbuf, &ios->Information);

	    if (ios->Status == STATUS_CONNECTION_DISCONNECTED ||
		ios->Status == STATUS_VOLUME_DISMOUNTED) {
		// mark replica as invalid
		FspEvict(vol, (ULONG)(1 << i), TRUE);
		// reload mask again
		mask = vol->ReadSet;
	    } else {
		break;
	    }
	}
    }

    // process ios and evict replicas that don't agree with majority
    if (vol->ReadSet == 0) {
	ios->Status = STATUS_MEDIA_WRITE_PROTECTED;
	ios->Information = 0;
    }

    // unlock volume
    LockExit(vol->uLock);

    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////

DWORD
FsCreate(
    PVOID	fshdl,
    LPWSTR	name,
    USHORT namelen,
    UINT32 flags, 
    fattr_t* fattr, 
    fhandle_t* phandle,
    UINT32   *action
    )
{
    UserInfo_t	*uinfo = (UserInfo_t *) fshdl;
    NTSTATUS err;
    fs_create_reply_t nfd[FsMaxNodes];
    IO_STATUS_BLOCK status[FsMaxNodes];
    PVOID rbuf[FsMaxNodes];
    fs_create_msg_t msg;
    fhandle_t fdnum;

    ASSERT(uinfo != NULL);

    xFsLog(("FsDT::create(%S, 0x%08X, 0x%08X, 0x%08d)\n",
                 name, flags, fattr, namelen));

    if (!phandle) return ERROR_INVALID_PARAMETER;
    *phandle = INVALID_FHANDLE_T;

    if (!name) return ERROR_INVALID_PARAMETER;

    if (flags != (FLAGS_MASK & flags)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (action != NULL)
	*action = flags & FS_ACCESS_MASK;

    // if we are doing a directory, open locally
    // todo: this should be merged with other case, if
    // we are doing an existing open, then no need to
    // issue update and log it, but we have to do
    // mcast in order for the close to work.

    if (namelen > 0) {
	if (*name == L'\\') {
	    name++;
	    namelen--;
	}

	if (name[namelen-1] == L'\\') {
	    namelen--;
	    name[namelen] = L'\0';
	}
    }

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.name = name;
    msg.name_len = namelen;
    msg.flags = flags;
    msg.attr = 0;
    if (fattr) {
	msg.attr = unget_attributes(fattr->attributes);
    }

    FspInitAnswers(status, rbuf, (char *) nfd, sizeof(nfd[0]));

    // allocate a new handle
    err = FspAllocatePrivateHandle(uinfo, &fdnum);
    if (err == STATUS_SUCCESS) {
	int sid;

        msg.fnum = fdnum;
	// Set flags in advance to sync with replay
	uinfo->Table[fdnum].Flags = flags;

	if (namelen < 2 ||
	    ((flags & FS_DISP_MASK) == DISP_DIRECTORY) ||
	    (unget_disp(flags) == FILE_OPEN)) {
    
	    sid = SendAvailRequest(FspOpen, uinfo->VolInfo,
			      uinfo,
			      (PVOID) &msg, sizeof(msg),
			      rbuf, sizeof(nfd[0]),
			      status);
	} else {
	    sid = SendRequest(FspCreate,
			      uinfo,
			      (PVOID) &msg, sizeof(msg),
			      rbuf, sizeof(nfd[0]),
			      status);
	}

	if (action != NULL) {
	    if (!(nfd[sid].access & FILE_GENERIC_WRITE))
		flags &= ~ACCESS_WRITE;
	    *action = flags | nfd[sid].action;
	}

	err = status[sid].Status;
	if (err == STATUS_SUCCESS) {
	    fs_id_t *fid = FS_GET_FID_HANDLE(uinfo, fdnum);

	    // set file id
	    memcpy((PVOID) fid, (PVOID) nfd[sid].fid, sizeof(fs_id_t));
	    FsLog(("File id %I64x:%I64x\n", (*fid)[0], (*fid)[1]));
	    // todo: bind handles to completion port if we do async
        } else {
	    // free handle
	    FspFreeHandle(uinfo, fdnum);
	}
   }

    // todo: need to set fid 

    *phandle = fdnum;

    FsLog(("create: return fd %d err %x\n", *phandle, err));

    return RtlNtStatusToDosError(err);
}

void
BuildFileAttr(FILE_BASIC_INFORMATION *attr, fattr_t *fattr)
{

    memset(attr, 0, sizeof(*attr));
    if (fattr->create_time != INVALID_UINT64)
	attr->CreationTime.QuadPart = fattr->create_time;

    if (fattr->mod_time != INVALID_UINT64)
	attr->LastWriteTime.QuadPart = fattr->mod_time;

    if (fattr->access_time != INVALID_UINT64)
	attr->LastAccessTime.QuadPart = fattr->access_time;

    if (fattr->attributes != INVALID_UINT32)
	attr->FileAttributes = unget_attributes(fattr->attributes);

}


DWORD
FsSetAttr(
    PVOID	fshdl,
    fhandle_t handle,
    fattr_t* attr
    )
{
    UserInfo_t *uinfo = (UserInfo_t *)fshdl;
    fs_setattr_msg_t msg;
    int sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (!attr || handle == INVALID_FHANDLE_T)
	return ERROR_INVALID_PARAMETER;

    // todo: get file id
    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.fs_id = FS_GET_FID_HANDLE(uinfo, handle);
    BuildFileAttr(&msg.attr, attr);
    msg.fnum = handle;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspSetAttr, uinfo,
		      (char *)&msg, sizeof(msg),
		      NULL, 0,
		      status);

    return RtlNtStatusToDosError(status[sid].Status);
}

DWORD
FsSetAttr2(
    PVOID	fshdl,
    LPWSTR	name,
    USHORT	name_len,
    fattr_t* attr
    )
{
    UserInfo_t *uinfo = (UserInfo_t *) fshdl;
    fs_setattr_msg_t msg;
    int sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (!attr || !name)
	return ERROR_INVALID_PARAMETER;

    if (*name == '\\') {
	name++;
	name_len--;
    }

    // todo: locate file id

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.name = name;
    msg.name_len = name_len;

    BuildFileAttr(&msg.attr, attr);

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspSetAttr2, uinfo,
		      (char *)&msg, sizeof(msg),
		      NULL, 0,
		      status);

    return RtlNtStatusToDosError(status[sid].Status);
}

DWORD
FsLookup(
    PVOID	fshdl,
    LPWSTR	name,
    USHORT	name_len,
    fattr_t* fattr
    )
{
    fs_lookup_msg_t msg;
    int err;
    IO_STATUS_BLOCK ios;
    FILE_NETWORK_OPEN_INFORMATION attr;
    

    FsLog(("Lookup name '%S' %x\n", name, fattr));

    if (!fattr) return ERROR_INVALID_PARAMETER;

    if (*name == '\\') {
	name++;
	name_len--;
    }

    msg.name = name;
    msg.name_len = name_len;

    err = SendReadRequest(FspLookup, (UserInfo_t *)fshdl,
			  (PVOID) &msg, sizeof(msg),
			  (PVOID) &attr, sizeof(attr),
			  &ios);

    err = ios.Status;
    if (ios.Status == STATUS_SUCCESS) {
	fattr->file_size = attr.EndOfFile.QuadPart;
	fattr->alloc_size = attr.AllocationSize.QuadPart;
	fattr->create_time = *(TIME64 *)&attr.CreationTime;
	fattr->access_time = *(TIME64 *)&attr.LastAccessTime;
	fattr->mod_time = *(TIME64 *)&attr.LastWriteTime;
	fattr->attributes = get_attributes(attr.FileAttributes);
    }


    FsLog(("Lookup: return %x\n", err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsGetAttr(
    PVOID	fshdl,
    fhandle_t handle, 
    fattr_t* fattr
    )
{
    int err;
    IO_STATUS_BLOCK ios;
    FILE_NETWORK_OPEN_INFORMATION attr;

    xFsLog(("Getattr fid '%d' %x\n", handle, fattr));

    if (!fattr) return ERROR_INVALID_PARAMETER;

    err = SendReadRequest(FspGetAttr, (UserInfo_t *)fshdl,
			  (PVOID) &handle, sizeof(handle),
			  (PVOID) &attr, sizeof(attr),
			  &ios);

    err = ios.Status;
    if (err == STATUS_SUCCESS) {
	fattr->file_size = attr.EndOfFile.QuadPart;
	fattr->alloc_size = attr.AllocationSize.QuadPart;
	fattr->create_time = *(TIME64 *)&attr.CreationTime;
	fattr->access_time = *(TIME64 *)&attr.LastAccessTime;
	fattr->mod_time = *(TIME64 *)&attr.LastWriteTime;
	fattr->attributes =attr.FileAttributes;
    }

    FsLog(("Getattr: return %d\n", err));

    return RtlNtStatusToDosError(err);
}


DWORD
FsClose(
    PVOID	fshdl,
    fhandle_t handle
    )
{
    int sid, err;
    IO_STATUS_BLOCK status[FsMaxNodes];
    UserInfo_t *uinfo;

    if (handle == INVALID_FHANDLE_T) return ERROR_INVALID_PARAMETER;
    if (handle >= FsTableSize) return ERROR_INVALID_PARAMETER;


    FsLog(("Close: fid %d\n", handle));

    FspInitAnswers(status, NULL, NULL, 0);

    uinfo = (UserInfo_t *) fshdl;
    sid = SendAvailRequest(FspClose, uinfo->VolInfo, uinfo,
		      (PVOID) &handle, sizeof(handle),
		      NULL, 0,
		      status);

    err = status[sid].Status;
    if (err == STATUS_SUCCESS) {
	// need to free this handle slot
	FspFreeHandle((UserInfo_t *) fshdl, handle);
    }

    FsLog(("Close: fid %d err %x\n", handle, err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsWrite(
    PVOID	fshdl,
    fhandle_t handle, 
    UINT32 offset, 
    UINT16 *pcount, 
    void* buffer,
    PVOID context
    )
{
    DWORD	err;
    IO_STATUS_BLOCK status[FsMaxNodes];
    int i, sid;
    fs_io_msg_t	msg;
    UserInfo_t *uinfo = (UserInfo_t *) fshdl;
    
    if (!pcount || handle == INVALID_FHANDLE_T) return ERROR_INVALID_PARAMETER;

    FsLog(("Write %d offset %d count %d\n", handle, offset, *pcount));

    i = (int) offset;
    if (i < 0) {
	offset = 0;
	(*pcount)--;
    }

    // todo: locate file id

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.fs_id = FS_GET_FID_HANDLE(uinfo, handle);
    msg.offset = offset;
    msg.size = (UINT32) *pcount;
    msg.buf = buffer;
    msg.context = context;
    msg.fnum = handle;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspWrite, (UserInfo_t *)fshdl,
		      (PVOID) &msg, sizeof(msg),
		      NULL, 0,
		      status);


    err = status[sid].Status;
    *pcount = (USHORT) status[sid].Information;

    FsLog(("write: return %x\n", err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsRead(
    PVOID	fshdl,
    fhandle_t handle, 
    UINT32 offset, 
    UINT16* pcount, 
    void* buffer,
    PVOID context
    )
{
    NTSTATUS	err;
    IO_STATUS_BLOCK ios;
    fs_io_msg_t	msg;
    
    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.offset = offset;
    msg.buf = buffer;
    msg.size = (UINT32) *pcount;
    msg.context = context;
    msg.fnum = handle;

    FsLog(("read: %x fd %d sz %d\n", context, handle, msg.size));

    err = SendReadRequest(FspRead, (UserInfo_t *)fshdl,
			  (PVOID) &msg, sizeof(msg),
			  NULL, 0,
			  &ios);

    err = ios.Status;
    if (err == STATUS_END_OF_FILE) {
	*pcount = 0;
	return ERROR_SUCCESS;
    }
	
    err = RtlNtStatusToDosError(err);

    *pcount = (USHORT) ios.Information;

    FsLog(("read: %x return %x sz %d\n", context, err, *pcount));

    return err;
#if 0
#ifdef FS_ASYNC
    return ERROR_IO_PENDING; //err;
#else
    return ERROR_SUCCESS;
#endif
#endif
}



DWORD
FsReadDir(
    PVOID	fshdl,
    fhandle_t dir, 
    UINT32 cookie, 
    dirinfo_t* buffer,
    UINT32 size, 
    UINT32 *entries_found
    )
{
    fs_io_msg_t msg;
    int err;
    IO_STATUS_BLOCK	ios;


    FsLog(("read_dir: cookie %d buf %x entries %x\n", cookie, buffer, entries_found));
    if (!entries_found || !buffer) return ERROR_INVALID_PARAMETER;

    msg.cookie = cookie;
    msg.buf = (PVOID) buffer;
    msg.size = size;
    msg.fnum = dir;

    err = SendReadRequest(FspReadDir, (UserInfo_t *)fshdl,
			  (PVOID) &msg, sizeof(msg),
			  NULL, 0,
			  &ios);

    err = ios.Status;
    *entries_found = (UINT32) ios.Information;

    xFsLog(("read_dir: err %d entries %d\n", err, *entries_found));
    return RtlNtStatusToDosError(err);
}


DWORD
FsRemove(
    PVOID	fshdl,
    LPWSTR	name,
    USHORT	name_len
    )
{
    fs_remove_msg_t msg;
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];


    if (*name == L'\\') {
	name++;
	name_len--;
    }

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.name = name;
    msg.name_len = name_len;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspRemove, (UserInfo_t *) fshdl,
		      (PVOID *)&msg, sizeof(msg),
		      NULL, 0,
		      status);

    err = status[sid].Status;

    return RtlNtStatusToDosError(err);
}

DWORD
FsRename(
    PVOID	fshdl,
    LPWSTR 	from_name,
    USHORT	from_name_len,
    LPWSTR 	to_name,
    USHORT	to_name_len
    )
{

    int err, sid;
    fs_rename_msg_t msg;
    IO_STATUS_BLOCK status[FsMaxNodes];


    if (!from_name || !to_name) 
	return ERROR_INVALID_PARAMETER;

    if (*from_name == L'\\') {
	from_name++;
	from_name_len--;
    }

    if (*to_name == L'\\') {
	to_name++;
	to_name_len--;
    }
    if (*from_name == L'\0' || *to_name == L'\0') 
	return ERROR_INVALID_PARAMETER;


    FsLog(("rename %S -> %S,%d\n", from_name, to_name,to_name_len));

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.sname = from_name;
    msg.sname_len = from_name_len;
    msg.dname = to_name;
    msg.dname_len = to_name_len;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspRename, (UserInfo_t *) fshdl,
		      (PVOID) &msg, sizeof(msg),
		      NULL, 0,
		      status);

    err = status[sid].Status;

    return RtlNtStatusToDosError(err);
}


DWORD
FsMkDir(
    PVOID	fshdl,
    LPWSTR	name,
    USHORT	name_len,
    fattr_t* attr
    )
{
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];
    fs_id_t	ids[FsMaxNodes];
    PVOID	*rbuf[FsMaxNodes];
    fs_create_msg_t msg;

    // XXX: we ignore attr for now...
    if (!name) return ERROR_INVALID_PARAMETER;
    if (*name == L'\\') {
	name++;
	name_len--;
    }

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.attr = (attr != NULL ? unget_attributes(attr->attributes) : 
		FILE_ATTRIBUTE_DIRECTORY);
    msg.flags = DISP_DIRECTORY | SHARE_READ | SHARE_WRITE;
    msg.name = name;
    msg.name_len = name_len;

    FspInitAnswers(status, (PVOID *)rbuf, (PVOID) ids, sizeof(ids[0]));

    sid = SendRequest(FspMkDir, (UserInfo_t *) fshdl,
		      (PVOID) &msg, sizeof(msg),
		      (PVOID *)rbuf, sizeof(ids[0]),
		      status);

    err = status[sid].Status;
    // todo: insert pathname and file id into hash table

    return RtlNtStatusToDosError(err);
}


DWORD
FsFlush(
    PVOID	fshdl,
    fhandle_t handle
    )
{
    NTSTATUS status;
    int sid;
    IO_STATUS_BLOCK ios[FsMaxNodes];

    FspInitAnswers(ios, NULL, NULL, 0);

    sid = SendRequest(FspFlush, (UserInfo_t *) fshdl,
			 (PVOID) &handle, sizeof(handle),
			 NULL, 0,
			 ios);
    status = ios[sid].Status;

    FsLog(("Flush %d err %x\n", handle, status));

    if (status == STATUS_PENDING) {
	status = STATUS_SUCCESS;
    }

    return RtlNtStatusToDosError(status);
}

DWORD
FsLock(PVOID fshdl, fhandle_t handle, ULONG offset, ULONG length, ULONG flags,
	       PVOID context)
{
    fs_lock_msg_t msg;
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (handle == INVALID_FHANDLE_T)
	return ERROR_INVALID_PARAMETER;

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.offset = offset;
    msg.length = length;
    msg.flags = flags;
    msg.fnum = handle;

    FsLog(("Lock fid %d off %d len %d\n", msg.fnum, offset, length));

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspLock, (UserInfo_t *) fshdl,
		      (PVOID)&msg, sizeof(msg),
		      NULL, 0,
		      status);

    err = status[sid].Status;

    FsLog(("Lock fid %d err %x\n", msg.fnum, err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsUnlock(PVOID fshdl, fhandle_t handle, ULONG offset, ULONG length)
{
    fs_lock_msg_t msg;
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (handle == INVALID_FHANDLE_T)
	return ERROR_INVALID_PARAMETER;

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.offset = offset;
    msg.length = length;
    msg.fnum = handle;

    FsLog(("Unlock fid %d off %d len %d\n", handle, offset, length));

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspUnlock, (UserInfo_t *) fshdl,
		      (PVOID)&msg, sizeof(msg),
		      NULL, 0,
		      status);

    err = status[sid].Status;

    return RtlNtStatusToDosError(err);
}

DWORD
FsStatFs(
    PVOID	fshdl,
    fs_attr_t* attr
    )
{
    DWORD err;
    IO_STATUS_BLOCK ios;

    if (!attr) return ERROR_INVALID_PARAMETER;

    err = SendReadRequest(FspStatFs, (UserInfo_t *) fshdl,
			  (PVOID) attr, sizeof(*attr),
			  NULL, 0,
			  &ios);

    err = ios.Status;

    return RtlNtStatusToDosError(err);
}


DWORD
FsGetRoot(PVOID fshdl, LPWSTR fullpath)
{
    DWORD err;
    IO_STATUS_BLOCK ios;

    if (!fullpath || !fshdl) return ERROR_INVALID_PARAMETER;

    // use local replica instead
    if ((((UserInfo_t *)fshdl)->VolInfo->FsCtx->Root)) {
	swprintf(fullpath, L"\\\\?\\%s\\%s",
		 (((UserInfo_t *)fshdl)->VolInfo->FsCtx->Root),
		 (((UserInfo_t *)fshdl)->VolInfo->Root));
	     
	FsLog(("FspGetRoot '%S'\n", fullpath));
	err = STATUS_SUCCESS;
    } else {
	err = SendReadRequest(FspGetRoot, (UserInfo_t *) fshdl,
			      NULL, 0,
			      (PVOID)fullpath, 0,
			      &ios);

	err = ios.Status;
    }

    return RtlNtStatusToDosError(err);
}

static FsDispatchTable gDisp = {
    0x100,
    FsCreate,
    FsLookup,
    FsSetAttr,
    FsSetAttr2,
    FsGetAttr,
    FsClose,
    FsWrite,
    FsRead,
    FsReadDir,
    FsStatFs,
    FsRemove,
    FsRename,
    FsMkDir,
    FsRemove,
    FsFlush,
    FsLock,
    FsUnlock,
    FsGetRoot
};
//////////////////////////////////////////////////////////////


DWORD
FsInit(PVOID resHdl, PVOID *Hdl)
{
    DWORD status;
    FsCtx_t	*ctx;

    // This should be a compile check instead of runtime check
    ASSERT(sizeof(fs_log_rec_t) == CRS_RECORD_SZ);
    ASSERT(sizeof(fs_log_rec_t) == sizeof(CrsRecord_t));

    if (Hdl == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    FsLog(("FsInit:\n"));

    // allocate a context
    ctx = (FsCtx_t *) MemAlloc(sizeof(*ctx));
    if (ctx == NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    // initialize configuration table and other global state
    memset(ctx, 0, sizeof(*ctx));

    // local path
    ctx->Root = NULL;

    LockInit(ctx->Lock);

    ctx->reshdl = resHdl;
    *Hdl = (PVOID) ctx;

    // we need to mount the IPC share now
    status = FsRegister((PVOID)ctx, L"IPC$", L"dummy", NULL, 0, &ctx->ipcHdl);
    if (status == ERROR_SUCCESS) {
	// Init. volume
	VolInfo_t	*vinfo = (VolInfo_t *)ctx->ipcHdl;
	
	ASSERT(vinfo != NULL);

	// use node zero
	vinfo->Fd[0] = INVALID_HANDLE_VALUE;
	vinfo->ReadSet = 0;
	vinfo->AliveSet = 0;
    } else {
	FsLog(("FsInit: failed to register ipc share %d\n", status));
	// free memory
	MemFree(ctx);
	*Hdl = NULL;
    }

    return status;
}

void
FspFreeSession(SessionInfo_t *s)
{
	
    UserInfo_t *u;
    int i, j;

    u = &s->TreeCtx;
    FsLog(("Session free uid %d tid %d ref %d\n", u->Uid, u->Tid, u->RefCnt));

    LockEnter(u->Lock);
    if (u->VolInfo != NULL) {
	UserInfo_t **p;
	VolInfo_t *v = u->VolInfo;

	LockExit(u->Lock);

	// remove from vollist now
	LockEnter(v->uLock);
	p = &v->UserList;
	while (*p != NULL) {
	    if (*p == u) {
		// found it
		*p = u->Next;
		FsLog(("Remove uinfo %x,%x from vol %x %S\n", u, u->Next, 
		       v->UserList, v->Root));
		break;
	    }
	    p = &(*p)->Next;
	}
	LockExit(v->uLock);

	// relock again
	LockEnter(u->Lock);
    }

    // Close all user handles
    for (i = 0; i < FsTableSize; i++) {
	if (u->Table[i].Flags) {
	    FsLog(("Close slot %d %x\n", i, u->Table[i].Flags));
	    FsClose((PVOID) u, (fhandle_t)i);
	}
    }

    // sap volptr
    u->VolInfo = NULL;

    LockExit(u->Lock);

    DeleteCriticalSection(&u->Lock);

    // free memory now, don't free u since it's part of s
    MemFree(s);
}

void
FspCloseVolume(VolInfo_t *vol, ULONG AliveSet)
{
    DWORD i;

    // clear arbitrate state now
    vol->Arbitrate.State = ARB_STATE_IDLE;

    // Close crs and root handles, by evicting our alive set
    //  close nid handles <crs, vol, open files>
    for (i = 0; i < FsMaxNodes; i++) {
	if (AliveSet & (1 << i)) {
	    if (vol->CrsHdl[i]) {
		CrsClose(vol->CrsHdl[i]);
		vol->CrsHdl[i] = NULL;
	    }
	    FindCloseChangeNotification(vol->NotifyFd[i]);
	    vol->NotifyFd[i] = INVALID_HANDLE_VALUE;
	    xFsClose(vol->Fd[i]);
	    vol->Fd[i] = INVALID_HANDLE_VALUE;
	    // need to close all user handles now
	    {
		UserInfo_t *u;

		for (u = vol->UserList; u; u = u->Next) {
		    DWORD j;
		    FsLog(("Lock user %x root %S\n", u, vol->Root));
		    LockEnter(u->Lock);

		    // close all handles for this node
		    for (j = 0; j < FsTableSize; j++) {
			if (u->Table[j].Fd[i] != INVALID_HANDLE_VALUE) {
			    FsLog(("Close fid %d\n", j));
			    xFsClose(u->Table[j].Fd[i]);
			    u->Table[j].Fd[i] = INVALID_HANDLE_VALUE;
			}
		    }
		    LockExit(u->Lock);
		    FsLog(("Unlock user %x\n", u));
		}
	    }
	}
    }

}


// call this when we are deleting resource and we need to get ride of
// our IPC reference to directory
void
FsEnd(PVOID Hdl)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    VolInfo_t	*p;	

    if (!ctx)
	return;

    LockEnter(ctx->Lock);

    p = (VolInfo_t *)ctx->ipcHdl;
    if (p) {
	xFsClose(p->Fd[0]);
	p->Fd[0] = INVALID_HANDLE_VALUE;
	p->ReadSet = 0;
	p->AliveSet = 0;
    }

    LockExit(ctx->Lock);
	
}

void
FsExit(PVOID Hdl)
{
    // flush all state
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    VolInfo_t	*p;
    SessionInfo_t *s;
    LogonInfo_t	*log;

    LockEnter(ctx->Lock);
    while (s = ctx->SessionList) {
	ctx->SessionList = s->Next;
	// free this session now
	FspFreeSession(s);
    }
    
    while (p = ctx->VolList) {
	ctx->VolList = p->Next;
	ctx->VolListSz--;
	// free this volume now
	FspCloseVolume(p, p->AliveSet);
	MemFree(p);
    }

    while (log = ctx->LogonList) {
	ctx->LogonList = log->Next;
	// free token
	CloseHandle(log->Token);
	MemFree(log);
    }

    // now we free our structure
    LockExit(ctx->Lock);
    MemFree(ctx);
}

// adds a new share to list of trees available
DWORD
FsRegister(PVOID Hdl, LPWSTR root, LPWSTR share,
	   LPWSTR disklist[], DWORD len, PVOID *vHdl)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    VolInfo_t	*p;

    // check limit
    if (len >= FsMaxNodes) {
	return ERROR_TOO_MANY_NAMES;
    }

    if (root == NULL || share == NULL || (wcslen(share) > (MAX_PATH - 5))) {
	return ERROR_INVALID_PARAMETER;
    }


    // add a new volume to the list of volume. path is an array
    // of directories. Note: The order of this list MUST be the
    // same in all nodes since it also determines the disk id

    // this is a simple check and assume one thread is calling this function
    LockEnter(ctx->Lock);

    // update our ipc context
    if (ctx->ipcHdl) {
	NTSTATUS status;
	UINT32 disp = FILE_OPEN;
	HANDLE vfd;
	WCHAR	path[MAX_PATH];

	p = (VolInfo_t *)ctx->ipcHdl;
	if (p->Fd[0] != INVALID_HANDLE_VALUE)
	    xFsClose(p->Fd[0]);
	p->Fd[0] = INVALID_HANDLE_VALUE;
	p->ReadSet = 0;
	p->AliveSet = 0;

	// set local path
	ctx->Root = share;

	// update our ipc handle now
	FsLog(("FsRegister: ipc share '%S'\n", share));

	// open our local ipc path
	wcscpy(path, L"\\??\\");
	wcscat(path, share);
	wcscat(path, L"\\");

	status = xFsCreate(&vfd, NULL, path, wcslen(path),
			   FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
			   0,
			   FILE_SHARE_READ|FILE_SHARE_WRITE,
			   &disp,
			   FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
			   NULL, 0);

	if (status == STATUS_SUCCESS) {

	    // our root must have already been created and secured.
	    ASSERT(disp != FILE_CREATED);

	    // use node zero
	    p->Fd[0] = vfd;
	    p->ReadSet = 0x1;
	    p->AliveSet = 0x1;

	} else {
	    FsLog(("Fsregister: '%S' failed to open %x\n", share, status));
	    LockExit(ctx->Lock);
	    return RtlNtStatusToDosError(status);
	}
    }

    // find the volume share
    for (p = ctx->VolList; p != NULL; p = p->Next) {
	if (!wcscmp(root, p->Root)) {
	    LockEnter(p->uLock);
	    break;
	}
    }
    LockExit(ctx->Lock);

    if (p == NULL) {
	p = (VolInfo_t *)MemAlloc(sizeof(*p));
	if (p == NULL) {
	    return ERROR_NOT_ENOUGH_MEMORY;
	}

	memset(p, 0, sizeof(*p));

	LockInit(p->uLock);
	LockInit(p->qLock);
	// We don't need to walk the list again to check if a register has happened because
	// this is serialized in nodequorum.c

	LockEnter(ctx->Lock);
	p->Tid = (USHORT)++ctx->VolListSz;
	p->Next = ctx->VolList;
	ctx->VolList = p;
	p->FsCtx = ctx;

	// lock the volume
	LockEnter(p->uLock);

	LockExit(ctx->Lock);

	p->Label = L"Cluster Quorum";

    }

    p->Root = root;
    if (disklist) {
	DWORD i;

	for (i = 1; i < FsMaxNodes; i++)
	    p->DiskList[i] = disklist[i];
    }
    p->DiskListSz = len;


    FsLog(("FsRegister Tid %d Share '%S' %d disks\n", p->Tid, root, len));

    // drop the volume lock
    LockExit(p->uLock);

    *vHdl = (PVOID) p;

    return ERROR_SUCCESS;
}

SessionInfo_t *
FspAllocateSession()
{
    SessionInfo_t *s;
    UserInfo_t	*u;
    int i;

    // add user to our tree and initialize handle tables
    s = (SessionInfo_t *)MemAlloc(sizeof(*s));
    if (s != NULL) {
	memset(s, 0, sizeof(*s));

	u = &s->TreeCtx;
	LockInit(u->Lock);

	// init handle table
	for (i = 0; i < FsTableSize; i++) {
	    int j;
	    for (j = 0; j < FsMaxNodes; j++) {
		FS_SET_USER_HANDLE(u, j, i, INVALID_HANDLE_VALUE);
	    }
	}
    }

    return s;
}

// binds a session to a specific tree/share
DWORD
FsMount(PVOID Hdl, LPWSTR root_name, USHORT uid, USHORT *tid)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    SessionInfo_t *s = NULL, *ns;
    VolInfo_t	*p;
    DWORD	err = ERROR_SUCCESS;


    *tid = 0;

    // allocate new ns
    ns = FspAllocateSession();
    if (ns == NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    LockEnter(ctx->Lock);
    // locate share
    for (p = ctx->VolList; p != NULL; p = p->Next) {
	if (!_wcsicmp(root_name, p->Root)) {
	    FsLog(("Mount share '%S' tid %d\n", p->Root, p->Tid));
	    break;
	}
    }

    if (p != NULL) {

	*tid = p->Tid;

	for (s = ctx->SessionList; s != NULL; s = s->Next) {
	    if (s->TreeCtx.Uid == uid && s->TreeCtx.Tid == p->Tid) {
		break;
	    }
	}

	if (s == NULL) {
	    UserInfo_t *u = &ns->TreeCtx;

	    // insert into session list
	    ns->Next = ctx->SessionList;
	    ctx->SessionList = ns;
	    
	    FsLog(("Bind uid %d -> tid %d <%x,%x>\n", uid, p->Tid,
		   u, p->UserList));

	    u->RefCnt++;
	    u->Uid = uid;
	    u->Tid = p->Tid;
	    u->VolInfo = p;
	    // insert user_info into volume list
	    LockEnter(p->uLock);
	    FsLog(("Add <%x,%x>\n",    u, p->UserList));
	    u->Next = p->UserList;
	    p->UserList = u;
	    LockExit(p->uLock);
	} else {
	    // we already have this session opened, increment refcnt
	    s->TreeCtx.RefCnt++;
	    // free ns
	    MemFree(ns);
	}
    } else {
	err = ERROR_BAD_NET_NAME;
    }

    LockExit(ctx->Lock);

    return (err);
}

// This function is also a CloseSession
void
FsDisMount(PVOID Hdl, USHORT uid, USHORT tid)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    SessionInfo_t *s, **last;

    // lookup tree and close all user handles
    s = NULL;
    LockEnter(ctx->Lock);

    last = &ctx->SessionList;
    while (*last != NULL) {
	UserInfo_t *u = &(*last)->TreeCtx;
	if (u->Uid == uid && u->Tid == tid) {
	    ASSERT(u->RefCnt > 0);
	    u->RefCnt--;
	    if (u->RefCnt == 0) {
		FsLog(("Dismount uid %d tid %d <%x,%x>\n", uid, tid,
		       u, *last));
		s = *last;
		*last = s->Next;
	    }
	    break;
	}
	last = &(*last)->Next;
    }
    LockExit(ctx->Lock);
    if (s != NULL) {
	FspFreeSession(s);
    }
}

// todo: I am not using the token for now, but need to use it for all
// io operations
DWORD
FsLogonUser(PVOID Hdl, HANDLE token, LUID logonid, USHORT *uid)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    LogonInfo_t *s;
    int i;

    // add user to our tree and initialize handle tables
    s = (LogonInfo_t *)MemAlloc(sizeof(*s));
    if (s == NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(s, 0, sizeof(*s));

    s->Token = token;
    s->LogOnId = logonid;

    LockEnter(ctx->Lock);
    s->Next = ctx->LogonList;
    ctx->LogonList = s;
    LockExit(ctx->Lock);

    *uid = (USHORT) logonid.LowPart; 
    FsLog(("Logon %d,%d, uid %d\n", logonid.HighPart, logonid.LowPart, *uid));

    return (ERROR_SUCCESS);

}

void
FsLogoffUser(PVOID Hdl, LUID logonid)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    LogonInfo_t *s;
    USHORT	uid;

    LockEnter(ctx->Lock);
    for (s = ctx->LogonList; s != NULL; s = s->Next) {
	if (s->LogOnId.LowPart == logonid.LowPart &&
	    s->LogOnId.HighPart == logonid.HighPart) {
	    uid = (USHORT) logonid.LowPart;
	    break;
	}
    }
    if (s != NULL) {
	SessionInfo_t 	**last;

	FsLog(("Logoff user %d\n", uid));

	// Flush all user trees
	last = &ctx->SessionList;
	while (*last != NULL) {
	    UserInfo_t *u = &(*last)->TreeCtx;
	    if (u->Uid == uid) {
		SessionInfo_t *ss = *last;
		// remove session and free it now
		*last = ss->Next;
		FspFreeSession(ss);
	    } else {
		last = &(*last)->Next;
	    }
	}
    }

    LockExit(ctx->Lock);
}



FsDispatchTable* 
FsGetHandle(PVOID Hdl, USHORT tid, USHORT uid, PVOID *fshdl)
{
    FsCtx_t	*ctx = (FsCtx_t *) Hdl;
    SessionInfo_t *s;

    // locate tid,uid in session list
    LockEnter(ctx->Lock);
    for (s = ctx->SessionList; s != NULL; s = s->Next) {
	if (s->TreeCtx.Uid == uid && s->TreeCtx.Tid == tid) {
	    *fshdl = (PVOID *) &s->TreeCtx;
	    LockExit(ctx->Lock);
	    return &gDisp;
	}
    }

    LockExit(ctx->Lock);

    *fshdl = NULL;
    return NULL;
}

//////////////////////////////////// Arb/Release ///////////////////////////////

DWORD
FspOpenReplica(VolInfo_t *p, DWORD id, HANDLE *CrsHdl, HANDLE *Fd, HANDLE *notifyFd,
	       FspArbitrate_t *arb)
{
    WCHAR	path[MAXPATH];
    UINT32 disp = FILE_OPEN_IF;
    NTSTATUS	err;

    swprintf(path, L"\\\\?\\%s\\crs.log", p->DiskList[id]);
    err = CrsOpen(FsCrsCallback, (PVOID) p, (USHORT)id,
		  path, FsCrsNumSectors,
		  CrsHdl);

    if (err == ERROR_SUCCESS && CrsHdl != NULL) {
	// got it
	// open root volume directory
	swprintf(path, L"\\??\\%s\\%s\\", p->DiskList[id], p->Root);
	err = xFsCreate(Fd, NULL, path, wcslen(path),
			FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
			0,
			FILE_SHARE_READ|FILE_SHARE_WRITE,
			&disp,
			FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
			NULL, 0);

	if (err == STATUS_SUCCESS) {
	    // check if we are part of arb.
	    if (arb != NULL) {
		// get quorum lock
		LockEnter(p->qLock);
		if (arb->State == ARB_STATE_BUSY) {
		    arb->Count++;
		    arb->Set |= (1 << id);
		    if (arb->Event && CRS_QUORUM(arb->Count, p->DiskListSz)) {
			// first time only
			SetEvent(arb->Event);
			arb->Event = NULL;
		    }
		    // note it is safe to touch this because our parent thread already 
		    // locked the updates out and is wait for us to finish
		    p->Fd[id] = *Fd;
		    ASSERT(p->CrsHdl[id] == NULL);
		    p->CrsHdl[id] = *CrsHdl;
		    LockExit(p->qLock);
		    FsLog(("Add Replica %d\n", id));
		} else {
		    LockExit(p->qLock);
		    FsLog(("Stale open %d\n", id));
		    CrsClose(*CrsHdl);
		    xFsClose(*Fd);
		    err = ERROR_SEM_TIMEOUT;
		}
	    }
	    
	    if (err == ERROR_SUCCESS) {
		FsArbLog(("Mounted %S\n", path));
		swprintf(path, L"\\\\?\\%s\\", p->DiskList[id]);

		// scan the tree to break any current oplocks on dead nodes
		xFsTouchTree(*Fd);

		// we now queue notification changes to force srv to contact client
		*notifyFd = FindFirstChangeNotificationW(path, FALSE, FILE_NOTIFY_CHANGE_EA);
		// if part of arb, set it now
		if (arb != NULL) {
		    p->NotifyFd[id] = *notifyFd;
		}
		if (*notifyFd != INVALID_HANDLE_VALUE) {
		    int i;

		    for (i = 0; i < FsMaxNodes; i++) {
			FindNextChangeNotification(*notifyFd);
		    }
		} else {
		    FsArbLog(("Failed to register notification %d\n", GetLastError()));
		}
	    }
	} else {
	    FsArbLog(("Failed to mount root '%S' %x\n", path, err));
	    // close CrsHandle
	    CrsClose(*CrsHdl);
	}
    } else if (err == ERROR_LOCK_VIOLATION || err == ERROR_SHARING_VIOLATION) {
	FsArbLog(("Replica '%S' already locked\n", path));
    } else {
	FsArbLog(("Replica '%S' probe failed %d\n", path, err));
    }

    return err;
}

typedef struct {
    VolInfo_t   *vol;
    DWORD	id;
}FspProbeReplicaId_t;

DWORD WINAPI
ProbeThread(LPVOID arg)
{
    FspProbeReplicaId_t *probe = (FspProbeReplicaId_t *) arg;
    DWORD	i = probe->id;
    VolInfo_t *p = probe->vol;
    FspArbitrate_t *arb = &p->Arbitrate;
    NTSTATUS	err;
    HANDLE	crshdl, fshdl, notifyhdl;
    DWORD	retry_cnt;

    // set our priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    for (retry_cnt = 0; retry_cnt < 8; retry_cnt++) {
	err = FspOpenReplica(p, i, &crshdl, &fshdl, &notifyhdl, arb);

	if (err == ERROR_SUCCESS) {
	    // got it, we are done
	    break;
	}

	// handle error
	if (err == ERROR_BAD_NETPATH || err == ERROR_REM_NOT_LIST || err == ERROR_SEM_TIMEOUT) {
	    // don't retry just bail out now
	    break;
	} else { 
	    BOOLEAN flag = FALSE;

	    // we try again as long as we are not cancelled and no quorum is reached
	    LockEnter(p->qLock);
	    if (arb->State == ARB_STATE_BUSY && !CRS_QUORUM(arb->Count, p->DiskListSz)) {
		flag = TRUE;
	    }
	    // drop lock
	    LockExit(p->qLock);

	    // if cancelled we are out of here
	    if (flag == FALSE)
		break;

	    // retry in 5 seconds again
	    Sleep(5 * 1000);
	}
    }

    return 0;
}

ULONG
FspFindMissingReplicas(VolInfo_t *p, ULONG set)

{
    ULONG FoundSet = 0;
    DWORD i, err;
    HANDLE crshdl, fshdl, notifyfd;

    if (set == 0)
	return 0;

    for (i = 1; i < FsMaxNodes; i++) {
	if (p->DiskList[i] == NULL)
	    continue;
	
	if (!(set & (1 << i))) {
	    // drop the lock
	    LockExit(p->uLock);

	    err = FspOpenReplica(p, i, &crshdl, &fshdl, &notifyfd, NULL);

	    // get the lock
	    LockEnter(p->uLock);

	    if (err == STATUS_SUCCESS) {
		if (p->CrsHdl[i] == NULL) {
		    p->NotifyFd[i] = notifyfd;
		    p->Fd[i] = fshdl;
		    p->CrsHdl[i] = crshdl;
		    FoundSet |= (1 << i);
		} else {
		    // someone beat us to it, close ours
		    CrsClose(crshdl);
		    xFsClose(fshdl);
		    FindCloseChangeNotification(notifyfd);
		}
	    }
	}
    }
    if (FoundSet != 0)
	FsArbLog(("New replica set after probe %x\n", FoundSet));

    return FoundSet;
}


DWORD WINAPI
FspArbitrateThread(LPVOID arg)
{
    VolInfo_t *p = (VolInfo_t *) arg;
    FspArbitrate_t *arb = &p->Arbitrate;
    HANDLE hdl[FsMaxNodes];
    DWORD	i, count = 0, err;
    ULONG	ReplicaSet;
    DWORD	Sequence;
    FspProbeReplicaId_t Ids[FsMaxNodes];
    FspProbeReplicaId_t *r;
    BOOLEAN flag;

    // set our priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    // if we arb then no update can be going on now
    LockEnter(p->uLock);

    // our parent already stored this for us here
    ReplicaSet = arb->Set;
    arb->Set = 0;

    FsArbLog(("ArbitrateThread begin %x\n", ReplicaSet));

    // we now start a thread for each replica and do the probe in parallel
    for (i = 1; i < FsMaxNodes; i++) {
	if (p->DiskList[i] == NULL)
	    continue;

	if (ReplicaSet & (1 << i)) 
	    continue;

	r = &Ids[i];

	r->vol = p;
	r->id = i;

	hdl[count] = CreateThread(NULL, 0, &ProbeThread, (LPVOID) r, 0, NULL);
	if (hdl[count] != NULL) {
	    count++;
	} else {
	    FsArbLog(("Unable to create thread to probe replica %d\n", i));
	    ProbeThread((LPVOID) r);
	}
    }

    // we now wait
    WaitForMultipleObjects(count, hdl, TRUE, INFINITE);

    // Close the handles
    for (i = 0; i < count; i++)
	CloseHandle(hdl[i]);

    flag = FALSE;
    // grab lock
    LockEnter(p->qLock);
    if (arb->State != ARB_STATE_BUSY) {
	flag = TRUE;
    }
    LockExit(p->qLock);

    if (flag == TRUE) {
	// we got cancelled, we undo what we just did and get out
	if (arb->Set) {
	    // tell evict this not part of alive set
	    FspEvict(p, arb->Set, FALSE);
	}
	err = ERROR_CANCELLED;
	goto exit;
    }

    count = arb->Count;
    ReplicaSet = arb->Set;

    FsArbLog(("ArbitrateThread working %x\n", ReplicaSet));

    p->WriteSet = p->ReadSet = 0;
    // check if we have a majority
    if (CRS_QUORUM(count, p->DiskListSz)) {

	FsArbLog(("I own quorum %d,%d set %x\n",count, p->DiskListSz, ReplicaSet));

	// we need to join crs replicas
	FspJoin(p, ReplicaSet);
	    
	if (p->WriteSet != 0 || p->ReadSet != 0) {
		// remember event to signal if we lose quorum again
	    p->Event = arb->Event;
	    err = ERROR_SUCCESS;
	} else {
	    // we lost the quorum
	    err = ERROR_WRITE_PROTECT;
	}

    } else {
	FspEvict(p, ReplicaSet, FALSE);
	err = ERROR_PATH_NOT_FOUND;
    }

 exit:
    // clear the arb state
    arb->State = ARB_STATE_IDLE;

    // unlock volume
    LockExit(p->uLock);

    return err;
}

DWORD
FsIsQuorum(PVOID vHdl)
{

    VolInfo_t *p = (VolInfo_t *)vHdl;
    DWORD err = ERROR_INVALID_PARAMETER, count;

    if (p) {

	// Read write and avail sets. If we have a majority
	// in avail set and wset is zero, we return pending.
	// if wset is non-zero we return success, otherwise
	// return failure

	LockEnter(p->qLock);
	if (p->Arbitrate.State == ARB_STATE_BUSY) {
	    count = p->Arbitrate.Count;
	} else {
	    ULONG mask = p->AliveSet;
	    count = 0;
	    for (mask = p->AliveSet; mask ; mask = mask >> 1) {
		if (mask & 0x1) {
		    count++;
		}
	    }
	}

	if (CRS_QUORUM(count, p->DiskListSz))
	    err = ERROR_SUCCESS;
	else
	    err = ERROR_BUSY;

	LockExit(p->qLock);
    }

    return err;

}

DWORD
FsArbitrate(PVOID vHdl, HANDLE event, HANDLE *wait_event)
{
    VolInfo_t *p = (VolInfo_t *)vHdl;
    NTSTATUS err;
    HANDLE hdl;

    if (p) {
	FspArbitrate_t *arb;

	// lock volume
	LockEnter(p->qLock);

	arb = &p->Arbitrate;

	if (p->AliveSet != 0) {
	    // we must have already arb. before, just bail out
	    LockExit(p->qLock);
	    return ERROR_SUCCESS;
	}

	if (arb->State == ARB_STATE_CANCEL) {
	    // there is already a pending arb, just return busy
	    LockExit(p->qLock);
	    return ERROR_CANCELLED;
	}

	if (arb->State == ARB_STATE_BUSY) {
	    // report current status
	    if (CRS_QUORUM(p->Arbitrate.Count, p->DiskListSz))
		err = ERROR_SUCCESS;
	    else
		err = ERROR_PATH_BUSY;
	    LockExit(p->qLock);
	    return err;
	}

	ASSERT(arb->State == ARB_STATE_IDLE);

	arb->State = ARB_STATE_BUSY;
	arb->Event = event;
	arb->Set = p->AliveSet; // store alive set here
	arb->Count = 0;

	FsArbLog(("FsArb: queueing thread\n"));

	// clear event
	ResetEvent(event);

	// drop lock
	LockExit(p->qLock);

	// we start a thread to do the arbitrate and return pending
	hdl = CreateThread(NULL, 0, &FspArbitrateThread, (LPVOID) p, 0, NULL);
	if (hdl != NULL) {
	    if (*wait_event != NULL) {
		CloseHandle(*wait_event);
	    }
	    *wait_event = hdl;
	    err = ERROR_IO_PENDING;
	} else {
	    // clear the state, no need for a lock here
	    arb->State = ARB_STATE_IDLE;
	    FsLogError(("FsArb: failed %d queueing thread\n", GetLastError()));
	    err = ERROR_INVALID_PARAMETER;
	}
    } else {
	err = ERROR_INVALID_PARAMETER;
    }

    return err;
}

DWORD
FsCancelArbitration(PVOID vHdl)

{
    VolInfo_t *p = (VolInfo_t *)vHdl;
    FspArbitrate_t *arb;
    DWORD	err = ERROR_INVALID_PARAMETER;

    if (p != NULL) {
	LockEnter(p->qLock);
	arb = &p->Arbitrate;
	if (arb->State == ARB_STATE_BUSY) {
	    // check if we already got quorum
	    if (CRS_QUORUM(arb->Count, p->DiskListSz)) {
		arb->Event = NULL; // no need to signal it
		err = ERROR_SUCCESS;
	    } else {
		FsArbLog(("FsCancelArbitration\n"));
		arb->State = ARB_STATE_CANCEL;
		err = ERROR_CANCELLED;
	    }
	} else if (arb->State == ARB_STATE_IDLE) {
	    // we might already have quorum
	    err = (p->AliveSet) ? ERROR_SUCCESS : ERROR_CANCELLED;
	} else {
	    err = ERROR_SUCCESS;
	}
	LockExit(p->qLock);
    }

    return err;
}

DWORD
FsRelease(PVOID vHdl)
{
    DWORD i;
    VolInfo_t *p = (VolInfo_t *)vHdl;
    NTSTATUS err;

    if (p) {
	ULONG	set;
	// lock volume
	LockEnter(p->uLock);

	LockEnter(p->qLock);
	set = p->AliveSet;
	p->AliveSet = 0;
	p->Event = 0;
	LockExit(p->qLock);

	FsArbLog(("FsRelease %S AliveSet %x\n", p->Root, set));

	FspCloseVolume(p, set);
	p->WriteSet = 0;
	p->ReadSet = 0;

	FsArbLog(("FsRelease %S done\n", p->Root));

	// unlock volume
	LockExit(p->uLock);

	err = ERROR_SUCCESS;

    } else {
	err = ERROR_INVALID_PARAMETER;
    }


    return err;
}

DWORD
FsReserve(PVOID vhdl)
{
    VolInfo_t *p = (VolInfo_t *)vhdl;
    NTSTATUS err;

    // check if there is a new replica online
    if (p) {
	ULONG ReplicaSet;

	LockEnter(p->qLock);
	if (p->Arbitrate.State != ARB_STATE_IDLE) {
	    // we are busy, just return success
	    LockExit(p->qLock);
	    return ERROR_SUCCESS;
	}
	ReplicaSet = p->AliveSet;
	// drop lock now
	LockExit(p->qLock);

	// get update lock, do a try only if we can't do bother and try again latter
	if (!LockTryEnter(p->uLock))
	    return ERROR_SUCCESS;

	ReplicaSet = FspFindMissingReplicas(p, ReplicaSet);

	// we found new disks
	if (ReplicaSet > 0) {
	    // Add new finds
	    FspJoin(p, ReplicaSet);
	}
	LockExit(p->uLock);
    }

    if (p) {
	// check each crs handle to be valid
	IO_STATUS_BLOCK ios[FsMaxNodes];
	DWORD sid;

	FspInitAnswers(ios, NULL, NULL, 0);

	sid = SendAvailRequest(FspCheckFs, p, NULL,
			  NULL, 0, NULL, 0, ios);


	if (ios[sid].Status == STATUS_MEDIA_WRITE_PROTECTED &&
	    ios[sid].Information > 0)
	    err = ERROR_SUCCESS;
	else
	    err = RtlNtStatusToDosError(ios[sid].Status);

    } else {
	err = ERROR_INVALID_PARAMETER;
    }


    if (err != ERROR_SUCCESS)
	FsLogError(("FsReserve vol '%x' failed 0x%x\n", p, err));


    return err;

}


DWORD
FsIsOnline(PVOID vHdl)
{
    
    VolInfo_t *p = (VolInfo_t *)vHdl;
    DWORD err = ERROR_INVALID_PARAMETER, count;

    if (p) {

	// Read write and avail sets. If we have a majority
	// in avail set and wset is zero, we return pending.
	// if wset is non-zero we return success, otherwise
	// return failure

	LockEnter(p->uLock);
	ASSERT(p->DiskListSz != (DWORD)-1);
	if (p->WriteSet > 0 || p->ReadSet > 0)
	    err = ERROR_SUCCESS;
	else {
	    LockEnter(p->qLock);
	    if (p->Arbitrate.State == ARB_STATE_BUSY)
		err = ERROR_IO_PENDING;
	    else {
		ULONG mask = p->AliveSet;
		count = 0;
		for (mask = p->AliveSet; mask ; mask = mask >> 1) {
		    if (mask & 0x1) {
			count++;
		    }
		}
		if (CRS_QUORUM(count, p->DiskListSz) || count > 0)
		    err = ERROR_IO_PENDING;
		else
		    err = ERROR_BUSY;
	    }
	    LockExit(p->qLock);
	}
	LockExit(p->uLock);
    }

    return err;
}


DWORD
FsUpdateReplicaSet(PVOID vhdl, LPWSTR new_path[], DWORD new_len)
{
    VolInfo_t *p = (VolInfo_t *)vhdl;
    NTSTATUS err;
    DWORD	i, j;
    ULONG	evict_mask, add_mask;

    if (p == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    if (new_len >= FsMaxNodes) {
	return ERROR_TOO_MANY_NAMES;
    }

    LockEnter(p->uLock);

    // Find which current replicas are in the new set, and keep them
    // We skip the IPC share, since it's local
    evict_mask = 0;
    for (j=1; j < FsMaxNodes; j++) {
	BOOLEAN found;
	if (p->DiskList[j] == NULL)
	    continue;
	found = FALSE;
	for (i=1; i < FsMaxNodes; i++) {
	    if (new_path[i] != NULL && wcscmp(new_path[i], p->DiskList[j]) == 0) {
		// keep this replica
		found = TRUE;
		break;
	    }
	}
	if (found == FALSE) {
	    // This replica is evicted from the new set, add to evict set mask
	    evict_mask |= (1 << j);
	    FsArbLog(("FsUpdateReplicaSet evict replica # %d '%S' set 0x%x\n",
		   j, p->DiskList[j], evict_mask));
	}
    }

    // At this point we have all the replicas in the current and new sets. We now need
    // to find replicas that are in the new set but missing from current set.
    add_mask = 0;
    for (i=1; i < FsMaxNodes; i++) {
	BOOLEAN found;
	if (new_path[i] == NULL)
	    continue;
	found = FALSE;
	for (j=1; j < FsMaxNodes; j++) {
	    if (p->DiskList[j] != NULL && wcscmp(new_path[i], p->DiskList[j]) == 0) {
		// keep this replica
		found = TRUE;
		break;
	    }
	}
	if (found == FALSE) {
	    add_mask |= (1 << i);
	    FsArbLog(("FsUpdateReplicaSet adding replica # %d '%S' set 0x%x\n",
		   i, new_path[i], add_mask));
	}
    }

    // we now update our disklist with new disklist
    for (i = 1; i < FsMaxNodes; i++) {
	if ((evict_mask & 1 << i) || (add_mask & (1 << i)))
	    FsArbLog(("FsUpdateReplicat %d: %S -> %S\n",
		   i, p->DiskList[i], new_path[i]));
	p->DiskList[i] = new_path[i];
    }
    p->DiskListSz = new_len;

    // If we are alive, apply changes
    if (p->WriteSet != 0 || p->ReadSet != 0) {
	// At this point we evict old replicas
	if (evict_mask != 0)
	    FspEvict(p, evict_mask, TRUE);

	// check if there is a new replica online
	if (add_mask > 0) {
	    ULONG ReplicaSet = 0;

	    // try to get the lock
	    if (LockTryEnter(p->qLock)) {
		ReplicaSet = p->AliveSet;
		LockExit(p->qLock);
	    }
	    ReplicaSet = FspFindMissingReplicas(p, ReplicaSet);

	    // we found new disks
	    if (ReplicaSet > 0) {
		FspJoin(p, ReplicaSet);
	    }
	}
    }

    LockExit(p->uLock);


    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\lkquorum\lkquorum.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    LkQuorum.c

Abstract:

    Resource DLL for Local Quorum

Author:

	Sivaprasad Padisetty (sivapad) April 21, 1997

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
//
// Type and constant definitions.
//

#define MAX_RETRIES 20

#define DBG_PRINT printf

// ADDPARAM: Add new parameters here.
#define PARAM_NAME__PATH L"Path"
#define PARAM_NAME__DEBUG L"Debug"

// ADDPARAM: Add new parameters here.
typedef struct _LKQUORUM_PARAMS {
    PWSTR           Path;
    DWORD           Debug;
} LKQUORUM_PARAMS, *PLKQUORUM_PARAMS;

typedef struct _LKQUORUM_RESOURCE {
    RESID                   ResId; // for validation
    LKQUORUM_PARAMS         Params;
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    CLUSTER_RESOURCE_STATE  State;
} LKQUORUM_RESOURCE, *PLKQUORUM_RESOURCE;


//
// Global data.
//

WCHAR   LkQuorumDefaultPath[MAX_PATH]=L"%SystemRoot%\\cluster";
//
// Local Quorum resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
LkQuorumResourcePrivateProperties[] = {
    { PARAM_NAME__PATH, NULL, CLUSPROP_FORMAT_SZ, 
      (DWORD_PTR) LkQuorumDefaultPath, 0, 0, 0, 
      FIELD_OFFSET(LKQUORUM_PARAMS,Path) },
    { PARAM_NAME__DEBUG, NULL, CLUSPROP_FORMAT_DWORD, 
      0, 0, 1, 0,
      FIELD_OFFSET(LKQUORUM_PARAMS,Debug) },           
    { 0 }
};


#ifdef OLD 
// Event Logging routine.

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

#else

#define g_LogEvent ClusResLogEvent

#endif

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_LkQuorumFunctionTable;

//
// Function prototypes.
//

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

RESID
WINAPI
LkQuorumOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
LkQuorumClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
LkQuorumOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );


DWORD
WINAPI
LkQuorumOffline(
    IN RESID ResourceId
    );

VOID
WINAPI
LkQuorumTerminate(
    IN RESID ResourceId
    );

DWORD
LkQuorumDoTerminate(
    IN PLKQUORUM_RESOURCE ResourceEntry
    );

BOOL
WINAPI
LkQuorumLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
LkQuorumIsAlive(
    IN RESID ResourceId
    );

BOOL
LkQuorumCheckIsAlive(
    IN PLKQUORUM_RESOURCE ResourceEntry
    );

DWORD
WINAPI
LkQuorumResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
LkQuorumGetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
LkQuorumValidatePrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PLKQUORUM_PARAMS Params
    );

DWORD
LkQuorumSetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


DWORD
LkQuorumGetDiskInfo(
    IN LPWSTR  lpszPath,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    ) ;


BOOLEAN
LkQuorumInit(
    VOID
    )
{
    return(TRUE);
}


BOOLEAN
WINAPI
LkQuorumDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !LkQuorumInit() ) {
            return(FALSE);
        }
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return(TRUE);

} // LkQuorumDllEntryPoint

DWORD BreakIntoDebugger (LPCWSTR) ;

#ifdef OLD

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_LkQuorumFunctionTable;

    return(ERROR_SUCCESS);

} // Startup

#endif


RESID
WINAPI
LkQuorumOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Local Quourm resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        LkQuorumStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;
    PLKQUORUM_RESOURCE  resourceEntry = NULL;
    DWORD               dwStrLen = 0;
    DWORD               dwSubStrLen = 0;
    LPWSTR              lpszNameofPropInError;
    
    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                   L"Parameters",
                                   KEY_READ,
                                   &parametersKey);

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }


    //
    // Allocate a resource entry.
    //

    resourceEntry = (PLKQUORUM_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(LKQUORUM_RESOURCE) );

    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry..
    //

    ZeroMemory( resourceEntry, sizeof(LKQUORUM_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;

    //
    // Read the resource's properties.
    //
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ParametersKey,
                                                   LkQuorumResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &lpszNameofPropInError );
                                                   
    if (status != ERROR_SUCCESS)
    {
        (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to read the parameter lock\n");
        goto exit;
    }

    //
    // Startup for the resource.
    //
    resid = (RESID)resourceEntry;

exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resourceEntry != NULL ) {
            LocalFree( resourceEntry );
        }
    }

    SetLastError( status );
    return(resid);

} // LkQuorumOpen



VOID
WINAPI
LkQuorumClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Local Quourm resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    PLKQUORUM_RESOURCE resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif

    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new parameters here.
    LocalFree( resourceEntry->Params.Path );

    LocalFree( resourceEntry );
} // LkQuorumClose



DWORD
WINAPI
LkQuorumOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Local Quourm resources.

    Bring the specified resource online (available for use). 

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    Win32 error code - The operation failed.

--*/

{
    PLKQUORUM_RESOURCE  resourceEntry = NULL;
    DWORD               status = ERROR_SUCCESS;
    LPWSTR              lpszNameofPropInError;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Read the resource's properties.
    //
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ParametersKey,
                                                   LkQuorumResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &lpszNameofPropInError );
                                                   
    if (status != ERROR_SUCCESS)
    {
        (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to read the parameter lock\n");
        return( status );
    }
    
#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOnline;

    return(status);

} // LkQuorumOnline



DWORD
WINAPI
LkQuorumOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Local Quourm resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    PLKQUORUM_RESOURCE resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Offline request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif

    // TODO: Offline code

    // NOTE: Offline should try to shut the resource down gracefully, whereas
    // Terminate must shut the resource down immediately. If there are no
    // differences between a graceful shut down and an immediate shut down,
    // Terminate can be called for Offline, as it is below.  However, if there
    // are differences, replace the call to Terminate below with your graceful
    // shutdown code.

    //
    // Terminate the resource.
    //

    LkQuorumDoTerminate( resourceEntry );

    return ERROR_SUCCESS ;

} // LkQuorumOffline



VOID
WINAPI
LkQuorumTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Local Quourm resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    PLKQUORUM_RESOURCE resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Terminate request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    //
    // Terminate the resource.
    //
    LkQuorumDoTerminate( resourceEntry );

} // LkQuorumTerminate



DWORD
LkQuorumDoTerminate(
    IN PLKQUORUM_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for Local Quourm resources.

Arguments:

    ResourceEntry - Supplies resource entry for resource to be terminated

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;

    ResourceEntry->State = ClusterResourceOffline;

    return(status);

} // LkQuorumDoTerminate



BOOL
WINAPI
LkQuorumLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Local Quourm resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PLKQUORUM_RESOURCE  resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("LkQuorum: LooksAlive request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    return(LkQuorumCheckIsAlive( resourceEntry ));

} // LkQuorumLooksAlive



BOOL
WINAPI
LkQuorumIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Local Quourm resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PLKQUORUM_RESOURCE  resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("LkQuorum: IsAlive request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    //
    // Check to see if the resource is alive.
    //
    return(LkQuorumCheckIsAlive( resourceEntry ));

} // LkQuorumIsAlive



BOOL
LkQuorumCheckIsAlive(
    IN PLKQUORUM_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Check to see if the resource is alive for Local Quourm resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    return(TRUE);

} // LkQuorumCheckIsAlive



DWORD
WINAPI
LkQuorumResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Local Quourm resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PLKQUORUM_RESOURCE  resourceEntry;
    DWORD               required;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("LkQuorum: ResourceControl request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( LkQuorumResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_LOCAL_QUORUM |
                    ((resourceEntry->Params.Debug == TRUE) ?
                    CLUS_CHAR_LOCAL_QUORUM_DEBUG : 0);
                status = ERROR_SUCCESS;                    
            }
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
            //
            // Chittur Subbaraman (chitturs) - 12/23/98
            //
            // If the local quorum drive letter cannot be found in the
            // path parameter, it defaults to "SystemDrive" environment 
            // variable.
            //
            status = LkQuorumGetDiskInfo(resourceEntry->Params.Path,
                                  &OutBuffer,
                                  OutBufferSize,
                                  BytesReturned);


            // Add the endmark.
            if ( OutBufferSize > *BytesReturned ) {
                OutBufferSize -= *BytesReturned;
            } else {
                OutBufferSize = 0;
            }
            *BytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize >= sizeof(CLUSPROP_SYNTAX) ) {
                PCLUSPROP_SYNTAX ptrSyntax = (PCLUSPROP_SYNTAX) OutBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            }
      
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( LkQuorumResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = LkQuorumGetPrivateResProperties( resourceEntry,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = LkQuorumValidatePrivateResProperties( resourceEntry,
                                                           InBuffer,
                                                           InBufferSize,
                                                           NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = LkQuorumSetPrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // LkQuorumResourceControl



DWORD
WINAPI
LkQuorumResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Local Quourm resources.

    Perform the control request specified by ControlCode on this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( LkQuorumResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( LkQuorumResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_LOCAL_QUORUM ;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // LkQuorumResourceTypeControl



DWORD
LkQuorumGetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Local Quorum.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    //
    // Get all our properties.
    //
    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      LkQuorumResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // LkQuorumGetPrivateResProperties



DWORD
LkQuorumValidatePrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PLKQUORUM_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Local Quourm.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    LKQUORUM_PARAMS     params;
    PLKQUORUM_PARAMS    pParams;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &params;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(LKQUORUM_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &ResourceEntry->Params,
                                       LkQuorumResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( LkQuorumResourcePrivateProperties,
                                         NULL,
                                         TRUE,   // Accept unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the parameter values.
        //
        // TODO: Code to validate interactions between parameters goes here.
    }

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   LkQuorumResourcePrivateProperties );
    }

    return(status);

} // LkQuorumValidatePrivateResProperties



DWORD
LkQuorumSetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Local Quourm.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD            status = ERROR_SUCCESS;
    LKQUORUM_PARAMS  params;

    ZeroMemory( &params, sizeof(LKQUORUM_PARAMS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = LkQuorumValidatePrivateResProperties( ResourceEntry,
                                                   InBuffer,
                                                   InBufferSize,
                                                   &params );

    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   LkQuorumResourcePrivateProperties );
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               LkQuorumResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               LkQuorumResourcePrivateProperties );

    if ( status == ERROR_SUCCESS ) {
        if ( ResourceEntry->State == ClusterResourceOnline ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else if ( ResourceEntry->State == ClusterResourceOnlinePending ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // LkQuorumSetPrivateResProperties



DWORD WINAPI LkQuorumArbitrate(
    RESID ResourceId,
    PQUORUM_RESOURCE_LOST LostQuorumResource
    )

/*++

Routine Description:

    Perform full arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk, one per second.

Arguments:

    DiskResource - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS ;
    return status ;
}



DWORD
WINAPI
LkQuorumRelease(
    IN RESID Resource
    )

/*++

Routine Description:

    Release arbitration for a device by stopping the reservation thread.

Arguments:

    Resource - supplies resource id to be brought online

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_HOST_NODE_NOT_OWNER if the resource is not owned.
    A Win32 error code if other failure.

--*/

{
    DWORD status = ERROR_SUCCESS ;

    return status ;
}



DWORD
LkQuorumGetDiskInfo(
    IN LPWSTR   lpszPath,
    OUT PVOID * OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Gets all of the disk information for a given signature.

Arguments:

    Signature - the signature of the disk to return info.

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    DWORD   bytesReturned = *BytesReturned;
    PVOID   ptrBuffer = *OutBuffer;
    PCLUSPROP_DWORD ptrDword;
    PCLUSPROP_PARTITION_INFO ptrPartitionInfo;

    DWORD   letterIndex;
    DWORD   letterCount = 1;
    WCHAR   driveLetters[1];
    LPWSTR  pszExpandedPath = NULL;
    WCHAR   chDrive;
    DWORD   dwLength;
    
    // Return the signature - a DWORD
    bytesReturned += sizeof(CLUSPROP_DWORD);
    if ( bytesReturned <= OutBufferSize ) {
        ptrDword = (PCLUSPROP_DWORD)ptrBuffer;
        ptrDword->Syntax.dw = CLUSPROP_SYNTAX_DISK_SIGNATURE;
        ptrDword->cbLength = sizeof(DWORD);
        ptrDword->dw = 777;//return a bogus signature for now
        ptrDword++;
        ptrBuffer = ptrDword;
    }

    status = ERROR_SUCCESS;

    pszExpandedPath = ClRtlExpandEnvironmentStrings(lpszPath);
    if (!pszExpandedPath)
    {
        status = GetLastError();
        goto FnExit;
    }
    //get a drive letter to fake the partition info
    //if the first char is drive letter, use that  
    if ((lstrlenW(pszExpandedPath) > 2) && (pszExpandedPath[1] == L':'))
    {
        driveLetters[0] = pszExpandedPath[0];
    }
    else
    {
        WCHAR   lpszTmpPath[MAX_PATH];
        DWORD   dwStrLen;
        
        //the path name could not have a drive letter
        //it can point to a share \\xyz\abc
        dwStrLen = GetWindowsDirectoryW( lpszTmpPath,
                                         MAX_PATH );
        if (!dwStrLen)
        {
            status = GetLastError();
            goto FnExit;
        }
        driveLetters[0] = lpszTmpPath[0];
        
    }        
    

    for ( letterIndex = 0 ; letterIndex < letterCount ; letterIndex++ ) {

        bytesReturned += sizeof(CLUSPROP_PARTITION_INFO);
        if ( bytesReturned <= OutBufferSize ) {
            ptrPartitionInfo = (PCLUSPROP_PARTITION_INFO) ptrBuffer;
            ZeroMemory( ptrPartitionInfo, sizeof(CLUSPROP_PARTITION_INFO) );
            ptrPartitionInfo->Syntax.dw = CLUSPROP_SYNTAX_PARTITION_INFO;
            ptrPartitionInfo->cbLength = sizeof(CLUSPROP_PARTITION_INFO) - sizeof(CLUSPROP_VALUE);
            if ( iswlower( driveLetters[letterIndex] ) ) {
                driveLetters[letterIndex] = towupper( driveLetters[letterIndex] );
            } else {
                ptrPartitionInfo->dwFlags = CLUSPROP_PIFLAG_STICKY;
            }
            ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_USABLE;
            ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_DEFAULT_QUORUM;

            wsprintfW( ptrPartitionInfo->szDeviceName,
                       L"%hc:\\",
                       driveLetters[letterIndex] );
            if ( !GetVolumeInformationW( ptrPartitionInfo->szDeviceName,
                                         ptrPartitionInfo->szVolumeLabel,
                                         sizeof(ptrPartitionInfo->szVolumeLabel)/sizeof(WCHAR),
                                         &ptrPartitionInfo->dwSerialNumber,
                                         &ptrPartitionInfo->rgdwMaximumComponentLength,
                                         &ptrPartitionInfo->dwFileSystemFlags,
                                         ptrPartitionInfo->szFileSystem,
                                         sizeof(ptrPartitionInfo->szFileSystem)/sizeof(WCHAR) ) ) {
                ptrPartitionInfo->szVolumeLabel[0] = L'\0';
            }

            //set the partition name to the path
            //in future, siva wants to be able to provide an smb name here
            lstrcpy(ptrPartitionInfo->szDeviceName, pszExpandedPath);
            dwLength = lstrlenW(ptrPartitionInfo->szDeviceName);
            //this should not be terminated in a '\'
            if (ptrPartitionInfo->szDeviceName[dwLength-1] == L'\\')
            {
                ptrPartitionInfo->szDeviceName[dwLength-1] = L'\0';
            }

            ptrPartitionInfo++;
            ptrBuffer = ptrPartitionInfo;
        }
    }

    //
    // Check if we got what we were looking for.
    //
    *OutBuffer = ptrBuffer;
    *BytesReturned = bytesReturned;

FnExit:
    if (pszExpandedPath) 
        LocalFree(pszExpandedPath);
    return(status);

} // LkQuorumGetDiskInfo





//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( LkQuorumFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         LkQuorum,                    // Prefix
                         LkQuorumArbitrate,           // Arbitrate
                         LkQuorumRelease,             // Release
                         LkQuorumResourceControl,     // ResControl
                         LkQuorumResourceTypeControl); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\fs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fs.h

Abstract:

    Interface between srv and fs

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef __FS_INTERFACE_H__
#define __FS_INTERFACE_H__

// note: we assume DWORD and DWORDDLONG are defined (from windows.h)
#define UINT16	USHORT
#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef _BASETSD_H_
typedef DWORDLONG UINT64;    // a 64-bit unsigned value
typedef DWORD     UINT32;    // a 32-bit unsigned value
#endif

#ifndef MAXPATH
#define	MAXPATH	1024
#endif

typedef UINT64    TIME64;    // in units of 100ns since Jan 1, 1601 (AD)

#define fhandle_t USHORT

#define INVALID_UINT64    ((UINT64)(0))
#define INVALID_UINT32    ((UINT32)(0))
#define INVALID_TIME64    INVALID_UINT64
#define INVALID_FHANDLE_T ((fhandle_t)(-1))

    // disposition:
#define DISP_CREATE_NEW        0x10000000
#define DISP_CREATE_ALWAYS     0x20000000
#define DISP_OPEN_EXISTING     0x30000000
#define DISP_OPEN_ALWAYS       0x40000000
#define DISP_TRUNCATE_EXISTING 0x50000000
#define DISP_DIRECTORY         0x60000000
#define FS_DISP_MASK              0x70000000

    // access:
#define ACCESS_READ         0x00010000
#define ACCESS_WRITE        0x00020000
#define FS_ACCESS_MASK         0x00030000

    // cache:
#define CACHE_WRITE_THROUGH 0x01000000
#define CACHE_NO_BUFFERING  0x02000000
#define FS_CACHE_MASK          0x03000000

    // sharing:
#define SHARE_READ          0x00100000
#define SHARE_WRITE         0x00200000
#define FS_SHARE_MASK          0x00300000

    // flags = dispositions | access | sharing
#define FLAGS_MASK (FS_DISP_MASK | FS_ACCESS_MASK | FS_SHARE_MASK | FS_CACHE_MASK)

    // attributes:
#define ATTR_SYMLINK        0x00002000
#define ATTR_DIRECTORY      0x00000010
#define ATTR_READONLY       0x00000001
#define ATTR_HIDDEN         0x00000002
#define ATTR_SYSTEM         0x00000004
#define ATTR_ARCHIVE        0x00000020
#define ATTR_COMPRESSED     0x00000800
#define ATTR_OFFLINE        0x00001000
#define ATTR_MASK           (ATTR_SYMLINK  | ATTR_DIRECTORY |  \
                                        ATTR_READONLY | ATTR_HIDDEN    | \
                                        ATTR_SYSTEM   | ATTR_ARCHIVE   | \
                                        ATTR_COMPRESSED | ATTR_OFFLINE)

#define MAX_FS_NAME_LEN  64

    // file system attributes
typedef struct {
    CHAR  fs_name[MAX_FS_NAME_LEN];
    UINT64 total_units;
    UINT64 free_units;
    ULONG  sectors_per_unit;
    ULONG  bytes_per_sector;
}fs_attr_t;

typedef struct {
    // sizes
    UINT64 file_size;
    UINT64 alloc_size;
    // times
    TIME64 create_time;
    TIME64 access_time;
    TIME64 mod_time;
    // mode/attr
    UINT32 attributes;
}fattr_t;

typedef struct {
    UINT32	cookie;
    fattr_t	attribs;
    WCHAR	name[MAX_PATH];
} dirinfo_t;

typedef struct {
    DWORD	FsVer;
    DWORD (*FsCreate)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name,
	    IN	   USHORT      name_len,
            IN     UINT32      flags, 
            IN     fattr_t*    attr, 
            OUT    fhandle_t*  handle,
            OUT    UINT32*     action
            );

    DWORD (*FsLookup)(
            IN     PVOID       fshandle,
            IN     LPWSTR	name, 
	    IN	   USHORT	len,
            OUT    fattr_t*    attr
            );

    DWORD (*FsSetAttr)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle,
            IN     fattr_t*    attr
            );

    DWORD (*FsSetAttr2)(
            IN     PVOID       fshandle,
	    IN	   LPWSTR	path,
	    IN	   USHORT	len,
            IN     fattr_t*    attr
            );

    DWORD (*FsGetAttr)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle, 
            OUT    fattr_t*    attr
            );

    DWORD (*FsClose)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle
            );

    DWORD (*FsWrite)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle, 
            IN     UINT32      offset, 
            IN OUT UINT16*     count, 
            IN     void*       buffer,
	    IN	   PVOID	context
            );

    DWORD (*FsRead)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle, 
            IN     UINT32      offset, 
            IN OUT UINT16*     count, 
            OUT    void*       buffer,
	    IN	   PVOID	context
            );


        // to use readir(), we do a create() with DISP_DIRECTORY
        // returns ERROR_NO_MORE_FILES when done...
    DWORD (*FsReadDir)(
            IN     PVOID       fshandle,
            IN     fhandle_t   dir, 
            IN     UINT32      cookie, 
            OUT    dirinfo_t*  buffer, 
            IN     UINT32      size, 
            OUT    UINT32*     entries_found
            );


    DWORD (*FsStatfs)(
            IN     PVOID       fshandle,
            OUT    fs_attr_t*  attr
            );

    DWORD (*FsRemove)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name,
	    IN	   USHORT      len
            );

    DWORD (*FsRename)(
            IN     PVOID       fshandle,
            IN     LPWSTR      fromname, 
	    IN	   USHORT      from_len,
            IN     LPWSTR      toname,
	    IN	   USHORT      to_len
            );

    DWORD (*FsMkdir)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name, 
	    IN	   USHORT	len,
            IN     fattr_t*    attr
            );

    DWORD (*FsRmdir)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name,
	    IN	   USHORT	len
            );

    DWORD (*FsFlush)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle
            );

    DWORD (*FsLock)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle,
	    IN	   ULONG       offset,
	    IN	   ULONG       length,
	    IN	   ULONG       flags,
	    IN	   PVOID       context
            );

    DWORD (*FsUnlock)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle,
	    IN	   ULONG       offset,
	    IN	   ULONG       length
            );

    DWORD (*FsGetRoot)(
            IN     PVOID       fshandle,
	    IN OUT LPWSTR      fullpath
            );

} FsDispatchTable;

#include "fsapi.h"

DWORD	
FsMount(PVOID hdl, LPWSTR root_name, USHORT uid, USHORT *tid);

void
FsDisMount(PVOID hdl, USHORT uid, USHORT tid);

DWORD
FsLogonUser(PVOID hdl, HANDLE token, LUID LogonId, USHORT *uid);

void
FsLogoffUser(PVOID hdl, LUID LogonId);

DWORD
LsaInit(
    HANDLE  *LsaHandle,
    ULONG   *AuthenticationPackage
    );

BOOL
LsaValidateLogon(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    LUID    *pLogonId,
    PHANDLE phLogonToken
    );

BOOL
LsaGetChallenge(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    LPBYTE lpChallenge,
    UINT cbSize,
    PUINT lpcbChallengeSize
    );


FsDispatchTable *
FsGetHandle(PVOID FsCtx, USHORT tid, USHORT uid, PVOID *fshandle);

#define EPRINT(_x_)	error_log _x_ 
#define DPRINT(_x_)	debug_log _x_ 

#define	SrvLogError(_x_)	EPRINT(_x_)

#define FsLogError(_x_)	EPRINT(_x_)
#define FsArbLog(_x_)	DPRINT(_x_)
#define FsLogReplay(_x_) DPRINT(_x_)
#define FsLogUndo(_x_)	DPRINT(_x_)

// enable this if you want details logging
#ifdef QFS_DBG
#define xFsLog(_x_)	DPRINT(_x_)
#define FsLog(_x_)	DPRINT(_x_)
#define	SrvLog(_x_)	DPRINT(_x_)
#else
#define xFsLog(_x_)	
#define FsLog(_x_)	
#define	SrvLog(_x_)	
#endif

#endif /* __FS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\crs.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    crs.c

Abstract:

    Implements Consistency Replica Set Algorithm

Author:

    Ahmed Mohamed (ahmedm) 1-Jan-2001

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <assert.h>

#include "crs.h"

#define xmalloc(size)  VirtualAlloc(NULL, size,MEM_RESERVE|MEM_COMMIT,PAGE_READWRITE)

#define xfree(buffer) VirtualFree(buffer, 0, MEM_RELEASE|MEM_DECOMMIT) 

#define CrspEqual(r1,r2)	((r1)->hdr.seq == (r2)->hdr.seq && \
                                 (r1)->hdr.epoch == (r2)->hdr.epoch && \
                                 (r1)->hdr.state == (r2)->hdr.state)

DWORD CrsForcedQuorumSize = 0xffff;

void
WINAPI
CrsSetForcedQuorumSize(DWORD size)
{
    CrsForcedQuorumSize = size;
}

DWORD
CrspFindLast(CrsInfo_t *p, DWORD logsz)
{
    
    CrsRecord_t *rec, *last_rec;
    BOOL err;
    DWORD n, i;

    n = SetFilePointer(p->fh, 0, NULL, FILE_BEGIN);
    if (n == INVALID_SET_FILE_POINTER) {
	return GetLastError();
    }

    err = ReadFile(p->fh, p->buf, logsz, &n, NULL);
    if (!err)
	return GetLastError();

    if (n != logsz) {
	CrsLog(("Crs%d: failed to load complete file, read %d expected %d\n",
		p->lid,
		n, logsz));
	return ERROR_BAD_LENGTH;
    }
    ASSERT(p->max_records * CRS_RECORD_SZ == (int)n);
    if(p->max_records * CRS_RECORD_SZ != (int)n) {
	CrsLog(("Crs%d: unable to load log file %d bytes, got %d bytes\n",
	       p->lid, n, logsz));
	return ERROR_BAD_LENGTH;
    }

    CrsLog(("Crs%d: loaded %d bytes, %d records\n", p->lid,
	   n, p->max_records));

    last_rec = NULL;
    rec = p->buf;
    for (i = 0; i < logsz; i += CRS_RECORD_SZ, rec++) {
	if (rec->hdr.tag != CRS_TAG) {
	    CrsLog(("crs%d: Bad record %d, got %x expected %x\n",
		    p->lid,
		    i/CRS_RECORD_SZ, rec->hdr.tag, CRS_TAG));
	    return ERROR_BAD_FORMAT;
	}

	if (!last_rec ||
	    rec->hdr.epoch > last_rec->hdr.epoch ||
	    (rec->hdr.epoch == last_rec->hdr.epoch &&
	     (rec->hdr.seq > last_rec->hdr.seq))) {
	    last_rec = rec;
	}
    }
    ASSERT(last_rec);

    // make sure only the last record is not committed or aborted
    rec = p->buf;
    for (i = 0; i < logsz; i += CRS_RECORD_SZ, rec++) {
	if (!(rec->hdr.state & (CRS_COMMIT | CRS_ABORT))) {
	    if (rec != last_rec) {
		CrsLog(("crs:%d Bad record %d state %x expected commit|abort\n",
			p->lid,	i/CRS_RECORD_SZ, rec->hdr.state));
		return ERROR_INTERNAL_ERROR;
	    }
	}
    }

    p->last_record = (int) (last_rec - p->buf);
    p->seq = last_rec->hdr.seq;
    p->epoch = last_rec->hdr.epoch;

    return ERROR_SUCCESS;

}

#define CrspFlush(p,offset)	CrspWrite(p,offset, CRS_SECTOR_SZ)

static
DWORD
CrspWrite(CrsInfo_t *p, int offset, DWORD length)
{
    DWORD	n;

    p->pending = FALSE;

    n = (DWORD) offset;
    // write out last sector, assumes lock is held
    ASSERT(offset < p->max_records);
    offset = offset / CRS_RECORDS_PER_SECTOR;

    CrsLog(("Crs%d: flush %d bytes record %d -> %d,%d\n", p->lid,
	    length, n,
	    offset, offset*CRS_SECTOR_SZ));

    n = SetFilePointer(p->fh, offset * CRS_SECTOR_SZ, NULL, FILE_BEGIN);
    if (n == INVALID_SET_FILE_POINTER) {
	return GetLastError();
    }

    n = 0;
    if (WriteFile(p->fh, (PVOID) &p->buf[offset*CRS_RECORDS_PER_SECTOR], length, &n, NULL)) {
	if (n != length) {
	    CrsLog(("Write count mismatch, wrote %d, expected %d\n", n, length));
	    return ERROR_BAD_LENGTH;
	}
	return ERROR_SUCCESS;
    }

    n = GetLastError();
    CrsLog(("Crs%d: flush record %d failed err %d\n", p->lid, offset, n));
    if (n == ERROR_UNEXP_NET_ERR) {
	// repeat the write one more time
	p->pending = TRUE;
    }

    return n;
}

static
DWORD
CrspAppendRecord(CrsInfo_t *p, CrsRecord_t *rr, CrsRecord_t **rec)
{
    CrsRecord_t *q;
    DWORD err;

    // tag record 
    rr->hdr.tag = CRS_TAG;

    // assumes lock is held
    if ((p->last_record & CRS_SECTOR_MASK) == CRS_SECTOR_MASK) {
	// flush current sector
	err = CrspFlush(p, p->last_record);
	if (err != ERROR_SUCCESS)
	    return err;

    }

	// advance last record
    p->last_record++;
    if (p->last_record == p->max_records)
	p->last_record = 0;

    CrsLog(("Crs%d: append record %d epoch %I64d seq %I64d state %x\n",
	    p->lid, p->last_record,
	    rr->hdr.epoch, rr->hdr.seq, rr->hdr.state));

    // copy record
    q = &p->buf[p->last_record];
    memcpy((PVOID)q, (PVOID) rr, CRS_RECORD_SZ);

    // flush it out now
    err = CrspFlush(p, p->last_record);
    if (err == ERROR_SUCCESS) {
	if (rec) *rec = q;
    } else {
	if (p->last_record == 0)
	    p->last_record = p->max_records;
	p->last_record--;
    }

    return err;
}

// NextRecord:
//	if seq is null, fill in last record and return SUCCESS
//	if seq is not found, return NOT_FOUND
// 	if seq is last record, return EOF
// 	otherwise return next record after seq in lrec and SUCCESS
DWORD
CrspNextLogRecord(CrsInfo_t *info, CrsRecord_t *seq,
		  CrsRecord_t *lrec, BOOLEAN this_flag)
{
    CrsRecord_t	*last, *p;
    DWORD err = ERROR_SUCCESS;

    if (lrec == NULL || info == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    // read record
    EnterCriticalSection(&info->lock);
    last = &info->buf[info->last_record];
    if (seq == NULL) {
	CrsLog(("Crs%d: last record %d %I64d %I64d\n",
		info->lid, info->last_record, last->hdr.epoch, last->hdr.seq));

	// read last record
	memcpy(lrec, last, CRS_RECORD_SZ);

    } else if (seq->hdr.epoch != last->hdr.epoch ||
	       seq->hdr.seq != last->hdr.seq) {
	int i;

	CrsLog(("Crs%d: last record %d %I64d %I64d search %I64d %I64d\n",
		info->lid, info->last_record,
		last->hdr.epoch, last->hdr.seq,
		seq->hdr.epoch, seq->hdr.seq));

	// assume we don't have it
	p = seq;
	seq = NULL;
	// do a search instead of index, so that
	// seq can be reset as epoch increments
	for (i = 0; i < info->max_records; i++) {
	    last = &info->buf[i];
	    if (p->hdr.epoch == last->hdr.epoch &&
		p->hdr.seq == last->hdr.seq) {

		seq = last;
		break;
	    }
	}
	if (seq != NULL) {
	    if (this_flag == FALSE) {
		// return record after this one
		i++;
		if (i >= info->max_records)
		    i = 0;
		seq = &info->buf[i];
	    }
	    CrsLog(("Crs%d: search found %d %I64d, %I64d\n", info->lid,
		   seq - info->buf, seq->hdr.epoch, seq->hdr.seq));
	    memcpy(lrec, seq, CRS_RECORD_SZ);
	} else {
	    err = ERROR_NOT_FOUND;
	}
    } else {
	
	CrsLog(("Crs%d: reached last record %d %I64d %I64d, %I64d %I64d\n",
		info->lid, info->last_record,
		last->hdr.epoch, last->hdr.seq,
		seq->hdr.epoch, seq->hdr.seq));

	if (this_flag == TRUE) {
	    // we are trying to read the last record
	    memcpy(lrec, last, CRS_RECORD_SZ);
	    err = ERROR_SUCCESS;
	} else {
	    err = ERROR_HANDLE_EOF;
	}
    }

    LeaveCriticalSection(&info->lock);

    if (err == ERROR_SUCCESS && lrec->hdr.epoch == 0) {
	// invalid rec, log is empty
	err = ERROR_HANDLE_EOF;
    }


    return err;
}

// Call into fs with <undo, replay, query, disable, enable, done>
//	undo: pass replica in recovery due to a conflict
//	replay: replica is missing change, if replay fails with abort, we
//		do a full copy; otherwise we issue a skip record
//	query: ask replica if record was completed or not
//	done: signal end of recovery and pass in new wset, rset
// we silently handle <abort(skip) and epoch records>
//	abort: add a skip record
//	epoch records: just log it as is
DWORD
CrspReplay(LPVOID rec)
{
    CrsRecoveryBlk_t *rr;
    CrsInfo_t *info, *minfo;
    CrsRecord_t *p, *q;
    CrsRecord_t lrec, mlrec;
    DWORD err;

    rr = (CrsRecoveryBlk_t *) rec;
    info = rr->info;
    minfo = rr->minfo;

    CrsLog(("CrsReplay%d mid %d, lid %d leader_id %d\n",
	    rr->nid, rr->mid, info->lid, info->leader_id));

    do {
	p = NULL;
	// read last record
	err = CrspNextLogRecord(info, NULL, &lrec, FALSE);
	if (err != ERROR_SUCCESS) {
	    CrsLog(("CrsReplay%d: unable to read last record %d\n",
		    info->lid, err));
	    break;
	}

	// find our last record in master replica
	q = &lrec;
	p = &mlrec;
	err = CrspNextLogRecord(minfo, q, p, TRUE);
	// if found and consistent with master, no undo
	if (err == ERROR_SUCCESS && p->hdr.state == q->hdr.state) {
	    CrsLog(("CrsReplay%d: last record %I64d, %I64d consistent %x %x\n",
		    info->lid, q->hdr.epoch, q->hdr.seq,
		    p->hdr.state, q->hdr.state));
	    break;
	}

	if (err != ERROR_SUCCESS) {
	    CrsLog(("CrsReplay%d: missing lrec %I64d, %I64d in disk %d, err %d\n",
		    info->lid, q->hdr.epoch, q->hdr.seq, minfo->lid, err));
	} else {
	    CrsLog(("CrsReplay%d: undo last record %I64d, %I64d %x needs %x\n",
		    info->lid, q->hdr.epoch, q->hdr.seq,
		    q->hdr.state, p->hdr.state));
	    ASSERT(p->hdr.state & (CRS_COMMIT|CRS_ABORT));
	}

	// last record is in conflict, we must undo it first
	if (!(q->hdr.state & CRS_EPOCH)) {
	    // if we found this record in master and a conflict is detected,
	    // we undo it. Otherwise, we need to do a full copy
	    if (err == ERROR_SUCCESS) {
		ASSERT(p->hdr.state & (CRS_COMMIT|CRS_ABORT));
		ASSERT(q->hdr.state & CRS_PREPARE);
		err = info->callback(info->callback_arg,
				     rr->nid, q,
				     CRS_ACTION_UNDO, rr->mid);
	    }
	} else {
	    // A missing epoch record doesn't mean we are old. A regroup
	    // could have happened but no new data records got added. We
	    // undo it, and continue;
	    err = STATUS_SUCCESS;
	}

	if (err == STATUS_SUCCESS) {
	    // update current record, sequence, epoch
	    info->buf[info->last_record].hdr.state = 0;
	    info->buf[info->last_record].hdr.epoch = 0;
	    info->buf[info->last_record].hdr.seq = 0;
	    if (info->last_record == 0) {
		info->last_record = info->max_records;
	    }
	    info->last_record--;
	    info->seq = info->buf[info->last_record].hdr.seq;
	    info->epoch = info->buf[info->last_record].hdr.epoch;
	    CrsLog(("CrsReplay%d: new last record %d %I64d, %I64d\n",
		    info->lid, info->last_record, info->epoch, info->seq));
	} else {
	    // can't undo it, do full copy and readjust our log
	    CrsLog(("CrsReplay%d: Unable to undo record %I64d, %I64d\n",
		    info->lid, q->hdr.epoch, q->hdr.seq));
	    p = NULL;
	}
    } while (err == STATUS_SUCCESS && info->state == CRS_STATE_RECOVERY);

		   
    while (p != NULL && info->state == CRS_STATE_RECOVERY) {
	// read master copy
	err = CrspNextLogRecord(minfo, p, &mlrec, FALSE);
	if (err != ERROR_SUCCESS) {
	    if (err == ERROR_HANDLE_EOF) {
		CrsLog(("CrsReplay%d: last record %I64d, %I64d in disk %d\n",
			info->lid, q->hdr.epoch, q->hdr.seq, minfo->lid));

		// the last record is where we are at
		info->seq = info->buf[info->last_record].hdr.seq;
		info->epoch = info->buf[info->last_record].hdr.epoch;

		// we reached the end, signal end of recovery
		err = info->callback(info->callback_arg,
			       rr->nid, p,
			       CRS_ACTION_DONE, rr->mid);

		goto exit;
	    }
	    break;
	}

	p = &mlrec;
	if ((p->hdr.state & CRS_EPOCH) || (p->hdr.state & CRS_ABORT)) {
	    CrsLog(("CrsReplay%d: skip record %I64d, %I64d %x\n",
		    info->lid, p->hdr.epoch, p->hdr.seq, p->hdr.state));
	    err = !STATUS_SUCCESS;
	} else if (p->hdr.state & CRS_COMMIT) {
	    err = info->callback(info->callback_arg,
				 rr->nid, p,
				 CRS_ACTION_REPLAY, rr->mid);
	    if (err == STATUS_TRANSACTION_ABORTED) {
		CrsLog(("CrsReplay: failed nid %d seq %I64d err %d\n",
			rr->nid, p->hdr.seq, err));
		break;
	    }
	} else {
	    ASSERT(p->hdr.state & CRS_PREPARE);
	    // what if the record is prepared but not yet committed or
	    // aborted; in transit record. 
	    // stop now
	    CrsLog(("CrsReplay%d: bad record seq %I64d state %x\n",
		    rr->nid, p->hdr.seq, p->hdr.state));
	    break;
	}
	if (err != STATUS_SUCCESS) {
	    // add record
	    err = CrspAppendRecord(info, p, NULL);
	    if (err != ERROR_SUCCESS) {
		CrsLog(("CrsReplay%d: failed append seq %I64d err %d\n",
			rr->nid, p->hdr.seq, err));
		break;
	    }
	    if (p->hdr.state & CRS_EPOCH) {
		; //ASSERT(info->epoch+1 == p->hdr.epoch);
	    } else {
		ASSERT(info->epoch == p->hdr.epoch);
		ASSERT(info->seq+1 == p->hdr.seq);
	    }
	    info->seq = p->hdr.seq;
	    info->epoch = p->hdr.epoch;
	} else {
	    // make sure we have added it
	    ASSERT(info->seq == p->hdr.seq);
	    ASSERT(info->epoch == p->hdr.epoch);
	    ASSERT(info->buf[info->last_record].hdr.seq == p->hdr.seq);
	    ASSERT(info->buf[info->last_record].hdr.epoch == p->hdr.epoch);

	    // Propagate dubious bit
	    if (p->hdr.state & CRS_DUBIOUS) {
		info->buf[info->last_record].hdr.state |= CRS_DUBIOUS;
	    }
	    ASSERT(info->buf[info->last_record].hdr.state == p->hdr.state);
	}
    }

    if (p == NULL || err != STATUS_SUCCESS) {
	CrsLog(("CrsReplay%d: Full copy from disk %d\n",
		info->lid, minfo->lid));
	// we are out of date or need full recovery, do a full copy
	err = info->callback(info->callback_arg,
			     rr->nid, NULL,
			     CRS_ACTION_COPY, rr->mid);

	if (err == STATUS_SUCCESS) {
	    DWORD len;

	    // we now copy our master log and flush it
	    ASSERT(minfo->max_records == info->max_records);

	    len = info->max_records * CRS_RECORD_SZ;
	    memcpy(info->buf, minfo->buf, len);
	    err = CrspWrite(info, 0, len);
	    if (err == ERROR_SUCCESS) {
		// adjust our state
		info->last_record = minfo->last_record;
		info->seq = info->buf[info->last_record].hdr.seq;
		info->epoch = info->buf[info->last_record].hdr.epoch;

		// we reached the end, signal end of recovery
		err = info->callback(info->callback_arg,
			       rr->nid, p,
			       CRS_ACTION_DONE, rr->mid);
	    }
	}
    }

 exit:

    CrsLog(("CrsReplay%d mid %d status 0x%x\n", rr->nid, rr->mid, err));

    return err;
}


/////////////////////// Public Functions //////////////////////
DWORD
WINAPI
CrsOpen(crs_callback_t callback, PVOID callback_arg, USHORT lid,
	WCHAR *log_name, int max_logsectors, HANDLE *outhdl)
{

    // Open the log file
    // If the file in newly create, set the proper size
    // If the file size is not the same size, we need to either
    // expand or truncate the file. (truncate needs copy)
    // Scan file to locate last sector and record
    // If last record hasn't been commited, issue a query.
    // If query succeeded then, mark it as committed.
    // Set epoch,seq
    DWORD status;
    HANDLE maph;
    CrsInfo_t	*p;
    int logsz;

    if (outhdl == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    *outhdl = NULL;

    p = (CrsInfo_t *) malloc(sizeof(*p));
    if (p == NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }
    memset((PVOID) p, 0, sizeof(*p));

    CrsLog(("Crs%d file '%S'\n", lid, log_name));
    p->lid = lid;
    p->callback = callback;
    p->callback_arg = callback_arg;
    p->pending = FALSE;

    // Create log file, and set size of newly created
    p->fh = CreateFileW(log_name,
		     GENERIC_READ | GENERIC_WRITE,
		     FILE_SHARE_READ|FILE_SHARE_WRITE,
		     NULL,
		     OPEN_ALWAYS,
		     FILE_FLAG_WRITE_THROUGH,
		     NULL);
			   
    status = GetLastError();
    if(p->fh == INVALID_HANDLE_VALUE){
	free((char *) p);
	return status;
    }

    // acquire an exclusive lock on the whole file
    if (!LockFile(p->fh, 0, 0, (DWORD)-1, (DWORD)-1)) {
	FILE_FULL_EA_INFORMATION ea[2] = {0};
	IO_STATUS_BLOCK ios;
	NTSTATUS err;

	// get status
	status = GetLastError();

	// change the ea to cause a notification to happen
	ea[0].NextEntryOffset = 0;
	ea[0].Flags = 0;
	ea[0].EaNameLength = 1;
	ea[0].EaValueLength = 1;
	ea[0].EaName[0] = 'X';
	err = NtSetEaFile(p->fh, &ios, (PVOID) ea, sizeof(ea));
	CrsLog(("Crs%d Setting EA %x\n", lid, err));
	goto error;
    }

    if (status == ERROR_ALREADY_EXISTS) {
	// todo: compare current file size to new size and adjust file
	// size accordingly. For now, just use old size
	logsz = GetFileSize(p->fh, NULL);
	CrsLog(("Crs%d: Filesz %d max_sec %d\n", lid, logsz, max_logsectors));
	ASSERT(logsz == max_logsectors * CRS_SECTOR_SZ);
    } else {
	//extend the file pointer to max size 
	logsz = max_logsectors * CRS_SECTOR_SZ;
	SetFilePointer(p->fh, logsz, NULL, FILE_BEGIN);
	SetEndOfFile(p->fh);
	CrsLog(("Crs%d: Set Filesz %d max_sec %d\n", lid, logsz, max_logsectors));
    }

    // allocate file copy in memory
    p->buf = xmalloc(logsz);
    if (p->buf == NULL) {
	status = ERROR_NOT_ENOUGH_MEMORY;
	goto error;
    }
    
    // set max record
    p->max_records = logsz / CRS_RECORD_SZ;

    if (status == ERROR_ALREADY_EXISTS) {
	// load file and compute last epoch/seq
	status = CrspFindLast(p, logsz);
    } else {
	status = !ERROR_SUCCESS;
    }
    // init the file, when we detect a read failure or first time
    if (status != ERROR_SUCCESS) {
	CrsRecord_t *r;
	int i;

	// initialize file
	p->seq = 0;
	p->epoch = 0;
	p->last_record = 0;

	r = p->buf;
	for (i = 0; i < logsz; i+= CRS_RECORD_SZ, r++) {
	    r->hdr.epoch = p->epoch;
	    r->hdr.seq = p->seq;
	    r->hdr.tag = CRS_TAG;
	    r->hdr.state = CRS_COMMIT | CRS_PREPARE | CRS_EPOCH;
	}
	status = CrspWrite(p, 0, logsz);
    }

    if (status != ERROR_SUCCESS) {
	goto error;
    }

    CrsLog(("Crs%d: %x Last record %d max %d epoch %I64d seq %I64d\n", p->lid,
	    p->fh,
	    p->last_record, p->max_records, p->epoch, p->seq));

    // initialize rest of state
    p->state = CRS_STATE_INIT;
    p->refcnt = 1;
    p->leader_id = 0;
    InitializeCriticalSection(&p->lock);

    *outhdl = p;

    return ERROR_SUCCESS;

 error:
    CloseHandle(p->fh);
    if (p->buf) {
	xfree(p->buf);
    }
    free((PVOID) p);
    return status;
}

//
DWORD
WINAPI
CrsStart(PVOID *hdls, ULONG alive_set, int cluster_sz,
	 ULONG *write_set, ULONG *read_set, ULONG *evict_set)

{
    DWORD status;
    CrsInfo_t **info = (CrsInfo_t **) hdls;
    int i, active_sz, mid;
    ULONG mask, active_set, fail_set;
    CrsInfo_t *p;
    CrsRecord_t	*q, *mlrec;

    if (write_set) *write_set = 0;
    if (read_set) *read_set = 0;
    if (evict_set) *evict_set = 0;

    // no alive node
    if (cluster_sz == 0 || alive_set == 0) {
	// nothing to do
	return ERROR_WRITE_PROTECT;
    }


    // scan each hdl and make sure it is initialized and lock all hdls
    mask = alive_set;
    for (i = 0; mask != 0; i++, mask = mask >> 1) {
	if (!(mask & 0x1)) {
	    continue;
	}

	p = info[i];
	if (p == NULL) {
	    continue;
	}

	EnterCriticalSection(&p->lock);

	// check the state of the last record
	p = info[i];
	q = &p->buf[p->last_record];
	CrsLog(("Crs%d last record %d epoch %I64d seq %I64d state %x\n",
		p->lid, p->last_record,
		q->hdr.epoch, q->hdr.seq, q->hdr.state));
    }

    mid = 0;
    mlrec = NULL;
    // select master replica
    for (i = 0, mask = alive_set; mask != 0; i++, mask = mask >> 1) {
	if (!(mask & 0x1)) {
	    continue;
	}
	p = info[i];
	if (p == NULL)
	    continue;

	q = &p->buf[p->last_record];
	if (!mlrec || 
	    mlrec->hdr.epoch < q->hdr.epoch || 
	    (mlrec->hdr.epoch == q->hdr.epoch && mlrec->hdr.seq < q->hdr.seq) ||
	    (mlrec->hdr.epoch == q->hdr.epoch && mlrec->hdr.seq == q->hdr.seq &&
	     mlrec->hdr.state != q->hdr.state && (q->hdr.state & CRS_COMMIT))) {

	    mid = i;
	    mlrec = q;
	}
    }

    ASSERT(mid != 0);

    // if master last record is in doubt, query filesystem. If the filesystem
    // is certain that the operation has occured, it returns STATUS_SUCCESS for
    //	COMMIT, STATUS_CANCELLED for ABORT, and STATUS_NOT_FOUND for can't tell.
    // All undetermined IO must be undone and redone in all non-master replicas
    // to ensure all replicas reach consistency. This statement is true even
    // for replicas that are currently absent from our set. We tag such records
    // we both COMMIT and ABORT, so that the replay thread issues replay for
    // new records and undo,replay for last records
    p = info[mid];
    p->leader_id = (USHORT) mid;
    ASSERT(mlrec != NULL);
    if (!(mlrec->hdr.state & (CRS_COMMIT | CRS_ABORT))) {
	ASSERT(mlrec->hdr.state & CRS_PREPARE);
	status = p->callback(p->callback_arg, p->lid,
			     mlrec, CRS_ACTION_QUERY,
			     p->lid);

	if (status == STATUS_SUCCESS) {
	    mlrec->hdr.state |= CRS_COMMIT;
	} else if (status == STATUS_CANCELLED) {
	    mlrec->hdr.state |= CRS_ABORT;
	} else if (status == STATUS_NOT_FOUND) {
	    // assume it is committed, but mark it for undo during recovery
	    mlrec->hdr.state |= (CRS_COMMIT | CRS_DUBIOUS);
	}

	// todo: if status == TRANSACTION_ABORTED, we need to bail out since
	// must master is dead
	// no need to flush, I think!
//	CrspFlush(p, p->last_record);

	// todo: what if the flush fails here, I am assuming that
	// an append will equally fail.
    }


    ASSERT(mlrec->hdr.state & (CRS_COMMIT | CRS_ABORT));

    // compute sync and recovery masks
    fail_set = 0;
    active_set = 0;
    active_sz = 0;
    for (i = 0, mask = alive_set; mask != 0; i++, mask = mask >> 1) {
	if (!(mask & 0x1)) {
	    continue;
	}

	p = info[i];
	if (p == NULL) {
	    continue;
	}

	// set leader id
	p->leader_id = (USHORT) mid;
	q = &p->buf[p->last_record];
	    
	if (CrspEqual(mlrec, q)) {
	    ASSERT(q->hdr.state & (CRS_COMMIT | CRS_ABORT));
	    p->state = CRS_STATE_READ;
	    active_set |= (1 << i);
	    active_sz++;
	} else if (p->state != CRS_STATE_RECOVERY) {
	    CrsRecoveryBlk_t rrbuf;
	    CrsRecoveryBlk_t *rr = &rrbuf;

	    // recover replica
	    rr->nid = i;
	    rr->mid = mid;
	    rr->info = p;
	    rr->minfo = info[mid];

	    // set recovery state
	    p->state = CRS_STATE_RECOVERY;

	    status = CrspReplay((LPVOID) rr);

	    // if we fail, evict this replica
	    if (status != ERROR_SUCCESS) {
		fail_set |= (1 << i);
	    } else {
		// repeat this replica again
		i--;
		mask = mask << 1;
	    }
	}
    }

    // assume success
    status = ERROR_SUCCESS;

    // set read sets
    if (read_set) *read_set = active_set;

    if (!CRS_QUORUM(active_sz, cluster_sz)) {
	CrsLog(("No quorum active %d cluster %d\n", active_sz, cluster_sz));
	mid = 0;
	status = ERROR_WRITE_PROTECT;
    } else {
	int pass_cnt = 0;
	ULONG pass_set = 0;

	// Enable writes on all active replicas
	for (i = 0, mask = active_set; mask != 0; i++, mask = mask >> 1) {
	    CrsRecord_t	rec;
	    if (!(mask & 0x1)) {
		continue;
	    }
	    p = info[i];
	    if (p == NULL)
		continue;

	    p->state = CRS_STATE_WRITE;

	    // we now generate a new epoch and flush it to the disk
	    p->epoch++;
	    if (p->epoch == 0)
		p->epoch = 1;
	    // reset seq to zero
	    p->seq = 0;

	    // write new epoch now, if not a majority replicas succeeded in writing
	    // the new <epoch, seq> we fail
	    rec.hdr.epoch = p->epoch;
	    rec.hdr.seq = p->seq;
	    rec.hdr.state = CRS_PREPARE | CRS_COMMIT | CRS_EPOCH;
	    memset(rec.data, 0, sizeof(rec.data));
	    if (CrspAppendRecord(p, &rec, NULL) == ERROR_SUCCESS) {
		pass_cnt++;
		pass_set |= (1 << i);
	    } else {
		fail_set |= (1 << i);
	    }
	}

	// Recheck to make sure all replicas have advanced epoch
	if (!CRS_QUORUM(pass_cnt, cluster_sz)) {
	    CrsLog(("No quorum due to error pass %d cluster %d\n", pass_cnt, cluster_sz));
	    mid = 0;
	    pass_set = 0;
	    pass_cnt = 0;
	    status = ERROR_WRITE_PROTECT;
	}

	if (pass_cnt != active_sz) {
	    // some replicas have died
	    for (i = 0, mask = pass_set; mask != 0; i++, mask = mask >> 1) {
		if ((alive_set & (1 << i)) && (!mask & (1 << i))) {
		    p = info[i];
		    ASSERT(p != NULL);
		    p->state = CRS_STATE_READ;
		}
	    }
	}
	// set write set
	if (write_set) *write_set = pass_set;
    }

    if (evict_set) *evict_set = fail_set;

    // unlock all hdls and set new master if any
    for (i = 0, mask = alive_set; mask != 0; i++, mask = mask >> 1) {
	if (!(mask & 0x1)) {
	    continue;
	}
	p = info[i];
	if (p == NULL)
	    continue;

	p->leader_id = (USHORT) mid;
	LeaveCriticalSection(&p->lock);
    }

    return status;
}


void
WINAPI
CrsClose(PVOID hd)
{
    DWORD err;
    CrsInfo_t *info = (CrsInfo_t *) hd;

    // If we any recovery threads running, make sure we terminate them first
    // before close and free all of this stuff
    if (info == NULL) {
	CrsLog(("CrsClose: try to close a null handle!\n"));
	return;
    }

    // Flush everything out and close the file
    EnterCriticalSection(&info->lock);
    // flush 
    CrspFlush(info, info->last_record);
    LeaveCriticalSection(&info->lock);

    DeleteCriticalSection(&info->lock);

    err = CloseHandle(info->fh);

    CrsLog(("Crs%d: %x Closed %d\n", info->fh, info->lid, err));

    xfree(info->buf);
    free((char *) info);
}

void
WINAPI
CrsFlush(PVOID hd)
{
    CrsInfo_t *info = (CrsInfo_t *) hd;

    // if we have a commit or abort that isn't flushed yet, flush it now
    EnterCriticalSection(&info->lock);
    if (info->pending == TRUE) {
	CrspFlush(info, info->last_record);
    }
    LeaveCriticalSection(&info->lock);
}

PVOID
WINAPI
CrsPrepareRecord(PVOID hd, PVOID lrec, crs_id_t id)
{
    CrsRecord_t	*p = (CrsRecord_t *)lrec;
    CrsInfo_t *info = (CrsInfo_t *) hd;
    DWORD err;

    // move to correct slot in this sector. If we need a new sector,
    // read it from the file. Make sure we flush any pending commits on
    // current sector before we over write our in memory sector buffer.

    // prepare record, if seq none 0 then we are skipping the next sequence
    EnterCriticalSection(&info->lock);

    if (info->state == CRS_STATE_WRITE ||
	(info->state == CRS_STATE_RECOVERY && id != NULL && id[0] != 0)) {

	if (id != NULL && id[0] != 0) {
	    CrsHdr_t *tmp = (CrsHdr_t *) id;
	    assert(id[0] == info->seq+1);
	    p->hdr.seq = tmp->seq;
	    p->hdr.epoch = tmp->epoch;
	} else {
	    p->hdr.seq = info->seq+1;
	    p->hdr.epoch = info->epoch;
	}
	p->hdr.state = CRS_PREPARE;
	err = CrspAppendRecord(info, p, &p);
	if (err == ERROR_SUCCESS) {
	    // we return with the lock held, gets release on commitorabort
	    CrsLog(("Crs%d prepare %x seq %I64d\n",info->lid, p, p->hdr.seq));
	    return p;
	}
	CrsLog(("Crs%d: Append failed seq %I64%d\n", info->lid, p->hdr.seq));
    } else {
	CrsLog(("Crs%d: Prepare bad state %d id %x\n", info->lid, info->state, id));
    }

    LeaveCriticalSection(&info->lock);
    return NULL;
}

int
WINAPI
CrsCommitOrAbort(PVOID hd, PVOID lrec, int commit)
{
    CrsRecord_t	*p = (CrsRecord_t *)lrec;
    CrsInfo_t *info = (CrsInfo_t *) hd;

    if (p == NULL || info == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    // update state of record
    if (p->hdr.seq != info->seq+1) {
	CrsLog(("Crs: sequence mis-match on commit|abort %I64d %I64d\n",
		p->hdr.seq, info->seq));
	assert(0);
	return ERROR_INVALID_PARAMETER;
    }

    assert(!(p->hdr.state & (CRS_COMMIT | CRS_ABORT)));

    // todo: this is wrong, what if one replica succeeds
    // and others abort. Now, the others will reuse the
    // same seq for a different update and when the
    // succeeded replica rejoins it can't tell that the
    // sequence got reused.
    if (commit == TRUE) {
	p->hdr.state |= CRS_COMMIT;
	// advance the sequence
	info->seq++;
	CrsLog(("Crs%d: commit last %d leader %d seq %I64d\n", info->lid, 
		info->last_record,
		info->leader_id, p->hdr.seq));
    } else {
	p->hdr.state |= CRS_ABORT;
	// we need to re-adjust our last record
	if (info->last_record == 0) {
	    info->last_record = info->max_records;
	}
	info->last_record--;
	CrsLog(("Crs%d: abort last %d leader %d seq %I64d\n", info->lid, 
		info->last_record,
		info->leader_id, p->hdr.seq));
    }

    info->pending = TRUE;
    LeaveCriticalSection(&info->lock);

    return ERROR_SUCCESS;
}


int
WINAPI
CrsCanWrite(PVOID hd)
{
    CrsInfo_t *info = (CrsInfo_t *) hd;
    int err;

    // do we have a quorm or not
    EnterCriticalSection(&info->lock);
    err = (info->state == CRS_STATE_WRITE);
    LeaveCriticalSection(&info->lock);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\fsapi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsapi.h

Abstract:

    External APIs to replication file system

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef _FS_API_H
#define _FS_API_H

// upto 16 nodes for now, node id start from 1
#define	FsMaxNodes	17

// initial crs log is 16 sectors, which is 8k
#define	FsCrsNumSectors	16

DWORD	FsInit(PVOID, PVOID *);
void	FsExit(PVOID);
void	FsEnd(PVOID);
DWORD 	FsRegister(PVOID, LPWSTR name, LPWSTR ipcshare, LPWSTR disks[], DWORD disksz, HANDLE *fsid);
DWORD 	FsUpdateReplicaSet(HANDLE fsid, LPWSTR disks[], DWORD disksz);
DWORD 	FsArbitrate(PVOID vid, HANDLE event, HANDLE *wait_event);
DWORD 	FsCancelArbitration(PVOID vid);
DWORD 	FsIsQuorum(PVOID vid);
DWORD 	FsIsOnline(PVOID vid);
DWORD 	FsRelease(PVOID vid);
DWORD 	FsReserve(PVOID vid);

DWORD	SrvInit(PVOID, PVOID, PVOID *);
DWORD	SrvOnline(PVOID, LPWSTR name, DWORD nic);
DWORD	SrvOffline(PVOID);
void	SrvExit(PVOID);

extern void WINAPI error_log(char *, ...);
extern void WINAPI debug_log(char *, ...);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\msmq\msmq.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    msmq.c

Abstract:

    Resource DLL to control and monitor the NT DHCPServer service.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#include "..\common\svc.c"
#include "clusudef.h"
#include "ntverp.h"

extern CLRES_FUNCTION_TABLE MsMQFunctionTable;


#define MSMQ_VERSION        L"Version"

#define MSMQ_DEFAULT_VERSION 0x04000000

#define PARAM_NAME__VERSION         L"Version"


RESUTIL_PROPERTY_ITEM
MsMQResourcePrivateProperties[] = {
    { PARAM_NAME__VERSION, NULL, CLUSPROP_FORMAT_DWORD, MSMQ_DEFAULT_VERSION, 0, 0xFFFFFFFF, 0, FIELD_OFFSET(COMMON_PARAMS,dwVersion) },
    { 0 }
};



//
// Forward Functions
//
DWORD
WINAPI
MsMQResourceControl(
    IN RESID ResourceId,
    IN DWORD nControlCode,
    IN PVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD
MsMQGetPrivateResProperties(
    IN OUT PCOMMON_RESOURCE pResourceEntry,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );


//
// Local Functions
//

VOID
MsMQResetCheckpoints(
    PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description

    Delete and then set registry checkpoints this will clean out old
    registry checkpoint settings.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD   returnSize;
    DWORD   idx;
    DWORD   status;

    //
    // Delete old registry checkpoints that were set.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < RegSyncCount; idx++ ) {
            status = ClusterResourceControl( ResourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
                                             RegSync[idx],
                                             (lstrlenW( RegSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if ( status == ERROR_ALREADY_EXISTS ){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to delete registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set new registry checkpoints that we need.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < RegSyncCount; idx++ ) {
            status = ClusterResourceControl( ResourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                                             RegSync[idx],
                                             (lstrlenW( RegSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if ( status == ERROR_ALREADY_EXISTS ){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any crypto checkpoints that we need.
    //
    if ( CryptoSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < CryptoSyncCount; idx++ ) {
            status = ClusterResourceControl( ResourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                             CryptoSync[idx],
                                             (lstrlenW( CryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if (status == ERROR_ALREADY_EXISTS){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set crypto checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any domestic crypto checkpoints that we need.
    //
    if ( DomesticCryptoSyncCount != 0 ) {
        HCRYPTPROV hProv = 0;
        //
        // check if domestic crypto is available
        //
        if (CryptAcquireContextA( &hProv,
                                  NULL,
                                  MS_ENHANCED_PROV_A,
                                  PROV_RSA_FULL,
                                  CRYPT_VERIFYCONTEXT)) {
            CryptReleaseContext( hProv, 0 );
            returnSize = 0;
            //
            // Set registry sync keys if we need them.
            //
            for ( idx = 0; idx < DomesticCryptoSyncCount; idx++ ) {
                status = ClusterResourceControl( ResourceEntry->hResource,
                                                 NULL,
                                                 CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                                 DomesticCryptoSync[idx],
                                                 (lstrlenW( DomesticCryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                                 NULL,
                                                 0,
                                                 &returnSize );
                if ( status != ERROR_SUCCESS ){
                    if (status == ERROR_ALREADY_EXISTS){
                        status = ERROR_SUCCESS;
                    }
                    else{
                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Failed to set domestic crypto checkpoint, status %1!u!.\n",
                            status );
                        goto error_exit;
                    }
                }
            }
        }
    }

error_exit:

    return;

} // MsMQResetCheckpoints


DWORD
MsMQReadParametersEx(
    IN OUT PVOID pvResourceEntry,
    IN BOOL bCheckForRequiredProperties
    )

/*++

Routine Description:

    Reads all the parameters for a specied MsMQ resource.

Arguments:

    pResourceEntry - Entry in the resource table.

    bCheckForRequiredProperties - TRUE = make sure required properties are
        present.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code if failure occurrs.

--*/

{
    DWORD               status;
    COMMON_PARAMS       params = { 0 };
    LPWSTR              pszNameOfPropInError;
    PCOMMON_RESOURCE    pResourceEntry = (PCOMMON_RESOURCE) pvResourceEntry;

    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock(
                    pResourceEntry->ParametersKey,
                    MsMQResourcePrivateProperties,
                    (LPBYTE) &pResourceEntry->Params,
                    bCheckForRequiredProperties,
                    &pszNameOfPropInError
                    );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            status
            );
    }

    return(status);

} // MsMQReadParametersEx



VOID
MsMQPerformFixup(
    IN OUT PCOMMON_RESOURCE pResourceEntry
    )
{
    DWORD   status;
    DWORD   version;
    DWORD   bytesReturned;
    DWORD   bytesRequired;
    PVOID   propBuffer;
    COMMON_PARAMS params;

    status = MsMQReadParametersEx(
                        pResourceEntry,
                        FALSE );
    if ( status != ERROR_SUCCESS ) {
        return;
    }

    version = pResourceEntry->Params.dwVersion;
    version = version >> 16;

    if ( version < 0x0500 ) {
        //
        // Delete Old Checkpoints and set new ones
        //
        MsMQResetCheckpoints( pResourceEntry );

        params.dwVersion = VER_PRODUCTVERSION_DW;

        //
        // Get version number as a property list
        //
        status = ResUtilGetProperties(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        NULL,
                        0,
                        &bytesReturned,
                        &bytesRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to get properties. Error: %1!u!.\n",
                status
                );
            return;
        }

        propBuffer = LocalAlloc( LMEM_FIXED, bytesRequired + 2 );
        if ( !propBuffer ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate property buffer.\n"
                );
            return;
        }

        status = ResUtilGetProperties(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        propBuffer,
                        bytesRequired+2,
                        &bytesReturned,
                        &bytesRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to get properties. Error: %1!u!.\n",
                status
                );
            LocalFree( propBuffer );
            return;
        }

        //
        // Set Version Number
        //
        status = ResUtilSetPropertyParameterBlock(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        NULL,
                        (LPBYTE) &params,
                        propBuffer,
                        bytesReturned,
                        (LPBYTE) &pResourceEntry->Params
                        );
        LocalFree( propBuffer );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to set the property parameter block. Error: %1!u!.\n",
                status
                );
            return;
        }
    }

} //MsMQPerformFixup


DWORD
WINAPI
MsMQResourceControl(
    IN RESID ResourceId,
    IN DWORD nControlCode,
    IN PVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for MsMQ Service resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    nControlCode - Supplies the control code that defines the action
        to be performed.

    pvInBuffer - Supplies a pointer to a buffer containing input data.

    cbInBufferSize - Supplies the size, in bytes, of the data pointed
        to by pvInBuffer.

    pvOutBuffer - Supplies a pointer to the output buffer to be filled in.

    cbOutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by pvOutBuffer.

    pcbBytesReturned - Returns the number of bytes of pvOutBuffer actually
        filled in by the resource. If pvOutBuffer is too small, pcbBytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               cbRequired;
    PCOMMON_RESOURCE    pResourceEntry = (PCOMMON_RESOURCE) ResourceId;

    switch ( nControlCode ) {

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = MsMQGetPrivateResProperties(
                                pResourceEntry,
                                pvOutBuffer,
                                cbOutBufferSize,
                                pcbBytesReturned );
            break;

        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
            MsMQPerformFixup( pResourceEntry );
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = ERROR_INVALID_PARAMETER;
            break;

        default:
            status = CommonResourceControl(
                            ResourceId,
                            nControlCode,
                            pvInBuffer,
                            cbInBufferSize,
                            pvOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;
    }

    return(status);

} // MsMQResourceControl



DWORD
MsMQGetPrivateResProperties(
    IN OUT PCOMMON_RESOURCE pResourceEntry,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type MsMQ Service.

Arguments:

    pResourceEntry - Supplies the resource entry on which to operate.

    pvOutBuffer - Returns the output data.

    cbOutBufferSize - Supplies the size, in bytes, of the data pointed
        to by pvOutBuffer.

    pcbBytesReturned - The number of bytes returned in pvOutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           cbRequired;
    DWORD           cbLocalOutBufferSize = cbOutBufferSize;

    do {
        //
        // Read our parameters.
        //
        status = MsMQReadParametersEx( pResourceEntry, FALSE /* bCheckForRequiredProperties */ );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Construct a property list from the parameter block.
        //
        status = ResUtilPropertyListFromParameterBlock(
                        MsMQResourcePrivateProperties,
                        pvOutBuffer,
                        &cbLocalOutBufferSize,
                        (const LPBYTE) &pResourceEntry->Params,
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( status == ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Error constructing property list from parameter block. Error: %1!u!.\n",
                status
                );
            break;
        }

        //
        // Add unknown properties.
        //
        status = ResUtilAddUnknownProperties(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        pvOutBuffer,
                        cbOutBufferSize,
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Error adding unknown properties to the property list. Error: %1!u!.\n",
                status
                );
            break;
        }

    } while ( 0 );

    if ( status == ERROR_MORE_DATA ) {
        *pcbBytesReturned = cbRequired;
    }

    return(status);

} // MsMQGetPrivateResProperties



BOOLEAN
WINAPI
MsMQDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            CommonSemaphore = CreateSemaphoreW( NULL,
                                        0,
                                        1,
                                        COMMON_SEMAPHORE );
            if ( CommonSemaphore == NULL ) {
                return(FALSE);
            }
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                //if the semaphore didnt exist, set its initial count to 1
                ReleaseSemaphore(CommonSemaphore, 1, NULL);
            }

            break;

        case DLL_PROCESS_DETACH:
            if ( CommonSemaphore ) {
                CloseHandle( CommonSemaphore );
            }
            break;

        default:
            break;
    }

    return(TRUE);

} // MsMQDllEntryPoint



//***********************************************************
//
// Define MsMQ Function Table
//
//***********************************************************


CLRES_V1_FUNCTION_TABLE( MsMQFunctionTable,    // Name
                         CLRES_VERSION_V1_00,  // Version
                         Common,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         MsMQResourceControl,  // ResControl
                         CommonResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\fsp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsp.h

Abstract:

    Private replication file system data structures and functions

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef FS_P_H
#define FS_P_H

#ifdef __cplusplus
extern "C" {
#endif

#include "crs.h"

typedef ULONGLONG 	fs_id_t[2];

#define	PAGESIZE	4*1024

#define FsTableSize	1024

#define	FS_FID_NAME	"CRSFID$"
#define	FS_FID_NAME_LEN	7

typedef struct {
    FILE_FULL_EA_INFORMATION hdr;
    CHAR		data[FS_FID_NAME_LEN+sizeof(fs_id_t)];
}fs_ea_t;

typedef struct {
    FILE_GET_EA_INFORMATION hdr;
    CHAR		data[FS_FID_NAME_LEN];
}fs_ea_name_t;

#define	FsInitEa(x) { \
    (x)->hdr.NextEntryOffset = 0; \
    (x)->hdr.Flags = 0; \
    (x)->hdr.EaNameLength = FS_FID_NAME_LEN; \
    strcpy((x)->hdr.EaName, FS_FID_NAME); \
    (x)->hdr.EaValueLength = sizeof(fs_id_t); \
}

#define	FsInitEaName(x) { \
    (x)->hdr.NextEntryOffset = 0; \
    (x)->hdr.EaNameLength = FS_FID_NAME_LEN; \
    strcpy((x)->hdr.EaName, FS_FID_NAME); \
}

#define	FsInitEaFid(x, fid) { \
    (fid) = (fs_id_t *) (&((x)->hdr.EaName[FS_FID_NAME_LEN+1])); \
}

#define xFsOpenRA(fd,hvol,name,sz) \
        xFsOpen(fd,hvol,name,sz,FILE_READ_EA | (FILE_GENERIC_READ & ~FILE_READ_DATA), \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define xFsOpenWA(fd,hvol,name,sz) \
        xFsOpen(fd,hvol,name,sz, FILE_WRITE_EA | ((FILE_GENERIC_READ|FILE_GENERIC_WRITE)&~(FILE_READ_DATA|FILE_WRITE_DATA|FILE_APPEND_DATA)), \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define xFsOpenRD(fd,hvol,id,sz) \
        xFsOpen(fd,hvol,name,sz,FILE_READ_EA | FILE_GENERIC_READ, \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define xFsOpenWD(fd,hvol,name,sz) \
        xFsOpenById(fd,hvol,name,sz,FILE_WRITE_EA | fFILE_GENERIC_WRITE, \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define LockType	CRITICAL_SECTION
#define	LockInit(x)	InitializeCriticalSection(&x)
#define	LockEnter(x)	EnterCriticalSection(&x)
#define	LockTryEnter(x)	TryEnterCriticalSection(&x)
#define	LockExit(x)	LeaveCriticalSection(&x)

typedef struct {
    fs_id_t	Id;
    UINT32	Flags;
    HANDLE	Fd[FsMaxNodes];
}hdl_t;


// todo: if we want to support more than one tree/user we need to split this
typedef struct _USERINFO_ {
    LockType		Lock;
    // Add a refcnt, we can have multiple connects on an existing session
    DWORD		RefCnt;
    UINT16		Tid;
    UINT16		Uid;
    struct _VOLINFO_	*VolInfo;
    hdl_t		Table[FsTableSize];
    struct _USERINFO_	*Next;
}UserInfo_t;

#define	ARB_STATE_IDLE	0
#define	ARB_STATE_BUSY	1
#define	ARB_STATE_CANCEL	2

typedef struct {
    ULONG	State;
    ULONG	Set;
    ULONG	Count;
    HANDLE	Event;
}FspArbitrate_t;


typedef struct _VOLINFO_ {
    LockType	      qLock;	// quorum lock, protects alive set
    LockType	      uLock;	// update lock, serializes updates and crs recovery
    struct _VOLINFO_  *Next;
    UINT16	      Tid;
    PVOID	      CrsHdl[FsMaxNodes];	// crs log handles
    HANDLE	      Fd[FsMaxNodes];	// root directory handles
    HANDLE	      NotifyFd[FsMaxNodes];	// root directory notification handles
    ULONG	      ReadSet;
    ULONG	      WriteSet;
    ULONG	      AliveSet;
    USHORT	      LockUpdates;
    LPWSTR	      DiskList[FsMaxNodes];
    DWORD	      DiskListSz;
    UserInfo_t	      *UserList;
    LPWSTR	      Label;
    PVOID	     *ObjIdTable;
    HANDLE	       Event;	// signal when quorum is lost
    FspArbitrate_t     Arbitrate;
    struct _FSCTX_    *FsCtx;
    WCHAR	     *Root;
}VolInfo_t; 

typedef struct _SESSIONINFO_ {
    struct _SESSIONINFO_ *Next;
    UserInfo_t	TreeCtx;	// at tree connect time
}SessionInfo_t;

typedef struct _LOGONINFO_ {
    struct _LOGONINFO_ *Next;
    HANDLE	Token;
    LUID	LogOnId;
}LogonInfo_t;

typedef struct _FSCTX_ {
    LockType	Lock;
    VolInfo_t 	*VolList;
    DWORD	VolListSz;
    PVOID	reshdl;
    PVOID	ipcHdl;
    // list of logged on users that we have obtained valid lsa tokens
    // add an entry during session setup, when we assign a user an id
    // At tree connect, we validate the user and create a private structure
    // to hold state
    LogonInfo_t	*LogonList;
    SessionInfo_t *SessionList;
    WCHAR	*Root;
}FsCtx_t;
    
#define FS_SET_USER_HANDLE(u,nid,f,h) ((u)->Table[f].Fd[nid] = h)
#define FS_GET_USER_HANDLE(u,nid,f) ((u)->Table[f].Fd[nid])
#define FS_GET_FID_HANDLE(u,f) (&(u)->Table[f].Id)
#define FS_GET_VOL_HANDLE(v,nid) ((v)->Fd[nid])
#define FS_GET_VOL_NAME(v,nid) ((v)->DiskList[nid])
#define FS_SET_VOL_HANDLE(v,nid,h) ((v)->Fd[nid] = (h))
#define FS_GET_CRS_HANDLE(v,n) ((v)->CrsHdl[nid])
#define FS_GET_CRS_NID_HANDLE(v,nid) ((v)->CrsHdl[(nid)])
#define FS_GET_VOL_NOTIFY_HANDLE(v,nid) ((v)->NotifyFd[nid])

#define FS_BUILD_LOCK_KEY(uid,nid,fid) ((uid << 16) | fid)

#define MemAlloc(x)	malloc(x)
#define	MemFree(x)	free(x)


typedef NTSTATUS (*fs_handler_t)(VolInfo_t *,UserInfo_t *,int,PVOID,ULONG,PVOID,ULONG_PTR *);

#define FS_CREATE	0
#define FS_SETATTR	1
#define FS_WRITE	2
#define FS_MKDIR	3
#define FS_REMOVE	4
#define FS_RENAME	5

// 

typedef struct {
    crs_id_t	xid;
    UINT32	flags;
    UINT32	attr;
    LPWSTR	name;
    USHORT	name_len;
    USHORT	fnum;	// file number
}fs_create_msg_t;

typedef struct {
    fs_id_t	fid;
    USHORT	action;	// action taken
    USHORT	access;	// access granted
}fs_create_reply_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    FILE_BASIC_INFORMATION attr;
    union {
	struct {
	    USHORT	name_len;
	    LPWSTR	name;
	};
	USHORT	fnum;	// file number
    };
}fs_setattr_msg_t;

typedef struct {
    LPWSTR	name;
    int		name_len;
}fs_lookup_msg_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    union {
	UINT32	offset;
	UINT32	cookie;
    };
    UINT32	size;
    PVOID	buf;
    PVOID	context;
    USHORT	fnum;	// file number
}fs_io_msg_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    LPWSTR	name;
    int		name_len;
}fs_remove_msg_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    LPWSTR	sname;
    LPWSTR	dname;
    USHORT	sname_len;
    USHORT	dname_len;
}fs_rename_msg_t;

#define	FS_LOCK_WAIT	0x1
#define FS_LOCK_SHARED	0x2

typedef struct {
    crs_id_t	xid;
    USHORT	fnum;
    ULONG	offset;
    ULONG	length;
    ULONG	flags;
}fs_lock_msg_t;


#define EventWait(x)	WaitForSingleObject(x, INFINITE)

// Forward declaration
void
DecodeCreateParam(UINT32 uflags, UINT32 *flags, UINT32 *disp, UINT32 *share, UINT32 *access);

NTSTATUS
FspCreate(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf,
	  ULONG_PTR *rlen);

NTSTATUS
FspSetAttr2(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf,
	    ULONG_PTR *rlen);

NTSTATUS
FspMkDir(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen);

NTSTATUS
FspRemove(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen);

NTSTATUS
FspRename(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen);

NTSTATUS
FspWrite(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen);

void
FspEvict(VolInfo_t *vinfo, ULONG mask, BOOLEAN flag);

void
FspJoin(VolInfo_t *vinfo, ULONG mask);


//Consistency Replica Set
NTSTATUS
FsUndoXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int  mid);

NTSTATUS
FsReplayXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid);

// this must be 64 bytes
typedef struct {
    fs_id_t	id;	// crs epoch,seq
    ULONGLONG	crshdr;	// crs header
    fs_id_t 	fs_id;
    UINT32	command;
    UINT32	flags;
    union {
	char	buf[CRS_RECORD_SZ - (sizeof(ULONGLONG) * 5 + sizeof(int) * 2)];
	struct {
	    // create, set attrib
	    UINT32	attrib;
	};
	struct {
	    // write, lock
	    UINT32	offset;
	    UINT32	length;
	};
    };
}fs_log_rec_t;

typedef NTSTATUS (*FsReplayHandler_t)(VolInfo_t *info,
				      fs_log_rec_t *lrec,
				      int nid, int mid);

NTSTATUS
WINAPI
FsCrsCallback(PVOID hd, int nid, CrsRecord_t *arg, int action, int mid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\fsutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsutil.c

Abstract:

    Implements interface to underlying filesystem

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include <malloc.h>

#include "fs.h"
#include "fsp.h"

#include "fsutil.h"

#define	XFS_ENUM_FIRST	0x1
#define	XFS_ENUM_LAST	0x2
#define	XFS_ENUM_DIR	0x4

typedef NTSTATUS (*PXFS_ENUM_CALLBACK)(PVOID,HANDLE,PFILE_DIRECTORY_INFORMATION);

NTSTATUS
xFsCreate(HANDLE *fd, HANDLE root, LPWSTR buf, int n, UINT32 flag,
	  UINT32 attrib, UINT32 share, UINT32 *disp, UINT32 access,
	  PVOID eabuf, int easz)
{

    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    // if write access is enabled, we turn on write-through bit
    if (access & FILE_WRITE_DATA) {
	flag |= FILE_WRITE_THROUGH;
    }

    *fd = INVALID_HANDLE_VALUE;
    status = NtCreateFile(fd,
			  SYNCHRONIZE |
			  access,
			  &objattrs, &iostatus,
			  0,
			  attrib,
			  share,
			  *disp,
			  FILE_SYNCHRONOUS_IO_ALERT | 
			  flag,
			  eabuf,
			  easz);


    *disp = (UINT32) iostatus.Information;

    return status;

}

NTSTATUS
xFsOpen(HANDLE *fd, HANDLE root, LPWSTR buf, int n, UINT32 access,
	UINT32 share, UINT32 flags)
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    IO_STATUS_BLOCK iostatus;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    *fd = INVALID_HANDLE_VALUE;
    return  NtOpenFile(fd,
			SYNCHRONIZE |
			access,
                        &objattrs,
			&iostatus,
		       share,
                       flags | FILE_SYNCHRONOUS_IO_ALERT);

}

NTSTATUS
xFsDelete(HANDLE root, LPWSTR buf, int n)
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    return NtDeleteFile(&objattrs);

}

NTSTATUS
xFsQueryObjectId(HANDLE fd, PVOID id)
{
    NTSTATUS status;
    IO_STATUS_BLOCK iostatus;
    fs_ea_t x;
    fs_ea_name_t name;

    FsInitEa(&x);
    FsInitEaName(&name);

    status = NtQueryEaFile(fd, &iostatus, 
			   (PVOID) &x, sizeof(x),
			   TRUE, (PVOID) &name, sizeof(name), 
			   NULL, TRUE);

    if (status == STATUS_SUCCESS) {
	fs_id_t	*fid;
	
	if (iostatus.Information > sizeof(x.hdr)) {
	    FsInitEaFid(&x, fid);
	    memcpy(id, fid, sizeof(fs_id_t));
	} else {
	    memset(id, 0, sizeof(fs_id_t));
	}
    } else {
	FsLog(("QueryEa failed %x\n", status));
    }

    return status;
}


NTSTATUS
xFsRename(HANDLE fh, HANDLE root, WCHAR *dname, int n)
{
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;
    struct {
	FILE_RENAME_INFORMATION x;
	WCHAR	buf[MAXPATH];
    }info;

    info.x.ReplaceIfExists = TRUE;
    info.x.RootDirectory = root;

    ASSERT(n == (int)wcslen(dname));
    // convert to unicode
    wcscpy(info.x.FileName, dname);
    info.x.FileNameLength = n * 2;

    status = NtSetInformationFile(fh, &iostatus, (PVOID) &info, sizeof(info),
				FileRenameInformation);
    return status;
}

NTSTATUS
xFsSetAttr(HANDLE fd, FILE_BASIC_INFORMATION *attr)
{
    IO_STATUS_BLOCK iostatus;

    return NtSetInformationFile(fd, &iostatus, 
			       (PVOID) attr, sizeof(*attr),
				FileBasicInformation);
}

NTSTATUS
xFsQueryAttr(HANDLE fd, FILE_NETWORK_OPEN_INFORMATION *attr)
{
    IO_STATUS_BLOCK iostatus;

    return NtQueryInformationFile(fd, &iostatus, 
				  (PVOID)attr, sizeof(*attr),
				  FileNetworkOpenInformation);
}

NTSTATUS
xFsQueryAttrName(HANDLE root, LPWSTR buf, int n, FILE_NETWORK_OPEN_INFORMATION *attr)
{
    NTSTATUS err;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    err = NtQueryFullAttributesFile(&objattrs, attr);

    return err;

}

NTSTATUS
xFsReadDir(HANDLE fd, PVOID buf, int *rlen, BOOLEAN flag)
{
    NTSTATUS err;
    IO_STATUS_BLOCK iostatus;
	    
    err = NtQueryDirectoryFile(fd, NULL, NULL, NULL, &iostatus, 
			       (LPVOID) buf, *rlen >> 1,
			       FileDirectoryInformation, FALSE, NULL, 
			       flag);

    
    *rlen = (int) iostatus.Information;
    return err;
}

LPWSTR
xFsBuildRelativePath(VolInfo_t *vol, int nid, LPWSTR path)
{

    LPWSTR share, s;

    share = wcschr(vol->DiskList[nid], L'\\');
    if (share != NULL) {
	s = wcsstr(path, share);
	if (s == path) {
	    path += (wcslen(share)+1);
	    s = wcsstr(path, vol->Root);
	    if (s == path) {
		path += (wcslen(vol->Root) + 1);
	    }
	}
    }
    return path;
}

NTSTATUS
_FsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl)
{

    ULONGLONG	buf[MAXPATH/sizeof(ULONGLONG)];
    NTSTATUS	err, status;
    int 	sz;
    BOOLEAN	flag = TRUE;
    IO_STATUS_BLOCK ios;

    status = STATUS_OBJECT_PATH_NOT_FOUND;
    while (TRUE) {
	PFILE_DIRECTORY_INFORMATION p;

	err = NtQueryDirectoryFile(root, NULL, NULL, NULL, &ios,
				   (LPVOID) buf, sizeof(buf),
				   FileDirectoryInformation, FALSE, NULL, 
				   flag);

	sz = (int) ios.Information;

	if (err != STATUS_SUCCESS) {
//	    FsLogError(("ReadDir failed %x flags %d\n", err, flag));
	    break;
	}

	flag = FALSE;

	p = (PFILE_DIRECTORY_INFORMATION) buf;
	while (TRUE) {
	    // open each entry and get its object id
	    HANDLE fd;
	    OBJECT_ATTRIBUTES objattrs;
	    UNICODE_STRING  cwspath;

	    cwspath.Buffer = p->FileName;
	    cwspath.Length = (USHORT) p->FileNameLength;
	    cwspath.MaximumLength = (USHORT) p->FileNameLength;

	    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
				       root, NULL);

	    // todo: what if the file is nonsharable @ this time?
	    err = NtOpenFile(&fd,
			     SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
			     &objattrs,
			     &ios,
			     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			     FILE_SYNCHRONOUS_IO_ALERT);

	    if (err == STATUS_SUCCESS) {
		fs_id_t	fid;
		err = xFsQueryObjectId(fd, (PVOID) &fid);
		if (err == STATUS_SUCCESS) {
#ifdef DEBUG
		    wprintf(L"Compare file %wZ, %I64x:%I64x with %I64x:%I64x\n",
			    &cwspath, fid[0], fid[1], (*id)[0], (*id)[1]);
#endif
		    if (fid[0] == (*id)[0] && fid[1] == (*id)[1]) {
#ifdef DEBUG
			wprintf(L"Found file %wZ, %I64x:%I64x\n",
				&cwspath, fid[0], fid[1]);
#endif

			status = STATUS_SUCCESS;

			if (access != FILE_GENERIC_READ) {
			    HANDLE nfd;
			    err = NtOpenFile(&nfd,
					     SYNCHRONIZE | access,
					     &objattrs,
					     &ios,
					     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					     FILE_SYNCHRONOUS_IO_ALERT);

			    if (err == STATUS_SUCCESS) {
				xFsClose(fd);
				fd = nfd;
			    }
			}
			*fhdl = fd;
		    } else if (p->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			status = _FsGetHandleById(fd, id, access, fhdl);
		    }
		}

		if (status == STATUS_SUCCESS)
		    return status;

		xFsClose(fd);
	    }

	    if (p->NextEntryOffset == 0)
		break;

	    p = (PFILE_DIRECTORY_INFORMATION) (((PBYTE)p) + p->NextEntryOffset);
	}
    }

    return status;
}

NTSTATUS
xFsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl)
{
    // open each entry and get its object id
    HANDLE fd;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    IO_STATUS_BLOCK ios;
    NTSTATUS err;

    cwspath.Buffer = L"";
    cwspath.Length = 0;
    cwspath.MaximumLength = 0;

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
			       root, NULL);

    // todo: what if the file is nonsharable @ this time?
    err = NtOpenFile(&fd,
		     SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
		     &objattrs,
		     &ios,
		     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		     FILE_SYNCHRONOUS_IO_ALERT);

    if (err != STATUS_SUCCESS) {
	FsLogError(("Unable to duplicate handle for search %x\n", err));
	return err;
    }

    err = _FsGetHandleById(fd, id, access, fhdl);

    xFsClose(fd);

    return err;

}

DWORD
xFsGetHandlePath(HANDLE fd, WCHAR *path, int *pathlen)
{

    NTSTATUS status;
    IO_STATUS_BLOCK iostatus;
    struct {
	FILE_NAME_INFORMATION x;
	WCHAR	buf[MAXPATH];
    }info;

    *path = L'\0';
    *pathlen = 0;

    status = NtQueryInformationFile(fd, &iostatus,
				    (LPVOID) &info, sizeof(info),
				    FileNameInformation);

    if (status == STATUS_SUCCESS) {
	int k = info.x.FileNameLength / sizeof(WCHAR);
	info.x.FileName[k] = L'\0';
	wcscpy(path, info.x.FileName);
	*pathlen = k;
    }
    return status;
}

NTSTATUS
xFsGetPathById(HANDLE vfd, fs_id_t *id, WCHAR *name, int *name_len)
{
    NTSTATUS	err;
    HANDLE	fd;

    err = xFsGetHandleById(vfd, id, FILE_GENERIC_READ, &fd);
    if (err == STATUS_SUCCESS) {
	err = xFsGetHandlePath(fd, name, name_len);
	xFsClose(fd);
    }

    return err;
}


NTSTATUS
_xFsEnumTree(HANDLE hdl, int mode, PXFS_ENUM_CALLBACK callback, PVOID callback_arg)
{
    NTSTATUS err = STATUS_SUCCESS;
    IO_STATUS_BLOCK ios;
    BOOLEAN flag;
    ULONGLONG	buf[PAGESIZE/sizeof(ULONGLONG)];

    flag = TRUE;
    while (err == STATUS_SUCCESS) {
	PFILE_DIRECTORY_INFORMATION p;

	p = (PFILE_DIRECTORY_INFORMATION) buf;

	err = NtQueryDirectoryFile(hdl, NULL, NULL, NULL, &ios,
				   (LPVOID) buf, sizeof(buf),
				   FileDirectoryInformation, FALSE, NULL, flag);

	if (err != STATUS_SUCCESS) {
	    break;
	}
	flag = FALSE;

	while (err == STATUS_SUCCESS) {
	    BOOLEAN	skip = FALSE;

	    if (p->FileNameLength == 2 && p->FileName[0] == L'.' ||
		(p->FileNameLength == 4 && p->FileName[0] == L'.' && p->FileName[1] == L'.'))
		skip = TRUE;

	    // skip . and ..
	    if (skip == FALSE) {
		// traverse before
		if (mode & XFS_ENUM_FIRST) {
		    err = callback(callback_arg, hdl, p);
		}

		if ((mode & XFS_ENUM_DIR) && (p->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
		    HANDLE fd;
		    OBJECT_ATTRIBUTES objattrs;
		    UNICODE_STRING  cwspath;


		    cwspath.Buffer = p->FileName;
		    cwspath.Length = (USHORT) p->FileNameLength;
		    cwspath.MaximumLength = (USHORT) p->FileNameLength;

		    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
					       hdl, NULL);

		    // todo: what if the dir is nonsharable @ this time?
		    err = NtOpenFile(&fd,
				     SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
				     &objattrs,
				     &ios,
				     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
				     FILE_SYNCHRONOUS_IO_ALERT);

		    if (err == STATUS_SUCCESS) {
			err = _xFsEnumTree(fd, mode, callback, callback_arg);
			NtClose(fd);
		    } else {
			FsLog(("Open failed on traverse dir %S %x\n", p->FileName, err));
		    }
		}

		// traverse after
		if (mode & XFS_ENUM_LAST) {
		    err = callback(callback_arg, hdl, p);
		}
	    }

	    if (p->NextEntryOffset == 0)
		break;

	    p = (PFILE_DIRECTORY_INFORMATION) (((PBYTE)p) + p->NextEntryOffset);
	}
    }

    if (err == STATUS_NO_MORE_FILES)
	err = STATUS_SUCCESS;
    return err;

}

NTSTATUS
xFsRemove(PVOID arg, HANDLE root, PFILE_DIRECTORY_INFORMATION item)
{
    NTSTATUS err;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    cwspath.Buffer = item->FileName;
    cwspath.Length = (USHORT) item->FileNameLength;
    cwspath.MaximumLength = (USHORT) item->FileNameLength;
    
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);


    // if the file is marked read-only, we have to clear it first before we delete
    if (item->FileAttributes & FILE_ATTRIBUTE_READONLY) {
	// clear this bit in order to delete
	HANDLE	fd;
	IO_STATUS_BLOCK iostatus;

	err = NtOpenFile(&fd,
			 SYNCHRONIZE | (STANDARD_RIGHTS_WRITE | FILE_WRITE_ATTRIBUTES),
			 &objattrs,
			 &iostatus,
			 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			 FILE_SYNCHRONOUS_IO_ALERT);

	if (err == STATUS_SUCCESS) {
	    FILE_BASIC_INFORMATION attr;

	    memset((PVOID) &attr, 0, sizeof(attr));
	    attr.FileAttributes = item->FileAttributes & ~FILE_ATTRIBUTE_READONLY;

	    err = NtSetInformationFile(fd, &iostatus,
				       (PVOID) &attr, sizeof(attr),
				       FileBasicInformation);
	    xFsClose(fd);
	}
    }


    err = NtDeleteFile(&objattrs);

    FsLog(("xFsRemove: '%wZ' err 0x%x\n", &cwspath, err));

    return err;
}

NTSTATUS
xFsCopy(PVOID arg, HANDLE root, PFILE_DIRECTORY_INFORMATION item)
{
    WCHAR *name = item->FileName;
    int name_len = item->FileNameLength / sizeof(WCHAR);
    NTSTATUS err;

    err = xFsDupFile(root, (HANDLE) arg, name, name_len, TRUE);

    return err;
}

// copy all files from mvfd to vfd.
NTSTATUS
xFsCopyTree(HANDLE mvfd, HANDLE vfd)
{
    NTSTATUS err;

    // first, remove all files in vfd
    FsLog(("CopyTree: remove first\n"));
    err = _xFsEnumTree(vfd, XFS_ENUM_LAST|XFS_ENUM_DIR, xFsRemove, NULL);

    // copy files
    if (err == STATUS_SUCCESS) {
	FsLog(("CopyTree: copy second\n"));
	err = _xFsEnumTree(mvfd, XFS_ENUM_FIRST, xFsCopy, (PVOID) vfd);
    }

    FsLog(("CopyTree: exit %x\n", err));

    return err;
}

// delete all files 
NTSTATUS
xFsDeleteTree(HANDLE vfd)
{

    // remove all files in vfd
    return _xFsEnumTree(vfd, XFS_ENUM_LAST|XFS_ENUM_DIR, xFsRemove, NULL);

}

NTSTATUS
xFsTouch(PVOID arg, HANDLE root, PFILE_DIRECTORY_INFORMATION item)
{
    NTSTATUS err;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    cwspath.Buffer = item->FileName;
    cwspath.Length = (USHORT) item->FileNameLength;
    cwspath.MaximumLength = (USHORT) item->FileNameLength;
    
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);


    // if the file is marked read-only or directory then skip it
    if (!(item->FileAttributes & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY))) {
	HANDLE	fd;
	IO_STATUS_BLOCK iostatus;

	err = NtOpenFile(&fd,
			 SYNCHRONIZE | FILE_GENERIC_READ,
			 &objattrs,
			 &iostatus,
			 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			 FILE_SYNCHRONOUS_IO_ALERT);

	if (err == STATUS_SUCCESS) {
	    char	buf[1];
	    LARGE_INTEGER	off;

	    off.QuadPart = 0;
	    err = NtReadFile(fd, NULL, NULL, NULL, &iostatus, buf, sizeof(buf), &off, NULL);

	    xFsClose(fd);
	    if (err != STATUS_SUCCESS)
		FsLogError(("xFsTouch: read '%wZ' failed 0x%x\n", &cwspath, err));
	} else {
	    FsLogError(("xFsTouch: open '%wZ' failed 0x%x\n", &cwspath, err));
	}
    }


    return STATUS_SUCCESS;
}

// touch each file
NTSTATUS
xFsTouchTree(HANDLE mvfd)
{

    return _xFsEnumTree(mvfd, XFS_ENUM_LAST | XFS_ENUM_DIR, xFsTouch, NULL);
}

NTSTATUS
xFsDupFile(HANDLE mvfd, HANDLE vfd, WCHAR *name, int name_len, BOOLEAN flag)
{
    NTSTATUS err;
    HANDLE mfd, fd;
    IO_STATUS_BLOCK ios;
    fs_id_t	*fs_id;
    fs_ea_t xattr;
    FILE_NETWORK_OPEN_INFORMATION	attr;
    FILE_BASIC_INFORMATION	new_attr;
    char	buf[PAGESIZE];

    // Create file on vfd with same name and attrib and extended attributes (object id)
    // If we created a directory, we are done.
    // Otherwise, copy all data from source file to new file


    // Open master file
    err = xFsOpenRD(&mfd, mvfd, name, name_len); 
    if (err != STATUS_SUCCESS) {
	// We couldn't open source file. If file is locked we have to use the handle we
	// already have. todo:
	FsLog(("FsDupFile: unable to open source '%S' err %x\n", name, err));
	return err;
    }

    // Query name on mvfd and obtain all attributes.
    err = xFsQueryAttr(mfd, &attr);
    if (err != STATUS_SUCCESS) {
	FsLog(("FsDupFile: unable to query source '%S' err %x\n", name, err));
	xFsClose(mfd);
	return err;
    }

    // get objectid and set the ea stuff
    FsInitEa(&xattr);
    FsInitEaFid(&xattr, fs_id);

    err = xFsQueryObjectId(mfd, (PVOID) fs_id);
    if (err == STATUS_SUCCESS) {
	UINT32 disp = FILE_CREATE;

	err = xFsCreate(&fd, vfd, name, name_len,
			(attr.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ? 
			 FILE_DIRECTORY_FILE : 0),
			attr.FileAttributes,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			&disp,
			FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE,
			(PVOID) &xattr,
			sizeof(xattr));

	if (err == STATUS_SUCCESS) {
	    assert(disp == FILE_CREATED);

	    // if file we need to copy data and set access flags
	    if (!(attr.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
		int buflen = sizeof(buf);
		LARGE_INTEGER off;

		off.LowPart = 0;
		off.HighPart = 0;
		while (1) {
		    err = NtReadFile(mfd, NULL, NULL, NULL, &ios, buf, buflen, &off, NULL);
		    if (err == STATUS_PENDING) {
			EventWait(mfd);
			err = ios.Status;
		    }
		    if (err != STATUS_SUCCESS) {
			break;
		    }
		    err = NtWriteFile(fd, NULL, NULL, NULL, &ios, buf, (ULONG)ios.Information,
				      &off, NULL);
		    if (err == STATUS_PENDING) {
			EventWait(fd);
			err = ios.Status;
		    }
		    
		    if (err != STATUS_SUCCESS) {
			break;
		    }
		    off.LowPart += (ULONG) ios.Information;
		}

		// adjust return code
		if (err == STATUS_END_OF_FILE) {
		    err = STATUS_SUCCESS;
		}

		FsLog(("FsDupFile: '%S' err %x\n", name, err));
	    } else if (flag == TRUE) {
		// call enum again
		err = _xFsEnumTree(mfd, XFS_ENUM_FIRST, xFsCopy, (PVOID) fd);
	    }

	    // set new file attributes
	    new_attr.CreationTime = attr.CreationTime;
	    new_attr.LastAccessTime = attr.LastAccessTime;
	    new_attr.LastWriteTime = attr.LastWriteTime;
	    new_attr.ChangeTime = attr.ChangeTime;
	    new_attr.FileAttributes = attr.FileAttributes;
	    err = xFsSetAttr(fd, &new_attr);

	    // close new file
	    xFsClose(fd);

	}
	if (err != STATUS_SUCCESS)
	    FsLog(("FsDupFile: unable to open/reset attr '%S' err %x\n", name, err));
    } else {
	FsLog(("FsDupFile: unable to query sid '%S' err %x, skip!\n", name, err));
	err = STATUS_SUCCESS;
    }

    // close master file
    xFsClose(mfd);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\fsutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsutil.h

Abstract:

    Forward declarations

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#ifndef _FS_UTIL_H
#define _FS_UTIL_H

NTSTATUS
xFsCreate(HANDLE *fd, HANDLE root, LPWSTR name, int len, UINT32 flag,
	  UINT32 attrib, UINT32 share, UINT32 *disp, UINT32 access,
	  PVOID eabuf, int easz);

NTSTATUS
xFsOpen(HANDLE *fd, HANDLE root, LPWSTR name, int len, UINT32 access,
	UINT32 share, UINT32 flags);

#define xFsClose(fd)	NtClose(fd)

NTSTATUS
xFsQueryObjectId(HANDLE fd, PVOID id);

NTSTATUS
xFsDelete(HANDLE root, LPWSTR name, int len);

NTSTATUS
xFsQueryObjectId(HANDLE fd, PVOID id);

NTSTATUS
xFsQueryAttrName(HANDLE root, LPWSTR name, int len, FILE_NETWORK_OPEN_INFORMATION *attr);

NTSTATUS
xFsRename(HANDLE fh, HANDLE root, LPWSTR dname, int dlen);

NTSTATUS
xFsDupFile(HANDLE mvfd, HANDLE tvfd, LPWSTR name, int len, BOOLEAN flag);

NTSTATUS
xFsSetAttr(HANDLE fd, FILE_BASIC_INFORMATION *attr);

NTSTATUS
xFsQueryAttr(HANDLE fd, FILE_NETWORK_OPEN_INFORMATION *attr);

NTSTATUS
xFsReadDir(HANDLE fd, PVOID buf, int *rlen, BOOLEAN flag);

NTSTATUS
xFsCopyTree(HANDLE mvfd, HANDLE vfd);

NTSTATUS
xFsDeleteTree(HANDLE vfd);

NTSTATUS
xFsTouchTree(HANDLE vfd);

#ifdef FS_P_H

extern 
LPWSTR
xFsBuildRelativePath(VolInfo_t *vol, int nid, LPWSTR path);

NTSTATUS
xFsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl);

DWORD
xFsGetHandlePath(HANDLE fd, LPWSTR path, int *pathlen);

NTSTATUS
xFsGetPathById(HANDLE vfd, fs_id_t *id, LPWSTR name, int *name_len);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\majoritynodeset.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MajorityNodeSet.c

Abstract:

    Resource DLL for Majority Node Set (MajorityNodeSet).

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

    George Potts (gpotts) 05, 17, 2001
    Renamed from Node Quorum to Majority Node Set 

--*/

#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#pragma warning( disable : 4115 )  // named type definition in parentheses
#pragma warning( disable : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )  // nonstandard extension used : bit field types other than int

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>

#pragma warning( default : 4214 )  // nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )  // named type definition in parentheses

#include <clusapi.h>
#include <clusudef.h>
#include <resapi.h>
#include <stdio.h>
#include "clusres.h"
#include "fsapi.h"
#include "crs.h"        // for crssetforcedquorumsize()

//
// Type and constant definitions.
//
#ifdef STANDALONE_DLL

#define MajorityNodeSetDllEntryPoint DllEntryPoint
#define MNS_RESNAME  L"Majority Node Set"

// Event Logging routine.
PLOG_EVENT_ROUTINE g_LogEvent = NULL;
// Resource Status routine for pending Online and Offline calls.
PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

#else

// Event Logging routine.
#define g_LogEvent ClusResLogEvent
// Resource Status routine for pending Online and Offline calls.
#define g_SetResourceStatus ClusResSetResourceStatus
#endif // end of standalone_DLL

// ADDPARAM: Add new parameters here.
#define PARAM_NAME__PATH L"Path"
#define PARAM_NAME__ALLOWREMOTEACCESS L"AllowRemoteAccess"
#define PARAM_NAME__DISKLIST L"DiskList"

#define PARAM_MIN__ALLOWREMOTEACCESS     (0)
#define PARAM_MAX__ALLOWREMOTEACCESS     (4294967295)
#define PARAM_DEFAULT__ALLOWREMOTEACCESS (0)

// ADDPARAM: Add new parameters here.
typedef struct _MNS_PARAMS {
    PWSTR           Path;
    DWORD           AllowRemoteAccess;
    PWSTR           DiskList;
    DWORD           DiskListSize;
} MNS_PARAMS, *PMNS_PARAMS;

// Once we have UNC support in service, we need to disable this flag
// #define USE_DRIVE_LETTER 1

typedef struct _MNS_SETUP {
    LPWSTR      Path;

#ifdef USE_DRIVE_LETTER
    WCHAR       DriveLetter[10];
#else
#define DriveLetter Path
#endif

    LPWSTR      DiskList[FsMaxNodes];
    DWORD       DiskListSz;
    DWORD       Nic;
    LPWSTR      Transport;
    DWORD       ArbTime;
} MNS_SETUP, *PMNS_SETUP;

typedef struct _MNS_RESOURCE {
    RESID                   ResId; // for validation
    MNS_PARAMS              Params;
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    LPWSTR                  ResourceName;
    CLUS_WORKER             OnlineThread;
    CLUS_WORKER             ReserveThread;
    CLUSTER_RESOURCE_STATE  State;
    PQUORUM_RESOURCE_LOST   LostQuorumResource;

    CRITICAL_SECTION        Lock;
    HANDLE                  Event;
    HANDLE                  ArbThread;

    PVOID                   SrvHdl;
    PVOID                   FsHdl;
    PVOID                   VolHdl;

    MNS_SETUP        Setup;
} MNS_RESOURCE, *PMNS_RESOURCE;


#define MNS_ONLINE_PERIOD    (4 * 1000)
#define MNS_RESERVE_PERIOD   (4 * 1000)

//
// Global data.
//
RESOURCE_HANDLE         g_resHdl = 0;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE MajorityNodeSetFunctionTable;

//
// MajorityNodeSet resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
MajorityNodeSetResourcePrivateProperties[] = {
    { PARAM_NAME__PATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(MNS_PARAMS,Path) },
    { PARAM_NAME__ALLOWREMOTEACCESS, NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__ALLOWREMOTEACCESS, PARAM_MIN__ALLOWREMOTEACCESS, PARAM_MAX__ALLOWREMOTEACCESS, 0, FIELD_OFFSET(MNS_PARAMS,AllowRemoteAccess) },
    { PARAM_NAME__DISKLIST, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0, FIELD_OFFSET(MNS_PARAMS,DiskList) },
    { 0 }
};

#define MajorityNodeSetIoctlPhase1   CLUSCTL_USER_CODE(0, CLUS_OBJECT_RESOURCE)

//
// Function prototypes.
//
extern
DWORD
SetupIoctlQuorumResource(LPWSTR ResType, DWORD ControlCode);

extern
DWORD
SetupIsQuorum(IN LPWSTR ResourceName);

extern
DWORD
SetupDelete(IN LPWSTR Path);

extern
DWORD
SetupStart(LPWSTR ResourceName, LPWSTR *SrvPath,
       LPWSTR *DiskList, DWORD *DiskListSize,
       DWORD *NicId, LPWSTR *Transport, DWORD *ArbTime);

extern
DWORD
SetupTree(
    IN LPTSTR TreeName,
    IN LPTSTR DlBuf,
    IN OUT DWORD *DlBufSz,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SecurityDescriptor OPTIONAL
    );

RESID
WINAPI
MajorityNodeSetOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
MajorityNodeSetClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
MajorityNodeSetOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
MajorityNodeSetOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    );

DWORD
WINAPI
MajorityNodeSetOffline(
    IN RESID ResourceId
    );

VOID
WINAPI
MajorityNodeSetTerminate(
    IN RESID ResourceId
    );

DWORD
MajorityNodeSetDoTerminate(
    IN PMNS_RESOURCE ResourceEntry
    );

BOOL
WINAPI
MajorityNodeSetLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
MajorityNodeSetIsAlive(
    IN RESID ResourceId
    );

BOOL
MajorityNodeSetCheckIsAlive(
    IN PMNS_RESOURCE ResourceEntry
    );

DWORD
WINAPI
MajorityNodeSetResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
MajorityNodeSetGetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
MajorityNodeSetValidatePrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PMNS_PARAMS Params
    );

DWORD
MajorityNodeSetSetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
MajorityNodeSetGetDiskInfo(
    IN LPWSTR  lpszPath,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    ) ;

DWORD
WINAPI
MajorityNodeSetReserveThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    );


DWORD
WINAPI
MajorityNodeSetRelease(
    IN RESID ResourceId
    );

DWORD
MajorityNodeSetReadDefaultValues(
    PMNS_RESOURCE ResourceEntry
    );


BOOLEAN
WINAPI
MajorityNodeSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);

} // DllMain

#ifdef STANDALONE_DLL

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( lstrcmpiW( ResourceType, MNS_RESNAME ) != 0 ) {
        (LogEvent)(
            NULL,
            LOG_ERROR,
            L"MajorityNodeSet: %1 %2.\n", ResourceType, MNS_RESNAME);

        return(ERROR_MOD_NOT_FOUND);
    }

    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &MajorityNodeSetFunctionTable;

    return(ERROR_SUCCESS);

} // Startup

#endif


RESID
WINAPI
MajorityNodeSetOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for MajorityNodeSet resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        MajorityNodeSetStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;
    PMNS_RESOURCE resourceEntry = NULL;

    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
				L"Parameters",
				KEY_READ,
				&parametersKey);

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Allocate a resource entry.
    //

    resourceEntry = (PMNS_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(MNS_RESOURCE) );
    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry..
    //

    ZeroMemory( resourceEntry, sizeof(MNS_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;

    //
    // Save the name of the resource.
    //
    resourceEntry->ResourceName = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceName ) + 1) * sizeof(WCHAR) );
    if ( resourceEntry->ResourceName == NULL ) {
        status = GetLastError();
        goto exit;
    }
    lstrcpyW( resourceEntry->ResourceName, ResourceName );

    // todo: get ride off this hack. See bug # 389483
    if (g_resHdl == 0)
	g_resHdl = resourceEntry->ResourceHandle;

    // initialize lock
    InitializeCriticalSection(&resourceEntry->Lock);

    // create event
    resourceEntry->Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // Setup stuff
    //
    memset(&resourceEntry->Setup, 0, sizeof(resourceEntry->Setup));

    //
    // If we are the quorum, we need to make sure the share has been created. So,
    // we call setup now.
    //

    // read from private properties
    status = MajorityNodeSetReadDefaultValues(resourceEntry);
    if (status != ERROR_SUCCESS || resourceEntry->Setup.DiskListSz == 0) {
	// read from our own setup stuff
	status = SetupStart(resourceEntry->ResourceName,
			    &resourceEntry->Setup.Path,
			    resourceEntry->Setup.DiskList,
			    &resourceEntry->Setup.DiskListSz,
			    &resourceEntry->Setup.Nic,
			    &resourceEntry->Setup.Transport,
			    &resourceEntry->Setup.ArbTime);

	(g_LogEvent)(

	    resourceEntry->ResourceHandle,
	    LOG_INFORMATION,
	    L"Open %1 setup status %2!u!.\n", ResourceName, status);
    }

    // init fs
    if (status == ERROR_SUCCESS) {

	status = FsInit((PVOID)resourceEntry, &resourceEntry->FsHdl);


	(g_LogEvent)(
	    resourceEntry->ResourceHandle,
	    LOG_INFORMATION,
	    L"Open %1 fs status %2!u!.\n", ResourceName, status);
    }

    // init srv
    if (status == ERROR_SUCCESS) {
	status = SrvInit((PVOID)resourceEntry, resourceEntry->FsHdl,
			 &resourceEntry->SrvHdl);
	(g_LogEvent)(
	    resourceEntry->ResourceHandle,
	    LOG_INFORMATION,
	    L"Open %1 srv status %2!u!.\n", ResourceName, status);
    }

    if (status == ERROR_SUCCESS) {
	resid = (RESID)resourceEntry;

	//
	// Startup for the resource.
	//
    }

 exit:

    (g_LogEvent)(
	ResourceHandle,
	LOG_INFORMATION,
	L"Open %1 status %2!u!.\n", ResourceName, status);

    if ( resid == 0 ) {
	if (resourceEntry)
	    MajorityNodeSetClose((RESID)resourceEntry);
	else if ( parametersKey != NULL ) {
	    ClusterRegCloseKey( parametersKey );
	}
    }

    if ( status != ERROR_SUCCESS ) {
	SetLastError( status );
    }

    return(resid);

} // MajorityNodeSetOpen



VOID
WINAPI
MajorityNodeSetClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for MajorityNodeSet resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }


    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Hack: Check if we are online, just return. This must be the RPC run-down stuff
    //
    if (resourceEntry->VolHdl && FsIsOnline(resourceEntry->VolHdl) != ERROR_BUSY)
	return;

    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    //
    // Sync any arb threads
    //
    if (resourceEntry->ArbThread) {
	WaitForSingleObject(resourceEntry->ArbThread, INFINITE);
	CloseHandle(resourceEntry->ArbThread);
	resourceEntry->ArbThread = NULL;
    }

    //
    // Deallocate the resource entry.
    //
    if (resourceEntry->SrvHdl) {
	SrvExit(resourceEntry->SrvHdl);
    }

    if (resourceEntry->FsHdl) {
	FsExit(resourceEntry->FsHdl);
    }

    //
    // Deallocate setup stuff
    //
    if (resourceEntry->Setup.Path) {
	LocalFree( resourceEntry->Setup.Path);
    }

    if (resourceEntry->Setup.DiskList) {
	DWORD i;
	for (i = 0; i < FsMaxNodes; i++) {
	    if (resourceEntry->Setup.DiskList[i] != NULL)
		LocalFree(resourceEntry->Setup.DiskList[i]);
	}
    }

    if (resourceEntry->Setup.Transport) {
	LocalFree( resourceEntry->Setup.Transport);
    }

    // ADDPARAM: Add new parameters here.
    if ( resourceEntry->Params.Path )
	LocalFree( resourceEntry->Params.Path );

    if ( resourceEntry->Params.DiskList )
	LocalFree( resourceEntry->Params.DiskList );

    
    if ( resourceEntry->ResourceName )
	LocalFree( resourceEntry->ResourceName );

    LocalFree( resourceEntry );

} // MajorityNodeSetClose



DWORD
WINAPI
MajorityNodeSetOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for MajorityNodeSet resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{
    PMNS_RESOURCE resourceEntry = NULL;
    DWORD               status;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }


    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );


    resourceEntry->State = ClusterResourceOffline;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               (PWORKER_START_ROUTINE)MajorityNodeSetOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // MajorityNodeSetOnline


DWORD
MajorityNodeSetReadDefaultValues(PMNS_RESOURCE ResourceEntry)
{
    DWORD status;
    MNS_PARAMS	Params;
    LPWSTR      nameOfPropInError, sharename;

    ZeroMemory( &Params, sizeof(Params));

    //
    // Read parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   MajorityNodeSetResourcePrivateProperties,
                                                   (LPBYTE) &Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto exit;
    }

    // get server and share names
    // we need to validate that the user specified '\\srvname\share'
    if (Params.Path != NULL) {
	if (Params.Path[0] != L'\\' || Params.Path[1] != L'\\' || lstrlenW(Params.Path) < 3) {
	    (g_LogEvent)(
		ResourceEntry->ResourceHandle,
		LOG_ERROR,
		L"Invalid path property '%1', expecting server name\n",
		Params.Path);
	    status = ERROR_INVALID_PARAMETER;
	    goto exit;
	}


	sharename = wcschr(&Params.Path[2], L'\\');
	if (sharename == NULL || sharename[1] == L'\0') {
	    (g_LogEvent)(
		ResourceEntry->ResourceHandle,
		LOG_ERROR,
		L"Invalid path property '%1', expecting share name\n",
		Params.Path);
	    status = ERROR_INVALID_PARAMETER;
	    goto exit;
	}

	
	if (ResourceEntry->Setup.Path != NULL) {
	    LocalFree(ResourceEntry->Setup.Path);
	}
	ResourceEntry->Setup.Path = Params.Path;
	Params.Path = NULL;
    }

    // If we have a disklist we need to build it now
    if (Params.DiskList != NULL) {
	LPWSTR	p, sp, UncList[FsMaxNodes];
	DWORD	cnt, i;

	memset(UncList, 0, sizeof(UncList));

	p = Params.DiskList;

	cnt = 0;
	UncList[cnt++] = NULL;

	for (i = 0; p != NULL && *p != L'\0' && i < Params.DiskListSize; ) {
	    DWORD sz, len;

	    len = 0;
	    // validate format as '\\srvname\share'
	    if (p[0] == L'\\' && p[1] == L'\\' && p[2] != L'\0') {
		if (wcschr(&p[2],L'\\') != NULL) {
		    len = wcslen(p)+wcslen(L"UNC")+1;
		}
	    } else if (p[0] != L'\0' && iswalpha(p[0]) && p[1] == L':') {
		len = wcslen(p)+1;
	    } else {
		status = ERROR_INVALID_PARAMETER;
	    }

	    if (len > 0) {
		sp = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * len);
		if (sp == NULL) {
		    status = ERROR_NOT_ENOUGH_MEMORY;
		    len = 0;
		}
	    }

	    if (len == 0) {
		g_LogEvent(ResourceEntry->ResourceHandle,
			   LOG_ERROR,
			   L"LoadParams error %1!u! '%2'\n", status, p);

		// we free any stuff we have already allocated and goto exit
		while (cnt > 1) {
		    cnt--;
		    LocalFree(UncList[cnt]);
		}
		goto exit;
	    }

	    if (p[0] == L'\\') {
		wcscpy(sp, L"UNC\\");
		wcscat(sp, &p[2]);
	    } else {
		wcscpy(sp, p);
	    }

	    UncList[cnt] = sp;
	    cnt++;

	    len = wcslen(p)+1;
	    i += (len * sizeof(WCHAR));
	    p += len;
	}

	if (cnt > 1) {
	    // update count
	    ResourceEntry->Setup.DiskListSz = cnt-1;

	    // we copy and update our setup stuff now. We can do this because the fs
	    // is idle, otherwise freeing the old strings can cause av
	    for (i = 0; i < FsMaxNodes; i++) {
		if (ResourceEntry->Setup.DiskList[i]) {
		    LocalFree(ResourceEntry->Setup.DiskList[i]);
		}
		ResourceEntry->Setup.DiskList[i] = UncList[i];
	    }
	}
    }

 exit:

    if (Params.Path) {
	LocalFree(Params.Path);
    }

    if (Params.DiskList) {
	LocalFree(Params.DiskList);
    }

    return status;
}

DWORD
MajorityNodeSetDoRegister(IN PMNS_RESOURCE ResourceEntry)
{
    DWORD	status = ERROR_SUCCESS;

    if (ResourceEntry->VolHdl == NULL) {
	// if we have no volume handle, read config now

	// read from private properties
	status = MajorityNodeSetReadDefaultValues(ResourceEntry);

	if (status != ERROR_SUCCESS || ResourceEntry->Setup.DiskListSz == 0) {

	    // read from our own setup stuff
	    status = SetupStart(ResourceEntry->ResourceName,
				&ResourceEntry->Setup.Path,
				ResourceEntry->Setup.DiskList,
				&ResourceEntry->Setup.DiskListSz,
				&ResourceEntry->Setup.Nic,
				&ResourceEntry->Setup.Transport,
				&ResourceEntry->Setup.ArbTime);

	}

	
	if (status == ERROR_SUCCESS) {
	    LPWSTR ShareName, IpcName;


	    // register volume
	    ShareName = ResourceEntry->Setup.Path + 2;
	    ShareName = wcschr(ShareName, L'\\');
	    ASSERT(ShareName);
	    ShareName++;
	    ASSERT(*ShareName != L'\0');
	    
	    IpcName = ResourceEntry->Setup.DiskList[0];
	    if (IpcName == NULL) {
		// We use first replica. This must be the case when our private property is set
		IpcName = ResourceEntry->Setup.DiskList[1];
	    }
	    ASSERT(IpcName);
	    status = FsRegister(ResourceEntry->FsHdl,
				ShareName,	// share name
				IpcName, // ipc local name
				ResourceEntry->Setup.DiskList,	// replica set
				ResourceEntry->Setup.DiskListSz,	// num of replicas
				&ResourceEntry->VolHdl);

	}
    }


    return status;

}




DWORD
WINAPI
MajorityNodeSetOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    ResourceEntry - A pointer to the MNS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    RESOURCE_STATUS     resourceStatus;
    DWORD               i, status = ERROR_SUCCESS;

    ASSERT(ResourceEntry != NULL);

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    (g_LogEvent)(
	ResourceEntry->ResourceHandle,
	LOG_INFORMATION,
	L"onlinethread request.\n"
	);

    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);

    status = MajorityNodeSetDoRegister(ResourceEntry);

    if (status == ERROR_SUCCESS) {
	HANDLE th;
	ASSERT(ResourceEntry->VolHdl);

	if (ResourceEntry->ArbThread != NULL) {
	    // check if this is an old completed handle
	    status = WaitForSingleObject(ResourceEntry->ArbThread, 0);
	    if (status != WAIT_TIMEOUT) {
		CloseHandle(ResourceEntry->ArbThread);
		ResourceEntry->ArbThread = NULL;
	    }
	}

	if (ResourceEntry->ArbThread == NULL) {
	    // we need to arbitrate now
	    status = FsArbitrate(ResourceEntry->VolHdl, ResourceEntry->Event,
				 &ResourceEntry->ArbThread);
	    ASSERT(status != ERROR_CANCELLED);
	} else {
	    status = ERROR_IO_PENDING; // arb in progress already
	}

	// drop the lock
	LeaveCriticalSection(&ResourceEntry->Lock);

	th = ResourceEntry->ArbThread;
	if (status == ERROR_IO_PENDING || status == ERROR_PATH_BUSY) {
	    ASSERT(th != NULL);

	    do {
		// inform rcmon that we are working
		resourceStatus.ResourceState = ClusterResourceOnlinePending;
		resourceStatus.CheckPoint++;
		g_SetResourceStatus( ResourceEntry->ResourceHandle,
				     &resourceStatus );

		(g_LogEvent)(
		    ResourceEntry->ResourceHandle,
		    LOG_INFORMATION,
		    L"waiting for fs to online %1!u!.\n",
		    status );

		status = WaitForSingleObject(th, MNS_ONLINE_PERIOD);
	    } while (status == WAIT_TIMEOUT);

	    // arbitrate thread must have finished, check if we are online or not
	    status = FsIsOnline(ResourceEntry->VolHdl);
	}
    } else {
	// drop lock
	LeaveCriticalSection(&ResourceEntry->Lock);
    }

    if (status == ERROR_SUCCESS) {
	LPWSTR SrvName;
	// Online server
	SrvName = ResourceEntry->Setup.Path + 2;
	status = SrvOnline(ResourceEntry->SrvHdl, SrvName,
			   ResourceEntry->Setup.Nic);
    }


    //
    // Bring drive letter online
    //
    if (status == ERROR_SUCCESS) {
	PDWORD psz = NULL;
#ifdef USE_DRIVE_LETTER
	DWORD sz;
	sz = sizeof(ResourceEntry->Setup.DriveLetter);
	psz = &sz;
#endif
	// todo: create security descriptor and pass it onto tree
	status = SetupTree(ResourceEntry->Setup.Path,
			   ResourceEntry->Setup.DriveLetter, psz,
			   ResourceEntry->Setup.Transport, NULL);
#ifdef USE_DRIVE_LETTERxx
	if (status == ERROR_DUP_NAME)
	    status = ERROR_SUCCESS;
#endif
	if (status == ERROR_SUCCESS) {
#ifdef USE_DRIVE_LETTER
	    ResourceEntry->Setup.DriveLetter[sz] = L'\0';
#endif
	    (g_LogEvent)(
		ResourceEntry->ResourceHandle,
		LOG_INFORMATION,
		L"Resource %1 mounted on drive %2.\n",
		ResourceEntry->ResourceName,
		ResourceEntry->Setup.DriveLetter);
	} else {
	    (g_LogEvent)(
		ResourceEntry->ResourceHandle,
		LOG_ERROR,
		L"failed to setup tree path %1 drive %2 %3!u!.\n",
		ResourceEntry->Setup.Path,
		ResourceEntry->Setup.DriveLetter,
		status);
	}
    }

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error %1!u! bringing resource online.\n",
            status );
	resourceStatus.ResourceState = ClusterResourceFailed;
    } else {
        resourceStatus.ResourceState = ClusterResourceOnline;
    }

    // _ASSERTE(g_SetResourceStatus != NULL);
    g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
    ResourceEntry->State = resourceStatus.ResourceState;

    return(status);

} // MajorityNodeSetOnlineThread



DWORD
WINAPI
MajorityNodeSetOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for MajorityNodeSet resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }


    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );


    // TODO: Offline code

    // NOTE: Offline should try to shut the resource down gracefully, whereas
    // Terminate must shut the resource down immediately. If there are no
    // differences between a graceful shut down and an immediate shut down,
    // Terminate can be called for Offline, as it is below.  However, if there
    // are differences, replace the call to Terminate below with your graceful
    // shutdown code.

    //
    // Terminate the resource.
    //
    return MajorityNodeSetDoTerminate( resourceEntry );

} // MajorityNodeSetOffline



VOID
WINAPI
MajorityNodeSetTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for MajorityNodeSet resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );

    //
    // Terminate the resource.
    //
    MajorityNodeSetDoTerminate( resourceEntry );
    resourceEntry->State = ClusterResourceOffline;

} // MajorityNodeSetTerminate



DWORD
MajorityNodeSetDoTerminate(
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for MajorityNodeSet resources.

Arguments:

    ResourceEntry - Supplies resource entry for resource to be terminated

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;

    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);

    //
    // wait for arb thread if any
    //
    while (ResourceEntry->ArbThread) {
	HANDLE th = ResourceEntry->ArbThread;
	// drop lock
	LeaveCriticalSection(&ResourceEntry->Lock);

	WaitForSingleObject(ResourceEntry->ArbThread, INFINITE);

	// Get lock
	EnterCriticalSection(&ResourceEntry->Lock);
	if (th == ResourceEntry->ArbThread) {
	    CloseHandle(ResourceEntry->ArbThread);
	    ResourceEntry->ArbThread = NULL;
	}
    }

    // Drop lock
    LeaveCriticalSection(&ResourceEntry->Lock);

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );

    ClusWorkerTerminate( &ResourceEntry->ReserveThread );

    //
    // Terminate the resource.
    //
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offlining server.\n" );

    // Remove our network name now
    ASSERT(ResourceEntry->SrvHdl);
    SrvOffline(ResourceEntry->SrvHdl);

    // disconnect network connection
    status = WNetCancelConnection2(ResourceEntry->Setup.DriveLetter, FALSE, TRUE);
    if (status != NO_ERROR) {
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Failed to disconnect '%1' err %d.\n",
        ResourceEntry->Setup.DriveLetter, status);

    status = ERROR_SUCCESS;
    }

    // xxx: call our release since resmon won't do it
    MajorityNodeSetRelease((RESID)ResourceEntry);
    
    if ( status == ERROR_SUCCESS ) {
        ResourceEntry->State = ClusterResourceOffline;
    }


    return(status);

} // MajorityNodeSetDoTerminate



BOOL
WINAPI
MajorityNodeSetLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for MajorityNodeSet resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PMNS_RESOURCE  resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    return(MajorityNodeSetCheckIsAlive( resourceEntry ));

} // MajorityNodeSetLooksAlive



BOOL
WINAPI
MajorityNodeSetIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for MajorityNodeSet resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PMNS_RESOURCE  resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    //
    // Check to see if the resource is alive.
    //
    return(MajorityNodeSetCheckIsAlive( resourceEntry ));

} // MajorityNodeSetIsAlive



BOOL
MajorityNodeSetCheckIsAlive(
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Check to see if the resource is alive for MajorityNodeSet resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    DWORD err;
    HANDLE vol;

    //
    // Check to see if the resource is alive.
    //
    if (ResourceEntry->State == ClusterResourceFailed)
    return FALSE;

    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);
    vol = ResourceEntry->VolHdl;
    // Drop lock
    LeaveCriticalSection(&ResourceEntry->Lock);
    if (vol)
	err = FsIsOnline(vol);
    else
	err = ERROR_INVALID_PARAMETER;

    if (err != ERROR_SUCCESS && err != ERROR_IO_PENDING)
	return FALSE;
    return(TRUE);

} // MajorityNodeSetCheckIsAlive



DWORD
WINAPI
MajorityNodeSetResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for MajorityNodeSet resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PMNS_RESOURCE  resourceEntry;
    DWORD               required;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( MajorityNodeSetResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_FORCE_QUORUM:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
	    if (InBufferSize >= sizeof(CLUS_FORCE_QUORUM_INFO)) {
		PCLUS_FORCE_QUORUM_INFO p = (PCLUS_FORCE_QUORUM_INFO)InBuffer;
		DWORD mask = p->dwNodeBitMask;
		// count number of set bits.
		for (required = 0; mask != 0; mask = mask >> 1) {
		    if (mask & 0x1)
			required++;
		}

		(g_LogEvent)(
		    resourceEntry->ResourceHandle,
		    LOG_INFORMATION,
		    L"Setting quorum size = %1!u!.\n",
		    required);

		CrsSetForcedQuorumSize(required);
	    } else {
		status = ERROR_INVALID_PARAMETER;
	    }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_DELETE_REQUIRES_ALL_NODES;
                status = ERROR_SUCCESS;                    
            }
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
            //
            // If the local quorum drive letter cannot be found in the
            // path parameter, it defaults to "SystemDrive" environment 
            // variable.
            //
            status = MajorityNodeSetGetDiskInfo(resourceEntry->Setup.DriveLetter,
                                  &OutBuffer,
                                  OutBufferSize,
                                  BytesReturned);


            // Add the endmark.
            if ( OutBufferSize > *BytesReturned ) {
                OutBufferSize -= *BytesReturned;
            } else {
                OutBufferSize = 0;
            }
            *BytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize >= sizeof(CLUSPROP_SYNTAX) ) {
                PCLUSPROP_SYNTAX ptrSyntax = (PCLUSPROP_SYNTAX) OutBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            }
      
            break;
        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( MajorityNodeSetResourcePrivateProperties,
                                            (LPWSTR)OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = MajorityNodeSetGetPrivateResProperties( resourceEntry,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = MajorityNodeSetValidatePrivateResProperties( resourceEntry,
                                                           InBuffer,
                                                           InBufferSize,
                                                           NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = MajorityNodeSetSetPrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        case CLUSCTL_RESOURCE_DELETE:

	    // todo: we need to only do this if are using local defaults.
	    // we need to remove our share and directory now
	    if (resourceEntry->Setup.DiskList[0]) {
		// need to end IPC session in order to be able to delete
		// directory
		FsEnd(resourceEntry->FsHdl);
		status = SetupDelete(resourceEntry->Setup.DiskList[0]);
	    } else {
		status = ERROR_INVALID_PARAMETER;
	    }


	    (g_LogEvent)(
		resourceEntry->ResourceHandle,
		LOG_INFORMATION,
		L"Delete ResourceId = %1 err %2!u!.\n",
		resourceEntry->ResourceName, status);
        
	    break;

        // We need to find which node got added and adjust our
        // disklist. If we are online or we own quorum, then we need
        // to add this new replica to current filesystem set.
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
	    (g_LogEvent)(
		resourceEntry->ResourceHandle,
		LOG_INFORMATION,
		L"Recompute %1 quorum set changed, Install or Evict node = '%2'.\n",
		resourceEntry->ResourceName, (InBuffer ? InBuffer : L""));
	    // fall through

        case MajorityNodeSetIoctlPhase1:
        // we need to enumerate the current cluster and check it against
        // our disklist. we need to do this only if we actually have some
        if (1) {
	    MNS_SETUP Setup;

	    memset(&Setup, 0, sizeof(Setup));
	    status = SetupStart(resourceEntry->ResourceName,
				&Setup.Path,
				Setup.DiskList,
				&Setup.DiskListSz,
				&Setup.Nic,
				&Setup.Transport,
				&Setup.ArbTime);

	    if (status != ERROR_SUCCESS)
		return status;

	    EnterCriticalSection(&resourceEntry->Lock);
	    
	    if (resourceEntry->Setup.DiskListSz != Setup.DiskListSz)
		status = ERROR_INVALID_PARAMETER;
	    else {
		DWORD i;

		for (i = 0; i < FsMaxNodes; i++) {
		    if (Setup.DiskList[i] == NULL && resourceEntry->Setup.DiskList[i] == NULL)
			continue;
		    if (Setup.DiskList[i] == NULL || resourceEntry->Setup.DiskList[i] == NULL) {
			status = ERROR_INVALID_PARAMETER;
			break;
		    }
		    if (wcscmp(Setup.DiskList[i],
			       resourceEntry->Setup.DiskList[i])) {
			status = ERROR_INVALID_PARAMETER;
			break;
		    }
		}
	    }

	    if (status != ERROR_SUCCESS && resourceEntry->VolHdl) {
		// Update ourself now
		status = FsUpdateReplicaSet(resourceEntry->VolHdl,
					    Setup.DiskList,
					    Setup.DiskListSz);

		if (status == ERROR_SUCCESS) {
		    DWORD i;
		    // we need to free the current disklist, careful with slot 0
		    if (Setup.DiskList[0])
			LocalFree(Setup.DiskList[0]);
		    for (i = 1; i < FsMaxNodes; i++) {
			if (resourceEntry->Setup.DiskList[i]) {
			    LocalFree(resourceEntry->Setup.DiskList[i]);
			}
			resourceEntry->Setup.DiskList[i] = Setup.DiskList[i];
		    }
		}

		// set new arb timeout value
		resourceEntry->Setup.ArbTime = Setup.ArbTime;

		(g_LogEvent)(
		    resourceEntry->ResourceHandle,
		    LOG_WARNING,
		    L"Configuration change, new set size %1!u! status %2!u!.\n",
		    Setup.DiskListSz, status
		    );
	    }

	    LeaveCriticalSection(&resourceEntry->Lock);

		// free stuff
	    if (Setup.Path)
		LocalFree(Setup.Path);

	    if (Setup.Transport)
		LocalFree(Setup.Transport);

        }

        break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MajorityNodeSetResourceControl



DWORD
WINAPI
MajorityNodeSetResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for MajorityNodeSet resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( MajorityNodeSetResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( MajorityNodeSetResourcePrivateProperties,
                                            (LPWSTR)OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1:
	    status = SetupIoctlQuorumResource(CLUS_RESTYPE_NAME_MAJORITYNODESET,
					      MajorityNodeSetIoctlPhase1);
	    break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2:
	    status = ERROR_SUCCESS;
        break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MajorityNodeSetResourceTypeControl



DWORD
MajorityNodeSetGetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type MajorityNodeSet.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      MajorityNodeSetResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // MajorityNodeSetGetPrivateResProperties



DWORD
MajorityNodeSetValidatePrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PMNS_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type MajorityNodeSet.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    MNS_PARAMS   params;
    PMNS_PARAMS  pParams;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &params;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(MNS_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &ResourceEntry->Params,
                                       MajorityNodeSetResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( MajorityNodeSetResourcePrivateProperties,
                                         NULL,
                                         TRUE, // AllowUnknownProperties
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the parameter values.
        //
        // TODO: Code to validate interactions between parameters goes here.
	// we need to validate that the user specified '\\srvname\share'
	if (pParams->Path != NULL) {
	    if (pParams->Path[0] != L'\\' || pParams->Path[1] != L'\\' || lstrlenW(pParams->Path) < 3) {
		status = ERROR_INVALID_PARAMETER;
	    } else {
		LPWSTR sharename;

		sharename = wcschr(&pParams->Path[2], L'\\');
		if (sharename == NULL || sharename[1] == L'\0') {
		    status = ERROR_INVALID_PARAMETER;
		}
	    }

	}

	// we need to validate user specified disklist 'drive:\path or \\srv\path'
	if (pParams->DiskList == NULL) {
	    DWORD cnt = 0, i, len;
	    LPWSTR p;

	    p = pParams->DiskList;

	    for (i = 0; p != NULL && *p != L'\0' && i < pParams->DiskListSize; ) {

		// validate format as '\\srvname\share'
		if (p[0] == L'\\' && p[1] == L'\\' && p[2] != L'\0') {
		    if (wcschr(&p[2],L'\\') == NULL) {
			status = ERROR_INVALID_PARAMETER;
		    }
		} else if (p[0] == L'\0' || !iswalpha(p[0]) || p[1] != L':' || p[2] != L'\\') {
		    status = ERROR_INVALID_PARAMETER;
		}

		if (status != ERROR_INVALID_PARAMETER)
		    break;

		cnt++;
		len = wcslen(p) + 1;
		i += (len * sizeof(WCHAR));
		p += len;
	    }

	    if (cnt == 0)
		status = ERROR_INVALID_PARAMETER;
	}
    }

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   MajorityNodeSetResourcePrivateProperties );
    }

    return status;

} // MajorityNodeSetValidatePrivateResProperties



DWORD
MajorityNodeSetSetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type MajorityNodeSet.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    MNS_PARAMS   params;

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    ZeroMemory( &params, sizeof(params));
    status = MajorityNodeSetValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, &params );
    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   MajorityNodeSetResourcePrivateProperties );
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               MajorityNodeSetResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               MajorityNodeSetResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    // TODO: Modify the code below if your resource can handle
    // changes to properties while it is still online.
    if ( status == ERROR_SUCCESS ) {
        if ( ResourceEntry->State == ClusterResourceOnline ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else if ( ResourceEntry->State == ClusterResourceOnlinePending ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // MajorityNodeSetSetPrivateResProperties

DWORD
WINAPI
MajorityNodeSetReserveThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    ResourceEntry - A pointer to the MNS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    DWORD               status = ERROR_SUCCESS;


    //
    // todo: this should wait on a notify port and listen for 
    //  1- New nodes added to the cluster.
    //  2- Nodes removed from the cluster.
    //  3- Network priority changes.
    //  4- Network binding (added, removed, state) changes.
    //
    // check if we are being killed
    do {
	if (ResourceEntry->State != ClusterResourceFailed) {
	    HANDLE vol;
	    // don't hold any locks as not to hold back an arb
	    EnterCriticalSection(&ResourceEntry->Lock);
	    vol = ResourceEntry->VolHdl;
	    // Drop lock
	    LeaveCriticalSection(&ResourceEntry->Lock);
	    if (vol)
		status = FsReserve(vol);
	} else {
	    status = ERROR_INVALID_PARAMETER;
	}

	if (status != ERROR_SUCCESS) {
	    PQUORUM_RESOURCE_LOST   func;

	    (g_LogEvent)(
		ResourceEntry->ResourceHandle,
		LOG_ERROR,
		L"Reserve thread failed status %1!u!, resource '%2'.\n",
		status, ResourceEntry->ResourceName);

	    EnterCriticalSection(&ResourceEntry->Lock);
	    func = ResourceEntry->LostQuorumResource;
	    LeaveCriticalSection(&ResourceEntry->Lock);

	    if (func) {
		func(ResourceEntry->ResourceHandle);
	    }
	    break;
	}

	// Check every x seconds.
	// todo: need to make this a private property
	WaitForSingleObject(ResourceEntry->Event, MNS_RESERVE_PERIOD);
    } while(!ClusWorkerCheckTerminate(&ResourceEntry->ReserveThread));

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Reserve thread exiting, resource '%1' %2!u.\n",ResourceEntry->ResourceName,
	status);

    return(status);

} // MajorityNodeSetReserveThread


DWORD WINAPI MajorityNodeSetArbitrate(
    RESID ResourceId,
    PQUORUM_RESOURCE_LOST LostQuorumResource
    )

/*++

Routine Description:

    Perform full arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk, one per second.

Arguments:

    DiskResource - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD status;
    PMNS_RESOURCE ResourceEntry;


    ResourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( ResourceEntry == NULL ) {
        return(FALSE);
    }

    if ( ResourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }


    (g_LogEvent)(
	ResourceEntry->ResourceHandle,
	LOG_INFORMATION,
	L"Arbitrate request.\n"
	);

    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);

    status = MajorityNodeSetDoRegister(ResourceEntry);

    if (status == ERROR_SUCCESS) {
	// we wait for arbitration timeout in worse case
	DWORD delta = ResourceEntry->Setup.ArbTime;

	// do we already have quorum thread
	if (ResourceEntry->ArbThread) {
	    status = WaitForSingleObject(ResourceEntry->ArbThread, 0);
	    if (status != WAIT_TIMEOUT) {
		CloseHandle(ResourceEntry->ArbThread);
		ResourceEntry->ArbThread = NULL;
	    }
	}

	ASSERT(ResourceEntry->VolHdl);
	status = FsArbitrate(ResourceEntry->VolHdl, ResourceEntry->Event, &ResourceEntry->ArbThread);
	if (status == ERROR_IO_PENDING) {
	    HANDLE a[2];

	    ASSERT(ResourceEntry->ArbThread);

	    a[0] = ResourceEntry->ArbThread; // must be first
	    a[1] = ResourceEntry->Event;

	    status = WaitForMultipleObjects(2, a, FALSE, delta);
	    if (status != WAIT_TIMEOUT) {
		if (status == WAIT_OBJECT_0) {
		    CloseHandle(ResourceEntry->ArbThread);
		    ResourceEntry->ArbThread = NULL;
		}
		// check if we got it or not
		status = FsIsQuorum(ResourceEntry->VolHdl);
	    } else {
		// our time ran out, cancel it now
		status = FsCancelArbitration(ResourceEntry->VolHdl);
	    }
	}	    
    }

    if (status == ERROR_SUCCESS) {

	(g_LogEvent)(
	    ResourceEntry->ResourceHandle,
	    LOG_INFORMATION,
	    L"Arb: status %1!u!.\n",
	    status
	    );

	// we remember the callback and create a thread to monitor the quorum if we
	// don't have one already
	if (ResourceEntry->LostQuorumResource == NULL) {
	    status = ClusWorkerCreate( &ResourceEntry->ReserveThread,
				       (PWORKER_START_ROUTINE)MajorityNodeSetReserveThread,
				       ResourceEntry );
	}
	ResourceEntry->LostQuorumResource = LostQuorumResource;

	if ( status != ERROR_SUCCESS ) {
	    (g_LogEvent)(
		ResourceEntry->ResourceHandle,
		LOG_ERROR,
		L"Arb: Unable to start thread, status %1!u!.\n",
		status
		);
	}

    }

    // Drop lock
    LeaveCriticalSection(&ResourceEntry->Lock);

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Arbitrate request status %1!u!.\n",status);

    return status ;
}


DWORD
WINAPI
MajorityNodeSetRelease(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Release arbitration for a device by stopping the reservation thread.

Arguments:

    Resource - supplies resource id to be brought online

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_HOST_NODE_NOT_OWNER if the resource is not owned.
    A Win32 error code if other failure.

--*/

{
    DWORD status = ERROR_SUCCESS ;
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

 again:

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Release request resource %1.\n",resourceEntry->ResourceName);

    // Get lock
    EnterCriticalSection(&resourceEntry->Lock);
    // clear callback and stop thread
    resourceEntry->LostQuorumResource = NULL;
    // Drop lock
    LeaveCriticalSection(&resourceEntry->Lock);
    
    // kill reserve thread
    ClusWorkerTerminate( &resourceEntry->ReserveThread );

    // Get lock
    EnterCriticalSection(&resourceEntry->Lock);

    // clear callback and stop thread
    if (resourceEntry->LostQuorumResource != NULL) {
	// dam arb got called again
	goto again;
    }

    // issue FsRelease
    if (resourceEntry->VolHdl) {
	status = FsRelease(resourceEntry->VolHdl);
	if (status == ERROR_SUCCESS)
	    resourceEntry->VolHdl = NULL;
    }

    // Drop lock
    LeaveCriticalSection(&resourceEntry->Lock);

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Release request status %1!u!.\n",status);

    return status ;
}

DWORD
MajorityNodeSetGetDiskInfo(
    IN LPWSTR   lpszPath,
    OUT PVOID * OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Gets all of the disk information for a given signature.

Arguments:

    Signature - the signature of the disk to return info.

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    DWORD   bytesReturned = *BytesReturned;
    PVOID   ptrBuffer = *OutBuffer;
    PCLUSPROP_DWORD ptrDword;
    PCLUSPROP_PARTITION_INFO ptrPartitionInfo;

    // Return the signature - a DWORD
    bytesReturned += sizeof(CLUSPROP_DWORD);
    if ( bytesReturned <= OutBufferSize ) {
        ptrDword = (PCLUSPROP_DWORD)ptrBuffer;
        ptrDword->Syntax.dw = CLUSPROP_SYNTAX_DISK_SIGNATURE;
        ptrDword->cbLength = sizeof(DWORD);
        ptrDword->dw = 777;//return a bogus signature for now
        ptrDword++;
        ptrBuffer = ptrDword;
    }

    status = ERROR_SUCCESS;

    if (g_resHdl)
    (g_LogEvent)(
        g_resHdl,
        LOG_INFORMATION,
        L"Expanded path '%1'\n",lpszPath);


    bytesReturned += sizeof(CLUSPROP_PARTITION_INFO);
    if ( bytesReturned <= OutBufferSize ) {
    ptrPartitionInfo = (PCLUSPROP_PARTITION_INFO) ptrBuffer;
    ZeroMemory( ptrPartitionInfo, sizeof(CLUSPROP_PARTITION_INFO) );
    ptrPartitionInfo->Syntax.dw = CLUSPROP_SYNTAX_PARTITION_INFO;
    ptrPartitionInfo->cbLength = sizeof(CLUSPROP_PARTITION_INFO) - sizeof(CLUSPROP_VALUE);

    // set flags
//  ptrPartitionInfo->dwFlags = CLUSPROP_PIFLAG_STICKY;
    ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_USABLE;

    // copy device name
    if (lpszPath[0] == L'\\') {
        wcscpy(ptrPartitionInfo->szDeviceName, lpszPath);
        wcscat(ptrPartitionInfo->szDeviceName, L"\\");
    } else {
        ptrPartitionInfo->szDeviceName[0] = lpszPath[0];
        ptrPartitionInfo->szDeviceName[1] = L':';
        ptrPartitionInfo->szDeviceName[2] = L'\\';
        ptrPartitionInfo->szDeviceName[3] = L'\0';
    }

    if ( !GetVolumeInformationW( ptrPartitionInfo->szDeviceName,
                     ptrPartitionInfo->szVolumeLabel,
                     sizeof(ptrPartitionInfo->szVolumeLabel)/sizeof(WCHAR),
                     &ptrPartitionInfo->dwSerialNumber,
                     &ptrPartitionInfo->rgdwMaximumComponentLength,
                     &ptrPartitionInfo->dwFileSystemFlags,
                     ptrPartitionInfo->szFileSystem,
                     sizeof(ptrPartitionInfo->szFileSystem)/sizeof(WCHAR) ) ) {
        ptrPartitionInfo->szVolumeLabel[0] = L'\0';
    }
    //set the partition name to the path, nothing to do
    if (ptrPartitionInfo->szDeviceName[0] == L'\\')
        wcscpy(ptrPartitionInfo->szDeviceName, lpszPath);
    else
        ptrPartitionInfo->szDeviceName[2] = L'\0';

    ptrPartitionInfo++;
    ptrBuffer = ptrPartitionInfo;
    }

    //
    // Check if we got what we were looking for.
    //
    *OutBuffer = ptrBuffer;
    *BytesReturned = bytesReturned;

    return(status);

} // MajorityNodeSetGetDiskInfo

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( MajorityNodeSetFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         MajorityNodeSet,                    // Prefix
                         MajorityNodeSetArbitrate,           // Arbitrate
                         MajorityNodeSetRelease,             // Release
                         MajorityNodeSetResourceControl,     // ResControl
                         MajorityNodeSetResourceTypeControl); // ResTypeControl


void
msg_log(int level, char *buf, int cnt)
{
    WCHAR   wbuf[1024];

    cnt = mbstowcs(wbuf, buf, cnt-1);
    wbuf[cnt] = L'\0';
    if (g_resHdl)
        g_LogEvent(g_resHdl, level, L"%1\n", wbuf);
}

void
WINAPI
debug_log(char *format, ...)
{
    va_list marker;
    char buf[1024];
    int cnt;

    va_start(marker, format);
    cnt = vsprintf(buf, format, marker);
    msg_log(LOG_INFORMATION, buf, cnt);
    va_end(marker);
}

void
WINAPI
error_log(char *format, ...)
{
    va_list marker;
    char buf[1024];
    int cnt;

    va_start(marker, format);
    cnt = vsprintf(buf, format, marker);
    msg_log(LOG_ERROR, buf, cnt);
    va_end(marker);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\setup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    setup.c

Abstract:

    Implements "Majority Node Set" setup and configuration in cluster

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#define UNICODE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>

#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#include <tchar.h>
#include <clusapi.h>
#include <resapi.h>

#include <aclapi.h>
#include <accctrl.h>
#include <lm.h>
#include <lmshare.h>
#include <sddl.h>

// These may be included in any order:


#include <ntddnfs.h>            // DD_NFS_DEVICE_NAME, EA_NAME_ equates, etc.
#include <ntioapi.h>            // NtFsControlFile().
#include <ntrtl.h>              // Rtl APIs.
//#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>               // STRCAT(), STRCPY(), STRLEN().
#include <lmuse.h>              // USE_IPC...
#include <align.h>              // ALIGN_xxx

#include "fsutil.h"

#include <Iphlpapi.h>
#include <clusudef.h>
#include <clusrtl.h>

#define MAX_NAME_SIZE 256
#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)

#define SETUP_DIRECTORY_PREFIX  L"\\cluster\\" MAJORITY_NODE_SET_DIRECTORY_PREFIX

extern void WINAPI debug_log(char *, ...);

#define SetupLog(x) debug_log x
#define SetupLogError(x) debug_log x
    
DWORD
FindTransport(LPWSTR TransportId, LPWSTR *Transport);

// node section

#define MAX_CLUSTER_SIZE    16
#define MAX_NAME_SIZE       256

typedef struct _VCD_NODE_ {
    struct _VCD_NODE_   *next;
    DWORD   id;
    LPWSTR  name;
}VCD_NODE;

typedef struct {
    ULONG   lid;
    DWORD   Nic;
    DWORD   ArbTime;
    LPWSTR  Transport;
    DWORD   ClusterSize;
    VCD_NODE    *ClusterList;
}VCD_INFO, *PVCD_INFO;


DWORD
FindTransport(LPWSTR TransportId, LPWSTR *Transport)
{
   LPSERVER_TRANSPORT_INFO_0 pBuf = NULL;
   LPSERVER_TRANSPORT_INFO_0 pTmpBuf;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = 256;//-1
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   DWORD dwResumeHandle = 0;
   NET_API_STATUS nStatus;
   DWORD i;

   *Transport = NULL;

   //
   // Call the NetServerTransportEnum function; specify level 0.
   //
   do // begin do
   {
      nStatus = NetServerTransportEnum(NULL,
                                       dwLevel,
                                       (LPBYTE *) &pBuf,
                                       dwPrefMaxLen,
                                       &dwEntriesRead,
                                       &dwTotalEntries,
                                       &dwResumeHandle);
      //
      // If the call succeeds,
      //
      if ((nStatus != NERR_Success) && (nStatus != ERROR_MORE_DATA)) {
      break;
      }

      if ((pTmpBuf = pBuf) == NULL)  {
      nStatus = ERROR_NOT_FOUND;
      break;
      }

      //
      // Loop through the entries;
      //
      for (i = 0; i < dwEntriesRead; i++) {

      SetupLog(("\tTransport: %S address %S\n",
          pTmpBuf->svti0_transportname,
          pTmpBuf->svti0_networkaddress));

      if (wcsstr(pTmpBuf->svti0_transportname, TransportId)) {
          // found it, we are done
          LPWSTR p;
          DWORD sz;

          sz = wcslen(pTmpBuf->svti0_transportname) + 1;
          p = (LPWSTR) LocalAlloc(LMEM_FIXED, sz * sizeof(WCHAR));
          if (p != NULL) {
          wcscpy(p, pTmpBuf->svti0_transportname);
          *Transport = p;
          nStatus = ERROR_SUCCESS;
          break;
          }
      }
      pTmpBuf++;
      }
      //
      // Free the allocated buffer.
      //
      if (pBuf != NULL) {
         NetApiBufferFree(pBuf);
         pBuf = NULL;
      }
   } while (nStatus == ERROR_MORE_DATA);

   // Check again for an allocated buffer.
   //
   if (pBuf != NULL)
      NetApiBufferFree(pBuf);

   return nStatus;
}


DWORD 
NetInterfaceProp( IN  HNETINTERFACE hNet,IN  LPCWSTR name, WCHAR *buf)
{
    DWORD dwError     = ERROR_SUCCESS; // for return values
    DWORD cbAllocated = 1024;          // allocated size of output buffer
    DWORD cbReturned  = 0;             // adjusted size of output buffer
    WCHAR *value;

    //
    // Allocate output buffer
    //
    PVOID pPropList = LocalAlloc( LPTR, cbAllocated );
    if ( pPropList == NULL )
    {
        dwError = GetLastError();
        goto EndFunction;
    }

    //
    // Verify valid handle
    //
    if ( hNet == NULL )
    {
        dwError = ERROR_BAD_ARGUMENTS;
        goto EndFunction;
    }

    //
    // Retrieve common group properties.
    // cbReturned will be set to the size of the property list.
    //
    dwError = ClusterNetInterfaceControl(hNet, 
                     NULL,
                     CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES,
                     NULL, 
                     0, 
                     pPropList, 
                     cbAllocated, 
                     &cbReturned );

    //
    // If the output buffer was not big enough, reallocate it
    // according to cbReturned.
    //

    if ( dwError == ERROR_MORE_DATA )
    {
        cbAllocated = cbReturned;
        LocalFree( pPropList );
        pPropList = LocalAlloc( LPTR, cbAllocated );
        if ( pPropList == NULL )
        {
            dwError = GetLastError();
            goto EndFunction;
        }
        dwError = ClusterNetInterfaceControl(hNet, 
                         NULL,
                         CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES, 
                         NULL, 
                         0, 
                         pPropList, 
                         cbAllocated, 
                         &cbReturned );
    }

    if ( dwError != ERROR_SUCCESS ) goto EndFunction;

    dwError = ResUtilFindSzProperty( pPropList, 
                     cbReturned,
                     name,
                     &value);
    if (dwError == ERROR_SUCCESS) {
    wcscpy(buf, value);
    }
     
EndFunction:

    if (pPropList)
    LocalFree( pPropList );

    return dwError;

} //

int
strcmpwcs(char *s, WCHAR *p)
{
    char c;

    for (wctomb(&c,*p); (c == *s) && *s != '\0'; s++) {
    p++;
    wctomb(&c,*p);
    }
    if (*s == '\0' && c == *s)
    return 0;

    return 1;
}
DWORD
NetworkIsPrivate(HCLUSTER chdl, LPWSTR netname)
{
    HCLUSENUM ehdl;
    DWORD err, index;

    // Open enum handle
    ehdl = ClusterOpenEnum(chdl, CLUSTER_ENUM_INTERNAL_NETWORK);
    if (!ehdl) {
    err = GetLastError();
    return err;
    }


    for (index = 0; TRUE; index++) {
    DWORD type;
    DWORD sz;
    WCHAR name[MAX_NAME_SIZE];

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterEnum(ehdl, index, &type, name, &sz);
    if (err == ERROR_NO_MORE_ITEMS)
        break;
    if (err != ERROR_SUCCESS) {
        break;
    }
    ASSERT(type == CLUSTER_ENUM_INTERNAL_NETWORK);


    if (wcscmp(name, netname) == 0) {
        break;
    }

    err = ERROR_NOT_FOUND;
    // always return first one only, since I changed from a mask to a single number
    break;
    }

    ClusterCloseEnum(ehdl);

    return err;
}

DWORD
NodeNetworkAdapterMask(HCLUSTER chdl, HNODE nhdl, ULONG *nic, LPWSTR *transport)
{
    HNODEENUM nehdl = NULL;
    int index, done;
    DWORD err, type;
    DWORD sz = MAX_NAME_SIZE;
    WCHAR  buf[MAX_NAME_SIZE];
    LPWSTR id = (LPWSTR) buf;

    *nic = 0;
    *transport = NULL;

    // Open node enum handle
    nehdl = ClusterNodeOpenEnum(nhdl, CLUSTER_NODE_ENUM_NETINTERFACES);
    if (!nehdl) {
        err = GetLastError();
        return err;
    }

    // Get node properties
    done = 0;
    for (index = 0; !done; index++) {
        HNETINTERFACE nethdl;

        sz = MAX_NAME_SIZE;
        err = ClusterNodeEnum(nehdl, index, &type, id, &sz);
        if (err == ERROR_NO_MORE_ITEMS)
            break;
        if (err != ERROR_SUCCESS) {
            break;
        }

        nethdl = OpenClusterNetInterface(chdl, id);
        if (!nethdl) {
            continue;
        }
          
        err = NetInterfaceProp(nethdl, L"Network", id);
        if (err != ERROR_SUCCESS) {
            continue;
        }
        // check if this network can be used by cluster service
        err = NetworkIsPrivate(chdl, id);
        if (err != ERROR_SUCCESS) {
            continue;
        }

        err = NetInterfaceProp(nethdl, L"AdapterId", id);
        if (err == ERROR_SUCCESS) {
            // find nic
            PIP_INTERFACE_INFO ilist;
            LONG num;

            sz = 0;
            GetInterfaceInfo(NULL, &sz);
            ilist = (PIP_INTERFACE_INFO) malloc(sz);
            if (ilist != NULL) {
                err = GetInterfaceInfo(ilist, &sz);
                if (err == NO_ERROR) {
                    for (num = 0; num < ilist->NumAdapters; num++) {
                        if (wcsstr(ilist->Adapter[num].Name, id)) {
                            *nic = (ULONG) (ilist->Adapter[num].Index % ilist->NumAdapters);
                            SetupLog(("Adapter %d '%S'\n", *nic, id));
                            break;
                        }
                    }
                } else {
                    SetupLog(("GetInterfaceInfo failed %d\n", err));
                }
                free(ilist);
            }

            // find transport name
            err = FindTransport(id, transport);
            if (err == ERROR_SUCCESS) {
                SetupLog(("NetBT: %S\n", *transport));
            }
        }

        CloseClusterNetInterface(nethdl);
    }

    if (*transport == NULL) {
        SetupLog(("No transport is found\n"));
    }

    if (nehdl)
    ClusterNodeCloseEnum(nehdl);

    return err;
  
}

DWORD
NodeGetId(HNODE nhdl, ULONG *nid)
{
    DWORD sz = MAX_NAME_SIZE;
    WCHAR  buf[MAX_NAME_SIZE], *stopstring;
    LPWSTR id = (LPWSTR) buf;
    DWORD err;

    err = GetClusterNodeId(nhdl, id, &sz);
    if (err == ERROR_SUCCESS) {
    *nid = wcstol(id, &stopstring,10);
    }

    return err;
}

void
NodeAddNode(PVCD_INFO info, WCHAR *name, DWORD id)
{
    WCHAR   *p;
    VCD_NODE    *n, **last;

    n = (VCD_NODE *) LocalAlloc(LMEM_FIXED, ((wcslen(name)+1) * sizeof(WCHAR)) + sizeof(*n));
    if (n == NULL) {
    return;
    }
    p = (WCHAR *) (n+1);
    wcscpy(p, name);
    n->name = p;
    n->id = id;
    // insert into list in proper order, ascending
    last = &info->ClusterList;
    while (*last && (*last)->id < id) {
    last = &(*last)->next;
    }
    n->next = *last;
    *last = n;
    info->ClusterSize++;
}

NodeInit(PVCD_INFO info, HCLUSTER chdl)
{
    HCLUSENUM ehdl;
    DWORD err, index;

    // Open enum handle
    ehdl = ClusterOpenEnum(chdl, CLUSTER_ENUM_NODE);
    if (!ehdl) {
        err = GetLastError();
        SetupLogError(("Unable to open enum_node %d\n", err));
        return err;
    }


    for (index = 0; TRUE; index++) {
        DWORD type;
        DWORD sz, id;
        WCHAR name[128];
        HNODE nhdl = NULL;

        sz = sizeof(name) / sizeof(WCHAR);
        err = ClusterEnum(ehdl, index, &type, name, &sz);
        if (err == ERROR_NO_MORE_ITEMS) {
            err = ERROR_SUCCESS;
            break;
        }
        if (err != ERROR_SUCCESS) {
            SetupLogError(("Unable to enum %d node %d\n", index, err));
            break;
        }
        ASSERT(type == CLUSTER_ENUM_NODE);

        nhdl = OpenClusterNode(chdl, name);

        if (!nhdl) {
            err = GetLastError();
            SetupLogError(("Unable to open node %S err %d\n", name, err));
            continue;
        }

        err = NodeGetId(nhdl, &id);
        if (err == ERROR_SUCCESS) {
            NodeAddNode(info, name, id);
            if (id == info->lid) {
            NodeNetworkAdapterMask(chdl, nhdl, &info->Nic, &info->Transport);
            }
        } else {
            SetupLogError(("Unable to get node id %S %d\n", name, err));
        }
        CloseClusterNode(nhdl);
    }

    if (ehdl)
    ClusterCloseEnum(ehdl);

  return err;
}

// In order to deal with auto-setup:
// we need to create a directory mscs.<resource name>.
// we then create a share with guid:.....\mscs.<resource name>.
// set security on both directory and share for cluster service account only
DWORD
SetupShare(LPWSTR name, LPWSTR *lpath)
{
    
    DWORD err, len;
    WCHAR path[MAX_PATH];

    if (name == NULL || wcslen(name) > MAX_PATH)
    return ERROR_INVALID_PARAMETER;

    *lpath = NULL;
    len = GetWindowsDirectoryW(path, MAX_PATH);
    if (len > 0) {
        SECURITY_ATTRIBUTES sec;
        HANDLE hDir;

        path[len] = L'\0';
        lstrcatW(path, SETUP_DIRECTORY_PREFIX);
        lstrcatW(path, name);

        memset((PVOID) &sec, 0, sizeof(sec));

        if (!CreateDirectoryW(path, NULL)) {
            err = GetLastError();
            if (err != ERROR_ALREADY_EXISTS) {
                SetupLogError(("Failed to create %s %d\n", path, err));
                return 0;
            }
        }
        hDir =  CreateFileW(path,
                            GENERIC_READ|WRITE_DAC|READ_CONTROL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

        if (hDir != INVALID_HANDLE_VALUE) {
            // set the security attributes for the file.
            err = ClRtlSetObjSecurityInfo(hDir, SE_FILE_OBJECT,
                        GENERIC_ALL, GENERIC_ALL, 0);

            // close directory handle
            CloseHandle(hDir);

            // duplicate path
            *lpath = (LPWSTR) LocalAlloc(LMEM_FIXED, (wcslen(path)+1)*sizeof(WCHAR));
            if (*lpath != NULL) {
        	wcscpy(*lpath, path);
        	SetupLog(("Local path %S\n", lpath));
            } else {
        	err = GetLastError();
            }
        } else {
            err = GetLastError(); 
            SetupLogError(("Unable to open directory %d\n", err));
        }

        if (err == ERROR_SUCCESS) {

            // check if share doesn't exist already
            SHARE_INFO_502 shareInfo;
            PBYTE BufPtr;

            err = NetShareGetInfo(NULL, name, 502, (PBYTE *)&BufPtr);
            if (err == ERROR_SUCCESS) {
        	NetApiBufferFree(BufPtr);
            }
            if (err != ERROR_SUCCESS) {
        	PSECURITY_DESCRIPTOR    secDesc;

        	err = ConvertStringSecurityDescriptorToSecurityDescriptor(
        	    L"D:P(A;;GA;;;BA)(A;;GA;;;CO)",
        	    SDDL_REVISION_1,
        	    &secDesc,
        	    NULL);

        	if (!err) {
        	    secDesc = NULL;
        	    err = GetLastError();
        	    SetupLogError(("Unable to get security desc %d\n", err));
        	}

        	// create a net share now
        	ZeroMemory( &shareInfo, sizeof( shareInfo ) );
        	shareInfo.shi502_netname =      name;
        	shareInfo.shi502_type =         STYPE_DISKTREE;
        	shareInfo.shi502_remark =       L"Cluster Quorum Share";
        	shareInfo.shi502_max_uses =     -1;
        	shareInfo.shi502_path =         path;
        	shareInfo.shi502_passwd =       NULL;
        	shareInfo.shi502_permissions =  ACCESS_ALL;
        	//  set security stuff
        	shareInfo.shi502_security_descriptor = secDesc;

        	err = NetShareAdd( NULL, 502, (PBYTE)&shareInfo, NULL );

        	if (secDesc)
        	    LocalFree(secDesc);
            } else {
        	SetupLogError(("Netshare '%S' already exists\n", name));
            }
        }

    } else {
        err = GetLastError();
    }

    return err;

}

DWORD
GetDwParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )


{
    DWORD Value = 0;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = sizeof(Value);
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  (LPBYTE) &Value,
                                  &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        SetLastError(Status);
    }

    return(Value);
}

LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Queries a REG_SZ parameter out of the registry and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - Supplies the cluster key where the parameter is stored

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/

{
    LPWSTR Value;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = 0;
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  NULL,
                                  &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        SetLastError(Status);
        return(NULL);
    }
    if ( ValueType == REG_SZ ) {
        ValueLength += sizeof(UNICODE_NULL);
    }
    Value = LocalAlloc(LMEM_FIXED, ValueLength);
    if (Value == NULL) {
        return(NULL);
    }
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  (LPBYTE)Value,
                                  &ValueLength);
    if (Status != ERROR_SUCCESS) {
        LocalFree(Value);
        SetLastError(Status);
        Value = NULL;
    }

    return(Value);
} // GetParameter

DWORD
SetupNetworkInterfaceFromRegistry(HKEY hkey, LPWSTR netname, VCD_INFO *info)
{
    HKEY    rkey;
    DWORD   err, index;

    // get network key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_NETINTERFACES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
    return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    LPWSTR  tname;
    DWORD   id;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    tname = GetParameter(tkey, CLUSREG_NAME_NETIFACE_NODE);
    if (tname == NULL)
        continue;

    id = wcstol(tname, NULL, 10);
    LocalFree(tname);
    
    if (id != info->lid)
        continue;

    tname = GetParameter(tkey, CLUSREG_NAME_NETIFACE_NETWORK);
    
    SetupLog(("Found adapter %d %S\n", id, tname));
    if (wcscmp(tname, netname) == 0) {
        // get adapter id
        LocalFree(tname);

        tname = GetParameter(tkey, CLUSREG_NAME_NETIFACE_ADAPTER_ID);
        if (tname) {
        SetupLog(("Find transport %S\n", tname));
        err = FindTransport(tname, &info->Transport);
        }
        LocalFree(tname);
        ClusterRegCloseKey(tkey);
        break;
    }

    LocalFree(tname);
    ClusterRegCloseKey(tkey);
    }

    ClusterRegCloseKey(rkey);
    
    if (err == ERROR_NO_MORE_ITEMS)
    err = ERROR_SUCCESS;
    return err;
}

DWORD
SetupNetworkFromRegistry(HKEY hkey, VCD_INFO *info)
{
    HKEY    rkey;
    DWORD   err, index;

    // get network key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_NETWORKS, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
    return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    DWORD   id;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    id = GetDwParameter(tkey, CLUSREG_NAME_NET_PRIORITY);
    SetupLog(("Found network %d %S\n", id, name));
    if (id == 1) {
        // find which nic belongs to this transport
        err = SetupNetworkInterfaceFromRegistry(hkey, name, info);
        ClusterRegCloseKey(tkey);
        break;
    }

    ClusterRegCloseKey(tkey);
    }

    ClusterRegCloseKey(rkey);
    
    if (err == ERROR_NO_MORE_ITEMS)
    err = ERROR_SUCCESS;
    return err;
}

DWORD
SetupNodesFromRegistry(HCLUSTER hCluster, VCD_INFO *info)
{
    HKEY    hkey, rkey;
    DWORD   err, index;
    WCHAR   localname[MAX_COMPUTERNAME_LENGTH + 1];

    memset(info, 0, sizeof(*info));

    index = sizeof(localname) / sizeof(WCHAR);
    if (GetComputerName(localname, &index) == FALSE) {
    return GetLastError();
    }

    hkey = GetClusterKey(hCluster, KEY_READ);
    if (hkey == NULL)
	return GetLastError();

    // get resource key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_NODES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
	ClusterRegCloseKey(hkey);
	return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    LPWSTR  tname;
    DWORD   id;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    tname = GetParameter(tkey, CLUSREG_NAME_NODE_NAME);
    if (tname == NULL) {
        err = GetLastError();
        ClusterRegCloseKey(tkey);
        break;
    }
    ClusterRegCloseKey(tkey);

    id = wcstol(name, NULL, 10);

    SetupLog(("Found node %d %S\n", id, tname));

    NodeAddNode(info, tname, id);

    if (wcscmp(localname, tname) == 0) {
        // set our local id
        info->lid = id;
        // find which nic and transport to use
        SetupNetworkFromRegistry(hkey, info);
        
    }
    LocalFree(tname);
    }

    ClusterRegCloseKey(rkey);
    ClusterRegCloseKey(hkey);

    if (err == ERROR_NO_MORE_ITEMS)
    err = ERROR_SUCCESS;
    return err;
}

DWORD
SetupNodes(HCLUSTER chdl, VCD_INFO *info)
{
    DWORD err;

    memset(info, 0, sizeof(*info));

    err = NodeGetId(NULL, &info->lid);
    if (err != ERROR_SUCCESS) {
	SetupLogError(("Unable to get local id %d\n", err));
	return err;
    }

    SetupLog(("Local node id %d\n", info->lid));

    err = NodeInit(info, chdl);

    return err;
}


DWORD
GetIDFromRegistry(IN HCLUSTER hCluster, IN LPWSTR resname, OUT LPWSTR *id)
{
    HKEY    hkey, rkey;
    DWORD   err, index;

    *id = NULL;

    hkey = GetClusterKey(hCluster, KEY_READ);
    if (hkey == NULL)
    return GetLastError();

    // get resource key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_RESOURCES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
    ClusterRegCloseKey(hkey);
    return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    LPWSTR  tname;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    SetupLog(("Found name %S\n", name));

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    tname = GetParameter(tkey, CLUSREG_NAME_RES_NAME);
    if (tname == NULL) {
        err = GetLastError();
        ClusterRegCloseKey(tkey);
        break;
    }
    ClusterRegCloseKey(tkey);
    if (wcscmp(tname, resname) == 0) {
        SetupLog(("Guid %S\n", name));
        // found it
        *id = LocalAlloc(LMEM_FIXED, 80 * sizeof(WCHAR));
        if (*id != NULL) {
        wcscpy(*id, name);
        } else {
        err = GetLastError();
        }
        LocalFree(tname);
        break;
    }
    LocalFree(tname);
    }

    ClusterRegCloseKey(rkey);
    ClusterRegCloseKey(hkey);
    
    return err;
}

DWORD
GetIDFromName(
    IN     HRESOURCE  hResource,
       OUT LPWSTR    *ppszID
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (hResource && ppszID) 
    {
        //
        // Should be able to hold the string representation of a guid
        //
        DWORD cbBuf = 80;

        //
        // Set the out parameter to something known
        //
        *ppszID = NULL;
    
        
        if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
        {
            if ((dwError = ClusterResourceControl(hResource, 
                                                  NULL,
                                                  CLUSCTL_RESOURCE_GET_ID,
                                                  NULL,                                               
                                                  0,
                                                  *ppszID,
                                                  cbBuf,
                                                  &cbBuf)) == ERROR_MORE_DATA) 
            {
                LocalFree(*ppszID);

                if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
                {
                    dwError = ClusterResourceControl(hResource, 
                                                     NULL,
                                                     CLUSCTL_RESOURCE_GET_ID,
                                                     NULL,                                               
                                                     0,
                                                     *ppszID,
                                                     cbBuf,
                                                     &cbBuf);
                }
                else
                {
                    dwError = GetLastError();
                }
            }

            //
            // Free the memory if getting the ID failed
            //
            if (dwError != ERROR_SUCCESS && *ppszID) 
            {
                LocalFree(*ppszID);
                *ppszID = NULL;
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }
    
    return dwError;
}

DWORD
SetupIoctlQuorumResource(LPWSTR ResType, DWORD ControlCode)
{

    HRESOURCE hres;
    HCLUSTER chdl;
    HKEY    hkey, rkey, qkey;
    DWORD   err, index;
    LPWSTR  tname, resname;

    chdl = OpenCluster(NULL);
    if (chdl == NULL) {
	SetupLogError(("Unable to open cluster\n"));
	return GetLastError();
    }

    hkey = GetClusterKey(chdl, KEY_READ);
    if (hkey == NULL) {
	CloseCluster(chdl);
	return GetLastError();
    }

    // get quorum key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_QUORUM, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
	ClusterRegCloseKey(hkey);
	CloseCluster(chdl);
	return err;
    }

    // read guid of current quorum
    tname = GetParameter(rkey, CLUSREG_NAME_QUORUM_RESOURCE);
    if (tname == NULL) {
	err = GetLastError();
	ClusterRegCloseKey(rkey);
	ClusterRegCloseKey(hkey);
	CloseCluster(chdl);
	return err;
    }

    // close rkey
    ClusterRegCloseKey(rkey);

    // get resources key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_RESOURCES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
	ClusterRegCloseKey(hkey);
	CloseCluster(chdl);
	LocalFree(tname);
	return err;
    }

    // get resource key
    err = ClusterRegOpenKey(rkey, tname, KEY_READ, &qkey);
    LocalFree(tname);
    if (err != ERROR_SUCCESS) {
	ClusterRegCloseKey(rkey);
	ClusterRegCloseKey(hkey);
	CloseCluster(chdl);
	return err;
    }

    // read resource type of current quorum
    tname = GetParameter(qkey, CLUSREG_NAME_RES_TYPE);
    if (tname == NULL)
	err = GetLastError();

    if (tname != NULL && wcscmp(tname, ResType) == 0) {
	resname = GetParameter(qkey, CLUSREG_NAME_RES_NAME);
	if (resname != NULL) {
	    err = ERROR_SUCCESS;
	    // open this resource and drop ioctl now
	    hres = OpenClusterResource(chdl, resname);
	    if (hres != NULL) {
		err = ClusterResourceControl(hres, NULL, ControlCode, NULL, 0, NULL,
					     0, NULL);
		CloseClusterResource(hres);
	    }

	    LocalFree(resname);

	} else {
	    err = GetLastError();
	}
    }

    if (tname)
	LocalFree(tname);

    ClusterRegCloseKey(qkey);
    ClusterRegCloseKey(rkey);
    ClusterRegCloseKey(hkey);
    CloseCluster(chdl);

    return err;
}

// This not is not efficient, some day someone can do this better. For now, I just
// need this stuff.

DWORD
SetupIsQuorum(LPWSTR ResourceName)
{

    HRESOURCE hres;
    HCLUSTER chdl;
    DWORD status;
    LPWSTR  Guid = NULL;


    chdl = OpenCluster(NULL);
    if (chdl == NULL) {
	SetupLogError(("Unable to open cluster\n"));
	return GetLastError();
    }

    hres = OpenClusterResource(chdl, ResourceName);
    if (hres == NULL) {
	status = GetLastError();
	SetupLogError(("Unable to open resource\n"));
	CloseCluster(chdl);
	return status;
    }
    
    status = GetIDFromName(hres, &Guid);
    if (status != ERROR_SUCCESS) {
	SetupLogError(("Unable to get guid %d\n", status));
	// we need to walk the registry and find the guid ourself.
	status = GetIDFromRegistry(chdl, ResourceName, &Guid);
    }

    CloseClusterResource(hres);

    if (status == ERROR_SUCCESS) {
	HKEY	hkey, rkey;
	LPWSTR	tname;

	// ok we have guid of resource, we now get the current quorum resource
	// and compare guids

	hkey = GetClusterKey(chdl, KEY_READ);
	if (hkey == NULL) {
	    status = GetLastError();
	    goto exit;
	}

	// get quorum key
	status = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_QUORUM, KEY_READ, &rkey);
	if (status != ERROR_SUCCESS) {
	    ClusterRegCloseKey(hkey);
	    goto exit;
	}

	// read guid of current quorum
	tname = GetParameter(rkey, CLUSREG_NAME_QUORUM_RESOURCE);
	if (tname != NULL) {
	    if (wcscmp(tname, Guid) == 0)
		status = ERROR_SUCCESS;
	    else
		status = ERROR_CLUSTER_INSTANCE_ID_MISMATCH;

	    LocalFree(tname);
	}

	ClusterRegCloseKey(rkey);
	ClusterRegCloseKey(hkey);

    }

 exit:

    if (Guid)
	LocalFree(Guid);

    CloseCluster(chdl);

    return status;
	
}

DWORD
SetupStart(LPWSTR ResourceName, LPWSTR *SrvPath,
       LPWSTR *DiskList, DWORD *DiskListSize,
       DWORD *NicId, LPWSTR *Transport, DWORD *ArbTime)
{
    HRESOURCE hres;
    HCLUSTER chdl;
    DWORD status;
    LPWSTR  Guid = NULL, nbtName = NULL, lpath = NULL;
    VCD_INFO Info;

    chdl = OpenCluster(NULL);
    if (chdl == NULL) {
	SetupLogError(("Unable to open cluster\n"));
	return GetLastError();
    }
    
    // read quorum arb. timeout
    if (ArbTime != NULL) {
	HKEY hkey;

	*ArbTime = 60; // default is 60 seconds
	hkey = GetClusterKey(chdl, KEY_READ);
	if (hkey != NULL) {
	    DWORD tmp;

	    tmp = GetDwParameter(hkey, CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT);

	    if (tmp > 0)
		*ArbTime = tmp;

	    ClusterRegCloseKey(hkey);
	}
	// convert to msec and normalize
	*ArbTime = ((*ArbTime) * 7 * 1000) / 8; // use 7/8 of the actual timeout
	SetupLog(("Max. arbitration time %d msec\n", *ArbTime));
    }


    hres = OpenClusterResource(chdl, ResourceName);
    if (hres == NULL) {
	status = GetLastError();
	SetupLogError(("Unable to open resource\n"));
	CloseCluster(chdl);
	return status;
    }
    
    status = GetIDFromName(hres, &Guid);
    if (status != ERROR_SUCCESS) {
	SetupLogError(("Unable to get guid %d\n", status));
	// we need to walk the registry and find the guid ourself.
	status = GetIDFromRegistry(chdl, ResourceName, &Guid);
    }
    if (status == ERROR_SUCCESS) {
	int sz;

	// we add a $ onto the guid
	wcscat(Guid, L"$");

	sz = wcslen(Guid);
	// netbios name are 16 bytes, 3 back-slashs, 1 null and few extra pads
	sz += 32;
	nbtName = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * sz);
	if (nbtName == NULL) {
	    status = ERROR_NOT_ENOUGH_MEMORY;
	    goto done;
	}

	nbtName[0] = L'\\';
	nbtName[1] = L'\\';
	// netbios name are 15 bytes + 1 byte for type. So, we use first 15 bytes
	wcsncpy(&nbtName[2], Guid, 15);
	nbtName[17] = L'\0';
	wcscat(nbtName, L"\\");
	wcscat(nbtName, Guid);
        
	// guid for everything to do with shares and directory name
	status = SetupShare(Guid, &lpath);
	if (status != ERROR_SUCCESS) {
	    SetupLogError(("Unable to setup share %d\n", status));
	    goto done;
	}

	// get list of nodes.
	// make a path with \\guid\guid
	// make disklist with UNC\nodename\guid, for local node we can use the
	// raw ntfs path directly

	status = SetupNodes(chdl, &Info);
	if (status != ERROR_SUCCESS) {
	    status = SetupNodesFromRegistry(chdl, &Info);
	}
	if (status == ERROR_SUCCESS) {
	    // build an array of disk shares, \\hostname\guid
	    int i;
	    VCD_NODE *cur;

	    // we start @ slot 1 and not zero, store local path in zero
	    DiskList[0] = lpath;
	    for (cur = Info.ClusterList; cur != NULL; cur=cur->next){
		// build a unc\hostname\guid path

		sz = wcslen(L"UNC\\");
		sz += wcslen(cur->name);
		sz += wcslen(L"\\");
		sz += wcslen(Guid);
		sz += 1;

		i = cur->id;

		DiskList[i] = (LPWSTR) LocalAlloc(LMEM_FIXED, sz * sizeof(WCHAR));
		if (DiskList[i] == NULL) {
		    status = ERROR_NOT_ENOUGH_MEMORY;
		    break;
		}

		wcscpy(DiskList[i], L"UNC\\");
		wcscat(DiskList[i], cur->name);
		wcscat(DiskList[i], L"\\");
		wcscat(DiskList[i], Guid);

	    }

	    if (status == ERROR_SUCCESS) {
		*DiskListSize = Info.ClusterSize;
		*NicId = Info.Nic;
		*Transport = Info.Transport;
		*SrvPath = nbtName;
	    }


	    while(cur = Info.ClusterList) {
		cur = cur->next;
		LocalFree((PVOID)Info.ClusterList);
		Info.ClusterList = cur;
	    }

	    Info.ClusterSize = 0;
        } else {
	    status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

done:

    // free guid buffer
    if (Guid) {
	LocalFree(Guid);
    }

    if (status != ERROR_SUCCESS) {
	if (nbtName) {
	    LocalFree(nbtName);
	}
	if (lpath) {
	    LocalFree(lpath);
	}
    }

    CloseClusterResource(hres);

    CloseCluster(chdl);

    return status;
}

DWORD
SetupDelete(IN LPWSTR Path)
{
    LPWSTR  name;
    DWORD   err = ERROR_INVALID_PARAMETER;
    HANDLE  vfd;
    WCHAR   tmp[MAX_PATH];

    if (Path == NULL)
	return err;

    // We need to do couple of things here. First we remove the
    // network share and then delete the tree structure.

    SetupLog(("Delete path %S\n", Path));
    name = wcsstr(Path, SETUP_DIRECTORY_PREFIX);
    if (name != NULL) {
	name += wcslen(SETUP_DIRECTORY_PREFIX);
	err = NetShareDel(NULL, name, 0);
	SetupLog(("Delete share %S err %d\n", name, err));
    }

    // Open path with delete on close and delete whole tree
    ASSERT(wcslen(Path) < sizeof(tmp));

    swprintf(tmp,L"\\??\\%s", Path);
    err = xFsOpen(&vfd, NULL, tmp, wcslen(tmp), 
          FILE_GENERIC_READ | FILE_GENERIC_WRITE,
          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
          FILE_DIRECTORY_FILE);

    if (err == STATUS_SUCCESS) {

	err = xFsDeleteTree(vfd);
	xFsClose(vfd);
	SetupLog(("Delete tree %S err %x\n", tmp, err));
	// now delete root
	if (err == STATUS_SUCCESS)
	    err = xFsDelete(NULL, tmp, wcslen(tmp));
	SetupLog(("Delete tree %S err %x\n", tmp, err));
    }

    return RtlNtStatusToDosError(err);
}

DWORD
SetupTree(
    IN LPTSTR TreeName,
    IN LPTSTR DlBuf,
    IN OUT DWORD *DlBufSz,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SecurityDescriptor OPTIONAL
    )

{
    DWORD ApiStatus;
    DWORD ConnectionType = USE_WILDCARD; // use_chardev
    IO_STATUS_BLOCK iosb;
    NTSTATUS ntstatus;                      // Status from NT operations.
    OBJECT_ATTRIBUTES objattrTreeConn;      // Attrs for tree conn.
    LPTSTR pszTreeConn = NULL;              // See strTreeConn below.
    UNICODE_STRING ucTreeConn;
    HANDLE TreeConnHandle = NULL;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea;
    USHORT TransportNameSize = 0;
    ULONG EaBufferSize = 0;
    PWSTR UnicodeTransportName = NULL;

    UCHAR EaNameDomainNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_DOMAIN) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNamePasswordSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTransportNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_TRANSPORT) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTypeSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    UCHAR EaNameUserNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    USHORT TypeSize = sizeof(ULONG);



    if ((TreeName == NULL) || (TreeName[0] == 0)) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Build NT-style name for what we're connecting to.  Note that there is
    // NOT a pair of backslashes anywhere in this name.
    //

    {
        DWORD NameSize =

            // /Device/LanManRedirector      /    server/share     \0
            ( ( STRLEN((LPTSTR)DD_NFS_DEVICE_NAME_U) + 1 + STRLEN(TreeName) + 1 ) )
            * sizeof(TCHAR);

        pszTreeConn = (LPTSTR)LocalAlloc(LMEM_FIXED, NameSize );
    }

    if (pszTreeConn == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Build the tree connect name.
    //

    (void) STRCPY(pszTreeConn, (LPTSTR) DD_NFS_DEVICE_NAME_U);

    //
    // NOTE: We add 1, (not sizeof(TCHAR)) because pointer arithmetic is done
    // in terms of multiples of sizeof(*pointer), not bytes
    //
    {
    LPWSTR  p = wcschr(TreeName+2, L'\\');
    if (p != NULL) {
        *p = L'\0';
    }

    (void) STRCAT(pszTreeConn, TreeName+1); // \server\share
    if (p != NULL) {
        *p = L'\\';
        (void) STRCAT(pszTreeConn, L"\\IPC$"); // \server\IPC$
    }
    }

    RtlInitUnicodeString(&ucTreeConn, pszTreeConn);

    //
    // Calculate the number of bytes needed for the EA buffer.
    // This may have the transport name.  For regular sessions, the user
    // name, password, and domain name are implicit.  For null sessions, we
    // must give 0-len user name, 0-len password, and 0-len domain name.
    //

    if (ARGUMENT_PRESENT(TransportName)) {

        UnicodeTransportName = TransportName;
        TransportNameSize = (USHORT) (wcslen(UnicodeTransportName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameTransportNameSize + sizeof(CHAR) +
                            TransportNameSize,
                            ALIGN_DWORD
                            );
    }


    EaBufferSize += ((ULONG)FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]))+
                    EaNameTypeSize + sizeof(CHAR) +
                    TypeSize;


    //
    // Allocate the EA buffer
    //

    if ((EaBuffer = LocalAlloc(LMEM_FIXED, EaBufferSize )) == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill-in the EA buffer.
    //

    RtlZeroMemory(EaBuffer, EaBufferSize);

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(TransportName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy(Ea->EaName, EA_NAME_TRANSPORT);
        Ea->EaNameLength = EaNameTransportNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        (VOID) wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameTransportNameSize + sizeof(CHAR)]),
            UnicodeTransportName
            );

        Ea->EaValueLength = TransportNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameTransportNameSize + sizeof(CHAR) +
                                  TransportNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }




    //
    // Copy the EA for the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //
    strcpy(Ea->EaName, EA_NAME_TYPE);
    Ea->EaNameLength = EaNameTypeSize;

    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;

    Ea->EaValueLength = TypeSize;

    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    // Set object attributes for the tree conn.
    InitializeObjectAttributes(
                & objattrTreeConn,                       // obj attr to init
                (LPVOID) & ucTreeConn,                   // string to use
                OBJ_CASE_INSENSITIVE,                    // Attributes
                NULL,                                    // Root directory
                SecurityDescriptor);                     // Security Descriptor


    //
    // Open a tree connection to the remote server.
    //
    ntstatus = NtCreateFile(
                &TreeConnHandle,                        // ptr to handle
                SYNCHRONIZE                              // desired...
                | GENERIC_READ | GENERIC_WRITE,          // ...access
                & objattrTreeConn,                       // name & attributes
                & iosb,                                  // I/O status block.
                NULL,                                    // alloc size.
                FILE_ATTRIBUTE_NORMAL,                   // (ignored)
                FILE_SHARE_READ | FILE_SHARE_WRITE,      // ...access
                FILE_OPEN_IF,                            // create disposition
                FILE_CREATE_TREE_CONNECTION              // create...
                | FILE_SYNCHRONOUS_IO_NONALERT,          // ...options
                EaBuffer,                                // EA buffer
                EaBufferSize );                          // Ea buffer size


    ApiStatus = RtlNtStatusToDosError(ntstatus);
    if (ntstatus == STATUS_SUCCESS) {
	// create drive letter 
	NETRESOURCE nr;
	DWORD result;

	nr.dwType = RESOURCETYPE_DISK;
	nr.lpLocalName = NULL; //drive;
	nr.lpRemoteName = TreeName;
	nr.lpProvider = NULL;

	if (DlBufSz != NULL)
	    ApiStatus = WNetUseConnection(NULL, &nr, NULL, NULL, CONNECT_REDIRECT,
					  DlBuf, DlBufSz, &result);
	else
	    ApiStatus = WNetUseConnection(NULL, &nr, NULL, NULL, 0, NULL, 0, NULL);
    }


 Cleanup:

    // Clean up.
    if ( TreeConnHandle != NULL ) {
        ntstatus = NtClose(TreeConnHandle);
    }

    if ( pszTreeConn != NULL ) {
        LocalFree(pszTreeConn);
    }

    if (EaBuffer != NULL) {
        LocalFree(EaBuffer);
    }

    return ApiStatus;

}

#ifdef STANDALONE

__cdecl
main()
{
    DWORD err;
    WCHAR Drive[10];
    DWORD DriveSz;
    LPWSTR DiskList[FsMaxNodes];
    DWORD   DiskListSz, Nic;
    LPWSTR  Path, Share, Transport;
    LPWSTR  ResName = L"Node Quorum";

    err = SetupStart(ResName, &Path, DiskList, &DiskListSz, &Nic, &Transport);
    if (err == ERROR_SUCCESS) {
    DWORD i;
    
    Share = wcschr(Path+2, L'\\');
    wprintf(L"Path is '%s'\n", Path);
    wprintf(L"Share is '%s'\n", Share);
    wprintf(L"Nic %d\n", Nic);
    wprintf(L"Transport '%s'\n", Transport);

    for (i = 1; i < FsMaxNodes; i++) {
	if (DiskList[i])
	    wprintf(L"Disk%d: %s\n", i, DiskList[i]);
    }

    DriveSz = sizeof(Drive);
    err = SetupTree(Path, Drive, &DriveSz, Transport, NULL);
    if (err == ERROR_SUCCESS)
        wprintf(L"Drive %s\n", Drive);
    }
    printf("Err is %d\n",err);
    return err;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\lsa.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    lsa.c

Abstract:

    Implements security network logon

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <ntmsv1_0.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>

//int     lstrlenW(char *);

typedef int BOOL;
typedef unsigned int UINT;
typedef unsigned int *PUINT;
typedef unsigned char *LPBYTE;


#define LocalLSAInit()	(LsaHandle != NULL)

#ifdef LSA_AUDIT_FLAG
int LsaAuditFlag = 0;
#endif

#define BUF_SIZ 512


void
replstar(
    IN char *  starred,
    OUT LPWSTR UnicodeOut
    )
/*++ replstar

Routine Description:

    replaces the '*' in the string with either spaces or NULL
    if it's the only memeber of the string.  Used by parse().

    Converts the resultant string to unicode.

Arguments:

    char *  starred -

Return Value:

    void -
Warnings:
--*/
{
    char *cp;
    STRING AnsiString;
    UNICODE_STRING UnicodeString;

    if ( !strcmp(starred,"*") ) {
        *starred = '\0';
    } else {
        for ( cp = starred; *cp; ++cp )
            if (*cp == '*')
                *cp = ' ';
    }

    //
    // Convert the result to unicode
    //

    AnsiString.Buffer = starred;
    AnsiString.Length = AnsiString.MaximumLength =
        (USHORT) strlen( starred );

    UnicodeString.Buffer = UnicodeOut;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = BUF_SIZ * sizeof(WCHAR);

    (VOID) RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    return;
}

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )
/*++ NlpPutString

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);

    if ( InString->Length > 0 )
    {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = InString->Length;
        *Where += OutString->MaximumLength;

        RtlCopyString( (PSTRING) OutString, (PSTRING) InString );

    }
    else
    {
        RtlInitUnicodeString(OutString, NULL);
    }

    return;
}


BOOL
LsapLogonNetwork(
    IN HANDLE  	LsaHandle,
    IN ULONG   	AuthenticationPackage,
    IN  LPWSTR      Username,
    IN  PUCHAR      ChallengeToClient,
    IN  PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponse,
    IN  UINT        cbChallengeResponse,
    IN  LPWSTR      Domain,
    OUT PLUID       LogonId,
    OUT PHANDLE     TokenHandle
    )
/*++ LogonNetwork

Routine Description:

    Logs a user onto the network

Arguments:
        IN  LPWSTR  Username    - self explanatory
        IN  ChallengeToClient   -  The challenge sent to the client
        IN  ChallengeResponse   -  The response sent from the client
        IN  LPWSTR  Domain      - Logon Domain Name
        OUT PLUID   LogonId     - Unique generated logon id
        OUT PHANDLE TokenHandle - handle to the logon token

Return Value:

    BOOL -

Warnings:

--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      TempString;
    UNICODE_STRING      TempString2;
    UNICODE_STRING      OriginName;
    PMSV1_0_LM20_LOGON  Auth;
    PCHAR               Auth1[MSV1_0_CHALLENGE_LENGTH + BUF_SIZ*2];
    PUCHAR              Strings;
    PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
    ULONG               ProfileBufferSize;
    NTSTATUS            SubStatus;
    TOKEN_SOURCE        SourceContext;
    QUOTA_LIMITS        QuotaLimits;


    /*
     *  Fill in the Authentication structure.
     */
    Auth = (PMSV1_0_LM20_LOGON) Auth1;

    Strings = (PUCHAR)(Auth + 1);

    Auth->MessageType = MsV1_0Lm20Logon;
    RtlMoveMemory( Auth->ChallengeToClient,
                   ChallengeToClient,
                   MSV1_0_CHALLENGE_LENGTH );

    /* Init Strings
     *  username
     */
    RtlInitUnicodeString( &TempString, Username );
    NlpPutString( &Auth->UserName, &TempString, &Strings );

    /*
     *  workstation name
     */
    RtlInitUnicodeString( &TempString, L"NetQFS" );
    NlpPutString( &Auth->Workstation, &TempString, &Strings );

    /*
     *  Challenge Response
     */

    Auth->CaseSensitiveChallengeResponse.Length = 0;
    Auth->CaseSensitiveChallengeResponse.MaximumLength = 0;
    Auth->CaseSensitiveChallengeResponse.Buffer = NULL;


#ifdef OLD
    RtlInitUnicodeString(
        (PUNICODE_STRING)&TempString2,
        (PCWSTR)ChallengeResponse );
#else
    TempString2.Buffer = (PWSTR)ChallengeResponse;
    TempString2.Length = (USHORT)cbChallengeResponse;
    TempString2.MaximumLength = TempString2.Length;
#endif
    if( TempString2.Length > 24 )  {
        TempString2.Length = 24;
    }
    NlpPutString(
        (PUNICODE_STRING)&Auth->CaseInsensitiveChallengeResponse,
        (PUNICODE_STRING)&TempString2,
        &Strings );
    /*
     *  domain
     */
    RtlInitUnicodeString( &TempString, Domain );
    NlpPutString( &Auth->LogonDomainName, &TempString, &Strings );


    RtlInitUnicodeString( &OriginName, L"NetQFS" );
    Status = LsaLogonUser(
                LsaHandle,
                (PSTRING)&OriginName,
                Network,
                AuthenticationPackage,
                // LATER? AuthenticationPackage | LSA_CALL_LICENSE_SERVER,
                Auth,
                (ULONG)(Strings - (PUCHAR)Auth),
                NULL,
                &SourceContext,
                (PVOID *)&ProfileBuffer,
                &ProfileBufferSize,
                LogonId,
                TokenHandle,
                &QuotaLimits,
                &SubStatus );

    if ( !NT_SUCCESS( Status ) )
    {
	extern void WINAPI debug_log(char *,...);

	debug_log("Logon  failed %x\n",Status);
        // LSA Can't be trusted to not scrog our variables
        *TokenHandle = NULL;
        return( FALSE );
    }
    LsaFreeReturnBuffer( ProfileBuffer );

    return( TRUE );
}

BOOL
LsapChallenge(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    UCHAR *ChallengeToClient
    )
/*++ Challenge

Routine Description:

    get a challenge

Arguments:
        OUT  ChallengeToClient -  Returns the challenge to send to the client

Return Value:
    NTSTATUS -
Warnings:
--*/
{
    NTSTATUS Status;
    NTSTATUS ProtocolStatus;
    ULONG    ResponseSize;
    MSV1_0_LM20_CHALLENGE_REQUEST Request;
    PMSV1_0_LM20_CHALLENGE_RESPONSE Response;

    /*
     *  Fill in the Authentication structure.
     */

    Request.MessageType = MsV1_0Lm20ChallengeRequest;

    Status = LsaCallAuthenticationPackage (
                    LsaHandle,
                    AuthenticationPackage,
                    &Request,
                    sizeof(Request),
                    (PVOID *)&Response,
                    &ResponseSize,
                    &ProtocolStatus );

    if ( !NT_SUCCESS( Status ) || !NT_SUCCESS( ProtocolStatus) )
    {
	printf("ChallengeRequest failed %x\n",Status);
        return( FALSE );
    }

    RtlMoveMemory( ChallengeToClient,
                   Response->ChallengeToClient,
                   MSV1_0_CHALLENGE_LENGTH );

    LsaFreeReturnBuffer( Response );

    return( TRUE );
}


BOOL 
LsaGetChallenge(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    LPBYTE lpChallenge,
    UINT cbSize,
    PUINT lpcbChallengeSize
    )
{
#ifdef LSA_AUDIT_FLAG
    if (LsaAuditFlag == TRUE) {
	memset(lpChallenge, 0, MSV1_0_CHALLENGE_LENGTH);
        *lpcbChallengeSize = MSV1_0_CHALLENGE_LENGTH;
	return TRUE;
    }
#endif

    if( LocalLSAInit() )  {
        *lpcbChallengeSize = MSV1_0_CHALLENGE_LENGTH;
        return LsapChallenge( LsaHandle, AuthenticationPackage, lpChallenge );
    } else {
        return( FALSE );
    }
}

BOOL
LsaValidateLogon(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    LUID    *pLogonId,
    PHANDLE phLogonToken
    )
{
    WCHAR       wcUser[ BUF_SIZ ];
    WCHAR       wcDomain[ BUF_SIZ ];
    BOOL        nlRet;
    DWORD sz = BUF_SIZ;

#ifdef LSA_AUDIT_FLAG
    if (LsaAuditFlag == 1) {
	pLogonId->LowPart = 10;
	pLogonId->HighPart = 0;
	*phLogonToken = INVALID_HANDLE_VALUE;
	return TRUE;
    }
#endif

    if (GetUserName((LPSTR)wcUser, &sz)) {
	if (lpszUserName != NULL && *lpszUserName != '\0' &&
	    _stricmp(lpszUserName, (LPSTR)wcUser) &&
	    _stricmp(lpszUserName, "administrator")) {
	    return FALSE;
	}
    }

    if( !LocalLSAInit() )  {
        return( FALSE );
    }
    replstar( lpszUserName, wcUser );
    replstar( lpszDomainName, wcDomain );
    nlRet = LsapLogonNetwork( LsaHandle, AuthenticationPackage,
			  wcUser, lpChallenge,
			  (PMSV1_0_GETCHALLENRESP_RESPONSE)lpResponse,
			  cbResponseSize, wcDomain, pLogonId, phLogonToken );
    return( nlRet );
}

BOOL
LsaGetChallengeResponse(
    HANDLE  	LsaHandle,
    ULONG   	AuthenticationPackage,
    LUID        LogonId,
    LPSTR       lpszPasswordK1,
    int         cbPasswordK1,
    LPSTR       lpszChallenge,
    int         cbChallenge,
    int         *pcbPasswordK1,
    BOOL        *pbHasPasswordK1 )
{
    NTSTATUS Status;
    NTSTATUS ProtocolStatus;
    ULONG    ResponseSize;
    PMSV1_0_GETCHALLENRESP_RESPONSE Response;
    PMSV1_0_GETCHALLENRESP_REQUEST Request;

    PCHAR          Auth1[BUF_SIZ];
    PUCHAR         Strings;


    if( !LocalLSAInit() )  {
        *pbHasPasswordK1 = FALSE;
        return( FALSE );
    }
    Request = (PMSV1_0_GETCHALLENRESP_REQUEST) Auth1;
    Request->MessageType = MsV1_0Lm20GetChallengeResponse;
    Request->ParameterControl = 0;
    Request->ParameterControl |= USE_PRIMARY_PASSWORD;
    Request->LogonId = LogonId;
    Strings = (PUCHAR)(Request + 1);
    RtlMoveMemory( Request->ChallengeToClient,
                   lpszChallenge,
                   cbChallenge );

    RtlInitUnicodeString( &Request->Password, NULL );
    Status = LsaCallAuthenticationPackage (
                    LsaHandle,
                    AuthenticationPackage,
                    Request,
                    sizeof(MSV1_0_GETCHALLENRESP_REQUEST),
                    (PVOID *)&Response,
                    &ResponseSize,
                    &ProtocolStatus );
    if ( !NT_SUCCESS( Status ) || !NT_SUCCESS( ProtocolStatus) )
    {
        return( FALSE );
    }

    *pcbPasswordK1 = (Response)->CaseInsensitiveChallengeResponse.Length;
    memcpy( lpszPasswordK1,
        (Response)->CaseInsensitiveChallengeResponse.Buffer,
        (Response)->CaseInsensitiveChallengeResponse.Length );
    *pbHasPasswordK1 = TRUE;

    LsaFreeReturnBuffer( Response );

    return( TRUE );
}

#ifdef QON_TCB_REQUIRED
// When we have support for untrusted on REQUEST we disable this. Till then we need TCB.
// I am disabling this since the we don't need TCB anymore. Note if we
// want to run in win2k then we must have TCB and this code path reenabled.

NTSTATUS
LsaInit(HANDLE  *pLsaHandle, ULONG   *pAuthenticationPackage)
{
    char    MyName[MAX_PATH];
    char *  ModuleName;
    STRING  LogonProcessName;
    STRING  PackageName;
    ULONG   dummy;
    NTSTATUS Status;
    NTSTATUS TempStatus;
    BOOLEAN WasEnabled;
    HANDLE  LsaHandle = NULL;
    ULONG   AuthenticationPackage;

    BOOLEAN fThread = FALSE;   // did we enable privilege in thread token?
    BOOL fReverted = FALSE; // did we RevertToSelf() during call?
    HANDLE hPreviousToken = NULL;

#ifdef LSA_AUDIT_FLAG
    if (LsaAuditFlag == TRUE) {
	*pLsaHandle = 0;
	*pAuthenticationPackage = 0;
	return STATUS_SUCCESS;
    }
#endif

    //
    // three SeTcbPrivilege scenarios:
    // 1. present in process token, thread not impersonating.
    // 2. present in process token, thread is impersonating.
    // 3. present in thread token.
    //

    //
    // try in this order:
    // process token (original method).
    // if thread impersonating, thread token
    // if thread impersonating, process token after reverting.
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (!NT_SUCCESS(Status))
    {
         TempStatus = NtOpenThreadToken(
                         NtCurrentThread(),
                         TOKEN_IMPERSONATE,
                         FALSE,
                         &hPreviousToken
                         );

        if( !NT_SUCCESS(TempStatus) ) {

            //
            // retry with accesscheck against process.
            //

            if( TempStatus != STATUS_ACCESS_DENIED )
                goto Cleanup;

            TempStatus = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_IMPERSONATE,
                            TRUE,
                            &hPreviousToken
                            );

            if( !NT_SUCCESS(TempStatus) )
                goto Cleanup;
        }

        //
        // thread token is present.
        // first, try enabling the privilege in the thread token.
        //

        fThread = TRUE;

        Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, fThread, &WasEnabled);

        if( !NT_SUCCESS(Status) ) {

            HANDLE NewToken = NULL;

            //
            // if that fails, try reverting and enabling privilege in process token.
            //

            TempStatus = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            &NewToken,
                            sizeof(NewToken)
                            );

            if( !NT_SUCCESS(TempStatus) )
                goto Cleanup;

            fThread = FALSE;
            fReverted = TRUE;

            Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, fThread, &WasEnabled);
            if( !NT_SUCCESS(Status) )
                goto Cleanup;
        }
    }

    GetModuleFileNameA(NULL, MyName, MAX_PATH);
    ModuleName = strrchr(MyName, '\\');
    if (!ModuleName)
    {
        ModuleName = MyName;
    }


    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, ModuleName);

    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &LsaHandle,
                 &dummy
                 );


    //
    // Turn off the privilege now.
    //

    if( !WasEnabled ) {

        (VOID) RtlAdjustPrivilege(SE_TCB_PRIVILEGE, FALSE, fThread, &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        LsaHandle = NULL;
        goto Cleanup;
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME); //"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                LsaHandle,
                &PackageName,
                &AuthenticationPackage
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    *pLsaHandle = LsaHandle;
    *pAuthenticationPackage = AuthenticationPackage;

Cleanup:

    if( hPreviousToken ) {

        if( fReverted ) {

            //
            // put old token back...
            //

            (VOID) NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hPreviousToken,
                         sizeof(hPreviousToken)
                         );
        }

        NtClose( hPreviousToken );
    }


    if( !NT_SUCCESS(Status) ) {

        if( LsaHandle ) {
            (VOID) LsaDeregisterLogonProcess( LsaHandle );
            LsaHandle = NULL;
        }

    }

    return Status;
}

#else

NTSTATUS
LsaInit(HANDLE  *pLsaHandle, ULONG   *pAuthenticationPackage)
{
    char    MyName[MAX_PATH];
    char *  ModuleName;
    STRING  LogonProcessName;
    STRING  PackageName;
    ULONG   dummy;
    NTSTATUS Status;
    NTSTATUS TempStatus;
    BOOLEAN WasEnabled;
    HANDLE  LsaHandle;
    ULONG   AuthenticationPackage;

    BOOLEAN fThread = FALSE;   // did we enable privilege in thread token?
    BOOL fReverted = FALSE; // did we RevertToSelf() during call?
    HANDLE hPreviousToken = NULL;

    //
    // Connect with LSA process
    //
    Status = LsaConnectUntrusted(&LsaHandle);
    if (!NT_SUCCESS(Status))
	return Status;

    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME); //"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                LsaHandle,
                &PackageName,
                &AuthenticationPackage
                );

    if (NT_SUCCESS(Status)) {
	*pLsaHandle = LsaHandle;
	*pAuthenticationPackage = AuthenticationPackage;
    } else {
	(VOID) LsaDeregisterLogonProcess( LsaHandle );
    }

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\srv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srv.c

Abstract:

    Implements initialization and socket interface for smb server

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#include "srv.h"

#include <process.h> // for _beginthreadex
#include <mswsock.h>

#define PROTOCOL_TYPE	SOCK_SEQPACKET

#define  PLUS_CLUSTER	1

#define THREADAPI unsigned int WINAPI

void
SrvCloseEndpoint(EndPoint_t *endpoint);

void
PacketReset(SrvCtx_t *ctx)
{
    int i, npackets, nbufs;
    Packet_t *p;
    char *buf;

    npackets = MAX_PACKETS;
    nbufs = npackets * 2;

    ctx->freelist = NULL;
    p = (Packet_t *) ctx->packet_pool;
    buf = (char *) ctx->buffer_pool;
    for (i = 0; i < npackets; i++) {
	p->buffer = (LPVOID) buf;
	p->ov.hEvent = NULL;
	buf += SRV_PACKET_SIZE;
	p->outbuf = (LPVOID) buf;
	buf += SRV_PACKET_SIZE;
	p->next = ctx->freelist;
	ctx->freelist = p;
	p++;
    }

}

BOOL
PacketInit(SrvCtx_t *ctx)
{
    int npackets, nbufs;

    // Allocate 2 buffers for each packet
    npackets = MAX_PACKETS;
    nbufs = npackets * 2;

    ctx->packet_pool = xmalloc(sizeof(Packet_t) * npackets);
    if (ctx->packet_pool == NULL) {
	SrvLogError(("Unable to allocate packet pool!\n"));
	return FALSE;
    }
    
    ctx->buffer_pool = xmalloc(SRV_PACKET_SIZE * nbufs);
    if (ctx->buffer_pool == NULL) {
	xfree(ctx->packet_pool);
	SrvLogError(("Unable to allocate buffer pool!\n"));
	return FALSE;
    }

    PacketReset(ctx);

    return TRUE;
}

Packet_t *
PacketAlloc(EndPoint_t *ep)
{
    // allocate a packet from free list, if no packet is available then
    // we set the wanted flag and wait on event

    SrvCtx_t	*ctx;
    Packet_t	*p;

    ASSERT(ep);
    ctx = ep->SrvCtx;

 retry:
    EnterCriticalSection(&ctx->cs);
    if (ctx->running == FALSE) {
	LeaveCriticalSection(&ctx->cs);
	return NULL;
    }

    if (p = ctx->freelist) {
	ctx->freelist = p->next;
    } else {
	ctx->waiters++;
	LeaveCriticalSection(&ctx->cs);
	if (WaitForSingleObject(ctx->event, INFINITE) != WAIT_OBJECT_0) {
	    return NULL;
	}
	goto retry;
    }

    // Insert into per endpoint packet list
    p->endpoint = ep;
    p->next = ep->PacketList;
    ep->PacketList = p;

    LeaveCriticalSection(&ctx->cs);

    return p;
}

void
PacketRelease(SrvCtx_t *ctx, Packet_t *p)
{
    p->next = ctx->freelist;
    ctx->freelist = p;
    if (ctx->waiters > 0) {
	ctx->waiters--;
	SetEvent(ctx->event);
    }
}

void
PacketFree(Packet_t *p)
{
    EndPoint_t	*ep;
    SrvCtx_t	*ctx;
    Packet_t	**last;

    ep = p->endpoint;
    ASSERT(ep);
    ctx = ep->SrvCtx;
    ASSERT(ctx);

    // insert packet into head of freelist. if wanted flag is set, we signal event
    EnterCriticalSection(&ctx->cs);
    // Remove packet from ep list
    last = &ep->PacketList;
    while (*last != NULL) {
	if ((*last) == p) {
	    *last = p->next;
	    break;
	}
	last = &(*last)->next;
    }
    PacketRelease(ctx, p);
    if (ep->PacketList == NULL) {
	// Free this endpoint
	SrvCloseEndpoint(ep);
    }
    LeaveCriticalSection(&ctx->cs);
}

int
ProcessPacket(EndPoint_t *ep, Packet_t *p)

{
    BOOL disp;

    if (IsSmb(p->buffer, p->len)) {
	p->in.smb = (PNT_SMB_HEADER)p->buffer;
	p->in.size = p->len;
	p->in.offset = sizeof(NT_SMB_HEADER);
	p->in.command = p->in.smb->Command;

	p->out.smb = (PNT_SMB_HEADER)p->outbuf;
	p->out.size = SRV_PACKET_SIZE;
	p->out.valid = sizeof(NT_SMB_HEADER);
	InitSmbHeader(p);

	DumpSmb(p->buffer, p->len, TRUE);

	SrvLog(("dispatching Tid:%d Uid:%d Mid:%d Flags:%x Cmd:%d...\n",
		     p->in.smb->Tid, p->in.smb->Uid, p->in.smb->Mid,
		     p->in.smb->Flags2, p->in.command));

	p->tag = 0;

	disp = SrvDispatch(p);

	if (disp == ERROR_IO_PENDING) {
	    return ERROR_IO_PENDING;
	}


	// If we handled it ok...
	if (disp) {
	    char *buffer;
	    int len;
	    int rc;

	    buffer = (char *)p->out.smb;
	    len = (int) p->out.valid;
	    DumpSmb(buffer, len, FALSE);

	    SrvLog(("sending...len %d\n", len));

	    rc = send(ep->Sock, buffer, len, 0);
	    if (rc == SOCKET_ERROR || rc != len) {
		SrvLog(("Send clnt failed %d\n", WSAGetLastError()));
		closesocket(ep->Sock);
	    }

	} else {
	    SrvLog(("dispatch failed!\n"));
	    // did not understand...hangup on virtual circuit...
	    SrvLog(("hangup! -- disp failed on sock %s\n", ep->ClientId));
	    closesocket(ep->Sock);
	}
    }

    return ERROR_SUCCESS;
}


THREADAPI
CompletionThread(LPVOID arg)
{
    Packet_t* p;
    DWORD len;
    ULONG_PTR id;
    LPOVERLAPPED lpo;
    SrvCtx_t *ctx = (SrvCtx_t *) arg;
    HANDLE port = ctx->comport;
    EndPoint_t *endpoint;
    HANDLE ev;

    ev = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Each thread needs its own event, msg to use
    while(ctx->running) {
	BOOL b;
	b = GetQueuedCompletionStatus (
                                       port,
                                       &len,
                                       &id,
                                       &lpo,
                                       INFINITE
         );

	p = (Packet_t *) lpo;
	if (p == NULL) {
	    SrvLog(("SrvThread exiting, %x...\n", id));
	    CloseHandle(ev);
	    return 0;
	}

	if (!b && !lpo) {
	    SrvLog(("Getqueued failed %d\n",GetLastError()));
	    CloseHandle(ev);
	    PacketFree(p);
	    return 0;
	}

	// todo: when socket is closed, I need to free this endpoint.
	// I need to tag the endpoint with how many packets got scheduled
	// on it, when the refcnt reachs zero, I free it.
	endpoint = (EndPoint_t *) id;

	ASSERT(p->endpoint == endpoint);
	p->ev = ev;
	p->len = len;

	if (ProcessPacket(endpoint, p) != ERROR_IO_PENDING) {
	    // schedule next read
	    b = ReadFile ((HANDLE)endpoint->Sock,
			  p->buffer,
			  SRV_PACKET_SIZE,
			  &len,
			  &p->ov);

	    if (!b && GetLastError () != ERROR_IO_PENDING) {
		SrvLog(("SrvThread read ep 0x%x failed %d\n", endpoint, GetLastError()));
		// Return packet to queue
		PacketFree(p);
	    }
	}
    }
    CloseHandle(ev);
    SrvLog(("SrvThread exiting, not running...\n"));
    return 0;
}

void
SrvFinalize(Packet_t *p)
{
    char *buffer;
    DWORD len, rc;
    EndPoint_t *endpoint = p->endpoint;
    
    ASSERT(p->tag == ERROR_IO_PENDING);

    p->tag = 0;

    buffer = (char *)p->out.smb;
    len = (DWORD) p->out.valid;
    DumpSmb(buffer, len, FALSE);

    SrvLog(("sending...len %d\n", len));
    rc = send(endpoint->Sock, buffer, len, 0);
    if (rc == SOCKET_ERROR || rc != len) {
	SrvLog(("Finalize Send clnt failed <%d>\n", WSAGetLastError()));
    }

    rc = ReadFile ((HANDLE)endpoint->Sock,
		  p->buffer,
		  SRV_PACKET_SIZE,
		  &len,
		  &p->ov);

    if (!rc && GetLastError () != ERROR_IO_PENDING) {
	// Return packet to queue
	PacketFree(p);
    }
}

void
SrvCloseEndpoint(EndPoint_t *endpoint)
{
    EndPoint_t **p;
    Packet_t *packet;

    // lock must be held
    
    while (packet = endpoint->PacketList) {
	endpoint->PacketList = packet->next;
	// return to free list now
	PacketRelease(endpoint->SrvCtx, packet);
    }

    // remove from ctx list
    p = &endpoint->SrvCtx->EndPointList;
    while (*p != NULL) {
	if (*p == endpoint) {
	    *p = endpoint->Next;
	    break;
	}
	p = &(*p)->Next;
    }

    closesocket(endpoint->Sock);

    // We need to inform filesystem that this
    // tree is gone.
    FsLogoffUser(endpoint->SrvCtx->FsCtx, endpoint->LogonId);

    free(endpoint);
}

DWORD
ListenSocket(SrvCtx_t *ctx, int nic)
{
    
    DWORD err = ERROR_SUCCESS;
    SOCKET listen_socket = INVALID_SOCKET;
    struct sockaddr_nb local;
    unsigned char *srvname = ctx->nb_local_name;

    SET_NETBIOS_SOCKADDR(&local, NETBIOS_UNIQUE_NAME, srvname, ' ');

    listen_socket = socket(AF_NETBIOS, PROTOCOL_TYPE, -nic);

    if (listen_socket == INVALID_SOCKET){
	err = WSAGetLastError();
	SrvLogError(("socket() '%s' nic %d failed with error %d\n",
		srvname, nic, err));
	return err;
    } 

    //
    // bind socket
    //

    if (bind(listen_socket,(struct sockaddr*)&local,sizeof(local)) == SOCKET_ERROR) {
	err = WSAGetLastError();
	SrvLogError(("srv nic %d bind() failed with error %d\n",nic, err));
	closesocket(listen_socket);
	return err;
    }

    // issue listen
    if (listen(listen_socket,5) == SOCKET_ERROR) {
	err = WSAGetLastError();
	SrvLogError(("listen() failed with error %d\n", err));
	closesocket(listen_socket);
	return err;
    }

    // all is well.
    ctx->listen_socket = listen_socket;
    return ERROR_SUCCESS;
}


THREADAPI
ListenThread(LPVOID arg)
{
	SOCKET listen_socket, msgsock;
	struct sockaddr_nb from;
	int fromlen;
	HANDLE comport;
	SrvCtx_t *ctx = (SrvCtx_t *) arg;
	EndPoint_t *endpoint;
	char localname[64];

	gethostname(localname, sizeof(localname));

	listen_socket = ctx->listen_socket;
	comport = ctx->comport;
	while(ctx->running) {
	    int i;

	    fromlen =sizeof(from);
	    msgsock = accept(listen_socket,(struct sockaddr*)&from, &fromlen);
	    if (msgsock == INVALID_SOCKET) {
		if (ctx->running)
		    SrvLogError(("accept() error %d\n",WSAGetLastError()));
		break;
	    }
	    from.snb_name[NETBIOS_NAME_LENGTH-1] = '\0';
	    {
		char *s = strchr(from.snb_name, ' ');
		if (s != NULL) *s = '\0';
	    }
	    SrvLog(("Received call from '%s'\n", from.snb_name));

	    // Fence off all nodes except cluster nodes. We ask
	    // our resource to check for us. For now we fence off all nodes but the this node
	    if (_stricmp(localname, from.snb_name)) {
		// sorry, we just close the connection now
		closesocket(msgsock);
		continue;
	    }

	    // allocate a new endpoint 
	    endpoint = (EndPoint_t *) malloc(sizeof(*endpoint));
	    if (endpoint == NULL) {
		SrvLogError(("Failed allocate failed %d\n", GetLastError()));
		closesocket(msgsock);
		continue;
	    }
		
	    memset(endpoint, 0, sizeof(*endpoint));

	    // add endpoint now
	    EnterCriticalSection(&ctx->cs);
	    endpoint->Next = ctx->EndPointList;
	    ctx->EndPointList = endpoint;
	    LeaveCriticalSection(&ctx->cs);

	    endpoint->Sock = msgsock;
	    endpoint->SrvCtx = ctx;
	    memcpy(endpoint->ClientId, from.snb_name, sizeof(endpoint->ClientId));
	    
	    comport = CreateIoCompletionPort((HANDLE)msgsock, comport,
					     (ULONG_PTR)endpoint, 8);
	    if (!comport) {
		SrvLogError(("CompletionPort bind Failed %d\n", GetLastError()));
		SrvCloseEndpoint(endpoint);
		comport = ctx->comport;
		continue;
	    }

	    for (i = 0; i < SRV_NUM_WORKERS; i++) {
		Packet_t *p;
		BOOL b;
		DWORD nbytes;

		p = PacketAlloc(endpoint);
		if (p == NULL) {
		    SrvLog(("Listen thread got null packet, exiting posted...\n"));
		    break;
		}
		    
		b = ReadFile (
		    (HANDLE) msgsock,
		    p->buffer,
		    SRV_PACKET_SIZE,
		    &nbytes,
		    &p->ov);

		if (!b && GetLastError () != ERROR_IO_PENDING)  {
		    SrvLog(("Srv ReadFile Failed %d\n",
			    GetLastError()));
		    // Return packet to queue
		    PacketFree(p);
		    break;
		}
	    }
	}

	return (0);
}



DWORD
SrvInit(PVOID resHdl, PVOID fsHdl, PVOID *Hdl)
{
    SrvCtx_t *ctx;
    DWORD err;

    ctx = (SrvCtx_t *) malloc(sizeof(*ctx));
    if (ctx == NULL) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(ctx, 0, sizeof(*ctx));

    ctx->FsCtx = fsHdl;
    ctx->resHdl = resHdl;

    // init lsa now
    err = LsaInit(&ctx->LsaHandle, &ctx->LsaPack);
    if (err != ERROR_SUCCESS) {
	SrvLogError(("LsaInit failed with error %x\n", err));
	free(ctx);
	return err;
    }

    // init winsock now
    if (WSAStartup(0x202,&ctx->wsaData) == SOCKET_ERROR) {
	err = WSAGetLastError();
	SrvLogError(("WSAStartup failed with error %d\n", err));

	free(ctx);
	return err;
    }


    InitializeCriticalSection(&ctx->cs);
    ctx->running = FALSE;
    ctx->event = CreateEvent(NULL, FALSE, FALSE, NULL);
    ctx->waiters = 0;

    if (PacketInit(ctx) != TRUE) {
	WSACleanup();
	return ERROR_NO_SYSTEM_RESOURCES;
    }


    SrvUtilInit(ctx);

    *Hdl = (PVOID) ctx;
    return ERROR_SUCCESS;
}

DWORD
SrvOnline(PVOID Hdl, LPWSTR name, DWORD nic)
{
    SrvCtx_t *ctx = (SrvCtx_t *) Hdl;
    DWORD err;
    int i;
    int nFixedThreads = 1;
    char localname[128];
    SYSTEM_INFO sysinfo;

    if (ctx == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    if (nic > 0)
	nic--;

    //
    // Start up threads in suspended mode
    //
    if (ctx->running == TRUE)
	return ERROR_SUCCESS;

    // save name to use
    if (name != NULL) {
	// we need to translate name to ascii
	i = wcstombs(localname, name, NETBIOS_NAME_LENGTH-1);
	localname[i] = '\0';
	strncpy(ctx->nb_local_name, localname, NETBIOS_NAME_LENGTH);
    } else {
	// use local name and append our -crs extension
	gethostname(localname, sizeof(localname));
	strcat(localname, SRV_NAME_EXTENSION);
	strncpy(ctx->nb_local_name, localname, NETBIOS_NAME_LENGTH);
    }

    for (i = 0; i < NETBIOS_NAME_LENGTH; i++) {
	ctx->nb_local_name[i] = (char) toupper(ctx->nb_local_name[i]);
    }
    // create completion port
    GetSystemInfo(&sysinfo);
    ctx->comport = CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0, 
				     sysinfo.dwNumberOfProcessors*8);
    if (ctx->comport == INVALID_HANDLE_VALUE) {
	err = GetLastError();
	SrvLogError(("Unable to create completion port %d\n", err));
	WSACleanup();
	return err;
    }

    // create listen socket
    ctx->nic = nic;
    err = ListenSocket(ctx, nic);
    if ( err != ERROR_SUCCESS) {
	WSACleanup();
	return  err;
    }

    // start up 1 listener/receiver, a few workers, a few senders....
    ctx->nThreads = nFixedThreads + SRV_NUM_SENDERS;
    ctx->hThreads = (HANDLE *) malloc(sizeof(HANDLE) * ctx->nThreads);
    if (ctx->hThreads == NULL) {
	WSACleanup();
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    for (i = 0; i < nFixedThreads; i++) {
	ctx->hThreads[i] = (HANDLE)
	    _beginthreadex(NULL, 0, &ListenThread, (LPVOID)ctx, CREATE_SUSPENDED,  NULL);
    }
    for ( ; i < ctx->nThreads; i++) {
        ctx->hThreads[i] = (HANDLE)
	_beginthreadex(NULL, 0, &CompletionThread, (LPVOID)ctx, CREATE_SUSPENDED, NULL);
    }

    ctx->running = TRUE;
    for (i = 0; i < ctx->nThreads; i++)
        ResumeThread(ctx->hThreads[i]);

    return ERROR_SUCCESS;
}

DWORD
SrvOffline(PVOID Hdl)
{
    int i;
    SrvCtx_t *ctx = (SrvCtx_t *) Hdl;

    if (ctx == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    // we shutdown all threads in the completion port
    // we close all currently open sockets
    // we free all memory
    if (ctx->running) {
	EndPoint_t *ep;
        ctx->running = FALSE;
	closesocket(ctx->listen_socket);

	EnterCriticalSection(&ctx->cs);
	for (ep = ctx->EndPointList; ep; ep = ep->Next)
	    closesocket(ep->Sock);
	LeaveCriticalSection(&ctx->cs);
        SrvLog(("waiting for threads to die off...\n"));

	// send a kill packet to all threads on the completion port
	for (i = 0; i < ctx->nThreads; i++) {
	    if (!PostQueuedCompletionStatus(ctx->comport, 0, 0, NULL)) {
		SrvLog(("Port queued port failed %d\n", GetLastError()));
		break;
	    }
	}
	    
	if (i == ctx->nThreads) {
	    // wait for them to die of natural causes before we kill them...
	    WaitForMultipleObjects(ctx->nThreads, ctx->hThreads, TRUE, INFINITE);
	}

	// close handles
	for (i = 0; i < ctx->nThreads; i++) {
	    CloseHandle(ctx->hThreads[i]);
	}

	CloseHandle(ctx->comport);

        free((char *)ctx->hThreads);

	// free endpoints
	EnterCriticalSection(&ctx->cs);
	while (ep = ctx->EndPointList)
	    SrvCloseEndpoint(ep);
	LeaveCriticalSection(&ctx->cs);

    }

    return ERROR_SUCCESS;
}

void
SrvExit(PVOID Hdl)
{
    SrvCtx_t *ctx = (SrvCtx_t *) Hdl;

    if (ctx != NULL) {
	SrvUtilExit(ctx);

	// must do this last!
	if (ctx->packet_pool)
	    xfree(ctx->packet_pool);
	if (ctx->buffer_pool)
	    xfree(ctx->buffer_pool);

	free(ctx);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\replay.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    replay.c

Abstract:

    Implements replay of records during replica recovery

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>


#include "fs.h"
#include "fsp.h"

#include "fsutil.h"

NTSTATUS
fs_replay_create(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_create_msg_t msg;
    fs_create_reply_t reply;
    WCHAR name[MAXPATH];
    int name_sz = sizeof(name);
    HANDLE	vfd = FS_GET_VOL_HANDLE(volinfo, mid);


    name[0] = '\0';
    memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
    msg.flags = lrec->flags;
    msg.attr = lrec->attrib;

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogReplay(("fs_replay_create: try %I64x:%I64x\n", lrec->id[0],
		  lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_sz);

    if (err == STATUS_SUCCESS) {
	IO_STATUS_BLOCK ios;

	msg.name = xFsBuildRelativePath(volinfo, mid, name);
	msg.name_len = (USHORT) wcslen(msg.name);
	msg.fnum = INVALID_FHANDLE_T;

	ios.Information = sizeof(reply);
	err = FspCreate(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
			(PVOID) &reply, &ios.Information);
    }

    FsLogReplay(("fs_replay_create: %S err %x\n", name, err));

    return err;
}

NTSTATUS
fs_replay_setattr(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_setattr_msg_t msg;
    WCHAR	name[MAXPATH];
    int name_sz = sizeof(name);
    HANDLE	vfd = FS_GET_VOL_HANDLE(volinfo, nid);

    // find path for fs_id 
    FsLogReplay(("fs_replay_setattr: try %I64x:%I64x\n", lrec->fs_id[0],
		  lrec->fs_id[1]));

    err = xFsGetPathById(vfd, &lrec->fs_id, name, &name_sz);
    if (err == STATUS_SUCCESS) {
	IO_STATUS_BLOCK ios;

	ios.Information = 0;

	// todo: we need to read current attr from master and apply it into nid disk.
	// FileAttributes are not enough, we could have time changes which need to be
	// in sync in all disks.
	memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
	msg.fs_id = &lrec->fs_id;
	msg.name = xFsBuildRelativePath(volinfo, nid, name);
	msg.name_len = (USHORT) wcslen(msg.name);
	memset(&msg.attr, 0, sizeof(msg.attr));
	msg.attr.FileAttributes = lrec->attrib;

	err = FspSetAttr2(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
			 NULL, &ios.Information);
    }
    FsLogReplay(("replay_setattr: %I64x err %x\n",
		 lrec->fs_id[0], err));

    return err;

}

NTSTATUS
fs_replay_mkdir(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_create_msg_t msg;
    WCHAR name[MAXPATH];
    int name_sz = sizeof(name);
    HANDLE	vfd = FS_GET_VOL_HANDLE(volinfo, mid);

    name[0] = '\0';

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogReplay(("fs_replay_mkdir: %I64x:%I64x\n", lrec->id[0],
		  lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_sz);

    if (err == STATUS_SUCCESS) {
	IO_STATUS_BLOCK ios;

	ios.Information = 0;

	memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
	msg.name = xFsBuildRelativePath(volinfo, mid, name);
	msg.name_len = (USHORT) wcslen(msg.name);
	msg.flags = lrec->flags;
	msg.attr = lrec->attrib;

	err = FspMkDir(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
		       NULL, &ios.Information);

    }

    FsLogReplay(("Replay Mkdir %S err %x\n", name, err));

    return err;
}


NTSTATUS
fs_replay_remove(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_remove_msg_t msg;
    // we find the objectid in the old replica, since file is already delete in master
    HANDLE ovfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR name[MAXPATH];
    int name_sz = sizeof(name);

    name[0] = '\0';

    FsLogReplay(("fs_relay_remove: %I64x:%I64x\n", lrec->fs_id[0],
		  lrec->fs_id[1]));

    err = xFsGetPathById(ovfd, &lrec->fs_id, name, &name_sz);

    if (err == STATUS_SUCCESS) {
	IO_STATUS_BLOCK ios;

	ios.Information = 0;

	memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
	msg.fs_id = &lrec->fs_id;
	msg.name = xFsBuildRelativePath(volinfo, nid, name);
	msg.name_len = (USHORT) wcslen(msg.name);

	err = FspRemove(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
			NULL, &ios.Information);

    }

    FsLogReplay(("Replay remove %S err %x\n", name, err));

    return err;
}


NTSTATUS
fs_replay_rename(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_rename_msg_t msg;
    HANDLE	vfd = FS_GET_VOL_HANDLE(volinfo,mid);
    HANDLE	ovfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR	old_name[MAXPATH];
    WCHAR	new_name[MAXPATH];
    int	old_name_sz = sizeof(old_name);
    int	new_name_sz = sizeof(new_name);

    new_name[0] = old_name[0] = '\0';

    FsLogReplay(("fs_relay_rename: %I64x:%I64x\n", lrec->fs_id[0],
		  lrec->fs_id[1]));

    // get old name
    err = xFsGetPathById(ovfd, &lrec->fs_id, old_name, &old_name_sz);
    if (err == STATUS_SUCCESS) {
	IO_STATUS_BLOCK ios;

	ios.Information = 0;

	// get the new name
	err = xFsGetPathById(vfd, &lrec->fs_id, new_name, &new_name_sz);

	if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
	    NTSTATUS e;
	    // if we can't find file in the master disk, we must
	    // rename the file, pick a name based on file id
	    swprintf(new_name, L"%S%I64x%I64x", old_name,
		    lrec->fs_id[0],lrec->fs_id[1]);
	    new_name_sz = wcslen(new_name);
	    err = STATUS_SUCCESS;
	    mid = nid;
	}

	if (err == STATUS_SUCCESS) {


	    memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
	    msg.fs_id = &lrec->fs_id;
	    msg.sname = xFsBuildRelativePath(volinfo, nid, old_name);
	    msg.sname_len = (USHORT) wcslen(msg.sname);
	    msg.dname = xFsBuildRelativePath(volinfo, mid, new_name);
	    msg.dname_len = (USHORT) wcslen(msg.dname);
	    
	    err = FspRename(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
			    NULL, &ios.Information);
	
	}
    }

    FsLogReplay(("Replay rename %S -> %S err %x\n", old_name, new_name, err));

    return err;
}


NTSTATUS
fs_replay_write(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    HANDLE shdl = INVALID_HANDLE_VALUE;
    HANDLE dhdl = INVALID_HANDLE_VALUE;
    char *buf = NULL;
    fs_io_msg_t msg;
    HANDLE	ovfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE	vfd = FS_GET_VOL_HANDLE(volinfo, mid);


    FsLogReplay(("fs_replay_write: %I64x:%I64x\n", lrec->fs_id[0],
		  lrec->fs_id[1]));

    // get the new file first
    err = xFsGetHandleById(vfd, &lrec->fs_id, FILE_GENERIC_READ, &shdl);

    if (err == STATUS_SUCCESS) {
	LARGE_INTEGER off;
	IO_STATUS_BLOCK ios2;

	ios2.Information = 0;

	// get old file
	err = xFsGetHandleById(ovfd, &lrec->fs_id, FILE_GENERIC_WRITE, &dhdl);
	if (err != STATUS_SUCCESS) {
	    // this is a very bad error, must abort now
	    FsLogReplay(("Aborting replay_write err %x\n", err));
	    err = STATUS_TRANSACTION_ABORTED;
	    goto done;
	}


	// we need to read the new data from the sfd first
	if (lrec->length > 0) {
	    // allocate buf
	    buf = VirtualAlloc(NULL, lrec->length, MEM_RESERVE|MEM_COMMIT,
			       PAGE_READWRITE);

	    if (buf == NULL) {
		FsLogError(("Unable to allocate write buffer to replay\n"));
		err = STATUS_TRANSACTION_ABORTED;
		goto done;
	    }


	    off.LowPart = lrec->offset;
	    off.HighPart = 0;

	    // read local data. xxx: what if the file is locked? 
	    err = NtReadFile(shdl, NULL, NULL, NULL, &ios, buf,
			     lrec->length, &off, NULL);

	    if (err == STATUS_PENDING) {
		EventWait(shdl);
	    }

	    if (ios.Status != STATUS_SUCCESS) {
		FsLogReplay(("Read failed for replay %x\n", ios.Status));
		err = STATUS_TRANSACTION_ABORTED;
		goto done;
	    }
	} else {
	    buf = NULL;
	    ios.Information = 0;
	}
			
	memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
	msg.fs_id = &lrec->fs_id;
	msg.offset = lrec->offset;
	msg.size = (UINT32)ios.Information;
	msg.buf = buf;
	msg.context = (PVOID) dhdl;
	msg.fnum = INVALID_FHANDLE_T;

	err = FspWrite(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg), NULL, &ios2.Information);
	// check if we have the same size, otherwise abort
	if ((ULONG)ios2.Information != lrec->length) {
	    FsLogError(("Write sz mismatch, %d expected %d\n", (ULONG)ios2.Information, lrec->length));
	    err = STATUS_TRANSACTION_ABORTED;
	}
    }

 done:
    if (buf != NULL) {
	VirtualFree(buf, 0, MEM_DECOMMIT|MEM_RELEASE);
    }

    if (shdl != INVALID_HANDLE_VALUE)
	xFsClose(shdl);

    if (dhdl != INVALID_HANDLE_VALUE)
	xFsClose(dhdl);

    FsLogReplay(("Replay write offset %d len %d err %x\n", 
		 lrec->offset, lrec->length, err));

    return err;
}


FsReplayHandler_t FsReplayCallTable[] = {
    fs_replay_create,
    fs_replay_setattr,
    fs_replay_write,
    fs_replay_mkdir,
    fs_replay_remove,
    fs_replay_rename
};

NTSTATUS
FsReplayFid(VolInfo_t *volinfo, UserInfo_t *uinfo, int nid, int mid)
{
    int i;
    WCHAR path[MAXPATH];
    WCHAR *name;
    int	name_len;
    NTSTATUS err = STATUS_SUCCESS;

    // Open on replica nid all currently open files.
    for (i = 0; i < FsTableSize; i++) {
	HANDLE fd;
	UINT32 disp, share, access, flags;

	// todo: this should be in a for loop
	fd = uinfo->Table[i].Fd[mid];
	if (fd == INVALID_HANDLE_VALUE) 
	    continue;
	
	// get path name
	name_len = sizeof(path);
	err = xFsGetHandlePath(fd, path, &name_len);
	if (err != STATUS_SUCCESS) {
	    FsLogReplay(("FsReplayFid %d failed on handlpath %x\n",
			 mid, err));
	    // todo: the master might have failed, we should just
	    // try to go to a differnet replica if possible
	    return err;
	}
	// issue open against nid, but first get filename from master
	name = xFsBuildRelativePath(volinfo, mid, path);

	DecodeCreateParam(uinfo->Table[i].Flags, &flags, &disp, &share, &access);

	err = xFsOpen(&fd, FS_GET_VOL_HANDLE(volinfo, nid),
		      name, wcslen(name),
		      access, share, 0);

	if (err != STATUS_SUCCESS) {
	    FsLogReplay(("FsReplayFid mid %d nid %d open file '%S' '%S' failed %x\n",
			 mid, nid, name, path, err));
	    // Cleanup all open handles we have before returning an
	    // error. We cleanup this node later, so that's ok.
	    return err;
	}

	// we now add the open handle to the nid slot
	FS_SET_USER_HANDLE(uinfo, nid, i, fd);

	// todo: issue locks
    }
    return err;
}

NTSTATUS
FsReplayXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid)
{
    fs_log_rec_t	*p = (fs_log_rec_t *) arg;
    NTSTATUS		err = ERROR_SUCCESS;
    fs_id_t		*fs_id;
    HANDLE		vhdl;

    vhdl = FS_GET_VOL_HANDLE(volinfo, nid);
    if (vhdl == INVALID_HANDLE_VALUE) {
	FsLogUndo(("FsUndoXid Failed to get crs handle %d\n",
		     nid));
	return STATUS_TRANSACTION_ABORTED;
    }

    vhdl = FS_GET_VOL_HANDLE(volinfo, mid);
    if (vhdl == INVALID_HANDLE_VALUE) {
	FsLogReplay(("FsReplayXid Failed to get crs handle %d\n",
		     mid));
	return STATUS_TRANSACTION_ABORTED;
    }


    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    fs_id = &p->id;

    FsLogReplay(("Replay cmd %d mid %d nid %d objid %I64x:%I64x\n", p->command,
		 mid, nid,
		 (*fs_id)[0], (*fs_id)[1]));

    err = FsReplayCallTable[p->command](volinfo, p, nid, mid);

    FsLogReplay(("Replay Status %x\n", err));

    return err;
}

NTSTATUS
FsQueryXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid)
{
    fs_log_rec_t	*p = (fs_log_rec_t *) arg;
    NTSTATUS		err = ERROR_SUCCESS;
    fs_id_t		*fs_id;
    HANDLE		vhdl;
    WCHAR		name[MAXPATH];
    int			name_sz = sizeof(name);

    ASSERT(nid == mid);
    vhdl = FS_GET_VOL_HANDLE(volinfo, nid);
    if (vhdl == INVALID_HANDLE_VALUE) {
	FsLogUndo(("FsUndoXid Failed to get crs handle %d\n",
		     nid));
	return STATUS_TRANSACTION_ABORTED;
    }

    fs_id = &p->fs_id;

    FsLogReplay(("Query cmd %d nid %d objid %I64x:%I64x\n", p->command,
		 nid, (*fs_id)[0], (*fs_id)[1]));

    switch(p->command) {
    case FS_CREATE:
    case FS_MKDIR:
	// issue a lookup, 
	// note: use id instead of fs_id since we don't have fs_id till
	// a prepare has committed.
	fs_id = &p->id;
	err = xFsGetPathById(vhdl, fs_id, name, &name_sz);
	if (err == STATUS_OBJECT_PATH_NOT_FOUND)
	    err = STATUS_CANCELLED;
	break;
    case FS_REMOVE:
	err = xFsGetPathById(vhdl, fs_id, name, &name_sz);
	if (err == STATUS_OBJECT_PATH_NOT_FOUND)
	    err = STATUS_SUCCESS;
	else if (err == STATUS_SUCCESS)
	    err = STATUS_CANCELLED;
	break;
    default:
	// can't make any determination
	err = STATUS_NOT_FOUND;
	break;
    }

    FsLogReplay(("Commit Status %x\n", err));

    return err;
}



////////////////////////// Recovery Callback ////////////////////////////


NTSTATUS
WINAPI
FsCrsCallback(PVOID hd, int nid, CrsRecord_t *arg, int action, int mid)
{
    NTSTATUS		err = STATUS_SUCCESS;
    VolInfo_t		*volinfo = (VolInfo_t *) hd;

    switch(action) {

    case CRS_ACTION_REPLAY:

	err = FsReplayXid(volinfo, nid, arg, action, mid);
	break;

    case CRS_ACTION_UNDO:

	err = FsUndoXid(volinfo, nid, arg, action, mid);
	break;

    case CRS_ACTION_QUERY:

	err = FsQueryXid(volinfo, nid, arg, action, mid);
	break;

    case CRS_ACTION_DONE:
	FsLogReplay(("Vol %S done recovery nid %d mid %d\n",
		     volinfo->Root, nid, mid));


	// we now need to walk our current open table and join this new replica.
	{
	    UserInfo_t *u = volinfo->UserList;

	    for (; u != NULL; u = u->Next) {
		err = FsReplayFid(volinfo, u, nid, mid);
		if (err != STATUS_SUCCESS)
		    break;
	    }
	}
	break;

    case CRS_ACTION_COPY:

	FsLogReplay(("FullCopy Disk%d -> Disk%d\n", mid, nid));

	//
	// We need to open new directory handles instead of using current ones. Otherwise,
	// our enum on directory might not be consistent
	//
	if (0) {
	    WCHAR	path[MAXPATH];
	    HANDLE	mvfd, ovfd;
	    UINT32	disp;

	    // open root volume directory
	    disp = FILE_OPEN;
	    swprintf(path, L"\\??\\%s\\%s\\", FS_GET_VOL_NAME(volinfo, mid), volinfo->Root);
	    err = xFsCreate(&mvfd, NULL, path, wcslen(path),
			    FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
			    0,
			    FILE_SHARE_READ|FILE_SHARE_WRITE,
			    &disp,
			    FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
			    NULL, 0);
	    if (err != STATUS_SUCCESS) {
		FsLogReplay(("Failed to open mid %d '%S' err %x\n", mid, path, err));
		return err;
	    }

	    // open root volume directory
	    disp = FILE_OPEN;
	    swprintf(path, L"\\??\\%s\\%s\\", FS_GET_VOL_NAME(volinfo, nid), volinfo->Root);
	    err = xFsCreate(&ovfd, NULL, path, wcslen(path),
			    FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
			    0,
			    FILE_SHARE_READ|FILE_SHARE_WRITE,
			    &disp,
			    FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
			    NULL, 0);
	    if (err != STATUS_SUCCESS) {
		xFsClose(mvfd);
		FsLogReplay(("Failed to open nid %d '%S' err %x\n", mid, path, err));
		return err;
	    }

	    
	    err = xFsCopyTree(mvfd, ovfd);
	    xFsClose(mvfd);
	    xFsClose(ovfd);
	} else {
	    err = xFsCopyTree(FS_GET_VOL_HANDLE(volinfo, mid),
			      FS_GET_VOL_HANDLE(volinfo,nid));

	}
	FsLogReplay(("SlowStart Crs%d status %x\n", nid, err));

	break;

    default:
	FsLogReplay(("Unknown action %d\n", action));
	ASSERT(FALSE);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\srvcom.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srvcom.c

Abstract:

    Implements com smb packets

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#include "srv.h"

#define UPDATE_OUT_LEN(msg, resp_type, resp)      \
    (msg->out.valid += SIZEOF_SMB_PARAMS(resp_type, resp->ByteCount))

#define UPDATE_FOR_NEXT_ANDX(msg, req_type, req, resp_type, resp) {    \
        resp->AndXCommand = req->AndXCommand;                          \
        resp->AndXReserved = 0;                                        \
        resp->AndXOffset = UPDATE_OUT_LEN(msg, resp_type, resp);       \
        msg->in.command = req->AndXCommand;                            \
        msg->in.offset += SIZEOF_SMB_PARAMS(req_type, req->ByteCount); \
    }

#define SET_REQ(type, name, msg) \
    name = ((type)(((PUCHAR) msg->in.smb)+msg->in.offset))

#define SET_RESP(type, name, msg) \
    name = ((type)(((PUCHAR) msg->out.smb)+msg->out.valid))

#define SET_TYPE(type, name) \
    type name

extern DWORD dm_close(USHORT);

BOOL
SrvComUnknown(	
    Packet_t * msg
    )
{
    if (msg == NULL)
	return FALSE;

    SrvLog(("(------ CANNOT HANDLE THIS COMMAND %x ------)\n",
		 msg->in.command));
    SET_DOSERROR(msg, SERVER, NO_SUPPORT);
    return TRUE;
}


#define SRV_DIALECT_STRING	"LM1.2X002"

BOOL
SrvComNegotiate(
    Packet_t * msg
    )
{
    LPCSTR szDialect = NULL;
    int offset;
    USHORT dialect;
    BOOL found;
    EndPoint_t *ep;
    SET_TYPE(PREQ_NEGOTIATE, pReq);

    if (msg == NULL)
	return FALSE;

    ep = msg->endpoint;

    SET_REQ(PREQ_NEGOTIATE, pReq, msg);

    offset = sizeof(UCHAR);
    dialect = 0;

    found = FALSE;
    while (offset < pReq->ByteCount) {
        szDialect = (LPCSTR)NEXT_LOCATION(pReq, REQ_NEGOTIATE, offset);

        if (!lstrcmp(szDialect, SRV_DIALECT_STRING)) {
	    SrvLog(("Using dialect %s\n", szDialect));
            found = TRUE;
            break;
        }
        dialect++;
        offset += lstrlen(szDialect) + 1 + sizeof(UCHAR);
    }

    if (found) {
	SET_TYPE(PRESP_NEGOTIATE, pResp);

	SET_RESP(PRESP_NEGOTIATE, pResp, msg);
	// LM1.2X002
	msg->out.smb->Flags |= SMB_FLAGS_LOCK_AND_READ_OK;

        // spew back the dialect we want...
	pResp->WordCount = 13;
	pResp->DialectIndex = dialect;
	pResp->SecurityMode = NEGOTIATE_ENCRYPT_PASSWORDS|NEGOTIATE_USER_SECURITY; 
	pResp->MaxBufferSize = (USHORT)msg->out.size;
	pResp->MaxMpxCount = (USHORT)SRV_NUM_WORKERS;
	pResp->MaxNumberVcs = 1;
	pResp->RawMode = 0;
	pResp->SessionKey = 1;
	pResp->ServerTime.Ushort = 0;
	pResp->ServerDate.Ushort = 0;
	pResp->ServerTimeZone = 0;
	pResp->EncryptionKeyLength = 0;
	pResp->Reserved = 0;
	pResp->ByteCount = 0;
	{
	    UINT	sz;

	    found = LsaGetChallenge(ep->SrvCtx->LsaHandle,
				  ep->SrvCtx->LsaPack,
				  ep->ChallengeBuffer,
				  sizeof(ep->ChallengeBuffer),
				  &sz);
	    if (found == TRUE) { 
		pResp->ByteCount = (SHORT) sz;
		pResp->EncryptionKeyLength = (SHORT) sz;
		ep->ChallengeBufferSz = sz;
		memcpy(pResp->Buffer, ep->ChallengeBuffer, sz);

		UPDATE_OUT_LEN(msg, RESP_NEGOTIATE, pResp);
	    }
	}
    }

    if (!found) {
        // spew back an error to the client...
	SET_TYPE(PRESP_OLD_NEGOTIATE, pOldResp);

	SET_RESP(PRESP_OLD_NEGOTIATE, pOldResp, msg);
        pOldResp->WordCount = 1;
        pOldResp->DialectIndex = 0xFFFF;
        pOldResp->ByteCount = 0;
        msg->out.valid += sizeof(PRESP_OLD_NEGOTIATE);
	UPDATE_OUT_LEN(msg, RESP_OLD_NEGOTIATE, pOldResp);
    }

    return TRUE;
}

BOOL
SrvComSessionSetupAndx(
    Packet_t * msg
    )
{
    PCHAR szAccountName = NULL;
    PCHAR szDomainName = NULL;
    PCHAR pAccountPassword = NULL;
    int offset = 0;
    int pwdlen;
    BOOL  found;
    DWORD error;
    HANDLE token;
    LUID   logonid;
    EndPoint_t *ep;
    SET_TYPE(PRESP_SESSION_SETUP_ANDX, pResp);
    SET_TYPE(PREQ_SESSION_SETUP_ANDX, pReq);

    if (msg == NULL)
	return FALSE;

    ep = msg->endpoint;

    SET_RESP(PRESP_SESSION_SETUP_ANDX, pResp, msg);
    SET_REQ(PREQ_SESSION_SETUP_ANDX, pReq, msg);

    pResp->WordCount = 3;
    pResp->Action = 0;
    pResp->ByteCount = 0;


    if (pReq->WordCount == 12)
	return FALSE;

    SrvLog(("MxBuf: %x MxMpx: %d Key: %x Count: %d\n", pReq->MaxBufferSize,
		 pReq->MaxMpxCount, pReq->SessionKey, pReq->ByteCount));
    SrvLog(("Count: %d Pwd %d\n", pReq->ByteCount, pReq->PasswordLength));

    if (pReq->WordCount == 13) {
	PREQ_NT_SESSION_SETUP_ANDX pNtReq = (PREQ_NT_SESSION_SETUP_ANDX) pReq;

        if (pNtReq->ByteCount > offset) {
            pAccountPassword = (PCHAR)
                NEXT_LOCATION(pNtReq, REQ_NT_SESSION_SETUP_ANDX, offset);
            offset += pNtReq->CaseInsensitivePasswordLength;
            offset += pNtReq->CaseSensitivePasswordLength;
        }
        if (pNtReq->ByteCount > offset) {
            szAccountName = (PCHAR)
                NEXT_LOCATION(pNtReq, REQ_NT_SESSION_SETUP_ANDX, offset);
            offset += lstrlen(szAccountName) + 1;
        }

	pwdlen = pNtReq->CaseInsensitivePasswordLength; 

    }

    else if (pReq->WordCount == 10) {

        if (pReq->ByteCount > offset) {
            pAccountPassword = (PCHAR)
                NEXT_LOCATION(pReq, REQ_SESSION_SETUP_ANDX, offset);
            offset += pReq->PasswordLength;
        }
        if (pReq->ByteCount > offset) {
            szAccountName = (PCHAR)
                NEXT_LOCATION(pReq, REQ_SESSION_SETUP_ANDX, offset);
            offset += lstrlen(szAccountName) + 1;
        }
        if (pReq->ByteCount > offset) {
            szDomainName = (PCHAR)
                NEXT_LOCATION(pReq, REQ_SESSION_SETUP_ANDX, offset);
            offset += lstrlen(szDomainName) + 1;
        }
	pwdlen = pReq->PasswordLength; 

    }

    SrvLog(("setup username: %s\n", szAccountName));
    SrvLog(("setup domainname: %s\n", szDomainName));

    found = LsaValidateLogon(ep->SrvCtx->LsaHandle,
			     ep->SrvCtx->LsaPack,
			     ep->ChallengeBuffer, ep->ChallengeBufferSz,
			     pAccountPassword, pwdlen,
			     szAccountName, szDomainName,
			     &logonid, &token);
    if (found == TRUE) {
	// we need to remember the token and use it for all io operations
	error = FsLogonUser(ep->SrvCtx->FsCtx, token, logonid,
			      &msg->out.smb->Uid);
	if (error != ERROR_SUCCESS) {
	    SrvLog(("DOSERROR: user logon failed %d\n", error));
	    SET_DOSERROR(msg, SERVER, TOO_MANY_UIDS);
	} else {
	    // remember logon for this endpoint
	    ep->LogonId = logonid;
	    msg->in.smb->Uid = msg->out.smb->Uid;
	    SrvLog(("Setting up uid %d\n", msg->out.smb->Uid));
	}
    } else {
	SrvLogError(("DOSERROR: could not authenticate user\n"));
	SET_DOSERROR(msg, SERVER, BAD_PASSWORD);
    }

    if (pReq->WordCount == 10) {
	UPDATE_FOR_NEXT_ANDX(msg, 
			     REQ_SESSION_SETUP_ANDX, pReq,
			     RESP_SESSION_SETUP_ANDX, pResp);
    } else {
	UPDATE_FOR_NEXT_ANDX(msg, 
			     REQ_NT_SESSION_SETUP_ANDX, pReq,
			     RESP_SESSION_SETUP_ANDX, pResp);
    }

    return SrvDispatch(msg);
}

BOOL
SrvComTreeConnectAndx(
    Packet_t * msg
    )
{
    PUCHAR pPassword = NULL;
    PCHAR szPath = NULL;
    PCHAR szService = NULL;
    int offset = 0;
    DWORD error;
    SET_TYPE(PREQ_TREE_CONNECT_ANDX, pReq);
    SET_TYPE(PRESP_TREE_CONNECT_ANDX, pResp);

    if (msg == NULL)
	return FALSE;

    SET_REQ(PREQ_TREE_CONNECT_ANDX, pReq, msg);
    SET_RESP(PRESP_TREE_CONNECT_ANDX, pResp, msg);

    SrvLog(("TreeConnect pwdlen %d cnt %d\n", pReq->PasswordLength, pReq->ByteCount));

    if (pReq->ByteCount > offset) {
        pPassword = (PUCHAR)
            NEXT_LOCATION(pReq, REQ_TREE_CONNECT_ANDX, offset);
        offset += pReq->PasswordLength;
    }

    if (pReq->ByteCount > offset) {
        szPath = (PCHAR)
            NEXT_LOCATION(pReq, REQ_TREE_CONNECT_ANDX, offset);
        offset += lstrlen(szPath) + 1;
    }
    if (pReq->ByteCount > offset) {
        szService = (PCHAR)
            NEXT_LOCATION(pReq, REQ_TREE_CONNECT_ANDX, offset);
    }

    if (szPath != NULL) {
	PCHAR s = strrchr(szPath, '\\');
	if (s != NULL) {
	    szPath = s + 1;
	}
	SrvLog(("Path %s\n", szPath));
    }

    if (szService != NULL) {
	szService[4] = '\0';
	SrvLog(("Service %s\n", szService));
    }

    if (szPath != NULL) {
	// convert name to unicode
	int wsz;
	LPWSTR wpath;

	SRV_ASCII_TO_WCHAR(wpath, wsz, szPath, strlen(szPath));
	if (wpath)
	    // Get tree id
	    error = FsMount(msg->endpoint->SrvCtx->FsCtx, 
			    wpath, msg->in.smb->Uid, &msg->out.smb->Tid);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;

	SRV_ASCII_FREE(wpath);

    } else {
	error = ERROR_PATH_NOT_FOUND;
    }


    // it turns out that we can get away with an older-style reply...hehe
    pResp->AndXCommand = 0xff;
    pResp->AndXReserved = 0;
    pResp->WordCount = 2;

    if (error == ERROR_SUCCESS) {
	pResp->ByteCount = 3;
	strcpy((char*)pResp->Buffer, "A:");

	SrvLog(("FsMount tid %d\n", msg->out.smb->Tid));
    } else {
	pResp->ByteCount = 0;
        SrvLogError(("WIN32ERROR: FsMount error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }

    UPDATE_FOR_NEXT_ANDX(msg, 
                         REQ_TREE_CONNECT_ANDX, pReq,
                         RESP_TREE_CONNECT_ANDX, pResp);

    return SrvDispatch(msg);
}

BOOL
SrvComNoAndx(
    Packet_t * msg
    )
{

    return TRUE;
}

BOOL
SrvComTrans(
    Packet_t * msg
    )
{
    return SrvComUnknown(msg);
}

BOOL
SrvComTrans2(
    Packet_t * msg
    )
{
    PUSHORT pSetup;
    int iSetup;
    Trans2_t t2b;
    SET_TYPE(PREQ_TRANSACTION, pReq);
    SET_TYPE(PRESP_TRANSACTION, pResp);

    if (msg == NULL)
	return FALSE;

    SET_REQ(PREQ_TRANSACTION, pReq, msg);
    SET_RESP(PRESP_TRANSACTION, pResp, msg);

    pSetup = (PUSHORT) NEXT_LOCATION(pReq, REQ_TRANSACTION, 0);
    for (iSetup = 0; iSetup < pReq->SetupCount; iSetup++)
        SrvLog(("Setup[0x%02x]    : 0x%04x (%s)\n",
                     iSetup, pSetup[iSetup],
                     SrvUnparseTrans2(pSetup[iSetup])));

    if (pReq->SetupCount > 1) {
        SrvLog(("SetupCount > 1!!!\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    RtlZeroMemory(pResp, sizeof(RESP_TRANSACTION));
    pResp->WordCount = 10 + pReq->SetupCount;
    pResp->SetupCount = pReq->SetupCount;

    RtlCopyMemory((PUSHORT) NEXT_LOCATION(pResp, RESP_TRANSACTION, 0),
                  pSetup, pResp->SetupCount*sizeof(USHORT));

    t2b.in.pReq = pReq;
    t2b.in.pParameters = ((PUCHAR)msg->in.smb) + pReq->ParameterOffset;
    t2b.in.pData = ((PUCHAR)msg->in.smb) + pReq->DataOffset;
    t2b.out.pResp = pResp;
    t2b.out.ParameterBytesLeft = pReq->MaxParameterCount;
    t2b.out.DataBytesLeft = pReq->MaxDataCount;
    t2b.out.pByteCount = 
        (PUSHORT)NEXT_LOCATION(pResp, RESP_TRANSACTION, 
                               pResp->SetupCount*sizeof(USHORT));
    *(t2b.out.pByteCount) = 0;

    // initialize parameter and data offset. xxx: todo: need pad
    pResp->ParameterOffset = (USHORT) (((PUCHAR)pResp) - (PUCHAR)(msg->out.smb));
    pResp->ParameterOffset += sizeof(*pResp);
    pResp->ParameterOffset += SIZEOF_TRANS2_RESP_HEADER(pResp);
    pResp->DataOffset = pResp->ParameterOffset;

    // we increment:
    // pResp->WordCount
    // pResp->TotalParameterCount
    // pResp->TotalDataCount
    // pResp->ParameterCount
    // pResp->ParameterOffset
    // pResp->ParameterDisplacement -- not really, since we do not honor max
    // pResp->DataCount
    // pResp->DataOffset
    // pResp->DataDisplacement -- not really, since we do not honor max
    // *(t2b.out.pByteCount)

    msg->out.valid += sizeof(RESP_TRANSACTION) + sizeof(USHORT);
    // dispatch each transaction...
    for (iSetup = 0; iSetup < pReq->SetupCount; iSetup++) {
        msg->out.valid += sizeof(USHORT);
        msg->in.command = pSetup[iSetup];

        if (!Trans2Dispatch(msg, &t2b)) {
            // someone bellow us set an error, so we need to stop the loop
            // and return TRUE so the packet gets sent.
            break;
        }
    }

    SrvLog(("Trans2 %d %d %d %d %d %d %d %d %d %d\n", 
		 pResp->WordCount, pResp->SetupCount,
		 pResp->TotalParameterCount,
		 pResp->TotalDataCount,
		 pResp->ParameterCount,
		 pResp->ParameterOffset,
		 pResp->DataCount,
		 pResp->DataOffset,
		 *((PUSHORT) pResp->Buffer),
		 1[((PUSHORT) pResp->Buffer)]));

    // need to set length stuff
    return TRUE;
}

BOOL
SrvComQueryInformation(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    PCHAR file_name;
    fattr_t attribs;
    USHORT sz;
    SET_TYPE(PREQ_QUERY_INFORMATION, pReq);
    SET_TYPE(PRESP_QUERY_INFORMATION, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_QUERY_INFORMATION, pReq, msg);
    SET_RESP(PRESP_QUERY_INFORMATION, pResp, msg);

    pResp->WordCount = 10;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount < 2) {
        SrvLogError(("DOSERROR: ByteCount < 2\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // OK?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_QUERY_INFORMATION, 
                                             sizeof(UCHAR));

    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;
    if (sz == 0)
	file_name = "";
    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name)
	    error = pDisp->FsLookup(fshdl, wfile_name, (USHORT)wsz, &attribs);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;
	SRV_ASCII_FREE(wfile_name);
    }

    if (error) {
        SrvLog(("WIN32ERROR: lookup error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
	UPDATE_OUT_LEN(msg, RESP_QUERY_INFORMATION, pResp);
        return TRUE;
    }

    pResp->FileAttributes = attribs_to_smb_attribs(attribs.attributes);
    pResp->LastWriteTimeInSeconds = time64_to_smb_timedate(&attribs.mod_time);
    RtlZeroMemory(pResp->Reserved, sizeof(pResp->Reserved));
    pResp->FileSize = (ULONG) attribs.file_size;
    UPDATE_OUT_LEN(msg, RESP_QUERY_INFORMATION, pResp);

    return TRUE;
}

BOOL
SrvComSetInformation(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    fattr_t attribs;
    DWORD error;
    PCHAR file_name;
    USHORT sz;
    SET_TYPE(PREQ_SET_INFORMATION, pReq);
    SET_TYPE(PRESP_SET_INFORMATION, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_SET_INFORMATION, pReq, msg);
    SET_RESP(PRESP_SET_INFORMATION, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount < 2) {
        SrvLogError(("DOSERROR: ByteCount < 2\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_SET_INFORMATION, 
                                             sizeof(UCHAR));

    attribs.file_size = INVALID_UINT64;
    attribs.alloc_size = INVALID_UINT64;
    attribs.access_time = INVALID_TIME64;
    attribs.create_time = INVALID_TIME64;
    attribs.mod_time = INVALID_TIME64;

    if (pReq->LastWriteTimeInSeconds)
        attribs.mod_time = smb_timedate_to_time64(pReq->LastWriteTimeInSeconds);
    attribs.attributes = smb_attribs_to_attribs(pReq->FileAttributes);

    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;
    if (sz == 0)
	file_name = "";
    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name)
	    error = pDisp->FsSetAttr2(fshdl, wfile_name, (USHORT)wsz, &attribs);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;
	SRV_ASCII_FREE(wfile_name);
    }

    if (error) {
        SrvLog(("WIN32ERROR: set_attr error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }

    UPDATE_OUT_LEN(msg, RESP_SET_INFORMATION, pResp);

    return TRUE;
}

BOOL
SrvComCheckDirectory(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    fattr_t attribs;
    DWORD error;
    PCHAR file_name;
    USHORT sz;
    SET_TYPE(PREQ_CHECK_DIRECTORY, pReq);
    SET_TYPE(PRESP_CHECK_DIRECTORY, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_CHECK_DIRECTORY, pReq, msg);
    SET_RESP(PRESP_CHECK_DIRECTORY, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount < 2) {
        SrvLogError(("DOSERROR: ByteCount < 2\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_QUERY_INFORMATION, 
                                             sizeof(UCHAR));

    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;
    if (sz == 0)
	file_name = "";
    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name)
	    error = pDisp->FsLookup(fshdl, wfile_name, (USHORT)wsz, &attribs);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;
	SRV_ASCII_FREE(wfile_name);
    }

    if (error) {
        SrvLog(("ERROR: lookup error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    } else if (!(attribs.attributes & ATTR_DIRECTORY)) {
        SrvLog(("ERROR: lookup error 0x%08X\n", error));
        SET_DOSERROR(msg, DOS, BAD_PATH);
    }

    UPDATE_OUT_LEN(msg, RESP_CHECK_DIRECTORY, pResp);
    return TRUE;
}

BOOL
SrvComFindClose2(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    SET_TYPE(PREQ_FIND_CLOSE2, pReq);
    SET_TYPE(PRESP_FIND_CLOSE2, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_FIND_CLOSE2, pReq, msg);
    SET_RESP(PRESP_FIND_CLOSE2, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 1) {
        SrvLogError(("DOSERROR: WordCount != 1\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    error = dm_close(pReq->Sid);
    if (error) {
        SrvLog(("WIN32ERROR: findclose2 error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
        return TRUE;
    }

    UPDATE_OUT_LEN(msg, RESP_FIND_CLOSE2, pResp);
    return TRUE;
}


BOOL
SrvComFindNotifyClose(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    SET_TYPE(PREQ_FIND_NOTIFY_CLOSE, pReq);
    SET_TYPE(PRESP_FIND_NOTIFY_CLOSE, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_FIND_NOTIFY_CLOSE, pReq, msg);
    SET_RESP(PRESP_FIND_NOTIFY_CLOSE, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 1) {
        SrvLogError(("DOSERROR: WordCount != 1 got %d handle %x\n", pReq->WordCount, pReq->Handle));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    error = dm_close(pReq->Handle);
    if (error) {
        SrvLog(("WIN32ERROR: notifyclose error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
        return TRUE;
    }

    UPDATE_OUT_LEN(msg, RESP_FIND_NOTIFY_CLOSE, pResp);
    return TRUE;
}

BOOL
SrvComDelete(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    PCHAR file_name;
    DWORD error;
    USHORT sz;
    SET_TYPE(PREQ_DELETE, pReq);
    SET_TYPE(PRESP_DELETE, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_DELETE, pReq, msg);
    SET_RESP(PRESP_DELETE, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount < 2) {
        SrvLogError(("DOSERROR: ByteCount < 2\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_DELETE,
                                             sizeof(UCHAR));

    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;
    if (sz == 0)
	file_name = "";
    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name)
	    error = pDisp->FsRemove(fshdl, wfile_name, (USHORT)wsz);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;
	SRV_ASCII_FREE(wfile_name);
    }

    if (error) {
        SrvLog(("WIN32EROR: remove error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }
    
    UPDATE_OUT_LEN(msg, RESP_DELETE, pResp);
    return TRUE;
}

BOOL
SrvComRename(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    PCHAR to_name, from_name;
    SET_TYPE(PREQ_RENAME, pReq);
    SET_TYPE(PRESP_RENAME, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_RENAME, pReq, msg);
    SET_RESP(PRESP_RENAME, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount < 4) {
        SrvLogError(("DOSERROR: ByteCount < 4\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    from_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_RENAME,
                                             sizeof(UCHAR));

    to_name = (PCHAR)NEXT_LOCATION(pReq, 
                                           REQ_RENAME,
                                           2*sizeof(UCHAR)+
                                           lstrlen(from_name)+1);

    SrvLog(("Rename: attrib %x\n", pReq->SearchAttributes));

    {
	// convert name to unicode
	int wfsz, wtsz;
	LPWSTR wfrom_name, wto_name;

	SRV_ASCII_TO_WCHAR(wfrom_name, wfsz, from_name, lstrlen(from_name));
	SRV_ASCII_TO_WCHAR(wto_name, wtsz, to_name, lstrlen(to_name));
	if (wfrom_name  && wto_name)
	    error = pDisp->FsRename(fshdl, wfrom_name, (USHORT)wfsz,
				    wto_name, (USHORT) wtsz);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;
	SRV_ASCII_FREE(wfrom_name);
	SRV_ASCII_FREE(wto_name);
    }

    if (error) {
        SrvLog(("WIN32ERROR: rename error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }
    
    UPDATE_OUT_LEN(msg, RESP_RENAME, pResp);
    return TRUE;
}

BOOL
SrvComCreateDirectory(
    Packet_t * msg
    )
{
    DWORD error;
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    SET_TYPE(PREQ_CREATE_DIRECTORY, pReq);
    SET_TYPE(PRESP_CREATE_DIRECTORY, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_CREATE_DIRECTORY, pReq, msg);
    SET_RESP(PRESP_CREATE_DIRECTORY, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount >= 2) {
	USHORT sz;
	PCHAR file_name = (PCHAR)NEXT_LOCATION(pReq, 
						 REQ_CREATE_DIRECTORY,
						 sizeof(UCHAR));

	sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
	if (pReq->ByteCount > sz)
	    sz = pReq->ByteCount - sz;
	else
	    sz = 1;

	{
	    // convert name to unicode
	    int wsz;
	    LPWSTR wfile_name;

	    SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	    if (wfile_name)
		error = pDisp->FsMkdir(fshdl, wfile_name, (USHORT)wsz, 0);
	    else
		error = ERROR_NOT_ENOUGH_MEMORY;
	    SRV_ASCII_FREE(wfile_name);
	}
    } else {
	error = ERROR_BAD_NETPATH;
    }

    if (error) {
	SrvLog(("WIN32ERROR: mkdir error 0x%08X\n", error));
	SET_WIN32ERROR(msg, error);
    }

    UPDATE_OUT_LEN(msg, RESP_CREATE_DIRECTORY, pResp);
    return TRUE;
}

BOOL
SrvComDeleteDirectory(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    PCHAR file_name;
    USHORT sz;
    SET_TYPE(PREQ_DELETE_DIRECTORY, pReq);
    SET_TYPE(PRESP_DELETE_DIRECTORY, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_DELETE_DIRECTORY, pReq, msg);
    SET_RESP(PRESP_DELETE_DIRECTORY, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->ByteCount < 2) {
        SrvLogError(("DOSERROR: ByteCount < 2\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_DELETE_DIRECTORY,
                                             sizeof(UCHAR));

    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;

    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name)
	    error = pDisp->FsRmdir(fshdl, wfile_name, (USHORT)wsz);
	else
	    error = ERROR_NOT_ENOUGH_MEMORY;
	SRV_ASCII_FREE(wfile_name);
    }

    if (error) {
        SrvLog(("WIN32ERROR: rmdir error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }
    
    UPDATE_OUT_LEN(msg, RESP_DELETE_DIRECTORY, pResp);
    return TRUE;
}

BOOL
SrvComOpenAndx(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    PCHAR file_name;
    BOOL additional_info;
    UINT32 flags;
    fattr_t attr;
    DWORD error;
    USHORT sz;
    UINT32 action;
    SET_TYPE(PREQ_OPEN_ANDX, pReq);
    SET_TYPE(PRESP_OPEN_ANDX, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_OPEN_ANDX, pReq, msg);
    SET_RESP(PRESP_OPEN_ANDX, pResp, msg);

    pResp->WordCount = 15;
    pResp->AndXCommand = 0xff;
    pResp->AndXReserved = 0;
    pResp->FileType = 0;
    pResp->DeviceState = 0;
    // XXX - for actual Action value, need to do a lookup beforehand...
    pResp->Action = 0;
    // XXX - is ServerFid = 0 really ok?  It seems like it never gets used...
    pResp->ServerFid = 0;
    pResp->Reserved = 0;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 15) {
        SrvLogError(("DOSERROR: WordCount != 15\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
                                             REQ_OPEN_ANDX,
                                             sizeof(UCHAR));

    SrvLog(("OpenX: Flags %x Access %x Srch %x Attr %x Open %x Size %x\n",
		 pReq->Flags, pReq->DesiredAccess, pReq->SearchAttributes,
		 pReq->FileAttributes, pReq->OpenFunction, pReq->AllocationSize));

    additional_info = (pReq->Flags & SMB_OPEN_QUERY_INFORMATION);

    flags = smb_access_to_flags(pReq->DesiredAccess) | smb_openfunc_to_flags(pReq->OpenFunction);

    if (!(flags & FS_DISP_MASK)) {
        // XXX --- error!!!
        SrvLog(("DOSERROR: nothing to do!!!!\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok
        return TRUE;
    }

    attr.file_size = INVALID_UINT64;
    attr.alloc_size = INVALID_UINT64;
    attr.create_time = smb_timedate_to_time64(pReq->CreationTimeInSeconds);
    attr.access_time = INVALID_TIME64;
    attr.mod_time = INVALID_TIME64;
    attr.attributes = smb_attribs_to_attribs(pReq->FileAttributes);


    if (*file_name == '\\') {
	file_name++;
    }


    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;
    if (sz == 0)
	file_name = "";
    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name) {
	    fhandle_t fid;
	    error = pDisp->FsCreate(fshdl,
				    wfile_name, (USHORT)wsz,
				    flags,
				    &attr,
				    &fid,
				    &action);
	    pResp->Fid = fid;
	} else {
	    error = ERROR_NOT_ENOUGH_MEMORY;
	}
	SRV_ASCII_FREE(wfile_name);
    }


    if (error) {
        SrvLog(("WIN32ERROR: create error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
	UPDATE_OUT_LEN(msg, RESP_OPEN_ANDX, pResp);
        return TRUE;
    }

    if (additional_info) {
        error = pDisp->FsGetAttr(fshdl, pResp->Fid, &attr);
        if (error) {
            SrvLog(("WIN32ERROR: get_attr error 0x%08X\n", error));
            SET_WIN32ERROR(msg, error);
            return TRUE;
        }
        pResp->FileAttributes = attribs_to_smb_attribs(attr.attributes);
        pResp->LastWriteTimeInSeconds = time64_to_smb_timedate(&attr.mod_time);
        pResp->DataSize = (ULONG) attr.file_size;
    } else {
        pResp->FileAttributes = 0;
        pResp->LastWriteTimeInSeconds = 0;
        pResp->DataSize = 0;
    }

    pResp->WordCount = 15;
    pResp->GrantedAccess = pReq->DesiredAccess & SMB_DA_FCB_MASK;
    if (!(action & ACCESS_WRITE)) {

	if ((pResp->GrantedAccess & SMB_DA_ACCESS_MASK) == SMB_DA_ACCESS_WRITE) {
	    pResp->GrantedAccess &= ~SMB_DA_ACCESS_WRITE;
	} 
	if ((pResp->GrantedAccess & SMB_DA_ACCESS_MASK) == SMB_DA_ACCESS_READ_WRITE) {
	    pResp->GrantedAccess &= ~SMB_DA_ACCESS_READ_WRITE;
	} 
    }
    pResp->Action = action & ~FS_ACCESS_MASK;

    SrvLog(("GrantAccess 0x%x DesiredAccess %x addition %d sz %d\n", pResp->GrantedAccess,
		 pReq->DesiredAccess, additional_info, pResp->DataSize));


    UPDATE_FOR_NEXT_ANDX(msg, 
                         REQ_OPEN_ANDX, pReq,
                         RESP_OPEN_ANDX, pResp);

    return SrvDispatch(msg);
}

BOOL
SrvComOpen(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;

    UINT32 flags;
    fattr_t attr;
    DWORD error;
    UINT32 action;
    USHORT sz;
    PCHAR file_name;
    SET_TYPE(PREQ_OPEN, pReq);
    SET_TYPE(PRESP_OPEN, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_OPEN, pReq, msg);
    SET_RESP(PRESP_OPEN, pResp, msg);

    pResp->WordCount = 7;
    // XXX - is ServerFid = 0 really ok?  It seems like it never gets used...
    pResp->Fid = 0xffff;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 2) {
        SrvLogError(("DOSERROR: WordCount != 2\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    file_name = (PCHAR)NEXT_LOCATION(pReq, 
				      REQ_OPEN,
				      sizeof(UCHAR));

    flags = DISP_OPEN_EXISTING | smb_access_to_flags(pReq->DesiredAccess);

    if (*file_name == '\\') {
	file_name++;
    }

    sz = (USHORT) (((char *)file_name) - ((char *)&pReq->Buffer[0]));
    if (pReq->ByteCount > sz)
	sz = pReq->ByteCount - sz;
    else
	sz = 1;
    if (sz == 0)
	file_name = "";
    {
	// convert name to unicode
	int wsz;
	LPWSTR wfile_name;

	SRV_ASCII_TO_WCHAR(wfile_name, wsz, file_name, sz);
	if (wfile_name) {
	    fhandle_t fid;
	    error = pDisp->FsCreate(fshdl,
				    wfile_name, (USHORT)wsz,
				    flags,
				    NULL,
				    &fid, 	
				    &action);
	    pResp->Fid = fid;
	} else {
	    error = ERROR_NOT_ENOUGH_MEMORY;
	}
	SRV_ASCII_FREE(wfile_name);
    }

    if (error) {
        SrvLog(("WIN32ERROR: create error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
	UPDATE_OUT_LEN(msg, RESP_OPEN, pResp);
        return TRUE;
    }

    error = pDisp->FsGetAttr(fshdl, pResp->Fid, &attr);
    if (error) {
	SrvLog(("WIN32ERROR: get_attr error 0x%08X\n", error));
	SET_WIN32ERROR(msg, error);
	UPDATE_OUT_LEN(msg, RESP_OPEN, pResp);
	return TRUE;
    }

    pResp->FileAttributes = attribs_to_smb_attribs(attr.attributes);
    pResp->LastWriteTimeInSeconds = time64_to_smb_timedate(&attr.mod_time);
    pResp->DataSize = (ULONG)attr.file_size;

    pResp->GrantedAccess = pReq->DesiredAccess & SMB_DA_FCB_MASK;
    if (!(action & ACCESS_WRITE)) {

	if ((pResp->GrantedAccess & SMB_DA_ACCESS_MASK) == SMB_DA_ACCESS_WRITE) {
	    pResp->GrantedAccess &= ~SMB_DA_ACCESS_WRITE;
	} 
	if ((pResp->GrantedAccess & SMB_DA_ACCESS_MASK) == SMB_DA_ACCESS_READ_WRITE) {
	    pResp->GrantedAccess &= ~SMB_DA_ACCESS_READ_WRITE;
	} 
    }

    SrvLog(("GrantAccess 0x%x DesiredAccess %x sz %d\n", pResp->GrantedAccess,
		 pReq->DesiredAccess, pResp->DataSize));


    UPDATE_OUT_LEN(msg, RESP_OPEN, pResp);
    return TRUE;
}

BOOL
SrvComWrite(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    ULONG offset;
    DWORD error;
    USHORT count, actual_count;
    void *data;
    SET_TYPE(PREQ_WRITE, pReq);
    SET_TYPE(PRESP_WRITE, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_WRITE, pReq, msg);
    SET_RESP(PRESP_WRITE, pResp, msg);

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 5) {
        SrvLogError(("DOSERROR: WordCount != 5\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }


    count = pReq->Count;
    offset = pReq->Offset;

    // NOTE -- it turns out that the BufferFormat and DataLength fields
    // do not exist!

    data = (void*)NEXT_LOCATION(pReq,
                                      REQ_WRITE,
                                      0);

    actual_count = count;
    error = pDisp->FsWrite(fshdl, pReq->Fid, offset, &actual_count, data, NULL);
    if (error) {
        SrvLog(("WIN32ERROR: write error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }

    pResp->WordCount = 1;
    pResp->Count = actual_count;
    pResp->ByteCount = 0;

    UPDATE_OUT_LEN(msg, RESP_WRITE, pResp);
    return TRUE;
}

BOOL
SrvComClose(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    SET_TYPE(PREQ_CLOSE, pReq);
    SET_TYPE(PRESP_CLOSE, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_CLOSE, pReq, msg);
    SET_RESP(PRESP_CLOSE, pResp, msg);

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }


    error = pDisp->FsClose(fshdl, pReq->Fid);
    if (error) {
        SrvLog(("WIN32ERROR: close error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    UPDATE_OUT_LEN(msg, RESP_CLOSE, pResp);
    return TRUE;
}

void
WINAPI
SrvReadContinue(PVOID p, UINT32 status, UINT32 length)
{
    Packet_t *msg = (Packet_t *) p;
    SET_TYPE(PREQ_READ_ANDX, pReq);
    SET_TYPE(PRESP_READ_ANDX, pResp);
    DWORD consumed;

    if (msg == NULL)
	return;

    SET_REQ(PREQ_READ_ANDX, pReq, msg);
    SET_RESP(PRESP_READ_ANDX, pResp, msg);

    consumed = (DWORD)(pResp->Buffer - (PUCHAR)msg->out.smb);

    if (status == ERROR_SUCCESS) {

	pResp->WordCount = 12;
	pResp->Remaining = 0;
	pResp->DataCompactionMode = 0;
	pResp->Reserved = 0;

	pResp->Reserved2 = 0;
	RtlZeroMemory(pResp->Reserved3, sizeof(pResp->Reserved3));

	pResp->DataLength = (USHORT) length;
	pResp->DataOffset = (USHORT) consumed;
	pResp->ByteCount = (USHORT) length;

	UPDATE_FOR_NEXT_ANDX(msg, 
			     REQ_READ_ANDX, pReq,
			     RESP_READ_ANDX, pResp);

	if (msg->in.command != 0xFF)
	    SrvDispatch(msg);
    } else {
	SrvLog(("WIN32ERROR: read error 0x%08X\n", status));
	SET_WIN32ERROR(msg, status);
	pResp->ByteCount = 0;
	UPDATE_OUT_LEN(msg, RESP_READ_ANDX, pResp);
    }

    SrvFinalize(msg);
}


BOOL
SrvComReadAndx(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD consumed;
    DWORD remaining;
    USHORT MinCount;
    USHORT MaxCount;
    USHORT actual_count;
    ULONG offset;
    DWORD error;
    SET_TYPE(PREQ_READ_ANDX, pReq);
    SET_TYPE(PRESP_READ_ANDX, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_READ_ANDX, pReq, msg);
    SET_RESP(PRESP_READ_ANDX, pResp, msg);

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 10) {
        SrvLogError(("DOSERROR: WordCount != 10\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok
        return TRUE;
    }

    consumed = (DWORD)(pResp->Buffer - (PUCHAR)msg->out.smb);
    remaining = msg->out.size - consumed;
    MinCount = pReq->MinCount;
    MaxCount = pReq->MaxCount;
    offset = pReq->Offset;

    SrvLog(("Fid %d MaxCount = %d, MinCount = %d\n", pReq->Fid, MaxCount, MinCount));

    if (MaxCount > remaining) {
        SrvLog(("DOSERROR: MaxCount (%d) > remaining (%d)\n", MaxCount, remaining));
        SET_DOSERROR(msg, SERVER, ERROR); // XXX -- ok?
        return TRUE;
    }

    actual_count = MaxCount;

    msg->tag = ERROR_IO_PENDING;
    msg->completion = SrvReadContinue;
    error = pDisp->FsRead(fshdl, pReq->Fid, offset, &actual_count, pResp->Buffer, (PVOID)msg);
    if (error) {
	if (error == ERROR_IO_PENDING) {
	    return ERROR_IO_PENDING;
	}
	SrvLog(("WIN32ERROR: read error 0x%08X\n", error));
	SET_WIN32ERROR(msg, error);
	pResp->ByteCount = 0;
	UPDATE_OUT_LEN(msg, RESP_READ_ANDX, pResp);
	return TRUE;
    }

    msg->tag = 0;

    pResp->WordCount = 12;
    pResp->Remaining = 0;
    pResp->DataCompactionMode = 0;
    pResp->Reserved = 0;

    pResp->Reserved2 = 0;
    RtlZeroMemory(pResp->Reserved3, sizeof(pResp->Reserved3));

    pResp->DataLength = actual_count;
    pResp->DataOffset = (USHORT) consumed;
    pResp->ByteCount = actual_count;

    UPDATE_FOR_NEXT_ANDX(msg, 
                         REQ_READ_ANDX, pReq,
                         RESP_READ_ANDX, pResp);

    return SrvDispatch(msg);
}

BOOL
SrvComQueryInformation2(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    fattr_t attribs;
    DWORD error;
    SET_TYPE(PREQ_QUERY_INFORMATION2, pReq);
    SET_TYPE(PRESP_QUERY_INFORMATION2, pResp);


    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_QUERY_INFORMATION2, pReq, msg);
    SET_RESP(PRESP_QUERY_INFORMATION2, pResp, msg);

    pResp->WordCount = 11;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 1) {
        SrvLogError(("DOSERROR: WordCount != 1\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }


    error = pDisp->FsGetAttr(fshdl, pReq->Fid, &attribs);
    if (error) {
        SrvLog(("WIN32ERROR: get_attr error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
	UPDATE_OUT_LEN(msg, RESP_QUERY_INFORMATION2, pResp);
        return TRUE;
    }

    RtlZeroMemory(&pResp->CreationDate, sizeof(USHORT) * 6);
    time64_to_smb_datetime(&attribs.create_time,
                           &pResp->CreationDate.Ushort,
                           &pResp->CreationTime.Ushort);
    time64_to_smb_datetime(&attribs.access_time,
                           &pResp->LastAccessDate.Ushort,
                           &pResp->LastAccessTime.Ushort);
    time64_to_smb_datetime(&attribs.mod_time,
                           &pResp->LastWriteDate.Ushort,
                           &pResp->LastWriteTime.Ushort);
    pResp->FileDataSize = (ULONG) attribs.file_size;
    pResp->FileAllocationSize = (ULONG)attribs.alloc_size;
    pResp->FileAttributes = attribs_to_smb_attribs(attribs.attributes);
    UPDATE_OUT_LEN(msg, RESP_QUERY_INFORMATION2, pResp);

    return TRUE;
}

BOOL
SrvComSetInformation2(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    fattr_t attribs;
    DWORD error;
    SET_TYPE(PREQ_SET_INFORMATION2, pReq);
    SET_TYPE(PRESP_SET_INFORMATION2, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_SET_INFORMATION2, pReq, msg);
    SET_RESP(PRESP_SET_INFORMATION2, pResp, msg);

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 7) {
        SrvLogError(("DOSERROR: WordCount != 7\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    attribs.file_size = INVALID_UINT64;
    attribs.alloc_size = INVALID_UINT64;
    attribs.access_time = INVALID_TIME64;
    attribs.create_time = INVALID_TIME64;
    attribs.mod_time = INVALID_TIME64;
    attribs.attributes = INVALID_UINT32;

    if (pReq->CreationDate.Ushort || pReq->CreationTime.Ushort) {
        smb_datetime_to_time64(pReq->CreationDate.Ushort,
                               pReq->CreationTime.Ushort,
                               &attribs.create_time);
    }
    if (pReq->LastAccessDate.Ushort || pReq->LastAccessTime.Ushort) {
        smb_datetime_to_time64(pReq->LastAccessDate.Ushort,
                               pReq->LastAccessTime.Ushort,
                               &attribs.access_time);
    }
    if (pReq->LastWriteDate.Ushort || pReq->LastWriteTime.Ushort) {
        smb_datetime_to_time64(pReq->LastWriteDate.Ushort,
                               pReq->LastWriteTime.Ushort,
                               &attribs.mod_time);
    }

    error = pDisp->FsSetAttr(fshdl, pReq->Fid, &attribs);
    if (error) {
        SrvLog(("WIN32ERROR: set_attr error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }

    pResp->WordCount = 0;
    pResp->ByteCount = 0;
    UPDATE_OUT_LEN(msg, RESP_SET_INFORMATION2, pResp);

    return TRUE;
}

void
WINAPI
SrvLockContinue(PVOID p, UINT32 status, UINT32 length)
{
    Packet_t *msg = (Packet_t *) p;
    SET_TYPE(PREQ_LOCKING_ANDX, pReq);
    SET_TYPE(PRESP_LOCKING_ANDX, pResp);
    DWORD consumed;

    if (msg == NULL)
	return;

    SET_REQ(PREQ_LOCKING_ANDX, pReq, msg);
    SET_RESP(PRESP_LOCKING_ANDX, pResp, msg);

    consumed = (DWORD)(pResp->Buffer - (PUCHAR)msg->out.smb);

    pResp->WordCount = 2;
    pResp->ByteCount = 0;

    UPDATE_FOR_NEXT_ANDX(msg, 
			 REQ_LOCKING_ANDX, pReq,
			 RESP_LOCKING_ANDX, pResp);

    if (status == ERROR_SUCCESS) {
	if (msg->in.command != 0xFF)
	    SrvDispatch(msg);
    } else {
	SrvLog(("WIN32ERROR: read error 0x%08X\n", status));
	SET_WIN32ERROR(msg, status);
    }

    SrvFinalize(msg);
}

BOOL
SrvComLockingAndx(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    int i;
    ULONG flags;
    int offset;
    PLOCKING_ANDX_RANGE pUnlocks, pLocks;
    BOOL bShared;
    USHORT nulocks, nlocks;
    DWORD error;
    SET_TYPE(PREQ_LOCKING_ANDX, pReq);
    SET_TYPE(PRESP_LOCKING_ANDX, pResp);
 
    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_LOCKING_ANDX, pReq, msg);
    SET_RESP(PRESP_LOCKING_ANDX, pResp, msg);


    if (pReq->WordCount != 8) {
        SrvLogError(("DOSERROR: WordCount != 8\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }


    bShared  = pReq->LockType; // & LOCKING_ANDX_SHARED_LOCK;
    nulocks= pReq->NumberOfUnlocks;
    nlocks = pReq->NumberOfLocks;

    pLocks = NULL;
    pUnlocks = NULL;

    offset = 0;
    if (pReq->ByteCount > offset) {
	pUnlocks = (PLOCKING_ANDX_RANGE)
                NEXT_LOCATION(pReq, REQ_LOCKING_ANDX, offset);
	offset += (pReq->NumberOfUnlocks * sizeof(LOCKING_ANDX_RANGE));
    }
    if (pReq->ByteCount > offset) {
	pLocks = (PLOCKING_ANDX_RANGE)
                NEXT_LOCATION(pReq, REQ_LOCKING_ANDX, offset);
    }

    flags = 0;
    if (pReq->Timeout != 0) {
	flags |= 0x1;	// wait
    }
    if (pReq->LockType & LOCKING_ANDX_SHARED_LOCK) {
	flags |= 0x2;	// shared
    }

    SET_WIN32ERROR(msg, ERROR_INVALID_PARAMETER);

    if (pLocks != NULL) {
	for (i = 0; i < nlocks; i++) {
	    SrvLog(("Lock: %d pid %d offset %d len %d flags %x (%x,%d)\n", i,
		    pLocks[i].Pid, pLocks[i].Offset, pLocks[i].Length, flags,
		    pReq->LockType, pReq->Timeout));

	    msg->tag = ERROR_IO_PENDING;
	    msg->completion = SrvLockContinue;
	    error = pDisp->FsLock(fshdl, pReq->Fid,
				  pLocks[i].Offset, pLocks[i].Length,
				  flags,
				  (PVOID) msg);
	    if (error == ERROR_IO_PENDING) {
		return ERROR_IO_PENDING;
	    }
	    SET_WIN32ERROR(msg, error);
	}
    }

    if (pUnlocks != NULL) {
	for (i = 0; i < nulocks; i++) {
	    SrvLog(("Unlock: %d pid %d offset %d len %d\n", i,
		    pUnlocks[i].Pid, pUnlocks[i].Offset, pUnlocks[i].Length));

	    error = pDisp->FsUnlock(fshdl, pReq->Fid,
				    pUnlocks[i].Offset, pUnlocks[i].Length);
	    SET_WIN32ERROR(msg, error);
	}
    }

    pResp->WordCount = 2;
    pResp->ByteCount = 0;

    UPDATE_FOR_NEXT_ANDX(msg, 
                         REQ_LOCKING_ANDX, pReq,
                         RESP_LOCKING_ANDX, pResp);

    return SrvDispatch(msg);
}

BOOL
SrvComSeek(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    ULONG offset;
    fattr_t attribs;
    DWORD error;
    BOOL bStart;
    USHORT mode;
    SET_TYPE(PREQ_SEEK, pReq);
    SET_TYPE(PRESP_SEEK, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_SEEK, pReq, msg);
    SET_RESP(PRESP_SEEK, pResp, msg);

    pResp->WordCount = 2;
    pResp->ByteCount = 0;

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    if (pReq->WordCount != 4) {
        SrvLogError(("DOSERROR: WordCount != 4\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    mode = pReq->Mode;
    if (mode && (mode != 2)) {
        SrvLog(("DOSERROR: only support modes 0 & 2 (not %d)\n", mode));
        SET_DOSERROR(msg, SERVER, ERROR);
        return TRUE;
    }
    bStart = !mode;
    offset = pReq->Offset;
    error = pDisp->FsGetAttr(fshdl, pReq->Fid, &attribs);
    if (error) {
        SrvLog(("WIN32ERROR: get_attr error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
        return TRUE;
    }


    pResp->Offset = 0;

    UPDATE_OUT_LEN(msg, RESP_SEEK, pResp);
    return TRUE;
}

BOOL
SrvComFlush(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    SET_TYPE(PREQ_FLUSH, pReq);
    SET_TYPE(PRESP_FLUSH, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(PREQ_FLUSH, pReq, msg);
    SET_RESP(PRESP_FLUSH, pResp, msg);

    if (pReq->WordCount != 1) {
        SrvLogError(("DOSERROR: WordCount != 1\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    if (pReq->ByteCount != 0) {
        SrvLogError(("DOSERROR: ByteCount != 0\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    if (!pDisp) {
        SrvLogError(("DOSERROR: could not find dispatch table for uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return TRUE;
    }

    error = pDisp->FsFlush(fshdl, pReq->Fid);
    if (error) {
        SrvLog(("WIN32ERROR: flush error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
    }

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    UPDATE_OUT_LEN(msg, RESP_FLUSH, pResp);
    return TRUE;
}

BOOL
SrvComLogoffAndx(
    Packet_t * msg
    )
{
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    SET_TYPE(PREQ_LOGOFF_ANDX, pReq);
    SET_TYPE(PRESP_LOGOFF_ANDX, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);

    SET_REQ(PREQ_LOGOFF_ANDX, pReq, msg);
    SET_RESP(PRESP_LOGOFF_ANDX, pResp, msg);

    memcpy(pResp, pReq, sizeof(PRESP_LOGOFF_ANDX));

    FsDisMount(fsctx, uid, tid);

    UPDATE_OUT_LEN(msg, RESP_LOGOFF_ANDX, pResp);

    return TRUE;
}

BOOL
SrvComTreeDisconnect(
    Packet_t * msg
    )
{
    USHORT uid;
    USHORT tid;
    PVOID fsctx;
    SET_TYPE(PREQ_TREE_DISCONNECT, pReq);
    SET_TYPE(PRESP_TREE_DISCONNECT, pResp);

    if (msg == NULL)
	return FALSE;

    uid = msg->in.smb->Uid;
    tid = msg->in.smb->Tid;
    fsctx = SRV_GET_FS_HANDLE(msg);

    SET_REQ(PREQ_TREE_DISCONNECT, pReq, msg);
    SET_RESP(PRESP_TREE_DISCONNECT, pResp, msg);

    pResp->WordCount = 0;
    pResp->ByteCount = 0;

    FsDisMount(fsctx, uid, tid);

    UPDATE_OUT_LEN(msg, RESP_TREE_DISCONNECT, pResp);

    return TRUE;
}

BOOL
SrvComSearch(
    Packet_t * msg
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    SET_TYPE(PREQ_SEARCH, pReq);
    SET_TYPE(PRESP_SEARCH, pResp);

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;

    SET_REQ(PREQ_SEARCH, pReq, msg);
    SET_RESP(PRESP_SEARCH, pResp, msg);

    // this call is not supported in our dialect, so no worries.

    UPDATE_OUT_LEN(msg, RESP_SEARCH, pResp);

    return TRUE;
}


BOOL
SrvComIoctl(
    Packet_t * msg
    )
{

    SET_TYPE(PREQ_IOCTL, pReq);
    SET_TYPE(PRESP_IOCTL, pResp);

    if (msg == NULL)
	return FALSE;

    SET_REQ(PREQ_IOCTL, pReq, msg);
    SET_RESP(PRESP_IOCTL, pResp, msg);

    if (pReq->WordCount != 14) {
        SrvLogError(("DOSERROR: WordCount != 1\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    SrvLog(("Ioctl: fid %d category %d function %d tpc %d tdc %d mpc %d mdc %d pc %d po %d dc %d do %d bc %d\n",
		 pReq->Fid,
		 pReq->Category,
		 pReq->Function,
		 pReq->TotalParameterCount,
		 pReq->TotalDataCount,
		 pReq->MaxParameterCount,
		 pReq->MaxDataCount,
		 pReq->ParameterCount,
		 pReq->DataCount,
		 pReq->DataOffset,
		 pReq->ByteCount));

    memset((char *)pResp, 0, sizeof(*pResp));

    pResp->WordCount = 8;

    UPDATE_OUT_LEN(msg, RESP_IOCTL, pResp);

    return TRUE;
}

BOOL
SrvComEcho(
    Packet_t * msg
    )
{
    SET_TYPE(PREQ_ECHO, pReq);
    SET_TYPE(PRESP_ECHO, pResp);

    if (msg == NULL)
	return FALSE;

    SET_REQ(PREQ_ECHO, pReq, msg);
    SET_RESP(PRESP_ECHO, pResp, msg);

    if (pReq->WordCount != 1) {
        SrvLogError(("DOSERROR: WordCount != 1\n"));
        SET_DOSERROR(msg, SERVER, ERROR); // ok?
        return TRUE;
    }

    SrvLog(("Echo: count %d bytecount %d\n", pReq->EchoCount, pReq->ByteCount));

    pResp->WordCount = 1;
    pResp->SequenceNumber = 1;
    pResp->ByteCount = pReq->ByteCount;
    memcpy(pResp->Buffer, pReq->Buffer, pReq->ByteCount);

    UPDATE_OUT_LEN(msg, RESP_ECHO, pResp);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\srvtrans.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srvtrans.c

Abstract:

    Implements transaction smb packets

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#include "srv.h"

typedef struct {
    HANDLE	handle;
    WIN32_FIND_DATA *last;
    ULONG	cookie;
    USHORT	Sid;
    USHORT info_level;
    USHORT base_size;
    USHORT add_res_key;
}dm_t;

static CRITICAL_SECTION dLock;
#define DirTableSz 1024
static dm_t *DirTable[DirTableSz];

#define SET_REQ(x, type, p) { \
  x = (type) (p)->in.pParameters; \
 (p)->in.pParameters +=  sizeof(*x); \
}


// XXX: need to handle padding

void*
ADD_RESP_PARAMS(
    Packet_t * msg, 
    Trans2_t * trans2, 
    PVOID resp, 
    USHORT size
    )
{
    PUCHAR p;

    if (trans2->out.ParameterBytesLeft < size) return 0;
    if (trans2->out.pResp->DataCount) {
        PUCHAR d = (PUCHAR)msg->out.smb;
	d += trans2->out.pResp->DataOffset;
        // need to use MoveMemory due to possible overlap
        RtlMoveMemory((PVOID)(d + size), 
                      (PVOID)d, trans2->out.pResp->DataCount);
        // we up the data offset below
    }
    p = (PUCHAR)msg->out.smb;
    p += trans2->out.pResp->ParameterOffset +
         trans2->out.pResp->ParameterCount;
    if (resp) RtlCopyMemory((PVOID)p, (PVOID)resp, (ULONG)size);
    trans2->out.pResp->ParameterCount += size;
    trans2->out.pResp->TotalParameterCount += size;
    *(trans2->out.pByteCount) += size;
    trans2->out.pResp->DataOffset += size;
    msg->out.valid += size;
    trans2->out.ParameterBytesLeft -= size;
    return p;
}

void*
ADD_RESP_DATA(
    Packet_t * msg, 
    Trans2_t * trans2, 
    PVOID resp, 
    USHORT size
    )
{
    PUCHAR d;

    if (trans2->out.DataBytesLeft < size) {
	return 0;
    }

    d = (PUCHAR)msg->out.smb;
    d += (trans2->out.pResp->DataOffset +
         trans2->out.pResp->DataCount);

    if (resp != NULL) {
	RtlCopyMemory((PVOID)d, (PVOID)resp, (ULONG)size);
    }

    trans2->out.pResp->DataCount += size;
    trans2->out.pResp->TotalDataCount += size;
    *(trans2->out.pByteCount) += size;

    msg->out.valid += size;
    trans2->out.DataBytesLeft -= size;

    return d;
}

////

BOOL
Trans2Unknown(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    SrvLogError(("DOSERROR: (------ CANNOT HANDLE THIS TRANS2 FUNCTION ------)\n"));
    SET_DOSERROR(msg, SERVER, NO_SUPPORT);
    return FALSE;
}

BOOL
Trans2QueryFsInfo(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    PVOID fshdl;
    USHORT tid = msg->in.smb->Tid;
    USHORT uid = msg->in.smb->Uid;
    PVOID fsctx = SRV_GET_FS_HANDLE(msg);
    FsDispatchTable* pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);
    fs_attr_t fsattr;
    DWORD error;

    PREQ_QUERY_FS_INFORMATION pReq;
    SET_REQ(pReq, PREQ_QUERY_FS_INFORMATION, trans2);

    if (!pDisp) {
        SrvLogError(("DOSERROR: no such uid\n"));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return FALSE;
    }

    error = pDisp->FsStatfs(fshdl, &fsattr);
    if (error) {
        SrvLogError(("WIN32ERROR: statfs error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
        return FALSE;
    }

    SrvLog(("statfs %s level %d %d\n",
		 fsattr.fs_name,
		 pReq->InformationLevel,
		 trans2->out.pResp->WordCount));
    trans2->out.pResp->WordCount--;
    switch (pReq->InformationLevel) {
    case SMB_INFO_ALLOCATION: {
        FSALLOCATE Resp;
        Resp.idFileSystem = 0;
        Resp.cSectorUnit = fsattr.sectors_per_unit; 
        Resp.cbSector = (USHORT)fsattr.bytes_per_sector;
        Resp.cUnit = (ULONG)fsattr.total_units;
        Resp.cUnitAvail = (ULONG)fsattr.free_units;
        SrvLog(("statfs %u %u\n", Resp.cUnit, Resp.cUnitAvail));
        ADD_RESP_DATA(msg, trans2, &Resp, sizeof(FSALLOCATE));
        return TRUE;
    }
    case SMB_INFO_VOLUME: {
        FSINFO Resp;
        const int maxlen = sizeof(Resp.vol.szVolLabel);
        Resp.ulVsn = 0xFADB;
        Resp.vol.cch = min(lstrlen(fsattr.fs_name), maxlen);
        lstrcpyn(Resp.vol.szVolLabel, fsattr.fs_name, maxlen);
        SrvLog(("statfs name %s %d %d, %d\n",
		     fsattr.fs_name, Resp.vol.cch,
		     sizeof(FSINFO), sizeof(*msg->out.smb)));
        ADD_RESP_DATA(msg, trans2, &Resp, sizeof(FSINFO));
        return TRUE;
    }
    case SMB_QUERY_FS_VOLUME_INFO: {
        const int name_len = lstrlen(fsattr.fs_name);
        const USHORT size = sizeof(FILE_FS_VOLUME_INFORMATION) + name_len + 2;
        PFILE_FS_VOLUME_INFORMATION pResp = 
            (PFILE_FS_VOLUME_INFORMATION)xmalloc(size);
        pResp->VolumeCreationTime.QuadPart = 0;
        pResp->VolumeSerialNumber = 0xFEED;
        pResp->VolumeLabelLength = name_len * sizeof(WCHAR);
//        sprintf((char*)pResp->VolumeLabel, "%S", fsattr.fs_name);
	strcpy((char *)pResp->VolumeLabel, fsattr.fs_name);
        ADD_RESP_DATA(msg, trans2, pResp, size);
        xfree(pResp);
        return TRUE;
    }
    default:
        SrvLogError(("DOSERROR: <COULD NOT UNDERSTAND INFO LEVEL>\n"));
        SET_DOSERROR(msg, SERVER, NO_SUPPORT);
        return FALSE;
    }
}

void
Trans2Init()
{
    int i;

    InitializeCriticalSection(&dLock);
    memset(DirTable, 0, sizeof(DirTable));
}

dm_t *
dm_alloc()
{
    int i;
    dm_t *dm;

    dm = (dm_t *) malloc(sizeof(*dm));
    if (dm == NULL)
	return NULL;

    dm->handle = INVALID_HANDLE_VALUE;
    dm->last = NULL;
    
    EnterCriticalSection(&dLock);
    for (i = 0; i < DirTableSz; i++) {
	if (DirTable[i] == NULL) {
	    dm->Sid = (USHORT) i;
	    DirTable[i] = dm;
	    break;
	}
    }
    LeaveCriticalSection(&dLock);
	
    if (i == DirTableSz) {
	free((char *) dm);
	dm = NULL;
    }
    return dm;
}

void
dm_init(dm_t *p, USHORT _info_level,  USHORT _add_res_key)
{

    p->info_level = _info_level;
    p->add_res_key = _add_res_key;
    p->base_size = p->add_res_key ? sizeof(ULONG):0;

    switch (p->info_level) {
        case SMB_INFO_STANDARD:
            p->base_size += sizeof(SMB_FIND_BUFFER);
            break;
        case SMB_INFO_QUERY_EA_SIZE:
            p->base_size += sizeof(SMB_FIND_BUFFER2);
            break;
        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_FIND_FILE_DIRECTORY_INFO:
        case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
        case SMB_FIND_FILE_NAMES_INFO:
        case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
        default:
            p->base_size = 0;
    }
}

void
dm_free(dm_t *dm)
{

    EnterCriticalSection(&dLock);

    ASSERT(DirTable[dm->Sid] == dm);

    DirTable[dm->Sid] = NULL;
    LeaveCriticalSection(&dLock);

    if (dm->last) {
	free((char *) dm->last);
    }
    if (dm->handle != INVALID_HANDLE_VALUE) {
//	printf("Closing srch hdl %x\n", dm->handle);
	FindClose(dm->handle);
    }

    free((char *)dm);
}

dm_t *
dm_find(USHORT Sid)
{
    dm_t *dm;
    
    if (Sid >= DirTableSz) {
	return NULL;
    }

    // no need to get lock
    dm = DirTable[Sid];

    ASSERT(dm != NULL);
    ASSERT(dm->Sid == Sid);

    return dm;
}

DWORD
dm_close(USHORT Sid)
{
    dm_t *dm;

    dm = dm_find(Sid);
    if (dm == NULL) {
	return ERROR_INVALID_HANDLE;
    }
    dm_free(dm);
    return ERROR_SUCCESS;
}

void
dm_addentry(dm_t *dm, void* p, WIN32_FIND_DATA *entry, USHORT name_len)
{
    if (dm->add_res_key) {
	PULONG pl = (PULONG)p;
	*pl = dm->cookie;
	pl++;
	p = pl;
    }

    switch (dm->info_level) {
    case SMB_INFO_STANDARD: {
	PSMB_FIND_BUFFER pResp = (PSMB_FIND_BUFFER) p;

	time64_to_smb_datetime((TIME64 *)&entry->ftCreationTime,
			       &pResp->CreationDate.Ushort,
			       &pResp->CreationTime.Ushort);

	time64_to_smb_datetime((TIME64 *)&entry->ftLastAccessTime,
			       &pResp->LastAccessDate.Ushort,
			       &pResp->LastAccessTime.Ushort);

	time64_to_smb_datetime((TIME64 *)&entry->ftLastWriteTime,
			       &pResp->LastWriteDate.Ushort,
			       &pResp->LastWriteTime.Ushort);

	pResp->DataSize = entry->nFileSizeLow;
	pResp->AllocationSize = pResp->DataSize;
	pResp->Attributes = attribs_to_smb_attribs(entry->dwFileAttributes);
	pResp->FileNameLength = (UCHAR) name_len;
	RtlCopyMemory(pResp->FileName, entry->cFileName, name_len + 1);
	return;
    }
    case SMB_INFO_QUERY_EA_SIZE: {
	PSMB_FIND_BUFFER2 pResp = (PSMB_FIND_BUFFER2) p;
	time64_to_smb_datetime((TIME64 *)&entry->ftCreationTime,
			       &pResp->CreationDate.Ushort,
			       &pResp->CreationTime.Ushort);

	time64_to_smb_datetime((TIME64 *)&entry->ftLastAccessTime,
			       &pResp->LastAccessDate.Ushort,
			       &pResp->LastAccessTime.Ushort);

	time64_to_smb_datetime((TIME64 *)&entry->ftLastWriteTime,
			       &pResp->LastWriteDate.Ushort,
			       &pResp->LastWriteTime.Ushort);

	pResp->DataSize = entry->nFileSizeLow;
	pResp->AllocationSize = pResp->DataSize;
	pResp->Attributes = attribs_to_smb_attribs(entry->dwFileAttributes);
	pResp->EaSize = 0;
	pResp->FileNameLength = (UCHAR)name_len;
	RtlCopyMemory(pResp->FileName, entry->cFileName, name_len + 1);
	return;
    }
    
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_FIND_FILE_DIRECTORY_INFO:
    case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_NAMES_INFO:
    case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
    default:
	return;
    }
}

DWORD
bad_info_level(
    Packet_t * msg
    )
{
    SrvLogError(("DOSERROR: <COULD NOT UNDERSTAND INFO LEVEL>\n"));
    return ERROR_INVALID_FUNCTION;
}


BOOL
Trans2FindFirst2(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    dm_t	*dm;
    WCHAR	wfull_path[MAXPATH];
    char *path, full_path[MAXPATH];
    DWORD error;
    WIN32_FIND_DATA entry;
    PVOID	d = 0;

    PRESP_FIND_FIRST2 pResp;
    PREQ_FIND_FIRST2 pReq;

    if (msg == NULL || trans2 == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);


    SET_REQ(pReq, PREQ_FIND_FIRST2, trans2);

    if (!pDisp) {
        SrvLogError(("DOSERROR: bad uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return FALSE;
    }

    dm = dm_alloc();
    if (!dm) {
        SrvLogError(("DOSERROR:dm_alloc failed\n"));
	SET_WIN32ERROR(msg, ERROR_TOO_MANY_OPEN_FILES);
	return FALSE;
    }

    dm_init(dm, pReq->InformationLevel,
	    pReq->Flags & SMB_FIND_RETURN_RESUME_KEYS);

    if (!dm->base_size) {
	dm_free(dm);
        SET_WIN32ERROR(msg, bad_info_level(msg));
        return FALSE;
    }

    path = (char*)pReq->Buffer;

    // todo: Instead of using findfirst(), read whole directory and
    // store it locally in a temperary buffer. That way I don't have
    // to deal with a handle failing in the middle. Or, ensure that all
    // reads happen on a consistent local replica.

    // build our path
    pDisp->FsGetRoot(fshdl, wfull_path);

    // convert to ascii
    full_path[0] = '\0';
    error = wcstombs(full_path, wfull_path, wcslen(wfull_path));
    full_path[error] = '\0';

    strcat(full_path, path);

    pResp = (PRESP_FIND_FIRST2)
        ADD_RESP_PARAMS(msg, trans2, 0, sizeof(RESP_FIND_FIRST2));
    if (!pResp) {
        SrvLogError(("DOSERROR: not enough buffer space...\n"));
        SET_DOSERROR(msg, SERVER, ERROR);
        return FALSE;
    }

    dm->handle = FindFirstFile(full_path, &entry);

    if (dm->handle == INVALID_HANDLE_VALUE) {
	error = GetLastError();
        SrvLogError(("DOSERROR: could not find filter in '%s' %d\n",full_path, error));
        SET_DOSERROR(msg, SERVER, FILE_SPECS);
        return FALSE;
    }


    // entry number 0
    dm->cookie = 0;
    pResp->SearchCount = 0;
    dm->last = &entry;
    
    while (msg->out.size > msg->out.valid) {
	DWORD	name_len;
	USHORT len;

	len = dm->base_size + lstrlen(entry.cFileName);
	if (len <= (msg->out.size - msg->out.valid)) {
	    d = ADD_RESP_DATA(msg, trans2, 0, len);
	    dm_addentry(dm, d, &entry, len - dm->base_size);
	    dm->cookie++;
	    pResp->SearchCount++;
	    if (FindNextFile(dm->handle, &entry) == 0) {
		error = GetLastError();
		dm->last = NULL;
		break;
	    }
	} else {
	    // we are out of space
	    break;
	}
    } 
	
    if (dm->last != NULL) {
	WIN32_FIND_DATA *p;

	// we ran out of buffer space, we need to safe this entry in our dm
	dm->last = NULL;
	p = (WIN32_FIND_DATA *) malloc(sizeof(*p));
	if (p != NULL) {
	    memcpy(p, &entry, sizeof(entry));
	    dm->last = p;
	} else {
	    // todo: should return failure here
	    ;
	}
    }

    // -- common --
    pResp->EndOfSearch = (error == 18)?1:0;
    pResp->LastNameOffset = (pResp->EndOfSearch)?(((USHORT)((char*)d - 
                                              (char*)msg->out.smb)) -
                                    trans2->out.pResp->DataOffset):0;
    pResp->EaErrorOffset = 0;

    if ((pReq->Flags & SMB_FIND_CLOSE_AFTER_REQUEST) ||
        ((pReq->Flags & SMB_FIND_CLOSE_AT_EOS) && pResp->EndOfSearch)) {
        pResp->Sid = 0xFFFF;
	dm_free(dm);
    } else {
        pResp->Sid = dm->Sid;
    }

    return TRUE;
}

BOOL
Trans2FindNext2(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    DWORD error;
    dm_t *dm;
    PVOID d;

    PRESP_FIND_NEXT2 pResp;
    PREQ_FIND_NEXT2 pReq;

    if (msg == NULL || trans2 == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(pReq, PREQ_FIND_NEXT2, trans2);

    if (!pDisp) {
        SrvLogError(("DOSERROR: bad uid %d\n", uid));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return FALSE;
    }

    dm = dm_find(pReq->Sid);
    if (dm == NULL) {
        SrvLogError(("DOSERROR: could not find sid\n"));
        SET_DOSERROR(msg, DOS, BAD_FID);
        return FALSE;
    }

    dm_init(dm, pReq->InformationLevel, 
	    pReq->Flags & SMB_FIND_RETURN_RESUME_KEYS);

    if (!dm->base_size) {
        SET_WIN32ERROR(msg, bad_info_level(msg));
        return FALSE;
    }

    pResp = (PRESP_FIND_NEXT2)
        ADD_RESP_PARAMS(msg, trans2, 0, sizeof(RESP_FIND_NEXT2));
    if (!pResp) {
        SrvLogError(("DOSERROR: not enough buffer space...\n"));
        SET_DOSERROR(msg, SERVER, ERROR);
        return FALSE;
    }


    if (!(pReq->Flags & SMB_FIND_CONTINUE_FROM_LAST))
        dm->cookie = pReq->ResumeKey;

    pResp->SearchCount = 0;
    while (msg->out.size > msg->out.valid) {
	if (dm->last) {
	    USHORT len;

	    len = lstrlen(dm->last->cFileName) + dm->base_size;
	    if (len <= (msg->out.size - msg->out.valid)) {
		d = ADD_RESP_DATA(msg, trans2, 0, len);
		dm_addentry(dm, d, dm->last, len - dm->base_size);
		dm->cookie++;
		pResp->SearchCount++;
	    } else {
		break;
	    }
	}

	if (FindNextFile(dm->handle, dm->last) == 0) {
	    error = GetLastError();
	    free((char *)dm->last);
	    dm->last = NULL;
	    break;
	}
    }

    // -- common --
    pResp->EndOfSearch = (error == 18)?1:0;
    pResp->LastNameOffset = (pResp->EndOfSearch)?(((USHORT)((char*)d - 
                                              (char*)msg->out.smb)) -
                                    trans2->out.pResp->DataOffset):0;
    pResp->EaErrorOffset = 0;

    if (pResp->EndOfSearch) {
	dm_free(dm);
    }

    return TRUE;
}

BOOL
Trans2QueryPathInfo(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    PVOID fshdl;
    USHORT tid;
    USHORT uid;
    PVOID fsctx;
    FsDispatchTable* pDisp;
    PREQ_QUERY_PATH_INFORMATION pReq;
    PCHAR file_name;
    LPWSTR name;
    int	name_len;
    DWORD error;
    fattr_t attribs;

    if (msg == NULL)
	return FALSE;

    tid = msg->in.smb->Tid;
    uid = msg->in.smb->Uid;
    fsctx = SRV_GET_FS_HANDLE(msg);
    pDisp = FsGetHandle(fsctx, tid, uid, &fshdl);

    SET_REQ(pReq, PREQ_QUERY_PATH_INFORMATION, trans2);

    if (!pDisp) {
        SrvLogError(("Srv: no such uid\n"));
        SET_DOSERROR(msg, SERVER, BAD_UID);
        return FALSE;
    }

    file_name = (PCHAR)pReq->Buffer;

    // convert to unicode
    SRV_ASCII_TO_WCHAR(name, name_len, file_name, lstrlen(file_name));
    if (name != NULL)
	error = pDisp->FsLookup(fshdl, name, (USHORT) name_len, &attribs);
    else 
	error = ERROR_NOT_ENOUGH_MEMORY;
    SRV_ASCII_FREE(name);
    if (error) {
        SrvLogError(("Srv: lookup error 0x%08X\n", error));
        SET_WIN32ERROR(msg, error);
        ADD_RESP_DATA(msg, trans2, NULL, 0);
        return FALSE;
    }

    switch(pReq->InformationLevel) {
    case SMB_INFO_STANDARD: {
        USHORT len = sizeof(SMB_FIND_BUFFER) - sizeof(UCHAR) - sizeof(CHAR);
        PSMB_FIND_BUFFER pResp = (PSMB_FIND_BUFFER) xmalloc(len);
	if (pResp == NULL) {
	    SET_WIN32ERROR(msg, ERROR_NOT_ENOUGH_MEMORY);
	    ADD_RESP_DATA(msg, trans2, NULL, 0);
	    return FALSE;
	}
        time64_to_smb_datetime(&attribs.create_time,
                               &pResp->CreationDate.Ushort,
                               &pResp->CreationTime.Ushort);
        time64_to_smb_datetime(&attribs.access_time,
                               &pResp->LastAccessDate.Ushort,
                               &pResp->LastAccessTime.Ushort);
        time64_to_smb_datetime(&attribs.mod_time,
                               &pResp->LastWriteDate.Ushort,
                               &pResp->LastWriteTime.Ushort);
        pResp->DataSize = (ULONG)attribs.file_size;
        pResp->AllocationSize = (ULONG)attribs.alloc_size;
        pResp->Attributes = attribs_to_smb_attribs(attribs.attributes);
        ADD_RESP_DATA(msg, trans2, pResp, len);
        xfree(pResp);
        return TRUE;
    }
    case SMB_INFO_QUERY_EA_SIZE: {
        USHORT len = sizeof(SMB_FIND_BUFFER2) - sizeof(UCHAR) - sizeof(CHAR);
        PSMB_FIND_BUFFER2 pResp = (PSMB_FIND_BUFFER2) xmalloc(len);
	if (pResp == NULL) {
	    SET_WIN32ERROR(msg, ERROR_NOT_ENOUGH_MEMORY);
	    ADD_RESP_DATA(msg, trans2, NULL, 0);
	    return FALSE;
	}
        time64_to_smb_datetime(&attribs.create_time,
                               &pResp->CreationDate.Ushort,
                               &pResp->CreationTime.Ushort);
        time64_to_smb_datetime(&attribs.access_time,
                               &pResp->LastAccessDate.Ushort,
                               &pResp->LastAccessTime.Ushort);
        time64_to_smb_datetime(&attribs.mod_time,
                               &pResp->LastWriteDate.Ushort,
                               &pResp->LastWriteTime.Ushort);
        pResp->DataSize = (ULONG)attribs.file_size;
        pResp->AllocationSize = (ULONG)attribs.alloc_size;
        pResp->Attributes = attribs_to_smb_attribs(attribs.attributes);
        pResp->EaSize = 0;
        ADD_RESP_DATA(msg, trans2, pResp, len);
        xfree(pResp);
        return TRUE;
    }
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_FIND_FILE_DIRECTORY_INFO:
    case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
    case SMB_FIND_FILE_NAMES_INFO:
    case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
    default: {
        SrvLogError(("Srv: unsupported info level %d>\n"
		     ,pReq->InformationLevel));
        SET_DOSERROR(msg, SERVER, NO_SUPPORT);
        return FALSE;
    }
    }
}

BOOL
Trans2SetPathInfo(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    return Trans2Unknown(msg, trans2);
}

BOOL
Trans2QueryFileInfo(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    return Trans2Unknown(msg, trans2);
}

BOOL
Trans2SetFileInfo(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    return Trans2Unknown(msg, trans2);
}

BOOL
Trans2GetDfsReferral(
    Packet_t * msg,
    Trans2_t * trans2
    )
{
    return Trans2Unknown(msg, trans2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\srv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srv.h.c

Abstract:

    Header for user-level smb server

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef __SRV_H__
#define __SRV_H__

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <winsock2.h>
#include <wsnetbs.h>

#include <stdio.h>

#include <malloc.h>

#ifndef TIME
#define TIME LARGE_INTEGER
#endif

#ifndef CLONG
#define CLONG ULONG
#endif

#pragma pack(1)

#define INCLUDE_SMB_ALL

#include <status.h>
#include <smbtypes.h>
#include <smbmacro.h>
#include <smb.h>
#include <smbtrans.h>
#include <smbgtpt.h>

#include "fs.h"

#define SRV_PACKET_SIZE	0xffff
#define	SRV_NUM_WORKERS	16
#define	SRV_NUM_SENDERS	8
#define MAX_PACKETS	64

#define SRV_NAME_EXTENSION	"$QFS"

#ifndef ERR_STATUS
#define ERR_STATUS	0x4000
#endif

#define SET_DOSERROR(msg, ec, err) {               \
        msg->out.smb->Status.DosError.ErrorClass = SMB_ERR_CLASS_##ec; \
        msg->out.smb->Status.DosError.Error = SMB_ERR_##err;     \
    }


#define xmalloc(size)  VirtualAlloc(NULL, size,MEM_RESERVE|MEM_COMMIT,PAGE_READWRITE)

#define xfree(buffer) VirtualFree(buffer, 0, MEM_RELEASE|MEM_DECOMMIT) 

typedef void (WINAPI *srv_callback_t)(PVOID, UINT32 status, UINT32 information);

typedef struct _ENDPOINT_ {
    struct _ENDPOINT_	*Next;
    struct _SRVCTX_	*SrvCtx;
    SOCKET	Sock;
    struct _PACKET_	*PacketList;
    LUID	LogonId;
    DWORD	ChallengeBufferSz;
    char	ChallengeBuffer[128];
    char	ClientId[NETBIOS_NAME_LENGTH];
}EndPoint_t;

typedef struct _PACKET_ {
    union {
	OVERLAPPED	ov;
	struct {
	    int		tag;
	    srv_callback_t completion;
	};
    };
    struct _PACKET_ *next;
    EndPoint_t *endpoint;
    DWORD len;
    LPVOID buffer;

    LPVOID outbuf;
    HANDLE ev;
    struct { 
	PNT_SMB_HEADER smb;
	DWORD size;
	DWORD offset;
	USHORT command;
    } in;

    struct { 
	PNT_SMB_HEADER smb;
	DWORD size;
	USHORT valid;
    } out;

}Packet_t;

typedef struct _SRVCTX_ {
    CRITICAL_SECTION	cs;
    Packet_t	*freelist;
    BOOL	running;
    DWORD	waiters;
    HANDLE	event;
    PVOID	packet_pool;
    PVOID	buffer_pool;
    SOCKET	listen_socket;

    HANDLE	LsaHandle;
    ULONG	LsaPack;

    EndPoint_t	*EndPointList;

    WSADATA	wsaData;

    PVOID	FsCtx;
    PVOID	resHdl;

    DWORD	nic;
    char	nb_local_name[NETBIOS_NAME_LENGTH];
    HANDLE	comport;
    int		nThreads;
    HANDLE*	hThreads;
}SrvCtx_t;


typedef struct {
    struct {
	PREQ_TRANSACTION pReq;
	PUCHAR pParameters;
	PUCHAR pData;
    }in;
    struct {
	PRESP_TRANSACTION pResp;
	USHORT ParameterBytesLeft;
	USHORT DataBytesLeft;
	PUSHORT pByteCount;
    }out;
} Trans2_t;

#define SRV_GET_FS_HANDLE(msg)	((msg)->endpoint->SrvCtx->FsCtx)

#define SRV_ASCII_TO_WCHAR(buf,buflen,name,len) {\
    buflen = (len + 1) * sizeof(WCHAR); \
    buf = (WCHAR *) LocalAlloc(LMEM_FIXED, buflen); \
    if (buf != NULL) { \
        buflen = mbstowcs(buf, name, len); \
        if (buflen < 0) buflen = 0; \
        buf[buflen] = L'\0'; \
    } \
}\

#define	SRV_ASCII_FREE(buf)	((buf) ? LocalFree(buf) : 0)

void
SrvUtilInit(SrvCtx_t *);

void
SrvUtilExit();


#define DumpSmb(x,y,z)

BOOL
IsSmb(
    LPVOID pBuffer,
    DWORD nLength
    );

void
SrvFinalize(Packet_t *msg);

BOOL
SrvDispatch(
    Packet_t* msg
    );

BOOL
Trans2Dispatch(
    Packet_t* msg,
    Trans2_t* trans
    );

VOID
InitSmbHeader(
    Packet_t* msg
    );

LPCSTR
SrvUnparseCommand(
    USHORT command
    );

LPCSTR
SrvUnparseTrans2(
    USHORT code
    );

USHORT
attribs_to_smb_attribs(
    UINT32 attribs
    );

UINT32
smb_attribs_to_attribs(
    USHORT smb_attribs
    );

UINT32
smb_access_to_flags(
    USHORT access
    );

UINT32
smb_openfunc_to_flags(
    USHORT openfunc
    );


void SET_WIN32ERROR(Packet_t* msg,  DWORD error );

ULONG // local time
time64_to_smb_timedate(
    TIME64 *time // system time
    );

void
smb_datetime_to_time64(
    const USHORT smbdate,
    const USHORT smbtime,
    TIME64 *time
    );

#define time64_to_smb_datetime(a,b,c) { \
    USHORT t1, t2; \
    _time64_to_smb_datetime(a,&t1,&t2); \
    *b = t1; *c = t2;  \
}

void
_time64_to_smb_datetime(
    TIME64 *time,
    USHORT *smbdate,
    USHORT *smbtime
    );

ULONG // local time
time64_to_smb_timedate(
    TIME64 *time // system time
    );

TIME64 // system time
smb_timedate_to_time64(
    ULONG smb_timedate // local time
    );


BOOL
SrvComUnknown(
    Packet_t* msg
    );

BOOL
SrvComNegotiate(
    Packet_t* msg
    );

BOOL
SrvComSessionSetupAndx(
    Packet_t* msg
    );

BOOL
SrvComTreeConnectAndx(
    Packet_t* msg
    );

BOOL
SrvComNoAndx(
    Packet_t* msg
    );

BOOL
SrvComTrans2(
    Packet_t* msg
    );

BOOL
SrvComTrans(
    Packet_t* msg
    );

BOOL
SrvComQueryInformation(
    Packet_t* msg
    );

BOOL
SrvComSetInformation(
    Packet_t* msg
    );

BOOL
SrvComCheckDirectory(
    Packet_t* msg
    );

BOOL
SrvComFindClose2(
    Packet_t* msg
    );

BOOL
SrvComFindNotifyClose(
    Packet_t* msg
    );

BOOL
SrvComDelete(
    Packet_t* msg
    );

BOOL
SrvComRename(
    Packet_t* msg
    );

BOOL
SrvComCreateDirectory(
    Packet_t* msg
    );

BOOL
SrvComDeleteDirectory(
    Packet_t* msg
    );

BOOL
SrvComOpenAndx(
    Packet_t* msg
    );

BOOL
SrvComOpen(
    Packet_t* msg
    );

BOOL
SrvComWrite(
    Packet_t* msg
    );

BOOL
SrvComClose(
    Packet_t* msg
    );

BOOL
SrvComReadAndx(
    Packet_t* msg
    );

BOOL
SrvComQueryInformation2(
    Packet_t* msg
    );

BOOL
SrvComSetInformation2(
    Packet_t* msg
    );

BOOL
SrvComLockingAndx(
    Packet_t* msg
    );

BOOL
SrvComSeek(
    Packet_t* msg
    );

BOOL
SrvComFlush(
    Packet_t* msg
    );

BOOL
SrvComLogoffAndx(
    Packet_t* msg
    );

BOOL
SrvComTreeDisconnect(
    Packet_t* msg
    );

BOOL
SrvComSearch(
    Packet_t* msg
    );


BOOL
SrvComIoctl(
    Packet_t* msg
    );

BOOL
SrvComEcho(
    Packet_t* msg
    );

#define SIZEOF_TRANS2_RESP_HEADER(resp) (1 + resp->SetupCount)*sizeof(USHORT)

BOOL
Trans2Unknown(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2QueryFsInfo(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2FindFirst2(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2FindNext2(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2QueryPathInfo(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2SetPathInfo(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2QueryFileInfo(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2SetFileInfo(
    Packet_t *msg,
    Trans2_t *trans
    );

BOOL
Trans2GetDfsReferral(
    Packet_t *msg,
    Trans2_t *trans
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\util.h ===
#ifndef _X_FS_H
#define _X_FS_H

extern 
char *
char *
BuildRelativePath(VolInfo *vol, int nid, char *path);

NTSTATUS
FsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl);

DWORD
FsGetHandlePath(HANDLE fd, char *path, int *pathlen);

NTSTATUS
FsGetPathById(HANDLE vfd, fs_id_t *id, char *name, int *name_len);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\srvutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srvutil.c

Abstract:

    Implements misc. smb stuff

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#include "srv.h"

#if TRANS2_MAX_FUNCTION > 0xFF
#pragma error "TRANS2_MAX_FUNCTION > 0xFF"
#endif

typedef BOOL (*SMB_DISPATCH_FUNC)(Packet_t *);
typedef BOOL (*TRANS2_DISPATCH_FUNC)(Packet_t *, Trans2_t *);

static SMB_DISPATCH_FUNC SrvDispatchTable[0x100] = {0};
static TRANS2_DISPATCH_FUNC Trans2DispatchTable[0x100] = {0};


VOID
SrvInitDispTable();

void
SrvUtilInit(SrvCtx_t *ctx)
{
    extern void Trans2Init();

    SrvInitDispTable();

    Trans2Init();
}

void
SrvUtilExit(SrvCtx_t *ctx)
{
    // nothing to do
    return;
}


BOOL
IsSmb(
    LPVOID pBuffer,
    DWORD nLength
    )
{
    PNT_SMB_HEADER pSmb = (PNT_SMB_HEADER) pBuffer;
    return (pSmb && !(nLength < sizeof(NT_SMB_HEADER)) &&
            (*(PULONG)pSmb->Protocol == SMB_HEADER_PROTOCOL));
}

BOOL
SrvDispatch(
    Packet_t * msg
    )
{
    USHORT command =  msg->in.command;
    if (command > 0xFF) {
        SrvLogError(("(command > 0xFF)\n"));
        return FALSE;
    }
    SrvLog(("- parameter block - <0x%02x = %s>\n",
                 command,
                 SrvUnparseCommand(command)));
    if (SrvDispatchTable[command])
        return SrvDispatchTable[command](msg);
    else {
        return SrvComUnknown(msg);
    }
}

// returns whether or not to conitnue
BOOL
Trans2Dispatch(
    Packet_t * msg,
    Trans2_t * trans
    )
{
    USHORT command = msg->in.command;
    if (command > 0xFF) {
        SrvLogError(("DOSERROR: (function > 0xFF)\n"));
        SET_DOSERROR(msg, SERVER, NO_SUPPORT);
        return FALSE;
    }
    if (command > TRANS2_MAX_FUNCTION) {
        SrvLogError(("DOSERROR: (function > maximum)\n"));
        SET_DOSERROR(msg, SERVER, NO_SUPPORT);
        return FALSE;
    }
    SrvLog(("- parameter block - <0x%02x = %s>\n",
                 command,
                 SrvUnparseTrans2(command)));
    if (Trans2DispatchTable[command])
        return Trans2DispatchTable[command](msg, trans);
    else {
        return Trans2Unknown(msg, trans);
    }
}   

VOID
InitSmbHeader(
    Packet_t * msg
    )
{
    ZeroMemory(msg->out.smb, sizeof(NT_SMB_HEADER));
    CopyMemory(msg->out.smb->Protocol, msg->in.smb->Protocol, 
               sizeof(msg->out.smb->Protocol));
    msg->out.smb->Command = msg->in.smb->Command;
    msg->out.smb->Flags = 0x80;
    msg->out.smb->Flags2 = 1;
    msg->out.smb->Pid = msg->in.smb->Pid;
    msg->out.smb->Tid = msg->in.smb->Tid;
    msg->out.smb->Mid = msg->in.smb->Mid;
    msg->out.smb->Uid = msg->in.smb->Uid;
}

#define XLAT_STRING(code) static const char STRING_##code[] = #code
#define XLAT_CASE(code) case code: return STRING_##code
#define XLAT_STRING_DEFAULT XLAT_STRING(Unknown)
#define XLAT_CASE_DEFAULT default: return STRING_Unknown

LPCSTR
SrvUnparseCommand(
    USHORT command
    )
{
    XLAT_STRING_DEFAULT;
    XLAT_STRING(SMB_COM_CREATE_DIRECTORY);
    XLAT_STRING(SMB_COM_DELETE_DIRECTORY);
    XLAT_STRING(SMB_COM_OPEN);
    XLAT_STRING(SMB_COM_CREATE);
    XLAT_STRING(SMB_COM_CLOSE);
    XLAT_STRING(SMB_COM_FLUSH);
    XLAT_STRING(SMB_COM_DELETE);
    XLAT_STRING(SMB_COM_RENAME);
    XLAT_STRING(SMB_COM_QUERY_INFORMATION);
    XLAT_STRING(SMB_COM_SET_INFORMATION);
    XLAT_STRING(SMB_COM_READ);
    XLAT_STRING(SMB_COM_WRITE);
    XLAT_STRING(SMB_COM_LOCK_BYTE_RANGE);
    XLAT_STRING(SMB_COM_UNLOCK_BYTE_RANGE);
    XLAT_STRING(SMB_COM_CREATE_TEMPORARY);
    XLAT_STRING(SMB_COM_CREATE_NEW);
    XLAT_STRING(SMB_COM_CHECK_DIRECTORY);
    XLAT_STRING(SMB_COM_PROCESS_EXIT);
    XLAT_STRING(SMB_COM_SEEK);
    XLAT_STRING(SMB_COM_LOCK_AND_READ);
    XLAT_STRING(SMB_COM_WRITE_AND_UNLOCK);
    XLAT_STRING(SMB_COM_READ_RAW);
    XLAT_STRING(SMB_COM_READ_MPX);
    XLAT_STRING(SMB_COM_READ_MPX_SECONDARY);    // server to redir only
    XLAT_STRING(SMB_COM_WRITE_RAW);
    XLAT_STRING(SMB_COM_WRITE_MPX);
    XLAT_STRING(SMB_COM_WRITE_MPX_SECONDARY);
    XLAT_STRING(SMB_COM_WRITE_COMPLETE);    // server to redir only
    XLAT_STRING(SMB_COM_QUERY_INFORMATION_SRV);
    XLAT_STRING(SMB_COM_SET_INFORMATION2);
    XLAT_STRING(SMB_COM_QUERY_INFORMATION2);
    XLAT_STRING(SMB_COM_LOCKING_ANDX);
    XLAT_STRING(SMB_COM_TRANSACTION);
    XLAT_STRING(SMB_COM_TRANSACTION_SECONDARY);
    XLAT_STRING(SMB_COM_IOCTL);
    XLAT_STRING(SMB_COM_IOCTL_SECONDARY);
    XLAT_STRING(SMB_COM_COPY);
    XLAT_STRING(SMB_COM_MOVE);
    XLAT_STRING(SMB_COM_ECHO);
    XLAT_STRING(SMB_COM_WRITE_AND_CLOSE);
    XLAT_STRING(SMB_COM_OPEN_ANDX);
    XLAT_STRING(SMB_COM_READ_ANDX);
    XLAT_STRING(SMB_COM_WRITE_ANDX);
    XLAT_STRING(SMB_COM_CLOSE_AND_TREE_DISC);
    XLAT_STRING(SMB_COM_TRANSACTION2);
    XLAT_STRING(SMB_COM_TRANSACTION2_SECONDARY);
    XLAT_STRING(SMB_COM_FIND_CLOSE2);
    XLAT_STRING(SMB_COM_FIND_NOTIFY_CLOSE);
    XLAT_STRING(SMB_COM_TREE_CONNECT);
    XLAT_STRING(SMB_COM_TREE_DISCONNECT);
    XLAT_STRING(SMB_COM_NEGOTIATE);
    XLAT_STRING(SMB_COM_SESSION_SETUP_ANDX);
    XLAT_STRING(SMB_COM_LOGOFF_ANDX);
    XLAT_STRING(SMB_COM_TREE_CONNECT_ANDX);
    XLAT_STRING(SMB_COM_QUERY_INFORMATION_DISK);
    XLAT_STRING(SMB_COM_SEARCH);
    XLAT_STRING(SMB_COM_FIND);
    XLAT_STRING(SMB_COM_FIND_UNIQUE);
    XLAT_STRING(SMB_COM_FIND_CLOSE);
    XLAT_STRING(SMB_COM_NT_TRANSACT);
    XLAT_STRING(SMB_COM_NT_TRANSACT_SECONDARY);
    XLAT_STRING(SMB_COM_NT_CREATE_ANDX);
    XLAT_STRING(SMB_COM_NT_CANCEL);
    XLAT_STRING(SMB_COM_NT_RENAME);
    XLAT_STRING(SMB_COM_OPEN_PRINT_FILE);
    XLAT_STRING(SMB_COM_WRITE_PRINT_FILE);
    XLAT_STRING(SMB_COM_CLOSE_PRINT_FILE);
    XLAT_STRING(SMB_COM_GET_PRINT_QUEUE);
    XLAT_STRING(SMB_COM_SEND_MESSAGE);
    XLAT_STRING(SMB_COM_SEND_BROADCAST_MESSAGE);
    XLAT_STRING(SMB_COM_FORWARD_USER_NAME);
    XLAT_STRING(SMB_COM_CANCEL_FORWARD);
    XLAT_STRING(SMB_COM_GET_MACHINE_NAME);
    XLAT_STRING(SMB_COM_SEND_START_MB_MESSAGE);
    XLAT_STRING(SMB_COM_SEND_END_MB_MESSAGE);
    XLAT_STRING(SMB_COM_SEND_TEXT_MB_MESSAGE);

    switch (command)
    {
        XLAT_CASE(SMB_COM_CREATE_DIRECTORY);
        XLAT_CASE(SMB_COM_DELETE_DIRECTORY);
        XLAT_CASE(SMB_COM_OPEN);
        XLAT_CASE(SMB_COM_CREATE);
        XLAT_CASE(SMB_COM_CLOSE);
        XLAT_CASE(SMB_COM_FLUSH);
        XLAT_CASE(SMB_COM_DELETE);
        XLAT_CASE(SMB_COM_RENAME);
        XLAT_CASE(SMB_COM_QUERY_INFORMATION);
        XLAT_CASE(SMB_COM_SET_INFORMATION);
        XLAT_CASE(SMB_COM_READ);
        XLAT_CASE(SMB_COM_WRITE);
        XLAT_CASE(SMB_COM_LOCK_BYTE_RANGE);
        XLAT_CASE(SMB_COM_UNLOCK_BYTE_RANGE);
        XLAT_CASE(SMB_COM_CREATE_TEMPORARY);
        XLAT_CASE(SMB_COM_CREATE_NEW);
        XLAT_CASE(SMB_COM_CHECK_DIRECTORY);
        XLAT_CASE(SMB_COM_PROCESS_EXIT);
        XLAT_CASE(SMB_COM_SEEK);
        XLAT_CASE(SMB_COM_LOCK_AND_READ);
        XLAT_CASE(SMB_COM_WRITE_AND_UNLOCK);
        XLAT_CASE(SMB_COM_READ_RAW);
        XLAT_CASE(SMB_COM_READ_MPX);
        XLAT_CASE(SMB_COM_READ_MPX_SECONDARY);    // server to redir only
        XLAT_CASE(SMB_COM_WRITE_RAW);
        XLAT_CASE(SMB_COM_WRITE_MPX);
        XLAT_CASE(SMB_COM_WRITE_MPX_SECONDARY);
        XLAT_CASE(SMB_COM_WRITE_COMPLETE);    // server to redir only
        XLAT_CASE(SMB_COM_QUERY_INFORMATION_SRV);
        XLAT_CASE(SMB_COM_SET_INFORMATION2);
        XLAT_CASE(SMB_COM_QUERY_INFORMATION2);
        XLAT_CASE(SMB_COM_LOCKING_ANDX);
        XLAT_CASE(SMB_COM_TRANSACTION);
        XLAT_CASE(SMB_COM_TRANSACTION_SECONDARY);
        XLAT_CASE(SMB_COM_IOCTL);
        XLAT_CASE(SMB_COM_IOCTL_SECONDARY);
        XLAT_CASE(SMB_COM_COPY);
        XLAT_CASE(SMB_COM_MOVE);
        XLAT_CASE(SMB_COM_ECHO);
        XLAT_CASE(SMB_COM_WRITE_AND_CLOSE);
        XLAT_CASE(SMB_COM_OPEN_ANDX);
        XLAT_CASE(SMB_COM_READ_ANDX);
        XLAT_CASE(SMB_COM_WRITE_ANDX);
        XLAT_CASE(SMB_COM_CLOSE_AND_TREE_DISC);
        XLAT_CASE(SMB_COM_TRANSACTION2);
        XLAT_CASE(SMB_COM_TRANSACTION2_SECONDARY);
        XLAT_CASE(SMB_COM_FIND_CLOSE2);
        XLAT_CASE(SMB_COM_FIND_NOTIFY_CLOSE);
        XLAT_CASE(SMB_COM_TREE_CONNECT);
        XLAT_CASE(SMB_COM_TREE_DISCONNECT);
        XLAT_CASE(SMB_COM_NEGOTIATE);
        XLAT_CASE(SMB_COM_SESSION_SETUP_ANDX);
        XLAT_CASE(SMB_COM_LOGOFF_ANDX);
        XLAT_CASE(SMB_COM_TREE_CONNECT_ANDX);
        XLAT_CASE(SMB_COM_QUERY_INFORMATION_DISK);
        XLAT_CASE(SMB_COM_SEARCH);
        XLAT_CASE(SMB_COM_FIND);
        XLAT_CASE(SMB_COM_FIND_UNIQUE);
        XLAT_CASE(SMB_COM_FIND_CLOSE);
        XLAT_CASE(SMB_COM_NT_TRANSACT);
        XLAT_CASE(SMB_COM_NT_TRANSACT_SECONDARY);
        XLAT_CASE(SMB_COM_NT_CREATE_ANDX);
        XLAT_CASE(SMB_COM_NT_CANCEL);
        XLAT_CASE(SMB_COM_NT_RENAME);
        XLAT_CASE(SMB_COM_OPEN_PRINT_FILE);
        XLAT_CASE(SMB_COM_WRITE_PRINT_FILE);
        XLAT_CASE(SMB_COM_CLOSE_PRINT_FILE);
        XLAT_CASE(SMB_COM_GET_PRINT_QUEUE);
        XLAT_CASE(SMB_COM_SEND_MESSAGE);
        XLAT_CASE(SMB_COM_SEND_BROADCAST_MESSAGE);
        XLAT_CASE(SMB_COM_FORWARD_USER_NAME);
        XLAT_CASE(SMB_COM_CANCEL_FORWARD);
        XLAT_CASE(SMB_COM_GET_MACHINE_NAME);
        XLAT_CASE(SMB_COM_SEND_START_MB_MESSAGE);
        XLAT_CASE(SMB_COM_SEND_END_MB_MESSAGE);
        XLAT_CASE(SMB_COM_SEND_TEXT_MB_MESSAGE);
        XLAT_CASE_DEFAULT;
    }
}

LPCSTR
SrvUnparseTrans2(
    USHORT code
    )
{
    XLAT_STRING_DEFAULT;
    XLAT_STRING(TRANS2_OPEN2);
    XLAT_STRING(TRANS2_FIND_FIRST2);
    XLAT_STRING(TRANS2_FIND_NEXT2);
    XLAT_STRING(TRANS2_QUERY_FS_INFORMATION);
    XLAT_STRING(TRANS2_SET_FS_INFORMATION);
    XLAT_STRING(TRANS2_QUERY_PATH_INFORMATION);
    XLAT_STRING(TRANS2_SET_PATH_INFORMATION);
    XLAT_STRING(TRANS2_QUERY_FILE_INFORMATION);
    XLAT_STRING(TRANS2_SET_FILE_INFORMATION);
    XLAT_STRING(TRANS2_FSCTL);
    XLAT_STRING(TRANS2_IOCTL2);
    XLAT_STRING(TRANS2_FIND_NOTIFY_FIRST);
    XLAT_STRING(TRANS2_FIND_NOTIFY_NEXT);
    XLAT_STRING(TRANS2_CREATE_DIRECTORY);
    XLAT_STRING(TRANS2_SESSION_SETUP);
    XLAT_STRING(TRANS2_QUERY_FS_INFORMATION_FID);
    XLAT_STRING(TRANS2_GET_DFS_REFERRAL);
    XLAT_STRING(TRANS2_REPORT_DFS_INCONSISTENCY);

    switch (code)
    {
        XLAT_CASE(TRANS2_OPEN2);
        XLAT_CASE(TRANS2_FIND_FIRST2);
        XLAT_CASE(TRANS2_FIND_NEXT2);
        XLAT_CASE(TRANS2_QUERY_FS_INFORMATION);
        XLAT_CASE(TRANS2_SET_FS_INFORMATION);
        XLAT_CASE(TRANS2_QUERY_PATH_INFORMATION);
        XLAT_CASE(TRANS2_SET_PATH_INFORMATION);
        XLAT_CASE(TRANS2_QUERY_FILE_INFORMATION);
        XLAT_CASE(TRANS2_SET_FILE_INFORMATION);
        XLAT_CASE(TRANS2_FSCTL);
        XLAT_CASE(TRANS2_IOCTL2);
        XLAT_CASE(TRANS2_FIND_NOTIFY_FIRST);
        XLAT_CASE(TRANS2_FIND_NOTIFY_NEXT);
        XLAT_CASE(TRANS2_CREATE_DIRECTORY);
        XLAT_CASE(TRANS2_SESSION_SETUP);
        XLAT_CASE(TRANS2_QUERY_FS_INFORMATION_FID);
        XLAT_CASE(TRANS2_GET_DFS_REFERRAL);
        XLAT_CASE(TRANS2_REPORT_DFS_INCONSISTENCY);
        XLAT_CASE_DEFAULT;
    }
}

VOID
SrvInitDispTable(
    )
{
    ZeroMemory((PVOID) SrvDispatchTable, sizeof(SrvDispatchTable));
    SrvDispatchTable[SMB_COM_NEGOTIATE] = SrvComNegotiate;
    SrvDispatchTable[SMB_COM_TRANSACTION] = SrvComTrans;
    SrvDispatchTable[SMB_COM_TRANSACTION2] = SrvComTrans2;
    SrvDispatchTable[SMB_COM_SESSION_SETUP_ANDX] = SrvComSessionSetupAndx;
    SrvDispatchTable[SMB_COM_TREE_CONNECT_ANDX] = SrvComTreeConnectAndx;
    SrvDispatchTable[SMB_COM_NO_ANDX_COMMAND] = SrvComNoAndx;
    SrvDispatchTable[SMB_COM_QUERY_INFORMATION] = SrvComQueryInformation;
    SrvDispatchTable[SMB_COM_SET_INFORMATION] = SrvComSetInformation;
    SrvDispatchTable[SMB_COM_CHECK_DIRECTORY] = SrvComCheckDirectory;
    SrvDispatchTable[SMB_COM_FIND_CLOSE2] = SrvComFindClose2;
    SrvDispatchTable[SMB_COM_DELETE] = SrvComDelete;
    SrvDispatchTable[SMB_COM_RENAME] = SrvComRename;
    SrvDispatchTable[SMB_COM_CREATE_DIRECTORY] = SrvComCreateDirectory;
    SrvDispatchTable[SMB_COM_DELETE_DIRECTORY] = SrvComDeleteDirectory;
    SrvDispatchTable[SMB_COM_OPEN_ANDX] = SrvComOpenAndx;
    SrvDispatchTable[SMB_COM_OPEN] = SrvComOpen;
    SrvDispatchTable[SMB_COM_WRITE] = SrvComWrite;
    SrvDispatchTable[SMB_COM_CLOSE] = SrvComClose;
    SrvDispatchTable[SMB_COM_READ_ANDX] = SrvComReadAndx;
    SrvDispatchTable[SMB_COM_QUERY_INFORMATION2] = SrvComQueryInformation2;
    SrvDispatchTable[SMB_COM_SET_INFORMATION2] = SrvComSetInformation2;
    SrvDispatchTable[SMB_COM_LOCKING_ANDX] = SrvComLockingAndx;
    SrvDispatchTable[SMB_COM_SEEK] = SrvComSeek;
    SrvDispatchTable[SMB_COM_FLUSH] = SrvComFlush;
    SrvDispatchTable[SMB_COM_LOGOFF_ANDX] = SrvComLogoffAndx;
    SrvDispatchTable[SMB_COM_TREE_DISCONNECT] = SrvComTreeDisconnect;
    SrvDispatchTable[SMB_COM_FIND_NOTIFY_CLOSE] = SrvComFindNotifyClose;

    SrvDispatchTable[SMB_COM_SEARCH] = SrvComSearch;

    SrvDispatchTable[SMB_COM_IOCTL] = SrvComIoctl;

    SrvDispatchTable[SMB_COM_ECHO] = SrvComEcho;

    ZeroMemory((PVOID) Trans2DispatchTable, sizeof(Trans2DispatchTable));
    Trans2DispatchTable[TRANS2_QUERY_FS_INFORMATION] = Trans2QueryFsInfo;
    Trans2DispatchTable[TRANS2_FIND_FIRST2] = Trans2FindFirst2;
    Trans2DispatchTable[TRANS2_FIND_NEXT2] = Trans2FindNext2;
    Trans2DispatchTable[TRANS2_QUERY_PATH_INFORMATION] = Trans2QueryPathInfo;
    Trans2DispatchTable[TRANS2_SET_PATH_INFORMATION] = Trans2SetPathInfo;
    Trans2DispatchTable[TRANS2_QUERY_FILE_INFORMATION] = Trans2QueryFileInfo;
    Trans2DispatchTable[TRANS2_SET_FILE_INFORMATION] = Trans2SetFileInfo;
    Trans2DispatchTable[TRANS2_GET_DFS_REFERRAL] = Trans2GetDfsReferral;
}



USHORT
attribs_to_smb_attribs(
    UINT32 attribs
    )
{
    USHORT smb_attribs = 0;
    if (attribs & ATTR_READONLY)  smb_attribs |= SMB_FILE_ATTRIBUTE_READONLY;
    if (attribs & ATTR_HIDDEN)    smb_attribs |= SMB_FILE_ATTRIBUTE_HIDDEN;
    if (attribs & ATTR_SYSTEM)    smb_attribs |= SMB_FILE_ATTRIBUTE_SYSTEM;
    if (attribs & ATTR_ARCHIVE)   smb_attribs |= SMB_FILE_ATTRIBUTE_ARCHIVE;
    if (attribs & ATTR_DIRECTORY) smb_attribs |= SMB_FILE_ATTRIBUTE_DIRECTORY;
    return smb_attribs;
}

UINT32
smb_attribs_to_attribs(
    USHORT smb_attribs
    )
{
    UINT32 attribs = 0;
    if (smb_attribs & SMB_FILE_ATTRIBUTE_READONLY)  attribs |= ATTR_READONLY;
    if (smb_attribs & SMB_FILE_ATTRIBUTE_HIDDEN)    attribs |= ATTR_HIDDEN;
    if (smb_attribs & SMB_FILE_ATTRIBUTE_SYSTEM)    attribs |= ATTR_SYSTEM;
    if (smb_attribs & SMB_FILE_ATTRIBUTE_ARCHIVE)   attribs |= ATTR_ARCHIVE;
    if (smb_attribs & SMB_FILE_ATTRIBUTE_DIRECTORY) attribs |= ATTR_DIRECTORY;
    return attribs;
}

UINT32
smb_access_to_flags(
    USHORT access
    )
{
    UINT32 flags = 0;
    switch (access & SMB_DA_SHARE_MASK) {
    case SMB_DA_SHARE_COMPATIBILITY:
    case SMB_DA_SHARE_DENY_NONE:
        flags |= SHARE_READ | SHARE_WRITE;
        break;
    case SMB_DA_SHARE_DENY_WRITE:
        flags |= SHARE_READ;
        break;
    case SMB_DA_SHARE_DENY_READ:
        flags |= SHARE_WRITE;
        break;
    case SMB_DA_SHARE_EXCLUSIVE:
    default:
        break;
    }
    switch (access & SMB_DA_ACCESS_MASK) {
    case SMB_DA_ACCESS_READ:
    case SMB_DA_ACCESS_EXECUTE:
        flags |= ACCESS_READ;
        break;
    case SMB_DA_ACCESS_WRITE:
        flags |= ACCESS_WRITE;
        break;
    case SMB_DA_ACCESS_READ_WRITE:
        flags |= ACCESS_READ | ACCESS_WRITE;
        break;
    }

    if (access & SMB_DO_NOT_CACHE) {
	flags |= CACHE_NO_BUFFERING;
    }
    if (access & SMB_DA_WRITE_THROUGH) {
	flags |= CACHE_WRITE_THROUGH;
    }
    return flags;
}

UINT32
smb_openfunc_to_flags(
    USHORT openfunc
    )
{
    switch (openfunc & (SMB_OFUN_OPEN_MASK | SMB_OFUN_CREATE_MASK)) {
    case (SMB_OFUN_CREATE_FAIL   | SMB_OFUN_OPEN_FAIL):
        return 0;
    case (SMB_OFUN_CREATE_FAIL   | SMB_OFUN_OPEN_OPEN):
        return DISP_OPEN_EXISTING;
    case (SMB_OFUN_CREATE_FAIL   | SMB_OFUN_OPEN_TRUNCATE):
        return DISP_TRUNCATE_EXISTING;
    case (SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL):
        return DISP_CREATE_NEW;
    case (SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_OPEN):
        return DISP_OPEN_ALWAYS;
    case (SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_TRUNCATE):
        return DISP_CREATE_ALWAYS;
    default:
        return 0;
    }
}

void
local_time64(
    TIME64 *time  // system time to be converted to local time
    )
{
    TIME64 local = *time;
    FileTimeToLocalFileTime((LPFILETIME)time, (LPFILETIME)&local);
    *time = local;
}

void
sys_time64(
    TIME64 *time  // local time to be converted to system time
    )
{
    TIME64 sys = *time;
    LocalFileTimeToFileTime((LPFILETIME)time, (LPFILETIME)&sys);
    *time = sys;
}

void
smb_datetime_to_time64(
    const USHORT smbdate,
    const USHORT smbtime,
    TIME64 *time
    )
{
    DosDateTimeToFileTime(smbdate, smbtime, (LPFILETIME)time);
    sys_time64(time);
}

typedef struct {
    SMB_TIME time;
    SMB_DATE date;
}SMB_TIMEDATE;

TIME64 // system time
smb_timedate_to_time64(
    ULONG smb_timedate // local time
    )
{
    TIME64 time = 0;
    DosDateTimeToFileTime(((SMB_TIMEDATE*)&smb_timedate)->date.Ushort,
                          ((SMB_TIMEDATE*)&smb_timedate)->time.Ushort,
                          (LPFILETIME)&time);
    sys_time64(&time);
    return time;
}

void
_time64_to_smb_datetime(
    TIME64 *time,
    USHORT *smbdate,
    USHORT *smbtime
    )
{
    local_time64(time);
    *smbdate = *smbtime = 0;
    FileTimeToDosDateTime((LPFILETIME)time, smbdate, smbtime);
}

ULONG // local time
time64_to_smb_timedate(
    TIME64 *time // system time
    )
{
    ULONG smb_timedate = 0;
    local_time64(time);
    FileTimeToDosDateTime((LPFILETIME)&time,
                          &(((SMB_TIMEDATE*)&smb_timedate)->date.Ushort),
                          &(((SMB_TIMEDATE*)&smb_timedate)->date.Ushort));
    return smb_timedate;
}


#define dword_in_range(in, low, high) ((low <= in) && (in <= high))

void set_DOSERROR(Packet_t * msg, USHORT ec, USHORT err)
{
    msg->out.smb->Status.DosError.ErrorClass = (unsigned char) ec;
    msg->out.smb->Status.DosError.Error = err;
}

void SET_WIN32ERROR(
    Packet_t * msg, 
    DWORD error
    )
{

    if (!error) return;
    if (dword_in_range(error, 1, 18) || (error == 32) || (error == 33) || 
        (error == 80) || dword_in_range(error, 230, 234) || (error == 145)) {
        set_DOSERROR(msg,
                     SMB_ERR_CLASS_DOS, 
                     (USHORT)error);
    } else if (dword_in_range(error, 19, 31) || 
        (error == 34) || (error == 36) || (error == 39)) {
        set_DOSERROR(msg,
                     SMB_ERR_CLASS_HARDWARE, 
                     (USHORT)error);
    } else if (error == 112) {
        SET_DOSERROR(msg, HARDWARE, DISK_FULL);
    } else if (error == 67) {
        SET_DOSERROR(msg, SERVER, BAD_NET_NAME);
    } else if (error == 123) {
        set_DOSERROR(msg,
                     SMB_ERR_CLASS_SERVER,
                     (USHORT)error);
    } else if (error == 183) {
        SET_DOSERROR(msg, DOS, FILE_EXISTS);
    } else {
        SET_DOSERROR(msg, SERVER, ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\undo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    undo.c

Abstract:

    Implements undo of records during replica recovery

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "fsp.h"
#include "fsutil.h"

NTSTATUS
fs_undo_create(VolInfo_t *volinfo,
		 fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR name[MAXPATH];
    int name_len = sizeof(name);

    name[0] = '\0';

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogUndo(("fs_undo_create: try %I64x:%I64x\n",
		  lrec->id[0], lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_len);

    if (err == STATUS_SUCCESS) {
	int relative_name_len;
	LPWSTR relative_name;

	relative_name = xFsBuildRelativePath(volinfo, nid, name);
	relative_name_len = wcslen(relative_name);

	err = xFsDelete(vfd, relative_name, relative_name_len);
    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
	// if we can't find file in the master disk, the file/dir
	// must have already been delete. Just return success, since
	// we are trying to remove this file anyway.
	err = STATUS_SUCCESS;
    }


    FsLogUndo(("fs_undo_create: status %x\n", err));

    return err;
}


NTSTATUS
fs_undo_setattr(VolInfo_t *volinfo,
		fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE mvfd = FS_GET_VOL_HANDLE(volinfo, mid);
    WCHAR	name[MAXPATH];
    int		name_len;
    

    name[0] = '\0';

    FsLogUndo(("fs_undo_setattr: try %I64x:%I64x\n",
		  lrec->fs_id[0], lrec->fs_id[1]));

    err = xFsGetPathById(mvfd, &lrec->fs_id, name, &name_len);

    if (err == STATUS_SUCCESS) {
	int relative_name_len;
	LPWSTR relative_name;
	HANDLE fd;
	FILE_NETWORK_OPEN_INFORMATION attr;
	FILE_BASIC_INFORMATION new_attr;

	// build relative name and get current attribute from
	// master disk and apply it to 'nid' disk
	relative_name = xFsBuildRelativePath(volinfo, mid, name);
	relative_name_len = wcslen(relative_name);

	err = xFsQueryAttrName(mvfd, relative_name, relative_name_len,
			       &attr);

	if (err == STATUS_SUCCESS) {
	    // we now apply attribute to nid disk
	    err = xFsOpenWA(&fd, vfd, relative_name, relative_name_len);
	    if (err == STATUS_SUCCESS) {

		new_attr.CreationTime = attr.CreationTime;
		new_attr.LastAccessTime = attr.LastAccessTime;
		new_attr.LastWriteTime = attr.LastWriteTime;
		new_attr.ChangeTime = attr.ChangeTime;
		new_attr.FileAttributes = attr.FileAttributes;
		err = xFsSetAttr(fd, &new_attr);
		xFsClose(fd);
	    }
	}

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
	// if we can't find file in the master disk, the file/dir
	// must have already been delete. Just return success, since
	// we will get to remove this dir/file anyway during the
	// replay phase
	err = STATUS_SUCCESS;
    }

    FsLogUndo(("fs_undo_setattr: status %x\n", err));

    return err;
}

NTSTATUS
fs_undo_mkdir(VolInfo_t *volinfo,
		 fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR name[MAXPATH];
    int name_len = sizeof(name);

    name[0] = '\0';

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogUndo(("fs_undo_mkdir: try %I64x:%I64x\n",
		  lrec->id[0], lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_len);

    if (err == STATUS_SUCCESS) {
	int relative_name_len;
	WCHAR *relative_name;

	relative_name = xFsBuildRelativePath(volinfo, nid, name);
	relative_name_len = wcslen(relative_name);

	err = xFsDelete(vfd, relative_name, relative_name_len);
    }

    FsLogUndo(("fs_undo_mkdir: status %x\n", err));

    return err;
}

NTSTATUS
fs_undo_remove(VolInfo_t *volinfo,
	       fs_log_rec_t *lrec, int nid, int mid)

{

    // we need to recreate the file with same name and attributes.
    // if file is not a directory, we also need to copy data
    // from master disk to nid disk
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE mvfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR	name[MAXPATH];
    int		name_len;
    

    name[0] = '\0';
    FsLogUndo(("fs_undo_remove: try %I64x:%I64x\n",
		  lrec->fs_id[0], lrec->fs_id[1]));

    err = xFsGetPathById(mvfd, &lrec->fs_id, name, &name_len);

    if (err == STATUS_SUCCESS) {
	int relative_name_len;
	WCHAR *relative_name;

	// build relative name
	relative_name = xFsBuildRelativePath(volinfo, mid, name);
	relative_name_len = wcslen(relative_name);

	// duplicate file or dir
	err = xFsDupFile(mvfd, vfd, relative_name, relative_name_len, FALSE);

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
	// if we can't find file in the master disk, the file/dir
	// must have already been delete. 
	err = STATUS_SUCCESS;
    }

    FsLogUndo(("fs_undo_remove: status %x\n", err));

    return err;

}

NTSTATUS
fs_undo_rename(VolInfo_t *volinfo,
	       fs_log_rec_t *lrec, int nid, int mid)

{
    // we need to recreate the file with same name and attributes.
    // if file is not a directory, we also need to copy data
    // from master disk to nid disk
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE mvfd = FS_GET_VOL_HANDLE(volinfo, mid);
    WCHAR	name[MAXPATH];
    int		name_len;
    

    name[0] = '\0';
    FsLogUndo(("fs_undo_rename: try %I64x:%I64x\n",
		  lrec->fs_id[0], lrec->fs_id[1]));

    err = xFsGetPathById(mvfd, &lrec->fs_id, name, &name_len);

    if (err == STATUS_SUCCESS) {
	int relative_name_len;
	WCHAR *relative_name;
	HANDLE fd;

	// build relative name and get current attribute from
	// master disk
	relative_name = xFsBuildRelativePath(volinfo, mid, name);
	relative_name_len = wcslen(relative_name);

	// we open the file on the nid disk
	err = xFsGetHandleById(vfd, &lrec->fs_id, FILE_GENERIC_WRITE, &fd);
	if (err == STATUS_SUCCESS) {
	    err = xFsRename(fd, vfd, relative_name, relative_name_len);
	}

	xFsClose(fd);

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
	// if we can't find file in the master disk, the file/dir
	// must have already been delete. 
	err = STATUS_SUCCESS;
    }

    FsLogUndo(("fs_undo_rename: status %x\n", err));

    return err;

}

NTSTATUS
fs_undo_write(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    HANDLE shdl = INVALID_HANDLE_VALUE;
    HANDLE dhdl = INVALID_HANDLE_VALUE;
    WCHAR *buf = NULL;
    HANDLE	vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE	mvfd = FS_GET_VOL_HANDLE(volinfo, mid);


    FsLogUndo(("fs_undo_write: %I64x:%I64x\n", lrec->fs_id[0],
		  lrec->fs_id[1]));

    // get the master file
    err = xFsGetHandleById(mvfd, &lrec->fs_id, FILE_GENERIC_READ, &shdl);

    if (err == STATUS_SUCCESS) {
	ULONG sz = 0;
	LARGE_INTEGER off;

	// get nid disk file
	err = xFsGetHandleById(vfd, &lrec->fs_id, FILE_GENERIC_WRITE, &dhdl);
	if (err != STATUS_SUCCESS) {
	    // this is a very bad error, must abort now
	    FsLogUndo(("Aborting replay_write err %x\n", err));
	    err = STATUS_TRANSACTION_ABORTED;
	    goto done;
	}


	// we need to read the new data from the sfd first
	if (lrec->length > 0) {
	    // allocate buf
	    buf = VirtualAlloc(NULL, lrec->length, MEM_RESERVE|MEM_COMMIT,
			       PAGE_READWRITE);

	    if (buf == NULL) {
		FsLogError(("Unable to allocate write buffer to replay\n"));
		err = STATUS_TRANSACTION_ABORTED;
		goto done;
	    }


	    off.LowPart = lrec->offset;
	    off.HighPart = 0;

	    // read local data. todo: what if the file is locked? 
	    err = NtReadFile(shdl, NULL, NULL, NULL, &ios, buf,
			     lrec->length, &off, NULL);

	    if (err == STATUS_PENDING) {
		EventWait(shdl);
	    }

	    if (ios.Status != STATUS_SUCCESS) {
		FsLogUndo(("Read failed for replay %x\n", ios.Status));
		err = STATUS_TRANSACTION_ABORTED;
		goto done;
	    }
	} else {
	    buf = NULL;
	    ios.Information = 0;
	}
			
	sz = (ULONG) ios.Information;
	off.LowPart = lrec->offset;
	off.HighPart = 0;
	if (sz > 0) {
	    err = NtWriteFile(dhdl, NULL, NULL, (PVOID) NULL,
			      &ios, buf, sz, &off, NULL);
	} else {
	    FILE_END_OF_FILE_INFORMATION x;

	    x.EndOfFile = off;

	    err = NtSetInformationFile(dhdl, &ios,
				       (char *) &x, sizeof(x),
				       FileEndOfFileInformation);

	}
	if (err == STATUS_PENDING) {
	    EventWait(dhdl);
	    err = ios.Status;
	}
	sz = (ULONG) ios.Information;

	// check if we have the same size, otherwise abort
	if (sz != lrec->length) {
	    FsLogError(("Write sz mismatch, %d expected %d\n", sz, lrec->length));
	    err = STATUS_TRANSACTION_ABORTED;
	}

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
	// if we can't find file in the master disk, the file/dir
	// must have already been delete. 
	err = STATUS_SUCCESS;
    }

 done:
    if (buf != NULL) {
	VirtualFree(buf, 0, MEM_DECOMMIT|MEM_RELEASE);
    }

    if (shdl != INVALID_HANDLE_VALUE)
	xFsClose(shdl);

    if (dhdl != INVALID_HANDLE_VALUE)
	xFsClose(dhdl);

    FsLogUndo(("Undo write offset %d len %d err %x\n", 
		 lrec->offset, lrec->length, err));

    return err;
}

FsReplayHandler_t FsUndoCallTable[] = {
    fs_undo_create,
    fs_undo_setattr,
    fs_undo_write,
    fs_undo_mkdir,
    fs_undo_remove,
    fs_undo_rename
};

NTSTATUS
FsUndoXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid)
{
    fs_log_rec_t	*p = (fs_log_rec_t *) arg;
    NTSTATUS		err;
    fs_id_t		*fs_id;
    HANDLE		vhdl;

    vhdl = FS_GET_VOL_HANDLE(volinfo, mid);
    if (vhdl == INVALID_HANDLE_VALUE) {
	FsLogUndo(("FsUndoXid Failed to get crs handle %d\n",
		     mid));
	return STATUS_TRANSACTION_ABORTED;
    }

    vhdl = FS_GET_VOL_HANDLE(volinfo, nid);
    if (vhdl == INVALID_HANDLE_VALUE) {
	FsLogUndo(("FsUndoXid Failed to get crs handle %d\n", nid));
	return STATUS_TRANSACTION_ABORTED;
    }

    fs_id = &p->fs_id;

    FsLogUndo(("Undo action %d nid %d objid %I64x:%I64x\n", p->command,
	       nid,
	       (*fs_id)[0], (*fs_id)[1]));

    err = FsUndoCallTable[p->command](volinfo, p, nid, mid);

    FsLogUndo(("Undo Status %x\n", err));

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\ndquorum\standalone\main.c ===
#define UNICODE
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "fsp.h"
#include "fsutil.h"

extern
DWORD
FindTransport(LPWSTR TransportId, LPWSTR *Transport);

extern
DWORD
SetupTree(
    IN LPTSTR TreeName,
    IN LPTSTR DlBuf,
    IN OUT DWORD *DlBufSz,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SecurityDescriptor OPTIONAL
    );

HANDLE event;
int Done = FALSE;

BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
{
    switch(dwCtrlType) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
	Done = TRUE;
	SetEvent(event);
        return TRUE;
    default:
        return FALSE;
    }
}


_cdecl
main(int argc, char *argv[])
{
    int cnt;
    char cmd[80];
    DWORD err;
    WCHAR *share = L"root";
    HANDLE hdl;
    PVOID srvhdl, fshdl;
    PVOID fid;
    extern BOOLEAN FsReadOnly;
    WCHAR   *wargv[FsMaxNodes], *tmp[FsMaxNodes];
    int i, mask;
    LPWSTR	tid;
    WCHAR	localname[MAX_COMPUTERNAME_LENGTH + 20];
    DWORD	now;

    now = GetTickCount();

    wcscpy(localname,L"\\\\");
    err = sizeof(localname);
    if (GetComputerName(&localname[wcslen(localname)], &err) == FALSE) {
	return GetLastError();
    }

    wcscat(localname,L"$QFS\\");
    wcscat(localname,share);

    if (argc < 2) {
	printf("Usage %s: disk1 disk2 ... diskN\n", argv[0]);
	return 0;
    }

    tid = NULL;
    err = FindTransport(L"NetBT_Tcpip", &tid);
    if (err != ERROR_SUCCESS) {
	printf("Unable to find transport to bind1 %d\n", err);
	return 0;
    }

    memset(wargv, 0, sizeof(wargv));
    wargv[0] = NULL;
    for (i = 1; i < argc; i++) {
	int j;
	wargv[i] = (WCHAR *) malloc((strlen(argv[i])+1) * sizeof(WCHAR));
	j = mbstowcs(wargv[i], argv[i], strlen(argv[i]));
	wargv[i][j] = L'\0';
    }

    FsReadOnly = TRUE;
    err = FsInit(NULL, &fshdl);
    if (err != STATUS_SUCCESS) {
	printf("Unable to init filesystem %d\n", err);
	return 0;
    }

    err = SrvInit(NULL, fshdl, &srvhdl);
    if (err != STATUS_SUCCESS) {
	printf("Unable to init server %d\n", err);
	return 0;
    }

    err = FsRegister(fshdl, share, wargv[1], wargv, argc-1, &fid);
    if (err != STATUS_SUCCESS) {
	printf("Unable to register share %d\n", err);
	return 0;
    }

 regain:
    // arb
    event = CreateEvent(NULL, FALSE, FALSE, NULL);
    err = FsArbitrate(fid, event, &hdl);

    if (err == ERROR_IO_PENDING || err == ERROR_PATH_BUSY) {
	HANDLE	a[2];

	a[0] = hdl;
	a[1] = event;

	err = WaitForMultipleObjects(2, a, FALSE, 45 * 1000);
	if (err != WAIT_TIMEOUT) {
	    // check if we got it or not
	    err = FsIsQuorum(fid);
	} else {
	    // our time ran out, cancel it now
	    printf("Arb timedout\n");
	    FsCancelArbitration(fid);
	    err = ERROR_CANCELLED;
	}
    }

    if (err != ERROR_SUCCESS) {
	printf("Arbitration failed %d\n", err); Sleep(5*1000);
	goto regain;
	return 1;
    }

    printf("Arb in %d msec\n", GetTickCount() - now);

    {
	HANDLE	fd;

	sprintf(cmd, "\\\\?\\%s\\foo.txt", argv[1]);
	fd = CreateFileA(cmd, GENERIC_READ|GENERIC_WRITE,
			FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL);
	if (fd == INVALID_HANDLE_VALUE) {
	    printf("Open failed %d\n", GetLastError());
	}
    }
    // online filesystem before onlining its network name
    while (FsIsOnline(fid) == ERROR_IO_PENDING)
	Sleep(1*1000);

    // online
    err = SrvOnline(srvhdl, NULL, 0);
    if (err != ERROR_SUCCESS) {
	printf("Srv Online failed %d\n", err);
	return 1;
    }


    // Now we need to connect tree
 retry:
//    err = SetupTree(localname, NULL, NULL, tid, NULL);
    if (err != ERROR_SUCCESS) {
	printf("Unable to setup tree '%S' %d\n", localname, err);
	if (err == ERROR_PATH_NOT_FOUND) {
	    Sleep(1000 * 2);
	    goto retry;
	}
	return err;
    }

    SetConsoleCtrlHandler(HandlerRoutine, TRUE);
    printf("Server is up.\n");
    mask = 0x2;
    while (Done == FALSE) {
	int cnt;
	if (FsReserve(fid) != ERROR_SUCCESS) {
	    printf("Lost reservation!\n");
	    break;
	}
	err = FsIsOnline(fid);
	if ( err != ERROR_SUCCESS && err != ERROR_IO_PENDING) {
	    printf("Fs offlined %d!\n", err);
	}

	// Every 5 seconds change replica set
	WaitForSingleObject(event, 5 * 1000);
#if 0
	memset(tmp, 0, sizeof(tmp));
	cnt = 0;
	for (i = 1; i < argc; i++) {
	    if (mask & (1 << i)) {
		cnt++;
		printf("New replica %d '%S'\n", i, wargv[i]);
		tmp[i] = wargv[i];
	    }
	}
	printf("Changing set %x size %d\n", mask, cnt);
	FsUpdateReplicaSet(fid, tmp, cnt);
	mask += 2;
	if (cnt >= (argc - 1)) {
	    mask = 2;
	}
#endif
    }
    printf("Exiting...\n");

    // offline
    SrvOffline(srvhdl);

    // release
    FsRelease(fid);

    SrvExit(srvhdl);
    FsExit(fshdl);
    return 0;
}

#include <stdlib.h>
#include <stdarg.h>

void
debug_log(char *format, ...)
{
    va_list marker;

    va_start(marker, format);

    printf("%d:%x:",GetTickCount(), GetCurrentThreadId());
    vprintf(format, marker);

    va_end(marker);

}

void
error_log(char *format, ...)
{
    va_list marker;

    va_start(marker, format);

    printf("*E %d:%x:",GetTickCount(), GetCurrentThreadId());
    vprintf(format, marker);

    va_end(marker);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\compobj.cpp ===
/*++

Copyright (c) 2000, 2001  Microsoft Corporation

Module Name:

    compobj.cpp

Abstract:

    routines for backing computer object support

Author:

    Charlie Wickham (charlwi) 14-Dec-2000

Environment:

    User Mode

Revision History:

--*/

#define UNICODE         1
#define _UNICODE        1
#define LDAP_UNICODE    1

extern "C" {
#include "clusres.h"
#include "clusrtl.h"

#include <winsock2.h>

#include <lm.h>
#include <lmaccess.h>

#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <ntdsapi.h>
#include <sddl.h>

#include <objbase.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>

#include "netname.h"
#include "nameutil.h"
}

//
// Constants
//

#define LOG_CURRENT_MODULE LOG_MODULE_NETNAME

/* External */
extern PLOG_EVENT_ROUTINE   NetNameLogEvent;

extern "C" {
DWORD
EncryptNetNameData(
    RESOURCE_HANDLE ResourceHandle,
    LPWSTR          MachinePwd,
    PBYTE *         EncryptedData,
    PDWORD          EncryptedDataLength,
    HKEY            Key
    );

DWORD
DecryptNetNameData(
    RESOURCE_HANDLE ResourceHandle,
    PBYTE           EncryptedData,
    DWORD           EncryptedDataLength,
    LPWSTR          MachinePwd
    );
}

//
// static data
//
static WCHAR    LdapHeader[] = L"LDAP://";

//
// forward references
//

HRESULT
GetComputerObjectViaFQDN(
    IN     LPWSTR               DistinguishedName,
    IN     LPWSTR               DCName              OPTIONAL,
    IN OUT IDirectoryObject **  ComputerObject
    );

//
// private routines
//

DWORD
GenerateRandomBytes(
    PWSTR   Buffer,
    DWORD   BufferLength
    )

/*++

Routine Description:

    Generate random bytes for a password. Length is specified in characters
    and allows room for the trailing null.

Arguments:

    Buffer - pointer to area to receive random data

    BufferLength - size of Buffer in characters

Return Value:

    ERROR_SUCCESS otherwise GetLastError()

--*/

{
    HCRYPTPROV  cryptProvider;
    DWORD       status = ERROR_SUCCESS;
    DWORD       charLength = BufferLength - 1;
    DWORD       byteLength = charLength * sizeof( WCHAR );
    BOOL        success;

    if ( !CryptAcquireContext(&cryptProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT
                              )) {
        return GetLastError();
    }

    //
    // leave room for the terminating null
    //
    if (CryptGenRandom( cryptProvider, byteLength, (BYTE *)Buffer )) {

        //
        // run down the array as WCHARs to make sure there is no premature
        // terminating NULL
        //
        PWCHAR  pw = Buffer;

        while ( charLength-- ) {
            if ( *pw == UNICODE_NULL ) {
                *pw = 0xA3F5;
            }
            ++pw;
        }

        *pw = UNICODE_NULL;
    } else {
        status = GetLastError();
    }

    success = CryptReleaseContext( cryptProvider, 0 );
    ASSERT( success );

    return status;
} // GenerateRandomBytes

DWORD
FindDomainForServer(
    IN  PWSTR                       Server,
    OUT PDOMAIN_CONTROLLER_INFO *   DCInfo
    )

/*++

Routine Description:

    get the name of a DC for our node

Arguments:

    ServerName - pointer to string containing server (i.e., node) name

    DCInfo - address of a pointer that receives a pointer to DC information

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error. If successful, caller must
    free DCInfo buffer.

--*/

{
    ULONG                       status;
    WCHAR                       localServerName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    PDOMAIN_CONTROLLER_INFOW    dcInfo;
    DWORD                       dsFlags;

    //
    // MAX_COMPUTERNAME_LENGTH is defined to be 15 but I could create computer
    // objects with name lengths of up to 20 chars. Not sure why the
    // discrepenacy but we'll leave ourselves extra room by using the DNS
    // constants
    //
    wcsncpy( localServerName, Server, DNS_MAX_LABEL_LENGTH - 1 );
    wcscat( localServerName, L"$" );

    //
    // specifying that a writable DS is required makes us home in on a W2K DC
    // (as opposed to an NT4 PDC). Writable is needed since we always reset
    // the password to what is stored in the cluster registry.
    //
    dsFlags = DS_DIRECTORY_SERVICE_REQUIRED |
        DS_RETURN_DNS_NAME                  |
        DS_WRITABLE_REQUIRED;

    status = DsGetDcNameWithAccountW(NULL,
                                     localServerName,
                                     UF_MACHINE_ACCOUNT_MASK,
                                     L"",
                                     NULL,
                                     NULL,
                                     dsFlags,
                                     &dcInfo );

    if ( status == ERROR_NO_SUCH_DOMAIN ) {
        //
        // try again with rediscovery
        //
        dsFlags |= DS_FORCE_REDISCOVERY;

        status = DsGetDcNameWithAccountW(NULL,
                                         localServerName,
                                         UF_MACHINE_ACCOUNT_MASK,
                                         L"",
                                         NULL,
                                         NULL,
                                         dsFlags,
                                         &dcInfo );
    }

    if ( status == DS_S_SUCCESS ) {
        *DCInfo = dcInfo;
    } 

    return status;
} // FindDomainForServer

AddDnsHostNameAttribute(
    RESOURCE_HANDLE     ResourceHandle,
    IDirectoryObject *  CompObj,
    PWCHAR              VirtualName,
    PWCHAR              DnsDomain
    )

/*++

Routine Description:

    add the DnsHostName attribute to the computer object for the specified
    virtual name.

Arguments:

    ResourceHandle - used to log in cluster log

    CompObj - IDirObj COM pointer to object

    VirtualName - network name

    DnsDomain - DNS suffix for this name

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    HRESULT hr;
    DWORD   numberModified;

    ADSVALUE        attrValue;
    WCHAR           FQDnsName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    ADS_ATTR_INFO   attrInfo;

    //
    // build the FQ Dns name for this host
    //
    _snwprintf( FQDnsName, COUNT_OF( FQDnsName ) - 1, L"%ws.%ws", VirtualName, DnsDomain );

    attrValue.dwType =              ADSTYPE_CASE_IGNORE_STRING;
    attrValue.CaseIgnoreString =    FQDnsName;

    attrInfo.pszAttrName =      L"DnsHostName";
    attrInfo.dwControlCode =    ADS_ATTR_UPDATE;
    attrInfo.dwADsType =        ADSTYPE_CASE_IGNORE_STRING;
    attrInfo.pADsValues =       &attrValue;
    attrInfo.dwNumValues =      1;

    hr = CompObj->SetObjectAttributes( &attrInfo, 1, &numberModified );
    if ( SUCCEEDED( hr ) && numberModified != 1 ) {
        //
        // don't know why this scenario would happen but we'd better log
        // it since it is unusual
        //
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"SetObjectAttributes succeeded but NumberModified is zero!\n");

        hr = E_ADS_PROPERTY_NOT_SET;
    }

    return hr;
} // AddDnsHostNameAttribute

DWORD
AddServicePrincipalNames(
    HANDLE  DsHandle,
    PWCHAR  VirtualFQDN,
    PWCHAR  VirtualName,
    PWCHAR  DnsDomain
    )

/*++

Routine Description:

    add the DNS and Netbios host service principal names to the specified
    virtual name

Arguments:

    DsHandle - handle obtained from DsBind

    VirtualFQDN - distinguished name of computer object for the virtual netname

    VirtualName - the network name to be added

    DnsDomain - the DNS domain used to construct the DNS SPN

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    WCHAR   netbiosSpn[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    WCHAR   dnsSpn[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   status;
    PWSTR   spnArray[2] = { netbiosSpn, dnsSpn };
    DWORD   spnCount = COUNT_OF( spnArray );

    //
    // build the Host SPNs for netbios and DNS name variants
    //
    _snwprintf( netbiosSpn, COUNT_OF( netbiosSpn ) - 1, L"HOST/%ws", VirtualName );
    _snwprintf( dnsSpn, COUNT_OF( dnsSpn ) - 1, L"HOST/%ws.%ws", VirtualName, DnsDomain );

    //
    // write the SPNs to the DS
    //

    status = DsWriteAccountSpnW(DsHandle,
                                DS_SPN_ADD_SPN_OP,
                                VirtualFQDN,
                                spnCount,
                                (LPCWSTR *)spnArray);

    return status;
} // AddServicePrincipalNames

DWORD
SetACLOnParametersKey(
    HKEY    ParametersKey
    )

/*++

Routine Description:

    Set the ACL on the params key to allow only admin group and creator/owner
    to have access to the data

Arguments:

    ParametersKey - cluster HKEY to the netname's params key

Return Value:

    ERROR_SUCCESS if successful

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    success;

    PSECURITY_DESCRIPTOR    secDesc = NULL;

    //
    // build an SD the quick way. This gives builtin admins (local admins's
    // group), creator/owner and the service SID full access to the
    // key. Inheritance is prevented in both directions, i.e., doesn't inherit
    // from its parent nor passes the settings onto its children (of which the
    // node parameters keys are the only children).
    //
    success = ConvertStringSecurityDescriptorToSecurityDescriptor(
                  L"D:P(A;;KA;;;BA)(A;;KA;;;CO)(A;;KA;;;SU)",
                  SDDL_REVISION_1,
                  &secDesc,
                  NULL);

    if ( success  &&
         (secDesc != NULL) ) {
        status = ClusterRegSetKeySecurity(ParametersKey,
                                          DACL_SECURITY_INFORMATION,
                                          secDesc);
        LocalFree( secDesc );
    }
    else {
        if ( secDesc != NULL )
        {
            LocalFree( secDesc );
            status = GetLastError();
        }
    }

    return status;
} // SetACLOnParametersKey


DWORD
GetFQDN(
    IN     RESOURCE_HANDLE  ResourceHandle,
    IN     LPWSTR           NodeName,
    IN     LPWSTR           VirtualName,
    IN     HANDLE           DsHandle            OPTIONAL,
    IN     LPWSTR           NTDomainName        OPTIONAL,
    OUT    LPWSTR *         FQDistinguishedName
    )

/*++

Routine Description:

    for the given DNS name, find the DS distinguished name, dup it and return
    the dup'ed string in FQDistinguishedName

Arguments:

    None

Return Value:

    None

--*/

{
    PWCHAR  dot;
    WCHAR   flatName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    LPWSTR  flat = flatName;
    HANDLE  dsHandle = NULL;
    DWORD   status;
    LPWSTR  ntDomainName;
    BOOL    firstTime = TRUE;

    PDS_NAME_RESULTW    nameResult = NULL;
    DS_NAME_FLAGS       dsFlags = DS_NAME_NO_FLAGS;

    PDOMAIN_CONTROLLER_INFO dcInfo = NULL;

    //
    // if no DS handle was specified, go get one now
    //
    if ( DsHandle == NULL ) {

        //
        // get the name of a DC
        //
        status = FindDomainForServer( NodeName, &dcInfo );

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Unable to get domain information for node %1!ws!: %2!u!.\n",
                              NodeName,
                              status);
            return status;
        }

        (NetNameLogEvent)(ResourceHandle,
                          LOG_INFORMATION,
                          L"GetFQDN: Binding to domain controller %1!ws!.\n",
                          dcInfo->DomainControllerName);

        status = DsBindW( dcInfo->DomainControllerName, NULL, &dsHandle );
        if ( status != NO_ERROR ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Failed to bind to a DC in domain %1!ws!, status %2!u!\n", 
                              dcInfo->DomainName,
                              status );

            NetApiBufferFree( dcInfo );
            return status;
        }

        ntDomainName = dcInfo->DomainName;
    }
    else {
        dsHandle = DsHandle;
        ntDomainName = NTDomainName;
    }

    //
    // build a SAM style name (domain\node$) in flatName and "crack" it for
    // its FQDN (LDAP distinguished name)
    //
    wcsncpy( flatName, ntDomainName, DNS_MAX_NAME_BUFFER_LENGTH );
    flatName[ DNS_MAX_NAME_BUFFER_LENGTH - 1 ] = UNICODE_NULL;
    dot = wcschr( flatName, L'.' );
    if ( dot ) {
        *dot = UNICODE_NULL;
    }

    wcscat( flatName, L"\\" );
    wcscat( flatName, VirtualName );
    wcscat( flatName, L"$" );

retry:
    status = DsCrackNamesW(dsHandle,
                           dsFlags,
                           DS_NT4_ACCOUNT_NAME,
                           DS_FQDN_1779_NAME,
                           1,
                           &flat,
                           &nameResult );

    //
    // CrackNames must succeed, there should only be one name, and the status
    // associated with the name result should be ok. If it doesn't work the
    // first time, force a trip to the DC to find the object's DN.
    //
    if ( status != DS_NAME_NO_ERROR ) {
        if ( firstTime ) {
            firstTime = FALSE;
            dsFlags = DS_NAME_FLAG_EVAL_AT_DC;

            if ( nameResult != NULL ) {
                DsFreeNameResult( nameResult );
            }
            goto retry;
        }
        else {
            goto cleanup;
        }
    }

    if ( nameResult->cItems != 1 ) {
        status = DS_NAME_ERROR_NOT_UNIQUE;
        goto cleanup;
    }

    if ( nameResult->rItems[0].status != DS_NAME_NO_ERROR ) {
        if ( firstTime ) {
            firstTime = FALSE;
            dsFlags = DS_NAME_FLAG_EVAL_AT_DC;

            if ( nameResult != NULL ) {
                DsFreeNameResult( nameResult );
            }
            goto retry;
        }
        else {
            status = nameResult->rItems[0].status;
            goto cleanup;
        }
    }

    if ( status == DS_NAME_NO_ERROR ) {
        *FQDistinguishedName = ResUtilDupString( nameResult->rItems[0].pName );
        if ( *FQDistinguishedName == NULL ) {
            status = GetLastError();
        }
    }

cleanup:

    if ( DsHandle == NULL ) {
        NetApiBufferFree( dcInfo );
        DsUnBind( &dsHandle );
    }

    if ( nameResult != NULL ) {
        DsFreeNameResult( nameResult );
    }

    return status;
} // GetFQDN

HRESULT
GetComputerObjectViaFQDN(
    IN     LPWSTR               DistinguishedName,
    IN     LPWSTR               DCName              OPTIONAL,
    IN OUT IDirectoryObject **  ComputerObject
    )

/*++

Routine Description:

    for the specified distinguished name, get an IDirectoryObject pointer to
    it

Arguments:

    DistinguishedName - FQDN of object in DS to find

    DCName - optional pointer to name of DC (not domain) that we should bind to

    ComputerObject - address of pointer that receives pointer to computer object

Return Value:

    success if everything worked, otherwise....

--*/

{
    WCHAR   buffer[ 256 ];
    PWCHAR  bindingString = buffer;
    LONG    charCount;
    HRESULT hr;
    DWORD   dnLength;

    //
    // format an LDAP binding string for our distingiushed name. If DCName is
    // specified, we need to add a trailing "/".
    //
    dnLength =  (DWORD)( COUNT_OF( LdapHeader ) + wcslen( DistinguishedName ));
    if ( DCName != NULL ) {
        dnLength += wcslen( DCName );
    }

    if ( dnLength > COUNT_OF( buffer )) {
        bindingString = (PWCHAR)HeapAlloc( GetProcessHeap(), 0, dnLength * sizeof( WCHAR ));
        if ( bindingString == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy( bindingString, LdapHeader );
    if ( DCName != NULL ) {
        wcscat( bindingString, DCName );
        wcscat( bindingString, L"/" );
    }
    wcscat( bindingString, DistinguishedName );

    *ComputerObject = NULL;
    hr = ADsGetObject( bindingString, IID_IDirectoryObject, (VOID **)ComputerObject );

    if ( bindingString != buffer ) {
        HeapFree( GetProcessHeap(), 0, bindingString );
    }

    if ( FAILED( hr ) && *ComputerObject != NULL ) {
        (*ComputerObject)->Release();
    }

    return hr;
} // GetComputerObjectViaFQDN

HRESULT
GetComputerObjectViaGUID(
    IN     LPWSTR               ObjectGUID,
    IN     LPWSTR               DCName              OPTIONAL,
    IN OUT IDirectoryObject **  ComputerObject
    )

/*++

Routine Description:

    for the specified object GUID, get an IDirectoryObject pointer to it

Arguments:

    ObjectGUID - GUID of object in DS to find

    DCName - optional pointer to name of DC (not domain) that we should bind to

    ComputerObject - address of pointer that receives pointer to computer object

Return Value:

    success if everything worked, otherwise....

--*/

{
    WCHAR   ldapGuidHeader[] = L"LDAP://<GUID=";
    WCHAR   ldapTrailer[] = L">";
    LONG    charCount;
    HRESULT hr;
    DWORD   dnLength;

    //
    // 37 = guid length 
    //
    WCHAR   buffer[ COUNT_OF( ldapGuidHeader) + DNS_MAX_NAME_BUFFER_LENGTH + 37 + COUNT_OF( ldapTrailer) ];
    PWCHAR  bindingString = buffer;

    //
    // format an LDAP binding string for the object GUID. If DCName is
    // specified, we need to add a trailing / plus the trailing null.
    //
    ASSERT( ObjectGUID != NULL );
    dnLength =  (DWORD)( COUNT_OF( ldapGuidHeader ) + COUNT_OF( ldapTrailer ) + wcslen( ObjectGUID ));
    if ( DCName != NULL ) {
        dnLength += wcslen( DCName );
    }

    if ( dnLength > COUNT_OF( buffer )) {
        bindingString = (PWCHAR)HeapAlloc( GetProcessHeap(), 0, dnLength * sizeof( WCHAR ));
        if ( bindingString == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy( bindingString, ldapGuidHeader );
    if ( DCName != NULL ) {
        wcscat( bindingString, DCName );
        wcscat( bindingString, L"/" );
    }
    wcscat( bindingString, ObjectGUID );
    wcscat( bindingString, ldapTrailer );

    *ComputerObject = NULL;
    hr = ADsGetObject( bindingString, IID_IDirectoryObject, (VOID **)ComputerObject );

    if ( bindingString != buffer ) {
        HeapFree( GetProcessHeap(), 0, bindingString );
    }

    if ( FAILED( hr ) && *ComputerObject != NULL ) {
        (*ComputerObject)->Release();
    }

    return hr;
} // GetComputerObjectViaGUID

//
// exported routines
//

DWORD
NetNameDeleteComputerObject(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    delete the computer object in the DS for this name.

    Not called right now since we don't have the virtual netname at this point
    in time. The name must be kept around and cleaned during close processing
    instead of offline where it is done now. This means dealing with renaming
    issues while it is offline but not getting deleted.

Arguments:

    ResourceHandle - for logging cluster log events

    VirtualName - pointer to buffer holding virtual name to be deleted

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    DWORD   status;
    WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    HKEY    resourceKey = Resource->ResKey;
    PWSTR   virtualName = Resource->Params.NetworkName;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    PDOMAIN_CONTROLLER_INFO dcInfo;

    //
    // get the name of a DC
    //
    status = FindDomainForServer( Resource->NodeName, &dcInfo );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to get domain information: %1!u!.\n",
                          status);
        return status;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Using domain controller %1!ws! to delete computer account.\n",
                      dcInfo->DomainControllerName);

    //
    // add a $ to the end of the name
    //
    _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", virtualName );

    status = NetUserDel( dcInfo->DomainControllerName, virtualDollarName );
    if ( status == NERR_Success ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Deleted computer account %1!ws! in domain %2!ws!.\n",
                          virtualName,
                          dcInfo->DomainName);

        ClusResLogSystemEventByKey1(resourceKey,
                                    LOG_NOISE,
                                    RES_NETNAME_COMPUTER_ACCOUNT_DELETED,
                                    dcInfo->DomainName);

        LocalFree( Resource->ObjectGUID );
        Resource->ObjectGUID = NULL;
    } else {
        LPWSTR  msgBuff;
        DWORD   msgBytes;

        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Unable to delete computer account for %1!ws! in domain %2!ws!, status %3!u!.\n",
                          virtualName,
                          dcInfo->DomainName,
                          status);

        msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 status,
                                 0,
                                 (LPWSTR)&msgBuff,
                                 0,
                                 NULL);

        if ( msgBytes > 0 ) {

            ClusResLogSystemEventByKey2(resourceKey,
                                        LOG_UNUSUAL,
                                        RES_NETNAME_DELETE_COMPUTER_ACCOUNT_FAILED,
                                        dcInfo->DomainName,
                                        msgBuff);

            LocalFree( msgBuff );
        } else {
            ClusResLogSystemEventByKeyData1(resourceKey,
                                            LOG_UNUSUAL,
                                            RES_NETNAME_DELETE_COMPUTER_ACCOUNT_FAILED_STATUS,
                                            sizeof( status ),
                                            &status,
                                            dcInfo->DomainName);
        }
    }

    NetApiBufferFree( dcInfo );

    return status;
} // NetNameDeleteComputerObject

DWORD
NetNameAddComputerObject(
    IN  PCLUS_WORKER        Worker,
    IN  PNETNAME_RESOURCE   Resource,
    OUT PWCHAR *            MachinePwd
    )

/*++

Routine Description:

    Create a computer object in the DS that is primarily used for kerb
    authentication.

    Out of the box ACL on the computer container seems to let any
    authenticated user create a computer object; they can't delete it
    though. Also, authenticated users might have the "right to create computer
    objects" granted to them. This seems to allow the delete rights on the
    objects they create.

Arguments:

    Worker - cluster worker thread so we can abort early if asked to do so

    Resource - pointer to netname resource context block

    MachinePwd - address of pointer to receive pointer to machine account PWD

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    DWORD   status;
    PWSTR   virtualName = Resource->Params.NetworkName;
    DWORD   virtualNameSize = wcslen( virtualName );
    PWSTR   virtualFQDN = NULL;
    HANDLE  dsHandle = NULL;
    WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    PWCHAR  machinePwd = NULL;
    DWORD   pwdBufferByteLength = ((LM20_PWLEN + 1) * sizeof( WCHAR ));
    DWORD   pwdBufferCharLength = LM20_PWLEN + 1;
    DWORD   paramInError = 0;
    BOOL    deleteObjectOnFailure = FALSE;      // only delete the CO if we create it
    WCHAR   dnsSuffix[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   dnsSuffixSize;
    BOOL    success;
    DWORD   setValueStatus;

    HINSTANCE       hClusres;
    USER_INFO_1     netUI1;
    USER_INFO_1003  netUI1003;
    ULARGE_INTEGER  updateTime;

    RESOURCE_HANDLE     resourceHandle = Resource->ResourceHandle;
    IDirectoryObject *  compObj = NULL;

    PDOMAIN_CONTROLLER_INFO dcInfo;


    *MachinePwd = NULL;

    //
    // get DC related info
    //
    status = FindDomainForServer( Resource->NodeName, &dcInfo );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to get domain information to create computer account: %1!u!.\n",
                          status);
        return status;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Using domain controller %1!ws! to add or update computer account.\n",
                      dcInfo->DomainControllerName);

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    //
    // add a $ to the end of the name. I don't know why we need to do this;
    // computer accounts have always had a $ at the end.
    //
    _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", virtualName );

    //
    // get a buffer to hold the machine Pwd
    //
    machinePwd = (PWCHAR)HeapAlloc( GetProcessHeap(), 0, pwdBufferByteLength );
    if ( machinePwd == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to allocate memory for computer account data. status %1!u!.\n",
                          status);

        goto cleanup;
    }

    //
    // see if this object was created at some time in the past; if so, its
    // random property will be non-null
    //
    if ( Resource->Params.NetworkRandom == NULL ) {

        //
        // generate a random stream of bytes for the password
        //
        status = GenerateRandomBytes( machinePwd, pwdBufferCharLength );
        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to generate computer account data. status %1!u!.\n",
                              status);

            goto cleanup;
        }

        //
        // set the ACL on the parameters key to contain just the cluster
        // service account since we're about to store sensitive info in there.
        //
        status = SetACLOnParametersKey( Resource->ParametersKey );
        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to set ACL on parameters key. status %1!u!\n",
                              status );
            goto cleanup;
        }

        //
        // take our new password, encrypt it and store it in the cluster
        // registry
        //
        status = EncryptNetNameData(resourceHandle,
                                    machinePwd,
                                    &Resource->Params.NetworkRandom,
                                    &Resource->RandomSize,
                                    Resource->ParametersKey);

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to store computer account data. status %1!u!\n",
                              status );

            goto cleanup;
        }

        //
        // record when it is time to rotate the pwd; per MSDN, convert to
        // ULARGE Int and add in the update interval.
        //
        GetSystemTimeAsFileTime( &Resource->Params.NextUpdate );
        updateTime.LowPart = Resource->Params.NextUpdate.dwLowDateTime;
        updateTime.HighPart = Resource->Params.NextUpdate.dwHighDateTime;
        updateTime.QuadPart += ( Resource->Params.UpdateInterval * 60 * 1000 * 100 );
        Resource->Params.NextUpdate.dwLowDateTime = updateTime.LowPart;
        Resource->Params.NextUpdate.dwHighDateTime = updateTime.HighPart;

        setValueStatus = ResUtilSetBinaryValue(Resource->ParametersKey,
                                               PARAM_NAME__NEXT_UPDATE,
                                               (const LPBYTE)&updateTime,  
                                               sizeof( updateTime ),
                                               NULL,
                                               NULL);
        ASSERT( setValueStatus == ERROR_SUCCESS );
    }
    else {
        //
        // we have an encrypted blob which means that the object was created
        // at some point in time. Extract the password from the blob.
        //
        status = DecryptNetNameData(resourceHandle,
                                    Resource->Params.NetworkRandom,
                                    Resource->RandomSize,
                                    machinePwd);

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to decrypt computer account password. status %1!u!\n",
                              status );

            goto cleanup;
        }
    }

    //
    // update/create the computer object (machine account). Even though the
    // object might have been created by us in the past, it could have been
    // deleted and recreated at the DC or mangled in some other way. We'll
    // optimize for the case where it is left alone. If the object does exist,
    // our password on the SRV transport name and the object's password have
    // to be the same. We'll try NetUserSetInfo first to update the password
    // and test to see if the object exists. If we see that the object doesn't
    // exist, then we'll call NetUserAdd to create it.
    //
    // For some reason, Info level 1 fails with access denied when trying to
    // just update the password; possibly because it tries to set more than
    // just the password. 1003 works reliably when we create the computer
    // object.
    //
    netUI1003.usri1003_password   = (PWCHAR)machinePwd;
    status = NetUserSetInfo(dcInfo->DomainControllerName,
                            virtualDollarName,
                            1003,
                            (PBYTE)&netUI1003,
                            &paramInError );

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    if ( status != NERR_Success ) {

        if ( status == NERR_UserNotFound ) {

            RtlZeroMemory( &netUI1, sizeof( netUI1 ) );
            netUI1.usri1_password   = (PWCHAR)machinePwd;
            netUI1.usri1_priv       = USER_PRIV_USER;
            netUI1.usri1_name       = virtualDollarName;
            netUI1.usri1_flags      = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
            netUI1.usri1_comment    = NetNameCompObjAccountDesc;

            status = NetUserAdd( dcInfo->DomainControllerName, 1, (PBYTE)&netUI1, &paramInError );

            if ( status == NERR_Success ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_INFORMATION,
                                  L"Created computer account %1!ws! on DC %2!ws!.\n",
                                  virtualName,
                                  dcInfo->DomainControllerName);

                deleteObjectOnFailure = TRUE;
            } // if NetUserAdd was successful
            else {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to create computer account %1!ws! on DC %2!ws!, "
                                  L"status %3!u! (paramInfo: %4!u!)\n",
                                  virtualName,
                                  dcInfo->DomainControllerName,
                                  status,
                                  paramInError);

                goto cleanup;
            }

        } // if NetUserSetInfo didn't find the specified user
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to update password for computer account on DC %1!ws!, "
                              L"status %2!u!.\n",
                              dcInfo->DomainControllerName,
                              status);

            goto cleanup;
        }
    } // if NetUserSetInfo failed
    else {
        PUSER_INFO_20   netUI20;

        //
        // check if the account is disabled
        //
        status = NetUserGetInfo(dcInfo->DomainControllerName,
                                virtualDollarName,
                                20,
                                (LPBYTE *)&netUI20);

        if ( status == NERR_Success ) {
            if ( netUI20->usri20_flags & UF_ACCOUNTDISABLE ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Computer account for %1!ws! is disabled.\n",
                                  virtualName);

                status = ERROR_ACCOUNT_DISABLED;
            }

            NetApiBufferFree( netUI20 );

            if ( status != NERR_Success ) {
                goto cleanup;
            }
        } else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Failed to determine if computer account for %1!ws! is disabled. status %2!u!\n",
                              virtualName,
                              status);
        }
    }

    //
    // bind to the DS so we can write the DnsHostName and SPNs. We always
    // rewrite these since the things may have changed since the name was last
    // brought online.
    //
    status = DsBindW( dcInfo->DomainControllerName, NULL, &dsHandle );
    if ( status != NO_ERROR ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to bind to DC %1!ws! in domain %2!ws!, status %3!u!\n", 
                          dcInfo->DomainControllerName,
                          dcInfo->DomainName,
                          status );

        goto cleanup;
    }

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    //
    // get the LDAP distinguished name for this object; used temporarily to
    // set the DNS host attribute and SPNs on the account
    //
    status = GetFQDN(resourceHandle,
                     Resource->NodeName,
                     virtualName,
                     dsHandle,
                     dcInfo->DomainName,
                     &virtualFQDN );

    if ( status != DS_NAME_NO_ERROR ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to find distinguished name for %1!ws! on DC %2!ws!, "
                          L"status %3!u!\n",
                          virtualName,
                          dcInfo->DomainControllerName,
                          status );

        goto cleanup;
    }

    //
    // use the Object GUID for binding during CheckComputerObjectAttributes so
    // we don't have to track changes to the DN. If the object moved in the
    // DS, its DN will change but not its GUID. We use this code instead of
    // GetComputerObjectGuid because we want to target a specific DC.
    //
    {
        PWCHAR  dcName = dcInfo->DomainControllerName;
        IADs *  pADs = NULL;
        HRESULT hr;

        if ( *dcName == L'\\' && *(dcName+1) == L'\\' ) {
            //
            // skip over double backslashes
            //
            dcName += 2;
        }

        hr = GetComputerObjectViaFQDN( virtualFQDN, dcName, &compObj );
        if ( SUCCEEDED( hr )) {
            hr = compObj->QueryInterface(IID_IADs, (void**) &pADs);
            if ( SUCCEEDED( hr )) {
                BSTR    guidStr = NULL;

                hr = pADs->get_GUID( &guidStr );
                if ( SUCCEEDED( hr )) {
                    if ( Resource->ObjectGUID != NULL ) {
                        LocalFree( Resource->ObjectGUID );
                    }

                    Resource->ObjectGUID = ResUtilDupString( guidStr );
                }
                else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Failed to get computer object GUID for %1!ws!, status %2!08X!\n",
                                      virtualFQDN,
                                      hr );
                    status = hr;
                }

                if ( guidStr ) {
                    SysFreeString( guidStr );
                }
            }

            if ( pADs != NULL ) {
                pADs->Release();
            }

            if ( FAILED( hr )) {
                status = hr;
                goto cleanup;
            }

            if ( Resource->ObjectGUID == NULL ) {
                status = GetLastError();
                goto cleanup;
            }
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to get pointer to Computer Object for %1!ws!, status %2!08X!\n",
                              virtualFQDN,
                              hr );

            status = hr;
            goto cleanup;
        }
    }

    //
    // add the DnsHostName and ServicePrincipalName attributes
    //
    dnsSuffixSize = COUNT_OF( dnsSuffix );
    success = GetComputerNameEx(ComputerNameDnsDomain,
                                dnsSuffix,
                                &dnsSuffixSize);

    if ( success ) {
        status = AddDnsHostNameAttribute(resourceHandle,
                                         compObj,
                                         virtualName,
                                         dnsSuffix);

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to set DnsHostName attribute in the DS for %1!ws!, status %2!u!.\n",
                              virtualName,
                              status);

            goto cleanup;
        }
    }
    else {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to get primary DNS domain for this node, status %1!u!.\n",
                          status);

        goto cleanup;
    }

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    status = AddServicePrincipalNames( dsHandle, virtualFQDN, virtualName, dcInfo->DomainName );
    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to set ServicePrincipalName attribute in the DS for %1!ws!, status %2!u!.\n",
                          virtualName,
                          status);
    }

cleanup:
    //
    // always free these
    //
    if ( dsHandle != NULL ) {
        DsUnBind( &dsHandle );
    }

    if ( compObj != NULL ) {
        compObj->Release();
    }

    if ( status == ERROR_SUCCESS ) {
        *MachinePwd = machinePwd;
    } else {
        if ( status != ERROR_OPERATION_ABORTED ) {
            LPWSTR  msgBuff;
            DWORD   msgBytes;

            msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_SYSTEM,
                                     NULL,
                                     status,
                                     0,
                                     (LPWSTR)&msgBuff,
                                     0,
                                     NULL);

            if ( msgBytes > 0 ) {
                ClusResLogSystemEventByKey2(Resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_ADD_COMPUTER_ACCOUNT_FAILED,
                                            dcInfo->DomainName,
                                            msgBuff);

                LocalFree( msgBuff );
            } else {
                ClusResLogSystemEventByKeyData1(Resource->ResKey,
                                                LOG_CRITICAL,
                                                RES_NETNAME_ADD_COMPUTER_ACCOUNT_FAILED_STATUS,
                                                sizeof( status ),
                                                &status,
                                                dcInfo->DomainName);
            }
        }

        if ( machinePwd != NULL ) {
            //
            // don't zero out the string since we don't know if it was
            // properly constructed, i.e., decryption might have failed.
            //
            HeapFree( GetProcessHeap(), 0, machinePwd );
        }

        if ( deleteObjectOnFailure ) {
            //
            // only delete the object if we created it. It is possible that
            // the name was online at one time and the object was properly
            // created allowing additional information/SPNs to be registered
            // with the CO. For this reason, we shouldn't undo the work done
            // by other applications.
            //
            NetNameDeleteComputerObject( Resource );
        }
    }

    NetApiBufferFree( dcInfo );

    return status;
} // NetNameAddComputerObject

HRESULT
GetComputerObjectGuid(
    IN PNETNAME_RESOURCE    Resource
    )

/*++

Routine Description:

    For the given resource, find its computer object's GUID in the DS

Arguments:

    Resource - pointer to netname resource context block

    ResourceHandle - used to log in cluster log

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    LPWSTR  virtualFQDN;
    HRESULT hr;

    //
    // get the FQ Distinguished Name of the object
    //
    hr = GetFQDN(Resource->ResourceHandle,
                 Resource->NodeName,
                 Resource->Params.NetworkName,
                 NULL,                          /* DsHandle */
                 NULL,                          /* NTDomainName */
                 &virtualFQDN);

    if ( hr == ERROR_SUCCESS ) {
        IDirectoryObject *  compObj = NULL;

        //
        // get a COM pointer to the computer object
        //
        hr = GetComputerObjectViaFQDN( virtualFQDN, NULL, &compObj );
        if ( SUCCEEDED( hr )) {
            IADs *  pADs = NULL;

            //
            // get a pointer to the generic IADs interface so we can get the
            // GUID
            //
            hr = compObj->QueryInterface(IID_IADs, (void**) &pADs);
            if ( SUCCEEDED( hr )) {
                BSTR    guidStr = NULL;

                hr = pADs->get_GUID( &guidStr );
                if ( SUCCEEDED( hr )) {
                    if ( Resource->ObjectGUID != NULL ) {
                        LocalFree( Resource->ObjectGUID );
                    }

                    Resource->ObjectGUID = ResUtilDupString( guidStr );
                }

                if ( guidStr ) {
                    SysFreeString( guidStr );
                }
            }

            if ( pADs != NULL ) {
                pADs->Release();
            }
        }

        if ( compObj != NULL ) {
            compObj->Release();
        }

        LocalFree( virtualFQDN );
    }

    return hr;
} // GetComputerObjectGuid

HRESULT
CheckComputerObjectAttributes(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    LooksAlive routine for computer object. Using an IDirectoryObject pointer
    to the virtual CO, check its DnsHostName and SPN attributes

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;

    ADS_ATTR_INFO * attributeInfo = NULL;
    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    IDirectoryObject *  compObj = NULL;

    //
    // get a pointer to our CO
    //
    hr = GetComputerObjectViaGUID( Resource->ObjectGUID, NULL, &compObj );

    if ( SUCCEEDED( hr )) {
        LPWSTR          attributeNames[2] = { L"DnsHostName", L"ServicePrincipalName" };
        DWORD           numAttributes = COUNT_OF( attributeNames );
        DWORD           countOfAttrs;;

        hr = compObj->GetObjectAttributes(attributeNames,
                                          numAttributes,
                                          &attributeInfo,
                                          &countOfAttrs );

        if ( SUCCEEDED( hr )) {
            DWORD   i;
            WCHAR   fqDnsName[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD   nodeCharCount;
            DWORD   fqDnsSize;
            BOOL    setUnexpected = FALSE;
            BOOL    success;

            ADS_ATTR_INFO * attrInfo;

            //
            // check that we got our attributes
            //
            if ( countOfAttrs != numAttributes ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"DnsHostName and/or ServicePrincipalName attributes are "
                                  L"missing from computer account in DS.\n");

                hr = E_UNEXPECTED;
                goto cleanup;
            }

            //
            // build our FQDnsName using the primary DNS domain for this
            // node. Add 1 for the dot.
            //
            nodeCharCount = wcslen( Resource->Params.NetworkName ) + 1;
            wcscpy( fqDnsName, Resource->Params.NetworkName );
            wcscat( fqDnsName, L"." );
            fqDnsSize = COUNT_OF( fqDnsName ) - nodeCharCount;

            success = GetComputerNameEx( ComputerNameDnsDomain,
                                         &fqDnsName[ nodeCharCount ],
                                         &fqDnsSize );

            ASSERT( success );

            attrInfo = attributeInfo;
            for( i = 0; i < countOfAttrs; i++, attrInfo++ ) {
                if ( _wcsicmp( attrInfo->pszAttrName, L"DnsHostName" ) == 0 ) {
                    //
                    // should only be one entry and it should match our constructed FQDN
                    //
                    if ( attrInfo->dwNumValues == 1 ) {
                        if ( _wcsicmp( attrInfo->pADsValues->CaseIgnoreString,
                                       fqDnsName ) != 0 )
                        {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_ERROR,
                                              L"DnsHostName attribute in DS doesn't match. "
                                              L"Expected: %1!ws! Actual: %2!ws!\n",
                                              fqDnsName,
                                              attrInfo->pADsValues->CaseIgnoreString);
                            setUnexpected = TRUE;
                        }
                    }
                    else {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Found more than one string for DnsHostName attribute in DS.\n");
                        setUnexpected = TRUE;
                    }
                }
                else {
                    //
                    // SPNs require more work since we publish two and other
                    // services may have added their SPNs.
                    //
                    if ( attrInfo->dwNumValues >= 2 ) {
                        DWORD   countOfOurSPNs = 0;
                        DWORD   value;

                        for ( value = 0; value < attrInfo->dwNumValues; value++, attrInfo->pADsValues++) {
                            if ( _wcsnicmp( attrInfo->pADsValues->CaseIgnoreString, L"HOST/", 5 ) == 0 ) {
                                PWCHAR  hostName = attrInfo->pADsValues->CaseIgnoreString + 5;

                                if ( _wcsicmp( hostName, fqDnsName ) == 0 ) {
                                    ++countOfOurSPNs;
                                }
                                else {
                                    PWCHAR dot = wcschr( fqDnsName, L'.' );

                                    //
                                    // try again, this time with our Netbios variant
                                    //
                                    if ( dot ) {
                                        *dot = UNICODE_NULL;
                                    }

                                    if ( _wcsicmp( hostName, fqDnsName ) == 0 ) {
                                        ++countOfOurSPNs;
                                    }

                                    if ( !dot ) {
                                        *dot = L'.';
                                    }
                                }
                            } // if we found a HOST SPN
                        } // end of for each SPN value

                        if ( countOfOurSPNs != 2 ) {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_ERROR,
                                              L"There are missing HOST entries for ServicePrincipalName "
                                              L"attribute in DS.\n");
                            setUnexpected = TRUE;
                        }
                    }
                    else {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Found less than two entries for ServicePrincipalName "
                                          L"attribute in DS.\n");
                        setUnexpected = TRUE;
                    }
                }
            } // for each attribute info entry

            if ( setUnexpected ) {
                hr = E_UNEXPECTED;
            }
        } // if GetObjectAttributes succeeded
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable find attributes for computer object in DS. status %1!08X!.\n",
                              hr);
        }
    } // if GetComputerObjectViaFQDN succeeded
    else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable find computer object in DS. status %1!08X!.\n",
                          hr);
    }

cleanup:
    if ( attributeInfo != NULL ) {
        FreeADsMem( attributeInfo );
    }

    if ( compObj != NULL ) {
        compObj->Release();
    }

    return hr;
} // CheckComputerObjectAttributes

DWORD
IsComputerObjectInDS(
    IN  LPWSTR  NodeName,
    IN  LPWSTR  NewObjectName,
    OUT PBOOL   ObjectExists
    )

/*++

Routine Description:

    See if the specified name has a computer object in the DS. We do this by:

    1) binding to a domain controller in the domain and QI'ing for an IDirectorySearch object
    2) specifying (&(objectCategory=computer)(cn=<new name>)) as the search string
    3) examining result count of search; 1 means it exists.

Arguments:

    NewObjectName - requested new name of object

    ObjectExists - TRUE if object already exists; only valid if function status is success

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    BOOL    objectExists;
    HRESULT hr;
    DWORD   charsFormatted;
    LPWSTR  commonName = L"cn";
    WCHAR   bindingString[ DNS_MAX_NAME_BUFFER_LENGTH + COUNT_OF( LdapHeader ) ];

    WCHAR   searchLeader[] = L"(&(objectCategory=computer)(cn=";
    WCHAR   searchTrailer[] = L"))";
    WCHAR   searchFilter[ COUNT_OF( searchLeader ) + MAX_COMPUTERNAME_LENGTH + COUNT_OF( searchTrailer )];

    ADS_SEARCHPREF_INFO searchPrefs[2];
    IDirectorySearch *  pDSSearch = NULL;
    ADS_SEARCH_HANDLE   searchHandle;

    PDOMAIN_CONTROLLER_INFO dcInfo;

    //
    // get DC related info
    //
    hr = FindDomainForServer( NodeName, &dcInfo );

    if ( hr != ERROR_SUCCESS ) {
        return hr;
    }

    //
    // format an LDAP binding string for DNS suffix of the domain.
    //
    _snwprintf( bindingString, COUNT_OF( bindingString ) - 1, L"%ws%ws", LdapHeader, dcInfo->DomainName );

    hr = ADsGetObject( bindingString, IID_IDirectorySearch, (VOID **)&pDSSearch );
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // build search preference array. we limit the size to one and we want to
    // scope the search to check all subtrees.
    //
    searchPrefs[0].dwSearchPref     = ADS_SEARCHPREF_SIZE_LIMIT;
    searchPrefs[0].vValue.dwType    = ADSTYPE_INTEGER;
    searchPrefs[0].vValue.Integer   = 1;

    searchPrefs[1].dwSearchPref     = ADS_SEARCHPREF_SEARCH_SCOPE;
    searchPrefs[1].vValue.dwType    = ADSTYPE_INTEGER;
    searchPrefs[0].vValue.Integer   = ADS_SCOPE_SUBTREE;

    hr = pDSSearch->SetSearchPreference( searchPrefs, COUNT_OF( searchPrefs ));
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // build the search filter and execute the search; constrain the
    // attributes to just the common name. This is just an existance test.
    //
    charsFormatted = _snwprintf(searchFilter,
                                COUNT_OF( searchFilter ) - 1,
                                L"%ws%ws%ws",
                                searchLeader,
                                NewObjectName,
                                searchTrailer);
    ASSERT( charsFormatted > COUNT_OF( searchLeader ));

    hr = pDSSearch->ExecuteSearch(searchFilter,
                                  &commonName,
                                  1,
                                  &searchHandle);
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // try to get the first row. Anything but S_OK returns FALSE
    //
    hr = pDSSearch->GetFirstRow( searchHandle );
    *ObjectExists = (hr == S_OK);
    if ( hr == S_ADS_NOMORE_ROWS ) {
        hr = S_OK;
    }

    pDSSearch->CloseSearchHandle( searchHandle );

cleanup:
    if ( pDSSearch != NULL ) {
        pDSSearch->Release();
    }

    if ( dcInfo != NULL ) {
        NetApiBufferFree( dcInfo );
    }

    return hr;
} // IsComputerObjectInDS

HRESULT
RenameComputerObject(
    IN  PNETNAME_RESOURCE   Resource,
    IN  LPWSTR              NewName     OPTIONAL
    )

/*++

Routine Description:

    Rename the computer object at the DS. Do this by:

    1) using the supplied name or calling NetnameGetParams to get new name
       from the name property from the registry
    2) get the FQDN of the computer object
    3) get the parent FQDN by calling GetObjectInfomation
    4) get an IADsContainer pointer to the parent object
    5) call MoveHere with an updated FQDN to change the name

    Current status of renaming computer objects as of 4/5/01 - charlwi

    While this routine will rename the computer object (if the user account of
    the calling thread has the proper permissions), MoveHere does not fix any
    other properties that allow the renamed object to be useful. At a minimum,
    SamAccountName needs to be updated with the new name. When the name goes
    back online, netname will fix the DnsHostName and SPN attributes to be
    correct. The workaround is to use adsiedit.msc (from the resource kit) to
    rename the object and change SamAccountName under the mandatory property
    list.

    The good news is that MoveHere is not affected by child objects, such as
    MSMQ configuration objects. The bad news is that the creator of the object
    does not have permission to rename it. By running the cluster service in
    the domain admin's account, COs can be renamed. By default, the creating
    account does not have permission to rename the object nor can it modify
    the permissions on the object to grant itself that permission. It is not
    clear which permission allows renaming to occur.

    What I think this means is that the cluster team needs to work with the DS
    team to integrate virtual COs into the DS in a more cluster adminitrator
    friendly way.

Arguments:

    Resource - pointer to the netname context block

Return Value:

    ERROR_SUCCESS if it worked...

--*/

{
    LPWSTR  newName = NULL;
    LPWSTR  oldNameFQDN = NULL;
    HRESULT hr;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    IDirectoryObject *  oldCompObj = NULL;

    //
    // we shouldn't be here if the name specified in the resource's param
    // block is null.
    //
    if ( Resource->Params.NetworkName == NULL ) {
        ASSERT( Resource->Params.NetworkName != NULL );
        return ERROR_INVALID_PARAMETER;
    }

    if ( NewName == NULL ) {
        //
        // get the name parameter out of the registry.
        //
        newName = ResUtilGetSzValue( Resource->ParametersKey, PARAM_NAME__NAME );

        if (newName == NULL) {
            hr = GetLastError();
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to read NetworkName parameter to rename computer account, status %1!u!\n",
                              hr);
            return hr;
        }
    } else {
        newName = NewName;
    }

    //
    // make sure the name in the registry is different than the current name.
    //
    if ( _wcsicmp( newName, Resource->Params.NetworkName ) == 0 ) {
        hr = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // get the FQDN of the computer object for the current name. If one
    // doesn't exist then there is nothing to rename.
    //
    hr = GetFQDN(resourceHandle,
                 Resource->NodeName,
                 Resource->Params.NetworkName,
                 NULL,
                 NULL,
                 &oldNameFQDN);

    if ( hr == DS_NAME_ERROR_NOT_FOUND ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"No computer account was found to rename %1!ws! to %2!ws!.\n",
                          Resource->Params.NetworkName,
                          newName);

        hr = ERROR_SUCCESS;
        goto cleanup;
    }
    else if ( hr != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to get distinguished name to rename computer account, status 0x%1!08X!\n",
                          hr);
        goto cleanup;
    }

    //
    // get a pointer to our CO
    //
    hr = GetComputerObjectViaFQDN( oldNameFQDN, NULL, &oldCompObj );

    if ( SUCCEEDED( hr )) {
        PADS_OBJECT_INFO    objInfo;

        //
        // get the parent's FQDN string; it comes with the LDAP header already
        // on it
        //
        hr = oldCompObj->GetObjectInformation( &objInfo );
        if ( SUCCEEDED( hr )) {
            IADsContainer * parentContainer = NULL;

            //
            // get a pointer to the parent container object
            //
            hr = ADsGetObject( objInfo->pszParentDN, IID_IADsContainer, (void **)&parentContainer );
            if ( SUCCEEDED( hr )) {
                WCHAR   cnHeader[] = L"cn=";
                WCHAR   newNameRDN[ COUNT_OF( cnHeader ) + MAX_COMPUTERNAME_LENGTH ];
                LPWSTR  oldNamePath = NULL;
                DWORD   oldNamePathByteLength;

                IDispatch *     newNameDispatch = NULL;

                //
                // construct the relative distinguished name for the new name
                //
                _snwprintf( newNameRDN, COUNT_OF( newNameRDN ) - 1, L"%ws%ws", cnHeader, newName );

                //
                // argh. MoveHere needs BSTRs and the source DN needs the LDAP
                // header. sheesh!
                //
                oldNamePathByteLength = ( wcslen( oldNameFQDN ) + COUNT_OF( LdapHeader )) * sizeof( WCHAR );
                oldNamePath = (LPWSTR)HeapAlloc( GetProcessHeap(), 0, oldNamePathByteLength );

                if ( oldNamePath != NULL ) {
                    BSTR    bstrOldNamePath;
                    BSTR    bstrNewNameRDN;

                    wcscpy( oldNamePath, LdapHeader );
                    wcscat( oldNamePath, oldNameFQDN );

                    bstrOldNamePath = SysAllocString( oldNamePath );
                    bstrNewNameRDN = SysAllocString( newNameRDN );

                    if ( bstrOldNamePath != NULL && bstrNewNameRDN != NULL ) {
                        hr = parentContainer->MoveHere( bstrOldNamePath, bstrNewNameRDN, &newNameDispatch );

                        SysFreeString( bstrOldNamePath );
                        SysFreeString( bstrNewNameRDN );

                        if ( newNameDispatch != NULL ) {
                            newNameDispatch->Release();
                        }

                        if ( SUCCEEDED( hr )) {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_INFORMATION,
                                              L"Renamed computer account for %1!ws! to %2!ws!.\n",
                                              Resource->Params.NetworkName,
                                              newName);
                        } else {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_ERROR,
                                              L"Unable to rename computer account for %1!ws! to %2!ws!. "
                                              L"status 0x%3!08X!.\n",
                                              Resource->Params.NetworkName,
                                              newName,
                                              hr);
                        }
                    }
                    else {
                        if ( bstrOldNamePath != NULL ) {
                            SysFreeString( bstrOldNamePath );
                        }

                        if ( bstrNewNameRDN != NULL ) {
                            SysFreeString( bstrNewNameRDN );
                        }

                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Unable to allocate memory to rename %1!ws! to %2!ws!.\n",
                                          Resource->Params.NetworkName,
                                          newName);
                    }

                    HeapFree( GetProcessHeap(), 0, oldNamePath );
                }
                else {
                    hr = ERROR_NOT_ENOUGH_MEMORY;

                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Unable to allocate memory to rename %1!ws! to %2!ws!.\n",
                                      Resource->Params.NetworkName,
                                      newName);
                }
            }
            else {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to bind to parent container for computer account rename. "
                                  L"status 0x%1!08X!.\n",
                                  hr);
            }

            if ( parentContainer != NULL ) {
                parentContainer->Release();
            }


            FreeADsMem( objInfo );
        } // if GetObjectInformation succeeded
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to get computer object information in DS. status 0x%1!08X!.\n",
                              hr);
        }

    } // if GetComputerObjectViaFQDN succeeded
    else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable find computer object in DS. status 0x%1!08X!.\n",
                          hr);
    }

cleanup:
    if ( newName != NULL && newName != NewName ) {
        LocalFree( newName );
    }

    if ( oldNameFQDN != NULL ) {
        LocalFree( oldNameFQDN );
    }

    if ( oldCompObj != NULL ) {
        oldCompObj->Release();
    }

    return hr;
} // RenameComputerObject


DWORD
UpdateCompObjPassword(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_SUCCESS;
} // UpdateCompObjPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\namechk.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    namechk.h

Abstract:

    Routines for checking nbt network names.

Author:

    Rod Gamache (rodga) 1-Aug-1997

Revision History:

--*/

#include <tdi.h>
#include <nb30.h>


#define MAX_PATH_SIZE   64

#define NETBIOS_NAME_SIZE 16

//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;


//----------------------------------------------------------------------
//
//  Function Prototypes
//

NTSTATUS
ReadRegistry(
    IN UCHAR  pDeviceName[][MAX_PATH_SIZE]
    );

NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );

NTSTATUS
OpenNbt(
    IN  CHAR    path[][MAX_PATH_SIZE],
    OUT PHANDLE pHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\nameutil.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    nameutil.h

Abstract:

    Routines for manipulating LM workstation and server names.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

#include <windns.h>
#include <dnsapi.h>

#define NetNameSetResourceStatus    ClusResSetResourceStatus

//
// definitions
//

//
// function definitions
//

NET_API_STATUS
AddAlternateComputerName(
    IN     PCLUS_WORKER             Worker,
    IN     PNETNAME_RESOURCE        Resource,
    IN     LPWSTR *                 TransportList,
    IN     DWORD                    TransportCount,
    IN     PDOMAIN_ADDRESS_MAPPING  DomainMapList,
    IN     DWORD                    DomainMapCount
    );

VOID
DeleteAlternateComputerName(
    IN LPWSTR           AlternateComputerName,
    IN HANDLE *         NameHandleList,
    IN DWORD            NameHandleCount,
    IN RESOURCE_HANDLE  ResourceHandle
    );

NET_API_STATUS
DeleteServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName
    );

DWORD
RegisterDnsRecords(
    IN  PDNS_LISTS       DnsLists,
    IN  LPWSTR           NetworkName,
    IN  HKEY             ResourceKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  BOOL             LogRegistration,
    OUT PULONG           NumberOfRegisteredNames
    );

LPWSTR
BuildUnicodeReverseName(
    IN  LPWSTR  IpAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\crypto.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    routines for encrypting/decrypting random data blob. heavily modelled
    after service\cp\crypto.c

Author:

    Charlie Wickham (charlwi) 14-Feb-2001

Environment:

    User Mode

Revision History:

--*/

#include "clusres.h"
#include "clusrtl.h"
#include "netname.h"

#include <wincrypt.h>
#include <lm.h>

//
// header for encrypted data.
//
#define SALT_SIZE   16
#define IV_SIZE      8

typedef struct _NETNAME_ENCRYPTED_DATA {
    DWORD Version;
    struct _NETNAME_ENCRYPTION_INITIALIZATION_DATA {
        BYTE IV[IV_SIZE];
        BYTE Salt[SALT_SIZE];
    } InitData;
    BYTE Data[0];
} NETNAME_ENCRYPTED_DATA, *PNETNAME_ENCRYPTED_DATA;

// current version for the CRYPTO_KEY_INFO struct
#define NETNAME_ENCRYPTED_DATA_VERSION     1

DWORD
GenSymKey(
    IN HCRYPTPROV hProv,
    IN BYTE *pbSalt,
    IN BYTE *pbIV,
    OUT HCRYPTKEY *phSymKey
    )

/*++

Routine Description:

    Generate a session key based on the specified Salt and IV.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pbSalt - Salt value

    pbIV - IV value

    phSymKey - Resulting symmetric key (CALG_RC2)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    HCRYPTHASH hHash = 0;
    DWORD cbPassword = 0;
    DWORD Status;

    if (!CryptCreateHash(hProv,
                         CALG_SHA1,
                         0,
                         0,
                         &hHash))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (!CryptHashData(hHash,
                       pbSalt,
                       SALT_SIZE,
                       0))
    {
        Status = GetLastError();
        goto Ret;
    }

    // derive the key from the hash
    if (!CryptDeriveKey(hProv,
                        CALG_RC2,
                        hHash,
                        0,
                        phSymKey))
    {
        Status = GetLastError();
        goto Ret;
    }

    // set the IV on the key
    if (!CryptSetKeyParam(*phSymKey,
                          KP_IV,
                          pbIV,
                          0))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (hHash)
        CryptDestroyHash(hHash);

    return (Status);
} // GenSymKey

DWORD
EncryptNetNameData(
    RESOURCE_HANDLE ResourceHandle,
    LPWSTR          MachinePwd,
    PBYTE *         EncryptedInfo,
    PDWORD          EncryptedInfoLength,
    HKEY            Key
    )

/*++

Routine Description:

    encrypt the password, set a pointer to the encrypted data and store it in
    the registry.

    There is a chicken/egg problem of sorts in that we have to generate the
    key before we can use it to encrypt data. This requires having a spot to
    store the Salt and IV. Since we have to hold all the info in one buffer
    for the registry write, we tempoarily use stack-based buffer
    (keyGenBuffer) for the header info. Once we know the size of the encrypted
    data, we can allocate the proper sized buffer (encryptedInfo), copy
    everything into it, and write the registry. It is this buffer that is
    handed back to the caller via the EncryptedInfo argument.

Arguments:

    ResourceHandle - for logging to the cluster log

    MachinePwd - pointer to unicode string password

    EncryptedInfo - address of a pointer that receives a pointer to the encrypted blob

    EncryptedInfoLength - pointer to a DWORD that receives the length of the blob

    Key - handle to netname parameters key where the data is stored

Return Value:

    ERROR_SUCCESS, otherwise Win32 error

--*/

{
    DWORD   status;
    DWORD   encInfoLength;
    DWORD   encDataLength = 0;
    BOOL    success;
    DWORD   pwdLength = ( wcslen( MachinePwd ) + 1 ) * sizeof( WCHAR );

    HCRYPTPROV  cryptoProvider = 0;
    HCRYPTKEY   sessionKey = 0;

    NETNAME_ENCRYPTED_DATA  keyGenBuffer;           // temp header buffer to generate key
    PNETNAME_ENCRYPTED_DATA encryptedInfo = NULL;   // final data area


    //
    // get a handle to the full RSA provider
    //
    if ( !CryptAcquireContext(&cryptoProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_MACHINE_KEYSET | CRYPT_SILENT))
    {
        status = GetLastError();
        if ( status == NTE_BAD_KEYSET ) {
            success = CryptAcquireContext(&cryptoProvider,
                                          NULL,
                                          NULL,
                                          PROV_RSA_FULL,
                                          CRYPT_MACHINE_KEYSET  |
                                          CRYPT_SILENT          |
                                          CRYPT_NEWKEYSET);

            status = success ? ERROR_SUCCESS : GetLastError();
        }

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Can't acquire crypto context for encrypt. status %1!u!.\n",
                              status);
            return status;
        }
    }

    //
    // generate the session key.
    //
    if ( !CryptGenRandom(cryptoProvider,
                         sizeof(struct _NETNAME_ENCRYPTION_INITIALIZATION_DATA),
                         (PBYTE)&keyGenBuffer.InitData))
    {
        status = GetLastError();
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Can't generate seed data. status %1!u!.\n",
                          status);
        goto cleanup;
    }
    keyGenBuffer.Version = NETNAME_ENCRYPTED_DATA_VERSION;

    status = GenSymKey(cryptoProvider,
                       keyGenBuffer.InitData.Salt,
                       keyGenBuffer.InitData.IV,
                       &sessionKey);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Can't generate session key for encrypt. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    //
    // find the size we need for the buffer to receive the encrypted data
    //
    encDataLength = pwdLength;
    if ( CryptEncrypt(sessionKey,
                      0,
                      TRUE,
                      0,
                      NULL,
                      &encDataLength,
                      0))
    {
        //
        // alloc a buffer large enough to hold the data and copy the password into it.
        //
        ASSERT( encDataLength >= pwdLength );

        encInfoLength = sizeof( NETNAME_ENCRYPTED_DATA ) + encDataLength;

        encryptedInfo = HeapAlloc( GetProcessHeap(), 0, encInfoLength );

        if ( encryptedInfo != NULL ) {
            wcscpy( (PWCHAR)encryptedInfo->Data, MachinePwd );

            if ( CryptEncrypt(sessionKey,
                              0,
                              TRUE,
                              0,
                              encryptedInfo->Data,
                              &pwdLength,
                              encDataLength))            
            {
                *encryptedInfo = keyGenBuffer;

                status = ResUtilSetBinaryValue(Key,
                                               PARAM_NAME__RANDOM,
                                               (const LPBYTE)encryptedInfo,
                                               encInfoLength,
                                               NULL,
                                               NULL);

                if ( status != ERROR_SUCCESS ) {
                    (NetNameLogEvent)(ResourceHandle,
                                      LOG_ERROR,
                                      L"Can't write %1!u! bytes of data to registry. status %2!u!.\n",
                                      encInfoLength,
                                      status);
                    goto cleanup;
                }
            }
            else {
                status = GetLastError();
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Can't encrypt %1!u! bytes. status %2!u!.\n",
                                  pwdLength,
                                  status);
                goto cleanup;
            }
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Can't allocate %1!u! bytes for encrypted data. status %2!u!.\n",
                              encInfoLength,
                              status);
            goto cleanup;
        }
    }
    else {
        status = GetLastError();
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Can't determine size of encrypted data buffer for %1!u! bytes of data. status %2!u!.\n",
                          pwdLength,
                          status);
        goto cleanup;
    }

    *EncryptedInfoLength = encInfoLength;
    *EncryptedInfo = (PBYTE)encryptedInfo;

cleanup:

    if ( status != ERROR_SUCCESS && encryptedInfo != NULL ) {
        HeapFree( GetProcessHeap(), 0, encryptedInfo );
    }

    if ( sessionKey != 0 ) {
        if ( !CryptDestroyKey( sessionKey )) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Couldn't destory session key. status %1!u!.\n",
                              GetLastError());
        }
    }

    if ( !CryptReleaseContext( cryptoProvider, 0 )) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Can't release crypto context. status %1!u!.\n",
                          GetLastError());
    }

    return status;
} // EncryptNetNameData

DWORD
DecryptNetNameData(
    RESOURCE_HANDLE ResourceHandle,
    PBYTE           EncryptedInfo,
    DWORD           EncryptedInfoLength,
    LPWSTR          MachinePwd
    )

/*++

Routine Description:

    Reverse of encrypt routine - decrypt random blob and hand back the
    password

Arguments:

    ResourceHandle - used to log into the cluster log

    EncryptedInfo - pointer to encrypted info header and data

    EncryptedInfoLength - # of bytes in EncryptedInfo

    MachinePwd -  pointer to buffer that receives the unicode password

Return Value:

    ERROR_SUCCESS, otherwise Win32 error

--*/

{
    DWORD   status;
    DWORD   encDataLength = EncryptedInfoLength - sizeof( NETNAME_ENCRYPTED_DATA );
    BOOL    success;
    DWORD   pwdByteLength;
    DWORD   pwdBufferSize;
    PWCHAR  machinePwd = NULL;

    HCRYPTPROV  cryptoProvider = 0;
    HCRYPTKEY   sessionKey = 0;

    PNETNAME_ENCRYPTED_DATA encryptedInfo = (PNETNAME_ENCRYPTED_DATA)EncryptedInfo;

    //
    // get a handle to the full RSA provider
    //
    if ( !CryptAcquireContext(&cryptoProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_MACHINE_KEYSET | CRYPT_SILENT))
    {
        status = GetLastError();
        if ( status == NTE_BAD_KEYSET ) {
            success = CryptAcquireContext(&cryptoProvider,
                                          NULL,
                                          NULL,
                                          PROV_RSA_FULL,
                                          CRYPT_MACHINE_KEYSET  |
                                          CRYPT_SILENT          |
                                          CRYPT_NEWKEYSET);

            status = success ? ERROR_SUCCESS : GetLastError();
        }

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Can't acquire crypto context for decrypt. status %1!u!.\n",
                              status);
            return status;
        }
    }

    status = GenSymKey(cryptoProvider,
                       encryptedInfo->InitData.Salt,
                       encryptedInfo->InitData.IV,
                       &sessionKey);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Can't generate session key for decrypt. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    //
    // CryptDecrypt writes the decrypted data back into the buffer that was
    // holding the encrypted data. For this reason, allocate a new buffer that
    // will eventually contain the password.
    //
    pwdByteLength = ( LM20_PWLEN + 1 ) * sizeof( WCHAR );
    pwdBufferSize = ( pwdByteLength > encDataLength ? pwdByteLength : encDataLength );

    machinePwd = HeapAlloc( GetProcessHeap(), 0, pwdBufferSize );
    if ( machinePwd != NULL ) {
        RtlCopyMemory( machinePwd, encryptedInfo->Data, encDataLength );

        if ( CryptDecrypt(sessionKey,
                          0,
                          TRUE,
                          0,
                          (PBYTE)machinePwd,
                          &encDataLength))
        {
            ASSERT( pwdByteLength == encDataLength );
            wcscpy( MachinePwd, machinePwd );
        }
        else {
            status = GetLastError();
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Can't decrypt %1!u! bytes of data. status %2!u!.\n",
                              encDataLength,
                              status);
            goto cleanup;
        }
    }
    else {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Can't allocate %1!u! bytes for decrypt. status %2!u!.\n",
                          pwdBufferSize,
                          status);
        goto cleanup;
    }

cleanup:

    if ( machinePwd != NULL) {
        HeapFree( GetProcessHeap(), 0, machinePwd );
    }

    if ( sessionKey != 0 ) {
        if ( !CryptDestroyKey( sessionKey )) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Couldn't destory session key. status %1!u!.\n",
                              GetLastError());
        }
    }

    if ( !CryptReleaseContext( cryptoProvider, 0 )) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Can't release crypto context. status %1!u!.\n",
                          GetLastError());
    }

    return status;
} // DecryptNetNameData


/* end crypto.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\namechk.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    namechk.c

Abstract:

    Check on network names given by the cluster network name resource dll.

Author:

    Rod Gamache (rodga) 1-Aug-1997

Environment:

    User Mode

Revision History:


--*/

#define UNICODE 1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>

#include <nb30.h>
#include <lmaccess.h>

#include "namechk.h"
#include "resapi.h"
#include "netname.h"
#include "nameutil.h"
#include "clusres.h"


#define NET_NAME_SVC L"LanmanServer"

#define BUFF_SIZE   650

#define NBT_MAXIMUM_BINDINGS 20


NTSTATUS
CheckNbtName(
    IN HANDLE           Fd,
    IN LPCWSTR          Name,
    IN ULONG            Type,
    IN RESOURCE_HANDLE  ResourceHandle
    );

NTSTATUS
ReadRegistry(
    IN UCHAR  pDeviceName[][MAX_PATH_SIZE]
    );

NTSTATUS
OpenNbt(
    IN char path[][MAX_PATH_SIZE],
    OUT PHANDLE pHandle
    );



DWORD
NetNameCheckNbtName(
    IN LPCWSTR         NetName,
    IN DWORD           NameHandleCount,
    IN HANDLE *        NameHandleList,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Checks a network name.

Arguments:

    NetName - pointer to the network name to validate.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD     status = ERROR_SUCCESS;
    NTSTATUS  ntStatus;

    //
    // loop through the list of handles we acquired when bringing the
    // name online and check that our netname is still registered
    // on each device
    //

    while ( NameHandleCount-- ) {

        //
        // Check the workstation name. If this fails, immediate failure!
        //
        ntStatus = CheckNbtName(
                       *NameHandleList,
                       NetName,
                       0x00,
                       ResourceHandle
                       );

        if ( !NT_SUCCESS(ntStatus) ) {
            status = RtlNtStatusToDosError(ntStatus);
            return(status);
        }

        //
        // Check the server name. If this fails, then only fail if Srv service
        // is not running.
        //
        ntStatus = CheckNbtName(
                       *NameHandleList,
                       NetName,
                       0x20,
                       ResourceHandle
                       );

        if ( !NT_SUCCESS(ntStatus) ) {
            if ( ResUtilVerifyResourceService( NET_NAME_SVC) == ERROR_SUCCESS ) {
                status = ERROR_RESOURCE_FAILED;
            }
        }

        ++NameHandleList;
    }

    return(status);

} // NetNameCheckName


NTSTATUS
CheckNbtName(
    IN HANDLE           fd,
    IN LPCWSTR          Name,
    IN ULONG            Type,
    IN RESOURCE_HANDLE  ResourceHandle
    )

/*++

Routine Description:

    This procedure does an adapter status query to get the local name table.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG                            Count;
    ULONG                           BufferSize = sizeof( tADAPTERSTATUS );
    tADAPTERSTATUS                  staticBuffer;
    PVOID                           pBuffer = (PVOID)&staticBuffer;
    NTSTATUS                        status;
    tADAPTERSTATUS                  *pAdapterStatus;
    NAME_BUFFER                     *pNames;
    ULONG                           Ioctl;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    PVOID                           pInput;
    ULONG                           SizeInput;
    UCHAR                           netBiosName[NETBIOS_NAME_SIZE +4];
    OEM_STRING                      netBiosNameString;
    UNICODE_STRING                  unicodeName;
    NTSTATUS                        ntStatus;

    //
    // set the correct Ioctl for the call to NBT, to get either
    // the local name table or the remote name table
    //
    Ioctl = IOCTL_TDI_QUERY_INFORMATION;
    QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever
    SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
    pInput = &QueryInfo;

    do {
        status = DeviceIoCtrl(fd,
                              pBuffer,
                              BufferSize,
                              Ioctl,
                              pInput,
                              SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW) {
            if ( pBuffer != &staticBuffer ) {
                LocalFree(pBuffer);
            }

            BufferSize += sizeof( staticBuffer.Names );
            pBuffer = LocalAlloc(LMEM_FIXED, BufferSize);

            if (!pBuffer || (BufferSize >= 0xFFFF)) {
                LocalFree(pBuffer);
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Unable to allocate memory for name query.\n"
                    );
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    } while (status == STATUS_BUFFER_OVERFLOW);

    if (status != STATUS_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Name query request failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    Count = pAdapterStatus->AdapterInfo.name_count;
    pNames = pAdapterStatus->Names;

    status = STATUS_NOT_FOUND;

    if (Count == 0) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Name query request returned zero entries.\n"
            );
        goto error_exit;
    }

    //
    // Convert the ServerName to an OEM string
    //
    RtlInitUnicodeString( &unicodeName, Name );

    netBiosNameString.Buffer = (PCHAR)netBiosName;
    netBiosNameString.MaximumLength = sizeof( netBiosName );

    ntStatus = RtlUpcaseUnicodeStringToOemString(
                   &netBiosNameString,
                   &unicodeName,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            Name,
            status
            );
        return(status);
    }

    //
    // blank fill the name
    //
    memset(&netBiosName[netBiosNameString.Length],
           ' ',
           NETBIOS_NAME_SIZE - netBiosNameString.Length);

    while ( Count-- ) {
        //
        // Make sure the type and name matches
        //
        if ( (pNames->name[NETBIOS_NAME_SIZE-1] == Type) &&
             (memcmp(pNames->name, netBiosName, NETBIOS_NAME_SIZE-1) == 0) )
        {

            switch(pNames->name_flags & 0x0F) {

            case REGISTERING:
            case REGISTERED:
               status = STATUS_SUCCESS;
               break;

            case DUPLICATE_DEREG:
            case DUPLICATE:
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Name %1!ws!<%2!x!> is in conflict.\n",
                    Name,
                    Type
                    );
                status = STATUS_DUPLICATE_NAME;
                break;

            case DEREGISTERED:
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Name %1!ws!<%2!x!> was deregistered.\n",
                    Name,
                    Type
                    );
                status = STATUS_NOT_FOUND;
                break;

            default:
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Name %1!ws!<%2!x!> is in unknown state %3!x!.\n",
                    Name,
                    Type,
                    (pNames->name_flags & 0x0F)
                    );
               status = STATUS_UNSUCCESSFUL;
               break;
            }
        }

        pNames++;
    }

    if (status == STATUS_NOT_FOUND) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Name %1!ws!<%2!x!> is no longer registered with NBT.\n",
            Name,
            Type
            );
    }

error_exit:

    if ( pBuffer != &staticBuffer ) {
        LocalFree(pBuffer);
    }

    return(status);

} // CheckNbtName

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);

} // DeviceIoCtrl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\nameutil.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    nameutil.c

Abstract:

    Routines for manipulating LM workstation and server names.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

#define UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include <tdi.h>
#include <lm.h>
#include <stdlib.h>
#include "netname.h"
#include "nameutil.h"
#include <dnsapi.h>
#include <dnslib.h>

//
// Constants
//
#define LOG_CURRENT_MODULE LOG_MODULE_NETNAME

//
// forward declarations
//
VOID
LogDnsFailureToEventLog(
    IN  HKEY    ResourceKey,
    IN  LPWSTR  DnsName,
    IN  LPWSTR  ResourceName,
    IN  DWORD   Status,
    IN  LPWSTR  ConnectoidName
    );

//
// Local Utility Routines
//

NET_API_STATUS
CheckForServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName,
    IN  POEM_STRING      OemServerNameString,
    OUT PBOOLEAN         IsNameRegistered
    )
{
    PSERVER_TRANSPORT_INFO_0   psti0 = NULL;
    DWORD                      entriesRead = 0;
    DWORD                      totalEntries = 0;
    DWORD                      resumeHandle = 0;
    NET_API_STATUS             status;
    DWORD                      i;


    *IsNameRegistered = FALSE;

    status = NetServerTransportEnum(
                NULL,
                0,
                (LPBYTE *) &psti0,
                (DWORD) -1,
                &entriesRead,
                &totalEntries,
                &resumeHandle
                );

    if (status != NERR_Success) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"Unable to enumerate server tranports, error %1!u!.\n",
            status
            );
        return(status);
    }

    for ( i=0; i < entriesRead; i++ ) {
        if ( ( psti0[i].svti0_transportaddresslength ==
               OemServerNameString->Length
             )
             &&
             ( RtlCompareMemory(
                   psti0[i].svti0_transportaddress,
                   OemServerNameString->Buffer,
                   OemServerNameString->Length
                   ) == OemServerNameString->Length
             )
           )
        {
            *IsNameRegistered = TRUE;
            break;
        }
    }

    if (psti0 != NULL) {
        LocalFree(psti0);
    }

    return(status);

}  // CheckForServerName


NET_API_STATUS
pDeleteServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName,
    IN  POEM_STRING      OemServerNameString
    )
{
    NET_API_STATUS    status;
    BOOLEAN           isNameRegistered;
    DWORD             count;

    //
    // Delete the name
    //
    status = NetServerComputerNameDel(NULL, ServerName);

    if (status != NERR_Success) {
        if (status != ERROR_BAD_NET_NAME) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Failed to delete server name %1!ws!, status %2!u!.\n",
                ServerName,
                status
                );
        }

        return(status);
    }

    //
    // Check to make sure the name was really deleted. We'll wait up
    // to 2 seconds.
    //
    for (count = 0; count < 8; count++) {

        status = CheckForServerName(
                     ResourceHandle,
                     ServerName,
                     OemServerNameString,
                     &isNameRegistered
                     );

        if (status != NERR_Success) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Unable to verify that server name %1!ws! was deleted, status %2!u!.\n",
                ServerName,
                status
                );
            return(NERR_Success);
        }

        if (isNameRegistered == FALSE) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_INFORMATION,
                L"Deleted server name %1!ws! from all transports.\n",
                ServerName
                );

            return(NERR_Success);
        }

        Sleep(250);
    }

    (NetNameLogEvent)(
        ResourceHandle,
        LOG_WARNING,
        L"Delete of server name %1!ws! succeeded, but name still has not gone away. "
        L"Giving up.\n",
        ServerName
        );

    return(ERROR_IO_PENDING);

}  // pDeleteServerName


NET_API_STATUS
AddServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName,
    IN  BOOL             RemapPipeNames,
    IN  LPWSTR           TransportName,
    IN  BOOLEAN          CheckNameFirst,
    IN  PWCHAR           MachinePwd
    )
{
    SERVER_TRANSPORT_INFO_2   sti2;
    SERVER_TRANSPORT_INFO_3   sti3;
    UCHAR                     netBiosName[ NETBIOS_NAME_LEN ];
    OEM_STRING                netBiosNameString;
    UNICODE_STRING            unicodeName;
    NET_API_STATUS            status;
    NTSTATUS                  ntStatus;


    //
    // Convert the ServerName to an OEM string
    //
    RtlInitUnicodeString( &unicodeName, ServerName );

    netBiosNameString.Buffer = (PCHAR)netBiosName;
    netBiosNameString.MaximumLength = sizeof( netBiosName );

    ntStatus = RtlUpcaseUnicodeStringToOemString(
                   &netBiosNameString,
                   &unicodeName,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            ServerName,
            status
            );
        return(status);
    }

    if (CheckNameFirst) {
        BOOLEAN  isNameRegistered;

        //
        // Check to see if the name is already registered.
        //
        status = CheckForServerName(
                     ResourceHandle,
                     ServerName,
                     &netBiosNameString,
                     &isNameRegistered
                     );

        if (status != NERR_Success) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Unable to verify that server name %1!ws! does not already exist.\n",
                ServerName
                );
            isNameRegistered = TRUE;   // just to be safe
        }

        if (isNameRegistered) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_INFORMATION,
                L"Deleting old registration for server name %1!ws!.\n",
                ServerName
                );

            status = pDeleteServerName(
                         ResourceHandle,
                         ServerName,
                         &netBiosNameString
                         );

            if (status != NERR_Success) {
                if (status == ERROR_IO_PENDING) {
                    status = ERROR_GEN_FAILURE;
                }

                return(status);
            }
        }
    }

    //
    // Register the name on the specified transport. If we have a password,
    // then kerb was enabled. If no password, bring the name online without
    // any credentials. This will cause RDR to fall back to NTLM for
    // authentication.
    //
    if ( MachinePwd != NULL ) {
        RtlZeroMemory( &sti3, sizeof(sti3) );
        sti3.svti3_transportname = TransportName;
        sti3.svti3_transportaddress = netBiosName;
        sti3.svti3_transportaddresslength = strlen(netBiosName);

        if (RemapPipeNames) {
            sti3.svti3_flags = SVTI2_REMAP_PIPE_NAMES;
        }

        wcscpy( (PWCHAR)sti3.svti3_password, MachinePwd );
        sti3.svti3_passwordlength = wcslen( MachinePwd ) * sizeof(WCHAR);

        status = NetServerTransportAddEx( NULL, 3, (LPBYTE)&sti3 );
    }
    else {
        RtlZeroMemory( &sti2, sizeof(sti2) );
        sti2.svti2_transportname = TransportName;
        sti2.svti2_transportaddress = netBiosName;
        sti2.svti2_transportaddresslength = strlen(netBiosName);

        if (RemapPipeNames) {
            sti2.svti2_flags = SVTI2_REMAP_PIPE_NAMES;
        }

        status = NetServerTransportAddEx( NULL, 2, (LPBYTE)&sti2 );
    }

    if (status != NERR_Success) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to add server name %1!ws! to transport %2!ws!, status %3!u!.\n",
            ServerName,
            TransportName,
            status
            );
    }
    else {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Registered server name %1!ws! on transport %2!ws!.\n",
            ServerName,
            TransportName
            );
    }

    return(status);

}  // AddServerName


NET_API_STATUS
DeleteServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName
    )
{
    NET_API_STATUS             status;
    NTSTATUS                   ntStatus;
    UCHAR                      netBiosName[ NETBIOS_NAME_LEN ];
    OEM_STRING                 netBiosNameString;
    UNICODE_STRING             unicodeName;
    BOOLEAN                    isNameRegistered;
    DWORD                      count;


    //
    // Convert the ServerName to an OEM string
    //
    RtlInitUnicodeString( &unicodeName, ServerName );

    netBiosNameString.Buffer = (PCHAR)netBiosName;
    netBiosNameString.MaximumLength = sizeof( netBiosName );

    ntStatus = RtlUpcaseUnicodeStringToOemString(
                   &netBiosNameString,
                   &unicodeName,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            ServerName,
            status
            );
        return(status);
    }

    //
    // Delete the name
    //
    status = pDeleteServerName(
                 ResourceHandle,
                 ServerName,
                 &netBiosNameString
                 );

    if (status == ERROR_IO_PENDING) {
        status = NERR_Success;
    }

    return(status);

}  // DeleteServerName


DWORD
AddWorkstationName(
    IN LPWSTR WorkstationName,
    IN LPWSTR TransportName,
    IN RESOURCE_HANDLE ResourceHandle,
    OUT HANDLE * WorkstationNameHandle
    )

/*++

Routine Description:

    This function adds an alternate workstation ( <0> ) name on a netbios
    transport by opening a TDI address object. The name remains registered
    as long as the address object is open.

Arguments:

    WorkstationName - Alternate computer name to add.

    TransportName - Transport to add the computer name on.

Return Value:

    Status - The status of the operation.

--*/

{
    DWORD                      status;
    PFILE_FULL_EA_INFORMATION  eaBuffer;
    DWORD                      eaLength;
    OBJECT_ATTRIBUTES          objectAttributes;
    IO_STATUS_BLOCK            ioStatusBlock;
    UNICODE_STRING             transportString;
    DWORD                      i;
    PTA_NETBIOS_ADDRESS        taAddress;
    UNICODE_STRING             unicodeName;
    OEM_STRING                 oemName;
    PUCHAR                     nameBuffer;


    *WorkstationNameHandle = NULL;

    //
    // Allocate an extended attribute to hold the TDI address
    //
    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
               TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
               sizeof(TA_NETBIOS_ADDRESS);

    eaBuffer = LocalAlloc(LMEM_FIXED, eaLength);

    if (eaBuffer == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory for name registration.\n"
            );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    eaBuffer->NextEntryOffset = 0;
    eaBuffer->Flags = 0;
    eaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    eaBuffer->EaValueLength = sizeof(TA_NETBIOS_ADDRESS);

    CopyMemory(
        eaBuffer->EaName,
        TdiTransportAddress,
        eaBuffer->EaNameLength+1
        );


    //
    // Build the TDI NetBIOS Address structure
    //
    taAddress = (PTA_NETBIOS_ADDRESS) (eaBuffer->EaName +
                                       TDI_TRANSPORT_ADDRESS_LENGTH + 1);
    taAddress->TAAddressCount = 1;
    taAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    taAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    taAddress->Address[0].Address[0].NetbiosNameType =
                                                 TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    //
    // Canonicalize the name by converting to an upper case OEM string,
    // padding with spaces, and ending with a 0x0.
    //
    nameBuffer =  &(taAddress->Address[0].Address[0].NetbiosName[0]);

    oemName.Buffer = nameBuffer;
    oemName.Length = 0;
    oemName.MaximumLength = NETBIOS_NAME_LEN;

    RtlInitUnicodeString(&unicodeName, WorkstationName);

    status = RtlUpcaseUnicodeStringToOemString(
                                &oemName,
                                &unicodeName,
                                FALSE
                                );

    if (status != STATUS_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            WorkstationName,
            status
            );
        LocalFree(eaBuffer);
        return(RtlNtStatusToDosError(status));
    }

    for (i=oemName.Length; i < (NETBIOS_NAME_LEN - 1); i++) {
        nameBuffer[i] = 0x20;
    }

    nameBuffer[NETBIOS_NAME_LEN-1] = 0;

    //
    // Open an address object handle.
    //
    RtlInitUnicodeString(&transportString, TransportName);

    InitializeObjectAttributes(
        &objectAttributes,
        &transportString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
                 WorkstationNameHandle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 eaBuffer,
                 eaLength
                 );

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
    }

    LocalFree(eaBuffer);

    status = RtlNtStatusToDosError(status);

    if (status != ERROR_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to register workstation name %1!ws! on transport %2!ws!, "
            L"error %3!u!.\n",
            WorkstationName,
            TransportName,
            status
            );
    }
    else {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Registered workstation name %1!ws! on transport %2!ws!.\n",
            WorkstationName,
            TransportName
            );
    }

    return(status);

} // AddWorkstationName

DNS_STATUS
AddDnsNames(
    IN     PCLUS_WORKER             Worker,
    IN     LPWSTR                   AlternateComputerName,
    IN     HKEY                     ResourceKey,
    IN     RESOURCE_HANDLE          ResourceHandle,
    IN     PDOMAIN_ADDRESS_MAPPING  DomainMapList,
    IN     DWORD                    DomainMapCount,
    IN     BOOL                     FailOnAnyError,
    OUT    PULONG                   NumberOfDnsLists,
    OUT    PDNS_LISTS *             DnsLists,
    OUT    PULONG                   NumberOfRegisteredNames
    )

/*++

Routine Description:

    For the given set of IP addresses and their corresponding DNS domains,
    build DNS records that will register the network name in the domain(s)
    associated with the IP address. Lists of A and PTR records are built which
    are used by RegisterDnsRecords to publish the name/address associations at
    the DNS server. If the names can't be registered now,
    NetNameUpdateDnsServer will attempt to register them. This is the only
    shot at building the lists; if this portion fails, then the resource is
    failed.

    This routine also checks for whether a DNS zone accepts dynamic
    updates. DnsUpdateTest will tell us if the zone is dynamic or not, and if
    dynamic and integrated with the DS as a secure zone, whether the caller
    has sufficient permission to modify the entry.

    For non-dynamic zones, Netbios ends up being the only mechanism by which a
    name gets registered and therefore, DNS registration failures are not
    fatal unless the RequireDNS property is set to true.

    If the zone is dynamic but the caller lacks sufficient permission, we view
    that as DNS having precedence over Netbios. In that case, the resource is
    failed.

 Arguments:

    Worker - used to check if we should terminate early

    AlternateComputerName - NetBIOS network name to be registered

    ResourceKey - used to log events to the system event log

    ResourceHandle - for logging to the cluster log

    DomainMapList - list of IP address domain names pairs for registration

    DomainMapCount - # of entries in DomainMapList

    NumberOfDnsLists - pointer to location of final count of entries in DnsLists

    DnsLists - array of lists that contain A and PTR listheads

    NumberOfRegisteredNames - pointer to location of final count of names that
                              actually got registered

Return Value:

    DNS_STATUS indicating whether it worked or not. If the DNS lists couldn't
    be built, always return an error.

--*/

{
    LPWSTR          fqNameARec = NULL;
    LPWSTR          fqNamePTRRec = NULL;
    DWORD           fqNameLength;
    DWORD           listheadFreeEntries = 0;
    DWORD           listheadCount = 0;
    PDNS_LISTS      dnsLists = NULL;
    DWORD           mapIndex;
    DWORD           index;
    DNS_STATUS      dnsStatus;
    DNS_STATUS      ptrRecStatus;
    PDNS_RECORD     PTRRecord;
    PDNS_RECORD     ARecord;
    LPWSTR          PTRName = NULL;
    BOOL            ARecTimeout;
    BOOL            PTRRecTimeout;

    //
    // run through the list of domain map structs and register the names where
    // appopriate
    //
    for ( mapIndex = 0; mapIndex < DomainMapCount; ++mapIndex ) {

        if ( ClusWorkerCheckTerminate( Worker )) {
            dnsStatus = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        ASSERT( DomainMapList[ mapIndex ].DomainName != NULL );

        //
        // create the fully qualified DNS name and make a copy for the PTR
        // records. DnsRecordListFree operates in a way that makes it
        // difficult to use the same buffer multiple times. It is easier to
        // allocate separate buffers for everything and let DnsRecordListFree
        // clean up.
        //
        fqNameLength = (wcslen( DomainMapList[ mapIndex ].DomainName ) +
                        wcslen( AlternateComputerName ) +
                        2                                   // one for "." and one for null
                       )
                       * sizeof( WCHAR );

        fqNameARec = LocalAlloc( LMEM_FIXED, fqNameLength );
        fqNamePTRRec = LocalAlloc( LMEM_FIXED, fqNameLength );
        if ( fqNameARec == NULL || fqNamePTRRec == NULL ) {
            dnsStatus = GetLastError();
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Can't allocate memory for DNS name for address %1!ws!, "
                              L"status %2!u!.\n",
                              DomainMapList[ mapIndex ].IpAddress,
                              dnsStatus);
            goto error_exit;
        }

        wcscpy( fqNameARec, AlternateComputerName );
        wcscat( fqNameARec, L"." );
        wcscat( fqNameARec, DomainMapList[ mapIndex ].DomainName );
        _wcslwr( fqNameARec );

        wcscpy( fqNamePTRRec, fqNameARec );

        //
        // see if this domain is updatable.
        //
        ARecTimeout = FALSE;
        dnsStatus = DnsUpdateTest(NULL,
                                  fqNameARec,
                                  0,
                                  DomainMapList[ mapIndex ].DnsServerList);

#if DBG_DNSLIST
        {
            WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
            struct in_addr addr;

            addr.s_addr = DomainMapList[ mapIndex ].DnsServerList->AddrArray[0];
            _snwprintf(buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                       L"AddDnsNames UPDATETEST: %ws on %.32ws (%hs) returned %u\n",
                       fqNameARec,
                       DomainMapList[ mapIndex ].ConnectoidName,
                       inet_ntoa( addr ),
                       dnsStatus);
            OutputDebugStringW( buf );
        }
#endif

        if ( dnsStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
            //
            // zone does not accept dynamic updates.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_INFORMATION,
                              L"%1!ws! does not accept dynamic DNS registration updates over "
                              L"adapter '%2!ws!'.\n",
                              DomainMapList[ mapIndex ].DomainName,
                              DomainMapList[ mapIndex ].ConnectoidName);

            //
            // by freeing the name storage, we'll never to be able to register
            // the name. On the other hand, if the zone was changed to be
            // dynamic while the name was online, the admin would have to wait
            // 20 minutes before we would retry the registration. I suspect
            // that cycling the name would be preferred.
            //
            LocalFree( fqNameARec );
            LocalFree( fqNamePTRRec );

            fqNameARec = NULL;
            fqNamePTRRec = NULL;

            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                continue;
            }
        } else if ( dnsStatus == DNS_ERROR_RCODE_REFUSED ) {
            //
            // secure zone and we don't have credentials to change the
            // name. fail the resource.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"%1!ws! is a secure zone and has refused the registration of "
                              L"%2!ws! over adapter '%3!ws!'.\n",
                              DomainMapList[ mapIndex ].DomainName,
                              fqNameARec,
                              DomainMapList[ mapIndex ].ConnectoidName);

            LogDnsFailureToEventLog(ResourceKey,
                                    fqNameARec,
                                    AlternateComputerName,
                                    dnsStatus,
                                    DomainMapList[ mapIndex ].ConnectoidName);

            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                continue;
            }

        } else if ( dnsStatus == ERROR_TIMEOUT ) {
            //
            // couldn't contact a server so we're not sure if it allows
            // updates or not. build the records anyway and we'll deal with it
            // during the query period
            //
            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                ARecTimeout = TRUE;
            }

        } else if ( dnsStatus == DNS_ERROR_RCODE_YXDOMAIN ) {
            //
            // the record we asked about in DnsUpdateTest is not there but it
            // can be dynamically registered.
            //
        } else if ( dnsStatus != ERROR_SUCCESS ) {
            //
            // bad juju but only fail to bring the name online if DNS is
            // required. If any one of the registrations is successful, then
            // we consider that goodness.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Testing %1!ws! for dynamic updates failed over adapter "
                              L"'%3!ws!', status %2!u!.\n",
                              fqNameARec,
                              dnsStatus,
                              DomainMapList[ mapIndex ].ConnectoidName);

            LogDnsFailureToEventLog(ResourceKey,
                                    fqNameARec,
                                    AlternateComputerName,
                                    dnsStatus,
                                    DomainMapList[ mapIndex ].ConnectoidName);

            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                continue;
            }
        }

        //
        // allocate memory to hold an array of DNS list data for the A and PTR
        // records. Separate lists are maintained for the different record types.
        //
        if (listheadFreeEntries == 0) {

            dnsStatus = GrowBlock((PCHAR *)&dnsLists,
                                  listheadCount,
                                  sizeof( *dnsLists ),
                                  &listheadFreeEntries);

            if ( dnsStatus != ERROR_SUCCESS) {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to allocate memory (1).\n");
                goto error_exit;
            }
        }

        //
        // if the FQDN is already in use in another DNS record and the
        // connectoid names for the two FQDNs we're adding are the same, then
        // we have to add this new IP address entry to the existing DNS list.
        //
        for ( index = 0; index < listheadCount; ++index ) {
            if ( _wcsicmp( dnsLists[index].A_RRSet.pFirstRR->pName,
                           fqNameARec
                         ) == 0 )
            {
#if DBG_DNSLIST
                {
                    WCHAR   buf[DNS_MAX_NAME_BUFFER_LENGTH + 50];

                    _snwprintf( buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                                L"DNS NAME MATCH w/ index %d: %ws\n",
                                index, fqNameARec );
                    OutputDebugStringW(buf);
                }
#endif
                //
                // FQDNs are equal; how about the connectoids?
                //
                if (_wcsicmp(DomainMapList[ mapIndex ].ConnectoidName,
                             dnsLists[index].ConnectoidName )
                    ==
                    0 )
                {
                        break;
                }
            }
        }

#if DBG_DNSLIST
        {
            WCHAR   buf[DNS_MAX_NAME_BUFFER_LENGTH + 80];

            _snwprintf(buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                       L"ADDING (%ws, %ws, %.32ws) to dnsList[%d], lhCount = %d, DomMapList index = %d\n",
                       fqNameARec,
                       DomainMapList[mapIndex].IpAddress,
                       DomainMapList[mapIndex].ConnectoidName,
                       index,
                       listheadCount,
                       mapIndex );
            OutputDebugStringW(buf);
        }
#endif

        if ( index == listheadCount ) {

            //
            // it's not, so init a new pair of listheads and adjust the
            // distinct listhead count
            //
            DNS_RRSET_INIT( dnsLists[ index ].A_RRSet );
            DNS_RRSET_INIT( dnsLists[ index ].PTR_RRSet );
            ++listheadCount;
            --listheadFreeEntries;
        }

        dnsLists[ index ].UpdateTestTimeout = ARecTimeout;

        if ( ClusWorkerCheckTerminate( Worker )) {
            dnsStatus = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        //
        // build the PTR records. Per DNS dev, this should be considered a
        // warning instead of a failure. We note the failures and bring the
        // name online.
        //
        PTRName = BuildUnicodeReverseName( DomainMapList[ mapIndex ].IpAddress );
        if ( PTRName != NULL ) {

            PTRRecTimeout = FALSE;
            ptrRecStatus = DnsUpdateTest(NULL,
                                         PTRName,
                                         0,
                                         DomainMapList[ mapIndex ].DnsServerList);

#if DBG_DNSLIST
            {
                WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
                struct in_addr addr;

                addr.s_addr = DomainMapList[ mapIndex ].DnsServerList->AddrArray[0];
                _snwprintf(buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                           L"AddDnsNames UPDATETEST: %ws on %.32ws (%hs) returned %u\n",
                           PTRName,
                           DomainMapList[ mapIndex ].ConnectoidName,
                           inet_ntoa( addr ),
                           ptrRecStatus);
                OutputDebugStringW( buf );
            }
#endif

            if ( ptrRecStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
                //
                // zone does not accept dynamic updates.
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_INFORMATION,
                                  L"The zone for %1!ws! does not accept dynamic DNS "
                                  L"registration updates over adapter '%2!ws!'.\n",
                                  PTRName,
                                  DomainMapList[ mapIndex ].ConnectoidName);

                LocalFree( PTRName );
                LocalFree( fqNamePTRRec );

                PTRName = NULL;
                fqNamePTRRec = NULL;

            } else if ( ptrRecStatus == DNS_ERROR_RCODE_REFUSED ) {
                //
                // secure zone and we don't have credentials to change the
                // name. fail the resource.
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"%1!ws! is a secure zone and has refused the registration of "
                                  L"%2!ws! over adapter '%3!ws!'.\n",
                                  DomainMapList[ mapIndex ].DomainName,
                                  PTRName,
                                  DomainMapList[ mapIndex ].ConnectoidName);

            } else if ( ptrRecStatus == ERROR_TIMEOUT ) {
                //
                // couldn't contact a server so we're not sure if it allows
                // updates or not. build the records anyway and we'll deal
                // with it during the query period
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"The server for %1!ws! could not be contacted over adapter '%2!ws!' "
                                  L"to determine whether it accepts DNS registration updates. "
                                  L"Retrying at a later time.\n",
                                  PTRName,
                                  DomainMapList[ mapIndex ].ConnectoidName);

                PTRRecTimeout = TRUE;
                ptrRecStatus = ERROR_SUCCESS;

            } else if ( ptrRecStatus == DNS_ERROR_RCODE_YXDOMAIN ) {
                //
                // the record we asked about in DnsUpdateTest is not there but
                // it can be dynamically registered.
                //
                ptrRecStatus = ERROR_SUCCESS;

            } else if ( ptrRecStatus != ERROR_SUCCESS ) {
                //
                // bad juju - log the error but don't fail the name since
                // these are just lowly PTR records.
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"Testing %1!ws! for dynamic updates over adapter '%3!ws!' "
                                  L"failed, status %2!u!.\n",
                                  PTRName,
                                  ptrRecStatus,
                                  DomainMapList[ mapIndex ].ConnectoidName);
            }

            if ( ptrRecStatus == ERROR_SUCCESS ) {
                //
                // build the PTR rec
                //
                PTRRecord = DnsRecordBuild_W(&dnsLists[ index ].PTR_RRSet,
                                             PTRName,
                                             DNS_TYPE_PTR,
                                             TRUE,
                                             0,
                                             1,
                                             &fqNamePTRRec);

                if (PTRRecord != NULL) {

                    //
                    // BUGBUG - DNS doesn't free the owner and data fields for
                    // us in DnsRecordListFree. Set these flags until we sort
                    // out what is happening
                    //
                    SET_FREE_OWNER( PTRRecord );
                    SET_FREE_DATA( PTRRecord );

                    //
                    // set the time to live so clients don't beat up the
                    // server
                    //
                    PTRRecord->dwTtl = 20 * 60;   // 20 minutes

                    //
                    // "consume" the pointers to name strings. If we got this
                    // far, then these pointers have been captured in the DNS
                    // record and will be freed when the record is freed by
                    // DnsRecordListFree.
                    //
                    PTRName = NULL;
                    fqNamePTRRec = NULL;
                }
                else {
                    (NetNameLogEvent)(ResourceHandle,
                                      LOG_WARNING,
                                      L"Error building PTR record for owner %1!ws!, addr %2!ws!, status %3!u!\n",
                                      fqNameARec,
                                      DomainMapList[ mapIndex ].IpAddress,
                                      ptrRecStatus = GetLastError());

                    LocalFree( PTRName );
                    LocalFree( fqNamePTRRec );

                    PTRName = NULL;
                    fqNamePTRRec = NULL;
                }

            } // if ptrRecStatus == ERROR_SUCCESS

        } // if PTRName != NULL
        else {
            ptrRecStatus = GetLastError();
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Error building PTR name for owner %1!ws!, addr %2!ws!, status %3!u!\n",
                              fqNameARec,
                              DomainMapList[ mapIndex ].IpAddress,
                              ptrRecStatus);

            LocalFree( fqNamePTRRec );
            fqNamePTRRec = NULL;
        }

        //
        // build the A rec
        //
        ARecord = DnsRecordBuild_W(&dnsLists[ index ].A_RRSet,
                                   fqNameARec,
                                   DNS_TYPE_A,
                                   TRUE,
                                   0,
                                   1,
                                   &DomainMapList[ mapIndex ].IpAddress);

        if ( ARecord == NULL ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Error building A rec for owner %1!ws!, addr %2!ws!, status %3!u!\n",
                              fqNameARec,
                              DomainMapList[ mapIndex ].IpAddress,
                              dnsStatus = GetLastError());

            goto error_exit;
        }

        //
        // set the time to live so clients don't beat up the server
        //
        ARecord->dwTtl = 20 * 60;   // 20 minutes

        //
        // BUGBUG - DNS doesn't free the owner and data fields for us in
        // DnsRecordListFree. Set these flags until we sort out what is
        // happening
        //

        SET_FREE_OWNER( ARecord );
        SET_FREE_DATA( ARecord );

        //
        // "consume" this pointer as well
        //
        fqNameARec = NULL;

        //
        // capture the DNS server list and connectoid name for this entry
        //
        dnsLists[ index ].DnsServerList = DomainMapList[ mapIndex ].DnsServerList;
        DomainMapList[ mapIndex ].DnsServerList = NULL;

        dnsLists[ index ].ConnectoidName = ResUtilDupString( DomainMapList[ mapIndex ].ConnectoidName );
        if ( dnsLists[ index ].ConnectoidName == NULL ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Unable to allocate memory .\n");
            goto error_exit;
        }
    } // end of for each entry in DomainMapCount

    //
    // update the DNS server with the records that were just created
    //
    *NumberOfRegisteredNames = 0;
    for( index = 0; index < listheadCount; ++index ) {

        if ( ClusWorkerCheckTerminate( Worker )) {
            dnsStatus = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        //
        // if we made it this far, we know that the server is dynamic or we
        // timed out trying to figure that out. For the timeout case, we'll
        // assume that the servers are dynamic and let NetNameUpdateDnsServer
        // discover otherwise.
        //
        dnsLists[ index ].ForwardZoneIsDynamic = TRUE;
        dnsLists[ index ].ReverseZoneIsDynamic = TRUE;

        dnsStatus = RegisterDnsRecords(&dnsLists[ index ],
                                       AlternateComputerName,
                                       ResourceKey,
                                       ResourceHandle,
                                       TRUE,                    /* LogRegistration */
                                       NumberOfRegisteredNames);

        if ( dnsStatus != ERROR_SUCCESS && FailOnAnyError ) {
            goto error_exit;
        }
    }

    *NumberOfDnsLists = listheadCount;
    *DnsLists = dnsLists;

    return dnsStatus;

error_exit:

    if ( dnsLists != NULL ) {
        while ( listheadCount-- ) {
            DnsRecordListFree(
                dnsLists[listheadCount].PTR_RRSet.pFirstRR,
                DnsFreeRecordListDeep );

            DnsRecordListFree(
                dnsLists[listheadCount].A_RRSet.pFirstRR,
                DnsFreeRecordListDeep );

            if ( dnsLists[listheadCount].DnsServerList != NULL ) {
                LocalFree( dnsLists[listheadCount].DnsServerList );
            }

            if ( dnsLists[listheadCount].ConnectoidName != NULL ) {
                LocalFree( dnsLists[listheadCount].ConnectoidName );
            }
        }

        LocalFree( dnsLists );
    }

    if ( PTRName != NULL ) {
        LocalFree( PTRName );
    }

    if ( fqNamePTRRec != NULL ) {
        LocalFree( fqNamePTRRec );
    }

    if ( fqNameARec != NULL ) {
        LocalFree( fqNameARec );
    }

    *NumberOfDnsLists = 0;
    *NumberOfRegisteredNames = 0;
    *DnsLists = NULL;

    return dnsStatus;
} // AddDnsNames

VOID
LogDnsFailureToEventLog(
    IN  HKEY    ResourceKey,
    IN  LPWSTR  DnsName,
    IN  LPWSTR  ResourceName,
    IN  DWORD   Status,
    IN  LPWSTR  ConnectoidName
    )

/*++

Routine Description:

    Log dns name failures to the event log

Arguments:

    DnsName - FQ DNS name that failed to be registered

    ResourceName - associated resource

    Status - status returned by DNSAPI

Return Value:

    NONE

--*/

{
    LPWSTR  msgBuff;
    DWORD   msgBytes;

    msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             Status,
                             0,
                             (LPWSTR)&msgBuff,
                             0,
                             NULL);

    if ( msgBytes > 0 ) {
        ClusResLogSystemEventByKeyData3(ResourceKey,
                                        LOG_UNUSUAL,
                                        RES_NETNAME_DNS_REGISTRATION_MISSING,
                                        sizeof( Status ),
                                        &Status,
                                        DnsName,
                                        msgBuff,
                                        ConnectoidName);

        LocalFree( msgBuff );
    }

} // LogDnsFailureToEventLog

//
// Exported Routines
//

LPWSTR
BuildUnicodeReverseName(
    IN  LPWSTR  IpAddress
    )

/*++

Routine Description:

    Given an Ip address, build a reverse DNS name for publishing as
    a PTR record

Arguments:

    IpAddress - unicode version of dotted decimal IP address

Return Value:

    address of pointer to buffer with reverse name. Null if an error occured

--*/

{
    ULONG ipAddress;
    PCHAR ansiReverseName;
    PCHAR pAnsi;
    ULONG ansiNameLength;
    PWCHAR unicodeReverseName;
    PWCHAR pUni;

    CHAR ansiIpAddress[ 64 ];

    //
    // convert to ansi, have DNS create the name, and then convert back to
    // unicode
    //

    wcstombs( ansiIpAddress, IpAddress, sizeof( ansiIpAddress ));
    ipAddress = inet_addr( ansiIpAddress );

    ansiReverseName = DnsCreateReverseNameStringForIpAddress(
                          (IP4_ADDRESS)ipAddress
                          );

    if ( ansiReverseName == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    ansiNameLength = strlen( ansiReverseName ) + 1;
    unicodeReverseName = LocalAlloc(LMEM_FIXED,
                                    ansiNameLength * sizeof(WCHAR));

    if ( unicodeReverseName == NULL ) {
        LocalFree( ansiReverseName );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    //
    // convert to Unicode
    //
    mbstowcs( unicodeReverseName, ansiReverseName, ansiNameLength );

    LocalFree( ansiReverseName );

    return unicodeReverseName;
} // BuildUnicodeReverseName

DWORD
RegisterDnsRecords(
    IN  PDNS_LISTS       DnsLists,
    IN  LPWSTR           NetworkName,
    IN  HKEY             ResourceKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  BOOL             LogRegistration,
    OUT PULONG           NumberOfRegisteredNames
    )

/*++

Routine Description:

    Register the A and PTR records specified in DnsLists with the DNS server.

Arguments:

    DnsLists - pointer to the list of structs holding the record sets to
               be registered

    NetworkName - host name portion of name being registered 

    ResourceKey - used to log events to the event viewer

    ResourceHandle - used to log messages in the cluster log

    LogRegistration - TRUE if the successful registration should be logged to the cluster log

    NumberOfRegisteredNames - pointer that receives count of successful registrations

Return Value:

    None

--*/

{
    DNS_STATUS      ARecStatus;
    DNS_STATUS      PTRRecStatus;
    DNS_STATUS      dnsStatus;
    PDNS_RECORD     dnsRecord;
    PDNS_RECORD     nextDnsRecord;
    ULONG           registeredCount = 0;

    //
    // check the status of DnsUpdateTest on this name. If we've previously
    // timed out, then try again.
    //
    if ( DnsLists->UpdateTestTimeout ) {

        DnsLists->UpdateTestTimeout = FALSE;
        dnsStatus = DnsUpdateTest(NULL,
                                  DnsLists->A_RRSet.pFirstRR->pName,
                                  0,
                                  DnsLists->DnsServerList);

#if DBG_DNSLIST
        {
            WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
            struct in_addr addr;

            addr.s_addr = DnsLists->DnsServerList->AddrArray[0];
            _snwprintf(buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                       L"RegisterDnsRecords UPDATETEST: %ws on %.32ws (%hs) returned %u\n",
                       DnsLists->A_RRSet.pFirstRR->pName,
                       DnsLists->ConnectoidName,
                       inet_ntoa( addr ),
                       dnsStatus);
            OutputDebugStringW( buf );
        }
#endif

        if ( dnsStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
            //
            // zone does not accept dynamic updates. Invalidate this entry
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_INFORMATION,
                              L"%1!ws! does not accept dynamic DNS registration updates over "
                              L"adapter '%2!ws!'.\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              DnsLists->ConnectoidName);

            DnsLists->ForwardZoneIsDynamic = FALSE;
            return dnsStatus;

        } else if ( dnsStatus == DNS_ERROR_RCODE_REFUSED ) {
            //
            // secure zone and we don't have credentials to change the
            // name. fail the resource.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"The registration of %1!ws! in a secure zone was refused "
                              L"because the record was already registered but owned by a "
                              L"different user.\n",
                              DnsLists->A_RRSet.pFirstRR->pName);

            if (!DnsLists->AErrorLogged ||
                dnsStatus != DnsLists->LastARecQueryStatus ) {

                LogDnsFailureToEventLog(ResourceKey,
                                        DnsLists->A_RRSet.pFirstRR->pName,
                                        NetworkName,
                                        dnsStatus,
                                        DnsLists->ConnectoidName);

                DnsLists->AErrorLogged = TRUE;
            }

            DnsLists->LastARecQueryStatus = dnsStatus;
            return dnsStatus;

        } else if ( dnsStatus == ERROR_TIMEOUT ) {

            //
            // couldn't contact a server so we're not sure if it allows
            // updates or not.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"The server for %1!ws! could not be contacted over adapter "
                              L"'%2!ws!' to determine whether it accepts DNS registration "
                              L"updates. Retrying at a later time.\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              DnsLists->ConnectoidName);

            if (!DnsLists->AErrorLogged ) {
                LogDnsFailureToEventLog(ResourceKey,
                                        DnsLists->A_RRSet.pFirstRR->pName,
                                        NetworkName,
                                        dnsStatus,
                                        DnsLists->ConnectoidName);

                DnsLists->AErrorLogged = TRUE;
            }

            DnsLists->UpdateTestTimeout = TRUE;
            return dnsStatus;

        } else if ( dnsStatus == DNS_ERROR_RCODE_YXDOMAIN ) {
            //
            // the record we asked about in DnsUpdateTest is not there but it
            // can be dynamically registered.
            //
        } else if ( dnsStatus != ERROR_SUCCESS ) {
            //
            // bad juju
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Testing %1!ws! for dynamic updates failed over adapter "
                              L"'%3!ws!', status %2!u!.\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              dnsStatus,
                              DnsLists->ConnectoidName);

            if (!DnsLists->AErrorLogged ||
                dnsStatus != DnsLists->LastARecQueryStatus ) {

                LogDnsFailureToEventLog(ResourceKey,
                                        DnsLists->A_RRSet.pFirstRR->pName,
                                        NetworkName,
                                        dnsStatus,
                                        DnsLists->ConnectoidName);

                DnsLists->AErrorLogged = TRUE;
            }
            DnsLists->LastARecQueryStatus = dnsStatus;
            return dnsStatus;
        }

        //
        // since we previously timed out but (at this point) are going to
        // register the records, adjust the logging flag so we get this time
        // recorded.
        //
        LogRegistration = TRUE;

    } // end if the update test had previously timed out

#if DBG
    (NetNameLogEvent)(ResourceHandle,
                      LOG_INFORMATION,
                      L"Registering %1!ws! over '%2!ws!'\n",
                      DnsLists->A_RRSet.pFirstRR->pName,
                      DnsLists->ConnectoidName);
#endif

    //
    // register the A Recs
    //
    ARecStatus = DnsReplaceRecordSetW(DnsLists->A_RRSet.pFirstRR,
                                      DNS_UPDATE_SECURITY_USE_DEFAULT,
                                      NULL,
                                      DnsLists->DnsServerList,
                                      NULL);

    if ( ARecStatus == DNS_ERROR_RCODE_NO_ERROR ) {

        ++registeredCount;
        DnsLists->AErrorLogged = FALSE;

        if ( LogRegistration ) {
            PDNS_RECORD dnsRecord;

            dnsRecord = DnsLists->A_RRSet.pFirstRR;
            while ( dnsRecord != NULL ) {
                struct in_addr ipAddress;

                ipAddress.s_addr = dnsRecord->Data.A.IpAddress;
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_INFORMATION,
                                  L"Registered DNS name %1!ws! with IP Address %2!hs! "
                                  L"over adapter '%3!ws!'.\n",
                                  dnsRecord->pName,
                                  inet_ntoa( ipAddress ),
                                  DnsLists->ConnectoidName);

                dnsRecord = dnsRecord->pNext;
            }
        }
    } else {
        //
        // it failed. log an error to the cluster log and change the worker
        // thread polling period. If we haven't logged an event before or the
        // error is different from the previous error, log it in the event log
        //
        if ( ARecStatus == ERROR_TIMEOUT ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"The DNS server couldn't be contacted to update the registration "
                              L"for %1!ws!. Retrying at a later time.\n",
                              DnsLists->A_RRSet.pFirstRR->pName);
        }
        else {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Failed to register DNS A records for owner %1!ws! over "
                              L"adapter '%3!ws!', status %2!u!\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              ARecStatus,
                              DnsLists->ConnectoidName);
        }

        NetNameWorkerCheckPeriod = NETNAME_WORKER_PROBLEM_CHECK_PERIOD;

        if (!DnsLists->AErrorLogged ||
            ARecStatus != DnsLists->LastARecQueryStatus ) {

            LogDnsFailureToEventLog(ResourceKey,
                                    DnsLists->A_RRSet.pFirstRR->pName,
                                    NetworkName,
                                    ARecStatus,
                                    DnsLists->ConnectoidName);

            DnsLists->AErrorLogged = TRUE;
        }
    }

    //
    // Record the status of the registration in the list for this
    // owner. NetnameLooksAlive will check this value to determine the health
    // of this set of registrations. Use interlocked to co-ordinate with
    // Is/LooksAlive.
    //
    InterlockedExchange( &DnsLists->LastARecQueryStatus, ARecStatus );

    //
    // don't bother with PTR recs if bad juju happened with the A recs. we'll
    // try to register them the next time the DNS check thread runs
    //
    if ( ARecStatus == DNS_ERROR_RCODE_NO_ERROR ) {

        //
        // dynamic DNS requires that the pName must be the same for a given
        // set of records in an RRSET. The pName for a set of PTR records will
        // always be different. Maintaining a huge pile of RRSets, one per PTR
        // record is ridiculous (or at least I thought so when I orginally
        // wrote this; in hind sight, this was a bad decision - charlwi).
        //
        // AddDnsNames linked all these recs together. Now we have to register
        // them one at time by remembering the link, breaking it, registering,
        // restoring the link and moving on to the next record.
        //
        // The ErrorLogged logic is broken since we don't keep the status for
        // each (separate) registration. It's an approximation at best.
        //
        // In addition, it is possible for the server to accept A records
        // dynamically but disallow PTR records hence the check to see if we
        // have records to register is up front.
        //
        // Finally, we use ModifyRecordsInSet instead of ReplaceRecordSet due
        // to the organization of the PTR RRSET. When two names map to the
        // same IP address, we have identical reverse addr strings in more
        // than one DNS_LIST entry. If ReplaceRecordSet were used instead, it
        // would delete all but one of the reverse address mappings. In hind
        // sight, each DNS_LIST entry should have hosted either an A or PTR
        // RRSet but not both.
        //

        dnsRecord = DnsLists->PTR_RRSet.pFirstRR;
        while ( dnsRecord != NULL ) {

            nextDnsRecord = dnsRecord->pNext;
            dnsRecord->pNext = NULL;

            PTRRecStatus = DnsModifyRecordsInSet_W(dnsRecord,
                                                   NULL,
                                                   DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                   NULL,
                                                   DnsLists->DnsServerList,
                                                   NULL);

            if ( PTRRecStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                DnsLists->PTRErrorLogged = FALSE;

                if ( LogRegistration ) {
                    (NetNameLogEvent)(ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Registered DNS PTR record %1!ws! for host %2!ws! "
                                      L"over adapter '%3!ws!'\n",
                                      dnsRecord->pName,
                                      DnsLists->A_RRSet.pFirstRR->pName,
                                      DnsLists->ConnectoidName);
                }
            } else {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Failed to register DNS PTR record %1!ws! for host "
                                  L"%2!ws! over adapter '%4!ws!', status %3!u!\n",
                                  dnsRecord->pName,
                                  DnsLists->A_RRSet.pFirstRR->pName,
                                  PTRRecStatus,
                                  DnsLists->ConnectoidName);

                if (!DnsLists->PTRErrorLogged ||
                    PTRRecStatus != DnsLists->LastPTRRecQueryStatus )
                {
                    DnsLists->PTRErrorLogged = TRUE;
                }
            }

            InterlockedExchange(&DnsLists->LastPTRRecQueryStatus,
                                PTRRecStatus);

            dnsRecord->pNext = nextDnsRecord;
            dnsRecord = nextDnsRecord;
        }
    } // end if A rec registration was successful
    else {
        //
        // since we don't end up trying the PTR records because of the A rec
        // failure, we'll propagate the A rec error code in the PTR status.
        //
        InterlockedExchange(&DnsLists->LastPTRRecQueryStatus,
                            ARecStatus);
    }

    *NumberOfRegisteredNames = registeredCount;

    return ARecStatus;
} // RegisterDnsRecords

VOID
DeleteAlternateComputerName(
    IN LPWSTR           AlternateComputerName,
    IN HANDLE *         NameHandleList,
    IN DWORD            NameHandleCount,
    IN RESOURCE_HANDLE  ResourceHandle
    )
{
    NET_API_STATUS  status;

    if ( NameHandleCount > 0 ) {
        status = DeleteServerName(ResourceHandle, AlternateComputerName);

        if (status != ERROR_SUCCESS) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Failed to delete server name %1!ws!, status %2!u!.\n",
                              AlternateComputerName,
                              status);
        }
    }

    while ( NameHandleCount-- ) {
        CloseHandle(NameHandleList[NameHandleCount]);
        NameHandleList[NameHandleCount] = NULL;

        (NetNameLogEvent)(ResourceHandle,
                          LOG_INFORMATION,
                          L"Deleted workstation name %1!ws! from transport %2!u!.\n",
                          AlternateComputerName,
                          NameHandleCount
                          );
    }

} // DeleteAlternateComputerName

DWORD
AddAlternateComputerName(
    IN     PCLUS_WORKER             Worker,
    IN     PNETNAME_RESOURCE        Resource,
    IN     LPWSTR *                 TransportList,
    IN     DWORD                    TransportCount,
    IN     PDOMAIN_ADDRESS_MAPPING  DomainMapList,
    IN     DWORD                    DomainMapCount
    )
{
    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;
    LPWSTR          alternateComputerName = Resource->Params.NetworkName;
    DWORD           status = ERROR_SUCCESS;
    DWORD           setValueStatus;
    DWORD           i;
    DWORD           handleCount = 0;
    LONG            numberOfDnsNamesRegistered = 0;
    PWCHAR          machinePwd = NULL;

    //
    // clear all the status values so we don't show left over crud if we fail
    // early on.
    //
    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_NETBIOS,
                                          0,
                                          NULL);
    ASSERT( setValueStatus == ERROR_SUCCESS );

    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_DNS,
                                          0,
                                          NULL);
    ASSERT( setValueStatus == ERROR_SUCCESS );

    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_KERBEROS,
                                          0,
                                          NULL);
    ASSERT( setValueStatus == ERROR_SUCCESS );

    //
    // register DNS name(s) with server
    //
    status = AddDnsNames(Worker,
                         alternateComputerName,
                         Resource->ResKey,
                         resourceHandle,
                         DomainMapList,
                         DomainMapCount,
                         Resource->Params.RequireDNS,       // FailOnAnyError
                         &Resource->NumberOfDnsLists,
                         &Resource->DnsLists,
                         &numberOfDnsNamesRegistered);

    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_DNS,
                                          status,
                                          NULL);
    ASSERT( setValueStatus == ERROR_SUCCESS );

    if ( status == ERROR_OPERATION_ABORTED || 
         ( status != ERROR_SUCCESS && Resource->Params.RequireDNS ))
    {
        if ( status != ERROR_OPERATION_ABORTED && Resource->Params.RequireDNS ) {
            LPWSTR  msgBuff;
            DWORD   msgBytes;

            msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_SYSTEM,
                                     NULL,
                                     status,
                                     0,
                                     (LPWSTR)&msgBuff,
                                     0,
                                     NULL);

            if ( msgBytes > 0 ) {
                
                ClusResLogSystemEventByKey1(Resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_DNS_REGISTRATION_FAILED,
                                            msgBuff);

                LocalFree( msgBuff );
            } else {
                ClusResLogSystemEventByKeyData(Resource->ResKey,
                                               LOG_CRITICAL,
                                               RES_NETNAME_DNS_REGISTRATION_FAILED_STATUS,
                                               sizeof( status ),
                                               &status);
            }
        }

        return status;
    }

#ifdef COMPOBJ_SUPPORT
    if ( Resource->Params.RequireKerberos ) {
        //
        // create the backing computer account in the DS for kerb. authentication
        //
        status = NetNameAddComputerObject( Worker, Resource, &machinePwd );

        Resource->KerberosStatus = status;
        Resource->DoKerberosCheck = ( status == ERROR_SUCCESS );

        setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                              PARAM_NAME__STATUS_KERBEROS,
                                              status,
                                              NULL);
        ASSERT( setValueStatus == ERROR_SUCCESS );


        if ( status != ERROR_SUCCESS ) {
            return status;
        }
    } else {
        //
        // we need some cluster wide mechanism (a property?) to indicate that
        // we need to delete the CO before online completes.
        //
        if ( Resource->ObjectGUID != NULL ) {
            status = NetNameDeleteComputerObject( Resource );

            //
            // ISSUE: check for comm error and post warning that we're
            // bringing the name online but that authentication may fail due
            // to a residual CO we can't detect.
            //
            if ( status == ERROR_NO_SUCH_DOMAIN ) {
            }
            else if ( status != ERROR_SUCCESS && status != NERR_UserNotFound ) {

                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Kerberos is disabled for this resource but a computer account "
                                  L"exists in the directory service and it can't be deleted by the cluster "
                                  L"service. The computer account must be deleted before the resource "
                                  L"can be brought online. error %1!u!\n",
                                  status);

                return status;
            }
        }

        Resource->DoKerberosCheck = FALSE;
    }
#else
    Resource->DoKerberosCheck = FALSE;
#endif

    //
    // bring NetBT names online
    //
    status = ERROR_SUCCESS;
    for (i=0; i<TransportCount; i++) {

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        status = AddServerName(resourceHandle,
                               alternateComputerName,
                               Resource->Params.NetworkRemap,
                               TransportList[i],
                               (BOOLEAN) ((i == 0) ? TRUE : FALSE),     // CheckNameFirst
                               machinePwd);

        if ( status == NERR_ServerNotStarted ) {
            status = ERROR_SUCCESS;
        }

        if ( status != ERROR_SUCCESS ) {
            goto cleanup;
        }

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        status = AddWorkstationName(
                     alternateComputerName,
                     TransportList[i],
                     resourceHandle,
                     &(Resource->NameHandleList[i])
                     );

        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

        handleCount++;
    }

    //
    // if didn't register any NetBt or DNS names, then fail the netname.
    //
    if ( TransportCount == 0 && numberOfDnsNamesRegistered == 0 ) {
        ClusResLogSystemEvent1(LOG_CRITICAL,
                               RES_NETNAME_NOT_REGISTERED,
                               alternateComputerName);

        status = ERROR_RESOURCE_FAILED;
    }

cleanup:
    if ( machinePwd != NULL ) {
        PWCHAR  p = machinePwd;

        while ( *p != UNICODE_NULL ) {
            *p++ = UNICODE_NULL;
        }

        HeapFree( GetProcessHeap(), 0, machinePwd );
    }

    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_NETBIOS,
                                          status,
                                          NULL);
    ASSERT( setValueStatus == ERROR_SUCCESS );

    return status;

} // AddAlternateComputerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\netname.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    netname.c

Abstract:

    Resource DLL for a network name.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

    Severely whacked on by Charlie Wickham (charlwi)

--*/

#define UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include <lm.h>
#include <srvann.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <adserr.h>
#include "netname.h"
#include "nameutil.h"
#include "namechk.h"
#include "clusudef.h"
#include "clusstrs.h"

//
// Constants
//

#define LOG_CURRENT_MODULE              LOG_MODULE_NETNAME

#define IP_ADDRESS_RESOURCETYPE_NAME    CLUS_RESTYPE_NAME_IPADDR

//
// Macros
//
#define ARGUMENT_PRESENT( ArgumentPointer )   (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )


//
// turn on _INSTRUMENTED_LOCKS if you're trying to figure out where the lock
// is getting orphaned
//

//#define _INSTRUMENTED_LOCKS
#ifdef _INSTRUMENTED_LOCKS

#define NetNameAcquireResourceLock()                                \
{                                                                   \
    DWORD status;                                                   \
    status = WaitForSingleObject(NetNameResourceMutex, INFINITE);   \
    if ( status == WAIT_ABANDONED ) {                               \
        OutputDebugStringW( L"Resource List Mutex Abandoned!\n" );  \
        DebugBreak();                                               \
    }                                                               \
    (NetNameLogEvent)(L"rtNetwork Name",                            \
                      LOG_INFORMATION,                              \
                      L"++NNMutex (line %1!u!)\n",                  \
                      __LINE__);                                    \
}

#define NetNameReleaseResourceLock()                                \
{                                                                   \
    BOOL    released;                                               \
    (NetNameLogEvent)(L"rtNetwork Name",                            \
                      LOG_INFORMATION,                              \
                      L"--NNMutex (line %1!u!)\n",                  \
                      __LINE__);                                    \
    released = ReleaseMutex(NetNameResourceMutex);                  \
}

#define NetNameAcquireDnsListLock( _res_ )                          \
{                                                                   \
    DWORD status;                                                   \
    status = WaitForSingleObject((_res_)->DnsListMutex, INFINITE);  \
    if ( status == WAIT_ABANDONED ) {                               \
        OutputDebugStringW( L"DNS List Mutex Abandoned!\n" );       \
        DebugBreak();                                               \
    }                                                               \
    (NetNameLogEvent)(L"rtNetwork Name",                            \
                      LOG_INFORMATION,                              \
                      L"++DNSMutex (res %1!X! line %2!u!)\n",       \
                      _res_, __LINE__);                             \
}

#define NetNameReleaseDnsListLock( _res_ )                      \
{                                                               \
    BOOL    released;                                           \
    (NetNameLogEvent)(L"rtNetwork Name",                        \
                      LOG_INFORMATION,                          \
                      L"--DNSMutex (res %1!X! line %2!u!)\n",   \
                      _res_, __LINE__);                         \
    released = ReleaseMutex((_res_)->DnsListMutex);             \
    if ( !released ) {                                          \
        (NetNameLogEvent)(L"rtNetwork Name",                    \
                          LOG_INFORMATION,                      \
                          L"ERROR %1!d! releasing DNS mutex (res %2!X! line %3!u!)\n", \
                          GetLastError(), _res_, __LINE__);     \
    }                                                           \
}

#else

#define NetNameAcquireResourceLock()                                \
{                                                                   \
    DWORD status;                                                   \
    status = WaitForSingleObject(NetNameResourceMutex, INFINITE);   \
}

#define NetNameReleaseResourceLock()                \
{                                                   \
    BOOL    released;                               \
    released = ReleaseMutex(NetNameResourceMutex);  \
}

#define NetNameAcquireDnsListLock( _res_ )                                  \
{                                                                           \
    DWORD status;                                                           \
    status = WaitForSingleObject((_res_)->DnsListMutex, INFINITE);          \
}

#define NetNameReleaseDnsListLock( _res_ )                                  \
{                                                                           \
    BOOL    released;                                                       \
    released = ReleaseMutex((_res_)->DnsListMutex);                         \
}
#endif

//
// Local Types.
//

#define PARAM_MIN__FLAGS    0
#define PARAM_MAX__FLAGS    0xFFFFFFFF
#define PARAM_DEFAULT__FLAGS    0

//
// Local Variables
//
// Mutex for sync'ing access to the list of resources as well as each resource
// block
//
HANDLE  NetNameResourceMutex = NULL;

//
// The checking of DNS names requires talking to a DNS server, hence this work
// is spun off to a separate thread. The resource context blocks are linked
// together on a doubly linked list and are ref counted to make sure that a
// block isn't changed during offline processing while its DNS name records
// are being checked.
//
// The NetNameWorkerTerminate event signals the worker routine to exit.
//
HANDLE  NetNameWorkerTerminate;

//
// NetNameWorkerPendingResources is used to signal the worker thread that a
// name is moving through a pending state. It is possible for an online
// operation to time out when lots of names go online
// simultaneously. Similarly, an offline might require communication with a DC
// which could take a while. The worker thread will periodically report back
// to resmon that we're making progress.
//
HANDLE  NetNameWorkerPendingResources;

//
// list head for resource context block linkage
//
LIST_ENTRY  NetNameResourceListHead;

//
// the amount of seconds the worker thread waits before doing something. This
// includes querying the DNS server to make sure registrations are correct and
// reporting back to resmon when names are going online. This value gets
// smaller when server communication is suspect.
//
ULONG   NetNameWorkerCheckPeriod;

//
// ladies and gentlemen, the worker thread
//
HANDLE  NetNameWorkerThread;

//
// Count of opened NetName resources.
//   Incremented in NetNameOpen
//   Decremented in NetNameClose
//
DWORD   NetNameOpenCount = 0;

//
// account description string used for computer objects
//
LPWSTR  NetNameCompObjAccountDesc;

//
// Network Name resource read-write private properties.
//
// IF YOU CHANGE THESE, YOU MUST MAKE THE CORRESPONDING CHANGE IN THE COMBINED
// PROP TABLE BELOW
//
RESUTIL_PROPERTY_ITEM
NetNameResourcePrivateProperties[] = {
    {
        PARAM_NAME__NAME,
        NULL,
        CLUSPROP_FORMAT_SZ,
        0, 0, 0,
        RESUTIL_PROPITEM_REQUIRED,
        FIELD_OFFSET(NETNAME_PARAMS,NetworkName)
    },
    {
        PARAM_NAME__REMAP,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__REMAP,
        0, 1, 0,
        FIELD_OFFSET(NETNAME_PARAMS,NetworkRemap)
    },
    {
        PARAM_NAME__REQUIRE_DNS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__REQUIRE_DNS,
        0, 1, 0,
        FIELD_OFFSET(NETNAME_PARAMS,RequireDNS)
    },
    {
        PARAM_NAME__REQUIRE_KERBEROS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__REQUIRE_KERBEROS,
        0, 1, 0,
        FIELD_OFFSET(NETNAME_PARAMS,RequireKerberos)
    },
    {
        PARAM_NAME__UPDATE_INTERVAL,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__UPDATE_INTERVAL,
        PARAM_MINIMUM__UPDATE_INTERVAL,
        PARAM_MAXIMUM__UPDATE_INTERVAL,
        0,
        FIELD_OFFSET(NETNAME_PARAMS,UpdateInterval)
    },
    { NULL, NULL, 0, 0, 0, 0 }
};

//
// Network Name resource read-only private properties.
//
// IF YOU CHANGE THESE, YOU MUST MAKE THE CORRESPONDING CHANGE IN THE COMBINED
// PROP TABLE BELOW
//
RESUTIL_PROPERTY_ITEM
NetNameResourceROPrivateProperties[] = {
    {
        PARAM_NAME__RANDOM,
        NULL,
        CLUSPROP_FORMAT_BINARY,
        0, 0, 0,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,NetworkRandom)
    },
    {
        PARAM_NAME__STATUS_NETBIOS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        0, 0, 0xFFFFFFFF,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,StatusNetBIOS)
    },
    {
        PARAM_NAME__STATUS_DNS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        0, 0, 0xFFFFFFFF,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,StatusDNS)
    },
    {
        PARAM_NAME__STATUS_KERBEROS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        0, 0, 0xFFFFFFFF,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,StatusKerberos)
    },
    {
        PARAM_NAME__NEXT_UPDATE,
        NULL,
        CLUSPROP_FORMAT_BINARY,
        0, 0, 0,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,NextUpdate)
    },
    { NULL, NULL, 0, 0, 0, 0 }
};

//
// Network Name resource combined private properties.
//
// IF YOU CHANGE THESE, YOU MUST MAKE THE CORRESPONDING CHANGE IN THE EITHER
// THE READONLY OR READWRITE PROP TABLE ABOVE
//
RESUTIL_PROPERTY_ITEM
NetNameResourceCombinedPrivateProperties[] = {
    {
        PARAM_NAME__NAME,
        NULL,
        CLUSPROP_FORMAT_SZ,
        0, 0, 0,
        RESUTIL_PROPITEM_REQUIRED,
        FIELD_OFFSET(NETNAME_PARAMS,NetworkName)
    },
    {
        PARAM_NAME__REMAP,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__REMAP,
        0, 1, 0,
        FIELD_OFFSET(NETNAME_PARAMS,NetworkRemap)
    },
    {
        PARAM_NAME__REQUIRE_DNS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__REQUIRE_DNS,
        0, 1, 0,
        FIELD_OFFSET(NETNAME_PARAMS,RequireDNS)
    },
    {
        PARAM_NAME__REQUIRE_KERBEROS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__REQUIRE_KERBEROS,
        0, 1, 0,
        FIELD_OFFSET(NETNAME_PARAMS,RequireKerberos)
    },
    {
        PARAM_NAME__UPDATE_INTERVAL,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        PARAM_DEFAULT__UPDATE_INTERVAL,
        PARAM_MINIMUM__UPDATE_INTERVAL,
        PARAM_MAXIMUM__UPDATE_INTERVAL,
        0,
        FIELD_OFFSET(NETNAME_PARAMS,UpdateInterval)
    },
    {
        PARAM_NAME__RANDOM,
        NULL,
        CLUSPROP_FORMAT_BINARY,
        0, 0, 0,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,NetworkRandom)
    },
    {
        PARAM_NAME__STATUS_NETBIOS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        0, 0, 0xFFFFFFFF,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,StatusNetBIOS)
    },
    {
        PARAM_NAME__STATUS_DNS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        0, 0, 0xFFFFFFFF,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,StatusDNS)
    },
    {
        PARAM_NAME__STATUS_KERBEROS,
        NULL,
        CLUSPROP_FORMAT_DWORD,
        0, 0, 0xFFFFFFFF,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,StatusKerberos)
    },
    {
        PARAM_NAME__NEXT_UPDATE,
        NULL,
        CLUSPROP_FORMAT_BINARY,
        0, 0, 0,
        RESUTIL_PROPITEM_READ_ONLY,
        FIELD_OFFSET(NETNAME_PARAMS,NextUpdate)
    },
    { NULL, NULL, 0, 0, 0, 0 }
};

//
// forward declarations
//

CLRES_FUNCTION_TABLE NetNameFunctionTable;

//
// Forward references
//

DWORD
NetNameGetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN BOOL ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
NetNameValidatePrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PNETNAME_PARAMS Params,
    OUT PBOOL NetnameHasChanged
    );

DWORD
NetNameSetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NetNameClusterNameChanged(
    IN PNETNAME_RESOURCE Resource
    );

DWORD
NetNameGetNetworkName(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

VOID
NetNameCleanupDnsLists(
    IN  PNETNAME_RESOURCE   Resource
    );

VOID
RemoveDnsRecords(
    PNETNAME_RESOURCE Resource
    );

//
// Local utility functions
//


VOID
WINAPI
NetNameReleaseResource(
    IN RESID Resource
    )

/*++

Routine Description:

    Cleanup all handles and memory allocations in the netname context block

Arguments:

    Resource - supplies resource id to be cleaned up.

Return Value:

    None.

--*/

{
    PNETNAME_RESOURCE   resource = (PNETNAME_RESOURCE) Resource;
    PLIST_ENTRY         entry;


    ASSERT( resource != NULL );

    if (resource->Params.NetworkName != NULL) {
        LocalFree(resource->Params.NetworkName);
    }

    if (resource->Params.NetworkRandom != NULL) {
        LocalFree(resource->Params.NetworkRandom);
    }

    if (resource->NodeName != NULL) {
        LocalFree(resource->NodeName);
    }

    if (resource->NodeId != NULL) {
        LocalFree(resource->NodeId);
    }

    if (resource->ParametersKey != NULL) {
        ClusterRegCloseKey(resource->ParametersKey);
    }

    if (resource->NodeParametersKey != NULL) {
        ClusterRegCloseKey(resource->NodeParametersKey);
    }

    if (resource->ResKey != NULL){
        ClusterRegCloseKey(resource->ResKey);
    }

    if (resource->ClusterResourceHandle != NULL){
        CloseClusterResource(resource->ClusterResourceHandle);
    }

    if ( resource->DnsLists != NULL ) {
        NetNameCleanupDnsLists( resource );
    }

    if ( resource->DnsListMutex != NULL ) {
#if DBG
        {
            DWORD status;

            status = WaitForSingleObject( resource->DnsListMutex, 0 );
            if ( status == WAIT_TIMEOUT ) {
                WCHAR   buf[64];

                _snwprintf( buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                            L"res %08X DNS list mutex still signalled at delete!\n",
                            resource);
                OutputDebugStringW( buf );
                DebugBreak();
            } else {
                ReleaseMutex( resource->DnsListMutex );
            }
        }
#endif

        CloseHandle( resource->DnsListMutex );
    }

    if (resource->ObjectGUID != NULL) {
        LocalFree( resource->ObjectGUID );
    }

    (NetNameLogEvent)(resource->ResourceHandle,
                      LOG_INFORMATION,
                      L"ResID %1!u! closed.\n",
                      Resource
                      );

    LocalFree( resource );

} // NetNameReleaseResource

VOID
NetNameUpdateDnsServer(
    PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    Update this resource's A and PTR records at its DNS server

Arguments:

    Resource - pointer to netname resource context block

Return Value:

    None

--*/

{
    PDNS_LISTS      dnsLists;
    DWORD           numberOfDnsLists;
    ULONG           numberOfRegisteredNames;

    NetNameAcquireDnsListLock( Resource );

    numberOfDnsLists = Resource->NumberOfDnsLists;
    dnsLists = Resource->DnsLists;
    while ( numberOfDnsLists-- ) {

        if ( dnsLists->ForwardZoneIsDynamic ) {
#if DBG_DNSLIST
            {
                PDNS_RECORD dnsRec = dnsLists->A_RRSet.pFirstRR;
                WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
                struct in_addr addr;

                if ( dnsRec != NULL ) {
                    addr.s_addr = dnsLists->DnsServerList->AddrArray[0];
                    _snwprintf(buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                               L"REGISTERING ON adapter %.32ws (%hs)\n",
                               dnsLists->ConnectoidName,
                               inet_ntoa( addr ) );
                    OutputDebugStringW( buf );

                    do {
                        addr.s_addr = dnsRec->Data.A.IpAddress;
                        _snwprintf(buf, (sizeof( buf ) / sizeof( WCHAR )) - 1,
                                   L"\t(%ws, %hs)\n",
                                   dnsRec->pName, inet_ntoa( addr ));
                        OutputDebugStringW( buf );

                        dnsRec = dnsRec->pNext;
                    } while ( dnsRec != NULL );
                }
            }
#endif

            //
            // resource went or is going offline; no point in
            // continueing. don't need to grab resource lock since we have a
            // refcount on the resource block
            //
            if (Resource->State != ClusterResourceOnline) {
                break;
            }

            //
            // register the records to update their timestamp (if there is
            // something to register). Before we used to query but eventually
            // the records would time out and be scavenged (deleted). This can
            // cause lots of grief (or in Exchange's case, lots of undelivered
            // mail).
            //
            // we don't worry about logging errors or update the
            // LastARecQueryStatus since all of that is done in
            // RegisterDnsRecords.
            //
            if ( dnsLists->A_RRSet.pFirstRR != NULL ) {
                RegisterDnsRecords(dnsLists,
                                   Resource->Params.NetworkName,
                                   Resource->ResKey,
                                   Resource->ResourceHandle,
                                   FALSE,                   /* LogRegistration */
                                   &numberOfRegisteredNames);
            }
        } // Is Forward zone dynamic?

        ++dnsLists;

    } // while numberOfDnsLists != 0

    NetNameReleaseDnsListLock( Resource );

} // NetNameUpdateDnsServer

DWORD WINAPI
NetNameWorker(
    IN LPVOID NotUsed
    )

/*++

Routine Description:

    background worker thread. Checks on the health of the DNS registrations
    and reports back to resmon while names are in the online pending
    state. The netname Is/LooksAlive checks are too frequent such that they
    would cause alot of DNS traffic on the network. This routine runs through
    the linked list of netname resource blocks and queries the server for the
    records that should be registered. Any discrepancies will cause the
    records to be registered again. The success of each operation is left in
    the DNS_LIST area for the particular record type.

    In addition, when prompted, it will run down the list of resources and
    report back the resource's status to resmon. Name registration is
    serialized through srv.sys causing some names to time out before they get
    registered.

Arguments:

    NotUsed - not used...

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD               status = ERROR_SUCCESS;
    PLIST_ENTRY         entry;
    PNETNAME_RESOURCE   resource;
    DNS_STATUS          dnsStatus;
    BOOL                reportPending;
    DWORD               oldCheckPeriod;
    DWORD               pendingResourceCount;
    RESOURCE_STATUS     resourceStatus;
    HANDLE              waitHandles[ 2 ] = { NetNameWorkerTerminate,
                                             NetNameWorkerPendingResources };

    ResUtilInitializeResourceStatus( &resourceStatus );

    do {
        status = WaitForMultipleObjects(2,
                                        waitHandles,
                                        FALSE,
                                        NetNameWorkerCheckPeriod * 1000);


        if ( status == WAIT_OBJECT_0 ) {
            return ERROR_SUCCESS;
        }

        if ( status == ( WAIT_OBJECT_0 + 1 )) {
            reportPending = TRUE;
#if DBG
            (NetNameLogEvent)(L"rtNetwork Name",
                              LOG_INFORMATION,
                              L"Start of pending resource reporting\n");
#endif
        }

        //
        // reset check frequency back to normal. if something goes wrong,
        // other code will set it back to the problem check period.
        //
        NetNameWorkerCheckPeriod = NETNAME_WORKER_NORMAL_CHECK_PERIOD;

        pendingResourceCount = 0;

        NetNameAcquireResourceLock();

        entry = NetNameResourceListHead.Flink;
        while ( entry != &NetNameResourceListHead ) {
            //
            // get a pointer to the resource block
            //
            resource = CONTAINING_RECORD( entry, NETNAME_RESOURCE, Next );

            if ( resource->State > ClusterResourcePending ) {

                //
                // bringing lots (40) of names online simultaneously caused
                // some names to hit their pending timeouts. Each time a name
                // enters a pending state, the NetNameWorkerPendingResources
                // event is set to wake up this thread. The timeout is changed
                // so we can report back to resmon that the operation is
                // continuing. This should prevent resmon from timing out the
                // resource and causing much thrashing. No other checking (DNS
                // or Kerb) is done while this is happening.
                //
#if DBG
                (NetNameLogEvent)(resource->ResourceHandle,
                                  LOG_INFORMATION,
                                  L"Reporting resource pending\n");
#endif

                oldCheckPeriod = NetNameWorkerCheckPeriod;
                NetNameWorkerCheckPeriod = NETNAME_WORKER_PENDING_PERIOD;

                resourceStatus.CheckPoint = ++resource->StatusCheckpoint;
                resourceStatus.ResourceState = resource->State;

                //
                // never hold the resource lock when calling
                // SetResourceStatus. You'll end up with deadlocks when resmon
                // calls back in to the Looks/IsAlive routines. However, the
                // resource state is always synch'ed by this lock. No need to
                // bump refcount since this resource is still in a Pending
                // state and resmon won't allow the resource delete cluster
                // control to be issued.
                //
                NetNameReleaseResourceLock();

                (NetNameSetResourceStatus)(resource->ResourceHandle,
                                           &resourceStatus);

                NetNameAcquireResourceLock();

                ++pendingResourceCount;
            }
            else if ( resource->State == ClusterResourceOnline && !reportPending ) {
                //
                // up the ref count so this resource doesn't go away while we
                // re-register the records with the DNS server. This keeps
                // them from getting scavenged (deleted).
                //
                ++resource->RefCount;
                NetNameReleaseResourceLock();

                NetNameUpdateDnsServer( resource );

                //
                // check the status of the computer object and see if it is
                // time to generate a new password.
                //
                if ( resource->DoKerberosCheck ) {
                    FILETIME    currentFileTime;

                    status = CheckComputerObjectAttributes( resource );
                    InterlockedExchange( &resource->KerberosStatus, status );

                    GetSystemTimeAsFileTime( &currentFileTime );
                    if ( CompareFileTime( &currentFileTime, &resource->Params.NextUpdate ) == 1 ) {
                        ULARGE_INTEGER  updateTime;
                        DWORD           setValueStatus;

                        status = UpdateCompObjPassword( resource );

                        updateTime.LowPart = currentFileTime.dwLowDateTime;
                        updateTime.HighPart = currentFileTime.dwHighDateTime;
                        updateTime.QuadPart += ( resource->Params.UpdateInterval * 60 * 1000 * 100 );
                        currentFileTime.dwLowDateTime = updateTime.LowPart;
                        currentFileTime.dwHighDateTime = updateTime.HighPart;

                        setValueStatus = ResUtilSetBinaryValue(resource->ParametersKey,
                                                               PARAM_NAME__NEXT_UPDATE,
                                                               (const LPBYTE)&updateTime,  
                                                               sizeof( updateTime ),
                                                               NULL,
                                                               NULL);
                        ASSERT( setValueStatus == ERROR_SUCCESS );
                    }
                }

                //
                // reacquire the mutex so we can release our reference. If the
                // resource went offline and was deleted during the
                // registration, then perform "last ref" cleanup. If the
                // resource just went offline, we need to inform resmon that
                // we're finally going offline. This is synchronized with the
                // resource delete code by not having the DNS lists in use
                // when a delete resource control is sent.
                //
                NetNameAcquireResourceLock();

                ASSERT( resource->RefCount > 0 );  /* Ruihu: 11/04/2000 */
                if (resource->RefCount == 1) {
                    //
                    // we hold the last reference to this resource so it must
                    // have been deleted while the registration was taking
                    // place. Clean up and free our context block for this
                    // resource. Restart the loop since we don't know if the
                    // flink for this entry is still valid.
                    //
                    NetNameReleaseResource( resource );

                    entry = NetNameResourceListHead.Flink; /* start over */

                    continue;
                } 
                else 
                {
                    if ( resource->State == ClusterResourceOfflinePending ) {
                        BOOL    nameChanged;
                        BOOL    deleteCO;

                        //
                        // The resource state was changed while we were
                        // dealing with DNS. Set the state to offline.
                        //
                        resourceStatus.ResourceState = ClusterResourceOffline;
                        resource->State = ClusterResourceOffline;

                        //
                        // note whatever cleanup we need to do while we hold the lock
                        //
                        nameChanged = resource->NameChangedWhileOnline;
                        resource->NameChangedWhileOnline = FALSE;

                        deleteCO = resource->DeleteCOWhenOffline;
                        resource->DeleteCOWhenOffline = FALSE;

                        //
                        // ok to release lock since we haven't released our
                        // reference to this block
                        //
                        NetNameReleaseResourceLock();

                        // 
                        // if appropriate, do cleanup processing
                        //
                        if ( nameChanged ) {
                            RemoveDnsRecords( resource );
#if RENAME_SUPPORT
                            status = RenameComputerObject( resource, NULL );
                            if ( status == ERROR_NO_SUCH_DOMAIN ) {
                                //
                                // no DC is available; deal with it
                                //
                            }
                            else if ( status != ERROR_SUCCESS ) {
                                //
                                // something else bad happened.
                                //
                            }
#endif
                            resource->NameChangedWhileOnline = FALSE;
                        }

                        if ( deleteCO ) {
                            status = NetNameDeleteComputerObject( resource );
                            //
                            // ISSUE: log errors and make sure we handle the
                            // case where the resource isn't being deleted
                            //
                            if ( status == ERROR_NO_SUCH_DOMAIN ) {
                                //
                                // no DC available right now; deal with it
                                //
                            }
                            else if ( status != ERROR_SUCCESS && status != NERR_UserNotFound ) {
                                //
                                // some other, significant error occurred.
                                //
                            }
                        }

                        (NetNameSetResourceStatus)(resource->ResourceHandle,
                                                   &resourceStatus);

                        (NetNameLogEvent)(resource->ResourceHandle,
                                          LOG_INFORMATION,
                                          L"Resource is now offline\n");

                        NetNameAcquireResourceLock();
                    }  // ( resource->State == ClusterResourceOfflinePending )

                    /* Ruihu: 11/04/2000 */
                    --resource->RefCount; 
                    ASSERT(resource->RefCount >=0 );
                    if (resource->RefCount == 0) {
                        NetNameReleaseResource( resource );
                        entry = NetNameResourceListHead.Flink; /* start over */
                        continue;
                    } 
                    /* Ruihu: 11/04/2000 */
                } // end if resource count != 1
            } // resource is online

            entry = entry->Flink;
        } // while entries in the resource block list

        NetNameReleaseResourceLock();

        if ( reportPending && pendingResourceCount == 0 ) {
            //
            // no resources are left in a pending state so revert back to
            // checking DNS registrations
            //
            NetNameWorkerCheckPeriod = oldCheckPeriod;
            reportPending = FALSE;
#if DBG
            (NetNameLogEvent)(L"rtNetwork Name",
                              LOG_INFORMATION,
                              L"End of pending resource reporting\n");
#endif
        }

    } while ( TRUE );

} // NetNameWorker

BOOLEAN
NetNameInit(
    IN HINSTANCE    DllHandle
    )
/*++

Routine Description:

    Process attach initialization routine.

Arguments:

    DllHandle - handle to clusres module

Return Value:

    TRUE if initialization succeeded. FALSE otherwise.

--*/
{
    DWORD   status;
    DWORD   charsCopied;
    DWORD   charsAllocated = 0;

    NetNameResourceMutex = CreateMutex(NULL, FALSE, NULL);

    if (NetNameResourceMutex == NULL) {
        return(FALSE);
    }

    //
    // create worker thread terminate event with no special security,
    // auto-reset, initially nonsignalled, and no name
    //
    NetNameWorkerTerminate = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( NetNameWorkerTerminate == NULL ) {
        CloseHandle( NetNameResourceMutex );
        return FALSE;
    }

    //
    // create worker thread online pending event with no special security,
    // auto-reset, initially nonsignalled, and no name
    //
    NetNameWorkerPendingResources = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( NetNameWorkerPendingResources == NULL ) {
        CloseHandle( NetNameWorkerTerminate );
        CloseHandle( NetNameResourceMutex );
        return FALSE;
    }

    //
    // init the list head of the list of resources to check for DNS
    // registrations
    //
    InitializeListHead( &NetNameResourceListHead );

    //
    // lookup the account description string resource; start with 64 char
    // buffer and double until we fail or we get all of the string. Not
    // considered fatal if we can't load the string
    //
    charsAllocated = 64;

realloc:
    charsCopied = 0;
    NetNameCompObjAccountDesc = HeapAlloc( GetProcessHeap(), 0, charsAllocated * sizeof( WCHAR ));
    if ( NetNameCompObjAccountDesc ) {

        charsCopied = LoadString(DllHandle,
                                 RES_NETNAME_COMPUTER_ACCOUNT_DESCRIPTION,
                                 NetNameCompObjAccountDesc,
                                 charsAllocated);

        if ( charsCopied != 0 && charsCopied == ( charsAllocated - 1 )) {
            HeapFree( GetProcessHeap(), 0, NetNameCompObjAccountDesc );
            charsAllocated *= 2;
            goto realloc;
        }
    }

    if ( charsCopied == 0 ) {
        NetNameCompObjAccountDesc = NULL;
    }

    return(TRUE);
} // NetNameInit


VOID
NetNameCleanup(
    VOID
    )
/*++

Routine Description:

    Process detach cleanup routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (NetNameResourceMutex != NULL) {
        CloseHandle(NetNameResourceMutex);
        NetNameResourceMutex = NULL;
    }

    if ( NetNameWorkerTerminate ) {
        CloseHandle( NetNameWorkerTerminate );
        NetNameWorkerTerminate = NULL;
    }

    if ( NetNameWorkerPendingResources ) {
        CloseHandle( NetNameWorkerPendingResources );
        NetNameWorkerPendingResources = NULL;
    }

} // NetNameCleanup


PNETNAME_RESOURCE
NetNameAllocateResource(
    IN  RESOURCE_HANDLE ResourceHandle
    )
/*++

Routine Description:

    Allocates a resource object.

Arguments:

    ResourceHandle - A pointer to the Resource Monitor handle to be associated
                     with this resource.

Return Value:

    A pointer to the new resource if successful. NULL otherwise.

--*/
{
    PNETNAME_RESOURCE  resource = NULL;

    resource = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                          sizeof(NETNAME_RESOURCE));

    if (resource == NULL) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Resource allocation failed\n");
        return(NULL);
    }

    resource->ResourceHandle = ResourceHandle;

    return(resource);
} // NetNameAllocateResource

DWORD
NetNameGetParameters(
    IN  HKEY            ResourceKey,
    IN  HKEY            ParametersKey,
    IN  HKEY            NodeParametersKey,
    IN  RESOURCE_HANDLE ResourceHandle,
    OUT PNETNAME_PARAMS ParamBlock,
    OUT DWORD *         RandomSize,
    OUT LPWSTR *        LastName,
    OUT DWORD  *        pdwFlags
    )
/*++

Routine Description:

    Reads the registry parameters for a netname resource.

Arguments:


    ParametersKey - An open handle to the resource's parameters key.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

    ParamBlock - A pointer to a buffer into which to place the private properties read
                 from the registry

    RandomSize - A pointer to a buffer into which to place the number of bytes in
                 ParamBlock->NetworkRandom

    LastName - A pointer to a buffer into which to place the unicode network name
               that was last created on this node.

    pdwFlags - a pointer to a DWORD that receives the flags data. Used to store the
               core resource flag.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD   status;
    DWORD   bytesReturned;

    //
    // get the Flags parameter; hold core resource flag for cluster name
    //
    status = ResUtilGetDwordValue(ResourceKey,
                                  PARAM_NAME__FLAGS,
                                  pdwFlags,
                                  0);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read Flags parameter, error=%1!u!\n",
                          status);
        *pdwFlags = 0;
    }

    //
    // Read the private parameters. always free the existing storage areas
    //
    if ( ParamBlock->NetworkName != NULL ) {
        LocalFree( ParamBlock->NetworkName );
        ParamBlock->NetworkName = NULL;
    }

    ParamBlock->NetworkName = ResUtilGetSzValue( ParametersKey, PARAM_NAME__NAME );

    if (ParamBlock->NetworkName == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NetworkName parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__REMAP,
                                  &ParamBlock->NetworkRemap,
                                  PARAM_DEFAULT__REMAP);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NetworkRemap parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    if ( ParamBlock->NetworkRandom != NULL ) {
        LocalFree( ParamBlock->NetworkRandom );
        ParamBlock->NetworkRandom = NULL;
    }

    status = ResUtilGetBinaryValue(ParametersKey,
                                   PARAM_NAME__RANDOM,
                                   &ParamBlock->NetworkRandom,
                                   RandomSize);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NetworkRandom parameter, error=%1!u!\n",
                          status);
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__REQUIRE_DNS,
                                  &ParamBlock->RequireDNS,
                                  PARAM_DEFAULT__REQUIRE_DNS);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read RequireDNS parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__REQUIRE_KERBEROS,
                                  &ParamBlock->RequireKerberos,
                                  PARAM_DEFAULT__REQUIRE_KERBEROS);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read RequireKerberos parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    status = ResUtilGetBinaryValue(ParametersKey,
                                   PARAM_NAME__NEXT_UPDATE,
                                   (LPBYTE *)&ParamBlock->NextUpdate,
                                   &bytesReturned);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NextUpdate parameter, error=%1!u!\n",
                          status);
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__UPDATE_INTERVAL,
                                  &ParamBlock->UpdateInterval,
                                  PARAM_DEFAULT__UPDATE_INTERVAL);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read UpdateInterval parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    //
    // Read the node-specific parameters.
    //
    *LastName = ResUtilGetSzValue( NodeParametersKey, PARAM_NAME__LASTNAME );
    status = ERROR_SUCCESS;


error_exit:

    if (status != ERROR_SUCCESS) {
        if (ParamBlock->NetworkName != NULL) {
            LocalFree(ParamBlock->NetworkName);
            ParamBlock->NetworkName = NULL;
        }

        if (ParamBlock->NetworkRandom != NULL) {
            LocalFree(ParamBlock->NetworkRandom);
            ParamBlock->NetworkRandom = NULL;
        }
    }

    return(status);
} // NetNameGetParameters

#define TRANSPORT_BLOCK_SIZE  4

DWORD
GrowBlock(
    PCHAR * Block,
    DWORD   UsedEntries,
    DWORD   BlockSize,
    PDWORD  FreeEntries
    )

/*++

Routine Description:

    Grow the specified block to hold more entries. Block might end up pointing
    to different chunk of memory as a result

Arguments:

    None

Return Value:

    None

--*/

{
    PVOID tmp;

    tmp = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                     (UsedEntries + TRANSPORT_BLOCK_SIZE) * BlockSize);

    if (tmp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (*Block != NULL) {
        CopyMemory( tmp, *Block, UsedEntries * BlockSize );
        LocalFree( *Block );
    }

    *Block = tmp;
    *FreeEntries = TRANSPORT_BLOCK_SIZE;

    return ERROR_SUCCESS;
} // GrowBlock

DWORD
UpdateDomainMapEntry(
    PDOMAIN_ADDRESS_MAPPING DomainEntry,
    LPWSTR                  IpAddress,
    LPWSTR                  DomainName,
    LPWSTR                  ConnectoidName,
    DWORD                   DnsServerCount,
    PDWORD                  DnsServerList
    )

/*++

Routine Description:

    Update the specified DomainMap entry by making copies of the supplied
    parameters

Arguments:

    None

Return Value:

    None

--*/

{

    //
    // make copies of the address and domain and connectoid names
    //
    DomainEntry->IpAddress = ResUtilDupString ( IpAddress );
    DomainEntry->DomainName = ResUtilDupString( DomainName );
    DomainEntry->ConnectoidName = ResUtilDupString( ConnectoidName );

    if ( DomainEntry->IpAddress == NULL
         ||
         DomainEntry->DomainName == NULL
         ||
         DomainEntry->ConnectoidName == NULL )
    {
        if ( DomainEntry->IpAddress != NULL ) {
            LocalFree( DomainEntry->IpAddress );
        }

        if ( DomainEntry->DomainName != NULL ) {
            LocalFree( DomainEntry->DomainName );
        }

        if ( DomainEntry->ConnectoidName != NULL ) {
            LocalFree( DomainEntry->ConnectoidName );
        }

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // make a copy of the DNS server addresses to use when registering
    //
    if ( DnsServerCount > 0 ) {
        DomainEntry->DnsServerList = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof( IP4_ARRAY ) + 
                                                (sizeof(IP4_ADDRESS) * (DnsServerCount - 1)));

        if ( DomainEntry->DnsServerList == NULL ) {
            LocalFree( DomainEntry->IpAddress );
            LocalFree( DomainEntry->DomainName );
            LocalFree( DomainEntry->ConnectoidName );

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DomainEntry->DnsServerList->AddrCount = DnsServerCount;
        RtlCopyMemory(DomainEntry->DnsServerList->AddrArray,
                      DnsServerList,
                      DnsServerCount * sizeof( IP4_ADDRESS ));
    } else {
        DomainEntry->DnsServerList = NULL;
    }
        
    return ERROR_SUCCESS;
} // UpdateDomainMapEntry

DWORD
NetNameGetLists(
    IN   PNETNAME_RESOURCE          Resource,
    IN   PCLRTL_NET_ADAPTER_ENUM    AdapterEnum     OPTIONAL,
    OUT  LPWSTR **                  TransportList,
    OUT  LPDWORD                    TransportCount,
    OUT  PDOMAIN_ADDRESS_MAPPING *  DomainMapList   OPTIONAL,     
    OUT  LPDWORD                    DomainMapCount  OPTIONAL
    )

/*++

    Build a list of NetBT transports, IP addresses, and Domain names on which
    this name is dependent. The transport devices are used to register NETBios
    names while the IP addresses and Domain Names are used if the adapter
    associated with the IP address is the member of a DNS domain. Each IP
    address can have a different domain name associated with it hence the need
    to maintain a separate list.

--*/

{
    DWORD                       status;
    HRESOURCE                   providerHandle = NULL;
    HKEY                        providerKey = NULL;
    HRESENUM                    resEnumHandle = NULL;
    DWORD                       i;
    DWORD                       objectType;
    DWORD                       providerNameSize = 0;
    LPWSTR                      providerName = NULL;
    LPWSTR                      providerType = NULL;
    DWORD                       transportFreeEntries = 0;
    LPWSTR *                    transportList = NULL;
    DWORD                       transportCount = 0;
    LPWSTR                      transportName = NULL;
    HCLUSTER                    clusterHandle = NULL;
    DWORD                       enableNetbios;
    PDOMAIN_ADDRESS_MAPPING     domainMapList = NULL;
    DWORD                       domainMapCount = 0;
    DWORD                       domainMapFreeEntries = 0;
    LPWSTR                      ipAddress;
    PCLRTL_NET_ADAPTER_INFO     adapterInfo;
    PCLRTL_NET_INTERFACE_INFO   interfaceInfo;
    WCHAR                       primaryDomain[ DNS_MAX_NAME_BUFFER_LENGTH ] = { 0 };
    DWORD                       primaryDomainSize = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    // get the node's primary domain name, if any. Domains with only NT4 DCs
    // won't necessarily have a PDN
    //
    if ( !GetComputerNameEx(ComputerNamePhysicalDnsDomain,
                            primaryDomain,
                            &primaryDomainSize))
    {
        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_WARNING,
            L"Unable to get primary domain name, status %1!u!.\n",
            status
            );

        primaryDomainSize = 0;
    }
 
    //
    // Open a handle to the cluster.
    //
    clusterHandle = OpenCluster(NULL);

    if (clusterHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to open handle to cluster, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Enumerate the dependencies to find the IP Addresses
    //
    resEnumHandle = ClusterResourceOpenEnum(
                        Resource->ClusterResourceHandle,
                        CLUSTER_RESOURCE_ENUM_DEPENDS
                        );

    if (resEnumHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to open enum handle for this resource, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // enum all the dependent resources for this netname resource
    //

    for (i=0; ;i++) {
        status = ClusterResourceEnum(
                     resEnumHandle,
                     i,
                     &objectType,
                     providerName,
                     &providerNameSize
                     );

        if (status == ERROR_NO_MORE_ITEMS) {
            break;
        }

        if ((status == ERROR_MORE_DATA) ||
            ((status == ERROR_SUCCESS) && (providerName == NULL))) {
            if (providerName != NULL) {
                LocalFree(providerName);
            }

            providerNameSize++;

            providerName = LocalAlloc(
                               LMEM_FIXED,
                               providerNameSize * sizeof(WCHAR)
                               );

            if (providerName == NULL) {
                (NetNameLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to allocate memory.\n"
                    );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto error_exit;
            }

            status = ClusterResourceEnum(
                         resEnumHandle,
                         i,
                         &objectType,
                         providerName,
                         &providerNameSize
                         );

            ASSERT(status != ERROR_MORE_DATA);
        }

        if (status != ERROR_SUCCESS) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to enumerate resource dependencies, status %1!u!.\n",
                status
                );
            goto error_exit;
        }

        //
        // Open the resource
        //
        providerHandle = OpenClusterResource(clusterHandle, providerName);

        if (providerHandle == NULL) {
            status = GetLastError();
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to open handle to provider resource %1!ws!, status %2!u!.\n",
                providerName,
                status
                );
            goto error_exit;
        }

        //
        // Figure out what type it is.
        //
        providerKey = GetClusterResourceKey(providerHandle, KEY_READ);

        status = GetLastError();

        CloseClusterResource(providerHandle);

        if (providerKey == NULL) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to open provider resource key, status %1!u!.\n",
                status
                );
            goto error_exit;
        }

        providerType = ResUtilGetSzValue(providerKey, CLUSREG_NAME_RES_TYPE);

        if (providerType == NULL) {
            status = GetLastError();
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to get provider resource type, status %1!u!.\n",
                status
                );
            goto error_exit;
        }

        //
        // make sure it's an IP address resource
        //

        if (wcscmp(providerType, IP_ADDRESS_RESOURCETYPE_NAME) == 0) {
            HKEY parametersKey;

            //
            // Open the provider's parameters key.
            //
            status = ClusterRegOpenKey(
                         providerKey,
                         CLUSREG_KEYNAME_PARAMETERS,
                         KEY_READ,
                         &parametersKey
                         );

            if (status != ERROR_SUCCESS) {
                (NetNameLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to open provider's parameters key, status %1!u!.\n",
                    status
                    );
                goto error_exit;
            }

            if ( ARGUMENT_PRESENT( DomainMapList )) {
                ASSERT( ARGUMENT_PRESENT( DomainMapCount ));
                ASSERT( ARGUMENT_PRESENT( AdapterEnum ));

                //
                // build a list of IP address strings that we can use for
                // building the appropriate DNS records
                //
                ipAddress = ResUtilGetSzValue( parametersKey, CLUSREG_NAME_IPADDR_ADDRESS );

                if (ipAddress == NULL) {
                    status = GetLastError();
                    ClusterRegCloseKey(parametersKey);
                    (NetNameLogEvent)(
                        Resource->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to get provider's Address value, status %1!u!.\n",
                        status
                        );
                    goto error_exit;
                }

                //
                // find the corresponding adapter/interface over which packets
                // for this IP address would be sent. Get the domain name (if
                // any) from the adapter info.
                //
                adapterInfo = ClRtlFindNetAdapterByInterfaceAddress(
                                  AdapterEnum,
                                  ipAddress,
                                  &interfaceInfo);

                if ( adapterInfo != NULL ) {
                    LPWSTR deviceGuid;
                    DWORD guidLength;

                    //
                    // argh. DeviceGuid is not bracketed by braces which the
                    // following Dns routines require. Dup the string and make
                    // it all nice and pretty for DNS.
                    //
                    guidLength = wcslen( adapterInfo->DeviceGuid );
                    deviceGuid = LocalAlloc(LMEM_FIXED,
                                            (guidLength + 3) * sizeof(WCHAR));

                    if ( deviceGuid == NULL ) {
                        status = GetLastError();

                        (NetNameLogEvent)(
                            Resource->ResourceHandle,
                            LOG_ERROR,
                            L"Unable to allocate memory.\n"
                            );
                        goto error_exit;
                    }

                    deviceGuid[0] = L'{';
                    wcscpy( &deviceGuid[1], adapterInfo->DeviceGuid );
                    wcscpy( &deviceGuid[ guidLength + 1 ],  L"}" );

                    //
                    // see if dynamic DNS is enabled for this adapter and that
                    // they are DNS servers associated with this adapter. Bail
                    // if not. This check corresponds to the "register this
                    // connection's addresses in DNS" checkbox in the DNS
                    // proppage in the advanced TCP properties
                    //
                    if ( DnsIsDynamicRegistrationEnabled( deviceGuid ) &&
                         adapterInfo->DnsServerCount > 0)
                    {

                        //
                        // set up a mapping with the Primary Domain Name if
                        // apropriate
                        //
                        if ( primaryDomainSize != 0 ) {

                            if (domainMapFreeEntries == 0) {

                                status = GrowBlock((PCHAR *)&domainMapList,
                                                   domainMapCount,
                                                   sizeof( *domainMapList ),
                                                   &domainMapFreeEntries);

                                if ( status != ERROR_SUCCESS) {
                                    (NetNameLogEvent)(
                                        Resource->ResourceHandle,
                                        LOG_ERROR,
                                        L"Unable to allocate memory.\n"
                                        );
                                    goto error_exit;
                                }
                            }

                            //
                            // make copies of the address and name
                            //
                            status = UpdateDomainMapEntry(&domainMapList[ domainMapCount ],
                                                          ipAddress,
                                                          primaryDomain,
                                                          adapterInfo->ConnectoidName,
                                                          adapterInfo->DnsServerCount,
                                                          adapterInfo->DnsServerList);

                            if ( status != ERROR_SUCCESS ) {
                                (NetNameLogEvent)(
                                    Resource->ResourceHandle,
                                    LOG_ERROR,
                                    L"Unable to allocate memory.\n"
                                    );
                                goto error_exit;
                            }

                            domainMapCount++;
                            domainMapFreeEntries--;
                        }

                        //
                        // now check if we should care about the adapter
                        // specific name. It must be different from the
                        // primary domain name and have the "use this
                        // connection's DNS suffix" checkbox checked.
                        //
                        if ( DnsIsAdapterDomainNameRegistrationEnabled( deviceGuid ) &&
                             adapterInfo->AdapterDomainName != NULL &&
                             _wcsicmp(adapterInfo->AdapterDomainName, primaryDomain) != 0)
                        {

                            if (domainMapFreeEntries == 0) {

                                status = GrowBlock((PCHAR *)&domainMapList,
                                                   domainMapCount,
                                                   sizeof( *domainMapList ),
                                                   &domainMapFreeEntries);

                                if ( status != ERROR_SUCCESS) {
                                    (NetNameLogEvent)(
                                        Resource->ResourceHandle,
                                        LOG_ERROR,
                                        L"Unable to allocate memory.\n"
                                        );
                                    goto error_exit;
                                }
                            }

                            //
                            // make copies of the address and name
                            //
                            status = UpdateDomainMapEntry(&domainMapList[ domainMapCount ],
                                                          ipAddress,
                                                          adapterInfo->AdapterDomainName,
                                                          adapterInfo->ConnectoidName,
                                                          adapterInfo->DnsServerCount,
                                                          adapterInfo->DnsServerList);

                            if ( status != ERROR_SUCCESS ) {
                                (NetNameLogEvent)(
                                    Resource->ResourceHandle,
                                    LOG_ERROR,
                                    L"Unable to allocate memory.\n"
                                    );
                                goto error_exit;
                            }

                            domainMapCount++;
                            domainMapFreeEntries--;
                        } // if register adapter domain is true and one has been specified

                    } // if dynamic DNS is enabled for this adapter

                    LocalFree( deviceGuid );
                } // if we found the matching adapter in our adapter info

                LocalFree( ipAddress );
            } // if DomainMapList present

            //
            // Figure out if this resource supports NetBios.
            //
            status = ResUtilGetDwordValue(
                         parametersKey,
                         CLUSREG_NAME_IPADDR_ENABLE_NETBIOS,
                         &enableNetbios,
                         1
                         );

            if (status != ERROR_SUCCESS) {
                ClusterRegCloseKey(parametersKey);
                (NetNameLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to get provider's EnableNetbios value, status %1!u!.\n",
                    status
                    );
                goto error_exit;
            }

            if (enableNetbios) {
                HKEY nodeParametersKey;

                //
                // Open the provider's node-specific parameters key.
                //
                status = ClusterRegOpenKey(
                             parametersKey,
                             Resource->NodeId,
                             KEY_READ,
                             &nodeParametersKey
                             );

                ClusterRegCloseKey(parametersKey);

                if (status != ERROR_SUCCESS) {
                    (NetNameLogEvent)(
                        Resource->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to open provider's node parameters key, status %1!u!.\n",
                        status
                        );
                    goto error_exit;
                }

                transportName = ResUtilGetSzValue(
                                            nodeParametersKey,
                                            L"NbtDeviceName"
                                            );

                status = GetLastError();

                ClusterRegCloseKey(nodeParametersKey);

                if (transportName == NULL) {
                    (NetNameLogEvent)(
                        Resource->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to get provider's transport name, status %1!u!.\n",
                        status
                        );
                    goto error_exit;
                }

                if (transportFreeEntries == 0) {

                    status = GrowBlock((PCHAR *)&transportList,
                                       transportCount,
                                       sizeof( *transportList ),
                                       &transportFreeEntries);

                    if ( status != ERROR_SUCCESS) {
                        (NetNameLogEvent)(
                            Resource->ResourceHandle,
                            LOG_ERROR,
                            L"Unable to allocate memory.\n"
                            );
                        goto error_exit;
                    }
                }

                transportList[transportCount] = transportName;
                transportName = NULL;
                transportCount++;
                transportFreeEntries--;
            }
            else {
                ClusterRegCloseKey(parametersKey);
            }
        }

        ClusterRegCloseKey(providerKey);
        providerKey = NULL;
        LocalFree(providerType);
        providerType = NULL;
    }

    if (providerName != NULL) {
        LocalFree(providerName);
        providerName = NULL;
    }

    CloseCluster(clusterHandle);
    ClusterResourceCloseEnum(resEnumHandle);

    *TransportList = transportList;
    *TransportCount = transportCount;

    if ( ARGUMENT_PRESENT( DomainMapList )) {
        *DomainMapList = domainMapList;
        *DomainMapCount = domainMapCount;
    }

    return(ERROR_SUCCESS);

error_exit:

    if (transportList != NULL) {
        ASSERT(transportCount > 0);

        while (transportCount > 0) {
            LocalFree(transportList[--transportCount]);
        }

        LocalFree(transportList);
    }

    if ( domainMapList != NULL ) {
        while (domainMapCount--) {
            if ( domainMapList[ domainMapCount ].IpAddress != NULL ) {
                LocalFree( domainMapList[ domainMapCount ].IpAddress );
            }
            if ( domainMapList[ domainMapCount ].DomainName != NULL ) {
                LocalFree( domainMapList[ domainMapCount ].DomainName );
            }
            if ( domainMapList[ domainMapCount ].DnsServerList != NULL ) {
                LocalFree( domainMapList[ domainMapCount ].DnsServerList );
            }
        }
        LocalFree(domainMapList);
    }

    if (clusterHandle != NULL) {
        CloseCluster(clusterHandle);
    }

    if (resEnumHandle != NULL) {
        ClusterResourceCloseEnum(resEnumHandle);
    }

    if (providerName != NULL) {
        LocalFree(providerName);
    }

    if (providerKey != NULL) {
        ClusterRegCloseKey(providerKey);
    }

    if (providerType != NULL) {
        LocalFree(providerType);
    }

    if (transportName != NULL) {
        LocalFree(transportName);
    }

    return(status);

} // NetNameGetLists


VOID
NetNameCleanupDnsLists(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    Clean up the DNS list structures associated with the resource.

Arguments:

    Resource - pointer to internal resource struct

Return Value:

    None

--*/

{
    PDNS_LISTS  dnsLists;
    DNS_STATUS  dnsStatus;
    PDNS_RECORD dnsRecord;

    dnsLists = Resource->DnsLists;
    while ( Resource->NumberOfDnsLists-- ) {

#if 0
        //
        // we have to free the args we handed to the DNS record build routines
        //
        dnsRecord = dnsLists->A_RRSet.pFirstRR;
        while ( dnsRecord != NULL ) {
            LocalFree( dnsRecord->pName );
            dnsRecord->pName = NULL;

            dnsRecord = dnsRecord->pNext;
        }

        dnsRecord = dnsLists->PTR_RRSet.pFirstRR;
        while ( dnsRecord != NULL ) {
            LocalFree( dnsRecord->Data.PTR.pNameHost );
            dnsRecord->Data.PTR.pNameHost = NULL;

            dnsRecord = dnsRecord->pNext;
        }
#endif

        //
        // have DNSAPI clean up its structs
        //
        DnsRecordListFree( dnsLists->PTR_RRSet.pFirstRR, DnsFreeRecordListDeep );
        DnsRecordListFree( dnsLists->A_RRSet.pFirstRR, DnsFreeRecordListDeep );

        //
        // free server address info and connectoid name string
        //
        if ( dnsLists->DnsServerList != NULL ) {
            LocalFree( dnsLists->DnsServerList );
        }

        if ( dnsLists->ConnectoidName != NULL ) {
            LocalFree( dnsLists->ConnectoidName );
        }

        ++dnsLists;
    }
    Resource->NumberOfDnsLists = 0;

    if ( Resource->DnsLists != NULL ) {
        LocalFree( Resource->DnsLists );
        Resource->DnsLists = NULL;
    }

} // NetNameCleanupDnsLists

VOID
NetNameOfflineNetbios(
    IN PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    do final clean up when taking this resource offline.

Arguments:

    Resource - A pointer to the NETNAME_RESOURCE block for this resource.

Returns:

    None.

--*/

{
    DWORD           status;
    DWORD           i;
    LPWSTR *        transportList = NULL;
    DWORD           transportCount = 0;

    //
    // Now we can finally do the real work of taking the netbios name offline.
    //
    DeleteAlternateComputerName(Resource->Params.NetworkName,
                                Resource->NameHandleList,
                                Resource->NameHandleCount,
                                Resource->ResourceHandle);

    if (Resource->NameHandleList != NULL) {
        LocalFree(Resource->NameHandleList);
        Resource->NameHandleList = NULL;
        Resource->NameHandleCount = 0;
    }

    //
    // Remove the cluster service type bits
    //
    status = NetNameGetLists(Resource,
                             NULL,
                             &transportList,
                             &transportCount,
                             NULL,
                             NULL);

    if (status == ERROR_SUCCESS) {
        DWORD serviceBits;

        serviceBits = SV_TYPE_CLUSTER_VS_NT | SV_TYPE_CLUSTER_NT;

        for (i=0; i<transportCount; i++) {
            I_NetServerSetServiceBitsEx(NULL,                          // target server
                                        Resource->Params.NetworkName,  // emulated server name
                                        transportList[i],              // transport name
                                        serviceBits,                   // bits of interest
                                        0,                             // bits
                                        TRUE );                        // Update immediately
        }

        while (transportCount > 0) {
            LocalFree(transportList[--transportCount]);
        }

        LocalFree(transportList);
    }
} // NetNameOfflineNetbios


DWORD
NetNameOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PNETNAME_RESOURCE Resource
    )
/*++

Routine Description:

    Brings a network name resource online.

Arguments:

    Worker - Supplies the worker structure

    Resource - A pointer to the NETNAME_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    DWORD                    status;
    CLUSTER_RESOURCE_STATE   finalState = ClusterResourceFailed;
    LPWSTR                   lastName = NULL;
    LPWSTR *                 transportList = NULL;
    DWORD                    transportCount = 0;
    PDOMAIN_ADDRESS_MAPPING  domainMapList = NULL;
    DWORD                    domainMapCount = 0;
    DWORD                    i;
    DWORD                    dwFlags;
    PCLRTL_NET_ADAPTER_ENUM  adapterEnum = NULL;
    RESOURCE_STATUS          resourceStatus;
    DWORD                    serviceBits;
    LPWSTR                   netbiosSMBDevice = L"\\Device\\NetbiosSmb";

    ResUtilInitializeResourceStatus( &resourceStatus );

    ASSERT(Resource->State == ClusterResourceOnlinePending);

    (NetNameLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Bringing resource online...\n"
        );

    //
    // If this is the first resource to be brought online then spin up the DNS
    // check thread at this point
    //
    NetNameAcquireResourceLock();
    if ( NetNameWorkerThread == NULL ) {
        NetNameWorkerThread = CreateThread(NULL,
                                              0,
                                              NetNameWorker,
                                              NULL,
                                              0,
                                              NULL);

        if ( NetNameWorkerThread == NULL ) {
            status = GetLastError();
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Can't start Netname worker thread. status = %1!u!\n",
                status
                );
            NetNameReleaseResourceLock();
            goto error_exit;
        }
    }
    NetNameReleaseResourceLock();

    //
    // initialize the checkpoint var that is used to communicate back to
    // resmon that we're still working on bringing the resource online
    //
    Resource->StatusCheckpoint = 0;

    //
    // notify the worker thread that we're bringing a name online.
    //
    SetEvent( NetNameWorkerPendingResources );

    //
    // see if we need to create the Node Parameters section in the registry
    // for this resource.
    //
    if ( Resource->NodeParametersKey == NULL ) {
        DWORD   disposition;

        status = ClusterRegCreateKey(Resource->ParametersKey,
                                     Resource->NodeId,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &Resource->NodeParametersKey,
                                     &disposition);

        if (status != NO_ERROR) {
            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_ERROR,
                              L"Unable to create node parameters key, status %1!u!.\n",
                              status
                              );
            goto error_exit;
        }
    }

    //
    // This read must continue to be here as long as adminstrative
    // agents (like CLUSCLI) continue to write to the registry behind the back
    // of the resource dll. We need to migrate to writing all registry
    // parameters via the SET_COMMON/PRIVATE_PROPERTIES control function. That
    // way, resource dll's can read their parameters in the open (allowing for
    // the possibility that they may fail), and then update the parameters
    // whenever the SET_PRIVATE_PROPERTIES control code is delivered and
    // (optionally) on the SET_COMMON_PROPERTIES as needed.
    //
    // Fetch our parameters from the registry.
    //
    status = NetNameGetParameters(
                Resource->ResKey,
                Resource->ParametersKey,
                Resource->NodeParametersKey,
                Resource->ResourceHandle,
                &Resource->Params,
                &Resource->RandomSize,
                &lastName,
                &Resource->dwFlags
                );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    if (lastName != NULL) {
        LocalFree(lastName);        // we don't use this value.
    }

    if ( Resource->Params.NetworkName == NULL ) {
        status = ERROR_RESOURCE_NOT_FOUND;
        goto error_exit;
    }

    //
    // Ensure that the specified network name is not the same as the
    // computername of this node.
    //
    if ( lstrcmpiW(Resource->Params.NetworkName, Resource->NodeName) == 0 ) {
        ClusResLogSystemEventByKey1(Resource->ResKey,
                                    LOG_CRITICAL,
                                    RES_NETNAME_DUPLICATE,
                                    Resource->Params.NetworkName);
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"The specified network name is the same as the local computername.\n"
            );
        status = ERROR_DUP_NAME;
        goto error_exit;
    }

    //
    // get the adapter configuration and determine which adapters are
    // participating in a DNS domain
    //

    adapterEnum = ClRtlEnumNetAdapters();

    if ( adapterEnum == NULL ) {

        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Couldn't acquire network adapter configuration, status %1!u!\n",
            status
            );

        goto error_exit;
    }

    //
    // Search our dependencies and return the list of NBT devices to which we
    // need to bind the server. Also get the IP addresses this resource
    // depends on so we can publish them in DNS.
    //
    status = NetNameGetLists(
                 Resource,
                 adapterEnum,
                 &transportList,
                 &transportCount,
                 &domainMapList,
                 &domainMapCount
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // transportCount could be zero in the case where NetBIOS names are turned
    // off for all IP addr resources. In any case, a network name must have at
    // least one IP address associated with it.
    //
    if (( transportCount + domainMapCount ) == 0 ) {
        ClusResLogSystemEventByKey(Resource->ResKey,
                                   LOG_CRITICAL,
                                   RES_NETNAME_NO_IP_ADDRESS);
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"This name is configured such that it will not be registered "
            L"with a name service or it could not be registered with either "
            L"NetBIOS or a DNS name server at this time. This condition prevents "
            L"the name from being brought online.\n"
            );
        status = ERROR_DEPENDENCY_NOT_FOUND;
        goto error_exit;
    }

    //
    // Write the name to the registry so we can delete it if we crash and
    // restart.
    //
    status = ClusterRegSetValue(
                 Resource->NodeParametersKey,
                 PARAM_NAME__LASTNAME,
                 REG_SZ,
                 (LPBYTE)Resource->Params.NetworkName,
                 ((lstrlenW(Resource->Params.NetworkName) + 1) * sizeof(WCHAR))
                 );

    if (status != ERROR_SUCCESS) {
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Failed to write name to registry, status %1!u!\n",
            status
            );

        goto error_exit;
    }

    if ( transportCount > 0 ) {
        //
        // Allocate an array to hold the handles for the registered name
        //
        Resource->NameHandleList = LocalAlloc(
                                       LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(HANDLE) * transportCount
                                       );

        if (Resource->NameHandleList == NULL) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate memory for name registration.\n"
                );
            goto error_exit;
        }
    }

    Resource->NameHandleCount = transportCount;

    //
    // if we have DNS related data from a previous online, free it up now
    // since AddAlternateComputerName will be reconstructing with current
    // info.
    //
    if ( Resource->DnsLists != NULL ) {
        NetNameCleanupDnsLists( Resource );
    }

    //
    // Add the name/transport combinations.
    //
    status = AddAlternateComputerName(
                 Worker,
                 Resource,
                 transportList,
                 transportCount,
                 domainMapList,
                 domainMapCount
                 );

    if (status != NERR_Success) {
        ClusResLogSystemEventByKeyData(Resource->ResKey,
                                       LOG_CRITICAL,
                                       RES_NETNAME_CANT_ADD_NAME,
                                       sizeof(status),
                                       &status);

        NetNameOfflineNetbios( Resource );

        //
        // don't need to synchronize with worker thread since it only checks
        // online resources
        //
        NetNameCleanupDnsLists( Resource );
        goto error_exit;
    }

    finalState = ClusterResourceOnline;

    //
    // set the appropriate service type bit(s) for this name. core cluster
    // name resource additionally gets the cluster bit.
    //
    serviceBits = SV_TYPE_CLUSTER_VS_NT;
    if (Resource->dwFlags & CLUS_FLAG_CORE) {
        serviceBits |= SV_TYPE_CLUSTER_NT;
    }
        
    for (i=0; i<transportCount; i++) {
        I_NetServerSetServiceBitsEx(NULL,                   // Local server serv
                                    Resource->Params.NetworkName,
                                    transportList[i],       //transport name
                                    serviceBits,
                                    serviceBits,
                                    TRUE );                 // Update immediately
    }

    (NetNameLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Network Name %1!ws! is now online\n",
        Resource->Params.NetworkName
        );

error_exit:

    if ( status != ERROR_SUCCESS ) {
        if ( Resource->NameHandleList != NULL ) {
            LocalFree(Resource->NameHandleList);
            Resource->NameHandleList = NULL;
            Resource->NameHandleCount = 0;
        }
    }

    if (transportList != NULL) {
        ASSERT(transportCount > 0);

        while (transportCount > 0) {
            LocalFree(transportList[--transportCount]);
        }

        LocalFree(transportList);
    }

    if (domainMapList != NULL) {

        while (domainMapCount--) {
            LocalFree( domainMapList[domainMapCount].IpAddress );
            LocalFree( domainMapList[domainMapCount].DomainName );
            LocalFree( domainMapList[domainMapCount].ConnectoidName );

            if ( domainMapList[domainMapCount].DnsServerList != NULL ) {
                LocalFree( domainMapList[domainMapCount].DnsServerList );
            }
        }

        LocalFree(domainMapList);
    }

    if ( adapterEnum != NULL ) {
        ClRtlFreeNetAdapterEnum( adapterEnum );
    }

    ASSERT(Resource->State == ClusterResourceOnlinePending);

    //
    // set the final state accordingly. We acquire the lock to synch with the
    // worker thread
    //
    NetNameAcquireResourceLock();

    Resource->State = finalState;
    resourceStatus.ResourceState = finalState;

    NetNameReleaseResourceLock();

    (NetNameSetResourceStatus)( Resource->ResourceHandle, &resourceStatus );

    return(status);

} // NetNameOnlineThread



DWORD
WINAPI
NetNameOfflineWorker(
    IN PNETNAME_RESOURCE    Resource,
    IN BOOL                 Terminate,
    IN PCLUS_WORKER         Worker      OPTIONAL
    )

/*++

Routine Description:

    Internal offline routine for Network Name resource. This routine is called
    by both the offline and terminate routines. Terminate calls it directly
    with Worker set to NULL, while Offline spins a worker thread and then has
    the worker thread call it.

    If terminate is true, we bag any long running operations like removing DNS
    records or renaming/deleting the object. We'll figure out how to deal with
    the resource's carcass the next time it is brought online.

 Arguments:

    Resource - supplies the resource it to be taken offline

    Terminate - indicates whether call is result of NetNameTerminate or NetNameOffline

    Worker - pointer to cluster work thread struct. NULL if called by Terminate

Return Value:

    None.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    nameChanged = FALSE;
    BOOL    deleteCO = FALSE;

    //
    // Terminate any pending thread if it is running.
    //
    if ( Terminate ) {
        ClusWorkerTerminate(&(Resource->PendingThread));
    }

    //
    // Synchronize offline/terminate and worker thread
    //
    NetNameAcquireResourceLock();

    if (Resource->State != ClusterResourceOffline) {
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Offline of resource continuing...\n"
            );

        Resource->State = ClusterResourceOfflinePending;

        NetNameOfflineNetbios( Resource );

        if ( Resource->RefCount > 1 ) {
            //
            // DNS registration is still in progress. If we don't synchronize
            // with the worker thread, then it is possible to delete the
            // resource while the worker routine still had a pointer to the
            // freed memory. kaboom....
            //
            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_INFORMATION,
                              L"Waiting for Worker thread operation to finish\n");

            status = ERROR_IO_PENDING;
        }

        if ( status == ERROR_SUCCESS ) {
            if ( !Terminate ) {
                //
                // If the name was changed or kerb was disbled while we were
                // still online, do the appropriate clean up after we release
                // the netname lock. We have to maintain a reference since a
                // delete can be issued after the resource has gone offline.
                //
                if ( Resource->NameChangedWhileOnline || Resource->DeleteCOWhenOffline ) {
                    ++Resource->RefCount;
                }

                if ( Resource->NameChangedWhileOnline ) {
                    nameChanged = TRUE;
                    Resource->NameChangedWhileOnline = FALSE;
                }

                if ( Resource->DeleteCOWhenOffline ) {
                    deleteCO = TRUE;
                    Resource->DeleteCOWhenOffline = FALSE;
                }
            }

            Resource->State = ClusterResourceOffline;

            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_INFORMATION,
                              L"Resource is now offline\n");
        }
    }
    else {
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource is already offline.\n"
            );
    }

    NetNameReleaseResourceLock();

    if ( !Terminate ) {
        RESOURCE_STATUS resourceStatus;

        ResUtilInitializeResourceStatus( &resourceStatus );
        resourceStatus.ResourceState = ClusterResourceOffline;
        (NetNameSetResourceStatus)( Resource->ResourceHandle, &resourceStatus );

        if ( nameChanged || deleteCO ) {
            //
            // we're not terminating the resource and we need to do some
            // cleanup work. Before each major operation, check if we need to
            // get out due to our Terminate routine being called.
            //
            if ( nameChanged ) {
                if ( !ClusWorkerCheckTerminate( Worker )) {
                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Attempting removal of DNS records\n");

                    RemoveDnsRecords( Resource );
                }
#if RENAME_SUPPORT
                //
                // only rename if we're not deleting and we don't have to
                // terminate
                //
                if ( !deleteCO && !ClusWorkerCheckTerminate( Worker )) {
                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Attempting to rename computer account\n");

                    status = RenameComputerObject( Resource, NULL );
                    if ( status == ERROR_NO_SUCH_DOMAIN ) {
                        //
                        // no DC is available;
                        //
                    }
                    else if ( status != ERROR_SUCCESS ) {
                        //
                        // something else bad happened
                        //
                    }
                }
#endif
            }

            if ( deleteCO && !ClusWorkerCheckTerminate( Worker )) {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_INFORMATION,
                                  L"Attempting to delete computer account\n");

                status = NetNameDeleteComputerObject( Resource );
                if ( status == ERROR_NO_SUCH_DOMAIN ) {
                    //
                    // no DC was available; deal with it
                    //
                }
                else if ( status != ERROR_SUCCESS && status != NERR_UserNotFound ) {
                    //
                    // failed for some other, significant reason
                    //
                }
            }

            NetNameAcquireResourceLock();

            --Resource->RefCount;

            ASSERT( Resource->RefCount >= 0 );
            if ( Resource->RefCount == 0 ) {
                NetNameReleaseResource( Resource );
            }

            NetNameReleaseResourceLock();
        }
    }

    return status;

}  // NetNameOfflineWorker

DWORD
NetNameOfflineThread(
    IN PCLUS_WORKER Worker,
    IN PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    stub routine to call common offline routine used by both terminate and
    offline

Arguments:

    Worker - pointer to cluster work thread

    Resource - pointer to netname resource context block that is going offline

Return Value:

    None

--*/

{
    DWORD   status;

    //
    // notify the worker thread that we're bringing a name offline.
    //
    SetEvent( NetNameWorkerPendingResources );

    status = NetNameOfflineWorker( Resource, FALSE, Worker );

    return status;

} // NetNameOfflineThread

DWORD
RemoveDependentIpAddress(
    PNETNAME_RESOURCE   Resource,
    LPWSTR              DependentResourceId
    )

/*++

Routine Description:

    A dependent IP address resource is being removed. Delete the associated
    DNS records for this address and the netbt device.

Arguments:

    Resource - pointer to private netname resource data

    DependentResourceId - pointer to Unicode string of dependent resource's name

Return Value:

    None

--*/

{
    HCLUSTER        clusterHandle;
    HRESOURCE       ipResourceHandle = NULL;
    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;
    DWORD           status;
    HKEY            ipResourceKey;
    HKEY            parametersKey;
    LPWSTR          reverseName;
    PDNS_LISTS      dnsList;
    DWORD           numberOfDnsLists = Resource->NumberOfDnsLists;
    LPWSTR          ipAddressBuffer;
    IP4_ADDRESS     ipAddress;
    UNICODE_STRING  ipAddressStringW;
    ANSI_STRING     ipAddressStringA;

    //
    // work our way through the miriad of Cluster APIs to read the IP address
    // resource's address from the registry
    //
    clusterHandle = OpenCluster(NULL);
    if (clusterHandle != NULL) {
        ipResourceHandle = OpenClusterResource( clusterHandle, DependentResourceId );
        CloseCluster( clusterHandle );

        if ( ipResourceHandle != NULL ) {
            ipResourceKey = GetClusterResourceKey( ipResourceHandle, KEY_READ );
            CloseClusterResource( ipResourceHandle );

            if ( ipResourceKey != NULL ) {
                status = ClusterRegOpenKey(ipResourceKey,
                                           CLUSREG_KEYNAME_PARAMETERS,
                                           KEY_READ,
                                           &parametersKey);

                ClusterRegCloseKey( ipResourceKey );

                if (status == ERROR_SUCCESS) {
                    ipAddressBuffer = ResUtilGetSzValue( parametersKey, CLUSREG_NAME_IPADDR_ADDRESS );
                    ClusterRegCloseKey( parametersKey );

                    if (ipAddressBuffer == NULL) {
                        status = GetLastError();
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Unable to get resource's Address value for resource "
                                          L"'%1!ws!', status %2!u!.\n",
                                          DependentResourceId,
                                          status);
                    }
                } else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Unable to open parameters key for resource '%1!ws!', "
                                      L"status %2!u!.\n",
                                      DependentResourceId,
                                      status);
                }
            } else {
                status = GetLastError();
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to obtain registry key to resource '%1!ws!', "
                                  L"status %2!u!.\n",
                                  DependentResourceId,
                                  status);
            }
        } else {
            status = GetLastError();
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to open handle to resource '%1!ws!', status %2!u!.\n",
                              DependentResourceId,
                              status);
        }
    } else {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to open handle to cluster, status %1!u!.\n",
                          status);
    }

    //
    // argh. dependencies can be removed while the two resources are in a
    // stable state, i.e., not pending. Furthermore, the remove dependency
    // control is issued to all nodes in the cluster (double argh). This
    // really complicates matters since we're not tracking add dependency
    // which means we potentially don't have current DNS data on all nodes
    // except for the one that owns the resource. Consequently, if all nodes
    // handle the remove then we may use stale DNS info and remove the wrong
    // records at the server.
    //
    // Since this is our only chance to clean up PTR records at the server
    // (due to the fact that the PTR logic uses ModifyRecordSet instead of
    // ReplaceRecordSet), we can only process this request on a node where the
    // resource is online (along with the fact that if the resource is online,
    // then its DNS lists are correct). This is sort of ok since the resource
    // will either 1) go online again at which point the DNS A records will be
    // corrected at the server or 2) the resource will be deleted in which
    // case the last node hosting resource will clean up at the server if
    // possible.
    //
    // In any case, if we can't delete the records, we should log it.
    //
    if ( Resource->State != ClusterResourceOnline || numberOfDnsLists == 0 ) {
        WCHAR   msgBuffer[64];

        msgBuffer[( sizeof( msgBuffer ) / sizeof( WCHAR )) - 1] = UNICODE_NULL;
        if ( status == ERROR_SUCCESS ) {
            _snwprintf(msgBuffer,
                       ( sizeof( msgBuffer ) / sizeof( WCHAR )) - 1,
                       L"IP Address %ws",
                       ipAddressBuffer);

        } else {
            _snwprintf(msgBuffer,
                       ( sizeof( msgBuffer ) / sizeof( WCHAR )) - 1,
                       L"Cluster IP Address resource %ws",
                       DependentResourceId);

        }

        ClusResLogSystemEventByKey1(Resource->ResKey,
                                    LOG_UNUSUAL,
                                    RES_NETNAME_CANT_DELETE_DEPENDENT_RESOURCE_DNS_RECORDS,
                                    msgBuffer);

        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to delete DNS records associated with IP resource '%1!ws!'. "
                          L"The DNS Administrator can delete these records through the DNS "
                          L"management snapin.\n",
                          DependentResourceId);

        if ( ipAddressBuffer != NULL ) {
            LocalFree( ipAddressBuffer );
        }
        return ERROR_SUCCESS;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"RemoveDependentIpAddress: Deleting DNS records associated with resource '%1!ws!'.\n",
                      DependentResourceId);

    RtlInitUnicodeString( &ipAddressStringW, ipAddressBuffer );
    RtlUnicodeStringToAnsiString( &ipAddressStringA,
                                  &ipAddressStringW,
                                  TRUE );
    ipAddress = inet_addr( ipAddressStringA.Buffer );
    RtlFreeAnsiString( &ipAddressStringA );
    
    //
    // finally, we know what to delete. Convert the address into reverse zone
    // format and find it in the resource's DNS list structures.
    //
    reverseName = BuildUnicodeReverseName( ipAddressBuffer );

    if ( reverseName == NULL ) {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to build DNS reverse zone name for resource '%1!ws!', status %2!u!.\n",
                          DependentResourceId,
                          status);
        return status;
    }

    //
    // co-ordinate changes to DnsLists with the worker thread
    //
    NetNameAcquireDnsListLock( Resource );

    dnsList = Resource->DnsLists;
    while ( numberOfDnsLists-- ) {
        PDNS_RECORD dnsRecord;
        PDNS_RECORD lastDnsRecord;
        PDNS_RECORD nextDnsRecord;
        DNS_STATUS  dnsStatus;

        if ( dnsList->ForwardZoneIsDynamic ) {
            dnsRecord = dnsList->A_RRSet.pFirstRR;
            lastDnsRecord = NULL;

            while( dnsRecord != NULL ) {
                if ( dnsRecord->Data.A.IpAddress == ipAddress ) {
                    //
                    // found a match. we need to whack just that record from
                    // the server and from our DNS lists.
                    //
                    nextDnsRecord = dnsRecord->pNext;
                    dnsRecord->pNext = NULL;

                    dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                        dnsRecord,
                                                        DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                        NULL,
                                                        dnsList->DnsServerList,
                                                        NULL);

                    if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_INFORMATION,
                                          L"Deleted DNS A record at server: name: %1!ws! IP Address: %2!ws!\n",
                                          dnsRecord->pName,
                                          ipAddressBuffer);

                    } else {
                        WCHAR   statusBuf[ 32 ];

                        _snwprintf(statusBuf, ( sizeof( statusBuf ) / sizeof( WCHAR )) - 1,
                                   L"%d",
                                   dnsStatus );
                        ClusResLogSystemEventByKey3(Resource->ResKey,
                                                    LOG_UNUSUAL,
                                                    RES_NETNAME_DNS_SINGLE_A_RECORD_DELETE_FAILED,
                                                    dnsRecord->pName,
                                                    ipAddressBuffer,
                                                    statusBuf);

                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_ERROR,
                                          L"Failed to delete DNS A record at server: owner: %1!ws!, "
                                          L"IP Address: %2!ws!. status %3!u!\n",
                                          dnsRecord->pName,
                                          ipAddressBuffer,
                                          dnsStatus);
                    }

                    //
                    // fix up forward ptrs
                    //
                    if ( lastDnsRecord != NULL ) {
                        lastDnsRecord->pNext = nextDnsRecord;
                    } else {
                        dnsList->A_RRSet.pFirstRR = nextDnsRecord;
                    }

                    //
                    // fix up last ptr if necessary
                    //
                    if ( dnsList->A_RRSet.pLastRR == dnsRecord ) {
                        dnsList->A_RRSet.pLastRR = lastDnsRecord;
                    }

                    //
                    // have DNS clean up its allocations and free the record
                    DnsRecordListFree( dnsRecord, DnsFreeRecordListDeep );
                    break;
                }

                lastDnsRecord = dnsRecord;
                dnsRecord = dnsRecord->pNext;

            } // while dnsRecord != NULL
        } // if forward zone is dynamic

        if ( dnsList->ReverseZoneIsDynamic ) {
            dnsRecord = dnsList->PTR_RRSet.pFirstRR;
            lastDnsRecord = NULL;

            while( dnsRecord != NULL ) {
                if ( _wcsicmp( reverseName, dnsRecord->pName ) == 0 ) {
                    //
                    // found a match. we need to whack that record from the
                    // server and from our DNS lists. This also means that we
                    // have to fix up the RRSet struct if the record we're
                    // whacking is either first and/or last.
                    //
                    nextDnsRecord = dnsRecord->pNext;
                    dnsRecord->pNext = NULL;

                    dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                        dnsRecord,
                                                        DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                        NULL,
                                                        dnsList->DnsServerList,
                                                        NULL);

                    if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_INFORMATION,
                                          L"Deleted DNS PTR record at server: name: %1!ws! host: %2!ws!\n",
                                          dnsRecord->pName,
                                          dnsRecord->Data.PTR.pNameHost
                                          );
                    } else {
                        WCHAR   statusBuf[ 32 ];

                        _snwprintf(statusBuf,  ( sizeof( statusBuf ) / sizeof( WCHAR )) - 1,
                                   L"%d",
                                   dnsStatus );
                        ClusResLogSystemEventByKey3(Resource->ResKey,
                                                    LOG_UNUSUAL,
                                                    RES_NETNAME_DNS_PTR_RECORD_DELETE_FAILED,
                                                    dnsRecord->pName,
                                                    dnsRecord->Data.PTR.pNameHost,
                                                    statusBuf);

                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_ERROR,
                                          L"Failed to delete DNS PTR record: owner %1!ws! "
                                          L"host: %2!ws!, status %3!u!\n",
                                          dnsRecord->pName,
                                          dnsRecord->Data.PTR.pNameHost,
                                          dnsStatus
                                          );
                    }

                    //
                    // fix up forward ptrs
                    //
                    if ( lastDnsRecord != NULL ) {
                        lastDnsRecord->pNext = nextDnsRecord;
                    } else {
                        dnsList->PTR_RRSet.pFirstRR = nextDnsRecord;
                    }

                    //
                    // fix up last ptr if necessary
                    //
                    if ( dnsList->PTR_RRSet.pLastRR == dnsRecord ) {
                        dnsList->PTR_RRSet.pLastRR = lastDnsRecord;
                    }

                    //
                    // have DNS clean up its allocations and free the record
                    DnsRecordListFree( dnsRecord, DnsFreeRecordListDeep );
                    break;
                }

                lastDnsRecord = dnsRecord;
                dnsRecord = dnsRecord->pNext;

            } // while dnsRecord != NULL
        } // if reverse zone is dynamic

        ++dnsList;

    } // while more dns lists to process

    NetNameReleaseDnsListLock( Resource );

    LocalFree( reverseName );
    LocalFree( ipAddressBuffer );

    return ERROR_SUCCESS;
} // RemoveDependentIpAddress

VOID
RemoveDnsRecords(
    PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    delete all the DNS records associated with this resource.

Arguments:

    Resource - pointer to private netname resource data

Return Value:

    None

--*/

{
    PDNS_LISTS  dnsLists;
    DNS_STATUS  dnsStatus;
    PDNS_RECORD dnsRecord;
    PDNS_RECORD nextDnsRecord;
    ULONG       numberOfDnsLists;

    if ( Resource->NumberOfDnsLists == 0 ) {
        //
        // nothing to cleanup; log an entry in the event log so they know what
        // to do
        //
        ClusResLogSystemEventByKey(Resource->ResKey,
                                   LOG_UNUSUAL,
                                   RES_NETNAME_CANT_DELETE_DNS_RECORDS);
        return;
    }

    NetNameAcquireDnsListLock( Resource );

    dnsLists = Resource->DnsLists;
    numberOfDnsLists = Resource->NumberOfDnsLists;

    while ( numberOfDnsLists-- ) {

        if ( dnsLists->ReverseZoneIsDynamic ) {
            //
            // whack the PTR records; see the write up in RegisterDnsRecords
            // for this bit of funkiness
            //
            dnsRecord = dnsLists->PTR_RRSet.pFirstRR;
            while ( dnsRecord != NULL ) {

                nextDnsRecord = dnsRecord->pNext;
                dnsRecord->pNext = NULL;

                dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                    dnsRecord,
                                                    DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                    NULL,
                                                    dnsLists->DnsServerList,
                                                    NULL);

                if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Deleted DNS PTR record at server: owner: %1!ws! host: %2!ws!\n",
                                      dnsRecord->pName,
                                      dnsRecord->Data.PTR.pNameHost
                                      );
                } else {
                    WCHAR   statusBuf[ 32 ];

                    _snwprintf(statusBuf,  ( sizeof( statusBuf ) / sizeof( WCHAR )) - 1,
                               L"%d",
                               dnsStatus );
                    ClusResLogSystemEventByKey3(Resource->ResKey,
                                                LOG_UNUSUAL,
                                                RES_NETNAME_DNS_PTR_RECORD_DELETE_FAILED,
                                                dnsRecord->pName,
                                                dnsRecord->Data.PTR.pNameHost,
                                                statusBuf);

                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_ERROR,
                                      L"Failed to delete DNS PTR record: owner %1!ws! host: %2!ws!, status %3!u!\n",
                                      dnsRecord->pName,
                                      dnsRecord->Data.PTR.pNameHost,
                                      dnsStatus
                                      );
                }

                dnsRecord->pNext = nextDnsRecord;
                dnsRecord = nextDnsRecord;
            }
        }

        //
        // it's possible to remove all dependencies from the netname
        // resource. In that situation, we're left with no DNS records.
        //
        if ( dnsLists->ForwardZoneIsDynamic && dnsLists->A_RRSet.pFirstRR != NULL ) {
            //
            // delete the A records from the DNS server
            //
            dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                dnsLists->A_RRSet.pFirstRR,
                                                DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                NULL,
                                                dnsLists->DnsServerList,
                                                NULL);

            if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {

                dnsRecord = dnsLists->A_RRSet.pFirstRR;
                while ( dnsRecord != NULL ) {
                    struct in_addr ipAddress;

                    ipAddress.s_addr = dnsRecord->Data.A.IpAddress;
                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Deleted DNS A record at server: owner: %1!ws! IP Address: %2!hs!\n",
                                      dnsRecord->pName,
                                      inet_ntoa( ipAddress ));

                    dnsRecord = dnsRecord->pNext;
                }
            } else {
                WCHAR   statusBuf[ 32 ];

                _snwprintf(statusBuf,  ( sizeof( statusBuf ) / sizeof( WCHAR )) - 1,
                           L"%d",
                           dnsStatus );
                ClusResLogSystemEventByKey2(Resource->ResKey,
                                            LOG_UNUSUAL,
                                            RES_NETNAME_DNS_A_RECORD_DELETE_FAILED,
                                            dnsLists->A_RRSet.pFirstRR->pName,
                                            statusBuf);

                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Failed to delete DNS A record at server: owner: %1!ws!, status %2!u!\n",
                                  dnsLists->A_RRSet.pFirstRR->pName,
                                  dnsStatus
                                  );
            }
        }

        ++dnsLists;
    }

    NetNameReleaseDnsListLock( Resource );

    NetNameCleanupDnsLists( Resource );
} // RemoveDnsRecords

DWORD
NetNameGetNetworkName(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_NETWORK_NAME control function
    for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_MORE_DATA - More data is available than can fit in OutBuffer.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    //
    // Calculate the required number of bytes required for
    // the network name string.
    //
    required = (lstrlenW( ResourceEntry->Params.NetworkName ) + 1) * sizeof( WCHAR );

    //
    // Make sure we can return the required number of bytes.
    //
    if ( BytesReturned == NULL ) {
        status = ERROR_INVALID_PARAMETER;
    } else {
        //
        // Copy the required number of bytes to the output parameter.
        //
        *BytesReturned = required;

        //
        // If there is no output buffer, the call just wanted the size.
        //
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            //
            // If the output buffer is large enough, copy the data.
            // Otherwise return an error.
            //
            if ( OutBufferSize >= required ) {
                lstrcpyW( OutBuffer, ResourceEntry->Params.NetworkName );
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        }
    }

    return(status);

} // NetNameGetNetworkName

//
// Public Functions
//
BOOLEAN
WINAPI
NetNameDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD     Reason,
    IN LPVOID    Reserved
    )
{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        return(NetNameInit( DllHandle ));
        break;

    case DLL_PROCESS_DETACH:
        NetNameCleanup();
        break;

    default:
        break;
    }

    return(TRUE);

} // NetNameDllEntryPoint



RESID
WINAPI
NetNameOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Network Name resource

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - a registry key for access registry information for this
            resource.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    NULL on failure

--*/

{
    DWORD               status;
    HKEY                parametersKey = NULL;
    HKEY                nodeParametersKey = NULL;
    HKEY                ResKey=NULL;
    PNETNAME_RESOURCE   resource = NULL;
    LPWSTR              nodeName = NULL;
    DWORD               nameSize = MAX_COMPUTERNAME_LENGTH + 1;
    LPWSTR              nodeId = NULL;
    DWORD               nodeIdSize = 6;
    NETNAME_PARAMS      paramBlock;
    LPWSTR              lastName = NULL;
    DWORD               dwFlags;
    DWORD               randomSize;
    HCLUSTER            clusterHandle;
    HRESOURCE           clusterResourceHandle = NULL;

    RtlZeroMemory( &paramBlock, sizeof( paramBlock ));

    //
    // Open a handle to the resource and remember it.
    //
    clusterHandle = OpenCluster(NULL);

    if (clusterHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open handle to cluster, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    clusterResourceHandle = OpenClusterResource(
                                    clusterHandle,
                                    ResourceName
                                    );

    CloseCluster( clusterHandle );
    if (clusterResourceHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open handle to resource <%1!ws!>, status %2!u!.\n",
            ResourceName,
            status
            );
        goto error_exit;
    }

    //
    // Figure out what node we are running on.
    //
    nodeName = LocalAlloc(LMEM_FIXED, nameSize * sizeof(WCHAR));

    if (nodeName == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    if ( !GetComputerNameW(nodeName, &nameSize) ) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get local node name, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    nodeId = LocalAlloc(LMEM_FIXED, nodeIdSize * sizeof(WCHAR));

    if (nodeId == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = GetCurrentClusterNodeId(nodeId, &nodeIdSize);

    if (status != ERROR_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get local node name, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open handles to our key, our parameters key, and our node parameters
    // key in the registry
    //
    status = ClusterRegOpenKey(ResourceKey,
                               L"",
                               KEY_ALL_ACCESS,
                               &ResKey);

    if (status != ERROR_SUCCESS)
    {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open the top level key,status %1!u!.\n",
            status
        );
        goto error_exit;
    }

    status = ClusterRegOpenKey(ResourceKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               KEY_ALL_ACCESS,
                               &parametersKey);

    if (status != NO_ERROR) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key, status %1!u!.\n",
            status);
        goto error_exit;
    }

    status = ClusterRegOpenKey(
                 parametersKey,
                 nodeId,
                 KEY_ALL_ACCESS,
                 &nodeParametersKey
                 );

    if (status == NO_ERROR) {

        //
        // Fetch our parameters from the registry.
        //
        status = NetNameGetParameters(ResourceKey,
                                      parametersKey,
                                      nodeParametersKey,
                                      ResourceHandle,
                                      &paramBlock,
                                      &randomSize,
                                      &lastName,
                                      &dwFlags);

        if (status == ERROR_SUCCESS && lastName != NULL) {

            //
            // Delete the name if it is currently instantiated, making sure
            // that the specified network name is not the same as the
            // computername of this node.
            //
            if (lstrcmpiW(lastName, nodeName) != 0) {
                DeleteServerName(ResourceHandle, lastName);
            }
        }
    } else {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_UNUSUAL,
                              L"Unable to open node parameters key, status %1!u!.\n",
                              status);
        }
    }

    //
    // Now we're ready to create a resource.
    //
    resource = NetNameAllocateResource(ResourceHandle);

    if (resource == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource structure.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    } else {
        status = ERROR_SUCCESS;
    }


    resource->RefCount = 1;
    resource->NodeName = nodeName;
    resource->NodeId = nodeId;
    resource->State = ClusterResourceOffline;
    resource->ResKey = ResKey;
    resource->ParametersKey = parametersKey;
    resource->NodeParametersKey = nodeParametersKey;
    resource->Params = paramBlock;
    resource->RandomSize = randomSize;
    resource->dwFlags = dwFlags;
    resource->ClusterResourceHandle = clusterResourceHandle;
    resource->NameChangedWhileOnline = FALSE;

    //
    // initialize the mutex used to protect the DNS list data.
    //
    resource->DnsListMutex = CreateMutex(NULL, FALSE, NULL);
    if ( resource->DnsListMutex == NULL ) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to initialize DNS list mutex: %1!d!.\n",
            status);
        goto error_exit;
    }

    //
    // insert resource in list for DNS check routine
    //
    NetNameAcquireResourceLock();
    InsertHeadList( &NetNameResourceListHead, &resource->Next );
    NetNameReleaseResourceLock();

    InterlockedIncrement(&NetNameOpenCount);

#ifdef COMPOBJ_SUPPORT
    //
    // If a computer object already exists for this name, get its object
    // GUID. We can't fail the open if this doesn't succeed: while the
    // resource may have its name property set, it may have never gone online,
    // therefore there maybe no CO in the DS at this point in time.
    //
    if ( resource->Params.NetworkName != NULL ) {
        GetComputerObjectGuid( resource );
    }
#endif

error_exit:
    if (lastName != NULL) {
        LocalFree(lastName);
    }

    if (status == ERROR_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Successful open of resid %1!u!\n",
            resource
            );
    } else {

        if (paramBlock.NetworkName != NULL) {
            LocalFree(paramBlock.NetworkName);
        }

        if (paramBlock.NetworkRandom != NULL) {
            LocalFree(paramBlock.NetworkRandom);
        }

        if (parametersKey != NULL) {
            ClusterRegCloseKey(parametersKey);
        }

        if (ResKey != NULL){
            ClusterRegCloseKey(ResKey);
        }
        if (nodeParametersKey != NULL) {
            ClusterRegCloseKey(nodeParametersKey);
        }

        if (clusterResourceHandle != NULL) {
            CloseClusterResource(clusterResourceHandle);
        }

        if (nodeName != NULL) {
            LocalFree(nodeName);
        }

        if (nodeId != NULL) {
            LocalFree(nodeId);
        }

        if (resource != NULL) {
            LocalFree(resource);
        }

        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Open failed, status %1!u!\n",
            status
            );

        SetLastError(status);
    }

    return resource;
} // NetNameOpen



DWORD
WINAPI
NetNameOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Network Name resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PNETNAME_RESOURCE      resource = (PNETNAME_RESOURCE) Resource;
    DWORD                  threadId;
    DWORD                  status=ERROR_SUCCESS;


    if (resource == NULL) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    NetNameAcquireResourceLock();

    resource->State = ClusterResourceOnlinePending;

    status = ClusWorkerCreate(
                 &resource->PendingThread,
                 NetNameOnlineThread,
                 resource
                 );

    if (status != ERROR_SUCCESS) {
        resource->State = ClusterResourceFailed;

        (NetNameLogEvent)(
            resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to start online thread, status %1!u!.\n",
            status
            );
    }
    else {
        status = ERROR_IO_PENDING;
    }

    NetNameReleaseResourceLock();

    return(status);

} // NetNameOnline

DWORD
WINAPI
NetNameOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for Network Name resource. Spin a worker thread and return
    pending.

Arguments:

    Resource - supplies resource id to be taken offline.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD                   status;
    PNETNAME_RESOURCE       resource = (PNETNAME_RESOURCE) Resource;

    if (resource != NULL) {
        (NetNameLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Taking resource offline...\n"
            );

        status = ClusWorkerCreate(&resource->PendingThread,
                                  NetNameOfflineThread,
                                  resource);

        if (status != ERROR_SUCCESS) {
            resource->State = ClusterResourceFailed;

            (NetNameLogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to start offline thread, status %1!u!.\n",
                status
                );
        }
        else {
            status = ERROR_IO_PENDING;
        }
    }
    else {
        status = ERROR_RESOURCE_NOT_FOUND;
    }

    return(status);

}  // NetNameOffline


VOID
WINAPI
NetNameTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for Network Name resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PNETNAME_RESOURCE       resource = (PNETNAME_RESOURCE) Resource;

    if (resource != NULL) {
        (NetNameLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Terminating resource...\n"
            );

        /* Ruihu: 11/06/2000 */
        NetNameAcquireResourceLock();
        if ((resource->State != ClusterResourceOffline)  && 
            (resource->State != ClusterResourceOfflinePending))
        {
            //
            // only call private offline routine if we haven't called it
            // already
            //
            NetNameReleaseResourceLock();
            NetNameOfflineWorker( resource, TRUE, NULL );
            NetNameAcquireResourceLock();
        }
        resource->State = ClusterResourceOffline;
        NetNameReleaseResourceLock();
        /* Ruihu: 11/06/2000 */
    }

    return;

} // NetNameTerminate



BOOL
WINAPI
NetNameLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for Network Name resource.

    Check that any Netbt plumbing is still intact. Then check the status of
    the last DNS operation. Finally check the kerberos status and fail if
    appropriate to do so.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PNETNAME_RESOURCE   resource = (PNETNAME_RESOURCE) Resource;
    BOOL                isHealthy = TRUE;
    DWORD               status;
    DWORD               numberOfFailures = 0;
    ULONG               numberOfDnsLists;
    PDNS_LISTS          dnsLists;
    BOOL                dnsFailure = FALSE;

    if (resource == NULL) {
         return(FALSE);
    }

    NetNameAcquireResourceLock();

    //
    // avoid gotos by breaking out of fake do loop
    //
    do {

        status = NetNameCheckNbtName(resource->Params.NetworkName,
                                     resource->NameHandleCount,
                                     resource->NameHandleList,
                                     resource->ResourceHandle);

        if ( status != ERROR_SUCCESS ) {
            ClusResLogSystemEventByKeyData1(resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_CANT_ADD_NAME,
                                            sizeof(status),
                                            &status,
                                            resource->Params.NetworkName);

            (NetNameLogEvent)(resource->ResourceHandle,
                              LOG_INFORMATION,
                              L"Name %1!ws! failed IsAlive/LooksAlive check, error %2!u!.\n",
                              resource->Params.NetworkName,
                              status);

            isHealthy = FALSE;
            break;
        }

        //
        // check how many of the DNS A record registrations are correct. We
        // don't acquire the resource's DNS list lock since we're only reading
        // the status out of a struct. The resource can't be deleted while
        // we're in this routine and we're not walking the DNS records
        // associated with this list so the number of lists won't change out
        // from underneath of us.
        //
        numberOfDnsLists = resource->NumberOfDnsLists;
        dnsLists = resource->DnsLists;

        while ( numberOfDnsLists-- ) {
            DNS_STATUS dnsStatus;

            dnsStatus = InterlockedExchange(&dnsLists->LastARecQueryStatus,
                                            dnsLists->LastARecQueryStatus);

            if (dnsStatus != DNS_ERROR_RCODE_NO_ERROR && dnsStatus != ERROR_TIMEOUT ) {
                dnsFailure = TRUE;
                ++numberOfFailures;
            }

            ++dnsLists;
        }

        //
        // If DNS is required and we detected a failure other than timeout or all
        // DNS name registrations failed and there are no netbt names associated
        // with this name, then we need to fail the resource
        //
        if ( ( resource->Params.RequireDNS && dnsFailure )
             ||
             ( numberOfFailures == resource->NumberOfDnsLists
               &&
               resource->NameHandleCount == 0 ) )
        {
            isHealthy = FALSE;
            break;
        }

#if 0
        if ( resource->DoKerberosCheck ) {
            //
            // ISSUE-01/03/13 charlwi - should resource fail if can't reach DS?
            //
            // The problem here is that we might have lost our connection to a
            // DC. Does that mean we fail the name? Not sure, since we don't know
            // if replication has been late. On the other hand, if the object has
            // been deleted from the DS, we should take some sort of action. This
            // will affect clients that do not have tickets at this point, i.e.,
            // existing clients with tickets will continue to work.
            //
            // see if our kerb plumbing is intact by getting a handle to the
            // computer object and checking its DnsHostName and
            // SecurityPrincipalName attributes
            //
            status = InterlockedExchange( &resource->KerberosStatus, resource->KerberosStatus );

            if ( status != ERROR_SUCCESS ) {
                isHealthy = FALSE;
            }
        }
#endif

    } while ( FALSE );

    NetNameReleaseResourceLock();

    return isHealthy;

} // NetNameLooksAlive



BOOL
WINAPI
NetNameIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for Network Name resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return(NetNameLooksAlive(Resource));

} // NetNameIsAlive



VOID
WINAPI
NetNameClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for Network Name resource.

Arguments:

    Resource - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PNETNAME_RESOURCE   resource = (PNETNAME_RESOURCE) Resource;
    PLIST_ENTRY         entry;


    if (resource != NULL) {

        ClusWorkerTerminate( &resource->PendingThread );
        if ( InterlockedDecrement(&NetNameOpenCount) == 0 ) {
            // This is the last resource //
            // Kill NetNameWorker        //
            //
            // set the event to terminate the worker thread and wait for it to
            // terminate.
            //
            if ( NetNameWorkerThread != NULL ) {
                DWORD status;
                SetEvent( NetNameWorkerTerminate );
                status = WaitForSingleObject(NetNameWorkerThread, 3 * 60 * 1000);
                if ( status == WAIT_TIMEOUT ) {
                    (NetNameLogEvent)(
                        resource->ResourceHandle,
                        LOG_CRITICAL,
                        L"Worker routine failed to stop. Terminating resrcmon.\n");
                    ClusResLogSystemEventByKey(resource->ResKey,
                                               LOG_CRITICAL,
                                               RES_NETNAME_DNS_CANNOT_STOP
                                               );
                    ExitProcess(WAIT_TIMEOUT);
                }
            
                CloseHandle( NetNameWorkerThread );
                NetNameWorkerThread = NULL;
            }
        }

        NetNameAcquireResourceLock();

        //
        // release our reference to this block. If the DNS worker thread
        // doesn't have an outstanding reference to it, then we can zap the
        // block now. Otherwise the DNS check routine will detect that the ref
        // count went to zero and get rid of it then. In either case, remove
        // it from the resource block list to avoid the problem where an
        // identical resource is recreated and both blocks are on the list.
        //
        RemoveEntryList(&resource->Next); 

        ASSERT( resource->RefCount > 0 );
        if ( --resource->RefCount == 0 ) {
            NetNameReleaseResource( resource );
        }

        NetNameReleaseResourceLock();
    }

    return;

} // NetNameClose


DWORD
NetNameGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for resources of type Network Name.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    typedef struct DEP_DATA {
        CLUSPROP_SZ_DECLARE( ipaddrEntry, sizeof(IP_ADDRESS_RESOURCETYPE_NAME) / sizeof(WCHAR) );
        CLUSPROP_SYNTAX endmark;
    } DEP_DATA, *PDEP_DATA;
    PDEP_DATA   pdepdata = (PDEP_DATA)OutBuffer;
    DWORD       status;

    *BytesReturned = sizeof(DEP_DATA);
    if ( OutBufferSize < sizeof(DEP_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( pdepdata, sizeof(DEP_DATA) );
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof(IP_ADDRESS_RESOURCETYPE_NAME);
        lstrcpyW( pdepdata->ipaddrEntry.sz, IP_ADDRESS_RESOURCETYPE_NAME );
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return status;

} // NetNameGetRequiredDependencies

DWORD
NetNameResourceControl(
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Network Name resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PNETNAME_RESOURCE   resourceEntry = (PNETNAME_RESOURCE)Resource;
    DWORD               required;
    BOOL                readOnly = FALSE;
    BOOL                nameHasChanged;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( NetNameResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = NetNameGetRequiredDependencies( OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned
                                                     );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( NetNameResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES:
            //
            // NOTE: fallthrough is the required behavior here.
            //
            readOnly = TRUE;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = NetNameGetPrivateResProperties( resourceEntry,
                                                     readOnly,
                                                     OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = NetNameValidatePrivateResProperties( resourceEntry,
                                                          InBuffer,
                                                          InBufferSize,
                                                          NULL,
                                                          &nameHasChanged);
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = NetNameSetPrivateResProperties( resourceEntry,
                                                     InBuffer,
                                                     InBufferSize );
            break;

        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
            //fm has changed the cluster name, this resource should read its
            //private name property from the registry if it is a core resource
            status = NetNameClusterNameChanged(resourceEntry);
            break;

        case CLUSCTL_RESOURCE_GET_NETWORK_NAME:
            status = NetNameGetNetworkName( resourceEntry,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            RemoveDnsRecords( resourceEntry );

#ifdef COMPOBJ_SUPPORT
            //
            // if resource was created but has no properities, then
            // NetworkName can be NULL
            //
            if ( resourceEntry->Params.NetworkName != NULL ) {
                NetNameDeleteComputerObject( resourceEntry );
            }
#endif

            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
            //
            // argh! resource dependencies can be removed without any veto
            // power by the resource DLL. We could be deleting the last
            // dependent resource which leaves netname with nothing.
            //
            RemoveDependentIpAddress( resourceEntry, InBuffer );
            status = ERROR_SUCCESS;
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // NetNameResourceControl

DWORD
NetNameResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Network Name resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( NetNameResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = NetNameGetRequiredDependencies( OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned
                                                     );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( NetNameResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // NetNameResourceTypeControl

DWORD
NetNameGetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE    ResourceEntry,
    IN     BOOL                 ReadOnly,
    OUT    PVOID                OutBuffer,
    IN     DWORD                OutBufferSize,
    OUT    LPDWORD              BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    ReadOnly - true if we're selecting read only property table

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD   status;
    DWORD   required;

    //
    // The resutil routines don't support resources with r/w, r/o, and unknown
    // props very well. There is no easy way to get just the unknown
    // properties. For the r/o request, the props are separated out into a
    // separate table. For the r/w case, if we call RUGetAllProperties using
    // the r/w table, we get the r/o props back since they weren't in the
    // table. If we combine the two tables into one, then the r/o case is
    // broken, i.e., it returns the r/w props as well as the r/o ones.
    //
    // The current (yucky) solution is to have 3 tables: r/w, r/o, and
    // combined. Combined is used to get any unknown props that are associated
    // with the resource. It would be nice to have a resutils routine that
    // gathers the unknown props using a list of prop list tables as input.
    //
    if ( ReadOnly ) {
        status = ResUtilGetProperties(ResourceEntry->ParametersKey,
                                      NetNameResourceROPrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    } else {
        //
        // get the r/w props first; after the call, required will be non-zero
        // if the buffer wasn't large enough. Regardless, we have to continue
        // to get the amount of space for any unknown props
        //
        status = ResUtilGetProperties(ResourceEntry->ParametersKey,
                                      NetNameResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );

        //
        // Add unknown properties to the property list.
        //
        if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA ) {
            status = ResUtilAddUnknownProperties(ResourceEntry->ParametersKey,
                                                 NetNameResourceCombinedPrivateProperties,
                                                 OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned,
                                                 &required);
        }
    } // end of if getting r/w props

    //
    // This is kinda wierd: if null is passed in for the input buffer, the
    // return status is success and required reflects how many bytes are
    // needed.  If a buffer was specified but it was too small, then more data
    // is returned. It appears that the thing to watch is required indicating
    // that more space is needed regardless of whether a buffer was specified
    // or not.
    //
    if ( required > 0 && ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )) {
        *BytesReturned = required;
    }

    return(status);

} // NetNameGetPrivateResProperties

DWORD
NetNameValidatePrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PNETNAME_PARAMS Params,
    OUT PBOOL NewNameIsDifferent
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

    NewNameIsDifferent - TRUE if the new name is different than the current name

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_DATA - No input data.

    ERROR_INVALID_NETNAME - The specified network name has invalid characters.

    RPC_S_STRING_TOO_LONG - The specified network name is too long.

    ERROR_BUSY - The specified network name is already in use.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    CLRTL_NAME_STATUS   netnameStatus;
    NETNAME_PARAMS      currentProps;
    NETNAME_PARAMS      newProps;
    PNETNAME_PARAMS     pParams;
    LPWSTR              nameOfPropInError;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private properties from the cluster
    // database. This may be different from what is stored in ResourceEntry
    // since the name could be online at this point in time.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 NetNameResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(NETNAME_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       NetNameResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( NetNameResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {

        *NewNameIsDifferent = FALSE;

        //
        // check the new name if:
        //     the name has never been set  (ResourceEntry value is null)
        // OR
        // (   it is different from the future name (currentProps).
        //   AND
        //     it is different from the name currently online (ResourceEntry)
        // )
        //
        // ClRtlIsNetNameValid will fail if the name hasn't changed and the name
        // is online. currentProps value is NULL only when the name is first
        // created and hasn't been online at all, i.e., no data in the
        // registry. Once brought online, the currentProps value is always
        // non-NULL hence no need to test if the pointer is valid.
        //
        if (ResourceEntry->Params.NetworkName == NULL
            ||
            (
             _wcsicmp( pParams->NetworkName, currentProps.NetworkName ) != 0
             &&
             _wcsicmp( pParams->NetworkName, ResourceEntry->Params.NetworkName ) != 0
             )
            )            
        {
            //
            // Validate the parameter values.
            //
            if ( !ClRtlIsNetNameValid( pParams->NetworkName, &netnameStatus, TRUE /* CheckIfExists */ ) ) {
                switch ( netnameStatus ) {
                case NetNameTooLong:
                    status = RPC_S_STRING_TOO_LONG;
                    break;
                case NetNameInUse:
                    status = ERROR_DUP_NAME;
                    break;
                case NetNameDNSNonRFCChars:
                    //
                    // we leave it up to the calling application to do the
                    // validation and ask the user if non-RFC chars
                    // (underscores) are acceptable.
                    //
                    status = ERROR_SUCCESS;
                    break;
                case NetNameInvalidChars:
                default:
                    status = ERROR_INVALID_NETNAME;
                    break;
                }
            }

#ifdef COMPOBJ_SUPPORT
            //
            // The NewNameIsDifferent flag drives the offline cleanup
            // routine. If the name has truly changed while it was online,
            // then we want to do the appropriate cleanup when it goes
            // offline. The problem is that the name can change many times
            // while it is online; it could return to its current value so the
            // overall appearance is that it never changed. In that case, we
            // want to avoid cleanup.
            //
            // If we're here because we're creating the name for the first
            // time and the properties haven't been read from the registry,
            // (ResourceEntry->Params.NetworkName equals NULL), then don't
            // consider the name to be changed. Otherwise, we consider it
            // changed if it is different from the currently stored name
            // (currentProps) or the current "online" name
            // (ResourceEntry->...).
            //
            if ( status == ERROR_SUCCESS && ResourceEntry->Params.NetworkName != NULL ) {

                if ( _wcsicmp( pParams->NetworkName, currentProps.NetworkName ) != 0
                     &&
                     _wcsicmp( pParams->NetworkName, ResourceEntry->Params.NetworkName ) != 0
                   )
                {
                    BOOL    objectExists;

                    //
                    // a CO for the new name can't already exist in the DS if
                    // we're renaming a netname that has been online at least
                    // once. Renaming would require deleting the existing
                    // object which is a bad decision for netname to be
                    // making.
                    //
                    status = IsComputerObjectInDS(ResourceEntry->NodeName,
                                                  pParams->NetworkName,
                                                  &objectExists);

                    if ( status == ERROR_SUCCESS && objectExists ) {
                        status = E_ADS_OBJECT_EXISTS;
                    }

                    *NewNameIsDifferent = TRUE;
                }
            }
#else
            *NewNameIsDifferent = TRUE;
#endif  // COMPOBJ_SUPPORT
        }

        if ( status == ERROR_SUCCESS ) {
            //
            // passed the valid check. now check that RequireDns must be set
            // if RequireKerberos is set
            //
            if ( !pParams->RequireDNS && pParams->RequireKerberos ) {
                status = ERROR_CLUSTER_PARAMETER_MISMATCH;
            }
        }
    } // end if ResUtilVerifyPropertyTable was successful

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (( status != ERROR_SUCCESS && pParams != NULL )
        || 
        pParams == &newProps
       )
    {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   NetNameResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        NetNameResourcePrivateProperties
        );

    return(status);

} // NetNameValidatePrivateResProperties

DWORD
NetNameSetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    newNameIsDifferent;
    BOOL    disablingKerberos;

    NETNAME_PARAMS  params;

    ZeroMemory( &params, sizeof(NETNAME_PARAMS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = NetNameValidatePrivateResProperties( ResourceEntry,
                                                  InBuffer,
                                                  InBufferSize,
                                                  &params,
                                                  &newNameIsDifferent);
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }


    //
    // If network name is one of the parameters to be set, convert the name
    // to uppercase.
    //
    if ( params.NetworkName != NULL ) {
        _wcsupr( params.NetworkName );
    }

    //
    // if kerb is currently required and we're turning it off, then note that
    // now.
    //
    disablingKerberos = ( ResourceEntry->Params.RequireKerberos && !params.RequireKerberos );

    if ( ResourceEntry->State == ClusterResourceOnline ||
         ResourceEntry->State == ClusterResourceOnlinePending )
    {
        //
        // If the resource is online, remember that the name property has
        // truly changed (it can change and then be set back to its original
        // value while online) and whether we need to delete the CO because is
        // no longer required.
        //
        ResourceEntry->NameChangedWhileOnline = newNameIsDifferent;
        ResourceEntry->DeleteCOWhenOffline = disablingKerberos;

        status = ERROR_RESOURCE_PROPERTIES_STORED;
    }
    else {
        if ( newNameIsDifferent ) {
            //
            // name change; try to cleanup the old name's DNS records
            //
            RemoveDnsRecords( ResourceEntry );

#if RENAME_SUPPORT
            //
            // ISSUE-01/04/05 charlwi - changes required if object renaming is supported
            //
            // Renaming the object adds another wrinkle at this point in that
            // we always need to make sure that the name of the object in the
            // DS is the same as the netname name property. So if we change
            // the name, we change the object name. If we change the name back
            // to its original name (without necessarily bringing it online),
            // then we have to change the object name as well.
            //
            // The previous strategy worked since all that was cleaned up
            // during a name change were the DNS records. If a name was
            // changed and then changed back to its original name, the most
            // damage done was the deletion of the DNS records which would
            // have been re-registered the next time the name went
            // online. With object renaming, we will probably need to track
            // the renaming events separately from whether the name has
            // changed from what is stored in the registry (the current
            // property value).
            //
            if ( !disablingKerberos ) {
                status = RenameComputerObject( ResourceEntry, params.NetworkName );

                if ( status == ERROR_NO_SUCH_DOMAIN ) {
                    //
                    // no DC is available; remember this so we can rename
                    // when we bring the name back online.
                    //
                    status = ERROR_SUCCESS;
                }
                else if ( status != ERROR_SUCCESS ) {
                }
            }
#endif
        }

        if ( disablingKerberos ) {
            status = NetNameDeleteComputerObject( ResourceEntry );
            if ( status == NERR_UserNotFound ) {
                //
                // it's not an error if the CO is already gone
                //
                status = ERROR_SUCCESS;
            }
            else if ( status == ERROR_NO_SUCH_DOMAIN ) {
                //
                // can't contact a DC right now. Remember that and the old
                // name so we can try to rename when brought online again.
                //
            }
        }
    }

    if ( status == ERROR_SUCCESS || status == ERROR_RESOURCE_PROPERTIES_STORED ) {
        //
        // Save the parameter values.
        //
        status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                                   NetNameResourcePrivateProperties,
                                                   NULL,
                                                   (LPBYTE) &params,
                                                   InBuffer,
                                                   InBufferSize,
                                                   NULL );
    }

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               NetNameResourcePrivateProperties );

    return status;

} // NetNameSetPrivateResProperties


/****
@func       BOOL | NetNameClusterNameChanged| Called when FM notifies the
            core network resource dll that the cluster name and the private
            name property of the resource has been changed.

@parm       PNETNAME_RESOURCE | pResource | Pointer to the netname
            resource whose name is being changed.

@comm       A core network resource updates its inmemory structure by reading the
            registry.
@xref
****/
DWORD
NetNameClusterNameChanged(
    IN PNETNAME_RESOURCE Resource
    )
{

    LPWSTR  NetworkName;
    DWORD   dwError = ERROR_SUCCESS;

    if (Resource->dwFlags & CLUS_FLAG_CORE)
    {
        //
        // Read the private parameters.
        //
        NetworkName = ResUtilGetSzValue(
                                   Resource->ParametersKey,
                                   PARAM_NAME__NAME
                                   );

        if (NetworkName == NULL) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"NameChanged -  unable to read network name parameter.\n"
                );
            goto error_exit;
        }
        if (Resource->Params.NetworkName) {
            LocalFree(Resource->Params.NetworkName);
        }

        Resource->Params.NetworkName = NetworkName;
    }
error_exit:
    return(dwError);
} // NetNameClusterNameChanged



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( NetNameFunctionTable,      // Name
                         CLRES_VERSION_V1_00,       // Version
                         NetName,                   // Prefix
                         NULL,                      // Arbitrate
                         NULL,                      // Release
                         NetNameResourceControl,    // ResControl
                         NetNameResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\netname\netname.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    netname.h

Abstract:

    defines for netname resource DLL

Author:

    Charlie Wickham (charlwi) 21-Jan-2001

Environment:

    User Mode

Revision History:

--*/

#include <windns.h>
#include <dsgetdc.h>

//
// local defines
//
#define COUNT_OF( x )   ( sizeof( x ) / sizeof( x[0] ))

#define NetNameLogEvent             ClusResLogEvent

//
// module externs
//
extern ULONG    NetNameWorkerCheckPeriod;
extern LPWSTR   NetNameCompObjAccountDesc;

//
// Resource Property constants
//

#define PARAM_NAME__NAME                CLUSREG_NAME_NET_NAME
#define PARAM_NAME__FLAGS               CLUSREG_NAME_FLAGS

#define PARAM_NAME__REMAP               L"RemapPipeNames"
#define PARAM_DEFAULT__REMAP            FALSE

#define PARAM_NAME__RANDOM              L"Random"
#define PARAM_NAME__LASTNAME            L"LastName"
#define PARAM_NAME__STATUS_NETBIOS      L"StatusNetBIOS"
#define PARAM_NAME__STATUS_DNS          L"StatusDNS"
#define PARAM_NAME__STATUS_KERBEROS     L"StatusKerberos"

#define PARAM_NAME__REQUIRE_DNS         L"RequireDNS"
#define PARAM_DEFAULT__REQUIRE_DNS      0

#define PARAM_NAME__REQUIRE_KERBEROS    L"RequireKerberos"
#define PARAM_DEFAULT__REQUIRE_KERBEROS 0

#define PARAM_NAME__NEXT_UPDATE         L"NextUpdate"

#define PARAM_NAME__UPDATE_INTERVAL     L"UpdateInterval"
#define PARAM_DEFAULT__UPDATE_INTERVAL  ( 60 * 24 * 7 )         // 1 week 
#define PARAM_MINIMUM__UPDATE_INTERVAL  ( 60 )                  // 1 hour
#define PARAM_MAXIMUM__UPDATE_INTERVAL  ( 60 * 24 * 7 * 365 )   // 1 year

//
// netname worker thread check frequencies for when talking to the DNS server
// goes as expected and when they don't. periods are in seconds. Short periods
// are for testing.
//
//#define _SHORT_PERIODS

#ifdef _SHORT_PERIODS
#define NETNAME_WORKER_NORMAL_CHECK_PERIOD      60
#define NETNAME_WORKER_PROBLEM_CHECK_PERIOD     60
#define NETNAME_WORKER_PENDING_PERIOD            2
#else
#define NETNAME_WORKER_NORMAL_CHECK_PERIOD      (60 * 60 * 24)      // 24 hours
#define NETNAME_WORKER_PROBLEM_CHECK_PERIOD     (60 * 10)           // 10 minutes
#define NETNAME_WORKER_PENDING_PERIOD            60
#endif

//
// this struct is used to hold the matched set of DNS A and PTR records with
// which the network name's DNS name and reverse name are registered.
// {Fwd,Rev}ZoneIsDynamic is used as a validity flag in the case where the
// initial DnsUpdateTest call timed out and we later discover that this server
// doesn't except updates. In that case, ZoneIsDynamic is set to FALSE and the
// worker thread checks for these records are skipped.
//
// In hind sight, each record type should have had its own DNS_LIST entry
// instead of putting both A and PTR together in one structure. This has led
// to constructing an invalid list of PTR records in its
// DNS_RRSET. Consequently, there is some ugly code in RegisterDnsRecords that
// has to build a fake DNS_RRSET in order to get the PTR records registered.
//

typedef struct _DNS_LISTS {
    DNS_RRSET   A_RRSet;
    DNS_STATUS  LastARecQueryStatus;
    DNS_RRSET   PTR_RRSet;
    DNS_STATUS  LastPTRRecQueryStatus;  // not used
    PIP4_ARRAY  DnsServerList;
    LPWSTR      ConnectoidName;

    //
    // TRUE if we couldn't contact the server during record build time. This
    // means that the worker thread will need to call DnsUpdateTest to
    // determine if the server is dynamic
    //
    BOOL        UpdateTestTimeout;

    //
    // used to "invalidate" this entry if we discovered after online that the
    // server isn't dynamic
    //
    BOOL        ForwardZoneIsDynamic;

    //
    // TRUE if we've already logged an error about this entry in the system
    // event log
    //
    BOOL        AErrorLogged;

    //
    // PTR corresponding vars with same functionality as their A counterparts
    //
    BOOL        ReverseZoneIsDynamic;
    BOOL        PTRErrorLogged;
} DNS_LISTS, *PDNS_LISTS;

//
// set this define to one to get addt'l debug spew to see the interaction with
// the DNS server and determine if the RRSet structures are getting built
// correctly.
//
#define DBG_DNSLIST 0

//
// this struct is used to hold the mapping between a cluster IP address and a
// DNS domain name. The FQDN is built using these domain suffixes and the
// cluster netname. The connectoid name is included so we can log over which
// NIC we did the registration.
//

typedef struct _DOMAIN_ADDRESS_MAPPING {
    LPWSTR      ConnectoidName;
    LPWSTR      IpAddress;
    LPWSTR      DomainName;
    PIP4_ARRAY  DnsServerList;
} DOMAIN_ADDRESS_MAPPING, *PDOMAIN_ADDRESS_MAPPING;

//
// backing structure for resource properties
//
typedef struct _NETNAME_PARAMS {
    //
    // the name that is currently online
    //
    LPWSTR      NetworkName;

    //
    // true if RemapPipeNames set to one; used by SQL to remap virtual pipe
    // names to the node's name (?)
    //
    DWORD       NetworkRemap;

    //
    // pointer to r/o encrypted computer object password
    //
    PBYTE       NetworkRandom;

    //
    // R/W props: if set to TRUE, the respective section must succeed for the
    // resource to go online. RequireKerberos implies RequireDNS.
    //
    BOOL        RequireDNS;
    BOOL        RequireKerberos;

    //
    // read-only props that reflect final status codes for the corresponding
    // functionality
    //
    DWORD       StatusNetBIOS;
    DWORD       StatusDNS;
    DWORD       StatusKerberos;

    //
    // read-only timestamp of when to perform next password update
    //
    FILETIME    NextUpdate;

    //
    // R/W pwd update interval in minutes
    //
    // ISSUE: units should be changed to hours and maybe even days 
    //
    DWORD   UpdateInterval;
} NETNAME_PARAMS, *PNETNAME_PARAMS;

//
// netname resource context block. One per instance of a netname resource.
//
typedef struct {
    LIST_ENTRY              Next;
    LONG                    RefCount;               // ref count on entire resource block
    CLUSTER_RESOURCE_STATE  State;
    RESOURCE_HANDLE         ResourceHandle;         // handle to ourselves
    DWORD                   dwFlags;
    HANDLE *                NameHandleList;         // array of netbios w/s handles
    DWORD                   NameHandleCount;
    CLUS_WORKER             PendingThread;
    LPWSTR                  NodeName;
    LPWSTR                  NodeId;

    //
    // handles to our resource key, resource parameters key and node
    // parameters keys as well as the resource itself
    //
    HKEY        ResKey;
    HKEY        ParametersKey;
    HKEY        NodeParametersKey;
    HRESOURCE   ClusterResourceHandle;

    //
    // used during online pending processing so we can keep increasing the
    // checkpoint value for each individual resource
    //
    ULONG   StatusCheckpoint;

    //
    // count and pointer to the DNS publishing information; mutex is used to
    // sync access to DnsLists and NumberOfDnsLists
    //
    HANDLE      DnsListMutex;
    DWORD       NumberOfDnsLists;
    PDNS_LISTS  DnsLists;

    //
    // holder of resource properties
    //
    NETNAME_PARAMS  Params;
    
    //
    // used to handle case where the name property has changed while the
    // resource is online. If TRUE, then offline processing will take
    // appropriate steps to handle this condition.
    //
    BOOL    NameChangedWhileOnline;

    //
    // number of bytes pointed to by Params.NetworkRandom
    //
    DWORD   RandomSize;

    //
    // objectGUID attribute of the computer object from DS. Using the GUID
    // frees us from having to track object moves in the DS.
    //
    LPWSTR  ObjectGUID;

    //
    // DoKerberosCheck is TRUE if AddComputerObject was successful. This is
    // used by the worker thread to check on the computer object. The status
    // returned by that check is stored in KerberosStatus.
    //
    BOOL    DoKerberosCheck;
    DWORD   KerberosStatus;

    //
    // used to track if we should delete the computer account at the DS when
    // the resource goes offline. This happens when RequireKerberos is changed
    // from one to zero. If we don't do this, client's will not fallback to
    // NTLM authentication when negotiating a security context.
    //
    BOOL    DeleteCOWhenOffline;
} NETNAME_RESOURCE, *PNETNAME_RESOURCE;

//
// public routines
//
DWORD
GrowBlock(
    PCHAR * Block,
    DWORD   UsedEntries,
    DWORD   BlockSize,
    PDWORD  FreeEntries
    );

DWORD
NetNameCheckNbtName(
    IN LPCWSTR         NetName,
    IN DWORD           NameHandleCount,
    IN HANDLE *        NameHandleList,
    IN RESOURCE_HANDLE ResourceHandle
    );


#ifdef __cplusplus
extern "C" {
#endif

DWORD
NetNameAddComputerObject(
    IN  PCLUS_WORKER        Worker,
    IN  PNETNAME_RESOURCE   Resource,
    OUT PWCHAR *            MachinePwd
    );

DWORD
NetNameDeleteComputerObject(
    IN  PNETNAME_RESOURCE   Resource
    );

HRESULT
CheckComputerObjectAttributes(
    IN  PNETNAME_RESOURCE   Resource
    );

DWORD
IsComputerObjectInDS(
    IN  LPWSTR  NodeName,
    IN  LPWSTR  NewObjectName,
    OUT PBOOL   ObjectExists
    );

HRESULT
GetComputerObjectGuid(
    IN PNETNAME_RESOURCE    Resource
    );

HRESULT
RenameComputerObject(
    IN  PNETNAME_RESOURCE   Resource,
    IN  LPWSTR              NewName     OPTIONAL
    );

DWORD
UpdateCompObjPassword(
    IN  PNETNAME_RESOURCE   Resource
    );

#ifdef __cplusplus
}
#endif

/* end netname.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\smbshare\dumpsd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dumpsd.c

Abstract:

    Dump security desc., ACLs, and access masks to the log. This is resource
    specific but otherwise identical to the routines in clusrtl\security.c

Author:

    Charlie Wickham (charlwi) 12/05/00

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "lm.h"
#include "lmerr.h"
#include "lmshare.h"
#include <dfsfsctl.h>
#include <srvfsctl.h>
#include <lmdfs.h>

#define g_LogEvent ClusResLogEvent

static VOID
SmbGetSidTypeDesc(
    SID_NAME_USE    SidType,
    LPSTR           pszSidType,
    size_t          cchSidType
    )

/*++

Routine Description:

    Convert the SidType into a meaningful string.

Arguments:

    SidType -
    pszSidType
    cchSidType

Return Value:

        none

--*/

{

    if ((pszSidType != NULL) && (cchSidType > 0))
    {
        char    szSidType [128];

        switch (SidType) {
        case SidTypeUser:
            lstrcpyA(szSidType, "has a user SID for");
            break;

        case SidTypeGroup:
            lstrcpyA(szSidType, "has a group SID for");
            break;

        case SidTypeDomain:
            lstrcpyA(szSidType, "has a domain SID for");
            break;

        case SidTypeAlias:
            lstrcpyA(szSidType, "has an alias SID for");
            break;

        case SidTypeWellKnownGroup:
            lstrcpyA(szSidType, "has a SID for a well-known group for");
            break;

        case SidTypeDeletedAccount:
            lstrcpyA(szSidType, "has a SID for a deleted account for");
            break;

        case SidTypeInvalid:
            lstrcpyA(szSidType, "has an invalid SID for");
            break;

        case SidTypeUnknown:
            lstrcpyA(szSidType, "has an unknown SID type:");
            break;

        default:
            szSidType [0] = '\0';
            break;

        } // switch: SidType

        strncpy(pszSidType, szSidType, cchSidType);

    } // if: buffer not null and has space allocated

}  //*** SmbGetSidTypeDesc()

static VOID
SmbExamineSid(
    RESOURCE_HANDLE ResourceHandle,
    PSID            pSid,
    LPSTR           lpszOldIndent
    )

/*++

Routine Description:

    Dump the SID.

Arguments:

    pSid -
    lpzOldIndent -

Return Value:

        none

--*/

{
    CHAR            szUserName [128];
    CHAR            szDomainName [128];
    DWORD           cbUser  = sizeof(szUserName);
    DWORD           cbDomain = sizeof(szDomainName);
    SID_NAME_USE    SidType;

    if ( LookupAccountSidA( NULL, pSid, szUserName, &cbUser, szDomainName, &cbDomain, &SidType ) )
    {
        char    szSidType [128];

        SmbGetSidTypeDesc( SidType, szSidType, sizeof( szSidType ) );
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"%1!hs!%2!hs! %3!hs!\\%4!hs!\n",
                     lpszOldIndent, szSidType, szDomainName, szUserName ) ;
    }

}  // *** SmbExamineSid()

VOID
SmbExamineMask(
    RESOURCE_HANDLE ResourceHandle,
    ACCESS_MASK     amMask
    )

/*++

Routine Description:

    Dump the AccessMask context.

Arguments:

    amMask -
    lpzOldIndent -

Return Value:

        none

--*/

{
    #define STANDARD_RIGHTS_ALL_THE_BITS 0x00FF0000L
    #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

    DWORD dwGenericBits;
    DWORD dwStandardBits;
    DWORD dwSpecificBits;
    DWORD dwAccessSystemSecurityBit;
    DWORD dwExtraBits;

    dwStandardBits            = (amMask & STANDARD_RIGHTS_ALL_THE_BITS);
    dwSpecificBits            = (amMask & SPECIFIC_RIGHTS_ALL         );
    dwAccessSystemSecurityBit = (amMask & ACCESS_SYSTEM_SECURITY      );
    dwGenericBits             = (amMask & GENERIC_RIGHTS_ALL_THE_BITS );

    // **************************************************************************
    // *
    // * Print then decode the standard rights bits
    // *
    // **************************************************************************

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Standard Rights        == 0x%1!.8x!\n", dwStandardBits);

    if (dwStandardBits) {

        if ((dwStandardBits & DELETE) == DELETE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                 L"                              0x%1!.8x! DELETE\n", DELETE);
        }

        if ((dwStandardBits & READ_CONTROL) == READ_CONTROL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! READ_CONTROL\n", READ_CONTROL);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_READ) == STANDARD_RIGHTS_READ) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_READ\n", STANDARD_RIGHTS_READ);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_WRITE) == STANDARD_RIGHTS_WRITE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_WRITE\n", STANDARD_RIGHTS_WRITE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_EXECUTE) == STANDARD_RIGHTS_EXECUTE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_EXECUTE\n", STANDARD_RIGHTS_EXECUTE);
        }

        if ((dwStandardBits & WRITE_DAC) == WRITE_DAC) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! WRITE_DAC\n", WRITE_DAC);
        }

        if ((dwStandardBits & WRITE_OWNER) == WRITE_OWNER) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! WRITE_OWNER\n", WRITE_OWNER);
        }

        if ((dwStandardBits & SYNCHRONIZE) == SYNCHRONIZE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! SYNCHRONIZE\n", SYNCHRONIZE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_REQUIRED) == STANDARD_RIGHTS_REQUIRED) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_REQUIRED\n", STANDARD_RIGHTS_REQUIRED);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_ALL) == STANDARD_RIGHTS_ALL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_ALL\n", STANDARD_RIGHTS_ALL);
        }

        dwExtraBits = dwStandardBits & (~(DELETE
                                          | READ_CONTROL
                                          | STANDARD_RIGHTS_READ
                                          | STANDARD_RIGHTS_WRITE
                                          | STANDARD_RIGHTS_EXECUTE
                                          | WRITE_DAC
                                          | WRITE_OWNER
                                          | SYNCHRONIZE
                                          | STANDARD_RIGHTS_REQUIRED
                                          | STANDARD_RIGHTS_ALL));
        if (dwExtraBits) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"    Extra standard bits    == 0x%1!.8x! <-This is a problem, should be all 0s\n",
                         dwExtraBits);
        }
    }

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Specific Rights        == 0x%1!.8x!\n", dwSpecificBits);

    // **************************************************************************
    // *
    // * Print then decode the ACCESS_SYSTEM_SECURITY bit
    // *
    // *************************************************************************

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Access System Security == 0x%1!.8x!\n", dwAccessSystemSecurityBit);

    // **************************************************************************
    // *
    // * Print then decode the generic rights bits, which will rarely be on
    // *
    // * Generic bits are nearly always mapped by Windows NT before it tries to do
    // *   anything with them.  You can ignore the fact that generic bits are
    // *   special in any way, although it helps to keep track of what the mappings
    // *   are so that you don't have any surprises
    // *
    // * The only time the generic bits are not mapped immediately is if they are
    // *   placed in an inheritable ACE in an ACL, or in an ACL that will be
    // *   assigned by default (such as the default DACL in an access token).  In
    // *   that case they're mapped when the child object is created (or when the
    // *   default DACL is used at object creation time)
    // *
    // **************************************************************************

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Generic Rights         == 0x%1!.8x!\n", dwGenericBits);

    if (dwGenericBits) {

        if ((dwGenericBits & GENERIC_READ) == GENERIC_READ) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_READ\n", GENERIC_READ);
        }

        if ((dwGenericBits & GENERIC_WRITE) == GENERIC_WRITE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_WRITE\n", GENERIC_WRITE);
        }

        if ((dwGenericBits & GENERIC_EXECUTE) == GENERIC_EXECUTE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_EXECUTE\n", GENERIC_EXECUTE);
        }

        if ((dwGenericBits & GENERIC_ALL) == GENERIC_ALL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_ALL\n", GENERIC_ALL);
        }

        dwExtraBits = dwGenericBits & (~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL));
        if (dwExtraBits) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"    Extra generic bits     == 0x%1!.8x! <-This is a problem, should be all 0s\n",
                         dwExtraBits);
        }
    }

}  // *** SmbExamineMask()

static BOOL
SmbExamineACL(
    RESOURCE_HANDLE ResourceHandle,
    PACL    paclACL
    )

/*++

Routine Description:

    Dump the Access Control List context.

Return Value:

        none

--*/

{
    ACL_SIZE_INFORMATION       asiAclSize;
    ACL_REVISION_INFORMATION   ariAclRevision;
    DWORD                      dwBufLength;
    DWORD                      dwAcl_i;
    ACCESS_ALLOWED_ACE *       paaAllowedAce;

    if (!IsValidAcl(paclACL)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  SmbExamineACL() - IsValidAcl() failed.\n");
        return FALSE;
    }

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(paclACL, &asiAclSize, dwBufLength, AclSizeInformation)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  SmbExamineACL() - GetAclInformation failed.\n");
        return FALSE;
    }

    dwBufLength = sizeof(ariAclRevision);

    if (!GetAclInformation(paclACL, (LPVOID) &ariAclRevision, dwBufLength, AclRevisionInformation)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  SmbExamineACL() - GetAclInformation failed\n");
        return FALSE;
    }

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"  ACL has %1!d! ACE(s), %2!d! bytes used, %3!d! bytes free\n",
                 asiAclSize.AceCount,
                 asiAclSize.AclBytesInUse,
                 asiAclSize.AclBytesFree);

    switch (ariAclRevision.AclRevision) {
        case ACL_REVISION1:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACL revision is %1!d! == ACL_REVISION1\n", ariAclRevision.AclRevision);
            break;
        case ACL_REVISION2:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACL revision is %1!d! == ACL_REVISION2\n", ariAclRevision.AclRevision);
            break;
        default:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACL revision is %1!d! == Unrecognized ACL Revision.\n",
                         ariAclRevision.AclRevision);
            return FALSE;
            break;
    }

    for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount;  dwAcl_i++) {

        if (!GetAce(paclACL, dwAcl_i, (LPVOID *) &paaAllowedAce)) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  SmbExamineACL() - GetAce failed.\n");
            return FALSE;
        }

        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  ACE %1!d! size %2!d!\n", dwAcl_i, paaAllowedAce->Header.AceSize);

        {
            char    szBuf [128];

            wsprintfA(szBuf, "  ACE %d ", dwAcl_i);
            SmbExamineSid(ResourceHandle, &(paaAllowedAce->SidStart), szBuf );
        }

        {
            DWORD dwAceFlags = paaAllowedAce->Header.AceFlags;

            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! flags 0x%2!.2x!\n", dwAcl_i, dwAceFlags);

            if (dwAceFlags) {
                 DWORD   dwExtraBits;

                if ((dwAceFlags & OBJECT_INHERIT_ACE) == OBJECT_INHERIT_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x01 OBJECT_INHERIT_ACE\n");
                }

                if ((dwAceFlags & CONTAINER_INHERIT_ACE) == CONTAINER_INHERIT_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x02 CONTAINER_INHERIT_ACE\n");
                }

                if ((dwAceFlags & NO_PROPAGATE_INHERIT_ACE) == NO_PROPAGATE_INHERIT_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x04 NO_PROPAGATE_INHERIT_ACE\n");
                }

                if ((dwAceFlags & INHERIT_ONLY_ACE) == INHERIT_ONLY_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x08 INHERIT_ONLY_ACE\n");
                }

                if ((dwAceFlags & VALID_INHERIT_FLAGS) == VALID_INHERIT_FLAGS) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x0F VALID_INHERIT_FLAGS\n");
                }

                if ((dwAceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) == SUCCESSFUL_ACCESS_ACE_FLAG) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x40 SUCCESSFUL_ACCESS_ACE_FLAG\n");
                }

                if ((dwAceFlags & FAILED_ACCESS_ACE_FLAG) == FAILED_ACCESS_ACE_FLAG) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x80 FAILED_ACCESS_ACE_FLAG\n");
                }

                dwExtraBits = dwAceFlags & (~(OBJECT_INHERIT_ACE
                                              | CONTAINER_INHERIT_ACE
                                              | NO_PROPAGATE_INHERIT_ACE
                                              | INHERIT_ONLY_ACE
                                              | VALID_INHERIT_FLAGS
                                              | SUCCESSFUL_ACCESS_ACE_FLAG
                                              | FAILED_ACCESS_ACE_FLAG));
                if (dwExtraBits) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"   Extra AceFlag bits     == 0x%1!.8x! <-This is a problem, should be all 0s\n",
                                 dwExtraBits);
                }
            }
        }

        switch (paaAllowedAce->Header.AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is an ACCESS_ALLOWED_ACE_TYPE\n", dwAcl_i);
            break;
        case ACCESS_DENIED_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is an ACCESS_DENIED_ACE_TYPE\n", dwAcl_i);
            break;
        case SYSTEM_AUDIT_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is a  SYSTEM_AUDIT_ACE_TYPE\n", dwAcl_i);
            break;
        case SYSTEM_ALARM_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is a  SYSTEM_ALARM_ACE_TYPE\n", dwAcl_i);
            break;
        default :
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is an IMPOSSIBLE ACE_TYPE!!! Run debugger, examine value!\n", dwAcl_i);
            return FALSE;
        }

        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  ACE %1!d! mask               == 0x%2!.8x!\n", dwAcl_i, paaAllowedAce->Mask);

        SmbExamineMask(ResourceHandle, paaAllowedAce->Mask);
    }

    return TRUE;

}  // *** SmbExamineACL()

BOOL
SmbExamineSD(
    RESOURCE_HANDLE         ResourceHandle,
    PSECURITY_DESCRIPTOR    psdSD
    )

/*++

Routine Description:

    Dump the Security descriptor context.

Arguments:

    psdSD - the SD to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    PACL                        paclDACL;
    PACL                        paclSACL;
    BOOL                        bHasDACL        = FALSE;
    BOOL                        bHasSACL        = FALSE;
    BOOL                        bDaclDefaulted  = FALSE;
    BOOL                        bSaclDefaulted  = FALSE;
    BOOL                        bOwnerDefaulted = FALSE;
    BOOL                        bGroupDefaulted = FALSE;
    PSID                        psidOwner;
    PSID                        psidGroup;
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD                       dwSDRevision;
    DWORD                       dwSDLength;

    if (!IsValidSecurityDescriptor(psdSD)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - IsValidSecurityDescriptor failed.\n");
        return FALSE;
    }

    dwSDLength = GetSecurityDescriptorLength(psdSD);

    if (!GetSecurityDescriptorDacl(psdSD, (LPBOOL) &bHasDACL, (PACL *) &paclDACL, (LPBOOL) &bDaclDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorDacl failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorSacl(psdSD, (LPBOOL) &bHasSACL, (PACL *) &paclSACL, (LPBOOL) &bSaclDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorSacl failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorOwner(psdSD, (PSID *)&psidOwner, (LPBOOL)&bOwnerDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorOwner failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorGroup(psdSD, (PSID *) &psidGroup, (LPBOOL) &bGroupDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorGroup failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorControl(
                                psdSD,
                                (PSECURITY_DESCRIPTOR_CONTROL) &sdcSDControl,
                                (LPDWORD) &dwSDRevision))
    {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorControl failed.\n");
        return FALSE;
    }

    switch (dwSDRevision) {
        case SECURITY_DESCRIPTOR_REVISION1:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD is valid.  SD is %1!d! bytes long.  SD revision is "
                         L"%2!d! == SECURITY_DESCRIPTOR_REVISION1\n",
                         dwSDLength, dwSDRevision);
            break;

        default :
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD is valid.  SD is %1!d! bytes long.  SD revision is "
                         L"%2!d! == ! SD Revision is an IMPOSSIBLE SD revision!!! "
                         L"Perhaps a new revision was added...\n",
                         dwSDLength,
                         dwSDRevision);
            return FALSE;
    }

    if (SE_SELF_RELATIVE & sdcSDControl) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD is in self-relative format (all SDs returned by the system are)\n");
    }

    if (NULL == psidOwner) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's Owner is NULL, so SE_OWNER_DEFAULTED is ignored\n");
    }
    else {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's Owner is Not NULL\n");

        if (bOwnerDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Owner-Defaulted flag is TRUE\n");
        }
        else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Owner-Defaulted flag is FALSE\n");
        }
    }

    // **************************************************************************
    // *
    // * The other use for psidGroup is for Macintosh client support
    // *
    // **************************************************************************

    if (NULL == psidGroup) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's Group is NULL, so SE_GROUP_DEFAULTED is ignored. SD's Group "
                     L"being NULL is typical, GROUP in SD(s) is mainly for POSIX compliance\n");
    }
    else {
        if (bGroupDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Group-Defaulted flag is TRUE\n");
        }
        else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Group-Defaulted flag is FALSE\n");
        }
    }

    if (SE_DACL_PRESENT & sdcSDControl) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's DACL is Present\n");

        if (bDaclDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's DACL-Defaulted flag is TRUE\n");
        } else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's DACL-Defaulted flag is FALSE\n");
        }

        if (NULL == paclDACL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD has a NULL DACL explicitly specified (allows all access to Everyone). "
                         L"This does not apply to this SD, but for comparison, a non-NULL DACL pointer "
                         L"to a 0-length ACL allows  no access to anyone\n");
        }
        else if(!SmbExamineACL(ResourceHandle, paclDACL))  {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SmbExamineSD() - SmbExamineACL failed.\n");
        }
    }
    else {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's DACL is Not Present, so SE_DACL_DEFAULTED is ignored. SD has no "
                     L"DACL at all (allows all access to Everyone)\n");
    }

    if (SE_SACL_PRESENT & sdcSDControl) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's SACL is Present\n");

        if (bSaclDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's SACL-Defaulted flag is TRUE\n");
        }
        else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's SACL-Defaulted flag is FALSE\n");
        }

        if (NULL == paclSACL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD has a NULL SACL explicitly specified\n");
        }
        else if (!SmbExamineACL(ResourceHandle, paclSACL)) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SmbExamineSD() - SmbExamineACL failed.\n");
        }
    }
    else {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's SACL is Not Present, so SE_SACL_DEFAULTED is ignored. SD has no "
                     L"SACL at all (or we did not request to see it)\n");
    }

    return TRUE;

}  // *** SmbExamineSD()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\smbshare\dfsmetaloc.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    dfsmetaloc.c

Abstract:

    DFS metadata locating routines.

Author:

    Uday Hegde (udayh) 10-May-2001

Revision History:

--*/
#define  UNICODE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include <lm.h>

#define DFS_REGISTRY_CHILD_NAME_SIZE_MAX 4096
LPWSTR DfsRootShareValueName = L"RootShare";


LPWSTR OldRegistryString = L"SOFTWARE\\Microsoft\\DfsHost\\volumes";
LPWSTR NewRegistryString = L"SOFTWARE\\Microsoft\\Dfs\\Roots\\Standalone";
LPWSTR DfsOldStandaloneChild = L"domainroot";

DWORD
CheckForShareNameMatch(
    HKEY DfsKey,
    LPWSTR ChildName,
    LPWSTR RootName,
    PBOOLEAN pMatch)
{
    DWORD Status;
    HKEY DfsRootKey;

    LPWSTR DfsRootShare = NULL;
    ULONG DataSize, DataType, RootShareLength;
    
    *pMatch = FALSE;

    Status = RegOpenKeyEx( DfsKey,
                           ChildName,
                           0,
                           KEY_READ,
                           &DfsRootKey );

    if (Status == ERROR_SUCCESS)
    {
        Status = RegQueryInfoKey( DfsRootKey,       // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  NULL );       // Last write time

        if (Status == ERROR_SUCCESS) {
            RootShareLength = DataSize;
            DfsRootShare = (LPWSTR) malloc(DataSize);
            if (DfsRootShare == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                Status = RegQueryValueEx( DfsRootKey,
                                          DfsRootShareValueName,
                                          NULL,
                                          &DataType,
                                          (LPBYTE)DfsRootShare,
                                          &RootShareLength);

                if (Status == ERROR_SUCCESS)
                {
                    if (_wcsicmp(DfsRootShare, RootName) == 0)
                    {
                        *pMatch = TRUE;
                    }
                }
                free(DfsRootShare);
            }
        }
        RegCloseKey( DfsRootKey );
    }

    //
    // we may be dealing with a new key here: which is just being setup.
    // return success if any of the above returned error not found.
    //
    if ((Status == ERROR_NOT_FOUND)  ||
        (Status == ERROR_FILE_NOT_FOUND))
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}


DWORD
DfsGetMatchingChild( 
    HKEY DfsKey,
    LPWSTR RootName,
    LPWSTR FoundChild,
    PBOOLEAN pMatch )
{
    DWORD Status;
    ULONG ChildNum = 0;

    do
    {
        //
        // For each child, get the child name.
        //

        DWORD ChildNameLen = DFS_REGISTRY_CHILD_NAME_SIZE_MAX;
        WCHAR ChildName[DFS_REGISTRY_CHILD_NAME_SIZE_MAX];

        //
        // Now enumerate the children, starting from the first child.
        //
        Status = RegEnumKeyEx( DfsKey,
                               ChildNum,
                               ChildName,
                               &ChildNameLen,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        ChildNum++;


        if ( Status == ERROR_SUCCESS )
        {

            Status = CheckForShareNameMatch( DfsKey,
                                             ChildName,
                                             RootName,
                                             pMatch );
            if ((Status == ERROR_SUCCESS) && (*pMatch == TRUE))
            {
                wcscpy(FoundChild, ChildName);
                break;
            }
        }
    } while (Status == ERROR_SUCCESS);

    //
    // If we ran out of children, then return success code.
    //
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}


DWORD
CreateShareNameToReturn (
    LPWSTR Child1,
    LPWSTR Child2,
    LPWSTR *pReturnName )
{
    DWORD Status;
    ULONG LengthNeeded = 0;
    PVOID BufferToReturn;

    if (Child1 != NULL)
    {
        LengthNeeded += sizeof(WCHAR);
        LengthNeeded += (DWORD) (wcslen(Child1) * sizeof(WCHAR));
    }
    if (Child2 != NULL)
    {
        LengthNeeded += sizeof(WCHAR);
        LengthNeeded += (DWORD) (wcslen(Child2) * sizeof(WCHAR));
    }
    LengthNeeded += sizeof(WCHAR);

    Status = NetApiBufferAllocate( LengthNeeded, &BufferToReturn );

    if (Status == ERROR_SUCCESS)
    {
        if (Child1 != NULL)
        {
            wcscpy(BufferToReturn, Child1);
        }
        if (Child2 != NULL)
        {
            wcscat(BufferToReturn, L"\\");
            wcscat(BufferToReturn, Child2);
        }
        *pReturnName = BufferToReturn;
    }

    return Status;
}


DWORD
DfsCheckNewStandaloneRoots( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation )
{
    BOOLEAN Found;
    HKEY DfsKey;
    WCHAR ChildName[MAX_PATH];
    DWORD Status;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           NewRegistryString,
                           0,
                           KEY_READ,
                           &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetMatchingChild( DfsKey,
                                      RootName,
                                      ChildName,
                                      &Found );

        if (Status == ERROR_SUCCESS) 
        {
            if (Found)
            {
                Status = CreateShareNameToReturn(NewRegistryString,
                                                 ChildName,
                                                 pMetadataNameLocation );
            }
            else
            {
                Status = ERROR_NOT_FOUND;
            }
        }
        RegCloseKey( DfsKey );
    }

    return Status;
}

DWORD
DfsCheckOldStandaloneRoot( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation )
{
    BOOLEAN Found;
    HKEY DfsKey;
    DWORD Status;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           NewRegistryString,
                           0,
                           KEY_READ,
                           &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = CheckForShareNameMatch( DfsKey,
                                         DfsOldStandaloneChild,
                                         RootName,
                                         &Found );

        if (Status == ERROR_SUCCESS) 
        {
            if (Found)
            {
                Status = CreateShareNameToReturn( OldRegistryString,
                                                  DfsOldStandaloneChild,
                                                  pMetadataNameLocation );
            }
            else
            {
                Status = ERROR_NOT_FOUND;
            }
        }
        RegCloseKey( DfsKey );
    }
    return Status;
}





DWORD
GetDfsRootMetadataLocation( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation )
{
    DWORD Status;

    Status = DfsCheckNewStandaloneRoots( RootName,
                                         pMetadataNameLocation );

    if (Status == ERROR_NOT_FOUND)
    {
        Status = DfsCheckOldStandaloneRoot( RootName,
                                            pMetadataNameLocation );
    }
                                         
    return Status;
}




VOID
ReleaseDfsRootMetadataLocation( 
    LPWSTR Buffer )
{
    NetApiBufferFree(Buffer);
}




#if 0
_cdecl
main(
    int argc, 
    char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argcw,i;
    LPWSTR out;
    DWORD Status;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);
    printf("Argvw is %wS\n", argvw[1]);

    Status = GetDfsRootMetadataLocation( argvw[1],
                                         &out );

    printf("Status is %x out is %ws\n", Status, out);
    if (Status == ERROR_SUCCESS)
    {
        ReleaseDfsRootMetadataLocation(out);
    }
    exit(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\resutils\resprop.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    resprop.c

Abstract:

    Implements the management of properties.

Author:

    Rod Gamache (rodga) 19-Mar-1997

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "stdio.h"
#include "stdlib.h"

//
// Cluster Registry API function pointers
//
CLUSTER_REG_APIS
ResUtilClusterRegApis = {
    (PFNCLRTLCREATEKEY) ClusterRegCreateKey,
    (PFNCLRTLOPENKEY) ClusterRegOpenKey,
    (PFNCLRTLCLOSEKEY) ClusterRegCloseKey,
    (PFNCLRTLSETVALUE) ClusterRegSetValue,
    (PFNCLRTLQUERYVALUE) ClusterRegQueryValue,
    (PFNCLRTLENUMVALUE) ClusterRegEnumValue,
    (PFNCLRTLDELETEVALUE) ClusterRegDeleteValue,
    NULL,
    NULL,
    NULL
};



DWORD
WINAPI
ResUtilEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Enumerates the properties for a given object.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    return( ClRtlEnumProperties( pPropertyTable,
                                 pszOutProperties,
                                 cbOutPropertiesSize,
                                 pcbBytesReturned,
                                 pcbRequired ) );


} // ResUtilEnumProperties



DWORD
WINAPI
ResUtilEnumPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Enumerates the properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    return( ClRtlEnumPrivateProperties( hkeyClusterKey,
                                        &ResUtilClusterRegApis,
                                        pszOutProperties,
                                        cbOutPropertiesSize,
                                        pcbBytesReturned,
                                        pcbRequired ) );


} // ResUtilEnumProperties



DWORD
WINAPI
ResUtilGetProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pPropertyList,
    IN DWORD cbPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pPropertyList - Supplies the output buffer.

    cbPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pPropertyList.

    pcbRequired - The required number of bytes if pPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    return( ClRtlGetProperties( hkeyClusterKey,
                                &ResUtilClusterRegApis,
                                pPropertyTable,
                                pPropertyList,
                                cbPropertyListSize,
                                pcbBytesReturned,
                                pcbRequired ) );

} // ResUtilGetProperties



DWORD
WINAPI
ResUtilGetAllProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the default and 'unknown' properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pPropertyList - Supplies the output buffer.

    cbPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pPropertyList.

    pcbRequired - The required number of bytes if pPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    return( ClRtlGetAllProperties( hkeyClusterKey,
                                   &ResUtilClusterRegApis,
                                   pPropertyTable,
                                   pPropertyList,
                                   cbPropertyListSize,
                                   pcbBytesReturned,
                                   pcbRequired ) );

} // ResUtilGetAllProperties



DWORD
WINAPI
ResUtilGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    )

/*++

Routine Description:

    Gets the default and 'unknown' properties for a given object and stores
    them in a parameter block.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pOutParams - Supplies the output parameter block.

    bCheckForRequiredProperties - Boolean value specifying whether missing
        required properties should cause an error.

    pszNameOfPropInError - String pointer in which to return the name of the
        property in error (optional).

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    status = ClRtlGetPropertiesToParameterBlock( hkeyClusterKey,
                                                 &ResUtilClusterRegApis,
                                                 pPropertyTable,
                                                 pOutParams,
                                                 bCheckForRequiredProperties,
                                                 pszNameOfPropInError );
    return(status);

} // ResUtilGetPropertiesToParameterBlock



DWORD
WINAPI
ResUtilPropertyListFromParameterBlock(
    IN const  PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Constructs a property list from a parameter block.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    pcbOutPropertyListSize - Supplies the size of the output buffer.

    pInParams - Supplies the input parameter block.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    status = ClRtlPropertyListFromParameterBlock( pPropertyTable,
                                                  pOutPropertyList,
                                                  pcbOutPropertyListSize,
                                                  pInParams,
                                                  pcbBytesReturned,
                                                  pcbRequired );
    return(status);

} // ResUtilPropertyListFromParameterBlock



DWORD
WINAPI
ResUtilGetPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the private properties for a given object.

    This routine assumes that it uses the Cluster Registry API's for
    access to registry info.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    return( ClRtlGetPrivateProperties( hkeyClusterKey,
                                       &ResUtilClusterRegApis,
                                       pOutPropertyList,
                                       cbOutPropertyListSize,
                                       pcbBytesReturned,
                                       pcbRequired ) );

} // ResUtilGetPrivateProperties



DWORD
WINAPI
ResUtilGetPropertySize(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    )

/*++

Routine Description:

    Get the total number of bytes required for this property.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

Return Value:

--*/

{
    return( ClRtlGetPropertySize( hkeyClusterKey,
                                  &ResUtilClusterRegApis,
                                  pPropertyTableItem,
                                  pcbOutPropertyListSize,
                                  pnPropertyCount ) );

} // ResUtilGetPropertySize



DWORD
WINAPI
ResUtilGetProperty(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    )

/*++

Routine Description:

Arguments:

Return Value:

Notes:

    The buffer size has already been determined to be large enough to hold
    the return data.

--*/

{
    return( ClRtlGetProperty( hkeyClusterKey,
                              &ResUtilClusterRegApis,
                              pPropertyTableItem,
                              pOutPropertyItem,
                              pcbOutPropertyItemSize ) );

} // ResUtilGetProperty



DWORD
WINAPI
ResUtilVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

    Validate a property list.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    Reserved - Possible pointer to a future ReadOnly property table.

    bAllowUnknownProperties - TRUE if unknown properties should be accepted.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    pOutParams - Parameters block in which to return the data.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlVerifyPropertyTable( pPropertyTable,
                                      Reserved,
                                      bAllowUnknownProperties,
                                      pInPropertyList,
                                      cbInPropertyListSize,
                                      pOutParams ) );

} // ResUtilVerifyPropertyTable



DWORD
WINAPI
ResUtilSetPropertyTable(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    Reserved - Possible pointer to a future ReadOnly property table.

    bAllowUnknownProperties - TRUE if unknown properties should be accepted.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    pOutParams - Parameters block in which to return the data.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyTable( NULL,
                                   hkeyClusterKey,
                                   &ResUtilClusterRegApis,
                                   pPropertyTable,
                                   Reserved,
                                   bAllowUnknownProperties,
                                   pInPropertyList,
                                   cbInPropertyListSize,
                                   FALSE, // bForceWrite
                                   pOutParams ) );

} // ResUtilSetPropertyTable



DWORD
WINAPI
ResUtilSetPropertyTableEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    Reserved - Possible pointer to a future ReadOnly property table.

    bAllowUnknownProperties - TRUE if unknown properties should be accepted.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameters block in which to return the data.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyTable( NULL,
                                   hkeyClusterKey,
                                   &ResUtilClusterRegApis,
                                   pPropertyTable,
                                   Reserved,
                                   bAllowUnknownProperties,
                                   pInPropertyList,
                                   cbInPropertyListSize,
                                   bForceWrite,
                                   pOutParams ) );

} // ResUtilSetPropertyTableEx



DWORD
WINAPI
ResUtilSetPropertyParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    pInParams - Parameters block to set.

    pInPropertyList - Full Property list.

    cbInPropertyListSize - Size of the input full property list.

    pOutParams - Parameters block to copy pInParams to.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyParameterBlock( NULL, // IN HANDLE hXsaction, 
                                            hkeyClusterKey,
                                            &ResUtilClusterRegApis,
                                            pPropertyTable,
                                            Reserved,
                                            pInParams,
                                            pInPropertyList,
                                            cbInPropertyListSize,
                                            FALSE, // bForceWrite
                                            pOutParams ) );

} // ResUtilSetPropertyParameterBlock



DWORD
WINAPI
ResUtilSetPropertyParameterBlockEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    pInParams - Parameters block to set.

    pInPropertyList - Full Property list.

    cbInPropertyListSize - Size of the input full property list.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameters block to copy pInParams to.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyParameterBlock( NULL, // IN HANDLE hXsaction, 
                                            hkeyClusterKey,
                                            &ResUtilClusterRegApis,
                                            pPropertyTable,
                                            Reserved,
                                            pInParams,
                                            pInPropertyList,
                                            cbInPropertyListSize,
                                            bForceWrite,
                                            pOutParams ) );

} // ResUtilSetPropertyParameterBlockEx



DWORD
WINAPI
ResUtilSetUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

    Set items that are not in the property table list.

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    pInPropertyList - Full Property list.

    cbInPropertyListSize - Size of the input full property list.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlpSetNonPropertyTable( NULL, // IN HANDLE hXsaction
                                       hkeyClusterKey,
                                       &ResUtilClusterRegApis,
                                       pPropertyTable,
                                       NULL,
                                       pInPropertyList,
                                       cbInPropertyListSize ) );

} // ResUtilSetUnknownProperties



DWORD
WINAPI
ResUtilVerifyPrivatePropertyList(
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

    Validate a private property list.

Arguments:

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlVerifyPrivatePropertyList( pInPropertyList, cbInPropertyListSize ) );

} // ResUtilVerifyPrivatePropertyList



DWORD
WINAPI
ResUtilSetPrivatePropertyList(
    IN HKEY hkeyClusterKey,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this resource's parameters.
        If not specified, the property list will only be validated.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                         hkeyClusterKey,
                                         &ResUtilClusterRegApis,
                                         pInPropertyList,
                                         cbInPropertyListSize ) );

} // ResUtilSetPrivatePropertyList



DWORD
WINAPI
ResUtilAddUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Adds the unknown properties for a given object to the end of a property
    list.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - On input, contains the number of bytes in use in the
        output buffer.  On output, contains the total number of bytes in
        pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;

    status = ClRtlAddUnknownProperties( hkeyClusterKey,
                                        &ResUtilClusterRegApis,
                                        pPropertyTable,
                                        pOutPropertyList,
                                        cbOutPropertyListSize,
                                        pcbBytesReturned,
                                        pcbRequired );

    return(status);

} // ResUtilAddUnknownProperties




//***************************************************************************
//
//   Utility routines to grovel though a Control Function item list buffer
//
//***************************************************************************



DWORD
WINAPI
ResUtilFindSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )

/*++

Routine Description:

    Finds the specified string property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindSzProperty( pPropertyList,
                                 cbPropertyListSize,
                                 pszPropertyName,
                                 pszPropertyValue ) );

} // ResUtilFindSzProperty



DWORD
WINAPI
ResUtilFindExpandSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )

/*++

Routine Description:

    Finds the specified EXPAND_SZ string property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindExpandSzProperty(
                pPropertyList,
                cbPropertyListSize,
                pszPropertyName,
                pszPropertyValue ) );

} // ResUtilFindExpandSzProperty



DWORD
WINAPI
ResUtilFindExpandedSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )

/*++

Routine Description:

    Finds the specified string property in the Property List buffer pointed at
    by pPropertyList and returns it's expanded value.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindExpandedSzProperty(
                pPropertyList,
                cbPropertyListSize,
                pszPropertyName,
                pszPropertyValue ) );

} // ResUtilFindExpandedSzProperty



DWORD
WINAPI
ResUtilFindDwordProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    )

/*++

Routine Description:

    Finds the specified DWORD property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pdwPropertyValue - the matching DWORD value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindDwordProperty( pPropertyList,
                                    cbPropertyListSize,
                                    pszPropertyName,
                                    pdwPropertyValue ) );

} // ResUtilFindDwordProperty

DWORD
WINAPI
ResUtilFindLongProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValue
    )

/*++

Routine Description:

    Finds the specified string in the Value List buffer pointed at by Buffer.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    plPropertyValue - the matching long value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindLongProperty( pPropertyList,
                                    cbPropertyListSize,
                                    pszPropertyName,
                                    plPropertyValue ) );
} // ResUtilFindLongProperty


DWORD
WINAPI
ResUtilFindBinaryProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified binary property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pbPropertyValue - the matching binary value found.

    pcbPropertyValueSize - the length of the matching binary value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindBinaryProperty( pPropertyList,
                                     cbPropertyListSize,
                                     pszPropertyName,
                                     pbPropertyValue,
                                     pcbPropertyValueSize ) );

} // ResUtilFindBinaryProperty



DWORD
WINAPI
ResUtilFindMultiSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified multiple string property in the Proprety List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching multiple string value found.

    pcbPropertyValueSize - the length of the matching multiple string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindMultiSzProperty( pPropertyList,
                                      cbPropertyListSize,
                                      pszPropertyName,
                                      pszPropertyValue,
                                      pcbPropertyValueSize ) );

} // ResUtilFindMultiSzProperty



DWORD
WINAPI
ResUtilDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to return.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    ERROR_SUCCESS - Parameter block duplicated successfully.

--*/

{
    DWORD   status;

    status = ClRtlDupParameterBlock( pOutParams, pInParams, pPropertyTable );

    return(status);

} // ResUtilDupParameterBlock



void
WINAPI
ResUtilFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to free.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    None.

--*/

{
    ClRtlFreeParameterBlock( pOutParams, pInParams, pPropertyTable );

} // ResUtilFreeParameterBlock


#define __INITIAL_NAME_LENGTH 256

BOOL
WINAPI
ResUtilResourceTypesEqual(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    )

/*++

Routine Description:
    Checks to see if the resource names type matches

Arguments:
    lpszResourceTypeName - The type of resource to check for

    hResource - A handle to the resource to check

Return Value:
    TRUE - the resource type matches
    FALSE - the resource types do not match

--*/
{
    BOOL    bIsEqual = FALSE;
    DWORD   dwError;
    WCHAR   szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR  pszName = szName;
    DWORD   cbNameBufSize = __INITIAL_NAME_LENGTH * sizeof( szName[ 0 ] );
    DWORD   cbRetSize;

    do {
        // Get the resource type name
        dwError = ClusterResourceControl(
                    hResource,            //Handle to the resource
                    NULL,                 //Don't care about node
                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, //Get the type
                    0,                    // &InBuffer
                    0,                    // nInBufferSize,
                    pszName,              // &OutBuffer
                    cbNameBufSize,        // nOutBufferSize,
                    &cbRetSize );         // returned size

        if ( dwError == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cbNameBufSize = cbRetSize + sizeof( WCHAR );
            pszName = LocalAlloc( LMEM_FIXED, cbNameBufSize );
            if ( pszName == NULL ) {
                break;
            } // if: error allocating buffer
            dwError = ClusterResourceControl(
                        hResource,            //Handle to the resource
                        NULL,                 //Don't care about node
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, //Get the type
                        0,                    // &InBuffer
                        0,                    // nInBufferSize,
                        pszName,              // &OutBuffer
                        cbNameBufSize,        // nOutBufferSize,
                        &cbRetSize );         // returned size
        } // if: name buffer too small
        if ( dwError != ERROR_SUCCESS ) {
            break;
        }

        // See if it's like US
        if ( lstrcmpiW( lpszResourceTypeName, pszName ) == 0 ) {
            bIsEqual = TRUE;
        }
    } while ( 0 );

    if ( pszName != szName ) {
        LocalFree( pszName );
    } // if: we allocated the output name buffer

    return bIsEqual;

} //*** ResUtilResourceTypesEqual()


BOOL
WINAPI
ResUtilResourcesEqual(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    )

/*++

Routine Description:
    Check to See if the resources are the same

Arguments:
    IN hSelf - a handle to the callee, or NULL to indicate not equal.

    IN hResource - a handle to the resource to compare

Return Value:

    TRUE - Resource are equal
    FALSE - otherwise

--*/
{
    BOOL    bIsEqual = FALSE;
    DWORD   dwError;
    WCHAR   szSelfName[ __INITIAL_NAME_LENGTH ];
    WCHAR   szResName[ __INITIAL_NAME_LENGTH ];
    LPWSTR  pszSelfName = szSelfName;
    LPWSTR  pszResName = szResName;
    DWORD   cbSelfNameBufSize = __INITIAL_NAME_LENGTH * sizeof( szSelfName[ 0 ] );
    DWORD   cbResNameBufSize = __INITIAL_NAME_LENGTH * sizeof( szResName[ 0 ] );
    DWORD   cbRetSize;

    do {
        if ( ( hSelf == NULL ) || ( hResource == NULL ) ) {
            break;
        }

        // Get the resource type name
        dwError = ClusterResourceControl(
                    hSelf,                //Handle to the resource
                    NULL,                 //Don't care about node
                    CLUSCTL_RESOURCE_GET_NAME, //Get the name
                    0,                    // &InBuffer
                    0,                    // nInBufferSize,
                    pszSelfName,          // &OutBuffer
                    cbSelfNameBufSize,    // OutBufferSize,
                    &cbRetSize );         // returned size

        if ( dwError == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cbSelfNameBufSize = cbRetSize + sizeof( WCHAR );
            pszSelfName = LocalAlloc( LMEM_FIXED, cbSelfNameBufSize );
            if ( pszSelfName == NULL ) {
                break;
            } // if: error allocating buffer
            dwError = ClusterResourceControl(
                        hSelf,                //Handle to the resource
                        NULL,                 //Don't care about node
                        CLUSCTL_RESOURCE_GET_NAME, //Get the name
                        0,                    // &InBuffer
                        0,                    // nInBufferSize,
                        pszSelfName,          // &OutBuffer
                        cbSelfNameBufSize,    // OutBufferSize,
                        &cbRetSize );         // returned size
        }
        if ( dwError != ERROR_SUCCESS ) {
            break;
        }

        // Get the resource type name
        dwError = ClusterResourceControl(
                    hResource,            //Handle to the resource
                    NULL,                 //Don't care about node
                    CLUSCTL_RESOURCE_GET_NAME, //Get the name
                    0,                    // &InBuffer
                    0,                    // nInBufferSize,
                    pszResName,           // &OutBuffer
                    cbResNameBufSize,     // OutBufferSize,
                    &cbRetSize );         // returned size

        if ( dwError == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cbResNameBufSize = cbRetSize + sizeof( WCHAR );
            pszResName = LocalAlloc( LMEM_FIXED, cbResNameBufSize );
            if ( pszResName == NULL ) {
                break;
            } // if: error allocating buffer
            dwError = ClusterResourceControl(
                        hResource,            //Handle to the resource
                        NULL,                 //Don't care about node
                        CLUSCTL_RESOURCE_GET_NAME, //Get the name
                        0,                    // &InBuffer
                        0,                    // nInBufferSize,
                        pszResName,           // &OutBuffer
                        cbResNameBufSize,     // OutBufferSize,
                        &cbRetSize );         // returned size
        }
        if ( dwError != ERROR_SUCCESS ) {
            break;
        }

        // See if were looking in a mirror
        if ( lstrcmpiW( pszResName, pszSelfName ) == 0 ) {
            bIsEqual = TRUE;
        }
    } while ( 0 );

    if ( pszSelfName != szSelfName ) {
        LocalFree( pszSelfName );
    }
    if ( pszResName != szResName ) {
        LocalFree( pszResName );
    }

    return bIsEqual;

} //*** ResUtilResourcesEqual()


BOOL
WINAPI
ResUtilIsResourceClassEqual(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    )

/*++

Routine Description:
    Checks to see if the resource names type matches

Arguments:
    prci - The resource class info to check for.

    hResource - A handle to the resource to check.

Return Value:
    TRUE - the resource type matches
    FALSE - the resource types do not match

--*/
{
    BOOL                        bIsEqual = FALSE;
    DWORD                       dwError;
    DWORD                       cbRetSize;
    CLUS_RESOURCE_CLASS_INFO    rci;

    do {
        // Get the resource class info
        dwError = ClusterResourceControl(
                    hResource,            // Handle to the resource
                    NULL,                 // Don't care about node
                    CLUSCTL_RESOURCE_GET_CLASS_INFO, // Get the class info
                    0,                    // &InBuffer
                    0,                    // nInBufferSize,
                    &rci,                 // &OutBuffer
                    sizeof( rci ),        // nOutBufferSize,
                    &cbRetSize );         // returned size

        if ( dwError != ERROR_SUCCESS ) {
            break;
        }

        // See if it's like US
        if ( rci.rc == prci->rc ) {
            bIsEqual = TRUE;
        }
    } while ( 0 );

    return bIsEqual;

} //*** ResUtilIsResourceClassEqual()


DWORD
WINAPI
ResUtilEnumResources(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    )
/*++

Routine Description:
    This is a generic resource walking routine. It enumerates all resources in
    the cluster and invokes the callback function for each resource.


Arguments:

    IN [OPTIONAL] hSelf
                    - A handle to the resource. When enumerating resources do
                      not invoke the callback when the enumerated resource is
                      hSelf.
                      IF NULL then invoke the callback for all resources

    IN [OPTIONAL] lpszResTypeName
                    - This is an optional resource type name. If specified the
                      callback function will only be invoked for resources of
                      this type.

    IN pResCallBack - Pointer to function that gets called for each enumerated
                      resource in the cluster

    IN pParameter   - An Opaque callback parameter

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           dwStatus    = ERROR_SUCCESS;
    HCLUSTER        hCluster    = NULL;
    HCLUSENUM       hClusEnum   = NULL;
    HRESOURCE       hResource   = NULL;
    BOOL            fExecuteCallBack;
    WCHAR           szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR          lpszName = szName;
    DWORD           cchSize = __INITIAL_NAME_LENGTH;
    DWORD           cchRetSize;
    DWORD           dwIndex;
    DWORD           dwType;

    //
    // Open the cluster
    //
    hCluster = OpenCluster( NULL );
    if( hCluster == NULL )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Get a resource enumeration handle
    //
    hClusEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
    if ( hClusEnum == NULL )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Enumerate each resource in the cluster
    //
    dwIndex = 0;

    do
    {
        cchRetSize  = cchSize;
        dwStatus = ClusterEnum(
                        hClusEnum,  //handle to enum
                        dwIndex,    //Index
                        &dwType,    //Type
                        lpszName,   //Name
                        &cchRetSize  //Size of name (in characters)
                        );

        if ( dwStatus == ERROR_MORE_DATA )
        {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating NULL
            if ( lpszName != szName )
            {
                LocalFree( lpszName );
            }
            lpszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( lpszName == NULL )
            {
                dwStatus = GetLastError();
                break;
            }
            cchRetSize = cchSize;
            dwStatus = ClusterEnum(
                            hClusEnum,  //handle to enum
                            dwIndex,    //Index
                            &dwType,    //Type
                            lpszName,   //Name
                            &cchRetSize  //Size of name
                            );
        }
        if ( dwStatus == ERROR_SUCCESS )
        {
            //
            // Try to open this resource
            //
            hResource = OpenClusterResource( hCluster, lpszName );

            if ( hResource == NULL )
            {
                dwStatus = GetLastError();
                if ( dwStatus == ERROR_RESOURCE_NOT_FOUND )
                {
                    //
                    //  If the resource cannot be found, assume it got deleted after
                    //  you opened the enumeration. So, skip the resource and proceed.
                    //
                    dwIndex ++;
                    dwStatus = ERROR_SUCCESS;
                    continue;
                }
                break;
            }

            //
            // Indicate that will invoke the callback
            //
            fExecuteCallBack = TRUE;

            // Determine if we need to check the type
            //
            if ( lpszResTypeName != NULL )
            {
                fExecuteCallBack = ResUtilResourceTypesEqual( lpszResTypeName, hResource );

            } //if lpszResTypeName


            if ( fExecuteCallBack && ( hSelf != NULL ) )
            {
                // Don't execute callback if hResource is callee (i.e., hSelf)
                fExecuteCallBack = !(ResUtilResourcesEqual( hSelf, hResource ));

            } //if fExecuteCallBack && hSelf

            if ( fExecuteCallBack )
            {
                dwStatus = pResCallBack( hSelf, hResource, pParameter );

                if ( dwStatus != ERROR_SUCCESS )
                {
                    break;
                }

            } //if fExecuteCallBack

            CloseClusterResource( hResource );
            hResource = NULL;

        } // If ERROR_SUCCESS

        dwIndex++;
    } while ( dwStatus == ERROR_SUCCESS );

Cleanup:

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    }

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    }

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    }

    if ( lpszName != szName )
    {
        LocalFree( lpszName );
    }

    if ( dwStatus == ERROR_NO_MORE_ITEMS )
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

} //*** ResUtilEnumResources()


DWORD
WINAPI
ResUtilEnumResourcesEx(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    )
/*++

Routine Description:
    This is a generic resource walking routine. It enumerates all resources in
    the cluster and invokes the callback function for each resource.


Arguments:

    IN hCluster     - A handle to the cluster to enumerate resources on.

    IN [OPTIONAL] hSelf
                    - A handle to the resource. When enumerating resources do
                      not invoke the callback when the enumerated resource is
                      hSelf.
                      IF NULL then invoke the callback for all resources

    IN [OPTIONAL] lpszResTypeName
                    - This is an optional resource type name. If specified the
                      callback function will only be invoked for resources of
                      this type.

    IN pResCallBack - Pointer to function that gets called for each enumerated
                      resource in the cluster

    IN pParameter   - An Opaque callback parameter

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           dwStatus    = ERROR_SUCCESS;
    HCLUSENUM       hClusEnum   = NULL;
    HRESOURCE       hResource   = NULL;
    BOOL            fExecuteCallBack;
    WCHAR           szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR          lpszName = szName;
    DWORD           cchSize = __INITIAL_NAME_LENGTH;
    DWORD           cchRetSize;
    DWORD           dwIndex;
    DWORD           dwType;

    //
    // Get a resource enumeration handle
    //
    hClusEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
    if ( hClusEnum == NULL )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Enumerate each resource in the cluster
    //
    dwIndex = 0;

    do
    {
        cchRetSize  = cchSize;
        dwStatus = ClusterEnum(
                        hClusEnum,  //handle to enum
                        dwIndex,    //Index
                        &dwType,    //Type
                        lpszName,   //Name
                        &cchRetSize  //Size of name
                        );

        if ( dwStatus == ERROR_MORE_DATA )
        {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( lpszName != szName )
            {
                LocalFree( lpszName );
            }
            lpszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( lpszName == NULL )
            {
                dwStatus = GetLastError();
                break;
            }
            cchRetSize = cchSize;
            dwStatus = ClusterEnum(
                            hClusEnum,  //handle to enum
                            dwIndex,    //Index
                            &dwType,    //Type
                            lpszName,   //Name
                            &cchRetSize  //Size of name
                            );
        }
        if ( dwStatus == ERROR_SUCCESS )
        {
            //
            // Try to open this resource
            //
            hResource = OpenClusterResource( hCluster, lpszName );

            if ( hResource == NULL )
            {
                dwStatus = GetLastError();
                if ( dwStatus == ERROR_RESOURCE_NOT_FOUND )
                {
                    //
                    //  If the resource cannot be found, assume it got deleted after
                    //  you opened the enumeration. So, skip the resource and proceed.
                    //
                    dwIndex ++;
                    dwStatus = ERROR_SUCCESS;
                    continue;
                }
                break;
            }

            //
            // Indicate that will invoke the callback
            //
            fExecuteCallBack = TRUE;

            // Determine if we need to check the type
            //
            if ( lpszResTypeName != NULL )
            {
                fExecuteCallBack = ResUtilResourceTypesEqual( lpszResTypeName, hResource );

            } //if lpszResTypeName


            if ( fExecuteCallBack && ( hSelf != NULL ) )
            {
                // Don't execute callback if hResource is callee (i.e., hSelf)
                fExecuteCallBack = !(ResUtilResourcesEqual( hSelf, hResource ));

            } //if fExecuteCallBack && hSelf

            if ( fExecuteCallBack )
            {
                dwStatus = pResCallBack( hCluster, hSelf, hResource, pParameter );

                if ( dwStatus != ERROR_SUCCESS )
                {
                    break;
                }

            } //if fExecuteCallBack

            CloseClusterResource( hResource );
            hResource = NULL;

        } // If ERROR_SUCCESS

        dwIndex++;
    } while ( dwStatus == ERROR_SUCCESS );

Cleanup:

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    }

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    }

    if ( lpszName != szName )
    {
        LocalFree( lpszName );
    }

    if ( dwStatus == ERROR_NO_MORE_ITEMS )
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

} //*** ResUtilEnumResourcesEx()



HRESOURCE
WINAPI
ResUtilGetResourceDependency(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    )

/*++

Routine Description:

    Returns a dependent resource for the local cluster.

Arguments:

    hSelf    - A handle to the original resource.

    lpszResourceType - the type of resource that it depends on


Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type ResourceType

--*/
{
    HRESOURCE   hResDepends = NULL;
    HCLUSTER    hCluster    = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize      = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status      = ERROR_SUCCESS;


    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL ) {
        return( NULL );
    }

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if ( hResEnum == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Determine the type of resource found
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            status = GetLastError();
            break;
        }

        if ( hResDepends != NULL ) {
            //
            // Valid resource now open the reg and get it's type
            //
            if ( ResUtilResourceTypesEqual( lpszResourceType, hResDepends ) ) {
                break;
            }

        } //if !hResDepends

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while ( status == ERROR_SUCCESS );

error_exit:
//
// At this point hResDepends is NULL if no match or non-null (success)
//
    if ( hCluster != NULL ) {
        CloseCluster( hCluster );
    }

    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }
    return(hResDepends);

} //*** ResUtilGetResourceDependency()


HRESOURCE
WINAPI
ResUtilGetResourceDependencyByName(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    )

/*++

Routine Description:

    Returns a dependent resource for a specified cluster based on the resource
    type name.

Arguments:

    hCluster - Cluster to query.

    hSelf    - A handle to the original resource.

    lpszResourceType - The name of the resource type of the resource that the
        specified resource depends on.

    bRecurse - TRUE = check dependents of dependents.  An immediate dependency
        will be returned if there is one.

Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type lpszResourceType

--*/
{
    HRESOURCE   hResDepends = NULL;
    HRESOURCE   hResDepends2 = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize      = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status      = ERROR_SUCCESS;

    if ( ( hCluster == NULL ) || ( lpszResourceType == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    } // if: no cluster handle or resource type name specified

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if ( hResEnum == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        //
        // Get the next dependent resource.
        //
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Open the resource.
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            status = GetLastError();
            break;
        }

        //
        // Resource is valid.  Now see if it is the right type.
        //
        if ( ResUtilResourceTypesEqual( lpszResourceType, hResDepends ) ) {
            break;
        }

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while ( status == ERROR_SUCCESS );

    //
    // If a match was not found, recurse the dependencies again looking for a
    // dependency of the dependencies if the bDeep argument was specified.
    //
    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) && bRecurse ) {

        //
        // Open the depends on enum (get resource dependencies)
        //
        ClusterResourceCloseEnum( hResEnum );
        hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

        if ( hResEnum == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        //
        // Enumerate all the depends on keys
        //
        dwIndex = 0;
        do {
            //
            // Get the next dependent resource.
            //
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            if ( status == ERROR_MORE_DATA ) {
                //
                // Output name buffer is too small.  Allocate a new one.
                //
                cchSize = cchRetSize + 1; // Add room for terminating null
                if ( pszName != szName ) {
                    LocalFree( pszName );
                }
                pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
                if ( pszName == NULL ) {
                    status = GetLastError();
                    break;
                } // if:  error allocating memory
                cchRetSize = cchSize;
                status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            }
            if ( status != ERROR_SUCCESS ) {
                break;
            }

            //
            // Open the resource.
            //
            hResDepends2 = OpenClusterResource( hCluster, pszName );
            if ( hResDepends2 == NULL ) {
                status = GetLastError();
                break;
            }

            //
            // Recursively call ourselves with this resource.
            //
            hResDepends = ResUtilGetResourceDependencyByName(
                                hCluster,
                                hResDepends2,
                                lpszResourceType,
                                bRecurse
                                );
            if ( hResDepends != NULL ) {
                break;
            }
            status = GetLastError();
            if ( status != ERROR_RESOURCE_NOT_FOUND ) {
                break;
            }
            status = ERROR_SUCCESS;

            //
            // Close all handles, key's
            //
            if ( hResDepends2 != NULL ) {
                CloseClusterResource( hResDepends2 );
                hResDepends2 = NULL;
            }

            dwIndex++;
        } while ( status == ERROR_SUCCESS );
    }

error_exit:
    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( hResDepends2 != NULL ) {
        CloseClusterResource( hResDepends2 );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) ) {
        status = ERROR_RESOURCE_NOT_FOUND;
    }
    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return hResDepends;

} //*** ResUtilGetResourceDependencyByName()


HRESOURCE
WINAPI
ResUtilGetResourceDependencyByClass(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    )

/*++

Routine Description:

    Returns a dependent resource for a specified cluster based on the resource
    type class information.

Arguments:

    hCluster - Cluster to query.

    hSelf    - A handle to the original resource.

    prci - The resource class info of the resource type of the resource that
        the specified resource depends on.

    bRecurse - TRUE = check dependents of dependents.  An immediate dependency
        will be returned if there is one.

Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource whose class is specified by prci.

--*/
{
    HRESOURCE   hResDepends = NULL;
    HRESOURCE   hResDepends2 = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize     = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status      = ERROR_SUCCESS;

    if ( ( hCluster == NULL ) || ( prci == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    } // if: no cluster handle or class info specified

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if ( hResEnum == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        //
        // Get the next dependent resource.
        //
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Determine the type of resource found
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            status = GetLastError();
            break;
        }

        //
        // Resource is valid.  Now see if it is the right class.
        //
        if ( ResUtilIsResourceClassEqual( prci, hResDepends ) ) {
            break;
        }

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while ( status == ERROR_SUCCESS );

    //
    // If a match was not found, recurse the dependencies again looking for a
    // dependency of the dependencies if the bDeep argument was specified.
    //
    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) && bRecurse ) {

        //
        // Open the depends on enum (get resource dependencies)
        //
        ClusterResourceCloseEnum( hResEnum );
        hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

        if ( hResEnum == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        //
        // Enumerate all the depends on keys
        //
        dwIndex = 0;
        do {
            //
            // Get the next dependent resource.
            //
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            if ( status == ERROR_MORE_DATA ) {
                //
                // Output name buffer is too small.  Allocate a new one.
                //
                cchSize = cchRetSize + 1; // Add room for terminating null
                if ( pszName != szName ) {
                    LocalFree( pszName );
                }
                pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
                if ( pszName == NULL ) {
                    status = GetLastError();
                    break;
                } // if:  error allocating memory
                cchRetSize = cchSize;
                status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            }
            if ( status != ERROR_SUCCESS ) {
                break;
            }

            //
            // Open the resource.
            //
            hResDepends2 = OpenClusterResource( hCluster, pszName );
            if ( hResDepends2 == NULL ) {
                status = GetLastError();
                break;
            }

            //
            // Recursively call ourselves with this resource.
            //
            hResDepends = ResUtilGetResourceDependencyByClass(
                                hCluster,
                                hResDepends2,
                                prci,
                                bRecurse
                                );
            if ( hResDepends != NULL ) {
                break;
            }
            status = GetLastError();
            if ( status != ERROR_RESOURCE_NOT_FOUND ) {
                break;
            }
            status = ERROR_SUCCESS;

            //
            // Close all handles, key's
            //
            if ( hResDepends2 != NULL ) {
                CloseClusterResource( hResDepends2 );
                hResDepends2 = NULL;
            }

            dwIndex++;
        } while ( status == ERROR_SUCCESS );
    }

error_exit:
    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( hResDepends2 != NULL ) {
        CloseClusterResource( hResDepends2 );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) ) {
        status = ERROR_RESOURCE_NOT_FOUND;
    }
    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return hResDepends;

} //*** ResUtilGetResourceDependencyByClass()


HRESOURCE
WINAPI
ResUtilGetResourceNameDependency(
            IN LPCWSTR      lpszResourceName,
            IN LPCWSTR      lpszResourceType
            )

/*++

Routine Description:

    Returns a dependent resource

Arguments:

    lpszResourceName - the name of the resource

    lpszResourceType - the type of the resource that it depends on


Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type ResourceType

--*/
{
    HRESOURCE   hResDepends = NULL;
    HCLUSTER    hCluster    = NULL;
    HRESOURCE   hSelf       = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize      = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status = ERROR_SUCCESS;

    if ( lpszResourceName == NULL )  {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL ) {
        return( NULL );
    }

    //
    // Open a handle to the passed in resource name.
    //
    hSelf = OpenClusterResource( hCluster, lpszResourceName );
    if ( hSelf == NULL ) {
        goto error_exit;
    }

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hResEnum == NULL ) {
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1;   // Add room for terminating NULL
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Determine the type of resource found
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            break;
        }

        //
        // Valid resource now open the reg and get it's type
        //
        if ( ResUtilResourceTypesEqual( lpszResourceType, hResDepends ) ) {
            break;
        }

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while (status == ERROR_SUCCESS);

error_exit:
//
// At this point hResDepends is NULL if no match or non-null (success)
//
    if ( hCluster != NULL ) {
        CloseCluster( hCluster );
    }

    if ( hSelf != NULL ) {
        CloseClusterResource( hSelf );
    }

    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return hResDepends;

} //*** ResUtilGetResourceNameDependency()


DWORD
WINAPI
ResUtilGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyFormatList,
    IN DWORD cbPropertyFormatListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )
{
    return( ClRtlGetPropertyFormats( pPropertyTable,
                                     pOutPropertyFormatList,
                                     cbPropertyFormatListSize,
                                     pcbBytesReturned,
                                     pcbRequired ) );

} // ResUtilGetPropertyFormats()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\smbshare\smbshare.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    smbshare.c

Abstract:

    Resource DLL for File Shares.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "lm.h"
#include "lmerr.h"
#include "lmshare.h"
#include <dfsfsctl.h>
#include <srvfsctl.h>
#include <lmdfs.h>
#include <validc.h>

#define LOG_CURRENT_MODULE LOG_MODULE_SMB

#define SMB_SVCNAME  TEXT("LanmanServer")

#define DFS_SVCNAME  TEXT("Dfs")

#define MAX_RETRIES 20

#define DBG_PRINT printf

#define PARAM_KEYNAME__PARAMETERS       CLUSREG_KEYNAME_PARAMETERS

#define PARAM_NAME__SHARENAME           CLUSREG_NAME_FILESHR_SHARE_NAME
#define PARAM_NAME__PATH                CLUSREG_NAME_FILESHR_PATH
#define PARAM_NAME__REMARK              CLUSREG_NAME_FILESHR_REMARK
#define PARAM_NAME__MAXUSERS            CLUSREG_NAME_FILESHR_MAX_USERS
#define PARAM_NAME__SECURITY            CLUSREG_NAME_FILESHR_SECURITY
#define PARAM_NAME__SD                  CLUSREG_NAME_FILESHR_SD
#define PARAM_NAME__SHARESUBDIRS        CLUSREG_NAME_FILESHR_SHARE_SUBDIRS
#define PARAM_NAME__HIDESUBDIRSHARES    CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES
#define PARAM_NAME__DFSROOT             CLUSREG_NAME_FILESHR_IS_DFS_ROOT
#define PARAM_NAME__CSCCACHE            CLUSREG_NAME_FILESHR_CSC_CACHE

#define PARAM_MIN__MAXUSERS     0
#define PARAM_MAX__MAXUSERS     ((DWORD)-1)
#define PARAM_DEFAULT__MAXUSERS ((DWORD)-1)

#define FREE_SECURITY_INFO()                    \
        LocalFree( params.Security );           \
        params.Security = NULL;                 \
        params.SecuritySize = 0;                \
        LocalFree( params.SecurityDescriptor ); \
        params.SecurityDescriptor = NULL;       \
        params.SecurityDescriptorSize = 0

typedef struct _SUBDIR_SHARE_INFO {
    LIST_ENTRY      ListEntry;
    WCHAR           ShareName [NNLEN+1];
}SUBDIR_SHARE_INFO,*PSUBDIR_SHARE_INFO;


typedef struct _SHARE_PARAMS {
    LPWSTR          ShareName;
    LPWSTR          Path;
    LPWSTR          Remark;
    ULONG           MaxUsers;
    PUCHAR          Security;
    ULONG           SecuritySize;
    ULONG           ShareSubDirs;
    ULONG           HideSubDirShares;
    ULONG           DfsRoot;
    ULONG           CSCCache;
    PUCHAR          SecurityDescriptor;
    ULONG           SecurityDescriptorSize;
} SHARE_PARAMS, *PSHARE_PARAMS;

typedef struct _SHARE_RESOURCE {
    RESID                   ResId; // for validation
    SHARE_PARAMS            Params;
    HKEY                    ResourceKey;
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    WCHAR                   ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    CLUS_WORKER             PendingThread;
    CLUSTER_RESOURCE_STATE  State;
    LIST_ENTRY              SubDirList;
    HRESOURCE               hResource;
    CLUS_WORKER             NotifyWorker;
    HANDLE                  NotifyHandle;
    BOOL                    bDfsRootNeedsMonitoring;
    WCHAR                   szDependentNetworkName[MAX_COMPUTERNAME_LENGTH+1];
} SHARE_RESOURCE, *PSHARE_RESOURCE;


typedef struct _SHARE_TYPE_LIST {
    PWSTR    Name;
    ULONG    Type;
} SHARE_TYPE_LIST, *PSHARE_TYPE_LIST;

typedef struct SHARE_ENUM_CONTEXT {
    PSHARE_RESOURCE pResourceEntry;
    PSHARE_PARAMS   pParams;
} SHARE_ENUM_CONTEXT, *PSHARE_ENUM_CONTEXT;

//
// Global data.
//

CRITICAL_SECTION SmbShareLock;

// Log Event Routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE SmbShareFunctionTable;

// SmbShare resource read-write private properties
RESUTIL_PROPERTY_ITEM
SmbShareResourcePrivateProperties[] = {
    { PARAM_NAME__SHARENAME,        NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SHARE_PARAMS,ShareName) },
    { PARAM_NAME__PATH,             NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SHARE_PARAMS,Path) },
    { PARAM_NAME__REMARK,           NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(SHARE_PARAMS,Remark) },
    { PARAM_NAME__MAXUSERS,         NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__MAXUSERS, PARAM_MIN__MAXUSERS, PARAM_MAX__MAXUSERS, 0, FIELD_OFFSET(SHARE_PARAMS,MaxUsers) },
    { PARAM_NAME__SECURITY,         NULL, CLUSPROP_FORMAT_BINARY, 0, 0, 0, 0, FIELD_OFFSET(SHARE_PARAMS,Security) },
    { PARAM_NAME__SHARESUBDIRS,     NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(SHARE_PARAMS,ShareSubDirs) },
    { PARAM_NAME__HIDESUBDIRSHARES, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(SHARE_PARAMS,HideSubDirShares) },
    { PARAM_NAME__DFSROOT,          NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(SHARE_PARAMS, DfsRoot) },
    { PARAM_NAME__SD,               NULL, CLUSPROP_FORMAT_BINARY, 0, 0, 0, 0, FIELD_OFFSET(SHARE_PARAMS,SecurityDescriptor) },
    { PARAM_NAME__CSCCACHE,         NULL, CLUSPROP_FORMAT_DWORD, CSC_CACHE_MANUAL_REINT, CSC_CACHE_MANUAL_REINT, CSC_CACHE_NONE, 0, FIELD_OFFSET(SHARE_PARAMS,CSCCache) },
    { NULL, NULL, 0, 0, 0, 0 }
};

typedef struct _SMB_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} SMB_DEPEND_SETUP, *PSMB_DEPEND_SETUP;

typedef struct _SMB_DEPEND_DATA {
#if 0
    CLUSPROP_RESOURCE_CLASS storageEntry;
#endif
    CLUSPROP_SYNTAX endmark;
} SMB_DEPEND_DATA, *PSMB_DEPEND_DATA;

typedef struct _DFS_DEPEND_DATA {
#if 0
    CLUSPROP_RESOURCE_CLASS storageEntry;
#endif
    CLUSPROP_SZ_DECLARE( networkEntry, sizeof(CLUS_RESTYPE_NAME_NETNAME) / sizeof(WCHAR) );
    CLUSPROP_SYNTAX endmark;
} DFS_DEPEND_DATA, *PDFS_DEPEND_DATA;


// This table is for Smb Share dependencies only
SMB_DEPEND_SETUP SmbDependSetup[] = {
#if 0 // rodga - allow for dependency on a local disk
    { FIELD_OFFSET(SMB_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)CLUS_RESCLASS_STORAGE },
#endif
    { 0, 0 }
};

// This table is for DFS Share dependencies only
SMB_DEPEND_SETUP DfsDependSetup[] = {
#if 0 // rodga - allow for dependency on a local disk
    { FIELD_OFFSET(DFS_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)CLUS_RESCLASS_STORAGE },
#endif
    { FIELD_OFFSET(DFS_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(CLUS_RESTYPE_NAME_NETNAME), CLUS_RESTYPE_NAME_NETNAME },
    { 0, 0 }
};

//
// External references
//
BOOL
SmbExamineSD(
    RESOURCE_HANDLE         ResourceHandle,
    PSECURITY_DESCRIPTOR    psdSD
    );

//
// Forward references
//

BOOL
WINAPI
SmbShareIsAlive(
    IN RESID Resource
    );

DWORD
SmbShareGetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
SmbShareValidatePrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSHARE_PARAMS Params
    );

DWORD
SmbShareSetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


DWORD
SmbpIsDfsRoot(
    IN PSHARE_RESOURCE ResourceEntry,
    OUT PBOOL  pbIsDfsRoot
    );


DWORD 
SmbpPrepareOnlineDfsRoot(
    IN PSHARE_RESOURCE ResourceEntry
    );


DWORD 
SmbpCreateDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD 
SmbpDeleteDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry   
    );

DWORD 
SmbpShareNotifyThread(
        IN PCLUS_WORKER pWorker,
        IN PSHARE_RESOURCE pResourceEntry
        );

DWORD 
SmbpCheckForSubDirDeletion (
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD 
SmbpCheckAndBringSubSharesOnline (
    IN PSHARE_RESOURCE pResourceEntry,
    IN BOOL IsCheckAllSubDirs,
    IN PRESOURCE_STATUS pResourceStatus,
    IN PCLUS_WORKER pWorker,
    OUT LPWSTR *pszRootDirOut
    );

DWORD
SmbpHandleDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry,
    OUT PBOOL pbIsDfsRoot
    );

DWORD
SmbpResetDfs(
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD
SmbpValidateShareName(
    IN  LPCWSTR  lpszShareName
    );

//
//  Private DFS APIs provided bu UDAYH - 4/26/2001
//
DWORD
GetDfsRootMetadataLocation( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation 
    );

VOID
ReleaseDfsRootMetadataLocation( 
    LPWSTR Buffer 
    );


DWORD
SmbpSetCacheFlags(
    IN PSHARE_RESOURCE      ResourceEntry,
    IN LPWSTR               ShareName
    )
/*++

Routine Description:

    Set the caching flags for the given resource entry.

Arguments:

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

    ShareName - the name of the share to set cache flags for.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 


--*/

{
    DWORD           status;
    DWORD           invalidParam;
    PSHARE_INFO_1005 shi1005;

    status = NetShareGetInfo( NULL,
                              ShareName,
                              1005,
                              (LPBYTE *)&shi1005 );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SetCacheFlags, error getting CSC info on share '%1!ws!. Error %2!u!.\n",
            ShareName,
            status );
        goto exit;
    } else {
        shi1005->shi1005_flags &= ~CSC_MASK;
        shi1005->shi1005_flags |= (ResourceEntry->Params.CSCCache & CSC_MASK);
        status = NetShareSetInfo( NULL,
                                  ShareName,
                                  1005,
                                  (LPBYTE)shi1005,
                                  &invalidParam );
        NetApiBufferFree((TCHAR FAR *)shi1005);
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SetCacheFlags, error setting CSC info on share '%1!ws!. Error %2!u!, property # %3!d!.\n",
                ShareName,
                status,
                invalidParam );
        }
    }

exit:

    return(status);

} // SmbpSetCacheFlags()



BOOLEAN
WINAPI
SmbShareDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection( &SmbShareLock );
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection( &SmbShareLock );
        break;

    default:
        break;
    }

    return(TRUE);

} // SmbShareDllEntryPoint



DWORD
SmbpShareNotifyThread(
    IN PCLUS_WORKER pWorker,
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Check whether any new subdirs have been added or deleted from
    under the root share.

Arguments:

    pWorker - Supplies the worker structure.
    
    pResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 

--*/
{
    DWORD  status = ERROR_SUCCESS;
    LPWSTR pszRootDir;

    // 
    // Chittur Subbaraman (chitturs) - 09/25/98
    //
    // This notification thread is activated once a 
    // notification is received. This thread checks for any 
    // new subdir additions or any subdir deletions. If it
    // finds such an occurrence, this thread adds the subdir to
    // or deletes the subdir from the root share. The two
    // Smbp functions this thread calls also checks 
    // whether any termination command has arrived from the
    // offline thread. If such a command has arrived, this thread 
    // terminates immediately, thus releasing the offline thread
    // from the infinite time wait.
    //
    SmbpCheckForSubDirDeletion( pResourceEntry );
    SmbpCheckAndBringSubSharesOnline( pResourceEntry, 
                                      TRUE, 
                                      NULL, 
                                      &pResourceEntry->NotifyWorker,
                                      &pszRootDir );
    LocalFree ( pszRootDir );
      
    return(status);
} // SmbShareNotify

DWORD 
SmbpCheckForSubDirDeletion (
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Check and remove any deleted subdirectory shares.

Arguments:

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 

--*/
{
    PLIST_ENTRY         pHead, plistEntry;
    PSUBDIR_SHARE_INFO  pSubShareInfo;
    HANDLE              hFind;
    DWORD               status = ERROR_SUCCESS;
    DWORD               dwLen;
    WCHAR               szPath [MAX_PATH+1];
    LPWSTR              pszRootDir;
    WIN32_FIND_DATA     FindData;
    DWORD               dwCount = 0;

    //
    //  Chittur Subbaraman (chitturs) - 09/25/98
    //
    //  This function first checks to see whether all the subshares
    //  are indeed currently present. If it finds any subdir 
    //  corresponding to a subshare to be absent, then it removes
    //  that subdir from the share list.
    //
    dwLen = lstrlenW( pResourceEntry->Params.Path );
    pszRootDir = (LPWSTR) LocalAlloc( LMEM_FIXED, (dwLen+10)*sizeof(WCHAR) );
    if ( pszRootDir == NULL )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate pszRootDir. Error: %1!u!.\n",
            status = GetLastError() );
        goto error_exit;
    }
    lstrcpyW( pszRootDir, pResourceEntry->Params.Path );

    //
    // If the path is not already terminated with \\ then add it.
    //
    if ( pszRootDir [dwLen-1] != L'\\' )
        pszRootDir [dwLen++] = L'\\';

    pszRootDir [dwLen] = L'\0' ;

    pHead = plistEntry = &pResourceEntry->SubDirList;

    for ( plistEntry = pHead->Flink;
          plistEntry != pHead;
          dwCount++)
    {
        if ( ClusWorkerCheckTerminate ( &pResourceEntry->NotifyWorker ) )
        {
            status = ERROR_SUCCESS;
            break;
        }
        pSubShareInfo = CONTAINING_RECORD( plistEntry, SUBDIR_SHARE_INFO, ListEntry );
        plistEntry = plistEntry->Flink;                          
        if ( lstrcmpW( pSubShareInfo->ShareName, pResourceEntry->Params.ShareName ))
        {
            //
            // This is not the root share
            //
            wsprintfW( szPath, L"%s%s", pszRootDir, pSubShareInfo->ShareName );
            //
            // Get rid of the hidden share '$' sign for passing onto
            // FindFirstFile, if present. Only do this if the 
            // "HideSubDirShares" option is chosen.
            //
            if ( pResourceEntry->Params.HideSubDirShares )
            {
                dwLen = lstrlenW( szPath );
                if ( szPath [dwLen-1] == L'$' )
                {
                    szPath [dwLen-1] = L'\0';
                }
            }
            
            hFind = FindFirstFile( szPath, &FindData );                          
            if ( hFind == INVALID_HANDLE_VALUE ) 
            {    
                status = GetLastError();
                 
                (g_LogEvent)(
                    pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpCheckForSubDirDeletion: Dir '%1' not found ...\n",
                    szPath
                );
                            
                if ( status == ERROR_FILE_NOT_FOUND )
                { 
                    //
                    // Delete the file share
                    //                           
                    status = NetShareDel( NULL, pSubShareInfo->ShareName, 0 );
                    if ( (status != NERR_NetNameNotFound) && 
                         (status != NO_ERROR) )
                    {
                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpCheckForSubDirDeletion: Error removing share '%1'. Error code = %2!u!...\n",
                            pSubShareInfo->ShareName,
                            status );                        
                    } else
                    {
                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpCheckForSubDirDeletion: Removing share '%1'...\n",
                            pSubShareInfo->ShareName );
                        RemoveEntryList( &pSubShareInfo->ListEntry );
                        LocalFree ( pSubShareInfo );                         
                    }
                }  
                else 
                {   
                    (g_LogEvent)(
                        pResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"SmbpCheckForSubDirDeletion: Error in FindFirstFile for share '%1'. Error code = %2!u!....\n",
                        pSubShareInfo->ShareName,
                        status );
                }               
            }
            else
            {
                if ( !FindClose ( hFind ) )
                {
                    (g_LogEvent)(
                        pResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"CheckForSubDirDeletion: FindClose Failed. Error: %1!u!.\n",
                        status = GetLastError () );
                }
            }
        } 
   } // end of for loop 

error_exit:
    LocalFree( pszRootDir );   
    
    return(status);
} // SmbpCheckForSubDirDeletion

DWORD 
SmbpCheckAndBringSubSharesOnline (
    IN PSHARE_RESOURCE pResourceEntry,
    IN BOOL IsCheckAllSubDirs, 
    IN PRESOURCE_STATUS pResourceStatus,
    IN PCLUS_WORKER pWorker,
    OUT LPWSTR *pszRootDirOut
    )
/*++

Routine Description:

    Check and bring online any newly added subdirectory shares.

Arguments:

    pResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.
    
    IsCheckAllSubDirs - Check whether a subdir is a share or not
    
    pResourceStatus - A pointer to the RESOURCE_STATUS

    pWorker - A pointer to the worker thread
    
    pszRootDirOut - A pointer to the root share store

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 

--*/
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR szPath [MAX_PATH+1];
    DWORD dwLen, dwShareLen;
    DWORD dwCount = 0;
    SHARE_INFO_502  shareInfo;
    PSHARE_INFO_502 pshareInfo = NULL;
    WCHAR szShareName [NNLEN+2];
    DWORD status = ERROR_SUCCESS;
    PSUBDIR_SHARE_INFO  pSubShareInfo;
    PLIST_ENTRY         plistEntry;
    RESOURCE_EXIT_STATE exitState;
    LPWSTR  pszRootDir;

    //
    //  Chittur Subbaraman (chitturs) - 09/25/98
    //
    //  This function will be called either from SmbpShareOnlineThread
    //  with the input parameter IsCheckAllSubDirs set to FALSE
    //  or from SmbpShareNotifyThread with the parameter set to TRUE.
    //  In the former case, this function will blindly make all the
    //  subdirs under the root share as shares. In the latter case,
    //  this function will first check whether a particular subdir
    //  is a share and if not it will make it as a share. 
    //
   
    dwLen = lstrlenW( pResourceEntry->Params.Path );
    plistEntry = &pResourceEntry->SubDirList;

    // 
    // Allocate memory to store the root share here and
    // free it at the caller
    //
    pszRootDir = (LPWSTR) LocalAlloc( LMEM_FIXED, (dwLen+10)*sizeof(WCHAR) );
    if ( pszRootDir == NULL )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate pszRootDir. Error: %1!u!.\n",
            status = GetLastError() );
        goto error_exit;
    }

    lstrcpyW( pszRootDir, pResourceEntry->Params.Path );

    //
    // If the path is not already terminated with \\ then add it.
    //
    if ( pszRootDir [dwLen-1] != L'\\' )
        pszRootDir [dwLen++] = L'\\';

    //
    // Add '*' to search all the files.
    //
    pszRootDir [dwLen++] = L'*' ;
    pszRootDir [dwLen] = L'\0' ;

    ZeroMemory( &shareInfo, sizeof( shareInfo ) );
    shareInfo.shi502_path =         szPath;
    shareInfo.shi502_netname =      szShareName;
    shareInfo.shi502_type =         STYPE_DISKTREE;
    shareInfo.shi502_remark =       pResourceEntry->Params.Remark;
    shareInfo.shi502_max_uses =     pResourceEntry->Params.MaxUsers;
    shareInfo.shi502_passwd =       NULL;
    shareInfo.shi502_security_descriptor = pResourceEntry->Params.SecurityDescriptor;

    // 
    // Find the first file in the root dir
    //
    if ( ( hFind = FindFirstFile( pszRootDir, &FindData ) ) == INVALID_HANDLE_VALUE ) {
        status = GetLastError () ;

        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        } else {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"CheckForSubDirAddition: FindFirstFile Failed For Root Share... Error: %1!u!.\n",
                    status );
        }
        goto error_exit;
    }

    //
    // Remove the '*' so the same variable can be used later.
    //
    pszRootDir [dwLen-1] = L'\0' ;


    while ( status == ERROR_SUCCESS ) { 
        if ( ClusWorkerCheckTerminate ( pWorker ) == TRUE ) {
            status = ERROR_SUCCESS;
            goto error_exit;
        }
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) { 
            //
            //  Check only subdirectories, not files
            //
            dwShareLen = lstrlenW( FindData.cFileName );

            if ( dwShareLen <= NNLEN && (dwLen + dwShareLen < MAX_PATH) )   // A safety check for overflow
            {
                lstrcpyW( szShareName, FindData.cFileName );

                if ( szShareName[0] == L'.' )
                {
                    if ( szShareName [1] == L'\0' ||
                            szShareName[1] == L'.' && szShareName [2] == L'\0' ) {
                        goto skip;
                    }
                }
            

                if ( pResourceEntry->Params.HideSubDirShares )
                    lstrcatW(szShareName, L"$") ;

                wsprintfW( szPath, L"%s%s", pszRootDir, FindData.cFileName );

                if ( IsCheckAllSubDirs == TRUE )
                {  
                    // 
                    // If this call is made from the notify thread,
                    // try to see whether a particular subdir is a
                    // share
                    //
                    status = NetShareGetInfo( NULL,
                                szShareName,
                                502, // return a SHARE_INFO_502 structure
                                (LPBYTE *) &pshareInfo );
                } else
                {
                    //
                    // If this call is made from the online thread,
                    // assume that the subdir is not a share (since
                    // it would have been removed as a share the 
                    // most recent time when it was made offline).
                    //
                    status = NERR_NetNameNotFound;
                }                                                      
                            
                if ( status == NERR_NetNameNotFound )
                {                  
                    status = NetShareAdd( NULL, 502, (PBYTE)&shareInfo, NULL );
             
                    if ( status == ERROR_SUCCESS )
                    {
                        pSubShareInfo = (PSUBDIR_SHARE_INFO) LocalAlloc( LMEM_FIXED, sizeof(SUBDIR_SHARE_INFO) );
                        if ( pSubShareInfo == NULL )
                        {
                            (g_LogEvent)(
                                pResourceEntry->ResourceHandle,
                                LOG_ERROR,
                                L"SmbpCheckAndBringSubSharesOnline: Unable to allocate pSubShareInfo. Error: %1!u!.\n",
                                status = GetLastError() );
                            goto error_exit;
                        }

                        lstrcpyW( pSubShareInfo->ShareName, szShareName );
                        InsertTailList( plistEntry, &pSubShareInfo->ListEntry );

                        //
                        // Set the caching flags for this entry.
                        //
                        status = SmbpSetCacheFlags( pResourceEntry,
                                                    szShareName );
                        if ( status != ERROR_SUCCESS ) {
                            goto error_exit;
                        }

                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpCheckAndBringSubSharesOnline: Adding share '%1'...\n",
                            pSubShareInfo->ShareName);
            
                        if ( IsCheckAllSubDirs == FALSE )
                        {
                            if ( (dwCount++ % 100) == 0)
                            {
                                pResourceStatus->CheckPoint++;
                                exitState = (g_SetResourceStatus)( pResourceEntry->ResourceHandle,
                                            pResourceStatus );
                                if ( exitState == ResourceExitStateTerminate ) 
                                {
                                    status = ERROR_OPERATION_ABORTED;
                                    goto error_exit;
                                }
                            } 
                        }
                    }
                    else
                    {
                        //
                        // ignore this error but log that something went wrong
                        //
                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpCheckAndBringSubSharesOnline: NetShareAdd failed for %1!ws! Error: %2!u!.\n",
                            szShareName,
                            status );
                        status = ERROR_SUCCESS;
                    }
                } else
                {
                    if ( pshareInfo != NULL )
                    {
                        NetApiBufferFree( pshareInfo );
                    }
                }
            }
            else
            {
                (g_LogEvent)(
                    pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpCheckAndBringSubSharesOnline: NetShareAdd Share not added for subdir due to illegal share name length '%1!ws!'.\n",
                    FindData.cFileName );
            }
        }
              
    skip:
        if ( !FindNextFile( hFind, &FindData ) )
        {
            status = GetLastError ();
        }       
    } // end of while loop

    if ( status == ERROR_NO_MORE_FILES )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"CheckForSubDirAddition: FindNextFile Failed. Error: %1!u!.\n",
            status );
    }
  
error_exit:
    if ( hFind != INVALID_HANDLE_VALUE  )
    {
        if( !FindClose (hFind) )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpCheckAndBringSubSharesOnline: FindClose Failed. Error: %1!u!.\n",
                    status = GetLastError () );
        }
    }

    *pszRootDirOut = pszRootDir;
        
    return(status);   
} // SmbpCheckAndBringSubSharesOnline


DWORD
SmbShareOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PSHARE_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource online.

Arguments:

    pWorker - Supplies the worker structure

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SHARE_INFO_502  shareInfo;
    DWORD           retry = MAX_RETRIES;
    DWORD           status;
    RESOURCE_STATUS resourceStatus;
    LPWSTR          nameOfPropInError;
    BOOL            bIsExistingDfsRoot = FALSE;
    BOOL            bDfsRootCreationFailed = FALSE;
    DWORD           dwLen;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    // resourceStatus.CheckPoint = 1;

    //
    // Read parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   SmbShareResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto exit;
    }

    if ( (ResourceEntry->Params.SecurityDescriptorSize != 0) &&
         !IsValidSecurityDescriptor(ResourceEntry->Params.SecurityDescriptor) ) {
        status = GetLastError();
        goto exit;
    }

    while ( retry-- )
    {        
        //
        // Make sure the path does _NOT_ have a trailing backslash or it will fail to
        // come online. But accept paths of the form E:\.
        //
        dwLen = ( DWORD ) wcslen( ResourceEntry->Params.Path );
        if ( ( ResourceEntry->Params.Path[ dwLen - 1 ] == L'\\' ) &&
             ( dwLen > 3 ) ) 
        {
            ResourceEntry->Params.Path[ dwLen - 1 ] = L'\0'; // wack it.
        }

        ZeroMemory( &shareInfo, sizeof( shareInfo ) );
        shareInfo.shi502_netname =      ResourceEntry->Params.ShareName;
        shareInfo.shi502_type =         STYPE_DISKTREE;
        shareInfo.shi502_remark =       ResourceEntry->Params.Remark;
        shareInfo.shi502_max_uses =     ResourceEntry->Params.MaxUsers;
        shareInfo.shi502_path =         ResourceEntry->Params.Path;
        shareInfo.shi502_passwd =       NULL;
        shareInfo.shi502_security_descriptor = ResourceEntry->Params.SecurityDescriptor;

        status = NetShareAdd( NULL, 502, (PBYTE)&shareInfo, NULL );

        if ( status == ERROR_SUCCESS ) {
            status = SmbpSetCacheFlags( ResourceEntry,
                                        ResourceEntry->Params.ShareName );
            if ( status != ERROR_SUCCESS ) {
                goto exit;
            }
            break;
        }

        // If we get a failure about the server not being started, then
        // try to start the server and wait a little while.

        if ( status != ERROR_SUCCESS ) {
            WCHAR errorValue[20];

            wsprintfW( errorValue, L"%u", status );
            ClusResLogSystemEventByKey1(ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_SMB_SHARE_CANT_ADD,
                                        errorValue);
            if ( status == NERR_ServerNotStarted ) {
                ResUtilStartResourceService( SMB_SVCNAME,
                                             NULL );
                Sleep( 500 );
            } else if ( status == NERR_DuplicateShare ) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Share %1!ws! is online already, try and delete and create it again\n",
                    ResourceEntry->Params.ShareName);

                //
                // Delete the share and try again.
                //
                status = NetShareDel( NULL, ResourceEntry->Params.ShareName, 0 );
                if ( status == NERR_IsDfsShare )
                {
                    //
                    // Chittur Subbaraman (chitturs) - 2/12/99
                    // 
                    // Reset the state info in the dfs driver dfs.sys 
                    // and stop it. This will let srv.sys let you delete 
                    // the share.
                    //
                    status = SmbpResetDfs( ResourceEntry ); 
                    //
                    // If we can't do this exit, else retry deleting and
                    // adding the share once again
                    //
                    if (status != ERROR_SUCCESS) {
                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpResetDfs for Share %1!ws! failed with error %2!u!\n",
                            ResourceEntry->Params.ShareName,
                            status);
                        goto exit;
                    } 
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Informing DFS that share %1!ws! is not a dfs root \n",
                        ResourceEntry->Params.ShareName);
                } else
                {
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Share %1!ws! deleted successfully ! \n",
                        ResourceEntry->Params.ShareName);
                }
            } else {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Error creating share. Error: %1!u!.\n",
                    status );
                goto exit;
            }
        }
    }  // End for while ( retry-- )

    if ( status == ERROR_SUCCESS )
    {
        // The share is now online, bring the subshares online

        PLIST_ENTRY plistEntry;
        PSUBDIR_SHARE_INFO pSubShareInfo;
        LPWSTR pszRootDir;
        
        plistEntry = &ResourceEntry->SubDirList;

        //
        // Store the Root share. This info is used to delete the share.
        //
        pSubShareInfo = (PSUBDIR_SHARE_INFO) LocalAlloc( LMEM_FIXED, sizeof (SUBDIR_SHARE_INFO) );
        if ( pSubShareInfo == NULL ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate pSubShareInfo. Error: %1!u!.\n",
                status = GetLastError() );
            goto exit;
        }
        lstrcpyW( pSubShareInfo->ShareName, ResourceEntry->Params.ShareName );
        InsertTailList( plistEntry, &pSubShareInfo->ListEntry );

        if ( ResourceEntry->Params.ShareSubDirs ) {
            // Chittur Subbaraman (chitturs) - 09/25/98
            //
            // Try to bring the subshares online.
            // If there is a failure in bringing subshares online,
            // pretend all is well since at least the root
            // share has been successfully created. However, we
            // write an entry into the log.
            //
            SmbpCheckAndBringSubSharesOnline ( ResourceEntry, 
                                               FALSE,  
                                               &resourceStatus,
                                               &ResourceEntry->PendingThread,
                                               &pszRootDir
                                             );
            if ( ClusWorkerCheckTerminate( &ResourceEntry->PendingThread ) ) {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpShareOnlineThread: Terminating... !!!\n"
                );
                status = ERROR_SUCCESS;
                goto exit;
            }

            // Chittur Subbaraman (chitturs) - 09/25/98
            //
            // Create a change notification handle for any subdirectory
            // additions/deletions and a notify thread which continuously 
            // checks and acts upon any such notifications. Do this
            // only once at the beginning. The notification thread
            // closes the handle at termination time.
            //
            ResourceEntry->NotifyHandle = FindFirstChangeNotification(
                                                pszRootDir,
                                                FALSE,
                                                FILE_NOTIFY_CHANGE_DIR_NAME
                                           );
            
            LocalFree ( pszRootDir );
                        
            if ( ResourceEntry->NotifyHandle == INVALID_HANDLE_VALUE )
            {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpShareOnlineThread: FindFirstChange Notification Failed. Error: %1!u!.\n",
                    GetLastError ());
                status = ERROR_SUCCESS;
                goto exit;
            }                   
            goto exit;
        }
    } // End for root share successfully created.

    //
    // Chittur Subbaraman (chitturs) - 2/10/99
    //
    // If the user requests for this resource to be a DFS root, the
    // dfs root will be created/accepted and the dfs registry
    // checkpoints will be added. On the other hand, if the user
    // wants this resource not to function as a dfs root any more,
    // that case is also taken care of.
    //
    status = SmbpHandleDfsRoot( ResourceEntry, &bIsExistingDfsRoot );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpHandleDfsRoot for Share %1!ws! failed with error %2!u!\n",
            ResourceEntry->Params.ShareName,
            status);
        bDfsRootCreationFailed = TRUE;
        goto exit;
    }

    if ( bIsExistingDfsRoot ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Share %1!ws! is a dfs root, online dfs\n",
            ResourceEntry->Params.ShareName);
        status = SmbpPrepareOnlineDfsRoot( ResourceEntry );
        if ( status != ERROR_SUCCESS ) {
            bDfsRootCreationFailed = TRUE;
        }
    }

exit:
    if ( status != ERROR_SUCCESS ) {
        if ( bDfsRootCreationFailed ) {
            WCHAR   szErrorString[12];
            
            wsprintfW(&(szErrorString[0]), L"%u", status);
            ClusResLogSystemEventByKeyData1( ResourceEntry->ResourceKey,
                                             LOG_CRITICAL,
                                             RES_SMB_CANT_ONLINE_DFS_ROOT,
                                             sizeof( status ),
                                             &status,
                                             szErrorString );           
        } else {
            ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                            LOG_CRITICAL,
                                            RES_SMB_CANT_CREATE_SHARE,
                                            sizeof( status ),
                                            &status );
        }
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error %1!u! bringing share %2!ws!, path %3!ws! online.\n",
            status,
            ResourceEntry->Params.ShareName,
            ResourceEntry->Params.Path );
        resourceStatus.ResourceState = ClusterResourceFailed;
    } else {
        resourceStatus.ResourceState = ClusterResourceOnline;
    }

    ResourceEntry->State = resourceStatus.ResourceState;

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

} // SmbShareOnlineThread



RESID
WINAPI
SmbShareOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for SMB share resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - Supplies handle to resource's cluster registry key.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    DWORD           status;
    RESID           resid = 0;
    HKEY            parametersKey = NULL;
    HKEY            resKey = NULL;
    PSHARE_RESOURCE resourceEntry = NULL;
    DWORD           computerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    HCLUSTER        hCluster;

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        SetLastError( status );
        return(0);
    }
    //
    // Open the Parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                PARAM_KEYNAME__PARAMETERS,
                                KEY_ALL_ACCESS,
                                &parametersKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Allocate a resource entry.
    //

    resourceEntry = (PSHARE_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(SHARE_RESOURCE) );

    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry..
    //

    ZeroMemory( resourceEntry, sizeof(SHARE_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;
    resourceEntry->NotifyHandle = INVALID_HANDLE_VALUE;

    InitializeListHead( &resourceEntry->SubDirList );

    hCluster = OpenCluster( NULL );
    if ( !hCluster ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open cluster. Error: %1!u!.\n",
            status );
        goto exit;
    }

    resourceEntry->hResource = OpenClusterResource( hCluster,
                                                    ResourceName );
    CloseCluster( hCluster );
    if ( !resourceEntry->hResource ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open cluster resource. Error: %1!u!.\n",
            status );
        goto exit;
    }

    if ( !GetComputerNameW( &resourceEntry->ComputerName[0],
                            &computerNameSize ) ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }
    resid = (RESID)resourceEntry;

exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resKey != NULL ) {
            ClusterRegCloseKey( resKey );
        }
        if ( resourceEntry &&
             resourceEntry->hResource ) {
            CloseClusterResource( resourceEntry->hResource );
        }
        LocalFree( resourceEntry );
    }

    SetLastError( status );
    return(resid);

} // SmbShareOpen


DWORD
WINAPI
SmbShareOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for File Share resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD           status;
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Online request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOffline;
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               SmbShareOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // SmbShareOnline


DWORD
SmbShareDoTerminate (
    IN PSHARE_RESOURCE ResourceEntry,
    IN PRESOURCE_STATUS presourceStatus
    )

/*++

Routine Description:

    Do the actual Terminate work for File Share resources.

Arguments:

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.
    presourceStatus - A pointer to the RESOURCE_STATUS. This will be NULL if called from TERMINATE.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. If more than one share delete fails then
    the last error is returned.

--*/

{
    DWORD               status = ERROR_SUCCESS, dwRet;
    PLIST_ENTRY         pHead, plistEntry;
    PSUBDIR_SHARE_INFO  pSubShareInfo;

#define SMB_DELETED_SHARES_REPORT_FREQ  100

    DWORD               dwSharesDeleted = SMB_DELETED_SHARES_REPORT_FREQ;
    DWORD               dwRetryCount;
    BOOL                bRetry;
    RESOURCE_EXIT_STATE exit;

    //
    // Chittur Subbaraman (chitturs) - 09/25/98
    //
    // Terminate the notification thread first, so you can
    // clean up even if the notification thread is forced to 
    // stop in the middle of its task. Also close the notification
    // handle.
    //
    ClusWorkerTerminate( &ResourceEntry->NotifyWorker );

    if ( ResourceEntry->NotifyHandle )
    {
        FindCloseChangeNotification ( ResourceEntry->NotifyHandle );
        ResourceEntry->NotifyHandle = INVALID_HANDLE_VALUE;
    }
    
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_ERROR,
        L"SmbShareDoTerminate: SmbpShareNotifyWorker Terminated... !!!\n"
    );

    pHead = plistEntry = &ResourceEntry->SubDirList;

    for ( plistEntry = pHead->Flink;
          plistEntry != pHead;
          dwSharesDeleted--
        )
    {
        pSubShareInfo = CONTAINING_RECORD( plistEntry, SUBDIR_SHARE_INFO, ListEntry );
        dwRetryCount = 1;
        bRetry = FALSE;
        do
        {
            dwRet = NetShareDel( NULL, pSubShareInfo->ShareName, 0 );
            status = dwRet;
            if ( dwRet != NO_ERROR )
            {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Error removing share '%1'. Error %2!u!.\n",
                    pSubShareInfo->ShareName,
                    dwRet );
                if (dwRet == NERR_IsDfsShare && !bRetry)
                {
                    //
                    // Chittur Subbaraman (chitturs) - 2/12/99
                    //
                    // If this is a dfs root, reset the dfs driver and
                    // stop it. This will let you delete the share.
                    //
                    dwRet = SmbpResetDfs( ResourceEntry );
                    //
                    // If this fails, log an error
                    // else try and offline the resource again.
                    //
                    if (dwRet == ERROR_SUCCESS) 
                    {
                        bRetry = TRUE;
                    }
                    else
                    {
                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Error in offlining the dfs root at this share '%1'. Error %2!u!.\n",
                            pSubShareInfo->ShareName,
                            dwRet );
                        status = dwRet;
                    }
                } 
            } 
        } while (dwRetryCount-- && bRetry);

        //
        // if we're updating our status to resmon, do so every
        // SMB_DELETED_SHARES_REPORT_FREQ shares
        //
        if ( presourceStatus && ( dwSharesDeleted == 0 )) {
            presourceStatus->CheckPoint++;
            exit = (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                                          presourceStatus );
            if ( exit == ResourceExitStateTerminate ) {
                status = ERROR_OPERATION_ABORTED;
            }

            dwSharesDeleted = SMB_DELETED_SHARES_REPORT_FREQ;
        }

        plistEntry = plistEntry->Flink;

        LocalFree (pSubShareInfo);
    }

    // This should initialize the list back to NULL
    InitializeListHead(pHead);

    ResourceEntry->bDfsRootNeedsMonitoring = FALSE;

    return(status);
} // SmbShareDoTerminate


DWORD
SmbShareOfflineThread (
    IN PCLUS_WORKER pWorker,
    IN PSHARE_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource offline.
    Do the actual Terminate work for File Share resources.

Arguments:

    pWorker - Supplies the worker structure

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    RESOURCE_STATUS resourceStatus;
    DWORD           status;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceOfflinePending;

    resourceStatus.ResourceState = (status = SmbShareDoTerminate (ResourceEntry, &resourceStatus)) == ERROR_SUCCESS?
                                                ClusterResourceOffline:
                                                ClusterResourceFailed;


    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    ResourceEntry->State = resourceStatus.ResourceState;
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Smbshare is now offline.\n" );

    return(status);

} // SmbShareOfflineThread



VOID
WINAPI
SmbShareTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for File Share resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Terminate request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    ClusWorkerTerminate( &resourceEntry->PendingThread );

    //
    // Terminate the resource.
    //
    SmbShareDoTerminate( resourceEntry, NULL);

} // SmbShareTerminate



DWORD
WINAPI
SmbShareOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for File Share resource.

Arguments:

    ResourceId - Supplies the resource it to be taken offline

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

--*/

{
    DWORD status;
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Offline request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif

    //
    // Terminate the resource.
    //
    // ClusWorkerTerminate( &resourceEntry->OfflineThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               SmbShareOfflineThread,
                               resourceEntry );

    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return status;

} // SmbShareOffline



BOOL
SmbShareCheckIsAlive(
    IN PSHARE_RESOURCE ResourceEntry,
    IN BOOL     IsAliveCheck
    )

/*++

Routine Description:

    Check to see if the resource is alive for File Share resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    DWORD           status;
    BOOL            success = TRUE;
    PSHARE_INFO_502 shareInfo;
    WCHAR           szErrorString[12];

    EnterCriticalSection( &SmbShareLock );

    //
    // Determine if the resource is online.
    //
    status = NetShareGetInfo( NULL,
                              ResourceEntry->Params.ShareName,
                              502, // return a SHARE_INFO_502 structure
                              (LPBYTE *) &shareInfo );

    if ( status == NERR_NetNameNotFound ) {
        ClusResLogSystemEventByKey(ResourceEntry->ResourceKey,
                                   LOG_CRITICAL,
                                   RES_SMB_SHARE_NOT_FOUND);
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"NERR_NetNameNotFound :share '%1!ws!' no longer exists.\n",
            ResourceEntry->Params.ShareName );
        success = FALSE;
    } else if ( status != ERROR_SUCCESS ) {
        wsprintfW(&(szErrorString[0]), L"%u", status);
        ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_SMB_SHARE_FAILED,
                                        sizeof(status),
                                        &status,
                                        szErrorString);
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error checking for share. Error %1!u!.\n",
            status );
        success = FALSE;
    }

    LeaveCriticalSection( &SmbShareLock );

    if ( success ) {
        NetApiBufferFree( shareInfo );
        if ( IsAliveCheck ) {
            HANDLE      fileHandle;
            WIN32_FIND_DATA fileData;
            WCHAR       shareName[MAX_PATH];
            DWORD       dwLoopCnt = 0;

            swprintf( shareName,
                      L"\\\\%ws\\%ws\\*.*\0",
                      ResourceEntry->ComputerName,
                      ResourceEntry->Params.ShareName);

            fileHandle = FindFirstFileW( shareName,
                                         &fileData );

            //
            // If we fail on the first attempt, try again. There seems to be a
            // bug in the RDR where the first attempt to read a share after it
            // has been deleted and reinstated.  The bug is that the RDR
            // returns failure on the first operation following the
            // reinstatement of the share.
            //

            if ( fileHandle == INVALID_HANDLE_VALUE ) {
                fileHandle = FindFirstFileW( shareName,
                                             &fileData );
            }

            //
            // If we succeeded in finding a file, or there were no files in the
            // path, then return success, otherwise we had a failure.
            //
            status = GetLastError();

            //
            // Chittur Subbaraman (chitturs) - 12/6/1999
            //
            // If FindFirstFile returns ERROR_NETNAME_DELETED, it 
            // could possibly because the netname resource deletes
            // all loopback sessions during the offline process. So,
            // sleep and retry the call.
            //
            while( ( fileHandle == INVALID_HANDLE_VALUE ) &&
                   ( status == ERROR_NETNAME_DELETED ) && 
                   ( dwLoopCnt++ < 3 ) ) {
                Sleep( 50 );
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Retrying FindFirstFile on error %1!u! for share %2!ws! !\n",
                    status,
                    shareName);
                fileHandle = FindFirstFileW( shareName,
                                             &fileData );
                status = GetLastError();
            } 

            if ( (fileHandle == INVALID_HANDLE_VALUE) &&
                 (status != ERROR_FILE_NOT_FOUND) &&
                 (status != ERROR_ACCESS_DENIED) ) {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Share has gone offline, Error=%1!u! !\n",
                    status);
                SetLastError(status);          
                wsprintfW(&(szErrorString[0]), L"%u", status);
                ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                                LOG_CRITICAL,
                                                RES_SMB_SHARE_FAILED,
                                                sizeof(status),
                                                &status,
                                                szErrorString);
                return(FALSE);
            }

            FindClose( fileHandle );

        }
    } else {
        SetLastError(status);
    }

    // 
    //  Chittur Subbaraman (chitturs) - 2/18/99
    //
    //  If this share is a dfs root, check whether the root is still alive
    //
    if ( success && ResourceEntry->bDfsRootNeedsMonitoring )
    {
        PDFS_INFO_1     pDfsInfo1 = NULL;
        WCHAR           szDfsEntryPath[MAX_PATH+1];
        
        //
        //  Prepare a path of the form \\VSName\ShareName to pass into DFS API.
        //
        lstrcpy( szDfsEntryPath, L"\\\\" );
        lstrcat( szDfsEntryPath, ResourceEntry->szDependentNetworkName );
        lstrcat( szDfsEntryPath, L"\\" );
        lstrcat( szDfsEntryPath, ResourceEntry->Params.ShareName );

        //
        //  Try to see whether the dfs root is alive.
        //
        status = NetDfsGetInfo( szDfsEntryPath,             // Root share
                                NULL,                       // Remote server
                                NULL,                       // Remote share
                                1,                          // Info Level
                                ( LPBYTE * ) &pDfsInfo1 );  // Out buffer

        if ( status == NERR_Success )
        {
            if ( pDfsInfo1 != NULL )
            {
                NetApiBufferFree( pDfsInfo1 );
            }
        } else 
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Status of looks alive check for dfs root is %1!u! !\n",
                status);

            wsprintfW(&(szErrorString[0]), L"%u", status);
            ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                      LOG_CRITICAL,
                                      RES_SMB_SHARE_FAILED,
                                      sizeof(status),
                                      &status,
                                      szErrorString);
            SetLastError( status );
            return( FALSE );
        }

        if ( IsAliveCheck )
        {
            //
            //  Make a thorough check to see whether the root share
            //  name matches the resource's share name.
            //
            status = SmbpIsDfsRoot( ResourceEntry, &success );
        
            if ( ( status != ERROR_SUCCESS ) ||
                 ( success == FALSE ) )
            {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Dfs root has been deleted/inaccessible, Error=%1!u! Root existence=%2!u! !\n",
                    status,
                    success);
                if( status != ERROR_SUCCESS ) 
                {   
                    SetLastError( status );
                    wsprintfW(&(szErrorString[0]), L"%u", status);
                    ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                                    LOG_CRITICAL,
                                                    RES_SMB_SHARE_FAILED,
                                                    sizeof(status),
                                                    &status,
                                                    szErrorString);
                }
                return( FALSE );
            }
        }
    }

    return(success);

} // SmbShareCheckIsAlive



BOOL
SmbShareIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for File Share resource. Also creates a 
    notification thread if any outstanding notifications are
    present.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    PSHARE_RESOURCE resourceEntry;
    DWORD           status;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: IsAlive request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif
    if ( ( ( resourceEntry->NotifyWorker ).hThread == NULL )
        && ( resourceEntry->NotifyHandle != INVALID_HANDLE_VALUE ) )
    {
        //
        // Chittur Subbaraman (chitturs) - 09/27/98
        //
        // No notify thread is active at this time (we don't want to
        // deal with concurrency issues with multiple notify threads
        // running concurrently since we decided to anyway use the 
        // rather slow approach of checking for and acting upon 
        // notifications within this function which may not be called 
        // frequently)
        //
        status = WaitForSingleObject( resourceEntry->NotifyHandle, 0 );
        if ( status == WAIT_OBJECT_0 )
        {
            FindNextChangeNotification( resourceEntry->NotifyHandle );

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbShareIsAlive: Notification Received !!!\n"
            );
        
            status = ClusWorkerCreate(
                    &resourceEntry->NotifyWorker, 
                    SmbpShareNotifyThread,
                    resourceEntry                        
                    );
              
            if (status != ERROR_SUCCESS)
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareIsAlive: Unable to start thread for monitoring subdir creations/deletions ! ResourceId = %1!u!.\n",
                    resourceEntry->ResId);
            } 
        }
    }

    //
    // Determine if the resource is online.
    //
    return(SmbShareCheckIsAlive( resourceEntry, TRUE ));

} // SmbShareIsAlive



BOOL
WINAPI
SmbShareLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for File Share resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: LooksAlive request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    //
    // Determine if the resource is online.
    //
    return(SmbShareCheckIsAlive( resourceEntry, FALSE ));

} // SmbShareLooksAlive



VOID
WINAPI
SmbShareClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for File Share resource.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif

    //
    //  Chittur Subbaraman (chitturs) - 3/1/99
    //
    //  Attempt to delete the dfs root if necessary
    //
    if ( resourceEntry->Params.DfsRoot ) {
        NetDfsRemoveStdRoot( resourceEntry->ComputerName, 
                             resourceEntry->Params.ShareName,
                             0 );    
    }

    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    if ( resourceEntry->ResourceKey ) {
        ClusterRegCloseKey( resourceEntry->ResourceKey );
    }

    if ( resourceEntry->hResource ) {
        CloseClusterResource( resourceEntry->hResource );
    }

    //
    // Deallocate the resource entry.
    //

    LocalFree( resourceEntry->Params.ShareName );
    LocalFree( resourceEntry->Params.Path );
    LocalFree( resourceEntry->Params.Remark );
    LocalFree( resourceEntry->Params.Security );
    LocalFree( resourceEntry->Params.SecurityDescriptor );

    LocalFree( resourceEntry );

} // SmbShareClose



DWORD
SmbShareGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for resources of type File Share.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    PSMB_DEPEND_SETUP pdepsetup = SmbDependSetup;
    PSMB_DEPEND_DATA pdepdata = (PSMB_DEPEND_DATA)OutBuffer;
    CLUSPROP_BUFFER_HELPER value;
    DWORD       status;

    *BytesReturned = sizeof(SMB_DEPEND_DATA);
    if ( OutBufferSize < sizeof(SMB_DEPEND_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( OutBuffer, sizeof(SMB_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 ) {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat ) {

            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                value.pULargeIntegerValue->li.LowPart = 
                    (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return(status);

} // SmbShareGetRequiredDependencies



DWORD
DfsShareGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for DFS File Share resource.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    PSMB_DEPEND_SETUP pdepsetup = DfsDependSetup;
    PDFS_DEPEND_DATA pdepdata = (PDFS_DEPEND_DATA)OutBuffer;
    CLUSPROP_BUFFER_HELPER value;
    DWORD       status;

    *BytesReturned = sizeof(DFS_DEPEND_DATA);
    if ( OutBufferSize < sizeof(DFS_DEPEND_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( OutBuffer, sizeof(DFS_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 ) {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat ) {

            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                value.pULargeIntegerValue->li.LowPart = 
                    (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return(status);

} // DfsShareGetRequiredDependencies



DWORD
SmbShareResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for File Share resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PSHARE_RESOURCE     resourceEntry;
    DWORD               required;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"ResourceControl request.\n" );
#endif

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SmbShareResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SmbShareResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = SmbShareGetPrivateResProperties( resourceEntry,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = SmbShareValidatePrivateResProperties( resourceEntry,
                                                           InBuffer,
                                                           InBufferSize,
                                                           NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = SmbShareSetPrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            if ( resourceEntry->Params.DfsRoot ) {
                status = DfsShareGetRequiredDependencies( OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned );
            } else {
                status = SmbShareGetRequiredDependencies( OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned );
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // SmbShareResourceControl



DWORD
SmbShareResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for File Share resources.

    Perform the control request specified by ControlCode on the specified
    resource type.

Arguments:

    ResourceTypeName - Supplies the name of the resource type - not useful!

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SmbShareResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            // rodga 2/15/99
            // CLUSBUG - how do we present DFS Root dependencies???
            status = SmbShareGetRequiredDependencies( OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SmbShareResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // SmbShareResourceTypeControl




DWORD
SmbShareGetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type SmbShare.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      SmbShareResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // SmbShareGetPrivateResProperties


DWORD
SMBValidateUniqueProperties(
    IN HRESOURCE            hSelf,
    IN HRESOURCE            hResource,
    IN PSHARE_ENUM_CONTEXT  pContext
    )

/*++

Routine Description:
    Callback function to validate that a resource's properties are unique.

    For the File Share resource the ShareName property must be unique
    in the cluster.

Arguments:

    hSelf     - A handle to the original resource (or NULL).

    hResource - A handle to a resource of the same Type. Check against this to make sure
                the new properties do not conflict.

    pContext  - Context for the enumeration.

Return Value:

    ERROR_SUCCESS - The function completed successfully, the name is unique

    ERROR_DUP_NAME - The name is not unique (i.e., already claimed by another resource)

    Win32 error code - The function failed.

--*/
{
    DWORD       dwStatus;
    LPWSTR      lpszShareName   = NULL;
    HKEY        hKey            = NULL;
    HKEY        hParamKey       = NULL;

    if ( !pContext->pParams->ShareName ) {
        return(ERROR_SUCCESS);
    }

    // Get the share name for hResource

    hKey = GetClusterResourceKey( hResource, KEY_READ );

    if (!hKey) {
        (g_LogEvent)(
            pContext->pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SMBValidateUniqueProperties: Failed to get the resource key, was resource deleted ? Error: %1!u!...\n",
            GetLastError() );
        return( ERROR_SUCCESS );
    }

    dwStatus = ClusterRegOpenKey( hKey, PARAM_KEYNAME__PARAMETERS, KEY_READ, &hParamKey );

    if (dwStatus != ERROR_SUCCESS) {
        (g_LogEvent)(
            pContext->pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SMBValidateUniqueProperties: Failed to open the cluster registry key for the resource, was resource deleted ? Error: %1!u!...\n",
            dwStatus );
        dwStatus = ERROR_SUCCESS;
        goto error_exit;
    }

    lpszShareName = ResUtilGetSzValue( hParamKey, PARAM_NAME__SHARENAME );

    //if the name exists, check it against this one.  If not, then
    //this is an incomplete resource and dont fail this call
    if (!lpszShareName) {
        goto error_exit;
    }

    // Ok now check for uniqueness
    if ( !( lstrcmpiW( lpszShareName, pContext->pParams->ShareName) ) ) {
        (g_LogEvent)(
            pContext->pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SMBValidateUniqueProperties: Share name '%1' already exists.\n",
            pContext->pParams->ShareName );
        dwStatus = ERROR_DUP_NAME;
    } else {
        dwStatus = ERROR_SUCCESS;
    }

    //
    //  If this share is set to be a DFS root share make sure there is no other DFS root
    //  with an overlapping path as this share.
    //
    if ( pContext->pParams->DfsRoot )
    {
        DWORD   dwIsDfsRoot = 0;
        
        ResUtilGetDwordValue( hParamKey, 
                              PARAM_NAME__DFSROOT,
                              &dwIsDfsRoot,
                              0 );

        if ( dwIsDfsRoot == 1 )
        {
            LPWSTR  lpszPath = NULL;
            
            lpszPath = ResUtilGetSzValue( hParamKey, PARAM_NAME__PATH );            

            if ( lpszPath != NULL )
            {
                if ( ( wcsstr( lpszPath, pContext->pParams->Path ) != NULL ) ||
                     ( wcsstr( pContext->pParams->Path, lpszPath ) != NULL ) )
                {
                    dwStatus = ERROR_BAD_PATHNAME;
                    (g_LogEvent)(
                        pContext->pResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"SMBValidateUniqueProperties: Path %1!ws! for existing DFS root %2!ws! conflicts with the specified path %3!ws! for DFS root %4!ws!...\n",
                        lpszPath,
                        lpszShareName,
                        pContext->pParams->Path,
                        pContext->pParams->ShareName);                   
                }               
                LocalFree ( lpszPath );
            }                        
        }       
    }
    
error_exit:
    if (hKey) ClusterRegCloseKey( hKey );

    if (hParamKey)  ClusterRegCloseKey( hParamKey );

    if (lpszShareName) LocalFree( lpszShareName );

    return( dwStatus );

} // SMBValidateUniqueProperties


DWORD
SmbShareValidatePrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSHARE_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type File Share.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    SHARE_PARAMS        currentProps;
    SHARE_PARAMS        newProps;
    PSHARE_PARAMS       pParams = NULL;
    LPWSTR              nameOfPropInError;
    SHARE_ENUM_CONTEXT  enumContext;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Capture the current set of private properties from the registry.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 SmbShareResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(SHARE_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       SmbShareResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to duplicate the parameter block. Error: %1!u!.\n",
            status );
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( SmbShareResourcePrivateProperties,
                                         NULL,
                                         TRUE,      // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the path
        //
        if ( pParams->Path &&
             !ResUtilIsPathValid( pParams->Path ) ) {
            status = ERROR_INVALID_PARAMETER;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid path specified ('%1'). Error: %2!u!.\n",
                pParams->Path,
                status );
            goto FnExit;
        }

        //
        // Validate the parameter values.
        //
        if ( (pParams->SecurityDescriptorSize != 0) &&
             !IsValidSecurityDescriptor(pParams->SecurityDescriptor) ) {
            status = ERROR_INVALID_PARAMETER;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid parameter specified ('SecurityDescriptor'). Error: %1!u!.\n",
                status );
            goto FnExit;
        }
        if ( (pParams->SecuritySize != 0) &&
             !IsValidSecurityDescriptor(pParams->Security) ) {
            status = ERROR_INVALID_PARAMETER;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid parameter specified ('Security'). Error: %1!u!.\n",
                status );
            goto FnExit;
        }
        if ( pParams->MaxUsers == 0 ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid value for MaxUsers specified (%1!u!).\n",
                pParams->MaxUsers );
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // Make sure the share name is  unique
        //
        enumContext.pResourceEntry = ResourceEntry;
        enumContext.pParams = pParams;
        status = ResUtilEnumResources(ResourceEntry->hResource,
                                      CLUS_RESTYPE_NAME_FILESHR,
                                      SMBValidateUniqueProperties,
                                      &enumContext);

        if (status != ERROR_SUCCESS) {
           (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbShareValidatePrivateResProperties: ResUtilEnumResources failed with status=%1!u!...\n",
                status);            
            goto FnExit;
        }

        //
        // Verify that the share name is valid.
        //
        status = SmbpValidateShareName( pParams->ShareName );

        if (status != ERROR_SUCCESS) {
           (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbShareValidatePrivateResProperties: Share name %1!ws! contains illegal chars, Status=%2!u!...\n",
                pParams->ShareName,
                status);            
            goto FnExit;
        }

        //
        // Verify that the directory exists.
        //
        if ( !ClRtlPathFileExists( pParams->Path ) ) {
            status = ERROR_PATH_NOT_FOUND;
            goto FnExit;
        }

        //
        //  If this share needs to be a DFS root, then make sure the path is on an NTFS volume.
        //
        if ( pParams->DfsRoot )
        {
            WCHAR   szRootPathName[4];
            WCHAR   szFileSystem[32];   // Array size stolen from CLUSPROP_PARTITION_INFO

            //
            //  Copy just the drive letter from the supplied path.
            //
            lstrcpyn ( szRootPathName, pParams->Path, 4 );

            szRootPathName[2] = L'\\';
            szRootPathName[3] = L'\0';
                
            if ( !GetVolumeInformationW( szRootPathName,
                                         NULL,              // Volume name buffer
                                         0,                 // Volume name buffer size
                                         NULL,              // Volume serial number
                                         NULL,              // Maximum component length
                                         NULL,              // File system flags    
                                         szFileSystem,      // File system name
                                         sizeof(szFileSystem)/sizeof(WCHAR) ) ) 
            {
                status = GetLastError();
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareValidatePrivateResProperties: GetVolumeInformation on root path %1!ws! for share %2!ws! failed, Status %3!u!...\n",
                    szRootPathName,
                    pParams->ShareName,
                    status );   
                goto FnExit;
            }

            if ( lstrcmpi( szFileSystem, L"NTFS" ) != 0 )
            {
                status = ERROR_BAD_PATHNAME;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareValidatePrivateResProperties: Root path %1!ws! for share %2!ws! is not NTFS, Status %3!u!...\n",
                    szRootPathName,
                    pParams->ShareName,
                    status );   
                goto FnExit;
            }
        }            
    } else {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Validating properties failed. Error: %1!u!.\n",
            status );
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   SmbShareResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        SmbShareResourcePrivateProperties
        );

    return(status);

} // SmbShareValidatePrivateResProperties



DWORD
SmbShareSetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type File Share.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.


    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    If the share name changes then we must delete the old share and
    create a new one. Otherwise, just set the new info.

--*/

{
    DWORD                   status;
    SHARE_PARAMS            params;
    LPWSTR                  oldName;
    BOOL                    bNameChange = FALSE;
    BOOL                    bPathChanged = FALSE;
    BOOL                    bFoundSecurity = FALSE;
    BOOL                    bFoundSD = FALSE;
    PSECURITY_DESCRIPTOR    psd = NULL;
    DWORD                   SDSize = 0;
    DWORD                   securitySize = 0;
    BOOL                    bChangeDfsRootProp = FALSE;

    ZeroMemory( &params, sizeof(SHARE_PARAMS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = SmbShareValidatePrivateResProperties( ResourceEntry,
                                                   InBuffer,
                                                   InBufferSize,
                                                   &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // fixup the Security and Security Descriptor properties to match
    //
   
    bFoundSecurity = ( ERROR_SUCCESS == ResUtilFindBinaryProperty( InBuffer,
                                                                   InBufferSize,
                                                                   PARAM_NAME__SECURITY,
                                                                   NULL,
                                                                   &securitySize ) );
   
    if ( bFoundSecurity && (securitySize == 0) ) {
        //
        // The security string could have been passed in, but it may be
        // a zero length buffer. We will delete the buffer and indicate it
        // is not present in that case.
        //
        bFoundSecurity = FALSE;
        FREE_SECURITY_INFO();
    }

    bFoundSD =( ERROR_SUCCESS == ResUtilFindBinaryProperty( InBuffer,
                                                            InBufferSize,
                                                            PARAM_NAME__SD,
                                                            NULL,
                                                            &SDSize ) );

    if ( bFoundSD && (SDSize == 0) ) {
        //
        // The security string could have been passed in, but it may be
        // a zero length buffer. We will delete the buffer and indicate it
        // is not present in that case.
        //
        bFoundSD = FALSE;
        FREE_SECURITY_INFO();
    }

    if ( bFoundSD ) {     // prefer SD, convert SD to Security

        psd = ClRtlConvertFileShareSDToNT4Format( params.SecurityDescriptor );

        LocalFree( params.Security );

        params.Security = psd;
        params.SecuritySize = GetSecurityDescriptorLength( psd );

        //
        // if the ACL has changed, dump it to the cluster log
        //
        if ( SDSize == ResourceEntry->Params.SecurityDescriptorSize ) {
            if ( memcmp(params.SecurityDescriptor,
                        ResourceEntry->Params.SecurityDescriptor,
                        SDSize ) != 0 )
            {

                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_INFORMATION,
                             L"Changing share permissions\n");
                SmbExamineSD( ResourceEntry->ResourceHandle, params.SecurityDescriptor );
            }
        }
    }
    else if ( bFoundSecurity ) {            // simply write Security to SD

        psd = ClRtlCopySecurityDescriptor( params.Security );

        LocalFree( params.SecurityDescriptor );

        params.SecurityDescriptor = psd;
        params.SecurityDescriptorSize = GetSecurityDescriptorLength( psd );

        //
        // if the ACL has changed, dump it to the cluster log
        //
        if ( securitySize == ResourceEntry->Params.SecuritySize ) {
            if ( memcmp(params.Security,
                        ResourceEntry->Params.Security,
                        securitySize ) != 0 )
            {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_INFORMATION,
                             L"Changing share permissions\n");
                SmbExamineSD( ResourceEntry->ResourceHandle, params.Security );
            }
        }
    }

    //
    // Duplicate the share name if it changed.
    // Do this even if only the case of the share name changed.
    //
    if ( (ResourceEntry->Params.ShareName != NULL) &&
         (ResourceEntry->State == ClusterResourceOnline) &&
         (lstrcmpW( params.ShareName, ResourceEntry->Params.ShareName ) != 0) ) {
        oldName = ResUtilDupString( ResourceEntry->Params.ShareName );
        bNameChange = TRUE;
    } else {
        oldName = ResourceEntry->Params.ShareName;
    }

    if ( (params.HideSubDirShares != ResourceEntry->Params.HideSubDirShares) ||
         (params.ShareSubDirs != ResourceEntry->Params.ShareSubDirs) ||
         (params.ShareSubDirs && lstrcmpW (params.Path, ResourceEntry->Params.Path)) ) {
        bNameChange = TRUE;
    }

    //
    // Find out if the path changed.
    //
    if ( (ResourceEntry->Params.Path != NULL) &&
         (lstrcmpW( params.Path, ResourceEntry->Params.Path ) != 0) ) {
        bPathChanged = TRUE;
    }

    //
    //  Chittur Subbaraman (chitturs) - 2/9/99
    //
    //  Don't welcome any changes if you are dealing with a dfs root. Also
    //  make sure "DfsRoot" is mutually exclusive with "ShareSubDirs"
    //  and "HideSubDirShares" properties.
    //
    if ( ( ( ResourceEntry->Params.DfsRoot ) && 
           ( bNameChange || bPathChanged ) ) ||
         ( ( params.DfsRoot ) && 
           ( params.ShareSubDirs || params.HideSubDirShares ) ) )
    {
        status = ERROR_RESOURCE_PROPERTY_UNCHANGEABLE;
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   SmbShareResourcePrivateProperties );
        goto FnExit;
    }

    if ( params.DfsRoot && !ResourceEntry->Params.DfsRoot )
    {
        BOOL    fIsDfsRoot = FALSE;

        //
        //  Check if this node has a DFS root already with the same root share name. If so,
        //  don't allow this resource to be promoted as a DFS resource.
        //
        SmbpIsDfsRoot( ResourceEntry, &fIsDfsRoot );

        if( fIsDfsRoot == TRUE ) 
        {
            status = ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT;
            ResUtilFreeParameterBlock( (LPBYTE) &params,
                                       (LPBYTE) &ResourceEntry->Params,
                                       SmbShareResourcePrivateProperties );
            goto FnExit;
        }
    }

    if ( ResourceEntry->Params.DfsRoot != params.DfsRoot ) {
        bChangeDfsRootProp = TRUE;
    }
    
    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               SmbShareResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               SmbShareResourcePrivateProperties );

    //
    // If the resource is online, set the new values.  If online pending,
    // we must wait until the user brings it online again.
    //
    if ( status == ERROR_SUCCESS ) {
        if ( (ResourceEntry->State == ClusterResourceOnline) && !bNameChange && !bPathChanged ) {

            PSHARE_INFO_502  oldShareInfo;
            SHARE_INFO_502   newShareInfo;

            EnterCriticalSection( &SmbShareLock );

            // Get current information.
            status = NetShareGetInfo( NULL,
                                      oldName,
                                      502,
                                      (LPBYTE*)&oldShareInfo );

            if ( status == ERROR_SUCCESS ) {
                DWORD           invalidParam;

                //
                // Set new share info.
                //
                CopyMemory( &newShareInfo, oldShareInfo, sizeof( newShareInfo ) );
                newShareInfo.shi502_netname =   ResourceEntry->Params.ShareName;
                newShareInfo.shi502_remark =    ResourceEntry->Params.Remark;
                newShareInfo.shi502_max_uses =  ResourceEntry->Params.MaxUsers;
                newShareInfo.shi502_path =      ResourceEntry->Params.Path;
                newShareInfo.shi502_security_descriptor = ResourceEntry->Params.SecurityDescriptor;

                //
                // Set new info.
                //
                status = NetShareSetInfo( NULL,
                                          oldName,
                                          502,
                                          (LPBYTE)&newShareInfo,
                                          &invalidParam );
                if ( status != ERROR_SUCCESS ) {
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"SetPrivateProps, error setting info on share '%1!ws!. Error %2!u!, property # %3!d!.\n",
                        oldName,
                        status,
                        invalidParam );
                    status = ERROR_RESOURCE_PROPERTIES_STORED;
                }

                NetApiBufferFree( oldShareInfo );

                if ( (status == ERROR_SUCCESS) ||
                     (status == ERROR_RESOURCE_PROPERTIES_STORED) ) {

                    status = SmbpSetCacheFlags( ResourceEntry,
                                                ResourceEntry->Params.ShareName );
                    if ( status != ERROR_SUCCESS ) {
                        status = ERROR_RESOURCE_PROPERTIES_STORED;
                    }
                }
            } else {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SetPrivateProps, error getting info on share '%1!ws!. Error %2!u!.\n",
                    oldName,
                    status );
                status = ERROR_RESOURCE_PROPERTIES_STORED;
            }
            
            LeaveCriticalSection( &SmbShareLock );
        } else if ( (ResourceEntry->State == ClusterResourceOnlinePending) ||
                    (ResourceEntry->State == ClusterResourceOnline) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        }
    }
    
FnExit:
    if ( oldName != ResourceEntry->Params.ShareName ) {
        LocalFree( oldName );
    }

    if ( ( status == ERROR_SUCCESS ) && bChangeDfsRootProp ) {
        if ( (ResourceEntry->State == ClusterResourceOnlinePending) ||
             (ResourceEntry->State == ClusterResourceOnline) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        }
    }

    return(status);

} // SmbShareSetPrivateResProperties

DWORD
SmbpHandleDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry,
    OUT PBOOL pbIsExistingDfsRoot
    )

/*++

Routine Description:

    Handles an smbshare which is configured as a DFS root.  

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

    pbIsExistingDfsRoot - Specifies whether the dfs root is a wolfpack resource

Return Value:

    None.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    fStatus;
    LPWSTR  lpszDfsRootCheckpointName = NULL;
    
    //
    //  Make sure the DFS service is started. This is necessary since the cluster service does not set 
    //  an explicit dependency on DFS service.
    //
    dwStatus = ResUtilStartResourceService( DFS_SVCNAME,
                                            NULL );
    if ( dwStatus != ERROR_SUCCESS ) 
    {
    	(g_LogEvent)(
        	pResourceEntry->ResourceHandle,
        	LOG_ERROR,
        	L"SmbpHandleDfsRoot: Failed to start DFS service, share name %1!ws!, status %2!u!...\n",
        	pResourceEntry->Params.ShareName,
        	dwStatus);
        goto FnExit;
    }       

    //
    //  Check whether this resource represents an existing dfs root. Note that you cannot use
    //  SmbpIsDfsRoot here since that function only assuredly returns roots that are MASTER
    //  in this node. Those roots that are STANDBY may fail to come out of NetDfsEnum if a
    //  checkpoint restore is in progress at the time we invoke the enum.
    //
    //  This is a private API provided by UDAYH of DFS team on 4/26/2001.
    //
    dwStatus = GetDfsRootMetadataLocation( pResourceEntry->Params.ShareName,
                                           &lpszDfsRootCheckpointName );

    if ( dwStatus == ERROR_NOT_FOUND ) 
    {
        *pbIsExistingDfsRoot = FALSE;
        //
        //  Change status to success so that you return the right status from this function if
        //  you happen to bail out early.
        //
        dwStatus = ERROR_SUCCESS;
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SmbpHandleDfsRoot: DFS root %1!ws! NOT found in local node...\n",
            pResourceEntry->Params.ShareName);
    } else if ( dwStatus == ERROR_SUCCESS )
    {
        *pbIsExistingDfsRoot = TRUE;
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SmbpHandleDfsRoot: DFS root %1!ws! found in local node...\n",
            pResourceEntry->Params.ShareName);
    } else
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpHandleDfsRoot: GetDfsRootMetadataLocation(1) for DFS root '%1!ws!' returns %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);       
        goto FnExit;
    }

    //
    //  If there is a DFS root on this node that matches the share name of this resource or if
    //  the user is attempting to set up a DFS root, then get the VS name that provides for
    //  this resource so that we can pass it onto DFS APIs.
    //
    if ( ( pResourceEntry->Params.DfsRoot ) ||
         ( *pbIsExistingDfsRoot == TRUE ) )
    {
        //
        //  Get the dependent network name of the dfs root resource. You need to do this in
        //  every online to account for the dependency change while this resource was offline.
        //
        fStatus = GetClusterResourceNetworkName( pResourceEntry->hResource,
                                                 pResourceEntry->szDependentNetworkName,
                                                 &dwSize );

        if ( !fStatus ) 
        {
            dwStatus = GetLastError();
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: SmpbIsDfsRoot for share %1!ws! returns %2!u!...\n",
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;       
        }

        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SmbpHandleDfsRoot: DFS root share %1!ws! has a provider VS name of %2!ws!...\n",
            pResourceEntry->Params.ShareName,
            pResourceEntry->szDependentNetworkName);
        //
        //  HACKHACK: Chittur Subbaraman (chitturs) - 5/18/2001
        //
        //  Sleep for few secs to mask an issue with the dependent netname not being really usable 
        //  (especially as binding parameter to named pipes done by the DFS APIs we call below) after  
        //  it declares itself to be online. This is due to the fact that netname NBT
        //  registrations are apparently async and it takes a while for that to percolate to other
        //  drivers such as SRV.
        //         
        Sleep ( 4 * 1000 );
    }
    
    if ( !pResourceEntry->Params.DfsRoot )
    {
        if ( *pbIsExistingDfsRoot )
        {
            //
            // This means the user no longer wants the share to be a 
            // DFS root. Delete the registry checkpoints and the
            // corresponding DFS root.
            //
            dwStatus = SmbpDeleteDfsRoot( pResourceEntry );
            if ( dwStatus != ERROR_SUCCESS )
            {
                (g_LogEvent)(
                    pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpHandleDfsRoot: Failed to delete DFS root for share %1!ws!, status %2!u!...\n",
                    pResourceEntry->Params.ShareName,
                    dwStatus);
                goto FnExit;
            }
            *pbIsExistingDfsRoot = FALSE;
        }
        pResourceEntry->bDfsRootNeedsMonitoring = FALSE;
        goto FnExit;
    } 

    //
    //  If there is no DFS root with the same rootshare name
    //  as this resource, attempt to create the dfs root. However, the 
    //  user could have mistakenly created a dfs root with a different 
    //  share name. In such a case, the following create call will fail.
    // 
    if ( !( *pbIsExistingDfsRoot ) )
    {
        dwStatus = SmbpCreateDfsRoot( pResourceEntry ); 
    
        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: Create dfs root for share %1!ws! returns %2!u!...\n",
                pResourceEntry->Params.ShareName,
                dwStatus);

            if ( dwStatus == ERROR_FILE_EXISTS )
            {
                dwStatus = ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT;
            }
                
            ClusResLogSystemEventByKeyData( pResourceEntry->ResourceKey,
                                            LOG_CRITICAL,
                                            RES_SMB_CANT_CREATE_DFS_ROOT,
                                            sizeof( dwStatus ),
                                            &dwStatus );           
            goto FnExit; 
        }
        (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SmbpHandleDfsRoot: Create dfs root for share %1!ws!\n",
                pResourceEntry->Params.ShareName);
        *pbIsExistingDfsRoot = TRUE;
    }

    if ( lpszDfsRootCheckpointName == NULL )
    {
        dwStatus = GetDfsRootMetadataLocation( pResourceEntry->Params.ShareName,
                                               &lpszDfsRootCheckpointName );

        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: GetDfsRootMetadataLocation(2) for dfs root %1!ws!, status %2!u!...\n",
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;
        }
    }

    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_NOISE,
        L"SmbpHandleDfsRoot: Dfs root %1!ws! metadata location from DFS API is %2!ws!...\n",
        pResourceEntry->Params.ShareName,
        lpszDfsRootCheckpointName);
    
    dwStatus = ClusterResourceControl(
                   pResourceEntry->hResource,
                   NULL,
                   CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                   lpszDfsRootCheckpointName,
                   (lstrlenW(lpszDfsRootCheckpointName) + 1) * sizeof(WCHAR),
                   NULL,
                   0,
                   &dwSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_ALREADY_EXISTS )
        {
            dwStatus = ERROR_SUCCESS;
        }
        else
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: Failed to set registry checkpoint %1!ws! for share %2!ws!, status %3!u!...\n",
                lpszDfsRootCheckpointName,
                pResourceEntry->Params.ShareName,
                dwStatus);
        }
    } 

    pResourceEntry->bDfsRootNeedsMonitoring = TRUE;
 
FnExit:
    //
    //  Free memory for the checkpoint name buffer for this DFS root resource. This is a private API provided
    //  by UDAYH of DFS team on 4/26/2001.
    //
    if ( lpszDfsRootCheckpointName != NULL ) 
        ReleaseDfsRootMetadataLocation ( lpszDfsRootCheckpointName );

    return( dwStatus );
} // SmbpHandleDfsRoot

DWORD
SmbpIsDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry,
    OUT PBOOL pbIsDfsRoot
    )

/*++

Routine Description:

    Checks if this root share is a dfs root.

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

    pbIsDfsRoot - Specifies whether a dfs root with the same root share
                  name as this resource exists.

Return Value:

    ERROR_SUCCESS or a Win32 error code

--*/

{
    DWORD           dwStatus = ERROR_SUCCESS;
    PDFS_INFO_200   pDfsInfo200 = NULL, pTemp = NULL;
    DWORD           cEntriesRead = 0;
    DWORD           dwResume = 0, i;

    //
    //  Chittur Subbaraman (chitturs) - 4/14/2001
    //
    *pbIsDfsRoot = FALSE;
    
    //
    // Call the NetDfsEnum function specifying level 200.
    //
    dwStatus = NetDfsEnum( pResourceEntry->ComputerName,        // Local computer name 
                           200,                                 // Info level  
                           0xFFFFFFFF,                          // Return all info 
                           ( LPBYTE * ) &pDfsInfo200,           // Data buffer
                           &cEntriesRead,                       // Entries read
                           &dwResume );                         // Resume handle
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        //
        //  If we did not find any root return success
        //
        if ( dwStatus == ERROR_FILE_NOT_FOUND ) 
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpIsDfsRoot: NetDfsEnum returns %1!u! for root share %2!ws!...\n",
                dwStatus,
                pResourceEntry->Params.ShareName);
        }
        goto FnExit;
    }

    pTemp = pDfsInfo200;
    
    for( i=0;i<cEntriesRead; i++, pTemp++ )
    {
        if ( lstrcmp( pResourceEntry->Params.ShareName, pTemp->FtDfsName ) == 0 )
        {
            *pbIsDfsRoot = TRUE;
            break;
        }
    } // for

    //
    // Free the allocated buffer.
    //
    NetApiBufferFree( pDfsInfo200 );
    
FnExit:    
    return( dwStatus );
} // SmbpIsDfsRoot


DWORD 
SmbpPrepareOnlineDfsRoot(
    IN PSHARE_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Prepares the online of the dfs root share.  

Arguments:

    ResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success
    Win32 error code otherwise

--*/
{
    DWORD           dwStatus;
    DFS_INFO_101    dfsInfo101;
    WCHAR           szDfsEntryPath[MAX_PATH+1];

    dfsInfo101.State = DFS_VOLUME_STATE_RESYNCHRONIZE;

    //
    //  Prepare a path of the form \\VSName\ShareName to pass into DFS API.
    //
    lstrcpy( szDfsEntryPath, L"\\\\" );
    lstrcat( szDfsEntryPath, ResourceEntry->szDependentNetworkName );
    lstrcat( szDfsEntryPath, L"\\" );
    lstrcat( szDfsEntryPath, ResourceEntry->Params.ShareName );
        
    dwStatus = NetDfsSetInfo( szDfsEntryPath,           // Root share   
                              NULL,                     // Remote server name
                              NULL,                     // Remote share name
                              101,                      // Info level
                              ( PBYTE ) &dfsInfo101 );  // Input buffer
    
    if ( dwStatus != ERROR_SUCCESS ) 
    {
    	(g_LogEvent)(
        	ResourceEntry->ResourceHandle,
        	LOG_ERROR,
        	L"SmbpPrepareOnlineDfsRoot: Failed to set DFS info for root %1!ws!, status %2!u!...\n",
        	ResourceEntry->Params.ShareName,
        	dwStatus);

        ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_SMB_CANT_INIT_DFS_SVC,
                                        sizeof( dwStatus ),
                                        &dwStatus ); 
        goto FnExit;
    }

    //
    //  HACKHACK (chitturs) - 5/21/2001
    //
    //  FFF in liveness check returns ERROR_PATH_NOT_FOUND in the first liveness check after 
    //  online.  This is due to the fact that the RDR caches share info for 10 seconds after 
    //  share creation and if the cache is not invalidated by the time we call FFF, RDR gets confused.
    //
    Sleep( 12 * 1000 );
    
FnExit:   
    return( dwStatus );
} // SmbpPrepareOnlineDfsRoot


DWORD 
SmbpCreateDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Create a DFS root.  

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;

    //
    // Chittur Subbaraman (chitturs) - 2/14/99
    //
    dwStatus = NetDfsAddStdRoot( pResourceEntry->szDependentNetworkName, 
                                 pResourceEntry->Params.ShareName,
                                 NULL,
                                 0 );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpCreateDfsRoot: Failed to create dfs root for share %1!ws!, status %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);
        goto FnExit;
    }
    
FnExit:
    return ( dwStatus );
} // SmbpCreateDfsRoot

DWORD 
SmbpDeleteDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry   
    )
/*++

Routine Description:

    Delete the DFS root and the registry checkpoints.  

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwReturnSize;
    LPWSTR          lpszDfsRootCheckpointName = NULL;

    //
    //  Get the checkpoint name for this DFS root resource. This is a private API provided
    //  by UDAYH of DFS team on 4/26/2001.
    //
    dwStatus = GetDfsRootMetadataLocation( pResourceEntry->Params.ShareName,
                                           &lpszDfsRootCheckpointName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpDeleteDfsRoot: Failed to get metadata location for dfs root %1!ws!, status %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);
        goto FnExit;
    }

    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_NOISE,
        L"SmbpDeleteDfsRoot: Dfs root %1!ws! metadata location from DFS API is %2!ws!...\n",
        pResourceEntry->Params.ShareName,
        lpszDfsRootCheckpointName);

    dwStatus = ClusterResourceControl(
                    pResourceEntry->hResource,
                    NULL,
                    CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
                    lpszDfsRootCheckpointName,
                    (lstrlenW(lpszDfsRootCheckpointName) + 1) * sizeof(WCHAR),
                    NULL,
                    0,
                    &dwReturnSize );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpDeleteDfsRoot: Failed to delete registry checkpoint %1!ws! for share %2!ws!, status %3!u!...\n",
                lpszDfsRootCheckpointName,
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;
        }
    }
    
    dwStatus = NetDfsRemoveStdRoot( pResourceEntry->szDependentNetworkName, 
                                    pResourceEntry->Params.ShareName,
                                    0 );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpDeleteDfsRoot: Failed to delete dfs root %1!ws!, status %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);
        goto FnExit;
    } else
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpDeleteDfsRoot: Delete share %1!ws! as a dfs root\n",
            pResourceEntry->Params.ShareName); 
    }

FnExit:
    //
    //  Free memory for the checkpoint name buffer for this DFS root resource. This is a private API provided
    //  by UDAYH of DFS team on 4/26/2001.
    //
    if ( lpszDfsRootCheckpointName != NULL ) 
        ReleaseDfsRootMetadataLocation ( lpszDfsRootCheckpointName );

    return ( dwStatus );
} // SmbpDeleteDfsRoot

DWORD
SmbpResetDfs(
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Set the DFS root to standby mode. This will make the root inaccessible as well as allow the
    share to be deleted.

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DFS_INFO_101    dfsInfo101;
    WCHAR           szDfsEntryPath[MAX_PATH+1];
    DWORD           dwStatus;

    dfsInfo101.State = DFS_VOLUME_STATE_STANDBY;

    //
    //  Prepare a path of the form \\VSName\ShareName to pass into DFS API.
    //
    lstrcpy( szDfsEntryPath, L"\\\\" );
    lstrcat( szDfsEntryPath, pResourceEntry->szDependentNetworkName );
    lstrcat( szDfsEntryPath, L"\\" );
    lstrcat( szDfsEntryPath, pResourceEntry->Params.ShareName );

    dwStatus = NetDfsSetInfo( szDfsEntryPath,          // Root share 
                              NULL,                    // Remote server name                      
                              NULL,                    // Remote share name
                              101,                     // Info level 
                              ( PBYTE ) &dfsInfo101 ); // Input buffer

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpResetDfs: NetDfsSetInfo with VS name %1!ws! for root %2!ws!, status %3!u!...\n",
            pResourceEntry->szDependentNetworkName,
            pResourceEntry->Params.ShareName,
            dwStatus);

        //
        //  If this function was called as a part of resmon rundown, then it is possible that
        //  the VS is terminated by resmon before this call is made. In such a case, we would
        //  fail in the above call. So, retry using computer name. That should succeed.
        //
        //  Prepare a path of the form \\ComputerName\ShareName to pass into DFS API.
        //
        lstrcpy( szDfsEntryPath, L"\\\\" );
        lstrcat( szDfsEntryPath, pResourceEntry->ComputerName );
        lstrcat( szDfsEntryPath, L"\\" );
        lstrcat( szDfsEntryPath, pResourceEntry->Params.ShareName );   

        dwStatus = NetDfsSetInfo( szDfsEntryPath,          // Root share 
                                  NULL,                    // Remote server name                      
                                  NULL,                    // Remote share name
                                  101,                     // Info level 
                                  ( PBYTE ) &dfsInfo101 ); // Input buffer 

        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpResetDfs: NetDfsSetInfo with computer name %1!ws! for root %2!ws!, status %3!u!...\n",
                pResourceEntry->ComputerName,
                pResourceEntry->Params.ShareName,
                dwStatus);                         
        }
    }

    return ( dwStatus );
} // SmbpResetDfs


DWORD
SmbpValidateShareName(
    IN  LPCWSTR  lpszShareName
    )

/*++

Routine Description:

    Validates the name of a share.

Arguments:

    lpszShareName - The name to validate.

Return Value:

    ERROR_SUCCESS if successful, Win32 error code otherwise.

--*/
{
    DWORD   cchShareName = lstrlenW( lpszShareName );

    //
    // Check the length of the name, return an error if it's out of range
    //
    if ( ( cchShareName < 1 ) || ( cchShareName > NNLEN ) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check for illegal characters, return an error if one is found
    //
    if ( wcscspn( lpszShareName, ILLEGAL_NAME_CHARS_STR TEXT("*") ) < cchShareName ) 
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Return an error if the name contains only dots and spaces.
    //
    if ( wcsspn( lpszShareName, DOT_AND_SPACE_STR ) == cchShareName ) 
    {
        return ERROR_INVALID_NAME;
    }

    //
    // If we get here, the name passed all of the tests, so it's valid
    //
    return ERROR_SUCCESS;
}// SmbpValidateShareName


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( SmbShareFunctionTable,  // Name
                         CLRES_VERSION_V1_00,    // Version
                         SmbShare,               // Prefix
                         NULL,                   // Arbitrate
                         NULL,                   // Release
                         SmbShareResourceControl,// ResControl
                         SmbShareResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\resutils\resutils.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    resutils.c

Abstract:

    Common utility routines for clusters resources

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/

#include "clusres.h"
#include "clusrtl.h"
#include "winbase.h"
#include "userenv.h"



//#define DBG_PRINT printf
#define DBG_PRINT

typedef struct _WORK_CONTEXT {
    PCLUS_WORKER Worker;
    PVOID lpParameter;
    PWORKER_START_ROUTINE lpStartRoutine;
} WORK_CONTEXT, *PWORK_CONTEXT;


//
// Local Data
//
CRITICAL_SECTION ResUtilWorkerLock;


BOOLEAN
WINAPI
ResUtilDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )

/*++

Routine Description:

    Main DLL entry for resource utility helper module.

Arguments:

    DllHandle - Supplies the DLL Handle.

    Reason - Supplies the call reason.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    if ( Reason == DLL_PROCESS_ATTACH ) {
        InitializeCriticalSection(&ResUtilWorkerLock);
        DisableThreadLibraryCalls(DllHandle);
    }

    if ( Reason == DLL_PROCESS_DETACH ) {
        DeleteCriticalSection(&ResUtilWorkerLock);
    }

    return(TRUE);

} // ResUtilDllEntry


DWORD
WINAPI
ResUtilStartResourceService(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    )

/*++

Routine Description:

    Start a service.

Arguments:

    pszServiceName - The name of the service to start.

    phServiceHandle - Pointer to a handle to receive the service handle
        for this service.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    SC_HANDLE       serviceHandle;
    SC_HANDLE       scManagerHandle;
    DWORD           status = ERROR_SUCCESS;
    SERVICE_STATUS  serviceStatus;

    scManagerHandle = OpenSCManager( NULL,        // local machine
                                     NULL,        // ServicesActive database
                                     SC_MANAGER_ALL_ACCESS ); // all access

    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT( "ResUtilStartResourceService: Cannot access service controller! Error: %u.\n",
                   status );
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 pszServiceName,
                                 SERVICE_ALL_ACCESS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT( "ResUtilStartResourceService: Cannot open service %ws. Error: %u.\n",
                   pszServiceName,
                   status );
        CloseServiceHandle( scManagerHandle );
        return(status);
    }
    CloseServiceHandle( scManagerHandle );

    if ( !StartService( serviceHandle,
                        0,
                        NULL) ) {
        status = GetLastError();
        if ( status == ERROR_SERVICE_ALREADY_RUNNING ) {
            status = ERROR_SUCCESS;
        } else {
            DBG_PRINT( "ResUtilStartResourceService: Failed to start %ws service. Error: %u.\n",
                       pszServiceName,
                       status );
        }
    } else {
        //
        // Wait for the service to start.
        //
        while ( TRUE ) {
            status = ERROR_SUCCESS;
            if ( !QueryServiceStatus(serviceHandle, &serviceStatus) ) {
                status = GetLastError();
                DBG_PRINT("ResUtilStartResourceService: Failed to query status of %ws service. Error: %u.\n",
                    pszServiceName,
                    status);
                break;
            }

            if ( serviceStatus.dwCurrentState == SERVICE_RUNNING ) {
                break;
            } else if ( serviceStatus.dwCurrentState != SERVICE_START_PENDING ) {
                status = ERROR_SERVICE_NEVER_STARTED;
                DBG_PRINT("ResUtilStartResourceService: Failed to start %ws service. CurrentState: %u.\n",
                    pszServiceName,
                    serviceStatus.dwCurrentState);
                break;
            }
            Sleep(200);         // Try again in a little bit
        }
    }

    if ( (status == ERROR_SUCCESS) &&
         ARGUMENT_PRESENT(phServiceHandle) ) {
        *phServiceHandle = serviceHandle;
    } else {
        CloseServiceHandle( serviceHandle );
    }

    return(status);

} // ResUtilStartResourceService


DWORD
WINAPI
ResUtilStopResourceService(
    IN LPCWSTR pszServiceName
    )

/*++

Routine Description:

    Stop a service.

Arguments:

    pszServiceName - The name of the service to stop.

Return Value:

    ERROR_SUCCESS - Service stopped successfully.

    Win32 error code - Error stopping service.

--*/

{
    SC_HANDLE       serviceHandle;
    SC_HANDLE       scManagerHandle;
    DWORD           status = ERROR_SUCCESS;
    DWORD           retryTime = 30*1000;  // wait 30 secs for shutdown
    DWORD           retryTick = 300;      // 300 msec at a time
    BOOL            didStop = FALSE;
    SERVICE_STATUS  serviceStatus;

    scManagerHandle = OpenSCManager( NULL,
                                     NULL,
                                     SC_MANAGER_ALL_ACCESS );
    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot access service controller! Error: %u.\n",
            status);
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 pszServiceName,
                                 SERVICE_ALL_ACCESS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot open service %ws. Error: %u.\n",
                  pszServiceName,
                  status);
        CloseServiceHandle(scManagerHandle);
        return(status);
    }
    CloseServiceHandle(scManagerHandle);

    while ( TRUE ) {

        status = ERROR_SUCCESS;
        if ( !ControlService(serviceHandle,
                             (didStop ? SERVICE_CONTROL_INTERROGATE : SERVICE_CONTROL_STOP),
                             &serviceStatus) ) {
            status = GetLastError();
            if ( status == ERROR_SUCCESS ) {
                didStop = TRUE;
                if ( serviceStatus.dwCurrentState == SERVICE_STOPPED ) {
                    DBG_PRINT("ResUtilStartResourceService: service %ws successfully stopped.\n",
                        pszServiceName);
                    break;
                }
            }
        }

        if ( (status == ERROR_EXCEPTION_IN_SERVICE) ||
             (status == ERROR_PROCESS_ABORTED) ||
             (status == ERROR_SERVICE_NOT_ACTIVE) ) {
            DBG_PRINT("ResUtilStartResourceService: service %ws stopped or died; status = %u.\n",
                pszServiceName,
                status);
            status = ERROR_SUCCESS;
            break;
        }

        if ( (retryTime -= retryTick) <= 0 ) {
            DBG_PRINT("ResUtilStartResourceService: service %ws did not stop; giving up.\n",
                pszServiceName,
                status);
            status = ERROR_TIMEOUT;
            break;
        }

        DBG_PRINT("ResUtilStartResourceService: StopResourceService retrying...\n");
        Sleep(retryTick);
    }

    CloseServiceHandle(serviceHandle);

    return(status);

} // ResUtilStopResourceService

DWORD
WINAPI
ResUtilVerifyResourceService(
    IN LPCWSTR pszServiceName
    )

/*++

Routine Description:

    Verify that a service is alive.

Arguments:

    pszServiceName - The name of the service to verify.

Return Value:

    ERROR_SUCCESS - Service is alive.

    Win32 error code - Error verifying service, or service is not alive.

--*/

{
    BOOL            success;
    SC_HANDLE       serviceHandle;
    SC_HANDLE       scManagerHandle;
    DWORD           status = ERROR_SUCCESS;
    SERVICE_STATUS  serviceStatus;

    scManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot access service controller! Error: %u.\n",
            status);
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 pszServiceName,
                                 SERVICE_QUERY_STATUS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot open service %ws. Error: %u.\n",
            pszServiceName,
            status);
        CloseServiceHandle(scManagerHandle);
        return(status);
    }
    CloseServiceHandle(scManagerHandle);

    success = QueryServiceStatus( serviceHandle,
                                  &serviceStatus );

    status = GetLastError();
    CloseServiceHandle(serviceHandle);
    if ( !success ) {
        DBG_PRINT("ResUtilStartResourceService: Cannot query service %ws. Error: %u.\n",
            pszServiceName,
            status);
        return(status);
    }

    if ( (serviceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (serviceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        DBG_PRINT("ResUtilStartResourceService: Service %ws is not alive: dwCurrentState: %u.\n",
            pszServiceName,
            serviceStatus.dwCurrentState);
        return(ERROR_SERVICE_NOT_ACTIVE);
    }

    return(ERROR_SUCCESS);

} // ResUtilVerifyResourceService


DWORD
WINAPI
ResUtilStopService(
    IN SC_HANDLE hServiceHandle
    )

/*++

Routine Description:

    Stop a service.

Arguments:

    hServiceHandle - The handle of the service to stop.

Return Value:

    ERROR_SUCCESS - Service stopped successfully.

    Win32 error code - Error stopping service.

Notes:

    The hServiceHandle is closed as a side effect of this routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       retryTime = 30*1000;  // wait 30 secs for shutdown
    DWORD       retryTick = 300;      // 300 msec at a time
    BOOL        didStop = FALSE;
    SERVICE_STATUS serviceStatus;


    while ( TRUE ) {

        status = ERROR_SUCCESS;
        if ( !ControlService(hServiceHandle,
                             (didStop ? SERVICE_CONTROL_INTERROGATE : SERVICE_CONTROL_STOP),
                             &serviceStatus) ) {
            status = GetLastError();
            if ( status == ERROR_SUCCESS ) {
                didStop = TRUE;
                if ( serviceStatus.dwCurrentState == SERVICE_STOPPED ) {
                    DBG_PRINT("ResUtilStartResourceService: service successfully stopped.\n" );
                    break;
                }
            }
        }

        if ( (status == ERROR_EXCEPTION_IN_SERVICE) ||
             (status == ERROR_PROCESS_ABORTED) ||
             (status == ERROR_SERVICE_NOT_ACTIVE) ) {
            DBG_PRINT("ResUtilStartResourceService: service stopped or died; status = %u.\n",
                status);
            status = ERROR_SUCCESS;
            break;
        }

        if ( (retryTime -= retryTick) <= 0 ) {
            DBG_PRINT("ResUtilStartResourceService: service did not stop; giving up.\n",
                status);
            status = ERROR_TIMEOUT;
            break;
        }

        DBG_PRINT("ResUtilStartResourceService: StopResourceService retrying...\n");
        Sleep(retryTick);
    }

    CloseServiceHandle(hServiceHandle);

    return(status);

} // ResUtilStopResourceService

DWORD
WINAPI
ResUtilVerifyService(
    IN SC_HANDLE hServiceHandle
    )

/*++

Routine Description:

    Verify that a service is alive.

Arguments:

    hServiceHandle - The handle of the service to verify.

Return Value:

    ERROR_SUCCESS - Service is alive.

    Win32 error code - Error verifying service, or service is not alive.

--*/

{
    BOOL        success;
    DWORD       status = ERROR_SUCCESS;
    SERVICE_STATUS serviceStatus;

    success = QueryServiceStatus( hServiceHandle,
                                  &serviceStatus );
    if ( !success ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot query service. Error: %u.\n",
            status);
        return(status);
    }

    if ( (serviceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (serviceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        DBG_PRINT("ResUtilStartResourceService: Service is not alive: dwCurrentState: %u.\n",
            serviceStatus.dwCurrentState);
        return(ERROR_SERVICE_NOT_ACTIVE);
    }

    return(ERROR_SUCCESS);

} // ResUtilVerifyService


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilTerminateServiceProcessFromResDll
//
//  Description:
//      Attempt to terminate a service process from a resource DLL.
//
//  Arguments:
//      dwServicePid [IN]
//          The process ID of the service process to terminate.
//
//      bOffline [IN]
//          TRUE = called from the offline thread.
//
//      pdwResourceState [OUT]
//          State of the resource.  Optional.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
ResUtilTerminateServiceProcessFromResDll(
    IN  DWORD               dwServicePid,
    IN  BOOL                bOffline,
    OUT PDWORD              pdwResourceState,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD   nStatus     = ERROR_SUCCESS;
    HANDLE  hSvcProcess = NULL;
    BOOLEAN bWasEnabled;
    DWORD   dwResourceState = ClusterResourceFailed;

    (pfnLogEvent)(
        hResourceHandle,
        LOG_INFORMATION,
        L"ResUtilTerminateServiceProcessFromResDll: Process with id=%1!u! might be terminated...\n",
        dwServicePid
        );

    //
    // Adjust the privilege to allow debug.  This is to allow termination
    // of a service process which runs in a local system account from a
    // different service process which runs in a domain user account.
    //
    nStatus = ClRtlEnableThreadPrivilege(
                SE_DEBUG_PRIVILEGE,
                &bWasEnabled
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilTerminateServiceProcessFromResDll: Unable to set debug privilege for process with id=%1!u!, status=%2!u!...\n",
            dwServicePid,
            nStatus
            );
        goto Cleanup;
    } // if: error enabling thread privilege

    //
    // Open the process so we can terminate it.
    //
    hSvcProcess = OpenProcess(
                        PROCESS_TERMINATE,
                        FALSE,
                        dwServicePid
                        );

    if ( hSvcProcess == NULL )
    {
        //
        //  Did this happen because the process terminated
        //  too quickly after we sent out one control request ?
        //
        nStatus = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_INFORMATION,
            L"ResUtilTerminateServiceProcessFromResDll: Unable to open pid=%1!u! for termination, status=%2!u!...\n",
            dwServicePid,
            nStatus
            );
    } // if: error opening the process
    else
    {
        if ( ! bOffline )
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_INFORMATION,
                L"ResUtilTerminateServiceProcessFromResDll: Pid=%1!u! will be terminated by brute force...\n",
                dwServicePid
                );
        } // if: called from Terminate
        else
        {
            //
            // Wait 3 seconds for the process to shutdown gracefully.
            //
            if ( WaitForSingleObject( hSvcProcess, 3000 )
                       == WAIT_OBJECT_0 )
            {
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_INFORMATION,
                    L"ResUtilTerminateServiceProcessFromResDll: Process with id=%1!u! shutdown gracefully...\n",
                    dwServicePid
                    );
                dwResourceState = ClusterResourceOffline;
                nStatus = ERROR_SUCCESS;
                goto RestoreAndCleanup;
            } // if: process exited on its own
        } // else: called from Offline

        if ( ! TerminateProcess( hSvcProcess, 0 ) )
        {
            nStatus = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilTerminateServiceProcessFromResDll: Unable to terminate process with id=%1!u!, status=%2!u!...\n",
                dwServicePid,
                nStatus
                );
        } // if: error terminating the process
        else
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_INFORMATION,
                L"ResUtilTerminateServiceProcessFromResDll: Process with id=%1!u! was terminated...\n",
                dwServicePid
                );
            dwResourceState = ClusterResourceOffline;
        } // else: process terminated successfully

    } // else: process opened successfully

RestoreAndCleanup:
    ClRtlRestoreThreadPrivilege(
        SE_DEBUG_PRIVILEGE,
        bWasEnabled
        );

Cleanup:
    if ( hSvcProcess != NULL )
    {
        CloseHandle( hSvcProcess );
    } // if: process was opened successfully

    if ( pdwResourceState != NULL )
    {
        *pdwResourceState = dwResourceState;
    } // if: caller wants the resource state

    (pfnLogEvent)(
        hResourceHandle,
        LOG_INFORMATION,
        L"ResUtilTerminateServiceProcessFromResDll: Process id=%1!u!, status=%2!u!, state=%3!u!.\n",
        dwServicePid,
        nStatus,
        dwResourceState
        );

    return nStatus;

} //*** ResUtilTerminateServiceProcessFromResDll()


LPWSTR
WINAPI
ResUtilDupString(
    IN LPCWSTR pszInString
    )

/*++

Routine Description:

    Duplicates a string.

Arguments:

    pszInString - Supplies the string to be duplicated.

Return Value:

    A pointer to a buffer containing the duplicate if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR newValue;
    DWORD valueSize;

    //
    // Get the size of the parameter so we know how much to allocate.
    //
    valueSize = (lstrlenW( pszInString ) + 1) * sizeof(WCHAR);

    //
    // Allocate a buffer to copy the string into.
    //
    newValue = LocalAlloc( LMEM_FIXED, valueSize );
    if ( newValue == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    //
    // Copy Value to the newValue buffer.
    //
    lstrcpyW( newValue, pszInString );

    return(newValue);

} // ResUtilDupString


DWORD
WINAPI
ResUtilGetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize
    )

/*++

Routine Description:

    Queries a REG_BINARY or REG_MULTI_SZ value out of the cluster
    database and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    ppbOutValue - Supplies the address of a pointer in which to return the value.

    pcbOutValueSize - Supplies the address of a DWORD in which to return the
        size of the value.

Return Value:

    ERROR_SUCCESS - The value was read successfully.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory for the value.

    Win32 error code - The operation failed.

--*/

{
    LPBYTE value;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;

    //
    // Initialize the output parameters.
    //
    *ppbOutValue = NULL;
    *pcbOutValueSize = 0;

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   NULL,
                                   &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        return(status);
    }

    //
    // Allocate a buffer to read the value into.
    //
    value = LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Read the value from the cluster database.
    //
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)value,
                                   &valueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( value );
    } else {
        *ppbOutValue = value;
        *pcbOutValueSize = valueSize;
    }

    return(status);

} // ResUtilGetBinaryValue


PWSTR
WINAPI
ResUtilGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    )

/*++

Routine Description:

    Queries a REG_SZ or REG_EXPAND_SZ value out of the cluster database
    and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR   value;
    DWORD   valueSize;
    DWORD   valueType;
    DWORD   status;

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   NULL,
                                   &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        SetLastError( status );
        return(NULL);
    }

    //
    // Add on the size of the null terminator.
    //
    valueSize += sizeof(UNICODE_NULL);

    //
    // Allocate a buffer to read the string into.
    //
    value = LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    //
    // Read the value from the cluster database.
    //
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)value,
                                   &valueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( value );
        value = NULL;
    } else if ( (valueType != REG_SZ) &&
                (valueType != REG_EXPAND_SZ) &&
                (valueType != REG_MULTI_SZ) ) {
        status = ERROR_INVALID_PARAMETER;
        LocalFree( value );
        value = NULL;
    }

    return(value);

} // ResUtilGetSzValue


PWSTR
WINAPI
ResUtilGetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    )

/*++

Routine Description:

    Queries a REG_EXPAND_SZ value out of the cluster database and allocates
    the necessary storage for it, optionally expanding it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    bExpand - TRUE = return the expanded string.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR   value;
    PWSTR   valueExpanded = NULL;
    DWORD   valueSize;
    DWORD   valueType;
    DWORD   valueExpandedSize;
    DWORD   valueExpandedSizeReturned;
    DWORD   status;

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   NULL,
                                   &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        SetLastError( status );
        return(NULL);
    }

    //
    // Add on the size of the null terminator.
    //
    valueSize += sizeof(UNICODE_NULL);

    //
    // Allocate a buffer to read the string into.
    //
    value = LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    //
    // Read the value from the cluster database.
    //
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)value,
                                   &valueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( value );
        value = NULL;
    } else if ( ( valueType != REG_EXPAND_SZ ) &&
                ( valueType != REG_SZ ) ) {
        status = ERROR_INVALID_PARAMETER;
        LocalFree( value );
        value = NULL;
    } else if ( bExpand ) {
        //
        // Expand the environment variable strings in the
        // value that was just read.
        //
        valueExpandedSize = valueSize;
        do
        {
            //
            // Allocate the buffer for the expansion string.  This will
            // get double each time we are told it is too small.
            //
            valueExpanded = LocalAlloc( LMEM_FIXED, valueExpandedSize );
            if ( valueExpanded == NULL ) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } else {
                //
                // Expand the environment variables in the value.
                // If the buffer isn't big enough, we will loop up to
                // the top of the loop and allocate a bigger buffer.
                //
                valueExpandedSizeReturned = ExpandEnvironmentStrings(
                    value,
                    valueExpanded,
                    valueExpandedSize );

                if ( valueExpandedSizeReturned == 0 ) {
                    status = GetLastError();
                    break;
                } else if ( valueExpandedSizeReturned > valueExpandedSize ) {
                    valueExpandedSize = valueExpandedSize * 2;
                } else {
                    status = ERROR_SUCCESS;
                    break;
                }
            }
        } while ( TRUE );

        //
        // If any errors occurred, cleanup.
        // Otherwise, return expanded string.
        //
        if ( status != ERROR_SUCCESS ) {
            LocalFree( valueExpanded );
            LocalFree( value );
            value = NULL;
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        } else {
            LocalFree( value );
            value = valueExpanded;
        }
    }

    return(value);

} // ResUtilGetExpandSzValue


DWORD
WINAPI
ResUtilGetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPDWORD pdwOutValue,
    IN DWORD dwDefaultValue
    )

/*++

Routine Description:

    Queries a REG_DWORD value out of the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    pdwOutValue - Supplies the address of a DWORD in which to return the value.

    dwDefaultValue - Value to return if the parameter is not found.

Return Value:

    ERROR_SUCCESS - The value was read successfully.

    Win32 error code - The operation failed.

--*/

{
    DWORD value;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;

    //
    // Initialize the output value.
    //
    *pdwOutValue = 0;

    //
    // Read the value from the cluster database.
    //
    valueSize = sizeof(DWORD);
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueSize );
    if ( status == ERROR_SUCCESS ) {
        if ( valueType != REG_DWORD ) {
            status = ERROR_INVALID_PARAMETER;
        } else {
            *pdwOutValue = value;
        }
    } else if ( status == ERROR_FILE_NOT_FOUND ) {
        *pdwOutValue = dwDefaultValue;
        status = ERROR_SUCCESS;
    }

    return(status);

} // ResUtilGetDwordValue


DWORD
WINAPI
ResUtilSetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN const LPBYTE pbNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPBYTE * ppbOutValue,
    IN OUT LPDWORD pcbOutValueSize
    )

/*++

Routine Description:

    Sets a REG_BINARY value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored.

    pszValueName - Supplies the name of the value.

    pbNewValue - Supplies the new binary value.

    cbNewValueSize - Supplies the size of the new value.

    ppbOutValue - Supplies pointer to the binary pointer in which to set
        the value.

    pcbOutValueSize - Supplies a pointer to a size DWORD in which to set
        the size of the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    LPBYTE      allocedValue = NULL;

    if ( ppbOutValue != NULL )
    {
        //
        // Allocate memory for the new value.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, cbNewValueSize );
        if ( allocedValue == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_BINARY,
                                 pbNewValue,
                                 cbNewValueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( allocedValue );
        return(status);
    }

    if ( ppbOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        CopyMemory( allocedValue, pbNewValue, cbNewValueSize );

        // Set the new value in the output pointer.
        if ( *ppbOutValue != NULL ) {
            LocalFree( *ppbOutValue );
        }
        *ppbOutValue = allocedValue;
        *pcbOutValueSize = cbNewValueSize;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetBinaryValue


DWORD
WINAPI
ResUtilSetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutValue
    )

/*++

Routine Description:

    Sets a REG_SZ value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored.

    pszValueName - Supplies the name of the value.

    pszNewValue - Supplies the new string value.

    ppszOutValue - Supplies pointer to the string pointer in which to set
        the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    DWORD       dataSize;
    PWSTR       allocedValue = NULL;

    dataSize = (lstrlenW( pszNewValue ) + 1) * sizeof(WCHAR);

    if ( ppszOutValue != NULL )
    {
        //
        // Allocate memory for the new value string.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, dataSize );
        if ( allocedValue == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_SZ,
                                 (CONST BYTE*)pszNewValue,
                                 dataSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( allocedValue );
        return(status);
    }

    if ( ppszOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        lstrcpyW( allocedValue, pszNewValue );

        // Set the new value in the output string pointer.
        if ( *ppszOutValue != NULL ) {
            LocalFree( *ppszOutValue );
        }
        *ppszOutValue = allocedValue;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetSzValue


DWORD
WINAPI
ResUtilSetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutValue
    )

/*++

Routine Description:

    Sets a REG_EXPAND_SZ value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored.

    pszValueName - Supplies the name of the value.

    pszNewValue - Supplies the new string value.

    ppszOutValue - Supplies pointer to the string pointer in which to set
        the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    DWORD       dataSize;
    PWSTR       allocedValue = NULL;

    dataSize = (lstrlenW( pszNewValue ) + 1) * sizeof(WCHAR);

    if ( ppszOutValue != NULL ) {
        //
        // Allocate memory for the new value string.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, dataSize );
        if ( allocedValue == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_EXPAND_SZ,
                                 (CONST BYTE*)pszNewValue,
                                 dataSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( allocedValue );
        return(status);
    }

    if ( ppszOutValue != NULL ) {
        //
        // Copy the new value to the output buffer.
        //
        lstrcpyW( allocedValue, pszNewValue );

        // Set the new value in the output string pointer.
        if ( *ppszOutValue != NULL ) {
            LocalFree( *ppszOutValue );
        }
        *ppszOutValue = allocedValue;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetSzValue


DWORD
WINAPI
ResUtilSetMultiSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPWSTR * ppszOutValue,
    IN OUT LPDWORD pcbOutValueSize
    )

/*++

Routine Description:

    Sets a REG_MULTI_SZ value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the ValueName is stored.

    pszValueName - Supplies the name of the value.

    pszNewValue - Supplies the new MULTI_SZ value.

    cbNewValueSize - Supplies the size of the new value.

    ppszOutValue - Supplies a pointer to the string pointer in which to set
        the value.

    pcbOutValueSize - Supplies a pointer to a size DWORD in which to set
        the size of the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    LPWSTR      allocedValue = NULL;

    if ( ppszOutValue != NULL )
    {
        //
        // Allocate memory for the new value.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, cbNewValueSize );
        if ( allocedValue == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_MULTI_SZ,
                                 (CONST BYTE*)pszNewValue,
                                 cbNewValueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree(allocedValue);
        return(status);
    }

    if ( ppszOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        CopyMemory( allocedValue, pszNewValue, cbNewValueSize );

        // Set the new value in the output pointer.
        if ( *ppszOutValue != NULL ) {
            LocalFree( *ppszOutValue );
        }
        *ppszOutValue = allocedValue;
        *pcbOutValueSize = cbNewValueSize;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetMultiSzValue


DWORD
WINAPI
ResUtilSetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    )

/*++

Routine Description:

    Sets a REG_DWORD value in a pointer and sets the value in the
    cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the property is stored.

    pszValueName - Supplies the name of the value.

    dwNewValue - Supplies the new DWORD value.

    pdwOutValue - Supplies pointer to the DWORD pointer in which to set
        the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_DWORD,
                                 (CONST BYTE*)&dwNewValue,
                                 sizeof(DWORD) );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    if ( pdwOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        *pdwOutValue = dwNewValue;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetDwordValue


DWORD
WINAPI
ResUtilGetBinaryProperty(
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_BINARY pValueStruct,
    IN const LPBYTE pbOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a binary property from a property list and advances the pointers.

Arguments:

    ppbOutValue - Supplies the address of a pointer in which to return a
        pointer to the binary value in the property list.

    pcbOutValueSize - Supplies the address of the output value size.

    pValueStruct - Supplies the binary value from the property list.

    pbOldValue - Supplies the previous value for this property.

    cbOldValueSize - Supplies the previous value's size.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    BOOL    propChanged = FALSE;
    DWORD   arrayIndex;
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct) + ALIGN_CLUSPROP( pValueStruct->cbLength );
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_BINARY) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If the value changed, point to the new value.
    //
    if ( (pbOldValue == NULL) ||
         (cbOldValueSize != pValueStruct->cbLength) ) {
        propChanged = TRUE;
    } else {
        for ( arrayIndex = 0 ; arrayIndex < cbOldValueSize ; arrayIndex++ ) {
            if ( pValueStruct->rgb[arrayIndex] != pbOldValue[arrayIndex] ) {
                propChanged = TRUE;
                break;
            }
        }
    }
    if ( propChanged ) {
        *ppbOutValue = pValueStruct->rgb;
        *pcbOutValueSize = pValueStruct->cbLength;
    }

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetBinaryProperty


DWORD
WINAPI
ResUtilGetSzProperty(
    OUT LPWSTR * ppszOutValue,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a string property from a property list and advances the pointers.

Arguments:

    ppszOutValue - Supplies the address of a pointer in which to return a
        pointer to the string in the property list.

    pValueStruct - Supplies the string value from the property list.

    pszOldValue - Supplies the previous value for this property.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct) + ALIGN_CLUSPROP( pValueStruct->cbLength );
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_SZ) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_EXPAND_SZ) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If the value changed, point to the new value.
    // Do this even if only the case of the value changed.
    //
    if ( (pszOldValue == NULL) ||
         (lstrcmpW( pValueStruct->sz, pszOldValue ) != 0) ) {
        *ppszOutValue = pValueStruct->sz;
    }

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetSzProperty


DWORD
WINAPI
ResUtilGetMultiSzProperty(
    OUT LPWSTR * ppszOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a binary property from a property list and advances the pointers.

Arguments:

    ppszOutValue - Supplies the address of a pointer in which to return a
        pointer to the binary value in the property list.

    pcbOutValueSize - Supplies the address of the output value size.

    pValueStruct - Supplies the string value from the property list.

    pszOldValue - Supplies the previous value for this property.

    cbOldValueSize - Supplies the previous value's size.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    BOOL    propChanged = FALSE;
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct) + ALIGN_CLUSPROP( pValueStruct->cbLength );
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_MULTI_SZ) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If the value changed, point to the new value.
    //
    if ( (pszOldValue == NULL) ||
         (cbOldValueSize != pValueStruct->cbLength) ) {
        propChanged = TRUE;
    } else if ( memcmp( pValueStruct->sz, pszOldValue, cbOldValueSize ) != 0 ) {
        propChanged = TRUE;
    }
    if ( propChanged ) {
        *ppszOutValue = pValueStruct->sz;
        *pcbOutValueSize = pValueStruct->cbLength;
    }

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetMultiSzProperty


DWORD
WINAPI
ResUtilGetDwordProperty(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a DWORD property from a property list and advances the pointers.

Arguments:

    pdwOutValue - Supplies the address of a pointer in which to return a
        pointer to the string in the property list.

    pValueStruct - Supplies the DWORD value from the property list.

    dwOldValue - Supplies the previous value for thie property.

    dwMinimum - Minimum value the value can have. If both Minimum and Maximum
        are 0, no range check will be done.

    dwMaximum - Maximum value the value can have.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct);
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_DWORD) ||
         (pValueStruct->cbLength != sizeof(DWORD)) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Make sure the value is in range.
    //
    if ( (dwMinimum != 0) && (dwMaximum != 0) ) {
        if ( (pValueStruct->dw < dwMinimum) ||
             (pValueStruct->dw > dwMaximum) ) {
            return(ERROR_INVALID_PARAMETER);
        }
    }

    //
    // Set to the new value.
    //
    *pdwOutValue = pValueStruct->dw;

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetDwordProperty


LPVOID
WINAPI
ResUtilGetEnvironmentWithNetName(
    IN HRESOURCE hResource
    )
/*++

Routine Description:

    Creates an environment block based on the current environment
    block, but with the addition of a _CLUSTER_NETWORK_NAME=xxx
    environment value. xxx in this case represents the network
    name of the supplied resource. This environment block is suitable
    for passing to CreateProcess to create an environment that will
    cause GetComputerName to lie to the application.

    _CLUSTER_NETWORK_FQDN_ will return a fully qualified DNS name.

Arguments:

    hResource - Supplies the resource

Return Value:

    pointer to the environment block if successful.

    NULL otherwise

--*/

{
    PVOID           pvEnvironment = NULL;
    DWORD           dwStatus;
    NTSTATUS        ntStatus;
    BOOL            fSuccess;
    LPWSTR          pszNetworkName = NULL;
    DWORD           cchNetworkName;
    DWORD           cchAllocSize;
    DWORD           cchDomain;
    UNICODE_STRING  usValueName;
    UNICODE_STRING  usValue;
    HANDLE          hProcessToken = NULL;

    //
    // First find out the network name
    //
    cchNetworkName = 256;
    cchAllocSize = cchNetworkName;
    pszNetworkName = LocalAlloc( LMEM_FIXED, cchAllocSize * sizeof( pszNetworkName[ 0 ] ) );
    if ( pszNetworkName == NULL )
    {
        dwStatus = E_OUTOFMEMORY;
        goto Cleanup;
    }
    fSuccess = GetClusterResourceNetworkName(
                    hResource,
                    pszNetworkName,
                    &cchNetworkName
                    );
    if ( ! fSuccess )
    {
        dwStatus = GetLastError();
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pszNetworkName );
            cchNetworkName++;
            cchNetworkName *= 2;
            cchAllocSize = cchNetworkName;
            pszNetworkName = LocalAlloc( LMEM_FIXED, cchAllocSize * sizeof( pszNetworkName[ 0 ] ) );
            if ( pszNetworkName == NULL )
            {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            fSuccess = GetClusterResourceNetworkName(
                            hResource,
                            pszNetworkName,
                            &cchNetworkName
                            );
        }
        if ( ! fSuccess )
        {
            dwStatus = GetLastError();
            goto Cleanup;
        }
    }

    RtlInitUnicodeString( &usValueName, L"_CLUSTER_NETWORK_NAME_" );
    RtlInitUnicodeString( &usValue, pszNetworkName );

    //
    // get the current process token. If it fails, we revert to using just the
    // system environment area
    //
    OpenProcessToken( GetCurrentProcess(), MAXIMUM_ALLOWED, &hProcessToken );

    //
    // Clone the current environment, picking up any changes that might have
    // been made after resmon started
    //
    fSuccess = CreateEnvironmentBlock( &pvEnvironment, hProcessToken, FALSE );

    if ( ! fSuccess )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Add the new value to the cloned environment
    //
    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvironment,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        dwStatus = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

    //
    // add in the DNS hostname
    //
    RtlInitUnicodeString( &usValueName, L"_CLUSTER_NETWORK_HOSTNAME_" );
    RtlInitUnicodeString( &usValue, pszNetworkName );

    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvironment,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        dwStatus = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

    //
    // Change the COMPUTERNAME environment variable to match.
    //
    RtlInitUnicodeString( &usValueName, L"COMPUTERNAME" );
    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvironment,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        dwStatus = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

    //
    // Now generate the string for the FQDN
    //
    RtlInitUnicodeString( &usValueName, L"_CLUSTER_NETWORK_FQDN_" );

    pszNetworkName[ cchNetworkName ] = L'.';
    cchDomain = cchAllocSize - cchNetworkName - 1;

    if ( GetComputerNameExW(
                ComputerNameDnsDomain,
                &pszNetworkName[ cchNetworkName + 1 ],
                &cchDomain )
                )
    {
        if ( cchDomain == 0 )
        {
            pszNetworkName[ cchNetworkName ] = L'\0';
        }
    }
    else
    {
        //
        // Error from trying to get the DNS Domain name.
        // Just don't set the DnsDomain name!
        //
        goto Cleanup;
    }

    RtlInitUnicodeString( &usValue, pszNetworkName );

    //
    // Add in the FQDN name
    //
    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvironment,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        dwStatus = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

Cleanup:
    if ( hProcessToken != NULL )
    {
        CloseHandle( hProcessToken );
    }

    if ( pszNetworkName != NULL )
    {
        LocalFree( pszNetworkName );
    }

    SetLastError( dwStatus );
    return pvEnvironment;

Error:
    if ( pvEnvironment != NULL )
    {
        RtlDestroyEnvironment( pvEnvironment );
        pvEnvironment = NULL;
    }
    goto Cleanup;

} // ResUtilGetEnvironmentWithNetName


//***************************************************************************
//
//     Worker thread routines
//
//***************************************************************************


DWORD
WINAPI
ClusWorkerStart(
    IN PWORK_CONTEXT pContext
    )
/*++

Routine Description:

    Wrapper routine for cluster resource worker startup

Arguments:

    Context - Supplies the context block. This will be freed.

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD Status;
    WORK_CONTEXT Context;

    //
    // Capture our parameters and free the work context.
    //
    Context = *pContext;
    LocalFree(pContext);

    //
    // Call the worker routine
    //
    Status = (Context.lpStartRoutine)(Context.Worker, Context.lpParameter);

    //
    // Synchronize and clean up properly.
    //
    EnterCriticalSection(&ResUtilWorkerLock);
    if (!Context.Worker->Terminate) {
        CloseHandle(Context.Worker->hThread);
        Context.Worker->hThread = NULL;
    }
    Context.Worker->Terminate = TRUE;
    LeaveCriticalSection(&ResUtilWorkerLock);

    return(Status);

} // ClusWorkerStart

DWORD
WINAPI
ClusWorkerCreate(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    )
/*++

Routine Description:

    Common wrapper for resource DLL worker threads. Provides
    "clean" terminate semantics

Arguments:

    lpWorker - Returns an initialized worker structure

    lpStartAddress - Supplies the worker thread routine

    lpParameter - Supplies the parameter to be passed to the
        worker thread routine

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PWORK_CONTEXT Context;
    DWORD ThreadId;
    DWORD Status;

    Context = LocalAlloc(LMEM_FIXED, sizeof(WORK_CONTEXT));
    if (Context == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Context->Worker = lpWorker;
    Context->lpParameter = lpParameter;
    Context->lpStartRoutine = lpStartAddress;

    lpWorker->Terminate = FALSE;
    lpWorker->hThread = CreateThread(NULL,
                                   0,
                                   ClusWorkerStart,
                                   Context,
                                   0,
                                   &ThreadId);
    if (lpWorker->hThread == NULL) {
        Status = GetLastError();
        LocalFree(Context);
        return(Status);
    }
    return(ERROR_SUCCESS);

} // ClusWorkerCreate


BOOL
WINAPI
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER lpWorker
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit ASAP.

Arguments:

    lpWorker - Supplies the worker

Return Value:

    TRUE if the thread should exit.

    FALSE otherwise

--*/

{
    return(lpWorker->Terminate);

} // ClusWorkerCheckTerminate


VOID
WINAPI
ClusWorkerTerminate(
    IN PCLUS_WORKER lpWorker
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit ASAP.

Arguments:

    lpWorker - Supplies the worker

Return Value:

    None.

--*/

{
    //
    // N.B.  There is a race condition here if multiple threads
    //       call this routine on the same worker. The first one
    //       through will set Terminate. The second one will see
    //       that Terminate is set and return immediately without
    //       waiting for the Worker to exit. Not really any nice
    //       way to fix this without adding another synchronization
    //       object.
    //

    if ((lpWorker->hThread == NULL) ||
        (lpWorker->Terminate)) {
        return;
    }
    EnterCriticalSection(&ResUtilWorkerLock);
    if (!lpWorker->Terminate) {
        lpWorker->Terminate = TRUE;
        LeaveCriticalSection(&ResUtilWorkerLock);
        WaitForSingleObject(lpWorker->hThread, INFINITE);
        CloseHandle(lpWorker->hThread);
        lpWorker->hThread = NULL;
    } else {
        LeaveCriticalSection(&ResUtilWorkerLock);
    }
    return;

} // ClusWorkerTerminate


DWORD
WINAPI
ResUtilCreateDirectoryTree(
    IN LPCWSTR pszPath
    )

/*++

Routine Description:

    Creates all the directories in the specified path.
    ERROR_ALREADY_EXISTS will never be returned by this routine.

Arguments:

    pszPath - String containing a path.

Return Value:

    ERROR_SUCCESS - The operation completed successfully

    Win32 error code - The operation failed.

--*/

{
    return( ClRtlCreateDirectory( pszPath ) );

} // ResUtilCreateDirectoryTree


BOOL
WINAPI
ResUtilIsPathValid(
    IN LPCWSTR pszPath
    )

/*++

Routine Description:

    Returns true if the given path looks syntactically valid.

    This call is NOT network-aware.

Arguments:

    pszPath - String containing a path.

Return Value:

    TRUE if the path looks valid, otherwise FALSE.

--*/

{
    return( ClRtlIsPathValid( pszPath ) );

} // ResUtilIsPathValid


DWORD
WINAPI
ResUtilFreeEnvironment(
    IN LPVOID lpEnvironment
    )

/*++

Routine Description:

    Destroys an environment variable block.

Arguments:

    Environment - the environment variable block to destroy.

Return Value:

    A Win32 error code.

--*/

{
    NTSTATUS  ntStatus;

    ntStatus = RtlDestroyEnvironment( lpEnvironment );

    return( RtlNtStatusToDosError(ntStatus) );

} // ResUtilFreeEnvironment


LPWSTR
WINAPI
ResUtilExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    )

/*++

Routine Description:

    Expands environment strings and returns an allocated buffer containing
    the result.

Arguments:

    pszSrc - Source string to expand.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    return( ClRtlExpandEnvironmentStrings( pszSrc ) );

} // ResUtilExpandEnvironmentStrings


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilSetResourceServiceEnvironment
//
//  Description:
//      Set the environment for the specified service.
//
//  Arguments:
//      pszServiceName [IN]
//          Name of service whose environment is to be set.
//
//      hResource [IN]
//          Handle to resource.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilSetResourceServiceEnvironment(
    IN  LPCWSTR             pszServiceName,
    IN  HRESOURCE           hResource,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD       nStatus;
    DWORD       cbEnvironment;
    PVOID       pvEnvironment = NULL;
    LPWSTR      pszEnvString;
    HKEY        hkeyServicesKey;
    HKEY        hkeyServiceName;

    do
    {
        //
        // Create the new environment with the simulated net name when the
        // service queries GetComputerName.
        //
        pvEnvironment = ResUtilGetEnvironmentWithNetName( hResource );
        if ( pvEnvironment == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if:  error getting environment

        //
        // Compute the size of the environment. We are looking for
        // the double NULL terminator that ends the environment block.
        //
        pszEnvString = (LPWSTR) pvEnvironment;
        while ( *pszEnvString != L'\0' )
        {
            while ( *pszEnvString++ != L'\0')
            {
            } // while: more characters in this environment string
        } // while: more environment strings
        cbEnvironment = (DWORD)((PUCHAR)pszEnvString - (PUCHAR)pvEnvironment) + sizeof( WCHAR );

        //
        // Open the Services key in the registry.
        //
        nStatus = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Services",
                        0,
                        KEY_READ,
                        &hkeyServicesKey
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceEnvironment: Failed to open services key, error = %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the Services key in the registry

        //
        // Open the service name key in the registry
        //
        nStatus = RegOpenKeyExW(
                        hkeyServicesKey,
                        pszServiceName,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyServiceName
                        );
        RegCloseKey( hkeyServicesKey );
        if ( nStatus != ERROR_SUCCESS )
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceEnvironment: Failed to open service key, error = %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the service name key in the registry

        //
        // Set the environment value in the service's registry key.
        //
        nStatus = RegSetValueExW(
                        hkeyServiceName,
                        L"Environment",
                        0,
                        REG_MULTI_SZ,
                        (const UCHAR *) pvEnvironment,
                        cbEnvironment
                        );
        RegCloseKey( hkeyServiceName );
        if ( nStatus != ERROR_SUCCESS )
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceEnvironment: Failed to set service environment value, error = %1!u!.\n",
                nStatus
                );
            break;
        } // if: error setting the Environment value in the registry
    } while ( 0 );

    if ( pvEnvironment != NULL )
    {
        ResUtilFreeEnvironment( pvEnvironment );
    } // if: environment block allocated

    return nStatus;

} //*** ResUtilSetResourceServiceEnvironment()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilSetResourceServiceStartParameters
//
//  Description:
//      Set the start parameters for the specified service.
//
//  Arguments:
//      pszServiceName [IN]
//          Name of service whose start parameters are to be set.
//
//      schSCMHandle [IN]
//          Handle to the Service Control Manager.  Can be specified as NULL.
//
//      phService [OUT]
//          Service handle.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilSetResourceServiceStartParameters(
    IN      LPCWSTR             pszServiceName,
    IN      SC_HANDLE           schSCMHandle,
    IN OUT  LPSC_HANDLE         phService,
    IN      PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN      RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD                       nStatus;
    DWORD                       cbBytesNeeded;
    DWORD                       cbQueryServiceConfig;
    DWORD                       idx;
    BOOL                        bWeOpenedSCM = FALSE;
    LPQUERY_SERVICE_CONFIG      pQueryServiceConfig = NULL;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;

    do
    {
        //
        // Open the Service Control Manager if necessary.
        //
        if ( schSCMHandle == NULL )
        {
            schSCMHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
            if ( schSCMHandle == NULL )
            {
                nStatus = GetLastError();
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ResUtilSetResourceServiceStartParameters: Failed to open Service Control Manager. Error: %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the Service Control Manager
            bWeOpenedSCM = TRUE;
        } // if: Service Control Manager not open yet

        //
        // Open the service.
        //
        *phService = OpenService(
                            schSCMHandle,
                            pszServiceName,
                            SERVICE_ALL_ACCESS
                            );
        if ( *phService == NULL )
        {
            nStatus = GetLastError();
            // TODO: Log event to the event log.
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to open the '%1' service. Error: %2!u!.\n",
                pszServiceName,
                nStatus
                );
            break;
        } // if: error opening the service

        //
        // Query the service to make sure it is not disabled.
        //
        cbQueryServiceConfig = sizeof( QUERY_SERVICE_CONFIG );
        do
        {
            //
            // Allocate memory for the config info structure.
            //
            pQueryServiceConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LMEM_FIXED, cbQueryServiceConfig );
            if ( pQueryServiceConfig == NULL )
            {
                nStatus = GetLastError();
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ResUtilSetResourceServiceStartParameters: Failed to allocate memory for query_service_config. Error: %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error allocating memory

            //
            // Query for the config info.  If it fails because the buffer
            // is too small, reallocate and try again.
            //
            if ( ! QueryServiceConfig(
                            *phService,
                            pQueryServiceConfig,
                            cbQueryServiceConfig,
                            &cbBytesNeeded
                            ) )
            {
                nStatus = GetLastError();
                if ( nStatus != ERROR_INSUFFICIENT_BUFFER )
                {
                    (pfnLogEvent)(
                        hResourceHandle,
                        LOG_ERROR,
                        L"ResUtilSetResourceServiceStartParameters: Failed to query service configuration for the '%1' service. Error: %2!u!.\n",
                        pszServiceName,
                        nStatus
                        );
                    break;
                }

                nStatus = ERROR_SUCCESS;
                LocalFree( pQueryServiceConfig );
                pQueryServiceConfig = NULL;
                cbQueryServiceConfig = cbBytesNeeded;
                continue;
            } // if: error querying for service config info
            else
            {
                nStatus = ERROR_SUCCESS;
                cbBytesNeeded = 0;
            } // else: query was successful

            //
            // Check to see if the service is disabled or not.
            //
            if ( pQueryServiceConfig->dwStartType == SERVICE_DISABLED )
            {
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ResUtilSetResourceServiceStartParameters: The service '%1' is DISABLED.\n",
                    pszServiceName
                    );
                nStatus = ERROR_SERVICE_DISABLED;
                break;
            } // if: service is disabled
        } while ( cbBytesNeeded != 0 );

        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error occurred checking to see if service is disabled

        //
        // Set the service to manual start.
        //
        if ( ! ChangeServiceConfig(
                    *phService,
                    SERVICE_NO_CHANGE,
                    SERVICE_DEMAND_START, // Manual start
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    ) )
        {
            nStatus = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to set service '%1' to manual start. Error: %2!u!.\n",
                pszServiceName,
                nStatus
                );
            break;
        } // if: error setting service to manual start

        //
        // Query for the size of the service failure actions array.
        // Use nStatus as the dummy buffer since the QueryServiceConfig2 API
        // is not that friendly.
        //
        if ( ! QueryServiceConfig2(
                        *phService,
                        SERVICE_CONFIG_FAILURE_ACTIONS,
                        (LPBYTE) &nStatus,
                        sizeof( DWORD ),
                        &cbBytesNeeded
                        ) )
        {
            nStatus = GetLastError();
            if ( nStatus == ERROR_INSUFFICIENT_BUFFER )
            {
                nStatus = ERROR_SUCCESS;
            } // if: expected "buffer too small" error occurred
            else
            {
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ResUtilSetResourceServiceStartParameters: Failed to query service configuration for size for the '%1' service. Error: %2!u!.\n",
                    pszServiceName,
                    nStatus
                    );
                break;
            } // else: an unexpected error occurred
        } // if: error querying for service failure actions buffer size

        //
        // Allocate memory for the service failure actions array.
        //
        pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS) LocalAlloc( LMEM_FIXED, cbBytesNeeded );
        if ( pSvcFailureActions == NULL )
        {
            nStatus = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to allocate memory of size %1!u!. Error: %2!u!.\n",
                cbBytesNeeded,
                nStatus
                );
            break;
        } // if: error allocating memory for the service failure actions array

        //
        // Query for the service failure actions array.
        //
        if ( ! QueryServiceConfig2(
                        *phService,
                        SERVICE_CONFIG_FAILURE_ACTIONS,
                        (LPBYTE) pSvcFailureActions,
                        cbBytesNeeded,
                        &cbBytesNeeded
                        ) )
        {
            nStatus = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to query service configuration for the '%1' service. Error: %2!u!.\n",
                pszServiceName,
                nStatus
                );
            break;
        } // if: error querying for service failure actions

        //
        // If any of the service action is set to service restart,
        // set it to  none.
        //
        for ( idx = 0 ; idx < pSvcFailureActions->cActions ; idx++ )
        {
            if ( pSvcFailureActions->lpsaActions[ idx ].Type == SC_ACTION_RESTART )
            {
                pSvcFailureActions->lpsaActions[ idx ].Type = SC_ACTION_NONE;
            } // if: action set to restart
        } // for: each service failure action array entry

        //
        // Set the changes to the service failure actions array.
        //
        if ( ! ChangeServiceConfig2(
                *phService,
                SERVICE_CONFIG_FAILURE_ACTIONS,
                pSvcFailureActions
                ) )
        {
            nStatus = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to set service failure actions for the '%1' service. Error: %2!u!.\n",
                pszServiceName,
                nStatus
                );
            break;
        } // if: error saving service failure actions

    } while ( 0 );

    //
    // Cleanup.
    //
    LocalFree( pQueryServiceConfig );
    LocalFree( pSvcFailureActions );
    if ( bWeOpenedSCM )
    {
        CloseServiceHandle( schSCMHandle );
    } // if: we opened the Server Control Manager
    if ( ( nStatus != ERROR_SUCCESS ) && ( *phService != NULL ) )
    {
        CloseServiceHandle( *phService );
        *phService = NULL;
    } // if: error occurred after opening service

    return nStatus;

} //*** ResUtilSetResourceServiceStartParameters()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilGetResourceDependentIPAddressProps
//
//  Description:
//      Get the properties from the first IP Address resource on which the
//      specified resource is dependent.
//
//  Arguments:
//      hResource [IN]
//          Handle to the resource to query.
//
//      pszAddress [OUT]
//          Output buffer for returning the address.
//
//      pcchAddress [IN OUT]
//          On input contains the size in characters of the pszAddress buffer.
//          On output contains the size in characters, including the terminating
//          NULL, of the string for the Address property.  If pszAddress is
//          specified as NULL and this is not specified as NULL, ERROR_SUCCESS
//          be returned.  Otherwise, ERROR_MORE_DATA will be returned.
//
//      pszSubnetMask [OUT]
//          Output buffer for returning the subnet mask.
//
//      pcchSubnetMask [IN OUT]
//          On input contains the size in characters of the pszSubnetMask buffer.
//          On output contains the size in characters, including the terminating
//          NULL, of the string for the SubnetMask property.  If pszSubnetMask is
//          specified as NULL and this is not specified as NULL, ERROR_SUCCESS
//          be returned.  Otherwise, ERROR_MORE_DATA will be returned.
//
//      pszNetwork [OUT]
//          Output buffer for returning the network.
//
//      pcchNetwork [IN OUT]
//          On input contains the size in characters of the pszNetwork buffer.
//          On output contains the size in characters, including the terminating
//          NULL, of the string for the Network property.  If pszNetwork is
//          specified as NULL and this is not specified as NULL, ERROR_SUCCESS
//          be returned.  Otherwise, ERROR_MORE_DATA will be returned.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The size of one of the buffers was too small.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilGetResourceDependentIPAddressProps(
    IN      HRESOURCE   hResource,
    OUT     LPWSTR      pszAddress,
    IN OUT  DWORD *     pcchAddress,
    OUT     LPWSTR      pszSubnetMask,
    IN OUT  DWORD *     pcchSubnetMask,
    OUT     LPWSTR      pszNetwork,
    IN OUT  DWORD *     pcchNetwork
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    HRESENUM    hresenum = NULL;
    HRESOURCE   hresDep = NULL;
    DWORD       idx;
    DWORD       nType;
    DWORD       cchmacName;
    DWORD       cchName;
    LPWSTR      pszName = NULL;
    DWORD       cbProps;
    PBYTE       pbProps = NULL;
    LPWSTR      pszProp;
    DWORD       cchProp;
    HCLUSTER    hCluster;

    do
    {
        //
        // Enumerate dependent resources.
        //
        hresenum = ClusterResourceOpenEnum( hResource, CLUSTER_RESOURCE_ENUM_DEPENDS );
        if ( hresenum == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if: error opening the enumeration

        //
        // Allocate the initial name buffer.
        //
        cchmacName = 256;
        cchName = cchmacName;
        pszName = (LPWSTR) LocalAlloc( LMEM_FIXED, cchName * sizeof( pszName[ 0 ] ) );
        if ( pszName == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if: error allocating resource name buffer

        for ( idx = 0 ; ; idx++ )
        {
            //
            // Get the first entry in the enumeration.
            //
            nStatus = ClusterResourceEnum(
                            hresenum,
                            idx,
                            &nType,
                            pszName,
                            &cchName
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                LocalFree( pszName );
                cchName++;
                cchmacName = cchName;
                pszName = (LPWSTR) LocalAlloc( LMEM_FIXED, cchName * sizeof( pszName[ 0 ] ) );
                if ( pszName == NULL )
                {
                    nStatus = GetLastError();
                    break;
                } // if: error allocating resource name buffer
                nStatus = ClusterResourceEnum(
                                hresenum,
                                idx,
                                &nType,
                                pszName,
                                &cchName
                                );
            } // if: buffer is too small
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if: error getting the dependent resource name

            //
            // Open the resource.
            //
            hCluster = GetClusterFromResource( hResource );
            if ( hCluster == NULL )  {
                nStatus = GetLastError();
                break;
            }

            hresDep = OpenClusterResource( hCluster, pszName );
            if ( hresDep == NULL )
            {
                nStatus = GetLastError();
                break;
            } // if: error opening the dependent resource

            //
            // Get the resource type name.
            //
            cchName = cchmacName;
            nStatus = ClusterResourceControl(
                            hresDep,
                            NULL,
                            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                            NULL,
                            0,
                            pszName,
                            cchmacName,
                            &cchName
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                LocalFree( pszName );
                cchName++;
                cchmacName = cchName;
                pszName = (LPWSTR) LocalAlloc( LMEM_FIXED, cchName * sizeof( pszName[ 0 ] ) );
                if ( pszName == NULL )
                {
                    nStatus = GetLastError();
                    break;
                } // if: error allocating resource type name buffer
                nStatus = ClusterResourceControl(
                                hresDep,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                pszName,
                                cchmacName,
                                &cchName
                                );
            } // if: buffer was too small
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if: error getting resource type name

            if ( lstrcmpiW( pszName, L"IP Address" ) == 0 )
            {
                //
                // Get the private properties of the dependent resource.
                //
                cbProps = 1024;
                pbProps = (PBYTE) LocalAlloc( LMEM_FIXED, cbProps );
                if ( pbProps == NULL )
                {
                    nStatus = GetLastError();
                    break;
                } // if: error allocating buffer for properties
                nStatus = ClusterResourceControl(
                                    hresDep,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                                    NULL,
                                    0,
                                    pbProps,
                                    cbProps,
                                    &cbProps
                                    );
                if ( nStatus == ERROR_MORE_DATA )
                {
                    LocalFree( pbProps );
                    pbProps = (PBYTE) LocalAlloc( LMEM_FIXED, cbProps );
                    if ( pbProps == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating buffer for properties
                    nStatus = ClusterResourceControl(
                                        hresDep,
                                        NULL,
                                        CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                                        NULL,
                                        0,
                                        pbProps,
                                        cbProps,
                                        &cbProps
                                        );
                } // if: properties buffer too small
                if ( nStatus != ERROR_SUCCESS )
                {
                    break;
                } // if: error getting private properties

                //
                // Return the address.
                //
                if (    ( pszAddress != NULL )
                    ||  ( pcchAddress != NULL )
                    )
                {
                    nStatus = ResUtilFindSzProperty(
                                        pbProps,
                                        cbProps,
                                        L"Address",
                                        &pszProp
                                        );
                    if ( nStatus != ERROR_SUCCESS )
                    {
                        break;
                    } // if: error finding the property
                    cchProp = lstrlenW( pszProp ) + 1;
                    if ( cchProp > *pcchAddress )
                    {
                        if ( pszAddress == NULL )
                        {
                            nStatus = ERROR_SUCCESS;
                        } // if: no buffer was specified
                        else
                        {
                            nStatus = ERROR_MORE_DATA;
                        } // else: buffer was specified but was too small
                        *pcchAddress = cchProp;
                        break;
                    } // if: buffer is too small
                    lstrcpyW( pszAddress, pszProp );
                    *pcchAddress = cchProp;
                } // if: address requested by caller

                //
                // Return the subnet mask.
                //
                if (    ( pszSubnetMask != NULL )
                    ||  ( pcchSubnetMask != NULL )
                    )
                {
                    nStatus = ResUtilFindSzProperty(
                                        pbProps,
                                        cbProps,
                                        L"SubnetMask",
                                        &pszProp
                                        );
                    if ( nStatus != ERROR_SUCCESS )
                    {
                        break;
                    } // if: error finding the property
                    cchProp = lstrlenW( pszProp ) + 1;
                    if ( cchProp > *pcchSubnetMask )
                    {
                        if ( pszSubnetMask == NULL )
                        {
                            nStatus = ERROR_SUCCESS;
                        } // if: no buffer was specified
                        else
                        {
                            nStatus = ERROR_MORE_DATA;
                        } // else: buffer was specified but was too small
                        *pcchSubnetMask = cchProp;
                        break;
                    } // if: buffer is too small
                    lstrcpyW( pszSubnetMask, pszProp );
                    *pcchSubnetMask = cchProp;
                } // if: subnet mask requested by caller

                //
                // Return the network.
                //
                if (    ( pszNetwork != NULL )
                    ||  ( pcchNetwork != NULL )
                    )
                {
                    nStatus = ResUtilFindSzProperty(
                                        pbProps,
                                        cbProps,
                                        L"Network",
                                        &pszProp
                                        );
                    if ( nStatus != ERROR_SUCCESS )
                    {
                        break;
                    } // if: error finding the property
                    cchProp = lstrlenW( pszProp ) + 1;
                    if ( cchProp > *pcchNetwork )
                    {
                        if ( pszNetwork == NULL )
                        {
                            nStatus = ERROR_SUCCESS;
                        } // if: no buffer was specified
                        else
                        {
                            nStatus = ERROR_MORE_DATA;
                        } // else: buffer was specified but was too small
                        *pcchNetwork = cchProp;
                        break;
                    } // if: buffer is too small
                    lstrcpyW( pszNetwork, pszProp );
                    *pcchNetwork = cchProp;
                } // if: network requested by caller

                //
                // Exit the loop since we found a match.
                //
                break;
            } // if: IP Address resource found

            //
            // Close the dependent resource.
            //
            CloseClusterResource( hresDep );
            hresDep = NULL;

        } // for: each dependency
    } while ( 0 );

    //
    // Cleanup.
    //
    LocalFree( pszName );
    LocalFree( pbProps );
    if ( hresenum != NULL )
    {
        ClusterResourceCloseEnum( hresenum );
    } // if: we opened the enumerator
    if ( hresDep != NULL )
    {
        CloseClusterResource( hresDep );
    } // if: opened dependent resource

    return nStatus;

} //*** ResUtilGetResourceDependentIPAddressProps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilFindDependentDiskResourceDriveLetter
//
//  Description:
//      Finds a disk resource in the dependent resources and retrieves the
//      the drive letter associated with it.
//
//  Arguments:
//      hCluster [IN]
//          Handle to the cluster.
//
//      hResource [IN]
//          Handle to the resource to query for dependencies.
//
//      pszDriveLetter [IN/RETVAL]
//          The drive letter of a dependent disk resource that was found.
//          If a resource is not found, this value is untouched.
//
//      pcchDriverLetter [IN/OUT]
//          [IN] The number of characters that pszDriverLetter points to.
//          [OUT] The number of characters written to the buffer
//          (including NULL). If ERROR_MORE_DATA is returned, this value
//          is the size of the buffer required to store the value.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully and the drive letter was
//          set.
//
//      ERROR_NO_MORE_ITEMS
//      ERROR_RESOURCE_NOT_PRESENT
//          A dependent disk resource was not found or the resource is
//          not dependent on a disk resource.
//
//      ERROR_MORE_DATA
//          The buffer passed in is too small. pcchDriveLetter will
//          contain the size of the buffer (WCHARs) needed to fulfill
//          the request.
//
//      Win32 error code
//          Other possible failures.
//
//  SPECIAL NOTE:
//      Do _NOT_ call this from a Resource DLL. It will cause a deadlock.
//      You should have your Resource Extension call this function and
//      write the results out as a private property that your Resource
//      DLL can then read.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilFindDependentDiskResourceDriveLetter(
    IN     HCLUSTER  hCluster,             // handle to cluster
    IN     HRESOURCE hResource,            // handle to resource to query for dependencies
    IN     LPWSTR    pszDriveLetter,       // buffer to store drive letter (ex. "X:")
    IN OUT DWORD *   pcchDriveLetter       // IN size of the pszDriveLetter buffer, OUT size of buffer required
    )
{
    BOOL     fFoundDriveLetter  = FALSE;
    DWORD    status             = ERROR_SUCCESS;
    HRESENUM hresenum;
    DWORD    cchName;
    DWORD    dwRetType;
    WCHAR    szName[ MAX_PATH ];
    INT      iCount;

    // validate arguments
    if ( !pszDriveLetter
      || !pcchDriveLetter )
    {
        return ERROR_INVALID_PARAMETER;
    }

    hresenum = ClusterResourceOpenEnum( hResource, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hresenum != NULL )
    {
        // Scan the dependencies until we find a disk resource or we hit
        // the end of the dependency list.
        for( iCount = 0 ; ! fFoundDriveLetter && ( status == ERROR_SUCCESS ) ; iCount++ )
        {
            cchName = sizeof(szName) / sizeof(szName[0]);
            status = ClusterResourceEnum( hresenum, iCount, &dwRetType, szName, &cchName );
            if ( status == ERROR_SUCCESS )
            {
                HRESOURCE hRes;

                // Interrogate the resource to see if it is a disk resource.
                hRes = OpenClusterResource( hCluster, szName );
                if ( hRes != NULL )
                {
                    DWORD cbDiskInfo = sizeof(CLUSPROP_DWORD)
                                       + sizeof(CLUSPROP_SCSI_ADDRESS)
                                       + sizeof(CLUSPROP_DISK_NUMBER)
                                       + sizeof(CLUSPROP_PARTITION_INFO)
                                       + sizeof(CLUSPROP_SYNTAX);
                    PBYTE pDiskInfo = (PBYTE) LocalAlloc( LMEM_FIXED, cbDiskInfo );
                    if ( !pDiskInfo )
                    {
                        status = ERROR_OUTOFMEMORY;
                        break;
                    } // if: !pDiskInfo

                    status = ClusterResourceControl( hRes,
                                                     NULL,
                                                     CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                                     NULL,
                                                     0,
                                                     pDiskInfo,
                                                     cbDiskInfo,
                                                     &cbDiskInfo
                                                     );
                    if ( status == ERROR_MORE_DATA )
                    {
                        LocalFree( pDiskInfo );

                        // get a bigger block
                        pDiskInfo = (PBYTE) LocalAlloc( LMEM_FIXED, cbDiskInfo );
                        if ( !pDiskInfo )
                        {
                            status = ERROR_OUTOFMEMORY;
                            break;
                        } // if: !pDiskInfo

                        status = ClusterResourceControl( hRes,
                                                         NULL,
                                                         CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                                         NULL,
                                                         0,
                                                         pDiskInfo,
                                                         cbDiskInfo,
                                                         &cbDiskInfo
                                                         );
                    } // if: more data

                    if ( status == ERROR_SUCCESS )
                    {
                        DWORD                       dwValueSize;
                        CLUSPROP_BUFFER_HELPER      props;
                        PCLUSPROP_PARTITION_INFO    pPartitionInfo;

                        props.pb = pDiskInfo;

                        // Loop through each property.
                        while ( ! fFoundDriveLetter
                             && ( status == ERROR_SUCCESS )
                             && ( cbDiskInfo > sizeof(CLUSPROP_SYNTAX ) )
                             && ( props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) )
                        {
                            // Get the size of this value and verify there is enough buffer left.
                            dwValueSize = sizeof(*props.pValue) + ALIGN_CLUSPROP( props.pValue->cbLength );
                            if ( dwValueSize > cbDiskInfo )
                            {
                                break;
                            } // if: data is not valid

                            if ( props.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
                            {
                                // Validate the data.  There must be a device name.
                                pPartitionInfo = props.pPartitionInfoValue;
                                if ( ( dwValueSize != sizeof(*pPartitionInfo) )
                                  || ( pPartitionInfo->szDeviceName[0] == L'\0' ) )
                                {
                                    break;
                                } // if: data is not valid

                                // Make sure it fits
                                if ( wcslen( pPartitionInfo->szDeviceName ) < *pcchDriveLetter )
                                {
                                    wcscpy( pszDriveLetter, pPartitionInfo->szDeviceName );
                                    fFoundDriveLetter = TRUE;
                                } // if: drive letter fits into buffer
                                else
                                {
                                    status = ERROR_MORE_DATA;
                                } // else: does not fit into buffer

                                // set the size written and/or size needed
                                *pcchDriveLetter = wcslen( pPartitionInfo->szDeviceName ) + 1;

                            } // if props.pSyntax->dw

                            cbDiskInfo -= dwValueSize;
                            props.pb += dwValueSize;
                        } // while

                    } // if status
                    else if ( status == ERROR_INVALID_FUNCTION )
                    {
                        // Ignore resources that don't support the control
                        // code.  Only storage-class resources will support
                        // the control code.
                        status = ERROR_SUCCESS;
                    } // else if: resource doesn't support the control code

                    LocalFree( pDiskInfo );

                    CloseClusterResource( hRes );
                } // if hRes

            } // if status
            else if ( status == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if status

        } // for ( i )

        ClusterResourceCloseEnum( hresenum );

    } // if: opened hresenum
    else
    {
        status = GetLastError( );
    } // else: failed to open hresenum

    // Make sure if we did not find a disk resource that we don't
    // return ERROR_SUCCESS or ERROR_NO_MORE_ITEMS.
    if ( ! fFoundDriveLetter
      && ( ( status == ERROR_SUCCESS )
        || ( status == ERROR_NO_MORE_ITEMS ) ) )
    {
        status = ERROR_RESOURCE_NOT_PRESENT;
    } // if: sanity check

    return status;

} //*** ResUtilFindDependentDiskResourceDriveLetter()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsResourceOfType()
//
//  Description:
//      Is the resource of the type passed in?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The resource is of the type requested.
//
//      S_FALSE
//          The resource is not of the type requested.
//
//      Other HRESULT
//          Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScIsResourceOfType(
      HRESOURCE     hResIn
    , const WCHAR * pszResourceTypeIn
    , BOOL *        pbIsResourceOfTypeOut
    )
{
    DWORD       sc;
    WCHAR *     psz = NULL;
    DWORD       cbpsz = 33 * sizeof( WCHAR );
    DWORD       cb;
    int         idx;
    BOOL        bIsResourceOfTypeOut = FALSE;

    psz = (WCHAR *) LocalAlloc( LPTR, cbpsz );
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    for ( idx = 0; idx < 2; idx++ )
    {
        sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, NULL, 0, psz, cbpsz, &cb );
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( psz );
            psz = NULL;

            cbpsz = cb + 1;

            psz = (WCHAR *) LocalAlloc( LPTR, cbpsz );
            if ( psz == NULL )
            {
                goto OutOfMemory;
            } // if:

            continue;
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:

        break;
    } // for:

    bIsResourceOfTypeOut = ( wcscmp( psz, pszResourceTypeIn ) == 0 );

    if ( pbIsResourceOfTypeOut != NULL )
    {
        *pbIsResourceOfTypeOut = bIsResourceOfTypeOut;
    } // if:
    else
    {
        sc = ERROR_INVALID_PARAMETER;
    } // else

    goto Cleanup;

OutOfMemory:

    sc = ERROR_NOT_ENOUGH_MEMORY;

Cleanup:

    LocalFree( psz );

    return sc;

} //*** ScIsResourceOfType()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsCoreResource()
//
//  Description:
//      Is the passed in resource a core resource?
//
//  Arguments:
//
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation succeeded.
//
//      Other Win32 error
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScIsCoreResource(
      HRESOURCE hResIn
    , BOOL *    pfIsCoreResourceOut
    )
{
    DWORD   sc;
    DWORD   dwFlags = 0;
    DWORD   cb;
    BOOL    fIsCoreResource = FALSE;

    sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_FLAGS, NULL, 0, &dwFlags, sizeof( dwFlags ), &cb );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    fIsCoreResource = ( dwFlags & CLUS_FLAG_CORE );

    if ( pfIsCoreResourceOut != NULL )
    {
        *pfIsCoreResourceOut = fIsCoreResource;
    } // if:
    else
    {
        sc = ERROR_INVALID_PARAMETER;
    } // else

Cleanup:

    return sc;

} //*** ScIsCoreResource()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsQuorumCapableResource()
//
//  Description:
//      Is the passed in resource quorum capable?
//
//  Arguments:
//      hResIn
//          The resource to check for quorum capability.
//
//      pfIsQuorumCapableResource
//          True if the resource is quorum capable, false if it is not.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation succeeded.
//
//      Other Win32 error
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScIsQuorumCapableResource(
      HRESOURCE hResIn
    , BOOL *    pfIsQuorumCapableResource
    )
{
    DWORD   sc;
    DWORD   cb;
    DWORD   dwFlags = 0;

    if ( hResIn == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    if ( pfIsQuorumCapableResource == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_CHARACTERISTICS, NULL, 0, &dwFlags, sizeof( dwFlags ), &cb );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    *pfIsQuorumCapableResource = ( dwFlags & CLUS_CHAR_QUORUM );

Cleanup:

    return sc;

} //*** ScIsQuorumCapableResource()


static WCHAR * g_pszCoreResourceTypes[] =
{
    L"Network Name",
    L"IP Address",
    L"\0"
};

#define CLUSTER_NAME        0
#define CLUSTER_IP_ADDRESS  1

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilGetCoreClusterResources()
//
//  Description:
//      Find the core cluster resources.
//
//  Arguments:
//      hClusterIn
//          The cluster whose core resource are sought.
//
//      phClusterNameResourceOut
//          The resource handle of the cluster name resource.
//
//      phClusterIPAddressResourceOut
//          The resource handle of the cluster IP address resource.
//
//      phClusterQuorumResourceOut
//          The resource handle of the cluster quorum resource.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
ResUtilGetCoreClusterResources(
      HCLUSTER      hClusterIn
    , HRESOURCE *   phClusterNameResourceOut
    , HRESOURCE *   phClusterIPAddressResourceOut
    , HRESOURCE *   phClusterQuorumResourceOut
    )
{
    DWORD       sc;
    HCLUSENUM   hEnum = NULL;
    DWORD       idxResource;
    DWORD       idx;
    DWORD       dwType;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    DWORD       cch;
    HRESOURCE   hRes = NULL;
    BOOL        fIsCoreResource = FALSE;
    BOOL        fIsResourceOfType = FALSE;
    BOOL        fCloseResource = FALSE;
    BOOL        fIsQuorumCapableResource = FALSE;

    if ( hClusterIn == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    hEnum = ClusterOpenEnum( hClusterIn, CLUSTER_ENUM_RESOURCE );
    if ( hEnum == NULL )
    {
        sc =  GetLastError();
        goto Cleanup;
    } // if:

    psz = (WCHAR *) LocalAlloc( LPTR, cchpsz * sizeof( WCHAR ) );
    if ( psz == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if:

    //
    //  KB: 10-JUL-2002 GalenB
    //
    //  Using cch in the ClusterEnum() call below because using cchpsz causes extra allocations.
    //  ClusterEnum() changes cch when the buffer is big enough to hold the data and returns
    //  ERROR_SUCCESS to be the size of the data that was just copied into the buffer.  Now
    //  cch no longer reflects the amount of memory allocated to psz...
    //

    for ( idxResource = 0; ; )
    {
        //
        //  Reset cch to the real size of the buffer to avoid extra allocations...
        //

        cch = cchpsz;

        sc = ClusterEnum( hEnum, idxResource, &dwType, psz, &cch );
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( psz );
            psz = NULL;

            cch++;          // need space for the NULL...
            cchpsz = cch;

            psz = (WCHAR *) LocalAlloc( LPTR, cchpsz * sizeof( WCHAR ) );
            if ( psz == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            } // if:

            sc = ClusterEnum( hEnum, idxResource, &dwType, psz, &cch );
        } // if: sc == ERROR_MORE_DATA

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = GetLastError();
                goto Cleanup;
            } // if:

            fCloseResource = TRUE;

            sc = ScIsCoreResource( hRes, &fIsCoreResource );
            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            } // if:

            //
            //  If the resource is not a core resource then close it and go around again.
            //

            if ( !fIsCoreResource )
            {
                CloseClusterResource( hRes );
                hRes = NULL;
                idxResource++;
                continue;
            } // if:

            sc = ScIsQuorumCapableResource( hRes, &fIsQuorumCapableResource );
            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            } // if:

            //
            //  If this core resource is a quorum capable resource then it must be the quorom.  If the caller
            //  has asked for the quorom resource then pass it back and leave the resource open, other wise
            //  close the resource and go around again.
            //

            if ( fIsQuorumCapableResource )
            {
                if ( phClusterQuorumResourceOut != NULL)
                {
                    *phClusterQuorumResourceOut = hRes;
                } // if:
                else
                {
                    CloseClusterResource( hRes );
                } // else:

                hRes = NULL;
                idxResource++;
                continue;
            } // if:

            //
            //  Since this core resource is not a quorum capable resource it is either the cluster
            //  name or the cluster IP address resource.
            //

            for ( idx = 0; *( g_pszCoreResourceTypes[ idx ] ) != '\0'; idx++ )
            {
                sc = ScIsResourceOfType( hRes, g_pszCoreResourceTypes[ idx ], &fIsResourceOfType );
                if ( sc != ERROR_SUCCESS )
                {
                    goto Cleanup;
                } // if:

                if ( !fIsResourceOfType )
                {
                    continue;
                } // if:

                switch ( idx )
                {
                    case CLUSTER_NAME :
                        if ( phClusterNameResourceOut != NULL )
                        {
                            *phClusterNameResourceOut = hRes;
                            fCloseResource = FALSE;
                        } // if:
                        break;

                    case CLUSTER_IP_ADDRESS :
                        if ( phClusterIPAddressResourceOut != NULL )
                        {
                            *phClusterIPAddressResourceOut = hRes;
                            fCloseResource = FALSE;
                        } // if:
                        break;

                    default:
                        goto Cleanup;
                } // switch:

                //
                //  If we get here then we broke from the switch above and we want out of
                //  this loop.
                //

                break;
            } // for:

            if ( fCloseResource )
            {
                CloseClusterResource( hRes );
            } // if:

            hRes = NULL;
            idxResource++;
            continue;
        } // if: sc == ERROR_SUCCESS
        else if ( sc == ERROR_NO_MORE_ITEMS )
        {
            sc = ERROR_SUCCESS;
            break;
        } // else if: sc == ERROR_NO_MORE_ITEMS
        else
        {
            goto Cleanup;
        } // else: sc has some other error...

        break;
    } // for:

Cleanup:

    LocalFree( psz );

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    return sc;

} //*** ResUtilGetCoreClusterResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilGetResourceName()
//
//  Description:
//      Get the name of the resource that is passed in.
//
//  Arguments:
//      hResourceIn
//          The resource whose name is sought.
//
//      pszResourceNameOut
//          Buffer to hold the resource's name.
//
//      pcchResourceNameInOut
//          The size of the buffer on input and the size required on output.
//
//
//  Return Value:
//      ERROR_SUCCESS
//      ERROR_MORE_DATA
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
ResUtilGetResourceName(
      HRESOURCE hResourceIn
    , WCHAR *   pszResourceNameOut
    , DWORD *   pcchResourceNameInOut
    )
{
    DWORD       sc = ERROR_INVALID_PARAMETER;
    WCHAR *     psz = NULL;
    DWORD       cb;

    if ( hResourceIn == NULL )
    {
        goto Bail;
    } // if:

    if ( ( pszResourceNameOut == NULL ) || ( pcchResourceNameInOut == NULL ) )
    {
        goto Bail;
    } // if:

    psz = (WCHAR *) LocalAlloc( LPTR, (*pcchResourceNameInOut) * sizeof( WCHAR ) );
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = ClusterResourceControl(
                  hResourceIn
                , NULL
                , CLUSCTL_RESOURCE_GET_NAME
                , NULL
                , 0
                , psz
                , (*pcchResourceNameInOut) * sizeof( WCHAR )
                , &cb
                );
    if ( sc == ERROR_MORE_DATA )
    {
        *pcchResourceNameInOut = ( cb / sizeof( WCHAR ) ) + 1;
        goto Cleanup;
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    wcsncpy( pszResourceNameOut, psz, *pcchResourceNameInOut );

    goto Cleanup;

OutOfMemory:

    sc = ERROR_NOT_ENOUGH_MEMORY;

Cleanup:

    LocalFree( psz );

Bail:

    return sc;

} //*** ResUtilGetResourceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\spooler\splsvc\process.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    genapp.c

Abstract:

    Resource DLL for Generic Applications.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



DWORD
GetProcessId(
    IN HANDLE ProcessHandle,
    OUT LPDWORD ProcessId
    )

/*++

Routine Description:

    Get the process Id for a process, given its process handle.

Arguments:

    ProcessHandle - the handle for the process to query.

    ProcessId - pointer to a DWORD to receive the process Id.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_PARAMETER on error.

--*/

{
    DWORD   status;
    DWORD   returnLength;
    PROCESS_BASIC_INFORMATION basicProcessInfo;

    //
    // Find the process id.
    //
    status = NtQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &basicProcessInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        &returnLength );
    if ( !NT_SUCCESS(status) ) {
        *ProcessId = 0;
        return(ERROR_INVALID_PARAMETER);
    }

    *ProcessId = basicProcessInfo.UniqueProcessId;

    return(ERROR_SUCCESS);

} // GetProcessId
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\spooler\splsvc\alloc.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    alloc.c

Abstract:

    Generic realloc code for any api that can fail with
    ERROR_INSUFFICIENT_BUFFER.

Author:

    Albert Ting (AlbertT)  25-Sept-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "alloc.hxx"

PBYTE
pAllocRead(
    HANDLE hUserData,
    ALLOC_FUNC AllocFunc,
    DWORD dwLenHint,
    PDWORD pdwLen OPTIONAL
    )
{
    ALLOC_DATA AllocData;
    PBYTE pBufferOut = NULL;
    DWORD dwLastError;
    DWORD cbActual;

    if( pdwLen ){
        *pdwLen = 0;
    }

    if( !dwLenHint ){

        DBGMSG( DBG_ERROR, ( "ReallocRead: dwLenHint = 0\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    AllocData.pBuffer = NULL;
    AllocData.cbBuffer = dwLenHint;

    for( ; ; ){

        cbActual = AllocData.cbBuffer;
        AllocData.pBuffer = (PBYTE)LocalAlloc( LMEM_FIXED, cbActual );

        if( !AllocData.pBuffer ){
            break;
        }

        if( !AllocFunc( hUserData, &AllocData )){

            //
            // Call failed.
            //
            dwLastError = GetLastError();
            LocalFree( (HLOCAL)AllocData.pBuffer );

            if( dwLastError != ERROR_INSUFFICIENT_BUFFER &&
                dwLastError != ERROR_MORE_DATA ){

                break;
            }
        } else {

            pBufferOut = AllocData.pBuffer;

            if( pdwLen ){
                *pdwLen = cbActual;
            }
            break;
        }
    }

    return pBufferOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\spooler\splsvc\clusinfo.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    clusinfo.c

Abstract:

    Retrieves cluster information: net name and TCP/IP address.

    Public functions from this module:

        bGetClusterNameInfo

    This code is a total hack.  It relies on internal knowledge about
    the registry structure of clustering and NetworkName and TCP/IP adddress:

    Questionable Assumptions:

        Directly under the resource GUID there will be a value called
        "Type" that holds the fixed resource name string.

        The resource type names "Network Name" and "IP Address" will
        never change or be localized.  (They shouldn't be localized, since
        they are keys, but I don't see a description value in the registry.)

        There will be a key called "Parameters" that will never change
        (or get localized).

    Bad Assumptions:

        IP Address resource stores a value "Address" that holds
        a REG_SZ string of the tcpip address.

        Network Name resource stores a value "Name" that holds a REG_SZ
        string of the network name.

    General strategy:

        1. Open self resource based on resource string from SplSvcOpen.
        2. Enumerate dependencies looking for net name.
        3. Find net name and save group name.
        4. Enumerate dependencies of net name looking for IP addresses.
        5. Save all found IP addresses.

Author:

    Albert Ting (AlbertT)  25-Sept-96

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "clusinfo.hxx"
#include "alloc.hxx"

#define GROUP_NAME_LEN_HINT MAX_PATH
#define RESOURCE_NAME_LEN_HINT MAX_PATH
#define TYPE_NAME_LEN_HINT MAX_PATH

LPCTSTR gszType = TEXT( "Type" );
LPCTSTR gszParameters = TEXT( "Parameters" );
DWORD   kGuidStringByteSize = 100;

/********************************************************************

    Callback for Querying cluster registry.

********************************************************************/

typedef struct _REG_QUERY_VALUE {
    HKEY hKey;
    LPCTSTR pszValue;
} REG_QUERY_VALUE, *PREG_QUERY_VALUE;

BOOL
bAllocClusterRegQueryValue(
    HANDLE hUserData,
    PALLOC_DATA pAllocData
    )
{
    DWORD dwStatus;
    PREG_QUERY_VALUE pRegQueryValue = (PREG_QUERY_VALUE)hUserData;

    dwStatus = ClusterRegQueryValue( pRegQueryValue->hKey,
                                     pRegQueryValue->pszValue,
                                     NULL,
                                     pAllocData->pBuffer,
                                     &pAllocData->cbBuffer );

    if( dwStatus != NO_ERROR ){

        SetLastError( dwStatus );
        return FALSE;
    }

    return TRUE;
}

/********************************************************************

    Callback for retrieving group name: GetClusterResourceState.

********************************************************************/


BOOL
bAllocGetClusterResourceState(
    HANDLE hUserData,
    PALLOC_DATA pAllocData
    )
{
    DWORD cchGroupName = pAllocData->cbBuffer / sizeof( TCHAR );
    CLUSTER_RESOURCE_STATE crs;

    crs = GetClusterResourceState( (HRESOURCE)hUserData,
                                   NULL,
                                   0,
                                   (LPTSTR)pAllocData->pBuffer,
                                   &cchGroupName );

    pAllocData->cbBuffer = cchGroupName * sizeof( TCHAR );

    return crs != ClusterResourceStateUnknown;
}


/********************************************************************

    Callback for enumerating group resources.

********************************************************************/


typedef struct _RESOURCE_ENUM {
    HRESENUM hResEnum;
    DWORD dwIndex;
} RESOURCE_ENUM, *PRESOURCE_ENUM;

BOOL
bAllocClusterResourceEnum(
    HANDLE hUserData,
    PALLOC_DATA pAllocData
    )
{
    PRESOURCE_ENUM pResourceEnum = (PRESOURCE_ENUM)hUserData;
    DWORD dwStatus;
    DWORD cchName = pAllocData->cbBuffer / sizeof( TCHAR );
    DWORD dwType;

    dwStatus = ClusterResourceEnum( pResourceEnum->hResEnum,
                                    pResourceEnum->dwIndex,
                                    &dwType,
                                    (LPTSTR)pAllocData->pBuffer,
                                    &cchName );

    pAllocData->cbBuffer = cchName * sizeof( TCHAR );

    if( dwStatus != NO_ERROR ){

        SetLastError( dwStatus );
        return FALSE;
    }
    return TRUE;
}


/********************************************************************

    End callbacks.

********************************************************************/

typedef struct _CLUSINFO_DATA {
    LPCTSTR pszResource;
    LPCTSTR pszValue;
} CLUSINFO_DATA, *PCLUSINFO_DATA;

CLUSINFO_DATA gaClusInfoDataMain[] = {
    { TEXT( "Network Name" ), TEXT( "Name" ) },
    { NULL, NULL }
};

CLUSINFO_DATA gaClusInfoDataNetName[] = {
    { TEXT( "IP Address" ), TEXT( "Address" ) },
    { NULL, NULL }
};

enum {
    ClusInfoName = 0,
    ClusInfoAddress,
    ClusInfoMax
};

typedef struct _CLUSINFO_DATAOUT {
    UINT cbData;
    LPCTSTR pszData;
} CLUSINFO_DATAOUT, *PCLUSINFO_DATAOUT;




BOOL
bProcessResourceRegKey(
    IN     HKEY hKey,
    IN     PCLUSINFO_DATA pClusInfoData,
    IN OUT PCLUSINFO_DATAOUT pClusInfoDataOut
    )

/*++

Routine Description:

    Checks whether a resource in a cluster matches any of the ClusInfoData
    resources.  If it does, fill one parameter into the ClusInfoDataOut
    parameter (comma delimited string).

Arguments:

    hKey - Key to read.

    pClusInfoData - Array of different ClusInfoData types that we
        want to look for.

    pClusInfoDataOut - Container that receives data we have found.
        This should be valid on input, since we append to form
        a comma delimited string.

Return Value:

    TRUE - Success: this may or may not have filled in one of the OUT
        parameters, but we didn't encounter any errors trying to read
        the resource.

    FALSE - Failure (LastError set).

--*/

{
    HKEY hKeyParameters = NULL;
    LPCTSTR pszType = NULL;
    BOOL bStatus = TRUE;

    REG_QUERY_VALUE rqv;
    DWORD dwStatus;
    UINT i;

    LPCTSTR pszNewSingleData = NULL;
    LPTSTR pszNewData = NULL;
    UINT cbNewSingleData;
    UINT cbNewData;

    rqv.hKey = hKey;
    rqv.pszValue = gszType;

    pszType = (LPCTSTR)pAllocRead( &rqv,
                                   bAllocClusterRegQueryValue,
                                   TYPE_NAME_LEN_HINT,
                                   NULL );

    if( !pszType ){

        DBGMSG( DBG_WARN,
                ( "bProcessResourceRegKey: ClusterRegOpenKey failed %d\n",
                  GetLastError() ));

        bStatus = FALSE;
        goto Done;
    }

    //
    // Walk through the list and check if there is a match.
    //

    for( i=0; bStatus && pClusInfoData[i].pszResource; ++i ){

        UINT cchLen;

        if( lstrcmp( pszType, pClusInfoData[i].pszResource )){

            //
            // No match, continue.
            //
            continue;
        }

        //
        // Found a match, read a value out of the
        // "parameters" key.
        //

        dwStatus = ClusterRegOpenKey( hKey,
                                      gszParameters,
                                      KEY_READ,
                                      &hKeyParameters );

        if( dwStatus != NO_ERROR ){

            DBGMSG( DBG_WARN,
                    ( "bProcessResourceRegKey: ClusterRegOpenKey failed %d\n",
                      dwStatus ));
            bStatus = FALSE;
            goto LoopDone;
        }

        rqv.hKey = hKeyParameters;
        rqv.pszValue = pClusInfoData[i].pszValue;

        pszNewSingleData = (LPCTSTR)pAllocRead( &rqv,
                                                bAllocClusterRegQueryValue,
                                                TYPE_NAME_LEN_HINT,
                                                NULL );
        if( !pszNewSingleData ){

            DBGMSG( DBG_WARN,
                    ( "bProcessResource: Read "TSTR" failed %d\n",
                      pClusInfoData[i].pszResource, GetLastError() ));

            bStatus = FALSE;
            goto LoopDone;
        }

        DBGMSG( DBG_TRACE,
                ( "bProcessResource: Read successful: "TSTR"\n",
                  pszNewSingleData, GetLastError() ));

        cchLen = lstrlen( pszNewSingleData );

        //
        // We have new data in pszNewData, add it to the end.
        //
        cbNewSingleData = ( cchLen + 1 ) * sizeof( TCHAR );
        cbNewData = cbNewSingleData + pClusInfoDataOut[i].cbData;

        pszNewData = (LPTSTR)LocalAlloc( LMEM_FIXED, cbNewData );

        if( !pszNewData ){

            bStatus = FALSE;
            goto Done;
        }


        //
        // If we have something, copy it over then add a ',' character.
        //
        if( pClusInfoDataOut[i].cbData ){

            //
            // Copy it over.
            //
            CopyMemory( (PVOID)pszNewData,
                        (PVOID)pClusInfoDataOut[i].pszData,
                        pClusInfoDataOut[i].cbData );

            //
            // Convert the NULL to a comma in our new data.
            //
            pszNewData[pClusInfoDataOut[i].cbData /
                       sizeof( pClusInfoDataOut[i].pszData[0] ) - 1] = TEXT( ',' );
        }

        //
        // Copy the new string.
        //
        CopyMemory( (PBYTE)pszNewData + pClusInfoDataOut[i].cbData,
                    (PVOID)pszNewSingleData,
                    cbNewSingleData );

        DBGMSG( DBG_TRACE,
                ( "bProcessResourceRegKey: Updated ("TSTR") + ("TSTR") = ("TSTR")\n",
                  DBGSTR(pClusInfoDataOut[i].pszData), pszNewSingleData, pszNewData ));

        //
        // Now swap the newly created memory with the old one.
        // We'll free pszNewSingleData and store the old memory there.
        //
        pClusInfoDataOut[i].cbData = cbNewData;

        LocalFree( (HLOCAL)pszNewSingleData );
        pszNewSingleData = pClusInfoDataOut[i].pszData;

        pClusInfoDataOut[i].pszData = pszNewData;
        pszNewData = NULL;

LoopDone:

        if( pszNewSingleData ){
            LocalFree( (HLOCAL)pszNewSingleData );
        }
        if( pszNewData ){
            LocalFree( (HLOCAL)pszNewData );
        }

        if( hKeyParameters && ClusterRegCloseKey( hKeyParameters )){

            DBGMSG( DBG_WARN,
                    ( "bProcessResource: ClusterRegCloseKey1 failed %x\n",
                      hKey ));
        }
    }

Done:

    if( pszType ){
        LocalFree( (HLOCAL)pszType );
    }

    return bStatus;
}



BOOL
bProcessResource(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN PCLUSINFO_DATA pClusInfoData,
    OUT PCLUSINFO_DATAOUT pClusInfoDataOut
    )

/*++

Routine Description:

    Checks whether a resource in a cluster matches any of the ClusInfoData
    resources.  If it does, fill one parameter into the ClusInfoDataOut
    parameter.

Arguments:

Return Value:

    TRUE - Success: this may or may not have filled in one of the OUT
        parameters, but we didn't encounter any errors trying to read
        the resource.

    FALSE - Failure (LastError set).

--*/

{
    HKEY hKey = NULL;
    LPCTSTR pszType = NULL;
    BOOL bStatus = FALSE;

    UNREFERENCED_PARAMETER( hCluster );

    hKey = GetClusterResourceKey( hResource, KEY_READ );

    if( !hKey ){

        DBGMSG( DBG_WARN,
                ( "bProcessResource: GetClusterResourceKey failed %d\n",
                  GetLastError() ));

        goto Done;
    }

    bStatus = bProcessResourceRegKey( hKey,
                                      pClusInfoData,
                                      pClusInfoDataOut );
Done:

    if( hKey && ClusterRegCloseKey( hKey )){

        DBGMSG( DBG_WARN,
                ( "bProcessResource: ClusterRegCloseKey2 failed %x\n",
                  hKey ));
    }

    return bStatus;
}


/********************************************************************

    Enum dependency support.  This is handled by calling a callback
    with the retieved handle.

********************************************************************/

typedef BOOL (*ENUM_CALLBACK )(
    HCLUSTER hCluster,
    HRESOURCE hResource,
    HANDLE hData
    );

BOOL
bHandleEnumDependencies(
    IN     HCLUSTER hCluster,
    IN     HRESOURCE hResource,
    IN     ENUM_CALLBACK pfnEnumCallback,
    IN     HANDLE hData,
       OUT PUINT puSuccess OPTIONAL
    );


/********************************************************************

    Callbacks for EnumDependencies.

********************************************************************/


BOOL
bEnumDependencyCallbackMain(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    );

BOOL
bEnumDependencyCallbackNetName(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    );


/********************************************************************

    Functions.

********************************************************************/

BOOL
bHandleEnumDependencies(
    IN     HCLUSTER hCluster,
    IN     HRESOURCE hResource,
    IN     ENUM_CALLBACK pfnEnumCallback,
    IN     HANDLE hData,
       OUT PUINT puSuccess OPTIONAL
    )

/*++

Routine Description:

    Takes a resource and calls pfnEnumCallback for each of the dependent
    resources.

Arguments:

    hResource - Resource that holds dependencies to check.

    pfnEnumCallback - Callback routine.

    hData - Private data.

    puSuccess - Number of successful hits.

Return Value:

    TRUE - success, FALSE - failure.

--*/

{
    RESOURCE_ENUM ResourceEnum;
    LPCTSTR pszResource;
    HRESOURCE hResourceDependency;

    UINT uSuccess = 0;
    BOOL bStatus = TRUE;

    ResourceEnum.hResEnum = ClusterResourceOpenEnum(
                                hResource,
                                CLUSTER_RESOURCE_ENUM_DEPENDS );

    if( !ResourceEnum.hResEnum ){

        DBGMSG( DBG_WARN,
                ( "bHandleEnumDependencies: ClusterResourceOpenEnum failed %d\n",
                  GetLastError() ));

        bStatus = FALSE;

    } else {

        //
        // Walk through all the dependent resources and call
        // the callback function to process them.
        //
        for( ResourceEnum.dwIndex = 0; ; ++ResourceEnum.dwIndex ){

            pszResource = (LPCTSTR)pAllocRead(
                              (HANDLE)&ResourceEnum,
                              bAllocClusterResourceEnum,
                              RESOURCE_NAME_LEN_HINT,
                              NULL );

            if( !pszResource ){

                SPLASSERT( GetLastError() == ERROR_NO_MORE_ITEMS );
                bStatus = FALSE;
                break;
            }

            hResourceDependency = OpenClusterResource( hCluster, pszResource );

            if( !hResourceDependency ){

                DBGMSG( DBG_WARN,
                        ( "bHandleEnumDependencies: OpenClusterResource failed "TSTR" %d\n",
                           pszResource, GetLastError() ));

                bStatus = FALSE;

            } else {

                if( pfnEnumCallback( hCluster, hResourceDependency, hData )){
                    ++uSuccess;
                }

                if( !CloseClusterResource( hResourceDependency )){

                    DBGMSG( DBG_WARN,
                            ( "bProcessResource: CloseClusterResource failed "TSTR" %x %d\n",
                            pszResource, hResourceDependency, GetLastError() ));
                }
            }

            LocalFree( (HLOCAL)pszResource );
        }

        if( ClusterResourceCloseEnum( ResourceEnum.hResEnum )){

            DBGMSG( DBG_WARN,
                    ( "bProcessResource: ClusterResourceCloseEnum failed %x\n",
                      ResourceEnum.hResEnum ));
        }
    }

    if( puSuccess ){
        *puSuccess = uSuccess;
    }

    return bStatus;
}


BOOL
bEnumDependencyCallbackMain(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    )

/*++

Routine Description:

    This routine processes the dependent resources of the main resource.
    It is called once for each.

    When we encounter net name, we'll do the same procedure except
    look for tcpip addresses.

Arguments:

    hResource - This resource is an enumerated dependency.

    hData - User supplied ata.

Return Value:

    TRUE - Found
    FALSE - Not found.

--*/

{
    BOOL bStatus;
    BOOL bReturn = FALSE;
    UINT uSuccess;

    bStatus = bProcessResource( hCluster,
                                hResource,
                                gaClusInfoDataMain,
                                (PCLUSINFO_DATAOUT)hData );

    //
    // If it's successful, it must have been "NetName," since that's
    // the only thing we're looking for.  In that case, build
    // names off of its tcpip addresses.
    //
    if( bStatus ){

        PCLUSINFO_DATAOUT pClusInfoDataOut = (PCLUSINFO_DATAOUT)hData;

        bReturn = TRUE;

        //
        // Use the proper index for tcpip addresses.
        //

        bStatus = bHandleEnumDependencies(
                      hCluster,
                      hResource,
                      bEnumDependencyCallbackNetName,
                      (HANDLE)&pClusInfoDataOut[ClusInfoAddress],
                      &uSuccess );

        if( !bStatus || !uSuccess ){

            DBGMSG( DBG_WARN,
                    ( "bEnumDependencyCallbackMain: failed to get ip addr %d %d %d\n",
                      bStatus, uSuccess, GetLastError() ));
        }
    } else {

        DBGMSG( DBG_WARN,
                ( "bEnumDependencyCallbackMain: failed to find net name %d\n",
                  GetLastError() ));
    }

    return bReturn;
}


BOOL
bEnumDependencyCallbackNetName(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    )

/*++

Routine Description:

    This routine processes the dependent resources of the net name
    resource.

Arguments:

    hResource - This resource is an enumerated dependency.

    hData - User supplied ata.

Return Value:

    TRUE - continue,
    FALSE - stop.

--*/

{
    BOOL bStatus;
    bStatus = bProcessResource( hCluster,
                                hResource,
                                gaClusInfoDataNetName,
                                (PCLUSINFO_DATAOUT)hData );

    return bStatus;
}


/********************************************************************

    Main entry point.

********************************************************************/

BOOL
bGetClusterNameInfo(
    IN LPCTSTR pszResource,
    OUT LPCTSTR* ppszName,
    OUT LPCTSTR* ppszAddress
    )

/*++

Routine Description:

    Retrieves information about a given resource.

Arguments:

    pszResource - Name of the resource.  Must not be NULL.

    ppszName - Receives LocalAlloc'd string of cluster name.

    ppszAddress - Receives LocalAlloc'd TCPIP address name string.

Return Value:

    TRUE - Success, *ppszName, *ppszAddress both valid and
        must be LocalFree'd when no longer needed.

    FALSE - Failed, *ppszName, *ppszAddress both NULL.
        LastError set.

--*/

{
    HCLUSTER  hCluster     = NULL;
    HRESOURCE hResource    = NULL;
    HRESENUM  hResEnum     = NULL;
    LPCTSTR   pszGroupName = NULL;
    UINT      uSuccess     = 0;
    UINT      i;

    CLUSINFO_DATAOUT aClusInfoDataOut[ClusInfoMax];

    //
    // Free the strings if there were allocated earlier so we can
    // start clean.
    //

    if( *ppszName ){
        LocalFree( (HLOCAL)*ppszName );
        *ppszName = NULL;
    }

    if( *ppszAddress ){
        LocalFree( (HLOCAL)*ppszAddress );
        *ppszAddress = NULL;
    }

    ZeroMemory( aClusInfoDataOut, sizeof( aClusInfoDataOut ));

    //
    // Open the cluster and acquire the information.
    //

    hCluster = OpenCluster( NULL );

    if( !hCluster ){

        DBGMSG( DBG_WARN,
                ( "bGetClusterNameInfo: OpenCluster failed %d\n",
                  GetLastError() ));

        goto Done;
    }

    hResource = OpenClusterResource(
                    hCluster,
                    pszResource );

    if( !hResource ){

        DBGMSG( DBG_WARN,
                ( "bGetClusterNameInfo: OpenClusterResource "TSTR" failed %d\n",
                  pszResource, GetLastError() ));

        goto Done;
    }

    //
    // Enum through the dependent resources in the group looking for either
    // type "IP Address" or "Network Name."  These shouldn't be
    // localized since they are registry keys (not values).
    //

    bHandleEnumDependencies( hCluster,
                             hResource,
                             bEnumDependencyCallbackMain,
                             (HANDLE)&aClusInfoDataOut[ClusInfoName],
                             &uSuccess );

Done:

    if( hResource && !CloseClusterResource( hResource )){

        DBGMSG( DBG_WARN,
                ( "bGetCluseterNameInfo: CloseClusterResource failed %d\n",
                  GetLastError() ));
    }

    if( hCluster && !CloseCluster( hCluster )){

        DBGMSG( DBG_WARN,
                ( "bGetClusterNameInfo: CloseCluster failed %d\n",
                  GetLastError() ));
    }

    if( !uSuccess ){

        DBGMSG( DBG_WARN,
                ( "bGetCluseterNameInfo: No NetName enumerated back! %d\n",
                  GetLastError() ));

        for( i=0; i<COUNTOF( aClusInfoDataOut ); ++i ){

            if( aClusInfoDataOut[i].pszData ){
                LocalFree( (HLOCAL)aClusInfoDataOut[i].pszData );
            }
        }
    } else {
        *ppszName = aClusInfoDataOut[ClusInfoName].pszData;
        *ppszAddress = aClusInfoDataOut[ClusInfoAddress].pszData;
    }

    DBGMSG( DBG_TRACE,
            ( "bGetClusterNameInfo: uSuccess %d "TSTR" "TSTR"\n",
              uSuccess, DBGSTR( *ppszName ), DBGSTR( *ppszAddress )));

    return uSuccess != 0;
}

/*++

Routine Description:

    Gets the GUID for a resource.

Arguments:

    hResource - handle obtained via OpenClusterResource

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/
DWORD
GetIDFromName(
    IN     HRESOURCE  hResource,
       OUT LPWSTR    *ppszID
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (hResource && ppszID) 
    {
        //
        // Set the out parameter to something known
        //
        *ppszID = NULL;
    
        //
        // Should be able to hold the string representation of a guid
        //
        DWORD cbBuf = kGuidStringByteSize;
        
        if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
        {
            if ((dwError = ClusterResourceControl(hResource, 
                                                  NULL,
                                                  CLUSCTL_RESOURCE_GET_ID,
                                                  NULL,                                               
                                                  0,
                                                  *ppszID,
                                                  cbBuf,
                                                  &cbBuf)) == ERROR_MORE_DATA) 
            {
                LocalFree(*ppszID);

                if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
                {
                    dwError = ClusterResourceControl(hResource, 
                                                     NULL,
                                                     CLUSCTL_RESOURCE_GET_ID,
                                                     NULL,                                               
                                                     0,
                                                     *ppszID,
                                                     cbBuf,
                                                     &cbBuf);
                }
                else
                {
                    dwError = GetLastError();
                }
            }

            //
            // Free the memory if getting the ID failed
            //
            if (dwError != ERROR_SUCCESS && *ppszID) 
            {
                LocalFree(*ppszID);
                *ppszID = NULL;
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }
    
    DBGMSG(DBG_TRACE, ("GetIDFromName returns %u\n", dwError));

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\spooler\splsvc\splsvc.cxx ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved.

Module Name:

    splsvc.c

Abstract:

    Resource DLL for Spooler

Author:

    Albert Ting (albertt) 17-Sept-1996
    Based on resdll\genapp

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "splsvc.hxx"
#include "spooler.hxx"
#include "clusinfo.hxx"
#include "clusrtl.h"

MODULE_DEBUG_INIT( DBG_ERROR|DBG_WARN|DBG_TRACE, DBG_ERROR );

#define MAX_SPOOLER 60

#define MAX_GROUP_NAME_LENGTH 120

#define SPOOLER_TERMINATE // Kill the spooler on terminate if pending offline.

#define SplSvcLogEvent ClusResLogEvent
#define SplSvcSetResourceStatus ClusResSetResourceStatus

#define NET_NAME_RESOURCE_NAME CLUS_RESTYPE_NAME_NETNAME

#define PARAM_NAME__DEFAULTSPOOLDIRECTORY CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR
#define PARAM_NAME__JOBCOMPLETIONTIMEOUT CLUSREG_NAME_PRTSPOOL_TIMEOUT

#define KEY_NAME__DEFAULTSPOOLDIRECTORY L"Printers"
#define KEY_NAME__JOBCOMPLETIONTIMEOUT NULL

#define PARAM_MIN__JOBCOMPLETIONTIMEOUT    0
#define PARAM_MAX__JOBCOMPLETIONTIMEOUT    ((DWORD) -1)
#define PARAM_DEFAULT_JOBCOMPLETIONTIMEOUT 160

typedef struct _SPOOLER_PARAMS {
    LPWSTR      DefaultSpoolDirectory;
    DWORD       JobCompletionTimeout;
} SPOOLER_PARAMS, *PSPOOLER_PARAMS;

//
// Properties
//

RESUTIL_PROPERTY_ITEM
SplSvcResourcePrivateProperties[] = {
    { PARAM_NAME__DEFAULTSPOOLDIRECTORY, KEY_NAME__DEFAULTSPOOLDIRECTORY, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SPOOLER_PARAMS,DefaultSpoolDirectory) },
    { PARAM_NAME__JOBCOMPLETIONTIMEOUT, KEY_NAME__JOBCOMPLETIONTIMEOUT, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT_JOBCOMPLETIONTIMEOUT, PARAM_MIN__JOBCOMPLETIONTIMEOUT, PARAM_MAX__JOBCOMPLETIONTIMEOUT, 0, FIELD_OFFSET(SPOOLER_PARAMS,JobCompletionTimeout) },
    { 0 }
};

//
// Lock to protect the ProcessInfo table
//
CRITICAL_SECTION gProcessLock;

//
// Global count of spooler resource instances.
//
UINT gcSpoolerInfo;

extern CLRES_FUNCTION_TABLE SplSvcFunctionTable;

#define PSPOOLERINFO_FROM_RESID(resid) ((PSPOOLER_INFORMATION)resid)
#define RESID_FROM_SPOOLERINFO(pSpoolerInfo) ((RESID)pSpoolerInfo)

//
// Forward prototypes.
//

#ifdef __cplusplus
extern "C"
#endif

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

RESID
WINAPI
SplSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
SplSvcClose(
    IN RESID Resid
    );

DWORD
WINAPI
SplSvcOnline(
    IN RESID Resid,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
SplSvcOffline(
    IN RESID Resid
    );

VOID
WINAPI
SplSvcTerminate(
    IN RESID Resource
    );

BOOL
WINAPI
SplSvcIsAlive(
    IN RESID Resource
    );

BOOL
WINAPI
SplSvcLooksAlive(
    IN RESID Resource
    );

DWORD
SplSvcGetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
SplSvcValidatePrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSPOOLER_PARAMS Params
    );

DWORD
SplSvcSetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


PSPOOLER_INFORMATION
pNewSpoolerInfo(
    LPCTSTR pszResource,
    RESOURCE_HANDLE ResourceHandle,
    PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    PLOG_EVENT_ROUTINE LogEvent
    )
{
    PSPOOLER_INFORMATION pSpoolerInfo = NULL;
    LPTSTR pszResourceNew = NULL;

    pSpoolerInfo = (PSPOOLER_INFORMATION)LocalAlloc(
                                             LPTR,
                                             sizeof( SPOOLER_INFORMATION ));

    if( !pSpoolerInfo ){
        goto Fail;
    }

    pszResourceNew = (LPTSTR)LocalAlloc(
                                 LMEM_FIXED,
                                 ( lstrlen( pszResource ) + 1 )
                                     * sizeof( TCHAR ));

    if( !pszResourceNew ){
        goto Fail;
    }

    lstrcpy( pszResourceNew, pszResource );

    pSpoolerInfo->pfnLogEvent = LogEvent;
    pSpoolerInfo->ResourceHandle = ResourceHandle;
    pSpoolerInfo->pfnSetResourceStatus = SetResourceStatus;

    pSpoolerInfo->pszResource = pszResourceNew;
    pSpoolerInfo->pszName = NULL;
    pSpoolerInfo->pszAddress = NULL;

    return pSpoolerInfo;

Fail:

    if( pszResourceNew ){
        LocalFree( (HLOCAL)pszResourceNew );
    }

    if( pSpoolerInfo ){
        LocalFree( (HLOCAL)pSpoolerInfo );
    }

    return NULL;
}

VOID
vDeleteSpoolerInfo(
    PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    if( !pSpoolerInfo ){
        return;
    }

    SPLASSERT( !pSpoolerInfo->cRef );

    //
    // Shut down everything.
    //
    if( pSpoolerInfo->pszName ){
        LocalFree( (HLOCAL)pSpoolerInfo->pszName );
    }

    if( pSpoolerInfo->pszAddress ){
        LocalFree( (HLOCAL)pSpoolerInfo->pszAddress );
    }

    if( pSpoolerInfo->pszResource ){
        LocalFree( (HLOCAL)pSpoolerInfo->pszResource );
    }
    
    LocalFree( (HLOCAL)pSpoolerInfo );
}




BOOL
Init(
    VOID
    )
{
    InitializeCriticalSection( &gProcessLock );
    return bSplLibInit();
}

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(DllHandle);
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:

        if( !Init() ){

            DBGMSG( DBG_ERROR, ( "DllEntryPoint: failed to init\n" ));
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return TRUE;

}


/********************************************************************

    Required exports and function table entries used by clustering.

********************************************************************/




/********************************************************************

    Resource DLL functions.

********************************************************************/



BOOL
bSplRegCopyTree(
    IN HKEY hClusterKey,
    IN HKEY hLocalKey
    )

/*++

Routine Description:

    Recursives copies every key and value from under hLocalKey to hClusterKey 

Arguments:

    hClusterKey - handle to the cluster registry (destination)
    hLocalKey   - handle to the local registry (source)

Return Value:

    TRUE - success
    FALSE - failure

--*/

{
    BOOL    bStatus = FALSE;
    DWORD   dwError, dwIndex, cbValueName, cbData, cbKeyName, dwType;
    DWORD   cbMaxSubKeyLen, cbMaxValueNameLen, cValues, cSubKeys, cbMaxValueLen;
    LPBYTE  lpValueName = NULL, lpData = NULL, lpKeyName = NULL;
    HKEY    hLocalSubKey = NULL, hClusterSubKey = NULL;

    //
    // Retrieve the max buffer sizes required for the copy
    //
    dwError = RegQueryInfoKey( hLocalKey, NULL, NULL, NULL, &cSubKeys,
                               &cbMaxSubKeyLen, NULL, &cValues,
                               &cbMaxValueNameLen, &cbMaxValueLen,
                               NULL, NULL );   
    if( dwError ){

        SetLastError( dwError );
        goto CleanUp;
    }

    // 
    // Add for the terminating NULL character
    //
    ++cbMaxSubKeyLen;
    ++cbMaxValueNameLen;

    //
    // Allocate the buffers
    //
    lpValueName = (LPBYTE) LocalAlloc( LMEM_FIXED, cbMaxValueNameLen * sizeof(WCHAR) );
    lpData      = (LPBYTE) LocalAlloc( LMEM_FIXED, cbMaxValueLen );
    lpKeyName   = (LPBYTE) LocalAlloc( LMEM_FIXED, cbMaxSubKeyLen * sizeof(WCHAR) );

    if( !lpValueName || !lpData || !lpKeyName){

        goto CleanUp;
    }    

    //
    // Copy all the values in the current key
    //
    for (dwIndex = 0; dwIndex < cValues; ++ dwIndex) {

       cbValueName = cbMaxValueNameLen;
       cbData = cbMaxValueLen;
 
       //
       // Retrieve the value name and the data
       //
       dwError = RegEnumValue( hLocalKey, dwIndex, (LPWSTR) lpValueName, &cbValueName,
                               NULL, &dwType, lpData, &cbData );
       
       if( dwError ){

           SetLastError( dwError );
           goto CleanUp;
       }

       // 
       // Set the value in the cluster registry
       //
       dwError = ClusterRegSetValue( hClusterKey, (LPWSTR) lpValueName, dwType,
                                     lpData, cbData );

       if( dwError ){

           SetLastError( dwError );
           goto CleanUp;
       }
    }

    //
    // Recursively copies all the subkeys
    //
    for (dwIndex = 0; dwIndex < cSubKeys; ++ dwIndex) {

        cbKeyName = cbMaxSubKeyLen;

        //
        // Retrieve the key name
        //
        dwError = RegEnumKeyEx( hLocalKey, dwIndex, (LPWSTR) lpKeyName, &cbKeyName,
                                NULL, NULL, NULL, NULL );
        
        if( dwError ){
 
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Open local subkey
        //
        if( dwError = RegOpenKeyEx( hLocalKey, (LPWSTR) lpKeyName, 0,
                                    KEY_READ, &hLocalSubKey ) ){

            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Create the cluster subkey
        //

        if(( dwError = ClusterRegOpenKey( hClusterKey, (LPWSTR) lpKeyName, 
                                          KEY_READ|KEY_WRITE,
                                          &hClusterSubKey)) == ERROR_FILE_NOT_FOUND )
        {
            if( dwError = ClusterRegCreateKey( hClusterKey, (LPWSTR) lpKeyName, 
                                               0,KEY_READ|KEY_WRITE,
                                               NULL, &hClusterSubKey, NULL ) )
            {
                SetLastError( dwError );
                goto CleanUp;
            }
        }

        //
        // Copy the subkey tree
        //
        if( !bSplRegCopyTree( hClusterSubKey, hLocalSubKey ) ){
            
            goto CleanUp;
        }

        // 
        // Close the registry handle
        //
        RegCloseKey( hLocalSubKey );
        ClusterRegCloseKey( hClusterSubKey );

        hLocalSubKey = NULL;
        hClusterSubKey = NULL;

    }

    bStatus = TRUE;

CleanUp:

    if( lpValueName ){
        LocalFree( lpValueName );
    }
    if( lpData ){
        LocalFree( lpData );
    }
    if( lpKeyName ){
        LocalFree( lpKeyName );
    }
    if( hLocalSubKey ){
        RegCloseKey( hLocalSubKey );
    }
    if( hClusterSubKey ){
        ClusterRegCloseKey( hClusterSubKey );
    }

    return bStatus;
}

BOOL
bUpdateRegPort(
    IN HKEY hClusterKey,
    OUT LPBOOL pbRegUpdated
    )

/*++

Routine Description:

    Moves Port data from the local to the cluster registry

Arguments:

    hClusterKey - handle to the cluster registry
    pbRegUpdated - flag to indicate if the registry was updated

Return Value:

    TRUE - success
    FALSE - failure

--*/

{
    BOOL   bStatus = FALSE;
    DWORD  dwError, dwType, dwValue, dwSize;
    HKEY   hLocalLPR = NULL, hClusterLPR = NULL;

    WCHAR  szLocalLPRKey[] = L"System\\CurrentControlSet\\Control\\Print\\Monitors\\LPR Port";
    WCHAR  szClusterLPRKey[] = L"Monitors\\LPR Port";
    WCHAR  szSplVersion[] = L"Spooler Version";
    
    //
    // Initialize the bRegUpdate flag
    //
    *pbRegUpdated = FALSE;

    //
    // Check if ports have been migrated already
    //
    dwSize = sizeof(DWORD);
    if( dwError = ClusterRegQueryValue( hClusterKey, szSplVersion, &dwType,
                                        (LPBYTE) &dwValue, &dwSize ) ){

        if( dwError != ERROR_FILE_NOT_FOUND ){

            SetLastError( dwError );
            return FALSE;
        }

    } else {

        if( dwValue == 1 ){
            return TRUE;
        }
    }

    //
    // Open the local LPR Port key, if any
    //
    if( dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szLocalLPRKey, 0,
                                KEY_READ, &hLocalLPR ) ){

        //
        // LPR Port key was not found
        //
        if( dwError == ERROR_FILE_NOT_FOUND ){
             
            bStatus = TRUE;

        } else {
            
            SetLastError( dwError );
        }
        goto CleanUp;
    }

    // 
    // Create the LPR Port key on the cluster registry
    //                                    

    if(( dwError = ClusterRegOpenKey( hClusterKey, szClusterLPRKey, 
                                     KEY_READ|KEY_WRITE,
                                     &hClusterLPR ) ) == ERROR_FILE_NOT_FOUND)
    {


        if( dwError = ClusterRegCreateKey( hClusterKey, szClusterLPRKey, 
                                           0,KEY_READ|KEY_WRITE,
                                           NULL, &hClusterLPR, NULL ) )
        {
            SetLastError( dwError );
            goto CleanUp;
        }
    }
    else if ( dwError )
    {
        SetLastError( dwError );
        goto CleanUp;
    }

    bStatus = bSplRegCopyTree( hClusterLPR, hLocalLPR );

    if( bStatus ){

        //
        // Create a value in the cluster to avoid repeated copying of the port data
        //
        dwValue = 1;
        dwSize  = sizeof(dwValue);
        ClusterRegSetValue( hClusterKey, szSplVersion, REG_DWORD,
                            (LPBYTE) &dwValue, dwSize ); 
        *pbRegUpdated = TRUE;
    }

CleanUp:

    if( hLocalLPR ){
        RegCloseKey( hLocalLPR );
    }

    if( hClusterLPR ){
        ClusterRegCloseKey( hClusterLPR );
    }

    return bStatus;
}

RESID
WINAPI
SplSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Opens the spooler resource.  This will start the spooler
    service if necessary.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo = NULL;
    BOOL bTooMany = FALSE,  bRegUpdated;
    HKEY parametersKey = NULL;
    DWORD status;
    HCLUSTER hCluster;

    UNREFERENCED_PARAMETER(ResourceKey);

    vEnterSem();

    DBGMSG( DBG_WARN, ( ">>> Open: called\n" ));

    if( gcSpoolerInfo == MAX_SPOOLER ){
        bTooMany = TRUE;
        status = ERROR_ALLOTTED_SPACE_EXCEEDED;
        goto FailLeave;
    }

    //
    // Open the Parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                CLUSREG_KEYNAME_PARAMETERS,
                                KEY_READ,
                                &parametersKey );
    if ( status != ERROR_SUCCESS || parametersKey == NULL ) {
        (SplSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key for resource '%1!ws!'. Error: %2!u!.\n",
            ResourceName,
            status );
        goto FailLeave;
    }

    //
    // Move the ports data from local to cluster registry
    //

    if( !bUpdateRegPort( parametersKey, &bRegUpdated ) ){

       (SplSvcLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"LPR Port settings could not be moved to cluster registry.\n" );

       DBGMSG( DBG_WARN, ( "Port settings could not be moved to cluster registry" ));
    }

    //
    // Find a free index in the process info table for this new app.
    //

    pSpoolerInfo = pNewSpoolerInfo( ResourceName,
                                    ResourceHandle,
                                    SplSvcSetResourceStatus,
                                    SplSvcLogEvent );

    if( !pSpoolerInfo ){
        status = ERROR_ALLOTTED_SPACE_EXCEEDED;
        goto FailLeave;
    }

    //
    // Save the name of the resource.
    //
    hCluster = OpenCluster( NULL );
    if ( !hCluster ) {
        status = GetLastError();
        goto FailLeave;
    }
    pSpoolerInfo->hResource = OpenClusterResource( hCluster,
                                                   ResourceName );
    status = GetLastError();
    CloseCluster( hCluster );
    if ( pSpoolerInfo->hResource == NULL ) {
        goto FailLeave;
    }
    
    pSpoolerInfo->eState = kOpen;
    pSpoolerInfo->ParametersKey = parametersKey;

    vAddRef( pSpoolerInfo );
    ++gcSpoolerInfo;

    vLeaveSem();

    DBGMSG( DBG_WARN,
            ( "Open: return %x\n", RESID_FROM_SPOOLERINFO( pSpoolerInfo )));

    return RESID_FROM_SPOOLERINFO(pSpoolerInfo);

FailLeave:

    vLeaveSem();

    if( bTooMany ){

        (SplSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Too many spoolers.\n" );

        DBGMSG( DBG_WARN, ( "SplSvcOpen: Too many spoolers.\n" ));

    } else {

        (SplSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to create new spooler. Error: %1!u!.\n",
            GetLastError() );

        DBGMSG( DBG_ERROR, ( "SplSvcOpen: Unable to create spooler %d\n",
                GetLastError()));
    }

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }

    if ( pSpoolerInfo && (pSpoolerInfo->hResource != NULL) ) {
        CloseClusterResource( pSpoolerInfo->hResource );
    }

    vDeleteSpoolerInfo( pSpoolerInfo );

    SetLastError( status );

    return (RESID)0;
}

VOID
WINAPI
SplSvcClose(
    IN RESID Resid
    )

/*++

Routine Description:

    Close down the open spooler resource ID.  Note that we'll leave
    the spooler running, since it always should be running.

Arguments:

    Resource - supplies resource id to be closed

Return Value:

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo;
    DBGMSG( DBG_WARN, ( ">>> Close: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    //
    // If resource is still online, terminate it.
    //
    if( pSpoolerInfo->eState == kOnline ){
        SplSvcTerminate( Resid );
    }

    vEnterSem();

    --gcSpoolerInfo;
    pSpoolerInfo->eState = kClose;

    vLeaveSem();

    if (pSpoolerInfo->hResource != NULL ) {
        CloseClusterResource( pSpoolerInfo->hResource );
    }

    if (pSpoolerInfo->ParametersKey != NULL ) {
        ClusterRegCloseKey( pSpoolerInfo->ParametersKey );
    }
    
    vDecRef( pSpoolerInfo );
}

DWORD
WINAPI
SplSvcOnline(
    IN RESID Resid,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online the spooler resource.

    This always completes asynchronously with ERROR_IO_PENDING.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    In success case, this returns ERROR_IO_PENDING, else win32
    error code.

--*/

{
    BOOL bStatus;
    DWORD Status = ERROR_IO_PENDING;
    PSPOOLER_INFORMATION pSpoolerInfo;

    UNREFERENCED_PARAMETER( EventHandle );

    DBGMSG( DBG_WARN, ( ">>> Online: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    //
    // Rpc to the spooler to initiate Online.
    //
    bStatus = SpoolerOnline( pSpoolerInfo );

    if( !bStatus ){

        Status = GetLastError();
        SPLASSERT( Status );

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Unable to online spooler resource. Error: %1!u!.\n",
            Status );

        DBGMSG( DBG_ERROR, ( "SplSvcOnline: Unable to online spooler\n" ));
    }

    return Status;
}

DWORD
WINAPI
SplSvcOffline(
    IN RESID Resid
    )

/*++

Routine Description:

    Offline the spooler resource.

Arguments:

    Resid - supplies the resource to be taken offline

Return Value:

    In success case, this returns ERROR_IO_PENDING, else win32
    error code.

--*/

{
    PSPOOLER_INFORMATION  pSpoolerInfo;

    DBGMSG( DBG_WARN, ( ">>> Offline: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    vEnterSem();
    pSpoolerInfo->ClusterResourceState = ClusterResourceOffline;
    vLeaveSem();

    return(SpoolerOffline(pSpoolerInfo));
}

VOID
WINAPI
SplSvcTerminate(
    IN RESID Resid
    )

/*++

Routine Description:

    Terminate and restart the spooler--no waiting.

Arguments:

    Resid - supplies resource id to be terminated

Return Value:

--*/

{
    PSPOOLER_INFORMATION  pSpoolerInfo;

    DBGMSG( DBG_WARN, ( ">>> Terminate: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    vEnterSem();
    pSpoolerInfo->ClusterResourceState = ClusterResourceFailed;
    vLeaveSem();

    SpoolerTerminate(pSpoolerInfo);
    return;

}

BOOL
WINAPI
SplSvcIsAlive(
    IN RESID Resid
    )

/*++

Routine Description:

    IsAlive routine for Generice Applications resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo;

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    return SpoolerIsAlive( pSpoolerInfo );
}


BOOL
WINAPI
SplSvcLooksAlive(
    IN RESID Resid
    )

/*++

Routine Description:

    LooksAlive routine for Generic Applications resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo;

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    return SpoolerLooksAlive( pSpoolerInfo );
}


DWORD
SplSvcGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLCTL_GET_REQUIRED_DEPENDENCIES control function
    for resources of type Print Spooler.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    typedef struct DEP_DATA {
        CLUSPROP_RESOURCE_CLASS storageEntry;
        CLUSPROP_SZ_DECLARE( netnameEntry, sizeof(NET_NAME_RESOURCE_NAME) / sizeof(WCHAR) );
        CLUSPROP_SYNTAX endmark;
    } DEP_DATA, *PDEP_DATA;
    PDEP_DATA   pdepdata = (PDEP_DATA)OutBuffer;
    DWORD       status;

    *BytesReturned = sizeof(DEP_DATA);
    if ( OutBufferSize < sizeof(DEP_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( pdepdata, sizeof(DEP_DATA) );
        pdepdata->storageEntry.Syntax.dw = CLUSPROP_SYNTAX_RESCLASS;
        pdepdata->storageEntry.cbLength = sizeof(DWORD);
        pdepdata->storageEntry.rc = CLUS_RESCLASS_STORAGE;
        pdepdata->netnameEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->netnameEntry.cbLength = sizeof(NET_NAME_RESOURCE_NAME);
        lstrcpyW( pdepdata->netnameEntry.sz, NET_NAME_RESOURCE_NAME );
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return status;

} // SplSvcGetRequiredDependencies


DWORD
SplSvcResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Print Spooler resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PSPOOLER_INFORMATION pSpoolerInfo;
    DWORD               required;
    LPWSTR              pszResourceNew;

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( ResourceId );

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SplSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            pszResourceNew = (LPWSTR)LocalAlloc(
                                         LMEM_FIXED,
                                         ( lstrlenW( (LPWSTR)InBuffer ) + 1 )
                                             * sizeof( WCHAR ));

            if ( pszResourceNew ) {
                LocalFree( (HLOCAL)pSpoolerInfo->pszResource );
                lstrcpyW( pszResourceNew, (LPWSTR)InBuffer );
                pSpoolerInfo->pszResource = (LPTSTR)pszResourceNew;
                status = ERROR_SUCCESS;
            } else {
                status = GetLastError();
            }

            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = SplSvcGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SplSvcResourcePrivateProperties,
                                            (LPWSTR) OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = SplSvcGetPrivateResProperties( pSpoolerInfo,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = SplSvcValidatePrivateResProperties( pSpoolerInfo,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = SplSvcSetPrivateResProperties( pSpoolerInfo,
                                                    InBuffer,
                                                    InBufferSize );
            break;

        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
            
            {
                LPWSTR pszResourceGuid = NULL;

                //
                // Retreive the guid of the spooler resource
                //
                if ((status = GetIDFromName(pSpoolerInfo->hResource, 
                                            &pszResourceGuid)) == ERROR_SUCCESS)
                {
                    status = SpoolerWriteClusterUpgradedKey(pszResourceGuid);
                
                    LocalFree(pszResourceGuid);
                }
            }

            break;

       case CLUSCTL_RESOURCE_DELETE:

            SpoolerCleanDriverDirectory(pSpoolerInfo->ParametersKey);

            //
            // Let the res mon do the rest of the job for us
            //
            status = ERROR_INVALID_FUNCTION;

            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // SplSvcResourceControl


DWORD
SplSvcResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Print Spooler resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SplSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = SplSvcGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SplSvcResourcePrivateProperties,
                                            (LPWSTR) OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // SplSvcResourceTypeControl



DWORD
SplSvcGetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
    function for resources of type Print Spooler.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    *BytesReturned = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Get the common properties.
    //
    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      SplSvcResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );

    if ( *BytesReturned == 0 ) {
        *BytesReturned = required;
    }

    return(status);

} // SplSvcGetPrivateResProperties



DWORD
SplSvcValidateUniqueProperties(
    IN HRESOURCE        hSelf,
    IN HRESOURCE        hResource,
    IN PVOID            GroupName
    )

/*++

Routine Description:

    Callback function to validate that a resources properties are unique.

    For the SplSvc resource we must ensure that only one print spooler
    resource exists in a group.

    We will never be called for the resource we are creating, only for
    other resources of the same type.

Arguments:

    hSelf     - A handle to the original resource.

    hResource - A handle to a resource of the same Type. Check against this
            to make sure the new properties do not conflict.

    lpszGroupName - The name of the Group the creating resource is in.

Return Value:

    ERROR_SUCCESS - The function completed successfully, only one print
            spooler in the given group.

    ERROR_OBJECT_ALREADY_EXISTS - The name is not unique (i.e., already have
            a print spooler in that group).

    A Win32 error code on other failure.

--*/
{
    WCHAR               groupName[MAX_GROUP_NAME_LENGTH + 1];
    DWORD               groupNameSize = MAX_GROUP_NAME_LENGTH * sizeof(WCHAR);
    CLUSTER_RESOURCE_STATE  resourceState;
    LPWSTR              lpszGroupName = (LPWSTR)GroupName;

    UNREFERENCED_PARAMETER(hSelf);

    groupName[0] = L'\0';

    resourceState =  GetClusterResourceState( hResource,
                                              NULL,
                                              0,
                                              groupName,
                                              &groupNameSize );
    if ( !*groupName ) {
        return(GetLastError());
    }

    if ( lstrcmpiW( lpszGroupName, groupName ) == 0 ) {
        return(ERROR_OBJECT_ALREADY_EXISTS);
    }

    return( ERROR_SUCCESS );

} // SplSvcValidateUniqueProperties



DWORD
SplSvcValidatePrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSPOOLER_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Print Spooler.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    SPOOLER_PARAMS  currentProps;
    SPOOLER_PARAMS  newProps;
    PSPOOLER_PARAMS pParams = NULL;
    WCHAR           groupName[MAX_GROUP_NAME_LENGTH + 1];
    DWORD           groupNameSize = MAX_GROUP_NAME_LENGTH * sizeof(WCHAR);
    CLUSTER_RESOURCE_STATE  resourceState;
    LPWSTR          nameOfPropInError;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Capture the current set of private properties from the registry.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 SplSvcResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (SplSvcLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }

    ZeroMemory( pParams, sizeof(SPOOLER_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       SplSvcResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( SplSvcResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the Default Spool Directory
        //
        if ( pParams->DefaultSpoolDirectory &&
             !ResUtilIsPathValid( pParams->DefaultSpoolDirectory ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // Make sure there is only one print spooler in this group.
        //
        resourceState =  GetClusterResourceState( ResourceEntry->hResource,
                                                  NULL,
                                                  0,
                                                  groupName,
                                                  &groupNameSize );
        if ( !*groupName ) {
            status = GetLastError();
            goto FnExit;
        }

        status = ResUtilEnumResources(ResourceEntry->hResource,
                                      CLUS_RESTYPE_NAME_PRTSPLR,
                                      SplSvcValidateUniqueProperties,
                                      (PVOID)groupName);

        if (status != ERROR_SUCCESS) {
            goto FnExit;
        }
    }

FnExit:

    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   SplSvcResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        SplSvcResourcePrivateProperties
        );

    return(status);

} // SplSvcValidatePrivateResProperties



DWORD
SplSvcSetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Print Spooler.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
//    SPOOLER_PARAMS  params;

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = SplSvcValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 NULL /*&params*/ );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyTable( ResourceEntry->ParametersKey,
                                      SplSvcResourcePrivateProperties,
                                      NULL,
                                      TRUE,    // Allow unknowns
                                      InBuffer,
                                      InBufferSize,
                                      NULL );
//    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
//                                               SplSvcResourcePrivateProperties,
//                                               NULL,
//                                               (LPBYTE) &params,
//                                               InBuffer,
//                                               InBufferSize,
//                                               (LPBYTE) &ResourceEntry->Params );

//    ResUtilFreeParameterBlock( (LPBYTE) &params,
//                               (LPBYTE) &ResourceEntry->Params,
//                               SplSvcResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( (ResourceEntry->eState == kOnline) ||
             (ResourceEntry->eState == kOnlinePending) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // SplSvcSetPrivateResProperties


/********************************************************************

    Utility functions

********************************************************************/


VOID
vEnterSem(
    VOID
    )
{
    EnterCriticalSection( &gProcessLock );
}


VOID
vLeaveSem(
    VOID
    )
{
    LeaveCriticalSection( &gProcessLock );
}

VOID
vAddRef(
    PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    vEnterSem();
    ++pSpoolerInfo->cRef;
    vLeaveSem();
}


VOID
vDecRef(
    PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    UINT uRef;

    SPLASSERT( pSpoolerInfo->cRef );

    vEnterSem();
    uRef = --pSpoolerInfo->cRef;
    vLeaveSem();

    if( !uRef ){
        vDeleteSpoolerInfo( pSpoolerInfo );
    }
}


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( SplSvcFunctionTable,
                         CLRES_VERSION_V1_00,
                         SplSvc,
                         NULL,
                         NULL,
                         SplSvcResourceControl,
                         SplSvcResourceTypeControl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\timesvc\timesvc.c ===
/*++

Copyright (c) 1992, 1996  Microsoft Corporation

Module Name:

    timesvc.c

Abstract:

    Resource DLL to control and monitor the Cluster Time Service

Author:

    Rod Gamache, 21-July-1996.

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "tsapi.h"


#define TIMESVC_PRINT printf

#define NOTIFY_KEY_RESOURCE_STATE 1

#define TimeSvcLogEvent ClusResLogEvent

#define SEMAPHORE_NAME L"Cluster$TimeSvcSemaphore"

#define MAX_RESOURCE_NAME_LENGTH 256
//
// Global Data
//

typedef struct _SERVICE_INFORMATION {
    RESOURCE_HANDLE ResourceHandle;
    HCLUSTER ClusterHandle;
    HCHANGE ClusterChange;
    HRESOURCE hResource;
} SERVICE_INFORMATION, *PSERVICE_INFORMATION;


// Global event handle

HANDLE TimeSvcSemaphore = NULL;

// The resource handle for the active instance.

PSERVICE_INFORMATION TimeSvcInfo = NULL;

// Local Computer Name

WCHAR TimeSvcLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];

// Notify thread handle

CLUS_WORKER TimeSvcNotifyHandle = {NULL, TRUE};

extern CLRES_FUNCTION_TABLE TimeSvcFunctionTable;


//
// Forward routines
//

BOOL
VerifyService(
    IN RESID Resource,
    IN BOOL IsAliveFlag
    );



BOOLEAN
WINAPI
TimeSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            TimeSvcSemaphore = CreateSemaphoreW( NULL,
                                         0,
                                         1,
                                         SEMAPHORE_NAME );
            if ( TimeSvcSemaphore == NULL ) {
                return(FALSE);
            }
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                //if the semaphore didnt exist, set its initial count to 1
                ReleaseSemaphore(TimeSvcSemaphore, 1, NULL);
            }

            break;

        case DLL_PROCESS_DETACH:
            if ( TimeSvcSemaphore ) {
                CloseHandle( TimeSvcSemaphore );
            }
            break;

        default:
            break;
    }

    return(TRUE);

} // TimeSvcDllEntryPoint



DWORD
TimeSvcNotifyThread(
    IN PCLUS_WORKER Worker,
    IN PVOID Context
    )

/*++

Routine Description:

    Thread to listen for resource change events on the Time Service resource.

Arguments:

    Worker - Supplies the worker structure

    Context - not used.

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD       status;
    HRESOURCE   resource;
    WCHAR*      buffer;
    DWORD       bufSize;
    DWORD       bufAlloced;
    DWORD       failures = 0;
    DWORD_PTR   notifyKey;
    DWORD       filter;
    CLUSTER_RESOURCE_STATE resourceState;
    DWORD       notUsed = 0;

    //
    // Now register for Notification of resource state change events.
    //
    if ( TimeSvcInfo->ClusterHandle == NULL ) {
        goto error_exit;
    }

    //
    // Create a real notification port.
    //
    if ( TimeSvcInfo->ClusterChange != NULL ) {
        CloseClusterNotifyPort( TimeSvcInfo->ClusterChange );
    }
    TimeSvcInfo->ClusterChange = CreateClusterNotifyPort( INVALID_HANDLE_VALUE,
                                              TimeSvcInfo->ClusterHandle,
                                              (DWORD) CLUSTER_CHANGE_RESOURCE_STATE |
                                              CLUSTER_CHANGE_HANDLE_CLOSE,
                                              NOTIFY_KEY_RESOURCE_STATE);

    if ( TimeSvcInfo->ClusterChange == NULL ) {
        (TimeSvcLogEvent)(
            TimeSvcInfo->ResourceHandle,
            LOG_ERROR,
            L"Failed to create notify port, status %1!u!. Stopped Listening...\n",
            GetLastError() );
        goto error_exit;
    }

    bufAlloced = 100;
    buffer = LocalAlloc( LMEM_FIXED, bufAlloced * sizeof( WCHAR ) );

    if ( buffer == NULL ) {
        (TimeSvcLogEvent)(
            TimeSvcInfo->ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a Notify buffer.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Loop listening for resource state change events...
    //

    while ( TRUE ) {
        bufSize = bufAlloced;

        status = GetClusterNotify( TimeSvcInfo->ClusterChange,
                                   &notifyKey,
                                   &filter,
                                   buffer,
                                   &bufSize,
                                   INFINITE );
        if ( ClusWorkerCheckTerminate( &TimeSvcNotifyHandle ) ) {
            break;
        }

        if ( status == ERROR_MORE_DATA ) {
            //
            // resize the buffer and loop again
            //
            
            LocalFree( buffer );

            bufSize++;          //add one for NULL
            bufAlloced = bufSize;

            buffer = LocalAlloc( LMEM_FIXED, bufAlloced * sizeof( WCHAR ) );

            if ( buffer == NULL ) {
                (TimeSvcLogEvent)(
                    TimeSvcInfo->ResourceHandle,
                    LOG_ERROR,
                    L"Failed to allocate a Notify buffer.\n");
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        } else if ( status != ERROR_SUCCESS ) {
            (TimeSvcLogEvent)(
                TimeSvcInfo->ResourceHandle,
                LOG_ERROR,
                L"Getting notification event failed, status %1!u!. \n",
                status);
            break;
        } else {
            WCHAR   lpszResourceName[MAX_RESOURCE_NAME_LENGTH];
            DWORD   bytesReturned;

            //
            // Re-fetch our name each time, in case it changes.
            //
            status = ClusterResourceControl(
                            TimeSvcInfo->hResource,
                            NULL,
                            CLUSCTL_RESOURCE_GET_NAME,
                            0,
                            0,
                            (PUCHAR)&lpszResourceName,
                            MAX_RESOURCE_NAME_LENGTH * sizeof(WCHAR),
                            &bytesReturned );
            if (status != ERROR_SUCCESS) {
                break;
            }

            if ( (filter == CLUSTER_CHANGE_RESOURCE_STATE) &&
                 (lstrcmpiW( buffer, lpszResourceName ) == 0) ) {
                bufSize = bufAlloced;
                resourceState = GetClusterResourceState( TimeSvcInfo->hResource,
                                                         buffer,
                                                         &bufSize,
                                                         NULL,
                                                         &notUsed );
                if ( resourceState == ClusterResourceOnline ) {
                    status = TSNewSource( TimeSvcLocalComputerName,
                                          buffer,
                                          0 );
                    (TimeSvcLogEvent)(
                        TimeSvcInfo->ResourceHandle,
                        LOG_INFORMATION,
                        L"Status of Time Service request to sync from node %1!ws! is %2!u!.\n",
                        buffer,
                        status);
                }
            } else if (filter == CLUSTER_CHANGE_HANDLE_CLOSE) {
                //
                // Clean up and exit.
                //
                break;
            }
        }
    }

error_exit:

    // Don't close the ClusterChange notification handle, let the close
    // routine do that!

    return(ERROR_SUCCESS);

} // TimeSvcNotifyThread



RESID
WINAPI
TimeSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Cluster Time Service resource.
    This routine gets a handle to the service controller, if we dont already have one,
    and then gets a handle to the specified service.  The service handle is saved
    in the TimeSvcInfo structure.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    ULONG   index = 1;
    DWORD   status;
    HKEY    parametersKey = NULL;
    PSERVICE_INFORMATION serviceInfo = NULL;
    DWORD   computerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR   nodeName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   nodeNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD   notUsed = 0;
    CLUSTER_RESOURCE_STATE resourceState;
    DWORD   threadId;
    DWORD   nameLength;

    (TimeSvcLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Creating resource.\n" );

    //
    // Make sure this is the only time we've been called!
    //
    if ( WaitForSingleObject( TimeSvcSemaphore, 0 ) == WAIT_TIMEOUT ) {
        //
        // A version of this service is already running
        //
        (TimeSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Service is already running.\n" );
        status = ERROR_SERVICE_ALREADY_RUNNING;
        goto error_exit2;
    }

    serviceInfo = LocalAlloc( LMEM_FIXED, sizeof(SERVICE_INFORMATION) );
    if ( serviceInfo == NULL ) {
        (TimeSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a service info structure.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( serviceInfo, sizeof(SERVICE_INFORMATION) );

    //
    // Get the local computer name.
    //
    status = GetComputerNameW( TimeSvcLocalComputerName, &computerNameSize );
    if ( !status ) {
        (TimeSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to get local computer name, error %1!u!.\n",
            status);
        goto error_exit;
    }

    if ( serviceInfo->ClusterHandle == NULL ) {
        serviceInfo->ClusterHandle = OpenCluster( NULL );
    }
    if ( serviceInfo->ClusterHandle == NULL ) {
        status = GetLastError();
        (TimeSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open local cluster, error %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Sync our time from whatever system currently 'owns' the time service.
    //
    if ( serviceInfo->hResource == NULL ) {
        serviceInfo->hResource = OpenClusterResource( serviceInfo->ClusterHandle,
                                                      ResourceName );
    }
    if ( serviceInfo->hResource == NULL ) {
        status = GetLastError();
        (TimeSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open Time Service resource.\n");
        goto error_exit;
    }

    resourceState = GetClusterResourceState( serviceInfo->hResource,
                                             nodeName,
                                             &nodeNameSize,
                                             NULL,
                                             &notUsed );
    if ( resourceState == ClusterResourceOnline ) {
        status = TSNewSource( TimeSvcLocalComputerName,
                              nodeName,
                              0 );
    }

    //
    // Create a notification thread to watch if the time service moves!
    //
    ClusWorkerTerminate(&TimeSvcNotifyHandle);
    status = ClusWorkerCreate(&TimeSvcNotifyHandle,
                              TimeSvcNotifyThread,
                              serviceInfo);
    if ( status != ERROR_SUCCESS ) {
        (TimeSvcLogEvent)(
            serviceInfo->ResourceHandle,
            LOG_ERROR,
            L"Error creating notify thread, status %1!u!.\n",
            status );
        goto error_exit;
    }

    TimeSvcInfo = serviceInfo;
    serviceInfo->ResourceHandle = ResourceHandle;

    return((RESID)serviceInfo);

error_exit:

    ReleaseSemaphore ( TimeSvcSemaphore, 1 , 0 );
    if ( TimeSvcInfo == serviceInfo ) {
        TimeSvcInfo = NULL;
    }

error_exit2:

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }

    if ( serviceInfo != NULL ) {
        if ( serviceInfo->hResource ) {
            CloseClusterResource( serviceInfo->hResource );
        }
        if ( serviceInfo->ClusterHandle ) {
            CloseCluster( serviceInfo->ClusterHandle );
        }
        LocalFree( serviceInfo );
    }

    SetLastError(status);

    return(0);

} // TimeSvcOpen


DWORD
WINAPI
TimeSvcOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Cluster Time Service resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{

    if ( TimeSvcInfo == NULL ) {
        TIMESVC_PRINT("TimeSvc: Online request for a nonexistent resource id 0x%p.\n",
            Resource);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( TimeSvcInfo != (PSERVICE_INFORMATION)Resource ) {
        (TimeSvcLogEvent)(
            TimeSvcInfo->ResourceHandle,
            LOG_ERROR,
            L"Online service info checked failed! Resource = %1!lx!.\n",
            Resource);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    return(ERROR_SUCCESS);

} // TimeSvcOnline


VOID
WINAPI
TimeSvcTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for Cluster Time Service resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    if ( TimeSvcInfo == NULL ) {
        TIMESVC_PRINT("TimeSvc: Offline request for a nonexistent resource id 0x%p.\n",
            Resource);
        return;
    }

    if ( TimeSvcInfo != (PSERVICE_INFORMATION)Resource ) {
        (TimeSvcLogEvent)(
            TimeSvcInfo->ResourceHandle,
            LOG_ERROR,
            L"Offline service info check failed! Resource = %1!u!.\n",
            Resource);
        return;
    }

    (TimeSvcLogEvent)(
        TimeSvcInfo->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request, returning.\n");

    return;

} // TimeSvcTerminate



DWORD
WINAPI
TimeSvcOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for Cluster Time Service resource.

Arguments:

    Resource - supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    TimeSvcTerminate( Resource );

    return(ERROR_SUCCESS);

} // Offline


BOOL
WINAPI
TimeSvcIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for Cluster Time Service resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{

    return( TRUE );

} // TimeSvcIsAlive



BOOL
WINAPI
TimeSvcLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for Cluster Time Service resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return( TRUE );

} // TimeSvcLooksAlive



VOID
WINAPI
TimeSvcClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for Cluster Time Service resource.
    This routine will stop the service, and delete the cluster
    information regarding that service.

Arguments:

    Resource - supplies resource id to be closed

Return Value:

    None.

--*/

{
    DWORD   status;
    PSERVICE_INFORMATION serviceInfo = NULL;

    serviceInfo = (PSERVICE_INFORMATION)Resource;

    if ( serviceInfo == NULL ) {
        TIMESVC_PRINT("TimeSvc: Close request for a nonexistent resource id 0x%p\n",
            Resource);
        return;
    }

    (TimeSvcLogEvent)(
        serviceInfo->ResourceHandle,
        LOG_INFORMATION,
        L"Close request for %1!lx!, TimeSvcInfo = %2!lx!.\n",
        serviceInfo, TimeSvcInfo);

    //
    // Shut it down if it's on line
    //

    TimeSvcTerminate(Resource);

    if ( serviceInfo->ClusterHandle ) {
        CloseCluster( serviceInfo->ClusterHandle );
    }

    if ( serviceInfo == TimeSvcInfo ) {
        ClusWorkerTerminate( &TimeSvcNotifyHandle );
        TimeSvcInfo = NULL;
        //SetEvent ( TimeSvcSemaphore );
        ReleaseSemaphore ( TimeSvcSemaphore, 1 , 0 );
    }

    if ( serviceInfo->hResource ) {
        CloseClusterResource( serviceInfo->hResource );
    }

    if ( serviceInfo->ClusterChange != NULL ) {
        CloseClusterNotifyPort( serviceInfo->ClusterChange );
    }

    LocalFree( serviceInfo );

    return;

} // TimeSvcClose


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( TimeSvcFunctionTable,
                         CLRES_VERSION_V1_00,
                         TimeSvc,
                         NULL,
                         NULL,
                         NULL,
                         NULL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\spooler\spltest\spltest.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    spltest.c

Abstract:

    Test program for enabling a spooler group.

Author:

    Albert Ting (AlbertT)  2-Oct-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop


MODULE_DEBUG_INIT( DBG_ERROR|DBG_WARN|DBG_TRACE, DBG_ERROR );

#ifdef __cplusplus
extern "C"
#endif
INT _CRTAPI1
main(
    INT argc,
    CHAR* argv[]
    )
{
    if( !bSplLibInit() )
    {
        return 1;
    }

    BOOL bOpen = FALSE;
    HANDLE hSpooler = NULL;

    HANDLE hStdIn = GetStdHandle( STD_INPUT_HANDLE );

    SetConsoleMode( hStdIn, ENABLE_PROCESSED_INPUT );

    for( ; ; )
    {
        TCHAR c;
        DWORD dwRead;

        printf( "SplTest> " );

        TStatusB bStatus;
        bStatus DBGCHK = ReadConsole( hStdIn,
                                      &c,
                                      1,
                                      &dwRead,
                                      NULL );


        c = TCHAR( CharLower( LPTSTR( c )));

        switch( c )
        {
        case '?':

            printf( "Usage: spltest {action}\n"
                    "       Actions: o - Open\n"
                    "                c - Close\n"
                    "                a - IsAlive\n" );
            break;

        case 'q':

            printf( "q: Exiting\n" );
            return 0;

        case 'o':
        {
            if( bOpen )
            {
                printf( "o: Error: already open %x\n", hSpooler );
                break;
            }


            TStatusB bStatus;
            bStatus DBGCHK = ClusterSplOpen( NULL,
                                             TEXT( "Spooler" ),
                                             &hSpooler,
                                             TEXT( "alberttc,," ),
                                             TEXT( ",1.2.3.4," ));

            if( bStatus )
            {
                printf( "o: Spooler albertt2 NULL opened %x\n", hSpooler );
                bOpen = TRUE;
            }
            else
            {
                printf( "o: Error: %d\n", GetLastError() );
            }
            break;
        }
        case 'c':
        {
            if( !bOpen )
            {
                printf( "c: Error: not open\n" );
                break;
            }

            TStatusB bStatus;
            bStatus DBGCHK = ClusterSplClose( hSpooler );

            if( bStatus )
            {
                printf( "c: Spooler closed %x.\n", hSpooler );
            }
            else
            {
                printf( "c: Error: closing %x %d\n", hSpooler, GetLastError() );
            }

            bOpen = FALSE;

            break;
        }
        case 'a':
        {

            TStatusB bStatus;
            bStatus DBGCHK = ClusterSplIsAlive( hSpooler );

            if( bStatus )
            {
                printf( "a: Spooler alive %x.\n", hSpooler );
            }
            else
            {
                printf( "a: Error: not alive %x %d (%x)\n",
                        hSpooler,
                        GetLastError(),
                        GetLastError() );
            }
            break;
        }
        default:

            printf( "%c: Unknown command\n", c );
            break;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\evntlist.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    evntlist.c

Abstract:

    This module contains routines to process the Poll Event List.

Author:

    Rod Gamache (rodga) 9-April-1996

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include "stdio.h"

#define RESMON_MODULE RESMON_MODULE_EVNTLIST

//
// Global data defined by this module
//
LIST_ENTRY  RmpEventListHead;           // Event list (under construction)

//
// Function prototypes local to this module
//



DWORD
RmpAddPollEvent(
    IN PPOLL_EVENT_LIST EventList,
    IN HANDLE EventHandle,
    IN PRESOURCE Resource OPTIONAL
    )

/*++

Routine Description:

    Add a new EventHandle to the list of events in the Poll EventList.

Arguments:

    EventList - The event list associated with this event handle and resource.

    EventHandle - The new event handle to be added.

    Resource - The resource associated with the event handle.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    ERROR_DUPLICATE_SERVICE_NAME - if the event handle is already in the list
    Win32 error code on other failures.

Note:

    Since the resource is optional, we cannot get the event list from the
    resource.

--*/

{
    DWORD i;
    DWORD status;
    PLIST_ENTRY listEntry;

    CL_ASSERT( EventHandle != NULL );

    if ( ARGUMENT_PRESENT( Resource ) ) {
        CL_ASSERT( Resource->EventHandle == NULL );
    }

    AcquireEventListLock( EventList );

    //
    // First, make sure this handle isn't already present.
    //

    for ( i = 0; i < EventList->EventCount; i++ ) {
        if ( EventHandle == EventList->Handle[i] ) {
            ReleaseEventListLock( EventList );
            return(ERROR_DUPLICATE_SERVICE_NAME);
        }
    }

    //
    // Now make sure that we don't have too many events in this list!
    //

    CL_ASSERT ( EventList->EventCount < MAX_HANDLES_PER_THREAD );

    //
    // Now add our event to our list.
    //

    EventList->Handle[EventList->EventCount] = EventHandle;
    EventList->Resource[EventList->EventCount] = Resource;

    if ( ARGUMENT_PRESENT( Resource ) ) {
        Resource->EventHandle = EventHandle;
    }

    ++EventList->EventCount;
    ReleaseEventListLock( EventList );

    //
    // Now wake up our poller thread to get the new list.
    // Currently, the Online routine will pulse the poller thread - so
    // no need to do it here.

    //SignalPoller( EventList );

    return(ERROR_SUCCESS);

} // RmpAddPollEvent



DWORD
RmpRemovePollEvent(
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    Remove an EventHandle from the list of events in the Poll EventList.

Arguments:

    EventHandle - The event handle to be removed.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    ERROR_RESOURCE_NOT_FOUND - if the EventHandle is not in the list.

Note:

    We can only add to the event lists listhead - we can never remove a
    POLL_EVENT_LIST structure from the list!

--*/

{
    DWORD i;
    DWORD j;
    PRESOURCE resource;
    PPOLL_EVENT_LIST eventList;
    PLIST_ENTRY listEntry;

    CL_ASSERT( ARGUMENT_PRESENT(EventHandle) );

    AcquireListLock();

    for ( listEntry = RmpEventListHead.Flink;
          listEntry != &RmpEventListHead;
          listEntry = listEntry->Flink ) {
        eventList = CONTAINING_RECORD( listEntry, POLL_EVENT_LIST, Next );

        AcquireEventListLock( eventList );

        //
        // Find the entry in the event list.
        //

        for ( i = 0; i < eventList->EventCount; i++ ) {
            if ( eventList->Handle[i] == EventHandle ) {
                break;
            }
        }

        if ( i < eventList->EventCount ) {
            break;
        }

        ReleaseEventListLock( eventList );
    }

    ReleaseListLock();

    //
    // If we hit the end of the list without finding our event, return error.
    //

    if ( (listEntry == &RmpEventListHead) || (i >= eventList->EventCount) ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Otherwise, collapse lists, but first save pointer to the resource.
    //

    resource = eventList->Resource[i];
    CL_ASSERT( resource != NULL );

    for ( j = i; j < (eventList->EventCount-1); j++ ) {
        eventList->Handle[j] = eventList->Handle[j+1];
        eventList->Resource[j] = eventList->Resource[j+1];
    }

    --eventList->EventCount;
    eventList->Handle[eventList->EventCount] = NULL;
    eventList->Resource[eventList->EventCount] = NULL;

    //
    // Event handle is of no use anymore until Online returns a new one.
    // N.B. We do not close the event handle, since the resource DLL is
    // responsible for taking care of this.
    //
    CL_ASSERT( EventHandle == resource->EventHandle );
    resource->EventHandle = NULL;

    ReleaseEventListLock( eventList );

    //
    // Now wake up the poll thread to get the new list.
    //
    RmpSignalPoller( eventList );

    return(ERROR_SUCCESS);

} // RmpRemovePollEvent



PVOID
RmpCreateEventList(
    VOID
    )

/*++

Routine Description:

    Allocates, initializes and inserts a new event list.

Arguments:

    None.

Returns:

    NULL - we failed.
    non-NULL - a pointer to the new event list.

    If NULL, it does a SetLastError() to indicate the failure.

Notes:

    This routine assumes that the EventListLock is held during this call.
    This routine will start a new event processing thread that will handle
    the list.

    There is one ListNotify event and one BucketListHead per event list!

--*/

{
    PPOLL_EVENT_LIST newEventList=NULL;
    DWORD   threadId;
    DWORD   dwError = ERROR_SUCCESS;

    AcquireListLock();

    if ( RmpShutdown || (RmpNumberOfThreads >= MAX_THREADS) ) {
        dwError = ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED;
        goto FnExit;
    }

    newEventList = LocalAlloc(LMEM_ZEROINIT,
                              sizeof( POLL_EVENT_LIST ));

    if ( newEventList == NULL ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Initialize the newEventList.
    //

    InitializeListHead( &newEventList->BucketListHead );
    InitializeCriticalSection( &newEventList->ListLock );

    //
    // Create a list notification event.
    //

    newEventList->ListNotify = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( newEventList->ListNotify == NULL ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Now create a thread and pass this Event List to it.
    //

    newEventList->ThreadHandle = CreateThread(NULL,
                                              0,
                                              RmpPollerThread,
                                              newEventList,
                                              0,
                                              &threadId);
    if ( newEventList->ThreadHandle == NULL ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Tally one more event list, and insert onto list of event lists.
    //

    RmpWaitArray[RmpNumberOfThreads] = newEventList->ThreadHandle;
    ++RmpNumberOfThreads;
    InsertTailList( &RmpEventListHead, &newEventList->Next );

    //
    // Signal the main thread to rewait and watch the new thread.
    //

    SetEvent( RmpRewaitEvent );


FnExit:
    ReleaseListLock();
    if (dwError != ERROR_SUCCESS)
    {
        //we failed, release any resource we might have allocated
        if (newEventList) 
        {
            if (newEventList->ListNotify) CloseHandle( newEventList->ListNotify );
            RmpFree( newEventList );
        }
        SetLastError(dwError);
    }
    return(newEventList);

} // RmpCreateEventList



DWORD
RmpResourceEventSignaled(
    IN PPOLL_EVENT_LIST EventList,
    IN DWORD EventIndex
    )

/*++

Routine Description:

    A resource event has been signaled. This indicates that the specified
    resource has failed.

Arguments:

    EventList - the waiting event list.
    EventIndex - index of the event that was signaled.

Return Value:

    ERROR_SUCCESS - if the request is successful.

--*/

{
    PRESOURCE resource;

    //
    //  Don't post any events if resmon is shutting down. This causes cluster service policies
    //  to be triggered while resmon is shutting down and that causes bogus RPC failures in
    //  cluster service.
    //
    if ( RmpShutdown ) return ( ERROR_SUCCESS );

    CL_ASSERT( EventIndex <= MAX_HANDLES_PER_THREAD );

    //
    // Get our resource.
    //

    resource = EventList->Resource[EventIndex];

    if ( resource == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Remove the failed resource from the event notification list.
    // N.B. we do not need to acquire the eventlist lock because there is
    // only one thread that can ever touch the waiting event list!
    //

    if ( resource->EventHandle ) {
        RmpRemovePollEvent( resource->EventHandle );
    }

    //
    // Post the failure of the resource, if the resource is not being taken
    // offline.
    //
    if ( resource->State != ClusterResourceOffline ) {
        resource->State = ClusterResourceFailed;
        RmpPostNotify(resource, NotifyResourceStateChange);
    }

    return(ERROR_SUCCESS);

} // RmpResourceEventSignaled
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\spooler\splsvc\spooler.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    spooler.c

Abstract:

    Handle spooler interaction via RPC.

    Public functions from this module:

        SpoolerOnline
        SpoolerOffline
        SpoolerStart
        SpoolerStop
        SpoolerIsAlive
        SpoolerLooksAlive

    There is a little interface bleed here--this module is aware
    of the cluster SetResourceStatus callback.

Author:

    Albert Ting (AlbertT)  23-Sept-96

Revision History:
    Khaled Sedky (KhaledS) 1998-2001

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "splsvc.hxx"
#include "clusinfo.hxx"
#include "spooler.hxx"
#include "winsprlp.h"

#define TERMINATETHREADONCHECK           \
if ( ClusWorkerCheckTerminate( Worker )) \
{                                        \
   goto Done;                            \
}


/********************************************************************

    Conditional compile defines:

    USE_ISALIVE_THREAD

        Causes the resource DLL to wait on a thread each time the
        IsAlive all is made.  This thread wait for ISALIVE_WAIT_TIME
        to see if the RPC call to the spooler successfully completes.
        If it does not, then we assume that the spooler is deadlocked.

        This is off because it kills the spooler if it's slow or
        being debugged.  There are no scenarios where we should
        be deadlocked (or hold the critical section while doing a
        slow operation like hitting the net).  During stress, however,
        we may appear deadlocked.

    USE_OFFLINE_HACK

        Causes an Offline call to terminate and restart the spooler.
        This will be turned on until we have clean shutdown code.

    USE_STUBS

        Causes us to use stubbed out winspool.drv calls.  Usefule if
        the new winspool.drv isn't available and you want to compile
        a DLL which simulates talking to the spooler.

********************************************************************/

//#define USE_ISALIVE_THREAD
//#define USE_OFFLINE_HACK
//#define USE_STUBS          

#define POLL_SLEEP_TIME 500         // Service control poll time.
#define STATUS_SLEEP_TIME 1500
#define ISALIVE_WAIT_TIME 2000      // Time before spooler is deadlocked.

LPCTSTR gszSpooler = TEXT( "Spooler" );
SC_HANDLE ghSpoolerService;
SC_HANDLE ghSC;


/********************************************************************

    Stubs

********************************************************************/

#ifdef USE_STUBS

BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )
{
    UNREFERENCED_PARAMETER( pszServer );
    UNREFERENCED_PARAMETER( pszResource );
    UNREFERENCED_PARAMETER( pszName );
    UNREFERENCED_PARAMETER( pszAddress );
    *phSpooler = (HANDLE)31;
    Sleep( 3200 );
    return TRUE;
}

BOOL
ClusterSplClose(
    HANDLE hSpooler
    )
{
    UNREFERENCED_PARAMETER( hSpooler );
    SPLASSERT( hSpooler==(HANDLE)31 );
    Sleep( 6000 );
    return TRUE;
}

BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    )
{
    UNREFERENCED_PARAMETER( hSpooler );
    Sleep( 500 );
    return TRUE;
}

#endif

/********************************************************************

    Utility functions

********************************************************************/

BOOL
QuerySpoolerState(
    OUT PDWORD pdwState
    )

/*++

Routine Description:

    Checks the current state of the spooler service.

Arguments:

    pdwState - Receives the state of the spooler.

Return Value:

    TRUE - success
    FALSE - failure.  *pdwState set to SERVICE_STOPPED


--*/

{
    SERVICE_STATUS ServiceStatus;

    SPLASSERT( ghSpoolerService );

    if( !QueryServiceStatus( ghSpoolerService,
                             &ServiceStatus)) {

        DBGMSG( DBG_WARN,
                ( "SpoolerStatus: QueryServiceStatus failed %d\n",
                  GetLastError() ));

        *pdwState = SERVICE_STOPPED;
        return FALSE;
    }

    *pdwState = ServiceStatus.dwCurrentState;

    return TRUE;
}

DWORD
WINAPI
SpoolerStatusReportThread(
    PCLUS_WORKER Worker,
    PVOID        pStatusThreadInfo
    )
{
    HANDLE hStatusEvent = ((STATUSTHREAD_INFO *)pStatusThreadInfo)->hStatusEvent;
    PSPOOLER_INFORMATION pSpoolerInfo = ((STATUSTHREAD_INFO *)pStatusThreadInfo)->pSpoolerInfo;
    PRESOURCE_STATUS pResourceStatus  = ((STATUSTHREAD_INFO *)pStatusThreadInfo)->pResourceStatus;

    while(WaitForSingleObject(hStatusEvent,STATUS_SLEEP_TIME) == WAIT_TIMEOUT)
    {
         pResourceStatus->CheckPoint++;
         (pSpoolerInfo->pfnSetResourceStatus)(pSpoolerInfo->ResourceHandle,
                                              pResourceStatus);
    }
    return (0);
}



/********************************************************************

    Worker threads for SpoolerOnline/Offline.

********************************************************************/

#ifdef USE_ISALIVE_THREAD

DWORD
WINAPI
SpoolerIsAliveThread(
    PVOID pSpoolerInfo_
    )

/*++

Routine Description:

    Async thread to online the resource instance.

    Assumes vAddRef has been called already; we will call vDecRef
    when we are done.

Arguments:

Return Value:

    ERRROR_SUCCESS - Spooler still alive.

    dwError - Spooler dead.

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo = (PSPOOLER_INFORMATION)pSpoolerInfo_;
    HANDLE hSpooler = pSpoolerInfo->hSpooler;
    BOOL bIsAlive;

    //
    // We've stored all the information we need from pSpoolerInfo;
    // decrement the refcount.
    //
    vDecRef( pSpoolerInfo );

    //
    // RPC to spooler.
    //
    SPLASSERT( hSpooler );

    bIsAlive = ClusterSplIsAlive( hSpooler );

    DBGMSG( DBG_TRACE,
            ( "SpoolerIsAliveThread: return status: h=%x s=%x,%d\n",
              hSpooler, bIsAlive, GetLastError() ));

    if( bIsAlive ){
        return ERROR_SUCCESS;
    }

    //
    // Spooler is dead--return some error code.
    //
    return ERROR_INVALID_PARAMETER;
}

#endif

DWORD
SpoolerOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PVOID pSpoolerInfo_
    )
/*++

Routine Description:

    Async thread to online the resource instance.

    Assumes vAddRef has been called already; we will call vDecRef
    when we are done.

Arguments:

Return Value:

--*/

{
    DWORD  dwState;
    DWORD  dwStatus;
    BOOL   bStatus = FALSE;
    HANDLE hStatusEvent   = NULL;
    
    RESOURCE_STATUS    ResourceStatus;
    STATUSTHREAD_INFO  StatusThreadInfo;

    PSPOOLER_INFORMATION pSpoolerInfo = (PSPOOLER_INFORMATION)pSpoolerInfo_;

    ResUtilInitializeResourceStatus( &ResourceStatus );

    ResourceStatus.ResourceState = ClusterResourceOnlinePending;
    ResourceStatus.CheckPoint = 1;
    (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                          &ResourceStatus );

    TERMINATETHREADONCHECK

    //
    // Get needed information about net name and tcpip address.
    //
    if( !bGetClusterNameInfo( pSpoolerInfo->pszResource,
                              &pSpoolerInfo->pszName,
                              &pSpoolerInfo->pszAddress )){

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Unable to retrieve Name and TcpIp address.\n" );

        DBGMSG( DBG_ERROR, ( "SplSvcOpen: Couldn't retrieve name/tcpip addr\n" ));
        goto Done;
    }

    TERMINATETHREADONCHECK


    //
    // Ensure the spooler is started.
    //
    bStatus = SpoolerStart( pSpoolerInfo );

    if( !bStatus ){

        DBGMSG( DBG_WARN, ( "SpoolerOnlineThread: SpoolerStart failed\n" ));
        goto Done;
    }

    while (TRUE)  {

        if( !QuerySpoolerState( &dwState )){

            dwStatus = GetLastError();

            (pSpoolerInfo->pfnLogEvent)(
                pSpoolerInfo->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                dwStatus);

            goto Done;
        }



        if( dwState != SERVICE_START_PENDING ){
            break;
        }
        else
        {
            ResourceStatus.CheckPoint ++;
            (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                                  &ResourceStatus );
            TERMINATETHREADONCHECK
        }

        Sleep( POLL_SLEEP_TIME );
    }

    if( dwState != SERVICE_RUNNING) {

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Failed to start service. Error: %1!u!.\n",
            ERROR_SERVICE_NEVER_STARTED);

        dwStatus = ERROR_SERVICE_NEVER_STARTED;
        goto Done;
    }

    //
    // Since we have to report the status of being online pending
    // to the cluster everywhile in order not to be considered failing
    // and because ClusterSplOpen takes a while and it is a synchronous 
    // call , we hae to create this Status Thread which would keep 
    // reporting the status to the cluster in the back ground.
    //
    hStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(hStatusEvent)
    {

        StatusThreadInfo.pResourceStatus = &ResourceStatus;
        StatusThreadInfo.hStatusEvent    = hStatusEvent;
        StatusThreadInfo.pSpoolerInfo    = pSpoolerInfo;

        dwStatus = ClusWorkerCreate(&pSpoolerInfo->OnLineStatusThread,
                                    SpoolerStatusReportThread,
                                    (PVOID)&StatusThreadInfo);

        if( dwStatus != ERROR_SUCCESS )
        {
            //
            // In this case we will unfortunatly fall out of the Reporting thread and 
            // behave the same as previously , which might cause the resource to fail
            // since it is not reporing the status properly (not likely to happen)
            //
            DBGMSG( DBG_WARN,
                    ( "SpoolerOnlineThread : ClusWorkerCreate(SpoolerStatusReportThread) failed %d\n", dwStatus ));
        }
    }
    else
    {
        //
        // In this case we will unfortunatly fall out of the Reporting thread and 
        // behave the same as previously , which might cause the resource to fail
        // since it is not reporing the status properly (not likely to happen)
        //
        DBGMSG( DBG_WARN,
                ( "SpoolerOnlineThread: Create StatusEvent failed %d\n", GetLastError() ));
    }

    //
    // RPC to spooler.
    //
    bStatus = ClusterSplOpen( NULL,
                              pSpoolerInfo->pszResource,
                              &pSpoolerInfo->hSpooler,
                              pSpoolerInfo->pszName,
                              pSpoolerInfo->pszAddress );

    if(hStatusEvent && pSpoolerInfo->OnLineStatusThread.hThread)
    {
        SetEvent(hStatusEvent);
    }


    SPLASSERT( bStatus || !pSpoolerInfo->hSpooler );

    DBGMSG( DBG_TRACE,
            ( "SpoolerOnlineThread: "TSTR" "TSTR" "TSTR" h=%x s=%x,d\n",
              DBGSTR( pSpoolerInfo->pszResource ),
              DBGSTR( pSpoolerInfo->pszName ),
              DBGSTR( pSpoolerInfo->pszAddress ),
              pSpoolerInfo->hSpooler,
              bStatus,
              GetLastError() ));

Done:

    //
    // If we are terminating, then we should not set any state
    // and avoid calling SetResourceStatus since clustering doesn't
    // think we are pending online anymore.
    //
    if( pSpoolerInfo->eState != kTerminate ){

        if( bStatus ){

            //
            // Spooler successfully onlined.
            //
            pSpoolerInfo->eState = kOnline;
            ResourceStatus.ResourceState = ClusterResourceOnline;
        }
        else
        {
           ResourceStatus.ResourceState = ClusterResourceFailed;
        }

        ResourceStatus.CheckPoint++;
        (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                              &ResourceStatus );
    }

    vDecRef( pSpoolerInfo );
    if(hStatusEvent)
    {
        CloseHandle(hStatusEvent);
    }

    ClusWorkerTerminate(&(pSpoolerInfo->OnLineStatusThread));

    return 0;
}

DWORD
SpoolerClose(
    PSPOOLER_INFORMATION pSpoolerInfo,
    EShutDownMethod ShutDownMethod
)
{
    CLUSTER_RESOURCE_STATE ClusterResourceState;
    STATUSTHREAD_INFO      StatusThreadInfo;
    RESOURCE_STATUS        ResourceStatus;
    BOOL                   bStatus      = TRUE;
    HANDLE                 hStatusEvent = NULL;
    HANDLE                 hSpooler     = NULL;
    DWORD                  dwStatus     = ERROR_SUCCESS;

    ResUtilInitializeResourceStatus( &ResourceStatus );

    ResourceStatus.CheckPoint = 1;
    ResourceStatus.ResourceState = ClusterResourceOfflinePending;
    (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                          &ResourceStatus );

    vEnterSem();
    {
        ClusterResourceState = pSpoolerInfo->ClusterResourceState;

        if( pSpoolerInfo->hSpooler )
        {
            hSpooler = pSpoolerInfo->hSpooler;
            pSpoolerInfo->hSpooler = NULL;
        }
    }
    vLeaveSem();
    
    if( hSpooler )
    {
         //
         // Since we have to report the status of being offline pending
         // to the cluster everywhile in order not to be considered failing
         // and because ClusterSplClose takes a while and it is a synchronous 
         // call , we have to create this Status Thread which would keep 
         // reporting the status to the cluster in the back ground.
         //
         hStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
         if(hStatusEvent)
         {
     
             StatusThreadInfo.pResourceStatus = &ResourceStatus;
             StatusThreadInfo.hStatusEvent    = hStatusEvent;
             StatusThreadInfo.pSpoolerInfo    = pSpoolerInfo;
     
             dwStatus = ClusWorkerCreate((ShutDownMethod == kTerminateShutDown) ? 
                                         &pSpoolerInfo->TerminateStatusThread :
                                         &pSpoolerInfo->OffLineStatusThread,
                                         SpoolerStatusReportThread,
                                         (PVOID)&StatusThreadInfo);

             if( dwStatus != ERROR_SUCCESS )
             {
                 //
                 // In this case we will unfortunatly fall out of the Reporting thread and 
                 // behave the same as previously , which might cause the resource to fail
                 // since it is not reporing the status properly (not likely to happen)
                 //
                 DBGMSG( DBG_WARN,
                         ( "SpoolerClose : ClusWorkerCreate(SpoolerStatusReportThread) failed %d\n", dwStatus ));
                 dwStatus = ERROR_SUCCESS;
             }
         }
         else
         {
             //
             // In this case we will unfortunatly fall out of the Reporting thread and 
             // behave the same as previously , which might cause the resource to fail
             // since it is not reporing the status properly (not likely to happen)
             //
             dwStatus = GetLastError();
             DBGMSG( DBG_WARN,
                     ( "SpoolerClose: Create StatusEvent failed %d\n", GetLastError() ));
         }

         if(ShutDownMethod == kOffLineShutDown)
         {
             ClusWorkerTerminate(&(pSpoolerInfo->OnlineThread));
         }

         //
         // RPC to Terminate
         //
         bStatus = ClusterSplClose( hSpooler );

         if(hStatusEvent && 
            (ShutDownMethod == kTerminateShutDown) ? 
            pSpoolerInfo->TerminateStatusThread.hThread :
            pSpoolerInfo->OffLineStatusThread.hThread)
         {
             SetEvent(hStatusEvent);
         }

         DBGMSG( DBG_TRACE,
                 ( "SpoolerClose: h=%x, s=%x,%d\n",
                   hSpooler, bStatus, GetLastError() ));
    }

    if( bStatus ){

        ResourceStatus.ResourceState = ClusterResourceState;
        pSpoolerInfo->hSpooler = NULL;
    }
    else
    {
        ResourceStatus.ResourceState = ClusterResourceFailed;
        dwStatus = ERROR_FUNCTION_FAILED;
    }

    ClusWorkerTerminate((ShutDownMethod == kTerminateShutDown) ? 
                        &(pSpoolerInfo->TerminateStatusThread) :
                        &(pSpoolerInfo->OffLineStatusThread));
    //
    // If we are terminating, don't call SetResourceStatus since
    // clustering doesn't expect this after a terminate call.
    //
    if( pSpoolerInfo->eState != kTerminate )
    {
        ResourceStatus.CheckPoint++;
        (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                              &ResourceStatus );

        pSpoolerInfo->eState = kOffline;
    }

    if(hStatusEvent)
    {
        CloseHandle(hStatusEvent);
    }

    return dwStatus;
}


DWORD
WINAPI
SpoolerOfflineThread(
    IN PCLUS_WORKER Worker,
    IN PVOID pSpoolerInfo_
    )
{
    PSPOOLER_INFORMATION   pSpoolerInfo = (PSPOOLER_INFORMATION)pSpoolerInfo_;
    SpoolerClose(pSpoolerInfo,kOffLineShutDown);
    vDecRef( pSpoolerInfo );
    return 0;
}

DWORD
WINAPI
SpoolerTerminateSync(
    IN PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    return SpoolerClose(pSpoolerInfo,kTerminateShutDown);
}



/********************************************************************

    Spooler routines.

********************************************************************/

BOOL
SpoolerOnline(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Put the spooler service online.  This call completes asynchronously;
    it will use the callback in pSpoolerInfo to update the status.

Arguments:


Return Value:


--*/

{
    DWORD  status=ERROR_SUCCESS;

    pSpoolerInfo->hSpooler = NULL;
    pSpoolerInfo->eState = kOnlinePending;

    vAddRef( pSpoolerInfo );

    //
    // Create a worker thread to start the spooler and poll.
    //
    status = ClusWorkerCreate(&pSpoolerInfo->OnlineThread,
                              SpoolerOnlineThread,
                              (PVOID)pSpoolerInfo
                             );

    if( status != ERROR_SUCCESS ){

        DBGMSG( DBG_WARN,
                ( "SpoolerOnline: ClusWorkerCreate failed %d\n", status ));

        vDecRef( pSpoolerInfo );

        return FALSE;
    }
    return TRUE;
}

DWORD
SpoolerOffline(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Put the spooler service offline.  This call completes asynchronously;
    it will use the callback in pSpoolerInfo to update the status.

Arguments:

Return Value:

--*/

{
    DWORD status = ERROR_SUCCESS;

    DBGMSG( DBG_WARN, ( ">>> SpoolerOffline: called %x\n", Resid ));

    vAddRef( pSpoolerInfo );

    pSpoolerInfo->eState = kOfflinePending;

    //
    // Create a worker thread to stop the spooler.
    //
    if((status = ClusWorkerCreate(&pSpoolerInfo->OfflineThread,
                                  SpoolerOfflineThread,
                                  (PVOID)pSpoolerInfo
                                  ))!=ERROR_SUCCESS)
    {
        DBGMSG( DBG_WARN,
                ( "SpoolerOffline: ClusWorkerCreate failed %d\n", status ));
        DBGMSG( DBG_ERROR, 
                ( "SpoolerOffline: Unable to offline spooler\n" ));
        SPLASSERT(status == ERROR_SUCCESS)
        vDecRef( pSpoolerInfo );
    }
    else
    {
        status = ERROR_IO_PENDING;
    }

    return status;
}

VOID
SpoolerTerminate(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Terminates the spooler process.  This call completes asynchronously;
    it will use the callback in pSpoolerInfo to update the status.

Arguments:

Return Value:

--*/

{
    DWORD status = ERROR_SUCCESS;

    DBGMSG( DBG_WARN, ( ">>> SpoolerTerminate: called %x\n", Resid ));

    vAddRef( pSpoolerInfo );
    {
        ClusWorkerTerminate(&(pSpoolerInfo->OnlineThread));
        ClusWorkerTerminate(&(pSpoolerInfo->OfflineThread));

        pSpoolerInfo->eState = kOfflinePending;

        //
        // Create a worker thread to stop the spooler.
        //

        if((status = SpoolerTerminateSync(pSpoolerInfo))!=ERROR_SUCCESS)
        {
            DBGMSG( DBG_WARN,
                    ( "SpoolerTerminate: ClusWorkerCreate failed %d\n", status ));
            DBGMSG( DBG_ERROR, 
                    ( "SpoolerTerminate: Unable to offline spooler\n" ));
            SPLASSERT(status == ERROR_SUCCESS)
        }
    }
    vDecRef( pSpoolerInfo );
}


BOOL
SpoolerStart(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Start the spooler.

Arguments:


Return Value:


--*/

{
    BOOL bStatus = TRUE;

    UNREFERENCED_PARAMETER( pSpoolerInfo );

    vEnterSem();

    if( !ghSC ){
        ghSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    }

    if( ghSC ){

        if( !ghSpoolerService ){
            ghSpoolerService = OpenService( ghSC,
                                            gszSpooler,
                                            SERVICE_ALL_ACCESS );
        }

        if( !ghSpoolerService ){

            DBGMSG( DBG_WARN,
                    ( "SpoolerStart: Failed to open spooler service %d\n ",
                      GetLastError() ));

            bStatus = FALSE;
            goto Done;
        }

        if( !StartService( ghSpoolerService, 0, NULL )){

            DWORD dwStatus;
            dwStatus = GetLastError();

            if( dwStatus != ERROR_SERVICE_ALREADY_RUNNING ){

                DBGMSG( DBG_WARN,
                        ( "SpoolerStart: StartService failed %d\n",
                          dwStatus ));

                bStatus = FALSE;
            }
        }
    }

Done:

    vLeaveSem();

    return bStatus;
}

BOOL
SpoolerStop(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Stop the spooler.

Arguments:

Return Value:

--*/

{
    BOOL bStatus;
    SERVICE_STATUS ServiceStatus;

    vEnterSem();

    bStatus = ControlService( ghSpoolerService,
                              SERVICE_CONTROL_STOP,
                              &ServiceStatus );

    if( !bStatus ){

        DBGMSG( DBG_WARN,
                ( "SpoolerStop: ControlService failed %d\n", GetLastError() ));

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Stop service failed, Error %1!u!.\n",
            GetLastError() );
    }

    CloseServiceHandle( ghSpoolerService );
    ghSpoolerService = NULL;

    vLeaveSem();

    return TRUE;
}

BOOL
SpoolerIsAlive(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Expensive check to see if the spooler is still alive.

Arguments:

Return Value:

    TRUE - Spooler is alive, and critical section successfully acquired.
    FALSE - Spooler is dead.

--*/

{
#ifdef USE_ISALIVE_THREAD

    HANDLE hThread;
    DWORD dwThreadId;
    DWORD dwExitCode;

    //
    // RPC to spooler.
    //
    SPLASSERT( pSpoolerInfo->hSpooler );

    vAddRef( pSpoolerInfo );

    //
    // Create a worker thread to start the spooler and poll.
    //
    hThread = CreateThread( NULL,
                            0,
                            SpoolerIsAliveThread,
                            (PVOID)pSpoolerInfo,
                            0,
                            &dwThreadId );
    if( !hThread ){

        DBGMSG( DBG_WARN,
                ( "SpoolerOnline: CreateThread failed %d\n", GetLastError() ));

        vDecRef( pSpoolerInfo );

        return FALSE;
    }

    WaitForSingleObject( hThread, ISALIVE_WAIT_TIME );
    if( !GetExitCodeThread( hThread, &dwExitCode )){
        dwExitCode = GetLastError();
    }

    CloseHandle( hThread );

    DBGMSG( DBG_TRACE,
            ( "SpoolerIsAlive: h=%x s=%d\n",
              pSpoolerInfo->hSpooler, dwExitCode ));

    return dwExitCode == ERROR_SUCCESS;

#else // Don't use thread.

    BOOL bIsAlive;

    //
    // RPC to spooler.
    //
    SPLASSERT( pSpoolerInfo->hSpooler );

    bIsAlive = ClusterSplIsAlive( pSpoolerInfo->hSpooler );

    DBGMSG( DBG_TRACE,
            ( "SpoolerIsAlive: h=%x s=%x,%d\n",
              pSpoolerInfo->hSpooler, bIsAlive, GetLastError() ));

    return bIsAlive;

#endif
}

BOOL
SpoolerLooksAlive(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Quick check to see if the spooler is still alive.

Arguments:

Return Value:

    TRUE - Looks alive.
    FALSE - Looks dead.

--*/

{
    DWORD dwState;

    if( !QuerySpoolerState( &dwState )){

        DBGMSG( DBG_WARN,
                ( "SpoolerLooksAlive: SpoolerStatus failed %d\n",
                  GetLastError() ));

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError());

        return FALSE;
    }

    //
    // Now check the status of the service
    //

    if(( dwState != SERVICE_RUNNING ) &&
       ( dwState != SERVICE_START_PENDING )){

        DBGMSG( DBG_WARN,
                ( "SpoolerLooksAlive: QueryServiceStatus bad state %d\n",
                  dwState ));

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Failed the IsAlive test.  Current State is %1!u!.\n",
            dwState );

        return FALSE;
    }

    return TRUE;
}

/*++

Routine Name

    SpoolerWriteClusterUpgradedKey
 
Routine Description:

    After the first reboot following an upgrade of a node, the cluster
    service informs the resdll that a version change occured. At this
    time out spooler resource may be running on  another node or may 
    not be actie at all. Thus we write a value in the local registry.
    When the cluster spooler resource fails over on this machine it
    will query for that value to know if it needs to preform post
    upgrade operations, like upgrading the printer drivers.

Arguments:

    pszResourceID - string representation of the GUID of the resoruce

Return Value:

    Win32 error code

--*/
DWORD
SpoolerWriteClusterUpgradedKey(
    IN LPCWSTR pszResourceID
    )
{
    DWORD dwError     = ERROR_INVALID_PARAMETER;
    HKEY  hRootKey    = NULL;     
    HKEY  hUpgradeKey = NULL;

    if (pszResourceID &&
        (dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                  0,
                                  NULL,
                                  0,
                                  KEY_WRITE,
                                  NULL,
                                  &hRootKey,
                                  NULL)) == ERROR_SUCCESS &&
        (dwError = RegCreateKeyEx(hRootKey,
                                  SPLREG_CLUSTER_UPGRADE_KEY,
                                  0,
                                  NULL,
                                  0,
                                  KEY_WRITE,
                                  NULL,
                                  &hUpgradeKey,
                                  NULL)) == ERROR_SUCCESS)
    {
        DWORD dwValue = 1;
    
        dwError = RegSetValueEx(hUpgradeKey, pszResourceID, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
    }
        
    if (hUpgradeKey) RegCloseKey(hUpgradeKey);        
    if (hRootKey)    RegCloseKey(hRootKey);        
    
    return dwError;
}

/*++

Routine Name

    WipeDirectory

Routine Description:

    Remove a directory tree.

Arguments:

    pszDir - directory to remove

Return Value:

    None

--*/
VOID
WipeDirectory(
    IN LPCWSTR pszDir
    )
{
    WCHAR           szBuf[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE          hFind;
    LPCWSTR         pszAllFiles = L"\\*.*";

    if (pszDir && *pszDir)
    {
        //
        // Sanity check. The string that we are going to construct must 
        // fit in the buffer.
        //
        if (wcslen(pszDir) + wcslen(pszAllFiles) + 1 <= MAX_PATH) 
        {
            wcscpy(szBuf, pszDir);
            wcscat(szBuf, L"\\*.*");
    
            //
            // Find first file that meets the criteria
            //
            if ((hFind = FindFirstFile(szBuf, &FindData)) != INVALID_HANDLE_VALUE)
            {
                do 
                {
                    //
                    // Sanity check to prevent buffer overrun
                    // length(pszdir) + "\" + length(cFileName) + NULL <= MAX_PATH
                    //
                    if (wcslen(pszDir) + 1 + wcslen(FindData.cFileName) + 1 <= MAX_PATH)
                    {
                        wcscpy(szBuf, pszDir);
                        wcscat(szBuf, L"\\");
                        wcscat(szBuf, FindData.cFileName);
            
                        //
                        // Search for the rest of the files. We are interested in files 
                        // which are not directories
                        //
                        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                        {
                            if (FindData.cFileName[0] != L'.') 
                            {
                                WipeDirectory(szBuf);
                            }
                        }
                        else
                        {
                            DeleteFile(szBuf);
                        }
                    }
        
                } while (FindNextFile(hFind, &FindData));
        
                FindClose(hFind);        
            }
        }
    
        RemoveDirectory(pszDir);
    }
}

/*++

Routine Name

    SpoolerCleanDriverDirectory

Routine Description:

    Thie routine is called when the spooler resource is deleted.
    It will remove from the cluster disk the directory where the 
    spooler keeps the pirnter drivers.

Arguments:

    hKey - handle to the Parameters key of the spooler resource

Return Value:

    Win32 error code

--*/
DWORD
SpoolerCleanDriverDirectory(
    IN HKEY hKey
    )
{
    DWORD dwError;
    DWORD dwType;
    DWORD cbNeeded = 0;

    //
    // We read the string value (private property) that was written 
    // by the spooler. This is the directory to delete.
    // Note that ClusterRegQueryValue has a bizzare behaviour. If
    // you pass NULL for the buffer and the value exists, then it
    // doesn't return ERROR_MORE_DATA, but ERROR_SUCCESS
    // Should the reg type not be reg_Sz, then we can't do anything 
    // in this function.
    //
    if ((dwError = ClusterRegQueryValue(hKey,
                                        SPLREG_CLUSTER_DRIVER_DIRECTORY,
                                        &dwType,
                                        NULL,
                                        &cbNeeded)) == ERROR_SUCCESS &&
        dwType == REG_SZ) 
    {
        LPWSTR pszDir;
           
        if (pszDir = (LPWSTR)LocalAlloc(LMEM_FIXED, cbNeeded)) 
        {
            if ((dwError = ClusterRegQueryValue(hKey,
                                                SPLREG_CLUSTER_DRIVER_DIRECTORY,
                                                &dwType,
                                                (LPBYTE)pszDir,
                                                &cbNeeded)) == ERROR_SUCCESS)
            {
                //
                // Remove the directory
                //
                WipeDirectory(pszDir);
            }
    
            LocalFree(pszDir);
        }   
        else
        {
            dwError = GetLastError();
        }        
    }
    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\poller.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    poller.c

Abstract:

    This module polls the resource list

Author:

    John Vert (jvert) 5-Dec-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include "stdio.h"

#define RESMON_MODULE RESMON_MODULE_POLLER

//
// Global data defined by this module
//

BOOL                RmpShutdown = FALSE;

//
// The following critical section protects both insertion of new event lists
// onto the event listhead, as well as adding new events to a given event list.
// This could be broken into one critical section for each purpose. The latter
// critical section would be part of each event list. The former would use the
// following lock.
//

CRITICAL_SECTION    RmpEventListLock; // Lock for processing event lists


//
// Function prototypes local to this module
//
DWORD
RmpComputeNextTimeout(
    IN PPOLL_EVENT_LIST EventList
    );

DWORD
RmpPollList(
    IN PPOLL_EVENT_LIST EventList
    );

VOID
RmpPollBucket(
    IN PMONITOR_BUCKET Bucket
    );

DWORD
RmpPollerThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Thread startup routine for the polling thread. The way this works, is that
    other parts of the resource monitor add events to the list of events that
    is being processed by this thread.  When they are done, they signal this
    thread, which makes a copy of the new lists, and then waits for an event to
    happen or a timeout occurs.

Arguments:

    Context - A pointer to the POLL_EVENT_LIST for this thread.

Return Value:

    Win32 error code.

Note:

    This code assumes that the EventList pointed to by Context does NOT go
    away while this thread is running. Further it assumes that the ResourceList
    pointed to by the given EventList does not go away or change.

--*/

{
    DWORD Timeout;
    DWORD Status;
    PPOLL_EVENT_LIST    NewEventList = (PPOLL_EVENT_LIST)Context;
    POLL_EVENT_LIST     waitEventList; // Event list outstanding
    DWORD WaitFailed = 0;

    //
    // Zero the local copy event list structure.
    //

    ZeroMemory( &waitEventList, sizeof(POLL_EVENT_LIST) );

    //
    // Don't allow system failures to generate popups.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    //
    // Create notification event to indicate that this list
    // has changed.
    //

    NewEventList->ListNotify = CreateEvent(NULL,
                                           FALSE,
                                           FALSE,
                                           NULL);
    if (NewEventList->ListNotify == NULL) {
        CL_UNEXPECTED_ERROR(GetLastError());
    }

    RmpAddPollEvent(NewEventList, NewEventList->ListNotify, NULL);

    //
    // Make a copy of the NewEventList first time through.
    //

    AcquireEventListLock( NewEventList );

    CopyMemory( &waitEventList,
                NewEventList,
                sizeof(POLL_EVENT_LIST)
               );

    ReleaseEventListLock( NewEventList );

try_again:
    //
    // Compute initial timeout.
    //
    Timeout = RmpComputeNextTimeout( NewEventList );

    //
    // There are four functions performed by this thread...
    //
    //  1. Handle timers for polling.
    //  2. Handle list notification changes and updates to the number of
    //     events handled by the WaitForMultipleObjects.
    //  3. Handle events set by resource DLL's to deliver asynchronous
    //     event (failure) notifications.
    //  4. Handle a shutdown request.
    //
    // N.B. Handles cannot go away while we are waiting... it is therefore
    //      best to set the event for the ListNotify event so we can redo the
    //      wait event list.
    //

    while (TRUE) {
        //
        // Wait for any of the events to be signaled.
        //
        CL_ASSERT(waitEventList.Handle[0] == NewEventList->ListNotify);
        Status = WaitForMultipleObjects(waitEventList.EventCount,
                                        &waitEventList.Handle[0],
                                        FALSE,
                                        Timeout);
        if (Status == WAIT_TIMEOUT) {
            //
            // Time period has elapsed, go poll everybody
            //
            Timeout = RmpPollList( NewEventList );
            WaitFailed = 0;
        } else {
            //
            // If the first event is signaled, which is the ListNotify event,
            // then the list changed or a new poll event was added.
            //
            if ( Status == WAIT_OBJECT_0 ) {
                if (RmpShutdown) {
                    //
                    // Exit the poller thread, this will notify the main thread
                    // to clean up and shutdown.
                    //
                    break;
                }
get_new_list:
                WaitFailed = 0;
                //
                // The list has changed or we have a new event to wait for,
                // recompute a new timeout and make a copy of the new event list
                //
                AcquireEventListLock( NewEventList );

                CopyMemory( &waitEventList,
                            NewEventList,
                            sizeof(POLL_EVENT_LIST)
                           );


                ReleaseEventListLock( NewEventList );

                Timeout = RmpComputeNextTimeout( NewEventList );

            } else if ( Status == WAIT_FAILED ) {
                //
                // We've probably signaled an event, and closed the handle
                // already. Wait on the Notify Event for just a little bit.
                // If that event fires, then copy a new event list. But only
                // try this 100 times.
                //
                if ( ++WaitFailed < 100 ) {
                    Status = WaitForSingleObject( waitEventList.ListNotify,
                                                  100 );
                    if ( RmpShutdown ) {
                        break;
                    }
                    if ( Status == WAIT_TIMEOUT ) {
                        continue;
                    } else {
                        goto get_new_list;
                    }
                } else {
                    Status = GetLastError();
                    break;
                }
            } else {
                //
                // One of the resource events was signaled!
                //
                WaitFailed = 0;
                CL_ASSERT( WAIT_OBJECT_0 == 0 );
                RmpResourceEventSignaled( &waitEventList,
                                          Status );
                Timeout = RmpComputeNextTimeout( NewEventList );
            }
        }
    }

    ClRtlLogPrint( LOG_NOISE,
                   "[RM] PollerThread stopping. Shutdown = %1!u!, Status = %2!u!, "
                   "WaitFailed = %3!u!, NotifyEvent address = %4!u!.\n",
                   RmpShutdown,
                   Status,
                   WaitFailed,
                   waitEventList.ListNotify);

#if 1 // RodGa - this is for debug only!
    WaitFailed = 0;
    if ( Status == ERROR_INVALID_HANDLE ) {
        DWORD i;
        for ( i = 0; i < waitEventList.EventCount; i++ ) {
            ClRtlLogPrint( LOG_NOISE, "[RM] Event address %1!u!, index %2!u!.\n",
                       waitEventList.Handle[i], i);
            Status = WaitForSingleObject( waitEventList.Handle[i], 10 );
            if ( (Status == WAIT_FAILED) &&
                 (GetLastError() == ERROR_INVALID_HANDLE) )
            {
                ClRtlLogPrint( LOG_UNUSUAL, "[RM] Event address %1!u!, index %2!u! is bad. Removing...\n",
                           waitEventList.Handle[i], i);
                RmpRemovePollEvent( waitEventList.Handle[i] );

                //
                // Copy new list... and try again.
                //
                AcquireEventListLock( NewEventList );

                CopyMemory( &waitEventList,
                            NewEventList,
                            sizeof(POLL_EVENT_LIST)
                           );


                ReleaseEventListLock( NewEventList );

                goto try_again;
            }
        }
    }
#endif

    CL_ASSERT( NewEventList->ListNotify );
    CL_ASSERT( waitEventList.ListNotify == NewEventList->ListNotify );
    CloseHandle( NewEventList->ListNotify );

    return(0);

} // RmpPollerThread



DWORD
RmpComputeNextTimeout(
    IN PPOLL_EVENT_LIST EventList
    )

/*++

Routine Description:

    Searches the resource list to determine the number of milliseconds
    until the next poll event.

Arguments:

    None.

Return Value:

    0 - A poll interval has already elapsed.
    INFINITE - No resources to poll
    number of milliseconds until the next poll event.

--*/

{
    DWORD Timeout;
    PMONITOR_BUCKET Bucket;
    DWORDLONG NextDueTime;
    DWORDLONG CurrentTime;
    DWORDLONG WaitTime;

    AcquireEventListLock( EventList );
    if (!IsListEmpty(&EventList->BucketListHead)) {
        Bucket = CONTAINING_RECORD(EventList->BucketListHead.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
        NextDueTime = Bucket->DueTime;
        Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
        while (&Bucket->BucketList != &EventList->BucketListHead) {
            if (Bucket->DueTime < NextDueTime) {
                NextDueTime = Bucket->DueTime;
            }

            Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                       MONITOR_BUCKET,
                                       BucketList);
        }

        //
        // Compute the number of milliseconds from the current time
        // until the next due time. This is our timeout value.
        //
        GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
        if (NextDueTime > CurrentTime) {
            WaitTime = NextDueTime - CurrentTime;
            CL_ASSERT(WaitTime < (DWORDLONG)0xffffffff * 10000); // check for excessive value
            Timeout = (ULONG)(WaitTime / 10000);
        } else {
            //
            // The next poll time has already passed, timeout immediately
            // and go poll the list.
            //
            Timeout = 0;
        }

    } else {
        //
        // Nothing to poll, so wait on the ListNotify event forever.
        //
        Timeout = INFINITE;
    }
    ReleaseEventListLock( EventList );

    return(Timeout);

} // RmpComputeNextTimeout



DWORD
RmpPollList(
    IN PPOLL_EVENT_LIST EventList
    )

/*++

Routine Description:

    Polls all resources in the resource list whose timeouts have
    expired. Recomputes the next timeout interval for each polled
    resource.

Arguments:

    None.

Return Value:

    The number of milliseconds until the next poll event.

--*/

{
    ULONG i;
    DWORD Timeout = INFINITE;
    DWORDLONG NextDueTime;
    DWORDLONG CurrentTime;
    DWORDLONG WaitTime;
    PMONITOR_BUCKET Bucket;

    AcquireEventListLock( EventList );

    if (!IsListEmpty(&EventList->BucketListHead)) {
        Bucket = CONTAINING_RECORD(EventList->BucketListHead.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
        NextDueTime = Bucket->DueTime;
        while (&Bucket->BucketList != &EventList->BucketListHead) {
            GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
            if (CurrentTime >= Bucket->DueTime) {
                //
                // This poll interval has expired. Compute the
                // next poll interval and poll this bucket now.
                //
                CL_ASSERT( Bucket->Period != 0 );
                Bucket->DueTime = CurrentTime + Bucket->Period;

                RmpPollBucket(Bucket);
            }
            //
            // If this bucket is the closest upcoming event,
            // update NextDueTime.
            //
            if (Bucket->DueTime < NextDueTime) {
                NextDueTime = Bucket->DueTime;
            }
            Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                       MONITOR_BUCKET,
                                       BucketList);
        }

        //
        // Compute new timeout value in milliseconds
        //
        GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
        if (CurrentTime > NextDueTime) {
            //
            // The next timeout has already expired
            //
            WaitTime = Timeout = 0;
        } else {
            WaitTime = NextDueTime - CurrentTime;
            CL_ASSERT(WaitTime < (DWORDLONG)0xffffffff * 10000);                // check for excessive value
            Timeout = (ULONG)(WaitTime / 10000);
        }
    }

    ReleaseEventListLock( EventList );
    return(Timeout);

} // RmpPollList



VOID
RmpPollBucket(
    IN PMONITOR_BUCKET Bucket
    )

/*++

Routine Description:

    Polls all the resources in a given bucket. Updates their state and notifies
    cluster manager as appropriate.

Arguments:

    Bucket - Supplies the bucket containing the list of resources to be polled.

Return Value:

    None.

--*/

{
    PLIST_ENTRY CurrentEntry;
    PRESOURCE Resource;
    BOOL Success = TRUE;

    CurrentEntry = Bucket->ResourceList.Flink;
    while (CurrentEntry != &Bucket->ResourceList) {
        Resource = CONTAINING_RECORD(CurrentEntry,RESOURCE,ListEntry);
        //
        // The EventList Lock protects concurrent calls to individual
        // resources. The EventList Lock was taken out in RmpPollList.
        // If we increase the granularity of locking, and lock the resource
        // then we'd add a lock here.
        //
        if (Resource->State == ClusterResourceOnline) {

            //
            // A resource that is online alternates between LooksAlive
            // and IsAlive polling by doing an IsAlive poll instead of
            // a LooksAlive poll every IsAliveCount iterations.
            //
            Resource->IsAliveCount += 1;
            CL_ASSERT( Resource->IsAliveRollover != 0 );
            if (Resource->IsAliveCount == Resource->IsAliveRollover) {

                //
                // Poll the IsAlive entrypoint.
                //

                RmpSetMonitorState(RmonIsAlivePoll, Resource);
#ifdef COMRES
                Success = RESMON_ISALIVE (Resource) ;
#else
                Success = (Resource->IsAlive)(Resource->Id);
#endif
                RmpSetMonitorState(RmonIdle, NULL);
                //
                // If this was successful, then we will perform the LooksAlive
                // test next time. Otherwise, we do the IsAlive check again.
                //
                if (Success) {
                    Resource->IsAliveCount = 0;
                } else {
                    --Resource->IsAliveCount;
                }

            } else {
                //
                // Poll the LooksAlive entrypoint.
                //
                if ( Resource->EventHandle == NULL ) {
                    RmpSetMonitorState(RmonLooksAlivePoll,Resource);
#ifdef COMRES
                    Success = RESMON_LOOKSALIVE (Resource) ;
#else
                    Success = (Resource->LooksAlive)(Resource->Id);
#endif
                    RmpSetMonitorState(RmonIdle, NULL);
                }
                if ( !Success ) {
                    RmpSetMonitorState(RmonIsAlivePoll, Resource);
#ifdef COMRES
                    Success = RESMON_ISALIVE (Resource) ;
#else
                    Success = (Resource->IsAlive)(Resource->Id);
#endif
                    RmpSetMonitorState(RmonIdle, NULL);
                } 
            }
            if (!Success) {
                //
                // The resource has failed. Mark it as Failed and notify
                // the cluster manager.
                //
                Resource->State = ClusterResourceFailed;
                RmpPostNotify(Resource, NotifyResourceStateChange);
            }
        }
        CurrentEntry = CurrentEntry->Flink;
    }

} // RmpPollBucket



VOID
RmpSignalPoller(
    IN PPOLL_EVENT_LIST EventList
    )

/*++

Routine Description:

    Interface to notify the poller thread that the resource list has
    been changed or a new event has been added to the poll event list.
    The poller thread should get a new event list and recompute its timeouts.

Arguments:

    EventList - the event list that is to be notified.

Return Value:

    None.

--*/

{
    BOOL Success;

    if (EventList->ListNotify != NULL) {
        Success = SetEvent(EventList->ListNotify);
        CL_ASSERT(Success);
    }

} // RmpSignalPoller
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\notify.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Interface for reporting resource notifications to cluster
    manager.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

--*/
#include "resmonp.h"

#define RESMON_MODULE RESMON_MODULE_NOTIFY

//
// Define queue to post notifications to
//
CL_QUEUE RmpNotifyQueue;

//
// Define notification block structure
//
typedef struct _NOTIFY {
    LIST_ENTRY ListEntry;
    RM_NOTIFY_KEY Key;
    NOTIFY_REASON Reason;
    CLUSTER_RESOURCE_STATE State;
} NOTIFY, *PNOTIFY;


BOOL
s_RmNotifyChanges(
    IN handle_t IDL_handle,
    OUT RM_NOTIFY_KEY *lpNotifyKey,
    OUT DWORD *lpNotifyEvent,
    OUT DWORD *lpCurrentState     
    )

/*++

Routine Description:

    This is a blocking RPC call which is used to implement notification.
    The client calls this API and blocks until a notification event
    occurs. Any notification events wake up the blocked thread and
    it returns to the client with the notification information.

Arguments:

    IDL_handle - Supplies binding handle, currently unused

    lpNotifyKey - Returns the notification key of the resource

    lpCurrentState - Returns the current state of the resource

Return Value:

    TRUE - A notification event was successfully delivered

    FALSE - No notification events were delivered, the process is
            shutting down.

--*/

{
    PLIST_ENTRY ListEntry;
    PNOTIFY Notify;
    DWORD Status;
    BOOL Continue;

    //
    // Wait for something to be posted to the queue, pull it off, and
    // return it.
    //
    ListEntry = ClRtlRemoveHeadQueue(&RmpNotifyQueue);
    if ( ListEntry == NULL ) {
        // If we got nothing - assume we are shutting down!
        return(FALSE);
    }

    Notify = CONTAINING_RECORD(ListEntry,
                               NOTIFY,
                               ListEntry);
    if (Notify->Reason == NotifyShutdown) {
        //
        // System is shutting down.
        //
        RmpFree(Notify);
        ClRtlLogPrint( LOG_NOISE, "[RM] NotifyChanges shutting down.\n");
        return(FALSE);
    }

    //
    // Return to the client with the notification data
    //
    *lpNotifyKey = Notify->Key;
    *lpNotifyEvent = Notify->Reason;
    *lpCurrentState = Notify->State;
    RmpFree(Notify);

    return(TRUE);

} // RmNotifyChanges


VOID
RmpPostNotify(
    IN PRESOURCE Resource,
    IN NOTIFY_REASON Reason
    )

/*++

Routine Description:

    Posts a notification block to the notify queue.

Arguments:

    Resource - Supplies the resource to post the notification for

    Reason - Supplies the reason for the notification.

Return Value:

    None.

--*/

{
    PNOTIFY Notify;

    Notify = RmpAlloc(sizeof(NOTIFY));

    if (Notify != NULL) {
        Notify->Reason = Reason;
        switch ( Reason ) {

        case NotifyResourceStateChange:
            Notify->Key = Resource->NotifyKey;
            Notify->State = Resource->State;
            break;

        case NotifyResourceResuscitate:
            Notify->Key = Resource->NotifyKey;
            Notify->State = 0;
            break;

        case NotifyShutdown:
            Notify->Key = 0;
            Notify->State = 0;
            break;

        default:
            Notify->Key = 0;
            Notify->State = 0;

        }

        ClRtlInsertTailQueue(&RmpNotifyQueue, &Notify->ListEntry);

    } else {
        //
        // The notification will get dropped on the floor, but there's
        // not too much we can do about it anyway.
        //
        ClRtlLogPrint( LOG_ERROR, "[RM] RmpPostNotify dropped notification for %1!ws!, reason %2!u!\n",
            Resource->ResourceName,
            Reason);
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
    }
} // RmpPostNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\excprpt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    excprt.c
    
Abstract:

    This module uses imagehlp.dll to dump the stack when an exception occurs.

Author:

    Sunita Shrivastava(sunitas) 11/5/1997

Revision History:

--*/
#define UNICODE 1
#define _UNICODE 1

#include "resmonp.h"
#include "imagehlp.h"


// Make typedefs for some IMAGEHLP.DLL functions so that we can use them
// with GetProcAddress
typedef BOOL (__stdcall * SYMINITIALIZEPROC)( HANDLE, LPSTR, BOOL );
typedef BOOL (__stdcall *SYMCLEANUPPROC)( HANDLE );

typedef BOOL (__stdcall * STACKWALKPROC)
           ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
            PREAD_PROCESS_MEMORY_ROUTINE,
            PFUNCTION_TABLE_ACCESS_ROUTINE,
            PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, ULONG_PTR );

typedef ULONG_PTR (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, ULONG_PTR );

typedef BOOL (__stdcall *SYMGETSYMFROMADDRPROC)
                            ( HANDLE, ULONG_PTR, PULONG_PTR, PIMAGEHLP_SYMBOL );



SYMINITIALIZEPROC _SymInitialize = 0;
SYMCLEANUPPROC _SymCleanup = 0;
STACKWALKPROC _StackWalk = 0;
SYMFUNCTIONTABLEACCESSPROC _SymFunctionTableAccess = 0;
SYMGETMODULEBASEPROC _SymGetModuleBase = 0;
SYMGETSYMFROMADDRPROC _SymGetSymFromAddr = 0;

//local prototypes for forward use
BOOL InitImagehlpFunctions();
void ImagehlpStackWalk( IN PCONTEXT pContext );
BOOL GetLogicalAddress(
        IN PVOID    addr, 
        OUT LPWSTR  szModule, 
        IN  DWORD   len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset );


VOID
DumpCriticalSection(
    IN PCRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

Inputs:

Outputs:

--*/

{
    DWORD status;

    ClRtlLogPrint(LOG_CRITICAL, "[RM] Dumping Critical Section at %1!08LX!\n",
                CriticalSection );

    try {
        if ( CriticalSection->LockCount == -1 ) {
            ClRtlLogPrint(LOG_CRITICAL, "     LockCount       NOT LOCKED\n" );
        } else {
            ClRtlLogPrint(LOG_CRITICAL, "     LockCount       %1!u!\n",
                        CriticalSection->LockCount );
        }
        ClRtlLogPrint(LOG_CRITICAL, "     RecursionCount  %1!x!\n",
                    CriticalSection->RecursionCount );
        ClRtlLogPrint(LOG_CRITICAL, "     OwningThread    %1!x!\n",
                    CriticalSection->OwningThread );
        ClRtlLogPrint(LOG_CRITICAL, "     EntryCount      %1!x!\n",
                    CriticalSection->DebugInfo->EntryCount );
        ClRtlLogPrint(LOG_CRITICAL, "     ContentionCount %1!x!\n\n",
                    CriticalSection->DebugInfo->ContentionCount );
    
    } except ( EXCEPTION_EXECUTE_HANDLER )  {
        status = GetExceptionCode();
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Exception %1!lx! occurred while dumping critsec\n\n",
            status );
    }

    
} // DumpCriticalSection


void GenerateExceptionReport(
    IN PEXCEPTION_POINTERS pExceptionInfo)
/*++

Routine Description:

    Top level exception handler for the cluster service process.
    Currently this just exits immediately and assumes that the
    cluster proxy will notice and restart us as appropriate.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{    
    PCONTEXT pCtxt = pExceptionInfo->ContextRecord;


    if ( !InitImagehlpFunctions() )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Imagehlp.dll or its exported procs not found\r\n");

#if 0 
        #ifdef _M_IX86  // Intel Only!
        // Walk the stack using x86 specific code
        IntelStackWalk( pCtx );
        #endif
#endif        

        return;
    }

    ImagehlpStackWalk( pCtxt );

    _SymCleanup( GetCurrentProcess() );

}


BOOL InitImagehlpFunctions()
/*++

Routine Description:

    Initializes the imagehlp functions/data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HMODULE hModImagehlp = LoadLibraryW( L"IMAGEHLP.DLL" );

    
    if ( !hModImagehlp )
        return FALSE;

    _SymInitialize = (SYMINITIALIZEPROC)GetProcAddress( hModImagehlp,
                                                        "SymInitialize" );
    if ( !_SymInitialize )
        return FALSE;

    _SymCleanup = (SYMCLEANUPPROC)GetProcAddress( hModImagehlp, "SymCleanup" );
    if ( !_SymCleanup )
        return FALSE;

    _StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" );
    if ( !_StackWalk )
        return FALSE;

    _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)
                        GetProcAddress( hModImagehlp, "SymFunctionTableAccess" );

    if ( !_SymFunctionTableAccess )
        return FALSE;

    _SymGetModuleBase=(SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp,
                                                            "SymGetModuleBase");
                                                            
    if ( !_SymGetModuleBase )
        return FALSE;

    _SymGetSymFromAddr=(SYMGETSYMFROMADDRPROC)GetProcAddress( hModImagehlp,
                                                "SymGetSymFromAddr" );
    if ( !_SymGetSymFromAddr )
        return FALSE;

    if ( !_SymInitialize( GetCurrentProcess(), 0, TRUE ) )
        return FALSE;

    return TRUE;        
}


void ImagehlpStackWalk(
    IN PCONTEXT pContext )
/*++

Routine Description:

    Walks the stack, and writes the results to the report file 

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    STACKFRAME  sf;
    BYTE        symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
    PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
    ULONG_PTR symDisplacement = 0;      // Displacement of the input address,
                                        // relative to the start of the symbol
    DWORD       dwMachineType;                                        
    UCHAR       printBuffer[512];
    LONG        nextPrtBufChar;

#if defined (_M_IX86)
    dwMachineType = IMAGE_FILE_MACHINE_I386;
#else if defined(_M_ALPHA)
    dwMachineType = IMAGE_FILE_MACHINE_ALPHA;
#endif    
    ClRtlLogPrint(LOG_CRITICAL, "[RM] CallStack:\n");

    ClRtlLogPrint(LOG_CRITICAL, "[RM] Address   Frame\n");

    // Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag

    memset( &sf, 0, sizeof(sf) );

#if defined (_M_IX86)
    // Initialize the STACKFRAME structure for the first call.  This is only
    // necessary for Intel CPUs, and isn't mentioned in the documentation.
    sf.AddrPC.Offset       = pContext->Eip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = pContext->Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;
#endif // _M_IX86


    while ( 1 )
    {
        if ( ! _StackWalk(  dwMachineType,
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            &sf,
                            pContext,
                            0,
                            _SymFunctionTableAccess,
                            _SymGetModuleBase,
                            0 ) )
               break;
                            
        if ( 0 == sf.AddrFrame.Offset ) // Basic sanity check to make sure
            break;                      // the frame is OK.  Bail if not.

        nextPrtBufChar = _snprintf(printBuffer,
                                   sizeof(printBuffer),
                                   "     %08X  %08X  ",
                                   sf.AddrFrame.Offset, sf.AddrPC.Offset );

        // IMAGEHLP is wacky, and requires you to pass in a pointer to an
        // IMAGEHLP_SYMBOL structure.  The problem is that this structure is
        // variable length.  That is, you determine how big the structure is
        // at runtime.  This means that you can't use sizeof(struct).
        // So...make a buffer that's big enough, and make a pointer
        // to the buffer.  We also need to initialize not one, but TWO
        // members of the structure before it can be used.

        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLength = 512;

        if ( nextPrtBufChar < 0 ) 
        {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Unable to print out stack trace for lack of space in buffer...\n");
            continue;
        }
        
        if ( _SymGetSymFromAddr(GetCurrentProcess(), sf.AddrPC.Offset,
                                &symDisplacement, pSymbol) )
        {
            _snprintf(printBuffer+nextPrtBufChar,
                      512-nextPrtBufChar,
                      "%hs+%p\n", 
                      pSymbol->Name, symDisplacement);
            
        }
        else    // No symbol found.  Print out the logical address instead.
        {
            WCHAR szModule[MAX_PATH] = L"";
            DWORD section = 0;
            ULONG_PTR offset = 0;

            GetLogicalAddress(  (PVOID)sf.AddrPC.Offset,
                                szModule, sizeof(szModule)/sizeof(WCHAR), 
                                &section, &offset );

            _snprintf(printBuffer+nextPrtBufChar,
                      512-nextPrtBufChar,
                      "%04X:%08p %s\n",
                      section, offset, szModule );
        }

        ClRtlLogPrint(LOG_CRITICAL, "%1!hs!\n", printBuffer);
    }
}


BOOL GetLogicalAddress(
        IN PVOID addr, 
        OUT LPWSTR szModule, 
        IN DWORD len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset )
/*++

Routine Description:

    Given a linear address, locates the module, section, and offset containing  
    that address.                                                               
    Note: the szModule paramater buffer is an output buffer of length specified 
    by the len parameter (in characters!)                                       

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    MEMORY_BASIC_INFORMATION mbi;
    ULONG_PTR hMod;
    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr;
    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr;
    PIMAGE_SECTION_HEADER pSection;
    ULONG_PTR rva ;
    int   i;
    
    if ( !VirtualQuery( addr, &mbi, sizeof(mbi) ) )
        return FALSE;

    hMod = (ULONG_PTR)mbi.AllocationBase;

    if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
        return FALSE;

    rva = (ULONG_PTR)addr - hMod; // RVA is offset from module load address

    pDosHdr =  (PIMAGE_DOS_HEADER)hMod;
    pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
    pSection = IMAGE_FIRST_SECTION( pNtHdr );
    
    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for ( i = 0; i < pNtHdr->FileHeader.NumberOfSections;
            i++, pSection++ )
    {
        ULONG_PTR sectionStart = pSection->VirtualAddress;
        ULONG_PTR sectionEnd = sectionStart
                    + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);


        // Is the address in this section???
        if ( (rva >= sectionStart) && (rva <= sectionEnd) )
        {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            *section = i+1;
            *offset = rva - sectionStart;
            return TRUE;
        }
    }

    return FALSE;   // Should never get here!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\resmonp.h ===
#ifndef _RESMONP_H
#define _RESMONP_H


/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resmonp.h

Abstract:

    Private header file for the Resource Monitor component

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "windows.h"
#include "cluster.h"
#include "rm_rpc.h"
#include "monmsg.h"

#ifdef COMRES
#define COBJMACROS
#include "comres.h"
#endif

#define LOG_CURRENT_MODULE LOG_MODULE_RESMON

//
// internal module identifiers. Not used with ClRtl logging code. Used to
// track lock acquisitions.
//
#define RESMON_MODULE_EVNTLIST 1
#define RESMON_MODULE_NOTIFY   2
#define RESMON_MODULE_POLLER   3
#define RESMON_MODULE_PROPERTY 4
#define RESMON_MODULE_RESLIST  5
#define RESMON_MODULE_RESMON   6
#define RESMON_MODULE_RMAPI    7

//
// Define the maximum number of resources handled per thread.
// (This value must be smaller than MAXIMUM_WAIT_OBJECTS-1!)
//
#define MAX_RESOURCES_PER_THREAD 27

#define MAX_HANDLES_PER_THREAD (MAX_RESOURCES_PER_THREAD+1)

//
// Define the maximum number of threads.
// (This value can be up to MAXIMUM_WAIT_OBJECTS, however the first two
//  entries are taken by events, so in fact we have 2 less threads available).
//
#define MAX_THREADS (MAXIMUM_WAIT_OBJECTS)

//
// Define structure and flags used for each resource entry
//
#define RESOURCE_SIGNATURE 'crsR'

extern RESUTIL_PROPERTY_ITEM RmpResourceCommonProperties[];

extern RESUTIL_PROPERTY_ITEM RmpResourceTypeCommonProperties[];

typedef struct _POLL_EVENT_LIST;
typedef struct _POLL_EVENT_LIST *PPOLL_EVENT_LIST;


//
// Lock Info for debugging lock acquires/releases
//
typedef struct _LOCK_INFO {
    DWORD   Module: 6;
    DWORD   ThreadId: 11;
    DWORD   LineNumber: 15;
} LOCK_INFO, *PLOCK_INFO;

// 
// Entry points
//
#define RESDLL_ENTRY_CLOSE      0x00000001
#define RESDLL_ENTRY_TERMINATE  0x00000002

//
// Flags
//
#define RESOURCE_INSERTED 1

typedef struct _RESOURCE {
    ULONG Signature;                // 'Rsrc'
    ULONG Flags;
    LIST_ENTRY ListEntry;           // for linking onto monitoring list
    LPWSTR DllName;
    LPWSTR ResourceType;
    LPWSTR ResourceId;
    LPWSTR ResourceName;
    DWORD LooksAlivePollInterval;
    DWORD IsAlivePollInterval;
    HINSTANCE Dll;                  // handle to resource's DLL
    RESID Id;
    HANDLE  EventHandle;            // async error notification handle
    HANDLE  OnlineEvent;

#ifdef COMRES
#define RESMON_TYPE_DLL    1
#define RESMON_TYPE_COM    2

    // TODO define this as a union
    IClusterResource          *pClusterResource ;
    IClusterResControl        *pClusterResControl ;
    IClusterQuorumResource    *pClusterQuorumResource ;

    DWORD dwType ; // Type of resource whether it is DLL or a COMResources

    POPEN_ROUTINE pOpen;
    PCLOSE_ROUTINE pClose;
    PONLINE_ROUTINE pOnline;
    POFFLINE_ROUTINE pOffline;
    PTERMINATE_ROUTINE pTerminate;
    PIS_ALIVE_ROUTINE pIsAlive;
    PLOOKS_ALIVE_ROUTINE pLooksAlive;
    PARBITRATE_ROUTINE pArbitrate;
    PRELEASE_ROUTINE pRelease;
    PRESOURCE_CONTROL_ROUTINE pResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE pResourceTypeControl;
#else
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PIS_ALIVE_ROUTINE IsAlive;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
#endif
    CLUSTER_RESOURCE_STATE State;
    ULONG IsAliveCount;
    ULONG IsAliveRollover;
    RM_NOTIFY_KEY NotifyKey;
    PPOLL_EVENT_LIST EventList;
    HANDLE TimerEvent;              // Timer event for offline completion.
    DWORD  PendingTimeout;
    DWORD  CheckPoint;              // Online pending checkpoint
    BOOL   IsArbitrated;
    DWORD  dwEntryPoint;            // Number indicating which resdll entry point is called.
    BOOL   fArbLock;                // Variable used for synchronizing arbitrate with close and rundown
} RESOURCE, *PRESOURCE;
#ifdef COMRES

extern DWORD tidActiveXWorker ;    // ThreadID for the COM worker thread

#define WM_RES_CREATE WM_USER+1
#define WM_RES_OPEN WM_USER+2
#define WM_RES_CLOSE WM_USER+3
#define WM_RES_ONLINE WM_USER+4
#define WM_RES_OFFLINE WM_USER+5
#define WM_RES_TERMINATE WM_USER+6
#define WM_RES_ISALIVE WM_USER+7
#define WM_RES_LOOKSALIVE WM_USER+8

#define WM_RES_ARBITRATE WM_USER+9
#define WM_RES_RELEASE WM_USER+10

#define WM_RES_EXITTHREAD WM_USER+11

#define WM_RES_FREE WM_USER+12

#define WM_RES_RESOURCECONTROL WM_USER+11
#define WM_RES_RESOURCETYPECONTROL WM_USER+12

DWORD WINAPI ActiveXWorkerThread (LPVOID pThreadInfo) ;

//
//  Used in RmpAcquireSpinLock
//
#define RESMON_MAX_SLOCK_RETRIES    400

typedef struct {
    PRESOURCE Resource ;
    LPVOID Data1 ; // For ResourceKey in Open & EvenHandle in Online
    DWORD status ; // This is the Com Status indicating if the function is actually called.
    LONG Ret ;  // Actual Return Value of the functions like IsAlive, LooksAlive etc.
} COMWORKERTHREADPARAM, *PCOMWORKERTHREADPARAM  ;

DWORD PostWorkerMessage (DWORD tid, UINT msg, PCOMWORKERTHREADPARAM pData) ;

RESID
Resmon_Open (
    IN PRESOURCE Resource,
    IN HKEY ResourceKey
    );

VOID
Resmon_Close (
    IN PRESOURCE Resource
    );

DWORD
Resmon_Online (
    IN PRESOURCE Resource,
    IN OUT LPHANDLE EventHandle
    );

DWORD
Resmon_Offline (
    IN PRESOURCE Resource
    );

VOID
Resmon_Terminate (
    IN PRESOURCE Resource
    );

BOOL
Resmon_LooksAlive (
    IN PRESOURCE Resource
    );

BOOL
Resmon_IsAlive (
    IN PRESOURCE Resource
    );

DWORD
Resmon_Arbitrate (
    IN PRESOURCE Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    ) ;

DWORD
Resmon_Release (
    IN PRESOURCE Resource
    ) ;

DWORD
Resmon_ResourceControl (
    IN PRESOURCE Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    ) ;

#define RESMON_OPEN(Resource, ResKey) Resmon_Open(Resource, ResKey)

#define RESMON_CLOSE(Resource) Resmon_Close(Resource)

#define RESMON_ONLINE(Resource, EventHandle) Resmon_Online(Resource, EventHandle)

#define RESMON_OFFLINE(Resource) Resmon_Offline(Resource)

#define RESMON_TERMINATE(Resource) Resmon_Terminate(Resource)

#define RESMON_ISALIVE(Resource) Resmon_IsAlive(Resource)

#define RESMON_LOOKSALIVE(Resource) Resmon_LooksAlive(Resource)

#define RESMON_ARBITRATE(Resource, RmpLostQuorumResource) \
            Resmon_Arbitrate (Resource, RmpLostQuorumResource)

#define RESMON_RELEASE(Resource) \
            Resmon_Release (Resource)

#define RESMON_RESOURCECONTROL(Resource, ControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize, BytesReturned) \
            Resmon_ResourceControl (Resource, ControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize, BytesReturned)

#endif // COMRES

typedef struct _RESDLL_FNINFO{
    HINSTANCE               hDll;
    PCLRES_FUNCTION_TABLE   pResFnTable;
}RESDLL_FNINFO, *PRESDLL_FNINFO;

#ifdef COMRES
typedef struct _RESDLL_INTERFACES{
    IClusterResource          *pClusterResource ;
    IClusterResControl        *pClusterResControl ;
    IClusterQuorumResource    *pClusterQuorumResource ;
}RESDLL_INTERFACES, *PRESDLL_INTERFACES;
#endif

typedef struct _MONITOR_BUCKET {
    LIST_ENTRY BucketList;          // For chaining buckets together.
    LIST_ENTRY ResourceList;        // List of resources in this bucket
    DWORDLONG DueTime;              // Next time that these resources should be polled
    DWORDLONG Period;               // Periodic interval of this bucket.
} MONITOR_BUCKET, *PMONITOR_BUCKET;


//
// The Poll Event List structure.
//

typedef struct _POLL_EVENT_LIST {
    LIST_ENTRY Next;                // Next event list
    LIST_ENTRY BucketListHead;      // Bucket Listhead for this list/thread
    DWORD   NumberOfBuckets;        // Number of entries on this bucket list
    DWORD   NumberOfResources;      // Number of resources on this event list
    CRITICAL_SECTION ListLock;      // Critical section to add/remove events
    LOCK_INFO PPrevPrevListLock;
    LOCK_INFO PrevPrevListLock;
    LOCK_INFO PrevListLock;
    LOCK_INFO LastListLock;
    LOCK_INFO LastListUnlock;
    LOCK_INFO PrevListUnlock;
    LOCK_INFO PrevPrevListUnlock;
    LOCK_INFO PPrevPrevListUnlock;
    HANDLE  ListNotify;             // List change notification
    HANDLE  ThreadHandle;           // Handle of thread processing this list
    DWORD   EventCount;             // Number of events/resources in lists
    HANDLE  Handle[MAX_HANDLES_PER_THREAD]; // Array of handles to wait for
    PRESOURCE Resource[MAX_HANDLES_PER_THREAD]; // Resources that match handles
    PRESOURCE LockOwnerResource;    // Resource that owns the eventlist lock
    DWORD     MonitorState;         // Resdll entry point called. 
} POLL_EVENT_LIST, *PPOLL_EVENT_LIST;


#define POLL_GRANULARITY (10)       // 10ms

#define PENDING_TIMEOUT  (3*1000*60) // 3 minutes for pending requests to finish

//
// Private helper macros and functions
//
VOID
RmpSetEventListLockOwner(
    IN PRESOURCE pResource,
    IN DWORD     dwMonitorState
    );

#define RmpAlloc(size) LocalAlloc(LMEM_FIXED, (size))
#define RmpFree(size)  LocalFree((size))

#define RmpSetMonitorState(state, resource)                                \
    EnterCriticalSection(&RmpMonitorStateLock);                            \
    GetSystemTimeAsFileTime((PFILETIME)&RmpSharedState->LastUpdate);       \
    RmpSharedState->State = (state);                                       \
    RmpSharedState->ActiveResource = (HANDLE)(resource);                   \
    LeaveCriticalSection(&RmpMonitorStateLock);                            \
    RmpSetEventListLockOwner( resource, state )

#define AcquireListLock() \
    EnterCriticalSection( &RmpListLock ); \
    RmpListPPrevPrevLock = RmpListPrevPrevLock; \
    RmpListPrevPrevLock = RmpListPrevLock; \
    RmpListPrevLock = RmpListLastLock; \
    RmpListLastLock.Module = RESMON_MODULE; \
    RmpListLastLock.ThreadId = GetCurrentThreadId(); \
    RmpListLastLock.LineNumber = __LINE__

#define ReleaseListLock() \
    RmpListPPrevPrevUnlock = RmpListPrevPrevUnlock; \
    RmpListPrevPrevUnlock = RmpListPrevUnlock; \
    RmpListPrevUnlock = RmpListLastUnlock; \
    RmpListLastUnlock.Module = RESMON_MODULE; \
    RmpListLastUnlock.ThreadId = GetCurrentThreadId(); \
    RmpListLastUnlock.LineNumber =  __LINE__; \
    LeaveCriticalSection( &RmpListLock )

#define AcquireEventListLock( EventList ) \
    EnterCriticalSection( &(EventList)->ListLock ); \
    (EventList)->PPrevPrevListLock = (EventList)->PrevPrevListLock; \
    (EventList)->PrevPrevListLock = (EventList)->PrevListLock; \
    (EventList)->PrevListLock = (EventList)->LastListLock; \
    (EventList)->LastListLock.Module = RESMON_MODULE; \
    (EventList)->LastListLock.ThreadId = GetCurrentThreadId(); \
    (EventList)->LastListLock.LineNumber = __LINE__

#define ReleaseEventListLock( EventList ) \
    (EventList)->PPrevPrevListUnlock = (EventList)->PrevPrevListUnlock; \
    (EventList)->PrevPrevListUnlock = (EventList)->PrevListUnlock; \
    (EventList)->PrevListUnlock = (EventList)->LastListUnlock; \
    (EventList)->LastListUnlock.Module = RESMON_MODULE; \
    (EventList)->LastListUnlock.ThreadId = GetCurrentThreadId(); \
    (EventList)->LastListUnlock.LineNumber = __LINE__; \
    (EventList)->LockOwnerResource = NULL; \
    (EventList)->MonitorState = RmonIdle; \
    LeaveCriticalSection( &(EventList)->ListLock )

//
// Data global to Resource Monitor
//
extern CRITICAL_SECTION RmpListLock;
extern LOCK_INFO RmpListPPrevPrevLock;
extern LOCK_INFO RmpListPrevPrevLock;
extern LOCK_INFO RmpListPrevLock;
extern LOCK_INFO RmpListLastLock;
extern LOCK_INFO RmpListLastUnlock;
extern LOCK_INFO RmpListPrevUnlock;
extern LOCK_INFO RmpListPrevPrevUnlock;
extern LOCK_INFO RmpListPPrevPrevUnlock;

extern CRITICAL_SECTION RmpMonitorStateLock;
extern PMONITOR_STATE RmpSharedState;
extern CL_QUEUE RmpNotifyQueue;
extern HKEY RmpResourcesKey;
extern HKEY RmpResTypesKey;
extern HCLUSTER RmpHCluster;
extern BOOL RmpShutdown;
extern LIST_ENTRY RmpEventListHead;
extern HANDLE RmpWaitArray[];
extern HANDLE RmpRewaitEvent;
extern HANDLE RmpClusterProcess;
extern DWORD RmpNumberOfThreads;
extern BOOL  RmpDebugger;

//
// Interfaces for manipulating the resource lists
//
VOID
RmpRundownResources(
    VOID
    );

DWORD
RmpInsertResourceList(
    IN PRESOURCE Resource,
    IN OPTIONAL PPOLL_EVENT_LIST pPollEventList
    );

VOID
RmpRemoveResourceList(
    IN PRESOURCE Resource
    );


DWORD
RmpOfflineResource(
    IN RESID ResourceId,
    IN BOOL  Shutdown,
    OUT DWORD *pdwState
    );

DWORD
RmpSetResourceStatus(
    IN RESOURCE_HANDLE  ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

VOID
RmpLogEvent(
    IN RESOURCE_HANDLE  ResourceHandle,
    IN LOG_LEVEL        LogLevel,
    IN LPCWSTR          FormatString,
    ...
    );

VOID
RmpLostQuorumResource(
    IN RESOURCE_HANDLE ResourceHandle
    );

//
// Interfaces for interfacing with the poller thread
//
DWORD
RmpPollerThread(
    IN LPVOID lpParameter
    );

VOID
RmpSignalPoller(
    IN PPOLL_EVENT_LIST EventList
    );

PVOID
RmpCreateEventList(
    VOID
    );

DWORD
RmpAddPollEvent(
    IN PPOLL_EVENT_LIST EventList,
    IN HANDLE EventHandle,
    IN PRESOURCE Resource
    );

DWORD
RmpRemovePollEvent(
    IN HANDLE EventHandle
    );

DWORD
RmpResourceEventSignaled(
    IN PPOLL_EVENT_LIST EventList,
    IN DWORD EventIndex
    );

//
// Notification interfaces
//
typedef enum _NOTIFY_REASON {
    NotifyResourceStateChange,
    NotifyResourceResuscitate,
    NotifyShutdown
} NOTIFY_REASON;

VOID
RmpPostNotify(
    IN PRESOURCE Resource,
    IN NOTIFY_REASON Reason
    );

DWORD
RmpTimerThread(
    IN LPVOID Context
    );

DWORD
RmpResourceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceGetCommonProperties(
    IN PRESOURCE Resource,
    IN BOOL     ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceValidateCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceSetCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceEnumPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceGetPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceValidatePrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceSetPrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceGetFlags(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeEnumCommonProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeGetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN BOOL   ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeValidateCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeSetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeEnumPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeGetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeValidatePrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeSetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeGetFlags(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

#ifdef COMRES
DWORD RmpLoadResType(
    IN  LPCWSTR                 lpszResourceTypeName,
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_FNINFO          pResDllFnInfo,
    OUT PRESDLL_INTERFACES      pResDllInterfaces,
    OUT LPDWORD                 pdwCharacteristics
);

DWORD RmpLoadComResType(
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_INTERFACES      pResDllInterfaces,
    OUT LPDWORD                 pdwCharacteristics
    );

#else

DWORD RmpLoadResType(
    IN  LPCWSTR                 lpszResourceTypeName,
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_FNINFO          pResDllFnInfo,
    OUT LPDWORD                 pdwCharacteristics
);

#endif

VOID
GenerateExceptionReport(
    IN PEXCEPTION_POINTERS pExceptionInfo
    );

VOID
DumpCriticalSection(
    IN PCRITICAL_SECTION CriticalSection
    );

BOOL
RmpAcquireSpinLock(
    IN PRESOURCE pResource,
    IN BOOL fSpin
    );

VOID
RmpReleaseSpinLock(
    IN PRESOURCE pResource
    );


#endif //_RESMONP_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\resmon.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resmon.c

Abstract:

    Startup and initialization portion of the Cluster Resource Monitor

Author:

    John Vert (jvert) 30-Nov-1995


Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusverp.h"

#ifdef COMRES
#include "comres_i.c"
#endif

#define RESMON_MODULE RESMON_MODULE_RESMON

//
// Global data
//
CRITICAL_SECTION RmpListLock;
LOCK_INFO RmpListPPrevPrevLock;
LOCK_INFO RmpListPrevPrevLock;
LOCK_INFO RmpListPrevLock;
LOCK_INFO RmpListLastLock;
LOCK_INFO RmpListLastUnlock;
LOCK_INFO RmpListPrevUnlock;
LOCK_INFO RmpListPrevPrevUnlock;
LOCK_INFO RmpListPPrevPrevUnlock;
CRITICAL_SECTION RmpMonitorStateLock;
PMONITOR_STATE RmpSharedState = NULL;
HANDLE RmpInitEvent = NULL;
HANDLE RmpFileMapping = NULL;
HANDLE RmpClusterProcess = NULL;
HKEY RmpResourcesKey = NULL;
HKEY RmpResTypesKey = NULL;
HCLUSTER RmpHCluster = NULL;
HANDLE RmpWaitArray[MAX_THREADS];
HANDLE RmpRewaitEvent = NULL;
DWORD  RmpNumberOfThreads = 0;
BOOL   RmpDebugger = FALSE;
BOOL   RmpCrashed = FALSE;
LPTOP_LEVEL_EXCEPTION_FILTER lpfnOriginalExceptionFilter = NULL;

PWCHAR RmonStates[] = {
    L"",       // Initializing
    L"",       // Idle
    L"Starting",
    L"Initializing",
    L"Online",
    L"Offline",
    L"Shutdown",
    L"Deleteing",
    L"IsAlivePoll",
    L"LooksAlivePoll",
    L"Arbitrate",
    L"Release"
    L"ResourceControl",
    L"ResourceTypeControl",
    0 };


//
// Prototypes local to this module
//

DWORD
RmpInitialize(
    VOID
    );

VOID
RmpCleanup(
    VOID
    );

VOID
RmpParseArgs(
    int argc,
    wchar_t *argv[],
    OUT LPDWORD pClussvcProcessId, 
    OUT HANDLE* pClussvcFileMapping, 
    OUT HANDLE* pClussvcInitEvent,
    OUT LPWSTR* pDebuggerCommand
    );


LONG
RmpExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
/*++

Routine Description:

    Top level exception handler for the resource monitor process.
    Currently this just exits immediately and assumes that the
    cluster service will notice and clean up the mess.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/

{
    DWORD  code = 0;

    if ( !RmpCrashed ) {
        RmpCrashed = TRUE;
        code = ExceptionInfo->ExceptionRecord->ExceptionCode;
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Exception. Code = 0x%1!lx!, Address = 0x%2!lx!\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               ExceptionInfo->ExceptionRecord->ExceptionAddress);
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Exception parameters: %1!lx!, %2!lx!, %3!lx!, %4!lx!\n",
                ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[2],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[3]);
        CL_LOGFAILURE(ExceptionInfo->ExceptionRecord->ExceptionCode);

        if (lpfnOriginalExceptionFilter)
            lpfnOriginalExceptionFilter(ExceptionInfo);

    }

    //
    // Dump an exception report
    //
    GenerateExceptionReport(ExceptionInfo);

    //
    // Try to dump the resource and the resource state
    //
    try {
        PRESOURCE resource;
        DWORD     state = 0;

        resource = (PRESOURCE)RmpSharedState->ActiveResource;

        if ( state <= RmonResourceTypeControl ) {
            state =RmpSharedState->State;
        }

        ClRtlLogPrint( LOG_CRITICAL, "[RM] Active Resource = %1!08LX!\n",
                   resource );
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Resource State is %1!u!,  \"%2!ws!\"\n",
                   RmpSharedState->State,
                   RmonStates[RmpSharedState->State] ); 

        if ( resource ) {
            ClRtlLogPrint( LOG_CRITICAL, "[RM] Resource name is %1!ws!\n",
                        resource->ResourceName );
            ClRtlLogPrint( LOG_CRITICAL, "[RM] Resource type is %1!ws!\n",
                        resource->ResourceType );
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Exception %1!08LX! while dumping state for resource!\n",
            GetExceptionCode());
    }

    if ( code == 0xC0000194 ) {
        DumpCriticalSection( (PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[0] );
    }

    if ( IsDebuggerPresent()) {
        return(EXCEPTION_CONTINUE_SEARCH);
    } else {

#if !CLUSTER_BETA
        // terminate only when product ships

        TerminateProcess( GetCurrentProcess(),
                          ExceptionInfo->ExceptionRecord->ExceptionCode );
#endif

        return(EXCEPTION_CONTINUE_SEARCH);
    }
}


int _cdecl
wmain (argc, argv)
    int     argc;
    wchar_t *argv[];
{
    PVOID EventList;
    DWORD Status;
    HANDLE ResourceId;
    CLUSTER_RESOURCE_STATE ResourceState;
    WCHAR rpcEndpoint[80];
    HKEY ClusterKey;
    BOOL Inited = FALSE;
    BOOL comInited = FALSE;
    BOOL   bSuccess;
    HANDLE ClussvcFileMapping, ClussvcInitEvent;
    DWORD ClussvcProcessId;
    LPWSTR debuggerCommand = NULL;

    //
    // Initialize the Cluster Rtl routines.
    //
    if ( (Status = ClRtlInitialize( FALSE, NULL )) != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] Failed to initialize Cluster RTL, error %1!u!.\n",
                      Status);
        goto init_failure;
    }
    ClRtlInitWmi(NULL);

    Inited = TRUE;

    //
    // Parse the input arguments.
    //

    RmpParseArgs(argc, argv, 
                 &ClussvcProcessId, 
                 &ClussvcFileMapping, 
                 &ClussvcInitEvent,
                 &debuggerCommand);

    if ((ClussvcInitEvent == NULL) ||
        (ClussvcFileMapping == NULL) ||
        (ClussvcProcessId == 0)) {
        //
        // All of these arguments are required.
        //
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to parse required parameter.\n");
        Status = ERROR_INVALID_PARAMETER;

        goto init_failure;
    }

    //
    // We do not want to create resmon process with InheritHandles flag.
    // So resmon parameters got changed. We no longer pass handles valid in
    // the context of resmon.
    //

    //
    // First, convert ProcessId into ProcessHandle
    //
    RmpClusterProcess = OpenProcess(PROCESS_ALL_ACCESS, 
                                    FALSE, // Don't inherit
                                    ClussvcProcessId);
        
    if (RmpClusterProcess == NULL) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] OpenProcess for %1!x! process failed, error %2!u!.\n",
                    RmpClusterProcess, Status);
        goto init_failure;
    }

    //
    // Now Dup the handles from ClusSvc to Resmon
    //

    bSuccess = DuplicateHandle(
                    RmpClusterProcess,  // Source Process
                    ClussvcInitEvent,   // Source Handle
                    GetCurrentProcess(),// Target Process
                    &RmpInitEvent,      // Target Handle
                    0,                  // DUPLICATE_SAME_ACCESS
                    FALSE,              // Don't inherit 
                    DUPLICATE_SAME_ACCESS);

    if (!bSuccess) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Dup InitEvent handle %1!x! failed, error %2!u!.\n",
                    ClussvcInitEvent, Status);
        goto init_failure;
    }

    bSuccess = DuplicateHandle(
                    RmpClusterProcess,  // Source Process
                    ClussvcFileMapping, // Source Handle
                    GetCurrentProcess(),// Target Process
                    &RmpFileMapping,    // Target Handle
                    0,                  // DUPLICATE_SAME_ACCESS
                    FALSE,              // Don't inherit 
                    DUPLICATE_SAME_ACCESS);

    if (!bSuccess) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Dup FileMapping handle %1!x! failed, error %2!u!.\n",
                    ClussvcFileMapping, Status);
        goto init_failure;
    }

    if ( debuggerCommand ) {
        //
        // if -d was specified, then check if the optional command arg was
        // specified. If not, wait for a debugger to be attached
        // external. Otherwise, append the PID to the passed command and call
        // CreateProcess on it.
        //
        if ( *debuggerCommand == UNICODE_NULL ) {
            while ( !IsDebuggerPresent()) {
                Sleep( 1000 );
            }
        } else {
            STARTUPINFOW startupInfo;
            PROCESS_INFORMATION processInfo;
            DWORD cmdLength;
            PWCHAR dbgCmdLine;

            cmdLength = wcslen( debuggerCommand );
            dbgCmdLine = LocalAlloc( LMEM_FIXED, ( cmdLength + 24 ) * sizeof( WCHAR ));
            if ( dbgCmdLine != NULL ) {
                wsprintfW(dbgCmdLine, L"%ws -p %d", debuggerCommand, GetCurrentProcessId());
                ClRtlLogPrint(LOG_NOISE, "[RM] Starting debugger process: %1!ws!\n", dbgCmdLine );

                //
                // Attempt to attach debugger to us
                //
                ZeroMemory(&startupInfo, sizeof(startupInfo));
                startupInfo.cb = sizeof(startupInfo);

                bSuccess = CreateProcessW(NULL,
                                          dbgCmdLine,
                                          NULL,
                                          NULL,
                                          FALSE,                 // Inherit handles
                                          DETACHED_PROCESS,      // so ctrl-c won't kill it
                                          NULL,
                                          NULL,
                                          &startupInfo,
                                          &processInfo);
                if (!bSuccess) {
                    Status = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                                  "[RM] Failed to create debugger process, error %1!u!.\n",
                                  Status);
                }

                CloseHandle(processInfo.hThread);           // don't need these
                CloseHandle(processInfo.hProcess);
                LocalFree( dbgCmdLine );
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] Failed to alloc memory for debugger command line, error %1!u!.\n",
                              GetLastError());
            }
        }
    }

    //
    // init COM for netname
    //
    Status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
    if ( !SUCCEEDED( Status )) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Couldn't init COM %1!08X!\n", Status );
        goto init_failure;
    }
    comInited = TRUE;

    ClRtlLogPrint( LOG_NOISE, "[RM] Main: Initializing.\r\n");

    //
    // Initialize the resource monitor.
    //
    Status = RmpInitialize();

    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to initialize, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    RmpSharedState = MapViewOfFile(RmpFileMapping,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0);
    if (RmpSharedState == NULL) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to init shared state, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }
    CloseHandle(RmpFileMapping);
    RmpFileMapping =  NULL;

    GetSystemTimeAsFileTime((PFILETIME)&RmpSharedState->LastUpdate);
    RmpSharedState->State = RmonInitializing;
    RmpSharedState->ActiveResource = NULL;
    if ( RmpSharedState->ResmonStop ) {
        // If ResmonStop is set to TRUE, then a debugger should be attached
        RmpDebugger = TRUE;
    }


    //
    // Connect to local cluster and open Resources key.
    //
    RmpHCluster = OpenCluster(NULL);
    if (RmpHCluster == NULL) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Error opening cluster, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    ClusterKey = GetClusterKey(RmpHCluster, KEY_READ);
    if (ClusterKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to open the cluster key, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = ClusterRegOpenKey(ClusterKey,
                               CLUSREG_KEYNAME_RESOURCES,
                               KEY_READ,
                               &RmpResourcesKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to open Resources cluster registry key, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = ClusterRegOpenKey(ClusterKey,
                               CLUSREG_KEYNAME_RESOURCE_TYPES,
                               KEY_READ,
                               &RmpResTypesKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to open ResourceTypes cluster registry key, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    // The Wait Count identifies the number of events the main thread will
    // wait for. This is the notification event, the Cluster Service Process
    // plus each event list thread. We start at 2 because the first two entries
    // are fixed - for the notification event and the Cluster Service process.
    //

    RmpNumberOfThreads = 2;

    //
    // Create an event to be signaled whenever we add a new thread.
    //

    RmpRewaitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( RmpRewaitEvent == NULL ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to create rewait event, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }

    //
    // Create the first event list, and start a polling thread.
    //
    EventList = RmpCreateEventList();

    if (EventList == NULL) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to create event list, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }

    //
    // Start RPC Server
    //
    wsprintfW( rpcEndpoint, L"resrcmon%d", GetCurrentProcessId());
    Status = RpcServerUseProtseqEpW(L"ncalrpc",
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                    rpcEndpoint,
                                    NULL);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to initialize RPC interface, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = RpcServerRegisterIf(s_resmon_v2_0_s_ifspec,
                                 NULL,
                                 NULL);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to register RPC interface, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to set RPC server listening, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    // Set our unhandled exception filter so that if anything horrible
    // goes wrong, we can exit immediately.
    //
    lpfnOriginalExceptionFilter = SetUnhandledExceptionFilter(RmpExceptionFilter);

    //
    // Set the event to indicate that our initialization is complete.
    // This event is passed on the command line.
    //
    if (!SetEvent(RmpInitEvent)) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to signal cluster service event, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }
    CloseHandle(RmpInitEvent);

    //
    // ResmonStop is initialized to TRUE by ClusSvc, we will wait for
    // ClusSvc to signal when it is done attaching a debugger by waiting
    // until ResmonStop is set to FALSE.
    //
    while ( RmpSharedState->ResmonStop ) {
        Sleep(100);
    }

    //
    // Boost our priority. Non-fatal if this fails.
    //
    if ( !SetPriorityClass( GetCurrentProcess(),
                            HIGH_PRIORITY_CLASS ) ) {
        ClRtlLogPrint( LOG_UNUSUAL, "[RM] Failed to set priority class, error %1!u!.\n",
                   GetLastError() );
    }

    //
    // Wait for shutdown. Either the cluster service terminating or
    // the poller thread terminating will initiate a shutdown.
    //
    RmpWaitArray[0] = RmpRewaitEvent;
    RmpWaitArray[1] = RmpClusterProcess;

    //
    // If we are notified a new thread is added, then just re-wait.
    // N.B. RmpNumberOfThreads is really the number of threads, plus the
    // two fixed wait events (the change notification and the Cluster Service).
    //

    do {
        Status = WaitForMultipleObjects(RmpNumberOfThreads,
                                        RmpWaitArray,
                                        FALSE,
                                        INFINITE);

    } while ( (Status == WAIT_OBJECT_0) && (RmpShutdown == FALSE) );

    ClRtlLogPrint( LOG_UNUSUAL, "[RM] Going away, Status = %1!u!, Shutdown = %2!u!.\n",
                  Status, RmpShutdown);

    RmpShutdown = TRUE;
    CloseHandle( RmpRewaitEvent );

    //
    // Initiate RM shutdown.
    //
    s_RmShutdownProcess(NULL);

    //
    // Clean up any resources left lying around by the cluster service.
    //
    RmpRundownResources();

    //
    // Shutdown RPC Server
    //
    RpcMgmtStopServerListening(NULL);
    RpcServerUnregisterIf(NULL, NULL, TRUE);

    CoUninitialize () ;

    return(0);

init_failure:
    if ( RmpInitEvent != NULL ) {
        CloseHandle( RmpInitEvent );
    }
    if ( RmpFileMapping != NULL ) {
        CloseHandle( RmpFileMapping );
    }
    if ( RmpClusterProcess != NULL ) {
        CloseHandle( RmpClusterProcess );
    }
    if ( RmpResTypesKey != NULL ) {
        ClusterRegCloseKey( RmpResTypesKey );
    }
    if ( RmpResourcesKey != NULL ) {
        ClusterRegCloseKey( RmpResourcesKey );
    }
    if ( RmpHCluster != NULL ) {
        CloseCluster( RmpHCluster );
    }
    if ( RmpRewaitEvent != NULL ) {
        CloseHandle( RmpRewaitEvent );
    }

    if ( comInited )
        CoUninitialize();

    if ( Inited )
        CL_LOGFAILURE(Status);

    return(Status);

} // main



VOID
RmpParseArgs(
    int argc,
    wchar_t *argv[],
    OUT LPDWORD pClussvcProcessId, 
    OUT HANDLE* pClussvcFileMapping, 
    OUT HANDLE* pClussvcInitEvent,
    OUT LPWSTR* pDebuggerCommand
    )

/*++

Routine Description:

    Parses the command line passed to the resource monitor

    Required options:
        -e EVENT  supplies Event handle to be signalled when
                  initialization is complete
        -m FILEMAPPING  supplies file mapping handle to be
                  used for shared monitor state.
        -p PROCESSID supplies process id of the cluster
                  service so resmon can detect failure of the
                  cluster service and shutdown cleanly.

        -d [DEBUGGERCMD] - wait for or attach a debugger during startup

    Additional options:
        none

Arguments:

    argc - supplies number of arguments

    argv - supplies actual arguments

Return Value:

    None.

--*/

{
    int i;
    wchar_t *p;

    for (i=1; i<argc; i++) {
        p=argv[i];
        if ((*p == '-') ||
            (*p == '/')) {

            ++p;

            switch (toupper(*p)) {
                case 'E':
                    if (i+1 < argc) {
                        *pClussvcInitEvent = LongToHandle(_wtoi(argv[++i]));
                    } else {
                        goto BadCommandLine;
                    }
                    break;

                case 'M':
                    if (i+1 < argc) {
                        *pClussvcFileMapping = LongToHandle(_wtoi(argv[++i]));
                    } else {
                        goto BadCommandLine;
                    }
                    break;

                case 'P':
                    if (i+1 < argc) {
                        *pClussvcProcessId = (DWORD)_wtoi(argv[++i]);
                    } else {
                        goto BadCommandLine;
                    }
                    break;

                case 'D':
                    //
                    // use the empty (but not NULL) string to indicate that
                    // resmon should wait for a debugger to be attached.
                    //
                    if (i+1 < argc) {
                        if ( *argv[i+1] != UNICODE_NULL && *argv[i+1] != L'-' ) {
                            *pDebuggerCommand = argv[++i];
                        } else {
                            *pDebuggerCommand = L"";
                        }
                    } else {
                        *pDebuggerCommand = L"";
                    }
                    break;

                default:
                    goto BadCommandLine;

            }
        }
    }

    return;

BadCommandLine:

    ClusterLogEvent0(LOG_CRITICAL,
                     LOG_CURRENT_MODULE,
                     __FILE__,
                     __LINE__,
                     RMON_INVALID_COMMAND_LINE,
                     0,
                     NULL);
    ExitProcess(0);

} // RmpParseArgs



DWORD
RmpInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize all resources needed by the resource monitor.

Arguments:

    None.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    //
    // Initialize global data
    //
    InitializeCriticalSection(&RmpListLock);
    InitializeCriticalSection(&RmpMonitorStateLock);
    InitializeListHead(&RmpEventListHead);
    ClRtlInitializeQueue(&RmpNotifyQueue);

    return(ERROR_SUCCESS);

} // RmpInitialize



VOID
RmpCleanup(
    VOID
    )

/*++

Routine Description:

    Cleanup all resources created during init.

Arguments:

    None.

Returns:

    None.

--*/

{

} // RmpCleanup



DWORD RmpLoadResType(
    IN      LPCWSTR                 lpszResourceTypeName,
    IN      LPCWSTR                 lpszDllName,
    OUT     PRESDLL_FNINFO          pResDllFnInfo,
#ifdef COMRES
    OUT     PRESDLL_INTERFACES      pResDllInterfaces,
#endif
    OUT     LPDWORD                 pdwCharacteristics
)
{
    DWORD                   retry;
    DWORD                   dwStatus = ERROR_SUCCESS;
    HINSTANCE               hDll = NULL;
    PSTARTUP_ROUTINE        pfnStartup;
    PCLRES_FUNCTION_TABLE   pFnTable = NULL;
    LPWSTR                  pszDllName = (LPWSTR) lpszDllName;

    pResDllFnInfo->hDll = NULL;
    pResDllFnInfo->pResFnTable = NULL;

#ifdef COMRES
    pResDllInterfaces->pClusterResource = NULL;
    pResDllInterfaces->pClusterQuorumResource = NULL;
    pResDllInterfaces->pClusterResControl = NULL;

#endif

    // Expand any environment variables included in the DLL path name.
    if ( wcschr( lpszDllName, L'%' ) != NULL ) {
        pszDllName = ClRtlExpandEnvironmentStrings( lpszDllName );
        if ( pszDllName == NULL ) {
            dwStatus = GetLastError();
            ClRtlLogPrint( LOG_UNUSUAL, "[RM] ResTypeControl: Error expanding environment strings in '%1!ls!, error %2!u!.\n",
                       lpszDllName,
                       dwStatus);
            goto FnExit;
        }
    }

    // Load the dll... we can't assume we have the DLL loaded!
    hDll = LoadLibraryW(pszDllName);

    if ( hDll == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Error loading resource DLL '%1!ls!, error %2!u!.\n",
                   pszDllName,
                   dwStatus);
    #ifdef COMRES
        dwStatus = RmpLoadComResType(lpszDllName, pResDllInterfaces,
                        pdwCharacteristics);
    #endif
        goto FnExit;
    }

    //
    // Invoke debugger if one is specified.
    //
    if ( RmpDebugger ) {
        //
        // Wait for debugger to come online.
        //
        retry = 100;
        while ( retry-- &&
                !IsDebuggerPresent() ) {
            Sleep(100);
        }
        OutputDebugStringA("[RM] ResourceTypeControl: Just loaded resource DLL ");
        OutputDebugStringW(lpszDllName);
        OutputDebugStringA("\n");
        DebugBreak();
    }

    // Get the startup routine
    pfnStartup = (PSTARTUP_ROUTINE)GetProcAddress( hDll,
                                                STARTUP_ROUTINE );
    if ( pfnStartup == NULL ) {
        dwStatus = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Error getting startup routine, status %1!u!.\n",
            dwStatus);
        goto FnExit;
    }

    // Get the function table
    RmpSetMonitorState(RmonStartingResource, NULL);
    try {
        dwStatus = (pfnStartup)( lpszResourceTypeName,
                            CLRES_VERSION_V1_00,
                            CLRES_VERSION_V1_00,
                            RmpSetResourceStatus,
                            RmpLogEvent,
                            &pFnTable );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetExceptionCode();
    }
    RmpSetMonitorState(RmonIdle, NULL);

    if ( dwStatus != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Startup call failed, error %1!u!.\n",
                   dwStatus);
        goto FnExit;
    }

    if ( pFnTable == NULL ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Startup function table is NULL!\n");
        dwStatus = ERROR_INVALID_DATA;
        goto FnExit;
    }

    if ( pFnTable->Version != CLRES_VERSION_V1_00 ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Incorrect function table version!\n");
        dwStatus = ERROR_INVALID_DATA;
        goto FnExit;
    }

    if ( pFnTable->TableSize != CLRES_V1_FUNCTION_SIZE ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Incorrect function table size!\n");
        dwStatus = ERROR_INVALID_DATA;
        goto FnExit;
    }

    if ( (pFnTable->V1Functions.Arbitrate != NULL) &&
         (pFnTable->V1Functions.Release != NULL) && pdwCharacteristics) {
        *pdwCharacteristics = CLUS_CHAR_QUORUM;
    }

FnExit:
    if (dwStatus != ERROR_SUCCESS)
    {
        if (hDll) FreeLibrary(hDll);
        if (pFnTable) LocalFree(pFnTable);
    }
    else
    {
        pResDllFnInfo->hDll = hDll;
        pResDllFnInfo->pResFnTable = pFnTable;
    }
    if ( pszDllName != lpszDllName )
    {
        LocalFree( pszDllName );
    }
    return(dwStatus);

} //*** RmpLoadResType()


#ifdef COMRES
DWORD RmpLoadComResType(
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_INTERFACES      pResDllInterfaces,
    OUT LPDWORD                 pdwCharacteristics)
{
    IClusterResource          *pClusterResource = NULL ;
    IClusterQuorumResource    *pClusterQuorumResource = NULL;
    IClusterResControl        *pClusterResControl = NULL;
    HRESULT                 hr ;
    CLSID                   clsid ;
    DWORD                   Error ;

    pResDllInterfaces->pClusterResource = NULL;
    pResDllInterfaces->pClusterQuorumResource = NULL;
    pResDllInterfaces->pClusterResControl = NULL;


    hr = CLSIDFromProgID(lpszDllName, &clsid) ;
    if (FAILED (hr))
    {
        ClRtlLogPrint( LOG_UNUSUAL, "[RM] Error converting CLSIDFromProgID Prog ID %1!ws!, error %2!u!.\n",
            lpszDllName, hr);
        goto FnExit ;
    }

    if ((hr = CoCreateInstance (&clsid, NULL, CLSCTX_ALL, &IID_IClusterResource, (LPVOID *) &pClusterResource)) != S_OK)
        goto FnExit ;

    //not a mandatory interface
    hr = IClusterResource_QueryInterface (pClusterResource, &IID_IClusterQuorumResource, (LPVOID *) &pClusterQuorumResource) ;

    if (SUCCEEDED(hr))
    {
        if (pdwCharacteristics)
            *pdwCharacteristics = CLUS_CHAR_QUORUM;
        IClusterQuorumResource_Release (pClusterQuorumResource) ;
    }

    //not a mandatory interface
    hr = IClusterResource_QueryInterface (
             pClusterResource,
             &IID_IClusterResControl,
             (LPVOID *) &pClusterResControl
             ) ;

    if (SUCCEEDED(hr))
    {
        *pdwCharacteristics = CLUS_CHAR_QUORUM;
        IClusterQuorumResource_Release (pClusterResControl) ;
    }

    hr = S_OK;

FnExit:
    if (hr != S_OK)
    {
        if (pClusterResource)
            IClusterResource_Release (pClusterResource) ;
        if (pClusterQuorumResource)
            IClusterQuorumResource_Release (pClusterQuorumResource) ;
        if (pClusterResControl)
            IClusterResControl_Release (pClusterResControl) ;

    }
    else
    {
        pResDllInterfaces->pClusterResource = pClusterResource;
        pResDllInterfaces->pClusterQuorumResource = pClusterQuorumResource;
        pResDllInterfaces->pClusterResControl = pClusterResControl;
    }
    return(hr);

}

#endif  //enf of #ifdef COMRES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\apip.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    apip.h

Abstract:

    Private data structures and procedure prototypes for
    the Cluster API subcomponent of the NT Cluster
    Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/
#include "service.h"
#include "clusapi.h"
#include "api_rpc.h"

#define LOG_CURRENT_MODULE LOG_MODULE_API


//
// Event processing routine
//
DWORD
WINAPI
ApipEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

//
// Data definitions global to the API module.
//
typedef enum _API_INIT_STATE {
    ApiStateUninitialized,
    ApiStateOffline,
    ApiStateReadOnly,
    ApiStateOnline
} API_INIT_STATE;

extern API_INIT_STATE ApiState;
extern LIST_ENTRY NotifyListHead;
extern CRITICAL_SECTION NotifyListLock;

#define API_CHECK_INIT() \
            if (ApiState != ApiStateOnline) return(ERROR_SHARING_PAUSED)

#define API_ASSERT_INIT() CL_ASSERT(ApiState == ApiStateOnline)

//
// Notification port
//
typedef struct _NOTIFY_PORT {
    LIST_ENTRY ListEntry;
    CRITICAL_SECTION Lock;
    CL_QUEUE Queue;
    DWORD Filter;
    LIST_ENTRY InterestList;
    LIST_ENTRY RegistryList;
} NOTIFY_PORT, *PNOTIFY_PORT;


//
// Common API handle structure. Every RPC context handle points to one of these.
// This allows us to do our own type checking since RPC does not do this for us.
//
#define API_NOTIFY_HANDLE       1
#define API_NODE_HANDLE         2
#define API_GROUP_HANDLE        3
#define API_RESOURCE_HANDLE     4
#define API_KEY_HANDLE          5
#define API_CLUSTER_HANDLE      6
#define API_NETWORK_HANDLE      7
#define API_NETINTERFACE_HANDLE 8

#define HANDLE_DELETED          1

typedef struct _API_HANDLE {
    USHORT Type;
    USHORT Flags;
    LIST_ENTRY NotifyList;
    union {
        PNOTIFY_PORT Notify;
        PNM_NODE     Node;
        PFM_GROUP    Group;
        PFM_RESOURCE Resource;
        HDMKEY       Key;
        PVOID        Cluster;
        PNM_NETWORK  Network;
        PNM_INTERFACE NetInterface;
    };
} API_HANDLE, *PAPI_HANDLE;

#define DELETE_HANDLE(_handle_) (((PAPI_HANDLE)(_handle_))->Flags |= HANDLE_DELETED)
#define IS_HANDLE_DELETED(_handle_) (((PAPI_HANDLE)(_handle_))->Flags & HANDLE_DELETED)

#define VALIDATE_NOTIFY(_notify_, _handle_)                             \
    if (((_handle_) == NULL) ||                                         \
        (((PAPI_HANDLE)(_handle_))->Type != API_NOTIFY_HANDLE) ||       \
        IS_HANDLE_DELETED(_handle_)) {                                  \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_notify_) = ((PAPI_HANDLE)(_handle_))->Notify;                 \
    }

#define VALIDATE_NODE(_node_, _handle_)                                 \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NODE_HANDLE)) {         \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_node_) = ((PAPI_HANDLE)(_handle_))->Node;                     \
    }

#define VALIDATE_NODE_EXISTS(_node_, _handle_)                          \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NODE_HANDLE)) {         \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_node_) = ((PAPI_HANDLE)(_handle_))->Node;                     \
        if (!OmObjectInserted((_node_))) {                              \
            return(ERROR_NODE_NOT_AVAILABLE);                           \
        }                                                               \
    }

#define VALIDATE_GROUP(_group_, _handle_)                               \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_GROUP_HANDLE)) {        \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_group_) = ((PAPI_HANDLE)(_handle_))->Group;                   \
    }

#define VALIDATE_GROUP_EXISTS(_group_, _handle_)                        \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_GROUP_HANDLE)) {        \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_group_) = ((PAPI_HANDLE)(_handle_))->Group;                   \
        if (!OmObjectInserted((_group_))) {                             \
            return(ERROR_GROUP_NOT_AVAILABLE);                          \
        }                                                               \
    }

#define VALIDATE_RESOURCE(_resource_, _handle_)                         \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_RESOURCE_HANDLE)) {     \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_resource_) = ((PAPI_HANDLE)(_handle_))->Resource;             \
    }

#define VALIDATE_RESOURCE_EXISTS(_resource_, _handle_)                  \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_RESOURCE_HANDLE)) {     \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_resource_) = ((PAPI_HANDLE)(_handle_))->Resource;             \
        if (!OmObjectInserted((_resource_))) {                          \
            return(ERROR_RESOURCE_NOT_AVAILABLE);                       \
        }                                                               \
    }

#define VALIDATE_KEY(_key_, _handle_)                                   \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_KEY_HANDLE)) {          \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_key_) = ((PAPI_HANDLE)(_handle_))->Key;                       \
    }

#define VALIDATE_NETWORK(_network_, _handle_)                           \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETWORK_HANDLE)) {      \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_network_) = ((PAPI_HANDLE)(_handle_))->Network;               \
    }

#define VALIDATE_NETWORK_EXISTS(_network_, _handle_)                    \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETWORK_HANDLE)) {      \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_network_) = ((PAPI_HANDLE)(_handle_))->Network;               \
        if (!OmObjectInserted((_network_))) {                           \
            return(ERROR_NETWORK_NOT_AVAILABLE);                        \
        }                                                               \
    }

#define VALIDATE_NETINTERFACE(_netinterface_, _handle_)                 \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETINTERFACE_HANDLE)) { \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_netinterface_) = ((PAPI_HANDLE)(_handle_))->NetInterface;     \
    }

#define VALIDATE_NETINTERFACE_EXISTS(_netinterface_, _handle_)          \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETINTERFACE_HANDLE)) { \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_netinterface_) = ((PAPI_HANDLE)(_handle_))->NetInterface;     \
        if (!OmObjectInserted((_netinterface_))) {                      \
            return(ERROR_NETWORK_NOT_AVAILABLE);                        \
        }                                                               \
    }

//
// Common routines
//

#define INITIAL_ENUM_LIST_ALLOCATION    8

#define ENUM_SIZE(Entries) ((Entries-1) * sizeof(ENUM_ENTRY) + sizeof(ENUM_LIST))

VOID
ApipAddToEnum(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN LPCWSTR Name,
    IN DWORD Type
    );

LPWSTR
ApipGetObjectName(
    IN PVOID Object
    );

VOID
ApipRundownNotify(
    IN PAPI_HANDLE Handle
    );

RPC_STATUS
ApipConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    );

DWORD
ApipUnblockGetNotifyCall(
    PNOTIFY_PORT pPort
    );

DWORD
ApipValidateClusterName(
    IN LPCWSTR  lpszNewName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\property.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    property.c

Abstract:

    Implements the management of resource and resource type properties.

Author:

    Rod Gamache (rodga) 7-Jan-1996

Revision History:

--*/
#define UNICODE 1
#include "resmonp.h"
#include "clusudef.h"

#define RESMON_MODULE RESMON_MODULE_PROPERTY

#define MAX_DWORD ((DWORD)-1)

#define PARAMETERS_KEY CLUSREG_KEYNAME_PARAMETERS
#define RESOURCE_TYPES_KEY CLUSREG_KEYNAME_RESOURCE_TYPES

const WCHAR cszName[] = CLUSREG_NAME_RES_NAME;

typedef struct _COMMON_RES_PARAMS {
    LPWSTR          lpszResType;
    LPWSTR          lpszDescription;
    LPWSTR          lpszDebugPrefix;
    DWORD           dwSeparateMonitor;
    DWORD           dwPersistentState;
    DWORD           dwLooksAlive;
    DWORD           dwIsAlive;
    DWORD           dwRestartAction;
    DWORD           dwRestartThreshold;
    DWORD           dwRestartPeriod;
    DWORD           dwRetryPeriodOnFailure;
    DWORD           dwPendingTimeout;
    DWORD           dwLoadBalStartup;
    DWORD           dwLoadBalSample;
    DWORD           dwLoadBalAnalysis;
    DWORD           dwLoadBalProcessor;
    DWORD           dwLoadBalMemory;
} COMMON_RES_PARAMS, *PCOMMON_RES_PARAMS;

//
// Resource Common properties.
//

//
// Read-Write Resource Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceCommonProperties[] = {
    { CLUSREG_NAME_RES_TYPE,              NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0, FIELD_OFFSET(COMMON_RES_PARAMS, lpszResType) },
    { CLUSREG_NAME_RES_DESC,              NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0, FIELD_OFFSET(COMMON_RES_PARAMS, lpszDescription) },
    { CLUSREG_NAME_RES_DEBUG_PREFIX,      NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0, FIELD_OFFSET(COMMON_RES_PARAMS, lpszDebugPrefix) },
    { CLUSREG_NAME_RES_SEPARATE_MONITOR,  NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwSeparateMonitor) },
    { CLUSREG_NAME_RES_PERSISTENT_STATE,  NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE,  CLUSTER_RESOURCE_MINIMUM_PERSISTENT_STATE,  CLUSTER_RESOURCE_MAXIMUM_PERSISTENT_STATE, RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET(COMMON_RES_PARAMS, dwPersistentState) },
    { CLUSREG_NAME_RES_LOOKS_ALIVE,       NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE,       CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,       CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLooksAlive) },
    { CLUSREG_NAME_RES_IS_ALIVE,          NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_IS_ALIVE,          CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,          CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwIsAlive) },
    { CLUSREG_NAME_RES_RESTART_ACTION,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION,    0,                                          CLUSTER_RESOURCE_MAXIMUM_RESTART_ACTION, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRestartAction) },
    { CLUSREG_NAME_RES_RESTART_THRESHOLD, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD, CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD, CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRestartThreshold) },
    { CLUSREG_NAME_RES_RESTART_PERIOD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD,    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRestartPeriod) },
    { CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE, 0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRetryPeriodOnFailure) },
    { CLUSREG_NAME_RES_PENDING_TIMEOUT,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwPendingTimeout) },
    { CLUSREG_NAME_RES_LOADBAL_STARTUP,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOADBAL_STARTUP,   0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalStartup) },
    { CLUSREG_NAME_RES_LOADBAL_SAMPLE,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOADBAL_SAMPLE,    0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalSample) },
    { CLUSREG_NAME_RES_LOADBAL_ANALYSIS,  NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOADBAL_ANALYSIS,  0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalAnalysis) },
    { CLUSREG_NAME_RES_LOADBAL_PROCESSOR, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalProcessor) },
    { CLUSREG_NAME_RES_LOADBAL_MEMORY,    NULL, CLUSPROP_FORMAT_DWORD, 0, 0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalMemory) },
    { 0 }
};

//
// Read-Only Resource Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceROCommonProperties[] = {
    { CLUSREG_NAME_RES_NAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
//    { CLUSREG_NAME_RES_DEPENDS_ON, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
//    { CLUSREG_NAME_RES_POSSIBLE_OWNERS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { 0 }
};


//
// Resource Type Common properties
//

//
// Read-Write Resource Type Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceTypeCommonProperties[] = {
    { CLUSREG_NAME_RESTYPE_NAME,           NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_DESC,           NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,   NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC, NULL, CLUSPROP_FORMAT_DWORD,    0, 0, 1, 0 },
    { CLUSREG_NAME_ADMIN_EXT,              NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,    NULL, CLUSPROP_FORMAT_DWORD,    CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE, CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE, CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE, 0 },
    { CLUSREG_NAME_RESTYPE_IS_ALIVE,       NULL, CLUSPROP_FORMAT_DWORD,    CLUSTER_RESOURCE_DEFAULT_IS_ALIVE,    CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,    CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE, 0 },
    { 0 }
};

//
// Read-Only Resource Type Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceTypeROCommonProperties[] = {
    { CLUSREG_NAME_RESTYPE_DLL_NAME,     NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { 0 }
};

//
// Local functions
//
DWORD
RmpCheckCommonProperties(
    IN PRESOURCE pResource,
    IN PCOMMON_RES_PARAMS pCommonParams
    );


DWORD
RmpResourceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given resource.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Enumerate the common properties.
    //
    status = ResUtilEnumProperties( RmpResourceCommonProperties,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    Required );

    return(status);

} // RmpResourceEnumCommonProperties



DWORD
RmpResourceGetCommonProperties(
    IN PRESOURCE Resource,
    IN BOOL     ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    ReadOnly - TRUE to get the Read-Only Common Properties. FALSE otherwise.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    PRESUTIL_PROPERTY_ITEM propertyTable;

    //
    // Clear the output buffer
    //
    if ( OutBufferSize != 0 ) {
        ZeroMemory( OutBuffer, OutBufferSize );
    }

    if ( ReadOnly ) {
        propertyTable = RmpResourceROCommonProperties;
    } else {
        propertyTable = RmpResourceCommonProperties;
    }

    //
    // Open the cluster resource key
    //
    status = ClusterRegOpenKey( RmpResourcesKey,
                                Resource->ResourceId,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        *BytesReturned = 0;
        *Required = 0;
        return(status);
    }

    //
    // Get the common properties.
    //
    status = ResUtilGetProperties( resKey,
                                   propertyTable,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required );

    ClusterRegCloseKey( resKey );

    return(status);

} // RmpResourceGetCommonProperties



DWORD
RmpResourceValidateCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    COMMON_RES_PARAMS CommonProps;

    ZeroMemory( &CommonProps, sizeof ( COMMON_RES_PARAMS ) );

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         ( LPBYTE ) &CommonProps );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpResourceValidateCommonProperties, Error %1!d! in verify routine for resource %2!ws!\n",
                      status,
                      Resource->ResourceName);
    } else {
        //  
        //  Chittur Subbaraman (chitturs) - 5/7/99
        //
        //  Validate the values of the common properties supplied
        //
        status = RmpCheckCommonProperties( Resource, &CommonProps );
        
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceValidateCommonProperties, Error %1!d! in "
                          "checking routine for resource %2!ws!\n",
                          status,
                          Resource->ResourceName);
        }
    }

    ResUtilFreeParameterBlock(( LPBYTE ) &CommonProps,
                               NULL,
                               RmpResourceCommonProperties
                             );

    return(status);
} // RmpResourceValidateCommonProperties



DWORD
RmpResourceSetCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    HKEY                    resKey = NULL;
    DWORD                   oldSeparateMonitor;
    DWORD                   newSeparateMonitor;
    COMMON_RES_PARAMS       CommonProps;

    ZeroMemory( &CommonProps, sizeof ( COMMON_RES_PARAMS ) );
    
    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         ( LPBYTE ) &CommonProps );

    if ( status == ERROR_SUCCESS ) {
        //  
        //  Chittur Subbaraman (chitturs) - 5/7/99
        //
        //  Validate the values of the common properties supplied
        //
        status = RmpCheckCommonProperties( Resource, &CommonProps );
        
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceSetCommonProperties, Error %1!d! in "
                          "checking routine for resource %2!ws!\n",
                          status,
                          Resource->ResourceName);
            goto FnExit;
        }
    
        //
        // Open the cluster resource key
        //
        status = ClusterRegOpenKey( RmpResourcesKey,
                                    Resource->ResourceId,
                                    KEY_READ,
                                    &resKey );

        if ( status != ERROR_SUCCESS ) {
            goto FnExit;
        }

        //
        // Get the current SeparateMonitor value.
        //
        status = ResUtilGetDwordValue( resKey,
                                       CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                       &oldSeparateMonitor,
                                       0 );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceSetCommonProperties, error %1!d! in getting "
                          "'SeparateMonitor' value for resource %2!ws!.\n",
                          status,
                          Resource->ResourceName);
            goto FnExit;
        }

        status = ResUtilSetPropertyTable( resKey,
                                          RmpResourceCommonProperties,
                                          NULL,     // Reserved
                                          FALSE,    // Don't allow unknowns
                                          InBuffer,
                                          InBufferSize,
                                          NULL );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceSetCommonProperties, Error %1!d! in set routine for resource %2!ws!.\n",
                          status,
                          Resource->ResourceName);
        } else {
            //
            // Get the new SeparateMonitor value.  If it changed, return a
            // different error code.
            //
            status = ResUtilGetDwordValue( resKey,
                                           CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                           &newSeparateMonitor,
                                           0 );

            if ( status == ERROR_SUCCESS ) {
                if ( oldSeparateMonitor != newSeparateMonitor ) {
                    status = ERROR_RESOURCE_PROPERTIES_STORED;
                }
            }
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpResourceSetCommonProperties, error %1!d! in verify routine for resource %2!ws!.\n",
                      status,
                      Resource->ResourceName);
    }

FnExit:
    ResUtilFreeParameterBlock(( LPBYTE ) &CommonProps,
                               NULL,
                               RmpResourceCommonProperties
                             );
    if ( resKey != NULL ) {
        ClusterRegCloseKey( resKey );
    }

    return( status );
} // RmpResourceSetCommonProperties



DWORD
RmpResourceEnumPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given resource.

Arguments:

    Resource - Supplies the resource.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    WCHAR       PrivateProperties[] = L"12345678-1234-1234-1234-123456789012\\Parameters";

    *BytesReturned = 0;
    *Required = 0;

    //
    // Copy the ResourceId for opening the private properties.
    //
    CL_ASSERT( lstrlenW( Resource->ResourceId ) == (32+4) );

    MoveMemory( PrivateProperties,
                Resource->ResourceId,
                lstrlenW( Resource->ResourceId ) * sizeof(WCHAR) );

    //
    // Open the cluster resource key
    //
    status = ClusterRegOpenKey( RmpResourcesKey,
                                PrivateProperties,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Enumerate the private properties.
    //
    status = ResUtilEnumPrivateProperties( resKey,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required );
    ClusterRegCloseKey( resKey );

    return(status);

} // RmpResourceEnumPrivateProperties



DWORD
RmpResourceGetPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    WCHAR       PrivateProperties[] = L"12345678-1234-1234-1234-123456789012\\Parameters";

    *BytesReturned = 0;
    *Required = 0;

    //
    // Copy the ResourceId for opening the private properties.
    //
    CL_ASSERT( lstrlenW( Resource->ResourceId ) == (32+4) );

    MoveMemory( PrivateProperties,
                Resource->ResourceId,
                lstrlenW( Resource->ResourceId ) * sizeof(WCHAR) );

    //
    // Open the cluster resource key
    //
    status = ClusterRegOpenKey( RmpResourcesKey,
                                PrivateProperties,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            if ( OutBufferSize < sizeof( DWORD ) ) {
                *Required = 4;
            } else {
                *((LPDWORD) OutBuffer) = 0;
                *BytesReturned = sizeof( DWORD );
            }
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Get private properties for the resource.
    //
    status = ResUtilGetPrivateProperties( resKey,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );

    ClusterRegCloseKey( resKey );

    return(status);

} // RmpResourceGetPrivateProperties



DWORD
RmpResourceValidatePrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    return(status);

} // RmpResourceValidatePrivateProperties



DWORD
RmpResourceSetPrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    WCHAR       PrivateProperties[] = L"12345678-1234-1234-1234-123456789012\\Parameters";

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Copy the ResourceId for opening the private properties.
        //
        CL_ASSERT( lstrlenW( Resource->ResourceId ) == (32+4) );

        MoveMemory( PrivateProperties,
                    Resource->ResourceId,
                    lstrlenW(Resource->ResourceId) * sizeof(WCHAR) );

        //
        // Open the cluster resource key
        //
        status = ClusterRegOpenKey( RmpResourcesKey,
                                    PrivateProperties,
                                    KEY_READ,
                                    &resKey );
        if ( status != ERROR_SUCCESS ) {
            return(status);
        }

        status = ResUtilSetPrivatePropertyList( resKey,
                                                InBuffer,
                                                InBufferSize );
        ClusterRegCloseKey( resKey );
    }

    return(status);

} // RmpResourceSetPrivateProperties



DWORD
RmpResourceGetFlags(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given resource.

Arguments:

    Resource - Supplies the resource.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        HKEY        resKey;
        DWORD       valueType;

        //
        // Open the cluster resource key
        //
        status = ClusterRegOpenKey( RmpResourcesKey,
                                    Resource->ResourceId,
                                    KEY_READ,
                                    &resKey );
        if ( status == ERROR_SUCCESS ) {
            //
            // Read the Flags value for the resource.
            //
            *BytesReturned = OutBufferSize;
            status = ClusterRegQueryValue( resKey,
                                           CLUSREG_NAME_FLAGS,
                                           &valueType,
                                           OutBuffer,
                                           BytesReturned );
            ClusterRegCloseKey( resKey );
            if ( status == ERROR_FILE_NOT_FOUND ) {
                *BytesReturned = sizeof(DWORD);
                *(LPDWORD)OutBuffer = 0;
                status = ERROR_SUCCESS;
            }
        }
    }

    return(status);

} // RmpResourceGetFlags



DWORD
RmpResourceTypeEnumCommonProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type's name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Enumerate the common properties.
    //
    status = ResUtilEnumProperties( RmpResourceTypeCommonProperties,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    Required );

    return(status);

} // RmpResourceTypeEnumCommonProperties



DWORD
RmpResourceTypeGetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN BOOL    ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resourceTypesKey;
    HKEY        resTypeKey;
    PRESUTIL_PROPERTY_ITEM propertyTable;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    if ( ReadOnly ) {
        propertyTable = RmpResourceTypeROCommonProperties;
    } else {
        propertyTable = RmpResourceTypeCommonProperties;
    }
        
    //
    // Open the specific cluster ResourceType key
    //
    status = ClusterRegOpenKey( RmpResTypesKey,
                                ResourceTypeName,
                                KEY_READ,
                                &resTypeKey );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Get the common properties.
    //
    status = ResUtilGetProperties( resTypeKey,
                                   propertyTable,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required );

    ClusterRegCloseKey( resTypeKey );

    return(status);

} // RmpResourceTypeGetCommonProperties



DWORD
RmpResourceTypeValidateCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceTypeCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpResourceTypeValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // RmpResourceTypeValidateCommonProperties



DWORD
RmpResourceTypeSetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    HKEY    resourceTypesKey;
    HKEY    resTypeKey;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceTypeCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         NULL );

    if ( status == ERROR_SUCCESS ) {
        //
        // Open the specific cluster resource type key
        //
        status = ClusterRegOpenKey( RmpResTypesKey,
                                    ResourceTypeName,
                                    KEY_READ,
                                    &resTypeKey );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] Failed to open ResourceTypes\\%1 cluster registry key, error %2!u!.\n",
                          ResourceTypeName,
                          status);
            return(status);
        }

        status = ResUtilSetPropertyTable( resTypeKey,
                                          RmpResourceTypeCommonProperties,
                                          NULL,     // Reserved
                                          FALSE,    // Don't allow unknowns
                                          InBuffer,
                                          InBufferSize,
                                          NULL );
        ClusterRegCloseKey( resTypeKey );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_UNUSUAL, "[RM] RmpResourceTypeSetCommonProperties, error in set routine.\n");
        }
    } else {
        ClRtlLogPrint( LOG_UNUSUAL, "[RM] RmpResourceTypeSetCommonProperties, error in verify routine.\n");
    }

    return(status);

} // RmpResourceTypeSetCommonProperties



DWORD
RmpResourceTypeEnumPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type's name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resTypeKey;
    DWORD       nameLength;
    LPWSTR      name;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Create name to open
    //
    nameLength = lstrlenW( ResourceTypeName ) + sizeof( PARAMETERS_KEY ) + 1;
    name = RmpAlloc( nameLength * sizeof(WCHAR) );
    if ( name == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wsprintfW( name, L"%ws\\%ws", ResourceTypeName, PARAMETERS_KEY );

    //
    // Open the specific cluster ResourceType key
    //
    status = ClusterRegOpenKey( RmpResTypesKey,
                                name,
                                KEY_READ,
                                &resTypeKey );
    RmpFree( name );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }


    //
    // Enumerate the private properties.
    //
    status = ResUtilEnumPrivateProperties( resTypeKey,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required );
    ClusterRegCloseKey( resTypeKey );

    return(status);

} // RmpResourceTypeEnumPrivateProperties



DWORD
RmpResourceTypeGetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given resource.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resTypeKey;
    DWORD       nameLength;
    LPWSTR      name;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Create name to open
    //
    nameLength = lstrlenW( ResourceTypeName ) + sizeof( PARAMETERS_KEY ) + 1;
    name = RmpAlloc( nameLength * sizeof(WCHAR) );
    if ( name == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wsprintfW( name, L"%ws\\%ws", ResourceTypeName, PARAMETERS_KEY );

    //
    // Open the specific cluster ResourceType key
    //
    status = ClusterRegOpenKey( RmpResTypesKey,
                                name,
                                KEY_READ,
                                &resTypeKey );
    RmpFree( name );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            if ( OutBufferSize < sizeof( DWORD ) ) {
                *Required = 4;
            } else {
                *((LPDWORD) OutBuffer) = 0;
                *BytesReturned = sizeof( DWORD );
            }
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Get private properties for the resource type.
    //
    status = ResUtilGetPrivateProperties( resTypeKey,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );

    ClusterRegCloseKey( resTypeKey );

    return(status);

} // RmpResourceTypeGetPrivateProperties



DWORD
RmpResourceTypeValidatePrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given resource.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    return(status);


} // RmpResourceTypeValidatePrivateProperties



DWORD
RmpResourceTypeSetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given resource.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resourceTypesKey;
    HKEY        resTypeKey;
    LPWSTR      name;
    DWORD       length;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Create name to open
        //
        length = lstrlenW( ResourceTypeName ) + 1;
        name = RmpAlloc( length * sizeof(WCHAR) );
        if ( name == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        wsprintfW( name, L"%ws", ResourceTypeName );

        //
        // Open the specific cluster ResourceType key
        //
        status = ClusterRegOpenKey( RmpResTypesKey,
                                    name,
                                    KEY_READ,
                                    &resourceTypesKey );
        RmpFree( name );
        if ( status != ERROR_SUCCESS ) {
            if ( status == ERROR_FILE_NOT_FOUND ) {
                status = ERROR_SUCCESS;
            }
            return(status);
        }

        //
        // Open the parameters key
        //
        status = ClusterRegOpenKey( resourceTypesKey,
                                    PARAMETERS_KEY,
                                    KEY_READ,
                                    &resTypeKey );
        if ( status != ERROR_SUCCESS ) {
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                status = ClusterRegCreateKey( resourceTypesKey,
                                              PARAMETERS_KEY,
                                              0,
                                              KEY_READ | KEY_WRITE,
                                              NULL,
                                              &resTypeKey,
                                              &disposition );
                if ( status != ERROR_SUCCESS ) {
                    ClusterRegCloseKey( resourceTypesKey );
                    return(status);
                }
            }
        }

        if ( status == ERROR_SUCCESS ) {

            status = ResUtilSetPrivatePropertyList( resTypeKey,
                                                    InBuffer,
                                                    InBufferSize );
            ClusterRegCloseKey( resTypeKey );
        }

        ClusterRegCloseKey( resourceTypesKey );
    }

    return(status);


} // RmpResourceTypeSetPrivateProperties



DWORD
RmpResourceTypeGetFlags(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        HKEY        resourceTypesKey;
        HKEY        resTypeKey;
        DWORD       valueType;

        //
        // Open the specific cluster ResourceType key
        //
        status = ClusterRegOpenKey( RmpResTypesKey,
                                    ResourceTypeName,
                                    KEY_READ,
                                    &resTypeKey );
        if ( status == ERROR_SUCCESS ) {
            //
            // Read the Flags value for the resource type.
            //
            *BytesReturned = OutBufferSize;
            status = ClusterRegQueryValue( resTypeKey,
                                           CLUSREG_NAME_FLAGS,
                                           &valueType,
                                           OutBuffer,
                                           BytesReturned );
            ClusterRegCloseKey( resTypeKey );
            if ( status == ERROR_FILE_NOT_FOUND ) {
                *(LPDWORD)OutBuffer = 0;
                *BytesReturned = sizeof(DWORD);
                status = ERROR_SUCCESS;
            }
        }
    }

    return(status);

} // RmpResourceTypeGetFlags

DWORD
RmpCheckCommonProperties(
    IN PRESOURCE pResource,
    IN PCOMMON_RES_PARAMS pCommonParams
    )

/*++

Routine Description:

    Checks and validates the supplied values of common properties.

Arguments:

    pResource - Pointer to the resource.

    pCommonParams - The parameter block supplied by the user.
    
Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       dwStatus;
    COMMON_RES_PARAMS 
                currentCommonParams;
    LPBYTE      pBuffer = NULL;
    DWORD       dwBytesReturned = 0;
    DWORD       dwBytesRequired = 0;

    //  
    //  Chittur Subbaraman (chitturs) - 5/7/99
    //
    //  This function verifies whether the common property values
    //  that are supplied by the user are valid.
    //
    ZeroMemory( &currentCommonParams, sizeof ( COMMON_RES_PARAMS ) );

    //
    //  First check whether the user has supplied two conflicting
    //  parameter values.
    //
    if ( ( pCommonParams->dwRetryPeriodOnFailure != 0 ) &&
         ( pCommonParams->dwRestartPeriod != 0 ) &&
         ( pCommonParams->dwRetryPeriodOnFailure <
              pCommonParams->dwRestartPeriod ) )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties, Invalid parameters supplied: "
                      "RetryPeriod=%1!d! < RestartPeriod=%2!d! for resource %3!ws!\n",
                      pCommonParams->dwRetryPeriodOnFailure, 
                      pCommonParams->dwRestartPeriod,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Get the buffer size for common properties list.
    //
    dwStatus = RmpResourceGetCommonProperties( pResource,
                                               FALSE,
                                               NULL,
                                               0,
                                               &dwBytesReturned,
                                               &dwBytesRequired
                                               );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties: Error %1!d! in getting props for resource %2!ws! (1st time)\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    pBuffer = LocalAlloc( LMEM_FIXED, dwBytesRequired + 10 );

    if ( pBuffer == NULL )
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
                      "[RM] RmpCheckCommonProperties: Error %1!d! in mem alloc for resource %2!ws!\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Get all the common properties from the cluster database
    //
    dwStatus = RmpResourceGetCommonProperties( pResource,
                                               FALSE,
                                               pBuffer,
                                               dwBytesRequired + 10,
                                               &dwBytesReturned,
                                               &dwBytesReturned
                                               );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties: Error %1!d! in getting props for resource %2!ws! (2nd time)\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Get the parameter block from the common properties list
    //
    dwStatus = ResUtilVerifyPropertyTable( RmpResourceCommonProperties,
                                           NULL,     // Reserved
                                           FALSE,    // Don't allow unknowns
                                           pBuffer,
                                           dwBytesRequired + 10,
                                           ( LPBYTE ) &currentCommonParams );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties: Error %1!d! in verifying props for resource %2!ws!\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Check whether the RetryPeriodOnFailure is >= RestartPeriod
    //
    if ( ( ( pCommonParams->dwRetryPeriodOnFailure != 0 ) &&
             ( pCommonParams->dwRetryPeriodOnFailure <
                   currentCommonParams.dwRestartPeriod ) ) ||
         ( ( pCommonParams->dwRestartPeriod != 0 ) && 
            ( currentCommonParams.dwRetryPeriodOnFailure <
                   pCommonParams->dwRestartPeriod ) ) )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties, Invalid IN params for resource %5!ws!: "
                      "Supplied Retry Period=%1!d!\n"
                      "[RM] Restart Period (DB)=%2!d!, RetryPeriod (DB)=%3!d!, Supplied Restart Period=%4!d! \n",
                      pCommonParams->dwRetryPeriodOnFailure,
                      currentCommonParams.dwRestartPeriod,
                      currentCommonParams.dwRetryPeriodOnFailure,
                      pCommonParams->dwRestartPeriod,
                      pResource->ResourceName);
        goto FnExit;
    }

FnExit:  
    LocalFree( pBuffer );

    ResUtilFreeParameterBlock(( LPBYTE ) &currentCommonParams,
                               NULL,
                               RmpResourceCommonProperties
                             );

    return( dwStatus );
} // RmpCheckCommonProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\rmapi.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Implements the management of the resource list. This includes
    adding resources to the list and deleting them from the list.

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "resmonp.h"
#include "stdio.h"

#define RESMON_MODULE RESMON_MODULE_RMAPI

//
// Local data
//

//
// Function prototypes local to this module
//
LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    );



//
// Local functions
//
DWORD   s_RmLoadResourceTypeDll(
    IN  handle_t IDL_handle,
    IN  LPCWSTR lpszResourceType,
    IN  LPCWSTR lpszDllName
)
{

    RESDLL_FNINFO       ResDllFnInfo;
#ifdef COMRES
    RESDLL_INTERFACES   ResDllInterfaces;
#endif

    DWORD   dwStatus;

    dwStatus = RmpLoadResType(
                    lpszResourceType,
                    lpszDllName,
                    &ResDllFnInfo,
#ifdef COMRES
                    &ResDllInterfaces,
#endif
                    NULL);

    if (ResDllFnInfo.hDll)
        FreeLibrary(ResDllFnInfo.hDll);
#ifdef COMRES

    if (ResDllInterfaces.pClusterResource)
        IClusterResource_Release (ResDllInterfaces.pClusterResource) ;
    if (ResDllInterfaces.pClusterQuorumResource)
        IClusterQuorumResource_Release (ResDllInterfaces.pClusterQuorumResource) ;
    if (ResDllInterfaces.pClusterResControl)
        IClusterResControl_Release (
            ResDllInterfaces.pClusterResControl
            ) ;
#endif //COMRES

    return(dwStatus);

}


RESID
s_RmCreateResource(
    IN handle_t IDL_handle,
    IN LPCWSTR DllName,
    IN LPCWSTR ResourceType,
    IN LPCWSTR ResourceId,
    IN DWORD LooksAlivePoll,
    IN DWORD IsAlivePoll,
    IN RM_NOTIFY_KEY NotifyKey,
    IN DWORD PendingTimeout,
    OUT LPDWORD Status
    )
/*++

Routine Description:

    Creates a resource to be monitored by the resource monitor.
    This involves allocating necessary structures, and loading its DLL.
    This does *NOT* insert the resource into the monitoring list or
    attempt to bring the resource on-line.

Arguments:

    IDL_handle - Supplies RPC binding handle, currently unused

    DllName - Supplies the name of the resource DLL

    ResourceType - Supplies the type of resource

    ResourceId - Supplies the Id of this specific resource

    LooksAlivePoll - Supplies the LooksAlive poll interval

    IsAlivePoll - Supplies the IsAlive poll interval

    PendingTimeout - Supplies the Pending Timeout value for this resource

    NotifyKey - Supplies a key to be passed to the notification
                callback if this resource's state changes.

Return Value:

    ResourceId - Returns a unique identifer to be used to identify
                 this resource for later operations.

--*/

{
    PRESOURCE Resource=NULL;
    DWORD Error;
    HKEY ResKey;
    PSTARTUP_ROUTINE Startup;
    PCLRES_FUNCTION_TABLE FunctionTable;
    DWORD   quorumCapable;
    DWORD   valueType;
    DWORD   valueData;
    DWORD   valueSize;
    DWORD   retry;
    DWORD   Reason;
    LPWSTR  pszDllName = (LPWSTR) DllName;

    CL_ASSERT(IsAlivePoll != 0);

    Resource = RmpAlloc(sizeof(RESOURCE));
    if (Resource == NULL) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    ZeroMemory( Resource, sizeof(RESOURCE) );
    //Resource->Dll = NULL;
    //Resource->Flags = 0;
    //Resource->DllName = NULL;
    //Resource->ResourceType = NULL;
    //Resource->ResourceId = NULL;
    //Resource->ResourceName = NULL;
    //Resource->TimerEvent = NULL;
    //Resource->OnlineEvent = NULL;
    //Resource->IsArbitrated = FALSE;
    Resource->Signature = RESOURCE_SIGNATURE;
    Resource->NotifyKey = NotifyKey;
    Resource->LooksAlivePollInterval = LooksAlivePoll;
    Resource->IsAlivePollInterval = IsAlivePoll;
    Resource->State = ClusterResourceOffline;

    if ( PendingTimeout <= 10 ) {
        Resource->PendingTimeout = PENDING_TIMEOUT;
    } else {
        Resource->PendingTimeout = PendingTimeout;
    }

    Resource->DllName = RmpAlloc((lstrlenW(DllName) + 1)*sizeof(WCHAR));
    if (Resource->DllName == NULL) {
        Error =  ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    lstrcpyW(Resource->DllName, DllName);

    Resource->ResourceType = RmpAlloc((lstrlenW(ResourceType) + 1)*sizeof(WCHAR));
    if (Resource->ResourceType == NULL) {
        Error =  ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    lstrcpyW(Resource->ResourceType, ResourceType);

    Resource->ResourceId = RmpAlloc((lstrlenW(ResourceId) + 1)*sizeof(WCHAR));
    if (Resource->ResourceId == NULL) {
        Error =  ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    lstrcpyW(Resource->ResourceId, ResourceId);

    // Expand any environment variables included in the DLL path name.
    if ( wcschr( DllName, L'%' ) != NULL ) {
        pszDllName = ClRtlExpandEnvironmentStrings( DllName );
        if ( pszDllName == NULL ) {
            Error = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, "[RM] Error expanding environment strings in '%1!ls!, error %2!u!.\n",
                       DllName,
                       Error);
            goto ErrorExit;
        }
    }

    //
    // Load the specified DLL and find the required entrypoints.
    //
    Resource->Dll = LoadLibraryW(pszDllName);
    if (Resource->Dll == NULL) {
#ifdef COMRES
        HRESULT hr ;
        CLSID clsid ;
        Error = GetLastError(); // Save the previous error. Return it instead of COM error on failure
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Error loading resource dll %1!ws!, error %2!u!.\n",
            pszDllName, Error);

        hr = CLSIDFromProgID(DllName, &clsid) ;

        if (FAILED (hr))
        {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] CLSIDFromProgID %1!ws!, hr = %2!u!.\n",
                DllName, hr);

            hr = CLSIDFromString( (LPWSTR) DllName, //Pointer to the string representation of the CLSID
                                  &clsid//Pointer to the CLSID
                                 );

            if (FAILED (hr))
            {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] CLSIDFromString Also failed %1!ws!, hr = %2!u!.\n",
                    DllName, hr);

                goto ComError ;
            }
        }

        if ((hr = CoCreateInstance (&clsid, NULL, CLSCTX_ALL, &IID_IClusterResource, (LPVOID *) &Resource->pClusterResource)) != S_OK)
        {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Error CoCreateInstance Prog ID %1!ws!, error %2!u!.\n", DllName, hr);
            goto ComError ;
        }

        Resource->dwType = RESMON_TYPE_COM ;

        hr = IClusterResource_QueryInterface (Resource->pClusterResource, &IID_IClusterQuorumResource,
                    &Resource->pClusterQuorumResource) ;
        if (FAILED(hr))
            Resource->pClusterQuorumResource = NULL ;

        quorumCapable = (Resource->pClusterQuorumResource)?1:0 ;

        hr = IClusterResource_QueryInterface (
                 Resource->pClusterResource,
                 &IID_IClusterResControl,
                 &Resource->pClusterResControl
                 ) ;
        if (FAILED(hr))
            Resource->pClusterResControl = NULL ;
        goto comOpened ;
ComError:
#else
        Error = GetLastError();
#endif
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Error loading resource dll %1!ws!, error %2!u!.\n",
            DllName, Error);
        CL_LOGFAILURE(Error);
        ClusterLogEvent2(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         RMON_CANT_LOAD_RESTYPE,
                         sizeof(Error),
                         &Error,
                         DllName,
                         ResourceType);
        goto ErrorExit;
    }
#ifdef COMRES
    else {
        Resource->dwType = RESMON_TYPE_DLL ;
    }
comOpened:
#endif

    //
    // Invoke debugger if one is specified.
    //
    if ( RmpDebugger ) {
        //
        // Wait for debugger to come online.
        //
        retry = 100;
        while ( retry-- &&
                !IsDebuggerPresent() ) {
            Sleep(100);
        }
        OutputDebugStringA("[RM] Just loaded resource DLL ");
        OutputDebugStringW(DllName);
        OutputDebugStringA("\n");
        DebugBreak();
    }

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
#endif
        //
        // We must have a startup routine to find all the other functions.
        //
        Startup = (PSTARTUP_ROUTINE)GetProcAddress(Resource->Dll,
                                                   STARTUP_ROUTINE);
        if ( Startup != NULL ) {
            FunctionTable = NULL;
            RmpSetMonitorState(RmonStartingResource, Resource);
            try {
                Error = (Startup)( ResourceType,
                                   CLRES_VERSION_V1_00,
                                   CLRES_VERSION_V1_00,
                                   RmpSetResourceStatus,
                                   RmpLogEvent,
                                   &FunctionTable );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                Error = GetExceptionCode();
            }
            RmpSetMonitorState(RmonIdle, NULL);
            if ( Error != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup call to %1!ws!, error %2!u!.\n",
                    DllName, Error );
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_CANT_INIT_RESTYPE,
                                 sizeof(Error),
                                 &Error,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
            Error = ERROR_INVALID_DATA;
            if ( FunctionTable == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup return, FunctionTable is NULL!\n");
                Reason = 0;
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_RESTYPE_BAD_TABLE,
                                 sizeof(Reason),
                                 &Reason,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
            if ( FunctionTable->Version != CLRES_VERSION_V1_00 ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup return, Invalid Version Number!\n");
                Reason = 1;
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_RESTYPE_BAD_TABLE,
                                 sizeof(Reason),
                                 &Reason,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
            if ( FunctionTable->TableSize != CLRES_V1_FUNCTION_SIZE ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup return, Invalid function table size!\n");
                Reason = 2;
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_RESTYPE_BAD_TABLE,
                                 sizeof(Reason),
                                 &Reason,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
#ifdef COMRES
            Resource->pOpen = FunctionTable->V1Functions.Open;
            Resource->pClose = FunctionTable->V1Functions.Close;
            Resource->pOnline = FunctionTable->V1Functions.Online;
            Resource->pOffline = FunctionTable->V1Functions.Offline;
            Resource->pTerminate = FunctionTable->V1Functions.Terminate;
            Resource->pLooksAlive = FunctionTable->V1Functions.LooksAlive;
            Resource->pIsAlive = FunctionTable->V1Functions.IsAlive;

            Resource->pArbitrate = FunctionTable->V1Functions.Arbitrate;
            Resource->pRelease = FunctionTable->V1Functions.Release;
            Resource->pResourceControl = FunctionTable->V1Functions.ResourceControl;
            Resource->pResourceTypeControl = FunctionTable->V1Functions.ResourceTypeControl;

            Error = ERROR_INVALID_DATA;
            if ( Resource->pOpen == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Open routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pClose == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Close routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pOnline == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Online routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pOffline == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Offline routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pTerminate == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Terminate routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pLooksAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null LooksAlive routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pIsAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null IsAlive routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }
        } else {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Could not find startup routine in resource DLL %1!ws!.\n",
                DllName);
            Error = ERROR_INVALID_DATA;
            goto ErrorExit;
        }

        if ( (Resource->pArbitrate) &&
             (Resource->pRelease) ) {
            quorumCapable = 1;
        } else {
            quorumCapable = 0;
        }
    }
#else // COMRES
            Resource->Open = FunctionTable->V1Functions.Open;
            Resource->Close = FunctionTable->V1Functions.Close;
            Resource->Online = FunctionTable->V1Functions.Online;
            Resource->Offline = FunctionTable->V1Functions.Offline;
            Resource->Terminate = FunctionTable->V1Functions.Terminate;
            Resource->LooksAlive = FunctionTable->V1Functions.LooksAlive;
            Resource->IsAlive = FunctionTable->V1Functions.IsAlive;

            Resource->Arbitrate = FunctionTable->V1Functions.Arbitrate;
            Resource->Release = FunctionTable->V1Functions.Release;
            Resource->ResourceControl = FunctionTable->V1Functions.ResourceControl;
            Resource->ResourceTypeControl = FunctionTable->V1Functions.ResourceTypeControl;

            Error = ERROR_INVALID_DATA;
            if ( Resource->Open == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Open routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Close == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Close routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Online == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Online routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Offline == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Offline routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Terminate == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Terminate routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->LooksAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null LooksAlive routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->IsAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null IsAlive routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

        } else {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Could not find startup routine in resource DLL %1!ws!.\n",
                pszDllName);
            Error = ERROR_INVALID_DATA;
            goto ErrorExit;
        }

        if ( (Resource->Arbitrate) &&
             (Resource->Release) ) {
            quorumCapable = 1;
        } else {
            quorumCapable = 0;
        }
#endif // COMRES

    Resource->State = ClusterResourceOffline;

    //
    // Open the resource's cluster registry key so that it can
    // be easily accessed from the Create entrypoint.
    //
    Error = ClusterRegOpenKey(RmpResourcesKey,
                              ResourceId,
                              KEY_READ,
                              &ResKey);
    if (Error != ERROR_SUCCESS) {
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }

    //
    // Get the resource name.
    //
    Resource->ResourceName = GetParameter( ResKey, CLUSREG_NAME_RES_NAME );
    if ( Resource->ResourceName == NULL ) {
        Error = GetLastError();
        ClusterRegCloseKey(ResKey);
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] Error reading resource name for %1!ws!, error %2!u!.\n",
            Resource->ResourceId, Error);
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }

    //
    // Call Open entrypoint.
    // This is done with the lock held to serialize calls to the
    // resource DLL and serialize access to the shared memory region.
    //

    AcquireListLock();

    RmpSetMonitorState(RmonInitializingResource, Resource);

    //
    // N.B. This is the only call that we make without locking the
    // eventlist lock! We can't, because we don't know that the event
    // list is yet.
    //
    try {
#ifdef COMRES
        Resource->Id = RESMON_OPEN (Resource, ResKey) ;
#else
        Resource->Id = (Resource->Open)(Resource->ResourceName,
                                        ResKey,
                                        Resource );
#endif
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        Resource->Id = 0;
    }
    if (Resource->Id == 0) {
        Error = GetLastError();
    } else {
        Error = RmpInsertResourceList(Resource, NULL);
    }

    //set the monitor state and close the key
    RmpSetMonitorState(RmonIdle, NULL);
    ClusterRegCloseKey(ResKey);

    if (Error != ERROR_SUCCESS)
    {
        //CL_LOGFAILURE(Error);
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] RmpInsertResourceList failed, returned %1!u!\n",
            Error);
        ReleaseListLock();
        goto ErrorExit;


    }

    ReleaseListLock();

    if (Resource->Id == 0) {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Open of resource %1!ws! returned null!\n",
            Resource->ResourceName);
        if ( Error == ERROR_SUCCESS ) {
            Error = ERROR_RESOURCE_NOT_FOUND;
        }
        //CL_LOGFAILURE(Error);
        goto ErrorExit;
    }

    *Status = ERROR_SUCCESS;

    if ( pszDllName != DllName ) {
        LocalFree( pszDllName );
    }

    //
    // Resource object has been successfully loaded into memory and
    // its entrypoints determined. We now have a valid RESID that
    // can be used in subsequent calls.
    //
    return((RESID)Resource);

ErrorExit:

    if (Resource != NULL) {
        if (Resource->Dll != NULL) {
            FreeLibrary(Resource->Dll);
        }
#ifdef COMRES
        if (Resource->pClusterResource)
            IClusterResource_Release (Resource->pClusterResource) ;
        if (Resource->pClusterQuorumResource)
            IClusterQuorumResource_Release (Resource->pClusterQuorumResource) ;
        if (Resource->pClusterResControl)
            IClusterResControl_Release (
                Resource->pClusterResControl
                ) ;
#endif
        RmpFree(Resource->DllName);
        RmpFree(Resource->ResourceType);
        RmpFree(Resource->ResourceName);
        RmpFree(Resource->ResourceId);
        RmpFree(Resource);
    }
    if ( pszDllName != DllName ) {
        LocalFree( pszDllName );
    }
    ClRtlLogPrint(LOG_CRITICAL, "[RM] Failed creating resource %1!ws!, error %2!u!.\n",
        ResourceId, Error);
    *Status = Error;
    return(0);

} // RmCreateResource


VOID
s_RmCloseResource(
    IN OUT RESID *ResourceId
    )

/*++

Routine Description:

    Closes the specified resource. This includes removing it from the poll list,
    freeing any associated memory, and unloading its DLL.

Arguments:

    ResourceId - Supplies a pointer to the resource ID. This will be set to
                 NULL after cleanup is complete to indicate to RPC that the
                 client side context can be destroyed.

Return Value:

    None.

--*/

{
    PRESOURCE Resource;
    BOOL Closed;

    Resource = (PRESOURCE)*ResourceId;

    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    CL_ASSERT(Resource->Flags & RESOURCE_INSERTED);

    AcquireListLock();
    if (Resource->ListEntry.Flink != NULL) {
        RmpRemoveResourceList(Resource);
        Closed = FALSE;
    } else {
        Closed = TRUE;
    }

    ReleaseListLock();

    if (!Closed) {
        //
        // Call the DLL to close the resource.
        //
        AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
        //
        // If the Online Thread is still pending, wait a little bit for it.
        //
        if ( Resource->TimerEvent ) {
            SetEvent( Resource->TimerEvent );
            Resource->TimerEvent = NULL;
        }
        
        Resource->dwEntryPoint = RESDLL_ENTRY_CLOSE;
        try {
#ifdef COMRES
            RESMON_CLOSE (Resource) ;
#else          
            (Resource->Close)(Resource->Id);
#endif
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
        Resource->dwEntryPoint = 0;
        ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
    }
    Resource->Signature = 0;

    if ( Resource->OnlineEvent ) {
        SetEvent( Resource->OnlineEvent );
        CloseHandle( Resource->OnlineEvent );
        Resource->OnlineEvent = NULL;
    }

    //
    // Free the resource dll.
    //

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        FreeLibrary(Resource->Dll);
    }
    else
    {
        IClusterResource_Release (Resource->pClusterResource) ;
        if (Resource->pClusterQuorumResource)
            IClusterQuorumResource_Release (Resource->pClusterQuorumResource) ;
        if (Resource->pClusterResControl)
            IClusterResControl_Release (
                Resource->pClusterResControl
                ) ;
    }
#else
    FreeLibrary(Resource->Dll);
#endif
    RmpFree(Resource->DllName);
    RmpFree(Resource->ResourceType);
    RmpFree(Resource->ResourceName);
    RmpFree(Resource->ResourceId);

    RmpFree(Resource);

    *ResourceId = NULL;

} // RmCloseResource


VOID
RPC_RESID_rundown(
    IN RESID Resource
    )

/*++

Routine Description:

    RPC rundown procedure for a RESID. Just closes the handle.

Arguments:

    Resource - supplies the RESID that is to be rundown.

Return Value:

    None.

--*/

{
    //
    //  Chittur Subbaraman (chitturs) - 5/10/2001
    //
    //  Don't do anything on RPC rundown. If clussvc dies, then resmon main thread detects it and
    //  runs down (close, terminate) resources. Merely, closing the resource here may cause
    //  it to be delivered when resource dlls don't expect it.
    //
#if 0
    s_RmCloseResource(&Resource);
#endif
} // RESID_rundown


error_status_t
s_RmChangeResourceParams(
    IN RESID ResourceId,
    IN DWORD LooksAlivePoll,
    IN DWORD IsAlivePoll,
    IN DWORD PendingTimeout
    )

/*++

Routine Description:

    Changes the poll intervals defined for a resource.

Arguments:

    ResourceId - Supplies the resource ID.

    LooksAlivePoll - Supplies the new LooksAlive poll in ms units

    IsAlivePoll - Supplies the new IsAlive poll in ms units

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    PRESOURCE Resource;
    BOOL Inserted;

    //
    //  If the resmon is shutting down, just return since you can't trust any resource structures
    //  accessed below.
    //
    if ( RmpShutdown ) return ( ERROR_SUCCESS );
    
    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    AcquireListLock();

    Inserted = (Resource->Flags & RESOURCE_INSERTED);
    if (Inserted) {
        //
        // Remove the resource from the list, update its properties,
        // and reinsert it. The reinsertion will put it back in the
        // right spot to reflect the new poll intervals.
        //

        RmpRemoveResourceList(Resource);
    }
    Resource->LooksAlivePollInterval = LooksAlivePoll;
    Resource->IsAlivePollInterval = IsAlivePoll;
    Resource->PendingTimeout = PendingTimeout;
    if (Inserted) {
        RmpInsertResourceList( Resource, 
                               (PPOLL_EVENT_LIST) Resource->EventList);
    }
    ReleaseListLock();

    return(ERROR_SUCCESS);

} // RmChangeResourcePoll


error_status_t
s_RmArbitrateResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Arbitrate for the resource.

Arguments:

    ResourceId - Supplies the resource to be arbitrated.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PRESOURCE Resource;
    DWORD   status;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        if ( (Resource->pArbitrate == NULL) ||
             (Resource->pRelease == NULL) ) {
            return(ERROR_NOT_QUORUM_CAPABLE);
        }
    }
    else
    {
        if (!Resource->pClusterQuorumResource)
            return(ERROR_NOT_QUORUM_CAPABLE);
    }
#else
    if ( (Resource->Arbitrate == NULL) ||
         (Resource->Release == NULL) ) {
        return(ERROR_NOT_QUORUM_CAPABLE);
    }
#endif

    // 
    //  Chittur Subbaraman (chitturs) - 10/15/99
    //
    //  Commenting out lock acquisition - This is done so that the
    //  arbitration request can proceed into the disk resource without
    //  any blockage. There have been cases where either some resource
    //  gets blocked in its "IsAlive" with this lock held or the resmon
    //  itself calling into clussvc to set a property (for instance) and
    //  this call gets blocked there. This results in an arbitration stall
    //  and the clussvc on this node dies. Note that arbitrate only needs to 
    //  be serialized with release and the disk resource is supposed 
    //  to take care of that.
    //
    
#if 0
    //
    // Lock the resource list and attempt to bring the resource on-line.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#else
    //
    // Try to acquire spin lock for synchronizing with resource rundown.
    // Return failure if you cannot get the lock.
    //
    if ( !RmpAcquireSpinLock( Resource, FALSE ) ) return ( ERROR_BUSY );
#endif

    //
    // Update shared state to indicate we are arbitrating a resource
    //
    RmpSetMonitorState(RmonArbitrateResource, Resource);

#ifdef COMRES
    status = RESMON_ARBITRATE (Resource, RmpLostQuorumResource) ;
#else
    status = (Resource->Arbitrate)(Resource->Id,
                                   RmpLostQuorumResource);
#endif
    if (status == ERROR_SUCCESS) {
        Resource->IsArbitrated = TRUE;
    }

    RmpSetMonitorState(RmonIdle, NULL);

#if 0
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#else
    RmpReleaseSpinLock( Resource );
#endif

    return(status);

} // s_RmArbitrateResource(


error_status_t
s_RmReleaseResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Release the resource.

Arguments:

    ResourceId - Supplies the resource to be released.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PRESOURCE Resource;
    DWORD   status;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        if (Resource->pRelease == NULL) {
            return(ERROR_NOT_QUORUM_CAPABLE);
        }
    }
    else
    {
        if (!Resource->pClusterQuorumResource)
            return(ERROR_NOT_QUORUM_CAPABLE);
    }
#else
    if ( Resource->Release == NULL ) {
        return(ERROR_NOT_QUORUM_CAPABLE);
    }
#endif
    //
    // Lock the resource list and attempt to bring the resource on-line.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
#if 0   // Not needed right now
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#endif

    //
    // Update shared state to indicate we ar arbitrating a resource
    //
    RmpSetMonitorState(RmonReleaseResource, Resource);

#ifdef COMRES
    status = RESMON_RELEASE (Resource) ;
#else
    status = (Resource->Release)(Resource->Id);
#endif
    Resource->IsArbitrated = FALSE;

    RmpSetMonitorState(RmonIdle, NULL);
#if 0   // Not needed right now
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#endif

    return(status);

} // s_RmReleaseResource(



error_status_t
s_RmOnlineResource(
    IN RESID    ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Brings the specified resource into the online state.

Arguments:

    ResourceId - Supplies the resource to be brought online.

    pdwState - The new state of the resource is returned.

Return Value:


--*/

{
    PRESOURCE Resource;
    DWORD   status;
    HANDLE  timerThread;
    HANDLE  eventHandle = NULL;
    DWORD   threadId;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    CL_ASSERT(Resource->EventHandle == NULL );

    *pdwState = ClusterResourceFailed;

    if ( Resource->State > ClusterResourcePending ) {
        return(ERROR_INVALID_STATE);
    }

    //
    // Create an event to allow the SetResourceStatus callback to synchronize
    // execution with this thread.
    //
    if ( Resource->OnlineEvent ) {
        return(ERROR_NOT_READY);
    }

    Resource->OnlineEvent = CreateEvent( NULL,
                                         FALSE,
                                         FALSE,
                                         NULL );
    if ( Resource->OnlineEvent == NULL ) {
        return(GetLastError());
    }

    //
    // Lock the resource list and attempt to bring the resource on-line.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    //
    // Update shared state to indicate we are bringing a resource online
    //
    RmpSetMonitorState(RmonOnlineResource, Resource);

    //
    // Call Online entrypoint. Regardless of whether this succeeds or
    // not, the resource has been successfully added to the list. If the
    // online call fails, the resource immediately enters the failed state.
    //
    Resource->CheckPoint = 0;
    try {
#ifdef COMRES
        status = RESMON_ONLINE (Resource, &eventHandle) ;
#else
        status = (Resource->Online)(Resource->Id, &eventHandle);
#endif
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }
    if (status == ERROR_SUCCESS) {
        SetEvent( Resource->OnlineEvent );
        CloseHandle( Resource->OnlineEvent );
        Resource->OnlineEvent = NULL;

        if ( eventHandle ) {
            status = RmpAddPollEvent( (PPOLL_EVENT_LIST)Resource->EventList,
                                      eventHandle,
                                      Resource );
            if ( status == ERROR_SUCCESS ) {
                Resource->State = ClusterResourceOnline;
            } else {
                CL_LOGFAILURE(status);
                Resource->State = ClusterResourceFailed;
            }
        } else {
            Resource->State = ClusterResourceOnline;
        }
    } else if ( status == ERROR_IO_PENDING ) {
        status = ERROR_SUCCESS;
        //
        // If the Resource DLL returns pending, then start a timer.
        //
        CL_ASSERT(Resource->TimerEvent == NULL );
        Resource->TimerEvent = CreateEvent( NULL,
                                            FALSE,
                                            FALSE,
                                            NULL );
        if ( Resource->TimerEvent == NULL ) {
            CL_UNEXPECTED_ERROR(status = GetLastError());
        } else {
            timerThread = CreateThread( NULL,
                                        0,
                                        RmpTimerThread,
                                        Resource,
                                        0,
                                        &threadId );
            if ( timerThread == NULL ) {
                CL_UNEXPECTED_ERROR(status = GetLastError());
            } else {
                //
                // Chittur Subbaraman (chitturs) - 1/12/99
                //
                // Raise the timer thread priority to highest. This
                // is necessary to avoid certain cases in which the
                // timer thread is sluggish to close out the timer event
                // handle before a second online. Note that there are
                // no major performance implications by doing this since
                // the timer thread is in a wait state most of the time.
                //
                if ( !SetThreadPriority( timerThread, THREAD_PRIORITY_HIGHEST ) )
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                                  "[RM] s_RmOnlineResource: Error setting priority of timer "
                                  "thread for resource %1!ws!\n",
                                  Resource->ResourceName);
                    CL_LOGFAILURE( GetLastError() );
                }
                CloseHandle( timerThread );
                //
                // If we have an event handle, then add it to our list.
                //
                if ( eventHandle ) {
                    status = RmpAddPollEvent( (PPOLL_EVENT_LIST)Resource->EventList,
                                              eventHandle,
                                              Resource );
                    if ( status == ERROR_SUCCESS ) {
                        Resource->State = ClusterResourceOnlinePending;
                    } else {
                        ClRtlLogPrint(LOG_UNUSUAL,
                                      "[RM] Failed to add event %1!u! for resource %2!ws!, error %3!u!.\n",
                                      eventHandle,
                                      Resource->ResourceName,
                                      status );
                        CL_LOGFAILURE(status);
                        Resource->State = ClusterResourceFailed;
                    }
                } else {
                    Resource->State = ClusterResourceOnlinePending;
                    //Resource->WaitHint = PENDING_TIMEOUT;
                    //Resource->CheckPoint = 0;
                }
            }
        }
        SetEvent( Resource->OnlineEvent );
    } else {
        CloseHandle( Resource->OnlineEvent );
        Resource->OnlineEvent = NULL;
        ClRtlLogPrint(LOG_CRITICAL, "[RM] OnlineResource failed, resource %1!ws!, status =  %2!u!.\n",
            Resource->ResourceName,
            status);

        ClusterLogEvent1(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         RMON_ONLINE_FAILED,
                         sizeof(status),
                         &status,
                         Resource->ResourceName);
        Resource->State = ClusterResourceFailed;
    }

    RmpSetMonitorState(RmonIdle, NULL);
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    //
    // Notify poller thread that the list has changed
    //
    RmpSignalPoller((PPOLL_EVENT_LIST)Resource->EventList);

    *pdwState = Resource->State;
    return(status);

} // RmOnlineResource



VOID
s_RmTerminateResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Brings the specified resource into the offline state immediately.

Arguments:

    ResourceId - Supplies the resource to be brought online.

Return Value:

    The new state of the resource.

--*/

{
    DWORD State;

    RmpOfflineResource(ResourceId, FALSE, &State);

    return;

} // RmTerminateResource



error_status_t
s_RmOfflineResource(
    IN RESID ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Brings the specified resource into the offline state by shutting it
    down gracefully.

Arguments:

    ResourceId - Supplies the resource to be brought online.
    pdwState - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful, else returns code.

--*/

{
    return(RmpOfflineResource(ResourceId, TRUE, pdwState));

} // RmOfflineResource



error_status_t
s_RmFailResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Fail the given resource.

Arguments:

    ResourceId - Supplies the resource ID.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    PRESOURCE Resource;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

    if ( Resource->State == ClusterResourceOnline ) {
        Resource->State = ClusterResourceFailed;
        RmpPostNotify(Resource, NotifyResourceStateChange);
        return(ERROR_SUCCESS);
    } else {
        return(ERROR_RESMON_INVALID_STATE);
    }

} // RmChangeResourcePoll



error_status_t
s_RmShutdownProcess(
    IN handle_t IDL_handle
    )

/*++

Routine Description:

    Set the shutdown flag and trigger a poller thread to exit.
    The termination of any poller thread will notify the main
    thread to clean up and shutdown.

Arguments:

    IDL_handle - Supplies RPC binding handle, currently unused

Return Value:

    ERROR_SUCCESS

--*/

{
    //
    // Check if we've already been called here before. This can happen
    // as a result of the Failover Manager calling us to perform a clean
    // shutdown. The main thread also will call here, in case it is shutting
    // down because of a failure of one of the threads.
    //

    if ( !RmpShutdown ) {
        RmpShutdown = TRUE;
        //
        // Wake up the main thread so that it can cleanup.
        //
        SetEvent( RmpRewaitEvent );
    }
    return(ERROR_SUCCESS);

} // RmShutdownProcess



error_status_t
s_RmResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Process a resource control request.

Arguments:

    ResourceId - the resource that is being controlled.

    ControlCode - the control request, reduced to just the function code.

    InBuffer - the input buffer for this control request.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBufferSize - the size of the output buffer.

    BytesReturned - the number of bytes returned.

    Required - the number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    A Win32 error code on failure

--*/

{
    PRESOURCE   Resource;
    DWORD       status = ERROR_INVALID_FUNCTION;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

    //
    // Lock the resource list and send down the control request.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

#ifdef COMRES
    if (Resource->pResourceControl || Resource->pClusterResControl) {
        RmpSetMonitorState(RmonResourceControl, Resource);
        status = RESMON_RESOURCECONTROL( Resource,
                                              ControlCode,
                                              InBuffer,
                                              InBufferSize,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned );
        RmpSetMonitorState(RmonIdle, NULL);
    }
#else
    if ( Resource->ResourceControl ) {
        RmpSetMonitorState(RmonResourceControl, Resource);
        status = (Resource->ResourceControl)( Resource->Id,
                                              ControlCode,
                                              InBuffer,
                                              InBufferSize,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned );
        RmpSetMonitorState(RmonIdle, NULL);
    }
#endif
    if ( status == ERROR_INVALID_FUNCTION ) {

        DWORD characteristics = CLUS_CHAR_UNKNOWN;

        switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_GET_COMMON_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( RmpResourceCommonProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                Required );
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                *BytesReturned = 0;
                *Required = sizeof(CLUS_RESOURCE_CLASS_INFO);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_UNKNOWN;
                ptrResClassInfo->SubClass = 0;
                *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
#ifdef COMRES
            if (Resource->dwType == RESMON_TYPE_DLL)
            {
                if ( (Resource->pArbitrate != NULL) &&
                     (Resource->pRelease != NULL) ) {
                    characteristics = CLUS_CHAR_QUORUM;
                }
            }
            else
            {
                if (!Resource->pClusterQuorumResource)
                    characteristics = CLUS_CHAR_QUORUM;
            }
#else
            if ( (Resource->Arbitrate != NULL) &&
                 (Resource->Release != NULL) ) {
                characteristics = CLUS_CHAR_QUORUM;
            }
#endif
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                *BytesReturned = sizeof(DWORD);
                *(LPDWORD)OutBuffer = characteristics;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_GET_FLAGS:
            status = RmpResourceGetFlags( Resource,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_ENUM_COMMON_PROPERTIES:
            status = RmpResourceEnumCommonProperties( OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned,
                                                      Required );
            break;

        case CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES:
            status = RmpResourceGetCommonProperties( Resource,
                                                     TRUE,
                                                     OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned,
                                                     Required );
            break;

        case CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES:
            status = RmpResourceGetCommonProperties( Resource,
                                                     FALSE,
                                                     OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned,
                                                     Required );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES:
            status = RmpResourceValidateCommonProperties( Resource,
                                                          InBuffer,
                                                          InBufferSize );
            break;

        case CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES:
            status = RmpResourceSetCommonProperties( Resource,
                                                     InBuffer,
                                                     InBufferSize );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = RmpResourceEnumPrivateProperties( Resource,
                                                       OutBuffer,
                                                       OutBufferSize,
                                                       BytesReturned,
                                                       Required );
            break;

        case CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES:
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                LPDWORD ptrDword = (LPDWORD) OutBuffer;
                *ptrDword = 0;
                *BytesReturned = sizeof(DWORD);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = RmpResourceGetPrivateProperties( Resource,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned,
                                                      Required );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = RmpResourceValidatePrivateProperties( Resource,
                                                           InBuffer,
                                                           InBufferSize );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = RmpResourceSetPrivateProperties( Resource,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            //
            //  Chittur Subbaraman (chitturs) - 6/28/99
            //
            //  The setting of the name in the cluster registry is done
            //  in NT5 by clussvc. So, resmon does not have to do any work
            //  except return a success code in case a resource DLL returns
            //  ERROR_INVALID_FUNCTION.
            //
            status = ERROR_SUCCESS;
            break;

        default:
            break;
        }
    } else {
        // If the function is returning a buffer size without
        // copying data, move this info around to satisfy RPC.
        if ( *BytesReturned > OutBufferSize ) {
            *Required = *BytesReturned;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        }
    }
    
    if ( ( status != ERROR_SUCCESS ) && 
         ( status != ERROR_MORE_DATA ) &&
         ( status != ERROR_INVALID_FUNCTION ) )
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] s_RmResourceControl: Resource <%1!ws!> control operation "
                      "0x%2!08lx! gives status=%3!u!...\n",
                      Resource->ResourceName,
                      ControlCode,
                      status);
    }

    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    return(status);

} // RmResourceControl



error_status_t
s_RmResourceTypeControl(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceTypeName,
    IN LPCWSTR DllName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Process a resource type control request.

Arguments:

    IDL_handle - not used.

    ResourceTypeName - the resource type name that is being controlled.

    DllName - the name of the dll.

    ControlCode - the control request, reduced to just the function code.

    InBuffer - the input buffer for this control request.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBufferSize - the size of the output buffer.

    BytesReturned - the number of bytes returned.

    Required - the number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    A Win32 error code on failure

--*/

{

    RESDLL_FNINFO           ResDllFnInfo;
#ifdef COMRES
    RESDLL_INTERFACES       ResDllInterfaces;
#endif
    DWORD                   status = ERROR_INVALID_FUNCTION;
    DWORD                   characteristics = CLUS_CHAR_UNKNOWN;

    status = RmpLoadResType(ResourceTypeName, DllName, &ResDllFnInfo,
    #ifdef COMRES
        &ResDllInterfaces,
    #endif
        &characteristics);

    if (status != ERROR_SUCCESS)
    {
        return(status);
    }

    status = ERROR_INVALID_FUNCTION;

    if (ResDllFnInfo.hDll && ResDllFnInfo.pResFnTable)
    {

        PRESOURCE_TYPE_CONTROL_ROUTINE resourceTypeControl = NULL ;

        resourceTypeControl = ResDllFnInfo.pResFnTable->V1Functions.ResourceTypeControl;

        if (resourceTypeControl)
        {
            RmpSetMonitorState(RmonResourceTypeControl, NULL);
            status = (resourceTypeControl)( ResourceTypeName,
                                        ControlCode,
                                        InBuffer,
                                        InBufferSize,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned );
            RmpSetMonitorState(RmonIdle, NULL);
        }
    }
#ifdef COMRES
    else if (ResDllInterfaces.pClusterResControl)
    {
        HRESULT hr ;
        VARIANT vtIn, vtOut ;
        SAFEARRAY sfIn = {1, 0, 1, 0, InBuffer, {InBufferSize, 0} } ;
        SAFEARRAY sfOut  = {1,  FADF_FIXEDSIZE, 1, 0, OutBuffer, {OutBufferSize, 0} } ;
        SAFEARRAY *psfOut = &sfOut ;
        BSTR pbResourceTypeName ;

        vtIn.vt = VT_ARRAY | VT_UI1 ;
        vtOut.vt = VT_ARRAY | VT_UI1 | VT_BYREF ;

        vtIn.parray = &sfIn ;
        vtOut.pparray = &psfOut ;

        pbResourceTypeName = SysAllocString (ResourceTypeName) ;

        if (pbResourceTypeName == NULL)
        {
            CL_LOGFAILURE( ERROR_NOT_ENOUGH_MEMORY) ;
            goto FnExit ; // Use the default processing
        }
        RmpSetMonitorState(RmonResourceTypeControl, NULL);
        hr = IClusterResControl_ResourceTypeControl (
                ResDllInterfaces.pClusterResControl,
                pbResourceTypeName,
                ControlCode,
                &vtIn,
                &vtOut,
                BytesReturned,
                &status);

        RmpSetMonitorState(RmonIdle, NULL);
        SysFreeString (pbResourceTypeName) ;

        if (FAILED(hr))
        {
            CL_LOGFAILURE(hr); // Use the default processing
            status = ERROR_INVALID_FUNCTION;
        }
    }
#endif
    if ( status == ERROR_INVALID_FUNCTION ) {

        switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_GET_COMMON_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( RmpResourceTypeCommonProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                *BytesReturned = 0;
                *Required = sizeof(CLUS_RESOURCE_CLASS_INFO);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_UNKNOWN;
                ptrResClassInfo->SubClass = 0;
                *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                *BytesReturned = sizeof(DWORD);
                *(LPDWORD)OutBuffer = characteristics;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_FLAGS:
            status = RmpResourceTypeGetFlags( ResourceTypeName,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS:
            *BytesReturned = 0;
            *Required = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_COMMON_PROPERTIES:
            status = RmpResourceTypeEnumCommonProperties( ResourceTypeName,
                                                          OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned,
                                                          Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES:
            status = RmpResourceTypeGetCommonProperties( ResourceTypeName,
                                                         TRUE,
                                                         OutBuffer,
                                                         OutBufferSize,
                                                         BytesReturned,
                                                         Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES:
            status = RmpResourceTypeGetCommonProperties( ResourceTypeName,
                                                         FALSE,
                                                         OutBuffer,
                                                         OutBufferSize,
                                                         BytesReturned,
                                                         Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES:
            status = RmpResourceTypeValidateCommonProperties( ResourceTypeName,
                                                              InBuffer,
                                                              InBufferSize );
            break;

        case CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES:
            status = RmpResourceTypeSetCommonProperties( ResourceTypeName,
                                                         InBuffer,
                                                         InBufferSize );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = RmpResourceTypeEnumPrivateProperties( ResourceTypeName,
                                                           OutBuffer,
                                                           OutBufferSize,
                                                           BytesReturned,
                                                           Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES:
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                LPDWORD ptrDword = (LPDWORD) OutBuffer;
                *ptrDword = 0;
                *BytesReturned = sizeof(DWORD);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES:
            status = RmpResourceTypeGetPrivateProperties( ResourceTypeName,
                                                          OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned,
                                                          Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES:
            status = RmpResourceTypeValidatePrivateProperties( ResourceTypeName,
                                                               InBuffer,
                                                               InBufferSize );
            break;

        case CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES:
            status = RmpResourceTypeSetPrivateProperties( ResourceTypeName,
                                                          InBuffer,
                                                          InBufferSize );
            break;

        default:
            break;

        }
    } else {
        // If the function is returning a buffer size without
        // copying data, move this info around to satisfy RPC.
        if ( *BytesReturned > OutBufferSize ) {
            *Required = *BytesReturned;
            *BytesReturned = 0;
        }
        if ( (status == ERROR_MORE_DATA) &&
             (OutBuffer == NULL) ) {
            status = ERROR_SUCCESS;
        }
    }


FnExit:

    if (ResDllFnInfo.hDll)
        FreeLibrary(ResDllFnInfo.hDll);
#ifdef COMRES
    if (ResDllInterfaces.pClusterResource)
        IClusterResource_Release (ResDllInterfaces.pClusterResource) ;
    if (ResDllInterfaces.pClusterQuorumResource)
        IClusterQuorumResource_Release (ResDllInterfaces.pClusterQuorumResource) ;
    if (ResDllInterfaces.pClusterResControl)
        IClusterResControl_Release (
            ResDllInterfaces.pClusterResControl
            ) ;
#endif


    return(status);

} // RmResourceTypeControl






LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Reads a REG_SZ parameter from the cluster regitry, and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - supplies the cluster key where the parameter is stored.

    ValueName - supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter value on success.

    NULL on failure.

--*/

{
    LPWSTR  value;
    DWORD   valueLength;
    DWORD   valueType;
    DWORD   status;

    valueLength = 0;
    status = ClusterRegQueryValue( ClusterKey,
                                   ValueName,
                                   &valueType,
                                   NULL,
                                   &valueLength );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        SetLastError(status);
        return(NULL);
    }
    if ( valueType == REG_SZ ) {
        valueLength += sizeof(UNICODE_NULL);
    }
    value = LocalAlloc(LMEM_FIXED, valueLength);
    if ( value == NULL ) {
        return(NULL);
    }
    status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &valueType,
                                  (LPBYTE)value,
                                  &valueLength);
    if ( status != ERROR_SUCCESS) {
        LocalFree(value);
        SetLastError(status);
        value = NULL;
    }

    return(value);

} // GetParameter

#ifdef COMRES
RESID
Resmon_Open (
    IN PRESOURCE Resource,
    IN HKEY ResourceKey
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pOpen) (Resource->ResourceName, ResourceKey, Resource) ;
    }
    else
    {
        HRESULT hr ;
        OLERESID ResId = 0 ;

        BSTR pbResourceName = SysAllocString (Resource->ResourceName) ;

        if (pbResourceName == NULL)
        {
            SetLastError ( ERROR_NOT_ENOUGH_MEMORY) ;
            CL_LOGFAILURE( ERROR_NOT_ENOUGH_MEMORY) ;
            goto ErrorExit ;
        }

        hr = IClusterResource_Open(Resource->pClusterResource, pbResourceName, (OLEHKEY)ResourceKey,
                        (OLERESOURCE_HANDLE)Resource, &ResId);

        SysFreeString (pbResourceName) ;

        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
        }
ErrorExit:
        return (RESID) ResId ;
    }
}

VOID
Resmon_Close (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        (Resource->pClose) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;

        hr = IClusterResource_Close (Resource->pClusterResource, (OLERESID)Resource->Id);
        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
        }
    }
}

DWORD
Resmon_Online (
    IN PRESOURCE Resource,
    IN OUT LPHANDLE EventHandle
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pOnline) (Resource->Id, EventHandle) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_Online(Resource->pClusterResource, (OLERESID)Resource->Id, (LPOLEHANDLE)EventHandle, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;  // Return a error
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

DWORD
Resmon_Offline (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pOffline) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_Offline(Resource->pClusterResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;  // Return a error
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

VOID
Resmon_Terminate (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        (Resource->pTerminate) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;

        hr = IClusterResource_Terminate (Resource->pClusterResource, (OLERESID)Resource->Id);
        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
        }
    }
}

BOOL
Resmon_LooksAlive (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pLooksAlive) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_LooksAlive (Resource->pClusterResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
            lRet = 0 ; // Incase of failure return 0 to indicate LooksAlive is failed.
        }
        return lRet ;
    }
}

BOOL
Resmon_IsAlive (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pIsAlive) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_IsAlive (Resource->pClusterResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
            lRet = 0 ; // Incase of failure return 0 to indicate IsAlive is failed.
        }
        return lRet ;
    }
}

DWORD
Resmon_Arbitrate (
    IN PRESOURCE Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pArbitrate) (Resource->Id, LostQuorumResource) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterQuorumResource_QuorumArbitrate(Resource->pClusterQuorumResource, (OLERESID)Resource->Id, (POLEQUORUM_RESOURCE_LOST)LostQuorumResource, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

DWORD
Resmon_Release (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pRelease) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterQuorumResource_QuorumRelease(Resource->pClusterQuorumResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

DWORD
Resmon_ResourceControl (
    IN PRESOURCE Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pResourceControl)( Resource->Id,
                                              ControlCode,
                                              InBuffer,
                                              InBufferSize,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned );
    }
    else
    {
        long status ;
        HRESULT hr ;
        VARIANT vtIn, vtOut ;
        SAFEARRAY sfIn = {1, 0, 1, 0, InBuffer, {InBufferSize, 0} } ;
        SAFEARRAY sfOut  = {1,  FADF_FIXEDSIZE, 1, 0, OutBuffer, {OutBufferSize, 0} } ;
        SAFEARRAY *psfOut = &sfOut ;

        vtIn.vt = VT_ARRAY | VT_UI1 ;
        vtOut.vt = VT_ARRAY | VT_UI1 | VT_BYREF ;

        vtIn.parray = &sfIn ;
        vtOut.pparray = &psfOut ;

        hr = IClusterResControl_ResourceControl (
                Resource->pClusterResControl,
                (OLERESID)Resource->Id,
                (long)ControlCode,
                &vtIn,
                &vtOut,
                (long *)BytesReturned,
                &status);

        if (FAILED(hr))
        {
            CL_LOGFAILURE(hr); // Use the default processing
            status = ERROR_INVALID_FUNCTION;
        }

        return (DWORD)status ;
    }
}

#endif  // COMRES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\apiinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    apiinit.c

Abstract:

    Initialization for Cluster API component (CLUSAPI) of the
    NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/
#include "apip.h"
#include "aclapi.h"
#include "stdio.h"
#include <psapi.h>


extern LPWSTR               g_pszServicesPath;
extern DWORD                g_dwServicesPid;

API_INIT_STATE ApiState=ApiStateUninitialized;

const DWORD NO_USER_SID         = 0;
const DWORD USER_SID_GRANTED    = 1;
const DWORD USER_SID_DENIED     = 2;

//forward declarations
DWORD
ApipGetLocalCallerInfo(
    IN  handle_t                hIDL,
    IN  OUT OPTIONAL LPDWORD    pdwCheckPid,
    IN  OPTIONAL LPCWSTR        pszModuleName,
    OUT BOOL                    *pbLocal,
    OUT OPTIONAL BOOL           *pbMatchedPid,
    OUT OPTIONAL BOOL           *pbMatchedModule,
    OUT OPTIONAL BOOL           *pbLocalSystemAccount
);


RPC_STATUS
ApipConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    )
/*++

Routine Description:

    RPC callback for authenticating connecting clients of CLUSAPI

Arguments:

    Interface - Supplies the UUID and version of the interface.

    Context - Supplies a server binding handle representing the client

Return Value:

    RPC_S_OK if the user is granted permission.
    RPC_S_ACCESS_DENIED if the user is denied permission.

    Win32 error code otherwise

--*/

{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD BufferSize=0;
    DWORD Size=0;
    DWORD Status;
    HANDLE ClientToken = NULL;
    PRIVILEGE_SET psPrivileges;
    DWORD PrivSize = sizeof(psPrivileges);
    DWORD GrantedAccess;
    DWORD AccessStatus;
    DWORD dwMask = CLUSAPI_ALL_ACCESS;
    GENERIC_MAPPING gmMap;
    DWORD dwStatus = 0;
    BOOL bReturn = FALSE;
    BOOL bACRtn = FALSE;
    DWORD dwUserPermStatus;
    RPC_STATUS RpcStatus;
    BOOL bRevertToSelfRequired = FALSE;
    BOOL bLocal, bMatchedPid, bMatchedModule, bLocalSystemAccount;


    //check if services is calling the cluster service for
    //services calls the interface only for eventlog propagation
    //if so, avoid the security checks
    // Get the process id
    Status = ApipGetLocalCallerInfo(Context,
                &g_dwServicesPid, 
                g_dwServicesPid ? NULL : g_pszServicesPath, //perform the module name match the first time
                &bLocal, 
                &bMatchedPid,
                &bMatchedModule,
                g_dwServicesPid ? &bLocalSystemAccount : NULL);//perform the local system account check if it is the first time
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE, "[API] ApipGetLocalCallerInfo failed with %1!u!.\n",
            Status);
        return RPC_S_ACCESS_DENIED;
    }
    if (Status == ERROR_SUCCESS)
    {
        //if the caller is local and if it matches the pid or if it matches
        //the module and is in local system account, allow access
        if ((bLocal) && 
                (bMatchedPid || (bMatchedModule && bLocalSystemAccount)))
        {
            return(RPC_S_OK);
        }
    }
    

    //
    // The authentication we do here is to retrieve the Security value
    // from the cluster registry, impersonate the client, and call
    // AccessCheck.
    //

    Status = DmQueryString(DmClusterParametersKey,
                           CLUSREG_NAME_CLUS_SD,
                           REG_BINARY,
                           (LPWSTR *) &pSD,
                           &BufferSize,
                           &Size);

    if (Status != ERROR_SUCCESS) {

        PSECURITY_DESCRIPTOR psd4;

        ClRtlLogPrint(LOG_NOISE, "[API] Did not find Security Descriptor key in the cluster DB.\n");
        Status = DmQueryString(DmClusterParametersKey,
                               CLUSREG_NAME_CLUS_SECURITY,
                               REG_BINARY,
                               (LPWSTR *) &psd4,
                               &BufferSize,
                               &Size);

        if (Status == ERROR_SUCCESS) {
            pSD = ClRtlConvertClusterSDToNT5Format(psd4);
            LocalFree(psd4);
        }
        else {

            DWORD   dwSDLen;

            ClRtlLogPrint(LOG_NOISE, "[API] Did not find Security key in the cluster DB.\n");
            Status = ClRtlBuildDefaultClusterSD(NULL, &pSD, &dwSDLen);
            if (SUCCEEDED(Status)) {
                ClRtlLogPrint(LOG_NOISE, "[API] Successfully built default cluster SD.\n");
            }
            else {
                ClRtlLogPrint(LOG_NOISE,
                              "[API] Did not successfully build default cluster SD.  Error = 0x%1!.8x!\n",
                              Status);
                Status = RPC_S_ACCESS_DENIED;
                goto FnExit;
            }
        }
    }

    if (!IsValidSecurityDescriptor(pSD)) {
        ClRtlLogPrint(LOG_ERROR, "[API] SD is not valid!\n");
        ClRtlExamineSD(pSD, "[API]");
        Status = RPC_S_ACCESS_DENIED;
        goto FnExit;
    }

    RpcStatus = RpcImpersonateClient(Context);
    if (RpcStatus != RPC_S_OK) {
        Status = RpcStatus;
        ClRtlLogPrint(LOG_NOISE, "[API] RpcImpersonateClient() failed.  Status = 0x%1!.8x!\n", Status);
        goto FnExit;
    }

    bRevertToSelfRequired = TRUE;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &ClientToken)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE, "[API] OpenThreadToken() failed.  Status = 0x%1!.8x!\n", Status);
        goto FnExit;
    }

    gmMap.GenericRead    = CLUSAPI_READ_ACCESS;
    gmMap.GenericWrite   = CLUSAPI_CHANGE_ACCESS;
    gmMap.GenericExecute = CLUSAPI_READ_ACCESS | CLUSAPI_CHANGE_ACCESS;
    gmMap.GenericAll     = CLUSAPI_ALL_ACCESS;

    MapGenericMask(&dwMask, &gmMap);

    bACRtn = AccessCheck(pSD, ClientToken, dwMask, &gmMap, &psPrivileges, &PrivSize, &dwStatus, &bReturn);
    if (bACRtn && bReturn) {
        Status = RPC_S_OK;
    } else {

        DWORD   dwSDLen;

        ClRtlLogPrint(LOG_NOISE,
                      "[API] User denied access.  GetLastError() = 0x%1!.8x!; dwStatus = 0x%2!.8x!.  Trying the default SD...\n",
                      GetLastError(),
                      dwStatus);
        Status = RPC_S_ACCESS_DENIED;

        ClRtlLogPrint(LOG_NOISE, "[API] Dump access mask.\n");
        ClRtlExamineMask(dwMask, "[API]");

        ClRtlLogPrint(LOG_NOISE, "[API] Dump the SD that failed...\n" );
        ClRtlExamineSD(pSD, "[API]");

        ClRtlLogPrint(LOG_NOISE, "[API] Dump the ClientToken that failed...\n" );
        ClRtlExamineClientToken(ClientToken, "[API]");

        if (pSD) {
            LocalFree(pSD);
            pSD = NULL;
        }

        Status = ClRtlBuildDefaultClusterSD(NULL, &pSD, &dwSDLen);
        if (SUCCEEDED(Status)) {
            ClRtlLogPrint(LOG_NOISE, "[API] Successfully built default cluster SD.\n");
            bACRtn = AccessCheck(pSD, ClientToken, dwMask, &gmMap, &psPrivileges, &PrivSize, &dwStatus, &bReturn);
            if (bACRtn && bReturn) {
                ClRtlLogPrint(LOG_NOISE, "[API] User granted access using default cluster SD.\n");
                Status = RPC_S_OK;
            } else {
                ClRtlLogPrint(LOG_NOISE,
                              "[API] User denied access using default cluster SD.  GetLastError() = 0x%1!.8x!; dwStatus = 0x%2!.8x!.\n",
                              GetLastError(),
                              dwStatus);
                Status = RPC_S_ACCESS_DENIED;
            }
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                          "[API] Did not successfully build default cluster SD.  Error = 0x%1!.8x!\n",
                          Status);
            Status = RPC_S_ACCESS_DENIED;
        }
    }

FnExit:
    if (bRevertToSelfRequired) {
        RpcRevertToSelf();
    }

    if (ClientToken) {
        CloseHandle(ClientToken);
    }

    if (pSD) {
        LocalFree(pSD);
    }

    return(Status);
}


DWORD
ApiInitialize(
    VOID
    )
/*++

Routine Description:

    Performs one-time initialization of the API data structures.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    ClRtlLogPrint(LOG_NOISE, "[API] Initializing\n");

    CL_ASSERT(ApiState == ApiStateUninitialized);

    //
    // Initialize global data.
    //
    InitializeListHead(&NotifyListHead);
    InitializeCriticalSection(&NotifyListLock);

    ApiState = ApiStateOffline;

    return(ERROR_SUCCESS);
}


DWORD
ApiOnlineReadOnly(
    VOID
    )
/*++

Routine Description:

    Brings up a limited set of APIs - currently OpenResource/read-only
    registry APIs. Only LPC connections are enabled.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;


    if (ApiState == ApiStateOffline) {
        ClRtlLogPrint(LOG_NOISE, "[API] Online read only\n");

        //
        // Register the clusapi RPC server interface so resources can use
        // the API when they are created by the FM. Note that we won't receive
        // any calls from remote clients yet because we haven't registered
        // the dynamic UDP endpoint. That will happnen in ApiOnline().
        //
        Status = RpcServerRegisterIfEx(s_clusapi_v2_0_s_ifspec,
                                       NULL,
                                       NULL,
                                       0,
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                       CsUseAuthenticatedRPC ? ApipConnectCallback : NULL
                                       );

        if (Status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[API] Failed to register clusapi RPC interface, status %1!u!.\n",
                          Status
                          );
            return(Status);
        }

        ApiState = ApiStateReadOnly;
    }
    else {
        //CL_ASSERT(ApiState == ApiStateOffline);
    }

    return(ERROR_SUCCESS);
}


DWORD
ApiOnline(
    VOID
    )
/*++

Routine Description:

    Enables the rest of the API set and starts listening for remote
    connections.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;


    ClRtlLogPrint(LOG_NOISE, "[API] Online\n");

    if (ApiState == ApiStateReadOnly) {
        //
        // Register for all events
        //
        Status = EpRegisterEventHandler(CLUSTER_EVENT_ALL,ApipEventHandler);
        if (Status != ERROR_SUCCESS) {
        return(Status);
        }

        //
        // Register the dynamic UDP endpoint for the clusapi interface.
        // This will enable remote clients to begin calling us. We do this
        // here to minimize the chances that we will service an external
        // call before we are ready. If we ever have to rollback after
        // this point, we will still be listening externally. Nothing we can
        // do about that.
        //
        CL_ASSERT(CsRpcBindingVector != NULL);

        Status = RpcEpRegister(s_clusapi_v2_0_s_ifspec,
                               CsRpcBindingVector,
                               NULL,
                               L"Microsoft Cluster Server API");

        if (Status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[API] Failed to register endpoint for clusapi RPC interface, status %1!u!.\n",
                          Status
                          );
            NmDumpRpcExtErrorInfo(Status);
            return(Status);
        }

        ApiState = ApiStateOnline;
    }
    else {
        CL_ASSERT(ApiState == ApiStateReadOnly);
    }

    return(ERROR_SUCCESS);

}

VOID
ApiOffline(
    VOID
    )

/*++

Routine Description:

    Takes the Cluster Api offline.

Arguments:

    None.

Returns:

    None.

--*/

{
    DWORD Status;


    if (ApiState == ApiStateOnline) {

        ClRtlLogPrint(LOG_NOISE, "[API] Offline\n");

        //
        // Deregister the Clusapi RPC endpoint
        //
        CL_ASSERT(CsRpcBindingVector != NULL);

        Status = RpcEpUnregister(
                     s_clusapi_v2_0_s_ifspec,
                     CsRpcBindingVector,
                     NULL
                     );

        if ((Status != RPC_S_OK) && (Status != EPT_S_NOT_REGISTERED)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[API] Failed to deregister endpoint for clusapi RPC interface, status %1!u!.\n",
                Status
                );
        }

        ApiState = ApiStateReadOnly;
    }

//
// KB - We can't deregister the interface because we can't wait for
//      pending calls to complete - pending notifies never complete.
//      If we deregistered the interface after a failed join without
//      a complete shutdown, the subsequent form would fail. As a
//      result, the API won't go offline until service shutdown.
//
#if 0

    if (ApiState == ApiStateReadOnly) {

        //
        // Deregister the Clusapi RPC interface
        //

        Status = RpcServerUnregisterIf(
                     s_clusapi_v2_0_s_ifspec,
                     NULL,
                     1      // Wait for outstanding calls to complete
                     );

        if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] Unable to deregister the clusapi RPC interface, Status %1!u!.\n",
                Status
                );
        }

        ApiState = ApiStateOffline;
    }

#endif

    return;
}


VOID
ApiShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the Cluster Api

Arguments:

    None.

Returns:

    None.

--*/

{
    DWORD  Status;


    if (ApiState > ApiStateOffline) {
        ApiOffline();

        //
        // KB - We do this here because shutdown of the Clusapi RPC
        //          interface is broken due to pending notifies.
        //
        Status = RpcServerUnregisterIf(
                     s_clusapi_v2_0_s_ifspec,
                     NULL,
                     0      // Don't wait for calls to complete
                     );

        if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] Unable to deregister the clusapi RPC interface, Status %1!u!.\n",
                Status
                );
        }

        ApiState = ApiStateOffline;
    }

    if (ApiState == ApiStateOffline) {

        ClRtlLogPrint(LOG_NOISE, "[API] Shutdown\n");

        //
        // KB
        //
        // Because we cannot shutdown the RPC server and cannot
        // unregister our event handler, it is not safe to delete
        // the critical section.
        //
        // DeleteCriticalSection(&NotifyListLock);
        // ApiState = ApiStateUninitialized;

        //
        // TODO?
        //
        // SS: free notify list head
        // SS: how do we deregister with the event handler
        //
    }

    return;
}

DWORD
ApipGetLocalCallerInfo(
    IN  handle_t                hIDL,
    IN  OUT OPTIONAL LPDWORD    pdwCheckPid,
    IN  OPTIONAL LPCWSTR        pszModuleName,
    OUT BOOL                    *pbLocal,
    OUT OPTIONAL BOOL           *pbMatchedPid,
    OUT OPTIONAL BOOL           *pbMatchedModule,
    OUT OPTIONAL BOOL           *pbLocalSystemAccount
)
/*++

Routine Description:

    This function checks whether the caller's account is the local system
    account.

Arguments:

    hIDL - The handle to the binding context
    
    pdwCheckPid - if the value passed in is NULL, the pid of the calling process is returned.  If
        is returned.

    pszModuleName - If non null, the call performs the check to compare
        the module name of the caller against pszModuleName.  If they
        match, *pbMatchedPid is set to TRUE.

    pbLocal - TRUE is returned if the caller initiated this call using 
        lrpc.  If this is FALSE, all other output values will be FALSE.

    pbMatchedModule - TRUE is returned, if the caller matches the module
        name specified by lpszModuleName. This pointer can be NULL.

    pbMatchedPid - if *pdwCheckPid is non NULL, and it matched the pid of the 
        caller, then this is set to TRUE.   Else, this is set to FALSE.

    pbLocalSystemAccount - If this is NON NULL, the call performs a check
        to see if the the caller is running in LocalSystemAccount.  If it is
        then TRUE is returned, else FALSE is returned.
        
Return Value:

    ERROR_SUCCESS on success.

    Win32 error code on failure.

Remarks:


--*/
{
    DWORD           Pid;
    HANDLE          hProcess = NULL;
    DWORD           dwNumChar;
    DWORD           dwLen;
    WCHAR           wCallerPath[MAX_PATH + 1];
    RPC_STATUS      RpcStatus;
    DWORD           dwStatus = ERROR_SUCCESS;
    BOOLEAN         bWasEnabled;

    if (pbMatchedModule)
        *pbMatchedModule = FALSE;
    if (pbMatchedPid)
        *pbMatchedPid = FALSE;
    if (pbLocalSystemAccount)
        *pbLocalSystemAccount = FALSE;


    //assume the caller is local
    *pbLocal = TRUE;
    
    RpcStatus = I_RpcBindingInqLocalClientPID(NULL, &Pid );
    if (RpcStatus == RPC_S_INVALID_BINDING)
    {
        *pbLocal = FALSE;
        RpcStatus = RPC_S_OK;
        goto FnExit;
    }            
    
    dwStatus = I_RpcMapWin32Status(RpcStatus);

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint( LOG_CRITICAL, 
                "[API] ApipGetLocalCallerInfo: Error %1!u! calling RpcBindingInqLocalClientPID.\n",
                dwStatus 
                );
        goto FnExit;
    }

    dwStatus = ClRtlEnableThreadPrivilege(SE_DEBUG_PRIVILEGE, &bWasEnabled);
    if ( dwStatus != ERROR_SUCCESS )
    {
        if (dwStatus == STATUS_PRIVILEGE_NOT_HELD) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[API] ApipGetLocalCallerInfo: Debug privilege not held by cluster service\n");
        } 
        else 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[API] ApipGetLocalCallerInfo: Attempt to enable debug privilege failed %1!lx!\n",
                dwStatus);
        }
        goto FnExit;
    }


    // Get the process
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, Pid);

    //restore the thread privilege, now that we have a process handle with the right access
    ClRtlRestoreThreadPrivilege(SE_DEBUG_PRIVILEGE,
        bWasEnabled);
    
    if(hProcess == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, 
                "[API] ApipGetLocalCallerInfo: Error %1!u! calling OpenProcess %2!u!.\n",
                dwStatus,
                Pid                
                );
                        
        goto FnExit;
    }        


    //if a process id has been specified, see if it matches that one
    if (pdwCheckPid)
    {
        if ((*pdwCheckPid) && (*pdwCheckPid == Pid))
        {
            *pbMatchedPid = TRUE;            
        }
    }
    
    if (pszModuleName && pbMatchedModule)
    {
        // Get the module name of whoever is calling us.
        
        dwNumChar = GetModuleFileNameExW(hProcess, NULL, wCallerPath, MAX_PATH);
        if(dwNumChar == 0)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint( LOG_CRITICAL, 
                "[API] ApipGetLocalCallerInfo: Error %1!u! calling GetModuleFileNameExW.\n",
                dwStatus 
                );
            goto FnExit;
        }        

        if(!lstrcmpiW(wCallerPath, pszModuleName))
        {
            *pbMatchedModule = TRUE;
        }
    }

    //check if it is the local system account, if requested
    if (pbLocalSystemAccount && hIDL)
    {
        // Impersonate the client.
        if ( ( RpcStatus = RpcImpersonateClient( hIDL ) ) != RPC_S_OK )
        {
            dwStatus = I_RpcMapWin32Status(RpcStatus);
            ClRtlLogPrint( LOG_CRITICAL, 
                    "[API] ApipGetLocalCallerInfo: Error %1!u! trying to impersonate caller...\n",
                    dwStatus 
                    );
            goto FnExit;
        }


        // Check that the caller's account is local system account
        dwStatus = ClRtlIsCallerAccountLocalSystemAccount(pbLocalSystemAccount );
        
        RpcRevertToSelf();
        
        if (dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint( LOG_CRITICAL, 
                        "[API] ApipGetLocalCallerInfo : Error %1!u! trying to check caller's account...\n",
                        dwStatus);   
            goto FnExit;
        }
    
    }

    //return the pid if the pid passed in is NULL and the pid passes
    //the criteria  - matches pszModuleName if specified and is in 
    //local system account
    if (pdwCheckPid && !(*pdwCheckPid))
    {
        //if we need to check for local system, the process must be in local system account
        //if the module name needs to be checked 
        if (((pbLocalSystemAccount && *pbLocalSystemAccount) || (!pbLocalSystemAccount))
            && ((pszModuleName && pbMatchedModule && *pbMatchedModule)  || (!pbMatchedModule)))
        {            
            ClRtlLogPrint( LOG_NOISE, 
                        "[API] ApipGetLocalCallerInfo : Returning Pid %1!u!\n",
                        Pid);   
            *pdwCheckPid = Pid;
        }            
    }

FnExit:
    if (hProcess)
        CloseHandle(hProcess);
    return(dwStatus);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resmon\reslist.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    reslist.c

Abstract:

    Implements the management of the resource list. This includes
    adding resources to the list and deleting them from the list.

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support
--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "resmonp.h"
#include "stdio.h"      //RNGBUG - remove all of these in all .c files

#define RESMON_MODULE RESMON_MODULE_RESLIST

DWORD   RmpLogLevel = LOG_ERROR;

//
// Function prototypes local to this module
//
BOOL
RmpChkdskNotRunning(
    IN PRESOURCE Resource
    );




DWORD
RmpSetResourceStatus(
    IN RESOURCE_HANDLE ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    )
/*++

Routine Description:

    Update the status of a resource.

Arguments:

    ResourceHandle - Handle (pointer to) the resource to update.

    ResourceStatus - Pointer to a resource status structure for update.

Returns:

    ResourceExitStateContinue - if the thread does not have to terminate.
    ResourceExitStateTerminate - if the thread must terminat now.

--*/

{
    BOOL      bSuccess;
    DWORD     status;
    PRESOURCE resource = (PRESOURCE)ResourceHandle;
    DWORD     retryCount = ( resource->PendingTimeout/100 >= 600 ) ? 
                            ( resource->PendingTimeout/100 - 400 ):200;
    PPOLL_EVENT_LIST eventList;
    HANDLE    OnlineEvent;

    //
    // Check if we're only updating the checkpoint value. If so, then
    // don't use any locks.
    //
    if ( ResourceStatus->ResourceState >= ClusterResourcePending ) {
        resource->CheckPoint = ResourceStatus->CheckPoint;
        return ResourceExitStateContinue;
    }

    //
    // Acquire the lock first to prevent race conditions if the resource
    // DLL manages to set resource status from a different thread before
    // returning PENDING from its online/offline entrypoint.
    //
    eventList = (PPOLL_EVENT_LIST) resource->EventList;

    status = TryEnterCriticalSection( &eventList->ListLock );
    while ( !status &&
            retryCount-- ) {
        //
        //  Chittur Subbaraman (chitturs) - 10/18/99
        //  
        //  Comment out this unprotected check. The same check is done
        //  protected further downstream. Unprotected checking could
        //  cause a resource to attempt to enter here even before
        //  the timer event has been created by s_RmOnlineResource or
        //  s_RmOfflineResource and in such a case the resource will
        //  not be able to set the resource status. This will cause
        //  the resmon to wrongly time out the resource.
        //
#if 0
        //
        // Check if the resource is shutting down as we're waiting.
        //
        if ( resource->TimerEvent == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] Resource (%1!ws!) TimerEvent became NULL, state (%2!d!)!\n",
                          resource->ResourceName,
                          resource->State);

            if ( resource->OnlineEvent ) {
                CloseHandle( resource->OnlineEvent );
                resource->OnlineEvent = NULL;
            }

            return ResourceExitStateTerminate;
        }
#endif
        //
        //  Chittur Subbaraman (chitturs) - 12/8/99
        //
        //  Check if the "Terminate" or "Close" entry point has been
        //  called for this resource. If so, then no need to set the
        //  resource status. Moreover, those entry points could be
        //  blocked waiting for the pending thread to terminate and
        //  if the pending thread is stuck looping here waiting for 
        //  the lock held by the former thread, we are in a deadlock-like 
        //  situation. [Note that the fact that you are at this point 
        //  means that it is not the "Terminate"/"Close" itself calling 
        //  this function since the eventlist lock can be obtained since 
        //  it was obtained by resmon prior to calling the resdll entry.]
        //
        if( ( resource->dwEntryPoint ) & 
            ( RESDLL_ENTRY_TERMINATE | RESDLL_ENTRY_CLOSE ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpSetResourceStatus: Resource <%1!ws!> not setting status since "
                          "%2!ws! is called, lock owner=0x%3!x!, resource=%4!ws!, state=%5!u!...\n",
                          resource->ResourceName,
                          (resource->dwEntryPoint == RESDLL_ENTRY_TERMINATE) ? 
                          L"Terminate":L"Close",
                          eventList->ListLock.OwningThread,
                          (eventList->LockOwnerResource != NULL) ? eventList->LockOwnerResource->ResourceName:L"Unknown resource",
                          eventList->MonitorState);                      
            if ( resource->OnlineEvent ) {
                CloseHandle( resource->OnlineEvent );
                resource->OnlineEvent = NULL;
            }
            return ResourceExitStateTerminate;       
        }
        
        Sleep(100);     // Delay a little
        status = TryEnterCriticalSection( &eventList->ListLock );
    }

    //
    // If we couldn't proceed, we're stuck. Just return now.
    //
    if ( !status ) {
        //
        // We're unsynchronized, but clean up a bit.
        //
        if ( resource->OnlineEvent ) {
            CloseHandle( resource->OnlineEvent );
            resource->OnlineEvent = NULL;
        }
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] Resource (%1!ws!) Failed TryEnterCriticalSection after too many "
                      "tries, state=%2!d!, lock owner=%3!x!, resource=%4!ws!, state=%5!u!\n",
                      resource->ResourceName,
                      resource->State,
                      eventList->ListLock.OwningThread,
                      (eventList->LockOwnerResource != NULL) ? eventList->LockOwnerResource->ResourceName:L"Unknown resource",
                      eventList->MonitorState);                      
        //
        // SS: Why do we let the resource continue ?
        //
        return ResourceExitStateContinue;
    }

    //
    // SS: If the timer thread has timed us out, there is no
    // point in continuing.
    //
    // First check if the resource is shutting down.
    //
    if ( resource->TimerEvent == NULL ) {
        //
        // Just return asking the resource dll to terminate, but clean 
        // up a bit.
        //
        if ( resource->OnlineEvent ) {
            CloseHandle( resource->OnlineEvent );
            resource->OnlineEvent = NULL;
        }
        ReleaseEventListLock( eventList );
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] Timer Event is NULL when resource (%1!ws!) tries to set state=%2!d! !\n",
                      resource->ResourceName,
                      resource->State);
        return ResourceExitStateTerminate;
    }

    //
    // Synchronize with the online thread.
    //
    if ( resource->OnlineEvent != NULL ) {
        OnlineEvent = resource->OnlineEvent;
        resource->OnlineEvent = NULL;
        ReleaseEventListLock( eventList );
        WaitForSingleObject( OnlineEvent, INFINITE );
        AcquireEventListLock( eventList );
        CloseHandle( OnlineEvent );
    }

    //
    // If the state of the resource is not pending, then return immediately
    //

    if ( resource->State < ClusterResourcePending ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] Resource (%1!ws!) attempted to set status while state was not pending (%2!d!)!\n",
                      resource->ResourceName,
                      resource->State);
        CL_LOGFAILURE(ERROR_INVALID_SERVER_STATE);
        ReleaseEventListLock( eventList );
        return ResourceExitStateContinue;
    }

    resource->State = ResourceStatus->ResourceState;
    // resource->WaitHint = ResourceStatus->WaitHint;
    resource->CheckPoint = ResourceStatus->CheckPoint;

    //
    // If the state has stabilized, stop the timer thread.
    //

    if ( resource->State < ClusterResourcePending ) {
        //
        // Add any events to our eventlist if the resource is reporting its state as online.
        //
        if ( ResourceStatus->EventHandle ) {
            if ( resource->State == ClusterResourceOnline ) {
                if ( (ULONG_PTR)ResourceStatus->EventHandle > 0x2000 ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                                  "[RM] SetResourceStatus: Resource <%1!ws!> attempted to set a bogus event %2!lx!.\n",
                                  resource->ResourceName,
                                  ResourceStatus->EventHandle );
                } else {
                    status = RmpAddPollEvent( eventList,
                                              ResourceStatus->EventHandle,
                                              resource );
                    if ( status != ERROR_SUCCESS ) {
                        resource->State = ClusterResourceFailed;
                        ClRtlLogPrint( LOG_UNUSUAL, "[RM] ResourceStatus, failed to add event to list.\n");
                    }
                    //
                    // Signal poller that event list changed.
                    //
                    if ( status == ERROR_SUCCESS ) {
                        RmpSignalPoller( eventList );
                    }
                }
            } else {
                ClRtlLogPrint(LOG_ERROR,
                              "[RM] RmpSetResourceStatus: Resource '%1!ws!' supplies event handle 0x%2!08lx! while reporting state %3!u!...\n",
                              resource->ResourceName,
                              ResourceStatus->EventHandle,
                              resource->State );
            }
        }
        
        //
        // The event may have been closed by the timer thread
        // if this is happening too late, ignore the error.
        //
        if( resource->TimerEvent != NULL )
        {
            bSuccess = SetEvent( resource->TimerEvent );
            if ( !bSuccess )
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] RmpSetResourceStatus, Error %1!u! calling SetEvent to wake timer thread\n",
                              GetLastError());
        }
        //
        // Chittur Subbaraman (chitturs) - 1/12/99
        //
        // Post a notification to the cluster service regarding a state
        // change AFTER sending a signal to a timer. This will reduce
        // the probability of the cluster service sending in another
        // request before the timer thread had a chance to close out
        // the event handle.
        //
        ClRtlLogPrint(LOG_NOISE,
                      "[RM] RmpSetResourceStatus, Posting state %2!u! notification for resource <%1!ws!>\n",
                      resource->ResourceName,
                      resource->State);

        RmpPostNotify( resource, NotifyResourceStateChange );
    }

    ReleaseEventListLock( eventList );
    return ResourceExitStateContinue;

} // RmpSetResourceStatus



VOID
RmpLogEvent(
    IN RESOURCE_HANDLE ResourceHandle,
    IN LOG_LEVEL LogLevel,
    IN LPCWSTR FormatString,
    ...
    )
/*++

Routine Description:

    Log an event for the given resource.

Arguments:

    ResourceHandle - Handle (pointer to) the resource to update.

    LogLevel - Supplies the level of this log event.

    FormatString - Supplies a format string for this log message.

Returns:

    None.

--*/

{
    LPWSTR headerBuffer;
    LPWSTR messageBuffer;
    DWORD bufferLength;
    PRESOURCE resource = (PRESOURCE)ResourceHandle;
    PVOID argArray[2];
    HKEY resKey;
    DWORD status;
    DWORD valueType;
#ifdef SLOW_RMP_LOG_EVENT
    WCHAR resourceName[128];
#endif
    va_list argList;
    ULONG rtlLogLevel;

    //
    // map resmon log levels to those used by ClRtlLogPrint
    //
    switch ( LogLevel ) {
    case LOG_INFORMATION:
        rtlLogLevel = LOG_NOISE;
        break;

    case LOG_WARNING:
        rtlLogLevel = LOG_UNUSUAL;
        break;

    case LOG_ERROR:
    case LOG_SEVERE:    
    default:
        rtlLogLevel = LOG_CRITICAL;
    }

    if ( (resource == NULL) ||
         (resource->Signature != RESOURCE_SIGNATURE) ) {

        LPWSTR resourcePrefix = (LPWSTR)ResourceHandle;
        //
        // Some resource DLLs have threads that do some
        // work on behalf of this resource DLL, but has no
        // relation to a particular resource. Thus they cannot
        // provide a resource handle, necessary to log an event.
        //
        // The following hack allows them to supply a string
        // to be printed before the message.
        //
        // This string should start with unicode 'r' and 't'
        // characters. "rt" is interpreted as a signature and is not printed.
        //
        if (resourcePrefix &&
            resourcePrefix[0] == L'r' && 
            resourcePrefix[1] == L't') 
        {
            resourcePrefix += 2; // skip the signature
        } else {
            resourcePrefix = L"<Unknown Resource>";
            //CL_LOGFAILURE((DWORD)resource);
        }

        va_start( argList, FormatString );

        //
        // Print out the actual message
        //
        if ( bufferLength = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                           FormatString,
                                           0,
                                           0,
                                           (LPWSTR)&messageBuffer,
                                           0,
                                           &argList) )
        {
            ClRtlLogPrint( rtlLogLevel, "%1!ws!: %2!ws!", resourcePrefix, messageBuffer);
            LocalFree(messageBuffer);
        }
        va_end( argList );

        return;
    }
    //CL_ASSERT(resource->Signature == RESOURCE_SIGNATURE);

#ifdef SLOW_RMP_LOG_EVENT
    status = ClusterRegOpenKey( RmpResourcesKey,
                                resource->ResourceId,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        return;
    }

    bufferLength = 128;
    status = ClusterRegQueryValue( resKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &valueType,
                                   (LPBYTE)&resourceName,
                                   &bufferLength );

    ClusterRegCloseKey( resKey );

    if ( status != ERROR_SUCCESS ) {
        return;
    }
#endif

    //
    // Print out the prefix string
    //
    argArray[0] = resource->ResourceType;
#ifdef SLOW_RMP_LOG_EVENT
    argArray[1] = resourceName;
#else
    argArray[1] = resource->ResourceName;
#endif

    if ( bufferLength = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                       FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       L"%1!ws! <%2!ws!>: ",
                                       0,
                                       0,
                                       (LPWSTR)&headerBuffer,
                                       0,
                                       (va_list*)&argArray) ) {
    } else {
        return;
    }

    va_start( argList, FormatString );

    //
    // Print out the actual message
    //
    if ( bufferLength = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                       FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                       FormatString,
                                       0,
                                       0,
                                       (LPWSTR)&messageBuffer,
                                       0,
                                       &argList) )
    {
        ClRtlLogPrint( rtlLogLevel, "%1!ws!%2!ws!", headerBuffer, messageBuffer);
        LocalFree(messageBuffer);
    }
    LocalFree(headerBuffer);
    va_end( argList );

} // RmpLogEvent



VOID
RmpLostQuorumResource(
    IN RESOURCE_HANDLE ResourceHandle
    )
/*++

Routine Description:

    Stop the cluster service... since we lost our quorum resource.

Arguments:

    ResourceHandle - Handle (pointer to) the resource to update.

Returns:

    None.

--*/

{
    PRESOURCE resource = (PRESOURCE)ResourceHandle;

    //
    // Kill the cluster service alone. Take no action for this process since the main
    // thread in resmon.c would detect the termination of the cluster service process
    // and cleanly shut down hosted resources and the process itself.
    //
    TerminateProcess( RmpClusterProcess, 1 );

    ClRtlLogPrint( LOG_CRITICAL, "[RM] LostQuorumResource, cluster service terminated...\n");

    return;

} // RmpLostQuorumResource


BOOL
RmpChkdskNotRunning(
    IN PRESOURCE Resource
    )

/*++

Routine Description:

    If this is a storage class resource, make sure CHKDSK is not running.

Arguments:

    Resource - A pointer to the resource to check.

Returns:

    TRUE - if this is not a STORAGE resource or CHKDSK is not running.
    FALSE - if this is a STORAGE resource AND CHKDSK is running.

--*/

{
    PSYSTEM_PROCESS_INFORMATION processInfo;
    NTSTATUS        ntStatus;
    DWORD           status;
    DWORD           size = 4096;
    ANSI_STRING     pname;
    PCHAR           commonBuffer = NULL;
    PCHAR           ptr;
    DWORD           totalOffset = 0;
    CLUS_RESOURCE_CLASS_INFO resClassInfo;
    DWORD           bytesReturned;

#if 1
    //
    // Get the class of resource... if not a STORAGE class then fail now.
    //
    if ( Resource->dwType == RESMON_TYPE_DLL ) {
        status = (Resource->pResourceTypeControl)( Resource->Id,
                                    CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                                    NULL,
                                    0,
                                    &resClassInfo,
                                    sizeof(resClassInfo),
                                    &bytesReturned );
    } else {
        HRESULT hr ;
        VARIANT vtIn, vtOut ;
        SAFEARRAY sfIn = {1, 0, 1, 0, NULL, {0, 0} } ;
        SAFEARRAY sfOut  = {1,  FADF_FIXEDSIZE, 1, 0, &resClassInfo, {sizeof(resClassInfo), 0} } ;
        SAFEARRAY *psfOut = &sfOut ;

        vtIn.vt = VT_ARRAY | VT_UI1 ;
        vtOut.vt = VT_ARRAY | VT_UI1 | VT_BYREF ;

        vtIn.parray = &sfIn ;
        vtOut.pparray = &psfOut ;

        hr = IClusterResControl_ResourceControl (
                Resource->pClusterResControl,
                (OLERESID)Resource->Id,
                (long)CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                &vtIn,
                &vtOut,
                (long *)&bytesReturned,
                &status);

        if (FAILED(hr)) {
            CL_LOGFAILURE(hr); // Use the default processing
            status = ERROR_INVALID_FUNCTION;
        }
    }

    if ( (status != ERROR_SUCCESS) ||
         (resClassInfo.rc != CLUS_RESCLASS_STORAGE) ) {
        return TRUE;            // fail now
    }
#endif

retry:

    RmpFree( commonBuffer );

    commonBuffer = RmpAlloc( size );
    if ( !commonBuffer ) {
        return TRUE;           // fail now
    }

    ntStatus = NtQuerySystemInformation(
                    SystemProcessInformation,
                    commonBuffer,
                    size,
                    NULL );

    if ( ntStatus == STATUS_INFO_LENGTH_MISMATCH ) {
        size += 4096;
        goto retry;
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        return TRUE;           // fail now
    }

    processInfo = (PSYSTEM_PROCESS_INFORMATION)commonBuffer;
    while ( TRUE ) {
        if ( processInfo->ImageName.Buffer ) {
            if ( ( ntStatus = RtlUnicodeStringToAnsiString( &pname,
                                               &processInfo->ImageName,
                                               TRUE ) ) != STATUS_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] ChkdskNotRunning: Unable to convert Unicode string to Ansi, status = 0x%lx...\n",
                              ntStatus);
                break;
            }
            
            ptr = strrchr( pname.Buffer, '\\' );
            if ( ptr ) {
                ptr++;
            } else {
                ptr = pname.Buffer;
            }
            if ( lstrcmpiA( ptr, "CHKDSK.EXE" ) == 0 ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] ChkdskNotRunning: Found process %1!ws!.\n",
                              processInfo->ImageName.Buffer );
                RmpFree( pname.Buffer );
                RmpFree( commonBuffer );
                return FALSE;    // chkdsk is running
            }
            RmpFree( pname.Buffer );
        }

        if ( processInfo->NextEntryOffset == 0 ) break;
        totalOffset += processInfo->NextEntryOffset;
        processInfo = (PSYSTEM_PROCESS_INFORMATION)&commonBuffer[totalOffset];
    }

    RmpFree( commonBuffer );
    return TRUE;            // CHKDSK is not running

} // RmpChkdskNotRunning



DWORD
RmpTimerThread(
    IN LPVOID Context
    )
/*++

Routine Description:

    Thread to wait on transition of a resource from pending to a stable state.

Arguments:

    Context - A pointer to the resource being timed.

Returns:

    Win32 error code.

--*/

{
    PRESOURCE resource = (PRESOURCE)Context;
    DWORD   status;
    HANDLE  timerEvent;
    DWORD   prevCheckPoint;

    CL_ASSERT( resource != NULL );

    timerEvent = resource->TimerEvent;
    if ( !timerEvent ) {
        return(ERROR_SUCCESS);
    }

    //
    // Loop waiting for resource to complete pending operation or to
    // shutdown processing.
    //
    while ( timerEvent ) {
        prevCheckPoint = resource->CheckPoint;

        status = WaitForSingleObject( timerEvent,
                                      resource->PendingTimeout );

        //
        // If we were asked to stop, then exit quietly.
        //
        if ( status != WAIT_TIMEOUT ) {
            //
            // The thread that cleans the timer event must close the handle.
            //
            CloseHandle(timerEvent);
            resource->TimerEvent = NULL;
            return(ERROR_SUCCESS);
        }

        //
        // Check if the resource has not made forward progress... if not,
        // then let break out now.
        //
        // Also if this is a storage class resource make sure that
        // CHKDSK is not running.
        //
        if ( (prevCheckPoint == resource->CheckPoint) &&
              RmpChkdskNotRunning( resource ) ) {
            break;
        }

        ClRtlLogPrint(LOG_NOISE,
                      "[RM] RmpTimerThread: Giving a reprieve for resource %1!ws!...\n",
                      resource->ResourceName);
    }

    //
    // Indicate that this resource failed!
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)resource->EventList );
    if ( resource->TimerEvent != NULL ) {

        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpTimerThread: Resource %1!ws! pending timed out "
                      "- setting state to failed.\n",
                      resource->ResourceName);

        CloseHandle(resource->TimerEvent);
        resource->TimerEvent = NULL;
        resource->State = ClusterResourceFailed;
        //
        // Log an event
        //
        status = ERROR_TIMEOUT;
        ClusterLogEvent1(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         RMON_RESOURCE_TIMEOUT,
                         sizeof(status),
                         &status,
                         resource->ResourceName);
        //
        //  Chittur Subbaraman (chitturs) - 4/5/99
        //
        //  Since the resource has failed, there is no point in having
        //  the OnlineEvent hanging around. If the OnlineEvent is not
        //  closed out, then you cannot call s_RmOnlineResource or
        //  s_RmOfflineResource.
        //
        if ( resource->OnlineEvent != NULL ) {
            CloseHandle( resource->OnlineEvent );
            resource->OnlineEvent = NULL;
        }    
        RmpPostNotify( resource, NotifyResourceStateChange );
    }
    ReleaseEventListLock( (PPOLL_EVENT_LIST)resource->EventList );


    return(ERROR_SUCCESS);

} // RmpTimerThread



DWORD
RmpOfflineResource(
    IN RESID ResourceId,
    IN BOOL Shutdown,
    OUT DWORD *pdwState
    )

/*++

Routine Description:

    Brings the specified resource into the offline state.

Arguments:

    ResourceId - Supplies the resource to be brought online.

    Shutdown - Specifies whether the resource is to be shutdown gracefully
        TRUE - resource will be shutdown gracefully
        FALSE - resource will be immediately taken offline

    pdwState - the new resource state is returned in here.

Return Value:

    The new state of the resource.

Notes:

    The resource's eventlist lock must NOT be held.

--*/

{
    DWORD   status=ERROR_SUCCESS;
    BOOL    success;
    PRESOURCE Resource;
    HANDLE  timerThread;
    DWORD   threadId;
    DWORD   loopCount;
    BOOL    fLockAcquired;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    *pdwState = Resource->State;

    //if this is a graceful close,create the online/offline
    //event such that if a resource calls rmpsetresourcestatus
    //soon after online for that resource is called and before
    //the timer thread/event  is even created then we wont have
    //an event leak and an abadoned thread
    if (Shutdown)
    {
        //
        // We should not be in a Pending state.
        //
        if ( Resource->State > ClusterResourcePending )
        {
            return(ERROR_INVALID_STATE);
        }

        //
        // Create an event to allow the SetResourceStatus callback to synchronize
        // execution with this thread.
        //
        if ( Resource->OnlineEvent )
        {
            return(ERROR_NOT_READY);
        }

        Resource->OnlineEvent = CreateEvent( NULL,
                                             FALSE,
                                             FALSE,
                                             NULL );
        if ( Resource->OnlineEvent == NULL )
        {
            return(GetLastError());
        }
    }

    //
    // Lock the EventList Lock, insert the
    // resource into the list, and take the resource offline.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireListLock();  // We need this lock for the potential remove below!
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );


    //
    // Stop any previous timer threads. Should this be done before the lock
    // is held?
    //

    if ( Resource->TimerEvent != NULL ) {
        success = SetEvent( Resource->TimerEvent );
    }

    //
    // Update shared state to indicate we are taking a resource offline
    //
    RmpSetMonitorState(RmonOfflineResource, Resource);

    //
    // If we have an error signal event, then remove it from our lists.
    //
    if ( Resource->EventHandle ) {
        RmpRemovePollEvent( Resource->EventHandle );
    }

    //
    // Call Offline entrypoint.
    //
    if ( Shutdown )
    {

        CL_ASSERT( (Resource->State < ClusterResourcePending) );



        try {
#ifdef COMRES
            status = RESMON_OFFLINE (Resource) ;
#else
            status = (Resource->Offline)(Resource->Id);
#endif
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }
        //
        // If the Resource DLL returns pending, then start a timer.
        //
        if (status == ERROR_SUCCESS) {
            //close the event
            SetEvent( Resource->OnlineEvent );
            CloseHandle( Resource->OnlineEvent );
            Resource->OnlineEvent = NULL;
            Resource->State = ClusterResourceOffline;

        }
        else if ( status == ERROR_IO_PENDING ) {
            CL_ASSERT(Resource->TimerEvent == NULL );
            Resource->TimerEvent = CreateEvent( NULL,
                                                FALSE,
                                                FALSE,
                                                NULL );
            if ( Resource->TimerEvent == NULL ) {
                CL_UNEXPECTED_ERROR(status = GetLastError());
            } else {
                timerThread = CreateThread( NULL,
                                            0,
                                            RmpTimerThread,
                                            Resource,
                                            0,
                                            &threadId );
                if ( timerThread == NULL ) {
                    CL_UNEXPECTED_ERROR(status = GetLastError());
                } else {
                    Resource->State = ClusterResourceOfflinePending;
                    //Resource->WaitHint = PENDING_TIMEOUT;
                    //Resource->CheckPoint = 0;
                    //
                    // Chittur Subbaraman (chitturs) - 1/12/99
                    //
                    // Raise the timer thread priority to highest. This
                    // is necessary to avoid certain cases in which the
                    // timer thread is sluggish to close out the timer event
                    // handle before a second offline. Note that there are
                    // no major performance implications by doing this since
                    // the timer thread is in a wait state most of the time.
                    //
                    if ( !SetThreadPriority( timerThread, THREAD_PRIORITY_HIGHEST ) )
                    {
                        ClRtlLogPrint(LOG_UNUSUAL,
                                      "[RM] RmpOfflineResource:Error setting priority of timer "
                                      "thread for resource %1!ws!\n",
                                      Resource->ResourceName);
                        CL_LOGFAILURE( GetLastError() );
                    }

                    CloseHandle( timerThread );
                }
            }
            Resource->State = ClusterResourceOfflinePending;
            SetEvent(Resource->OnlineEvent);
        }
        else {
            CloseHandle( Resource->OnlineEvent );
            Resource->OnlineEvent = NULL;
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] OfflinelineResource failed, resource %1!ws!, status =  %2!u!.\n",
                          Resource->ResourceName,
                          status);

            ClusterLogEvent1(LOG_CRITICAL,
                             LOG_CURRENT_MODULE,
                             __FILE__,
                             __LINE__,
                             RMON_OFFLINE_FAILED,
                             sizeof(status),
                             &status,
                             Resource->ResourceName);
            Resource->State = ClusterResourceFailed;
        }
    } else {
        Resource->dwEntryPoint = RESDLL_ENTRY_TERMINATE;
        try {
#ifdef COMRES
            RESMON_TERMINATE (Resource) ;
#else
            (Resource->Terminate)(Resource->Id);
#endif
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
        Resource->dwEntryPoint = 0;
        Resource->State = ClusterResourceOffline;
    }


    RmpSetMonitorState(RmonIdle, NULL);
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
    ReleaseListLock();

    *pdwState = Resource->State;
    return(status);

} // RmpOfflineResource



VOID
RmpRemoveResourceList(
    IN PRESOURCE Resource
    )

/*++

Routine Description:

    Removes a resource into the monitoring list.

Arguments:

    Resource - Supplies the resource to be removed from the list.

Return Value:

    None.

--*/

{
    PPOLL_EVENT_LIST EventList = (PPOLL_EVENT_LIST)Resource->EventList;

    AcquireEventListLock( EventList );

    //
    // Make sure it is really in the list.
    //
    CL_ASSERT(Resource->Flags & RESOURCE_INSERTED);
    CL_ASSERT(Resource->ListEntry.Flink->Blink == &Resource->ListEntry);
    CL_ASSERT(Resource->ListEntry.Blink->Flink == &Resource->ListEntry);
    CL_ASSERT(EventList->NumberOfResources);

    RemoveEntryList(&Resource->ListEntry);
    Resource->Flags &= ~RESOURCE_INSERTED;
    --EventList->NumberOfResources;

    ReleaseEventListLock( EventList );

} // RmpRemoveResourceList



DWORD
RmpInsertResourceList(
    IN PRESOURCE Resource,
    IN OPTIONAL PPOLL_EVENT_LIST pPollEventList
    )

/*++

Routine Description:

    Inserts a resource into the monitoring list.

    Each resource is placed in a list along with other resources with the
    same poll interval. The IsAlive and LooksAlive timeouts are adjusted
    so that the IsAlive interval is an even multiple of the LooksAlive interval.
    Thus, the IsAlive poll can simply be done every Nth poll instead of the normal
    LooksAlive poll.

Arguments:

    Resource - Supplies the resource to be added to the list.

    pPollEventList - Supplies the eventlist in which the resource is to
                     be added. Optional.

Return Value:

    None.

--*/

{
    DWORD Temp1, Temp2;
    ULONG i;
    PMONITOR_BUCKET NewBucket;
    PMONITOR_BUCKET Bucket;
    DWORDLONG PollInterval;
    PPOLL_EVENT_LIST EventList;
    PPOLL_EVENT_LIST MinEventList;
    PLIST_ENTRY ListEntry;
    DWORD   dwError = ERROR_SUCCESS;

    CL_ASSERT((Resource->Flags & RESOURCE_INSERTED) == 0);

    //
    // If we have no LooksAlivePollInterval, then poll the IsAlive on every
    // poll interval. Otherwise, poll IsAlive every N LooksAlive poll
    // intervals.
    //
    if ( Resource->LooksAlivePollInterval == 0 ) {
        //
        // Round IsAlivePollInterval up to the system granularity
        //
        Temp1 = Resource->IsAlivePollInterval;
        Temp1 = Temp1 + POLL_GRANULARITY - 1;
        //if this has rolled over
        if (Temp1 < Resource->IsAlivePollInterval)
            Temp1 = 0xFFFFFFFF;
        Temp1 = Temp1 / POLL_GRANULARITY;
        Temp1 = Temp1 * POLL_GRANULARITY;
        Resource->IsAlivePollInterval = Temp1;

        Resource->IsAliveRollover = 1;
        //
        // Convert poll interval from ms to 100ns units
        //
        PollInterval = Resource->IsAlivePollInterval * 10 * 1000;
    } else {
        //
        // First round LooksAlivePollInterval up to the system granularity
        //
        Temp1 = Resource->LooksAlivePollInterval;
        Temp1 = (Temp1 + POLL_GRANULARITY - 1) ;
        //check for rollover
        if (Temp1 < Resource->LooksAlivePollInterval)
            Temp1 = 0xFFFFFFFF;
        Temp1 = Temp1/POLL_GRANULARITY;
        Temp1 = Temp1 * POLL_GRANULARITY;
        Resource->LooksAlivePollInterval = Temp1;

        //
        // Now round IsAlivePollInterval to a multiple of LooksAlivePollInterval
        //
        Temp2 = Resource->IsAlivePollInterval;
        Temp2 = (Temp2 + Temp1 - 1) / Temp1;
        Temp2 = Temp2 * Temp1;
        Resource->IsAlivePollInterval = Temp2;

        Resource->IsAliveRollover = (ULONG)(Temp2 / Temp1);
        CL_ASSERT((Temp2 / Temp1) * Temp1 == Temp2);
        //
        // Convert poll interval from ms to 100ns units
        //
        PollInterval = Resource->LooksAlivePollInterval * 10 * 1000;
    }

    if ( PollInterval > 0xFFFFFFFF ) {
        PollInterval = 0xFFFFFFFF;
    }

    Resource->IsAliveCount = 0;

    //
    // Chittur Subbaraman (chitturs) - 1/30/2000
    //
    // If an eventlist is supplied as parameter, do not attempt to
    // find a new eventlist.
    //
    if( ARGUMENT_PRESENT( pPollEventList ) ) {
        MinEventList = pPollEventList;
        goto skip_eventlist_find;
    }
    //
    // First find the EventList with the fewest number of entries.
    //

    AcquireListLock();

    ListEntry = RmpEventListHead.Flink;
    MinEventList = CONTAINING_RECORD(ListEntry,
                                     POLL_EVENT_LIST,
                                     Next );

    CL_ASSERT( ListEntry != &RmpEventListHead );
    for ( ListEntry = RmpEventListHead.Flink;
          ListEntry != &RmpEventListHead;
          ListEntry = ListEntry->Flink ) {
        EventList = CONTAINING_RECORD( ListEntry, POLL_EVENT_LIST, Next );
        if ( EventList->NumberOfResources < MinEventList->NumberOfResources ) {
            MinEventList = EventList;
        }
    }

    ReleaseListLock();

    if ( MinEventList->NumberOfResources >= MAX_RESOURCES_PER_THREAD ) {
        MinEventList = RmpCreateEventList();
    }
    
skip_eventlist_find:
    if ( MinEventList == NULL ) {
        dwError = GetLastError();
        goto FnExit;
    }

    EventList = MinEventList;

    AcquireEventListLock( EventList );

    Resource->EventList = (PVOID)EventList;

    //
    // Search the list for a bucket with the same period as this resource.
    //
    Bucket = CONTAINING_RECORD(EventList->BucketListHead.Flink,
                               MONITOR_BUCKET,
                               BucketList);
    while (&Bucket->BucketList != &EventList->BucketListHead) {

        if (Bucket->Period == PollInterval) {
            break;
        }
        Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
    }
    if (&Bucket->BucketList == &EventList->BucketListHead) {
        //
        // Need to add a new bucket with this period.
        //
        Bucket = RmpAlloc(sizeof(MONITOR_BUCKET));
        if (Bucket == NULL) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        }
        InsertTailList(&EventList->BucketListHead, &Bucket->BucketList);
        InitializeListHead(&Bucket->ResourceList);
        GetSystemTimeAsFileTime((LPFILETIME)&Bucket->DueTime);
        Bucket->Period = PollInterval;
        if ( PollInterval == 0 ) {
            // The following constant should be over 136 years
            Bucket->DueTime += (DWORDLONG)((DWORDLONG)1000 * (DWORD) -1);
        } else {
            Bucket->DueTime += Bucket->Period;
        }
        EventList->NumberOfBuckets++;
    }
    InsertHeadList(&Bucket->ResourceList, &Resource->ListEntry);
    Resource->Flags |= RESOURCE_INSERTED;
    ++EventList->NumberOfResources;

    ReleaseEventListLock( EventList );

FnExit:
    return (dwError);

} // RmpInsertResourceList



VOID
RmpRundownResources(
    VOID
    )

/*++

Routine Description:

    Runs down the list of active resources and terminates/closes
    each one.

Arguments:

    None

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PMONITOR_BUCKET Bucket;
    PRESOURCE Resource;
    PPOLL_EVENT_LIST EventList;
    DWORD i;
    BOOL fLockAcquired;

    AcquireListLock();
    while (!IsListEmpty(&RmpEventListHead)) {
        ListEntry = RemoveHeadList(&RmpEventListHead);
        EventList = CONTAINING_RECORD(ListEntry,
                                      POLL_EVENT_LIST,
                                      Next);

        AcquireEventListLock( EventList );

        //
        // Find all resources on the bucket list and close them.
        //

        while (!IsListEmpty(&EventList->BucketListHead)) {
            ListEntry = RemoveHeadList(&EventList->BucketListHead);
            Bucket = CONTAINING_RECORD(ListEntry,
                                       MONITOR_BUCKET,
                                       BucketList);
            while (!IsListEmpty(&Bucket->ResourceList)) {
                ListEntry = RemoveHeadList(&Bucket->ResourceList);
                Resource = CONTAINING_RECORD(ListEntry,
                                             RESOURCE,
                                             ListEntry);

                //
                // Acquire spin lock for synchronizing with arbitrate.
                //
                fLockAcquired = RmpAcquireSpinLock( Resource, TRUE );
                
                //
                // If the resource is in online or in pending state, terminate it. Note that
                // we need to terminate pending resources as well, otherwise our close call
                // down below would cause those threads to AV.
                //
                if ((Resource->State == ClusterResourceOnline) ||
                    (Resource->State > ClusterResourcePending)) {
                    Resource->dwEntryPoint = RESDLL_ENTRY_TERMINATE;
                    
                    ClRtlLogPrint( LOG_NOISE,
                        "[RM] RundownResources, terminate resource <%1!ws!>.\n",
                        Resource->ResourceName );
#ifdef COMRES
                    RESMON_TERMINATE (Resource) ;
#else
                    (Resource->Terminate)(Resource->Id);
#endif
                    Resource->dwEntryPoint = 0;
                }

                //
                // If the resource has been arbitrated for, release it.
                //
                if (Resource->IsArbitrated) {
#ifdef COMRES
                    RESMON_RELEASE (Resource) ;
#else
                    (Resource->Release)(Resource->Id);
#endif
                }

                //
                // Close the resource.
                //
                Resource->dwEntryPoint = RESDLL_ENTRY_CLOSE;
#ifdef COMRES
                RESMON_CLOSE (Resource) ;
#else
                (Resource->Close)(Resource->Id);
#endif
                Resource->dwEntryPoint = 0;
                //
                // Zero the resource links so that RmCloseResource can tell
                // that this resource is already terminated and closed.
                //
                Resource->ListEntry.Flink = Resource->ListEntry.Blink = NULL;

                if ( fLockAcquired ) RmpReleaseSpinLock ( Resource );
            }
        }

        //
        // Stop the thread processing this event list, and the notify event.
        //
        CL_ASSERT(EventList->ThreadHandle != NULL);
        CL_ASSERT( EventList->ListNotify != NULL );
        SetEvent(EventList->ListNotify);

        ReleaseEventListLock( EventList );

        //
        // Wait for the thread to finish up before freeing the memory it is
        // referencing.
        //

        ReleaseListLock(); // Release the list lock while waiting...

        //
        // Wait for 60 seconds for the threads to finish up.
        //
        WaitForSingleObject(EventList->ThreadHandle, 60000);

        AcquireListLock();
        CloseHandle(EventList->ThreadHandle);
        EventList->ThreadHandle = NULL;

        //
        // We will assume that all of the event handles were closed as a
        // result of calling the Close entrypoint.
        //

        RmpFree( EventList );
    }

    ReleaseListLock();

    //
    // Post shutdown of notification thread.
    //
    ClRtlLogPrint( LOG_NOISE, "[RM] RundownResources posting shutdown notification.\n");

    RmpPostNotify( NULL, NotifyShutdown );

    return;

} // RmpRundownResources

VOID
RmpSetEventListLockOwner(
    IN PRESOURCE pResource,
    IN DWORD     dwMonitorState
    )

/*++

Routine Description:

    Saves the resource and the resource DLL entry point into the eventlist structure just
    before the resource DLL entry point is called.

Arguments:

    pResource - Pointer to the resource structure.

    dwMonitorState - The state of the resource monitor, what resource DLL entry point it has called.

Return Value:

    None.

--*/
{
    PPOLL_EVENT_LIST pEventList;

    if ( pResource == NULL ) return;
    
    pEventList = (PPOLL_EVENT_LIST) pResource->EventList;

    if ( pEventList != NULL )
    {
        pEventList->LockOwnerResource = pResource;
        pEventList->MonitorState = dwMonitorState;
    }
}

BOOL
RmpAcquireSpinLock(
    IN PRESOURCE pResource,
    IN BOOL fSpin
    )

/*++

Routine Description:

    Acquire a spin lock.

Arguments:

    pResource - Pointer to the resource structure.

    fSpin - TRUE if we must spin if the lock is unavailable. FALSE we shouldn't spin but return
    a failure.

Return Value:

    TRUE - Lock is acquired.

    FALSE - Lock is not acquired.

--*/
{
    DWORD       dwRetryCount = 0;

    //
    //  This resource is not one that supports arbitrate. Return failure. Note that resources
    //  other than the quorum resource support this entry point. We use this instead of the
    //  pResource->IsArbitrate since that variable is set only after the first arbitrate is called
    //  and we need to use this function before the arbitrate entry point is called.
    //
    if ( pResource->pArbitrate == NULL ) return FALSE;

    //
    //  Initial check for lock availability.
    //
    if ( InterlockedCompareExchange( &pResource->fArbLock, 1, 0 ) == 0 ) return TRUE;

    //
    //  Did not get the lock. Check if we must spin.
    //
    if ( fSpin == FALSE ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpAcquireSpinLock: Could not get spinlock for resource %1!ws! after no wait...\n",
                      pResource->ResourceName);
        return FALSE;
    }
    
    //
    //  We must spin. Spin until timeout.
    //
    while ( ( dwRetryCount < RESMON_MAX_SLOCK_RETRIES ) &&
            ( InterlockedCompareExchange( &pResource->fArbLock, 1, 0 ) ) )
    {
        Sleep ( 500 );
        dwRetryCount ++;
    }

    if ( dwRetryCount == RESMON_MAX_SLOCK_RETRIES ) 
    {
        ClRtlLogPrint(LOG_ERROR,
                      "[RM] RmpAcquireSpinLock: Could not get spinlock for resource %1!ws! after spinning...\n",
                      pResource->ResourceName);
        return FALSE;
    }

    return TRUE;
} // RmpAcquireSpinLock

VOID
RmpReleaseSpinLock(
    IN PRESOURCE pResource
    )

/*++

Routine Description:

    Release a spin lock.

Arguments:

    pResource - Pointer to the resource structure.

Return Value:

    None.

--*/
{
    DWORD       dwRetryCount = 0;

    //
    //  This resource is not one that supports arbitrate. Return failure.
    //
    if ( pResource->pArbitrate == NULL ) return;

    InterlockedExchange( &pResource->fArbLock, 0 );
} // RmpReleaseSpinLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\cluster.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    cluster.c

Abstract:

    Server side support for Cluster APIs dealing with the whole
    cluster.

Author:

    John Vert (jvert) 9-Feb-1996

Revision History:

--*/
#include "apip.h"
#include "clusverp.h"
#include "clusudef.h"


HCLUSTER_RPC
s_ApiOpenCluster(
    IN handle_t IDL_handle,
    OUT error_status_t *Status
    )
/*++

Routine Description:

    Opens a handle to the cluster. This context handle is
    currently used only to handle cluster notify additions
    and deletions correctly.

    Added call to ApipConnectCallback which checks that connecting
    users have rights to open cluster.

    Rod Sharper 03/27/97

Arguments:

    IDL_handle - RPC binding handle, not used.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a cluster object if successful

    NULL otherwise.

History:
    RodSh   27-Mar-1997     Modified to support secured user connections.

--*/

{
    PAPI_HANDLE Handle;

    if ( CsUseAuthenticatedRPC ) {

        // if user was not granted access don't return handle
        *Status = ApipConnectCallback( NULL, IDL_handle );
        if( *Status != RPC_S_OK ){
            SetLastError( *Status );
            return NULL;
        }
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    *Status = ERROR_SUCCESS;
    Handle->Type = API_CLUSTER_HANDLE;
    Handle->Flags = 0;
    Handle->Cluster = NULL;
    InitializeListHead(&Handle->NotifyList);

    return(Handle);
}


error_status_t
s_ApiCloseCluster(
    IN OUT HCLUSTER_RPC *phCluster
    )

/*++

Routine Description:

    Closes an open cluster context handle.

Arguments:

    phCluster - Supplies a pointer to the HCLUSTER_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PAPI_HANDLE Handle;

    Handle = (PAPI_HANDLE)*phCluster;
    if (Handle->Type != API_CLUSTER_HANDLE) {
        return(ERROR_INVALID_HANDLE);
    }
    ApipRundownNotify(Handle);

    LocalFree(*phCluster);
    *phCluster = NULL;

    return(ERROR_SUCCESS);
}


VOID
HCLUSTER_RPC_rundown(
    IN HCLUSTER_RPC Cluster
    )

/*++

Routine Description:

    RPC rundown procedure for a HCLUSTER_RPC. Just closes the handle.

Arguments:

    Cluster - Supplies the HCLUSTER_RPC that is to be rundown.

Return Value:

    None.

--*/

{

    s_ApiCloseCluster(&Cluster);
}


error_status_t
s_ApiSetClusterName(
    IN handle_t IDL_handle,
    IN LPCWSTR NewClusterName
    )

/*++

Routine Description:

    Changes the current cluster's name.

Arguments:

    IDL_handle - RPC binding handle, not used

    NewClusterName - Supplies the new name of the cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwSize;
    LPWSTR  pszClusterName = NULL;

    API_CHECK_INIT();

    //
    // Get the cluster name, which is kept in the root of the
    // cluster registry under the "ClusterName" value, call the
    // FM only if the new name is different
    //

    dwSize = (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR);
retry:
    pszClusterName = (LPWSTR)LocalAlloc(LMEM_FIXED, dwSize);
    if (pszClusterName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    Status = DmQueryValue(DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_NAME,
                          NULL,
                          (LPBYTE)pszClusterName,
                          &dwSize);

    if (Status == ERROR_MORE_DATA) {
        //
        // Try again with a bigger buffer.
        //
        LocalFree(pszClusterName);
        goto retry;
    }

    if ( Status == ERROR_SUCCESS ) {
        LPWSTR pszNewNameUpperCase = NULL;

        pszNewNameUpperCase = (LPWSTR) LocalAlloc(
                                            LMEM_FIXED,
                                            (lstrlenW(NewClusterName) + 1) *
                                                sizeof(*NewClusterName)
                                            );

        if (pszNewNameUpperCase != NULL) {
            lstrcpyW( pszNewNameUpperCase, NewClusterName );
            _wcsupr( pszNewNameUpperCase );

            Status = ApipValidateClusterName( pszNewNameUpperCase );

            if ( Status == ERROR_SUCCESS ) {
                Status = FmChangeClusterName(pszNewNameUpperCase);
            }

            LocalFree( pszNewNameUpperCase );
        }
        else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

FnExit:
    if ( pszClusterName ) LocalFree( pszClusterName );
    return(Status);

}


error_status_t
s_ApiGetClusterName(
    IN handle_t IDL_handle,
    OUT LPWSTR *ClusterName,
    OUT LPWSTR *NodeName
    )

/*++

Routine Description:

    Returns the current cluster name and the name of the
    node this RPC connection is to.

Arguments:

    IDL_handle - RPC binding handle, not used

    ClusterName - Returns a pointer to the cluster name.
        This memory must be freed by the client side.

    NodeName - Returns a pointer to the node name.
        This memory must be freed by the client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD           Size;
    DWORD           Status=ERROR_SUCCESS;

    //
    // Get the current node name
    //
    *ClusterName = NULL;
    Size = MAX_COMPUTERNAME_LENGTH+1;
    *NodeName = MIDL_user_allocate(Size*sizeof(WCHAR));
    if (*NodeName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    GetComputerNameW(*NodeName, &Size);


    //
    // Get the cluster name, which is kept in the root of the
    // cluster registry under the "ClusterName" value.
    //

    Status = ERROR_SUCCESS;
    Size = (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR);
retry:
    *ClusterName = MIDL_user_allocate(Size);
    if (*ClusterName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    Status = DmQueryValue(DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_NAME,
                          NULL,
                          (LPBYTE)*ClusterName,
                          &Size);
    if (Status == ERROR_MORE_DATA) {
        //
        // Try again with a bigger buffer.
        //
        MIDL_user_free(*ClusterName);
        goto retry;
    }


FnExit:
    if (Status == ERROR_SUCCESS) {
        return(ERROR_SUCCESS);
    }

    if (*NodeName) MIDL_user_free(*NodeName);
    if (*ClusterName) MIDL_user_free(*ClusterName);
    *NodeName = NULL;
    *ClusterName = NULL;
    return(Status);
}


error_status_t
s_ApiGetClusterVersion(
    IN handle_t IDL_handle,
    OUT LPWORD lpwMajorVersion,
    OUT LPWORD lpwMinorVersion,
    OUT LPWORD lpwBuildNumber,
    OUT LPWSTR *lpszVendorId,
    OUT LPWSTR *lpszCSDVersion
    )
/*++

Routine Description:

    Returns the current cluster version information.

Arguments:

    IDL_handle - RPC binding handle, not used

    lpdwMajorVersion - Returns the major version number of the cluster software

    lpdwMinorVersion - Returns the minor version number of the cluster software

    lpszVendorId - Returns a pointer to the vendor name. This memory must be
        freed by the client side.

    lpszCSDVersion - Returns a pointer to the current CSD description. This memory
        must be freed by the client side.
            N.B. The CSD Version of a cluster is currently the same as the CSD
                 Version of the base operating system.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    LPWSTR VendorString;
    LPWSTR CsdString;
    DWORD Length;
    OSVERSIONINFO OsVersionInfo;

    Length = lstrlenA(VER_CLUSTER_PRODUCTNAME_STR)+1;
    VendorString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (VendorString == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    mbstowcs(VendorString, VER_CLUSTER_PRODUCTNAME_STR, Length);

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionExW(&OsVersionInfo);
    Length = lstrlenW(OsVersionInfo.szCSDVersion)+1;
    CsdString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (CsdString == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpyW(CsdString, OsVersionInfo.szCSDVersion);

    *lpszCSDVersion = CsdString;
    *lpszVendorId = VendorString;
    *lpwMajorVersion = VER_PRODUCTVERSION_W >> 8;
    *lpwMinorVersion = VER_PRODUCTVERSION_W & 0xff;
    *lpwBuildNumber = (WORD)(CLUSTER_GET_MINOR_VERSION(CsMyHighestVersion));

    return(ERROR_SUCCESS);

}


error_status_t
s_ApiGetClusterVersion2(
    IN handle_t IDL_handle,
    OUT LPWORD lpwMajorVersion,
    OUT LPWORD lpwMinorVersion,
    OUT LPWORD lpwBuildNumber,
    OUT LPWSTR *lpszVendorId,
    OUT LPWSTR *lpszCSDVersion,
    OUT PCLUSTER_OPERATIONAL_VERSION_INFO *ppClusterOpVerInfo
    )
/*++

Routine Description:

    Returns the current cluster version information.

Arguments:

    IDL_handle - RPC binding handle, not used

    lpdwMajorVersion - Returns the major version number of the cluster software

    lpdwMinorVersion - Returns the minor version number of the cluster software

    lpszVendorId - Returns a pointer to the vendor name. This memory must be
        freed by the client side.

    lpszCSDVersion - Returns a pointer to the current CSD description. This memory
        must be freed by the client side.
            N.B. The CSD Version of a cluster is currently the same as the CSD
                 Version of the base operating system.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    LPWSTR          VendorString = NULL;
    LPWSTR          CsdString = NULL;
    DWORD           Length;
    OSVERSIONINFO   OsVersionInfo;
    DWORD           dwStatus;
    PCLUSTER_OPERATIONAL_VERSION_INFO    pClusterOpVerInfo=NULL;


    *lpszVendorId = NULL;
    *lpszCSDVersion = NULL;
    *ppClusterOpVerInfo = NULL;

    Length = lstrlenA(VER_CLUSTER_PRODUCTNAME_STR)+1;
    VendorString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (VendorString == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    mbstowcs(VendorString, VER_CLUSTER_PRODUCTNAME_STR, Length);

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionExW(&OsVersionInfo);
    Length = lstrlenW(OsVersionInfo.szCSDVersion)+1;
    CsdString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (CsdString == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(CsdString, OsVersionInfo.szCSDVersion);


    pClusterOpVerInfo = MIDL_user_allocate(sizeof(CLUSTER_OPERATIONAL_VERSION_INFO));
    if (pClusterOpVerInfo == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    pClusterOpVerInfo->dwSize = sizeof(CLUSTER_OPERATIONAL_VERSION_INFO);
    pClusterOpVerInfo->dwReserved = 0;

    dwStatus = NmGetClusterOperationalVersion(&(pClusterOpVerInfo->dwClusterHighestVersion),
                &(pClusterOpVerInfo->dwClusterLowestVersion),
                &(pClusterOpVerInfo->dwFlags));

    *lpszCSDVersion = CsdString;
    *lpszVendorId = VendorString;
    *ppClusterOpVerInfo = pClusterOpVerInfo;
    *lpwMajorVersion = VER_PRODUCTVERSION_W >> 8;
    *lpwMinorVersion = VER_PRODUCTVERSION_W & 0xff;
    *lpwBuildNumber = (WORD)CLUSTER_GET_MINOR_VERSION(CsMyHighestVersion);

FnExit:
    if (dwStatus != ERROR_SUCCESS)
    {
        // free the strings
        if (VendorString) MIDL_user_free(VendorString);
        if (CsdString) MIDL_user_free(CsdString);
        if (pClusterOpVerInfo) MIDL_user_free(pClusterOpVerInfo);
    }

    return(ERROR_SUCCESS);

}



error_status_t
s_ApiGetQuorumResource(
    IN handle_t IDL_handle,
    OUT LPWSTR  *ppszResourceName,
    OUT LPWSTR  *ppszClusFileRootPath,
    OUT DWORD   *pdwMaxQuorumLogSize
    )
/*++

Routine Description:

    Gets the current cluster quorum resource.

Arguments:

    IDL_handle - RPC binding handle, not used.

    *ppszResourceName - Returns a pointer to the current quorum resource name. This
        memory must be freed by the client side.

    *ppszClusFileRootPath - Returns the root path where the permanent cluster files are
        stored.

    *pdwMaxQuorumLogSize - Returns the size at which the quorum log path is set.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD           Status;
    LPWSTR          quorumId = NULL;
    DWORD           idMaxSize = 0;
    DWORD           idSize = 0;
    PFM_RESOURCE    pResource=NULL;
    LPWSTR          pszResourceName=NULL;
    LPWSTR          pszClusFileRootPath=NULL;
    LPWSTR          pszLogPath=NULL;
    LPWSTR          pszEndDeviceName;

    API_CHECK_INIT();
    //
    // Get the quorum resource value.
    //
    Status = DmQuerySz( DmQuorumKey,
                        CLUSREG_NAME_QUORUM_RESOURCE,
                        (LPWSTR*)&quorumId,
                        &idMaxSize,
                        &idSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_ERROR,
                      "[API] s_ApiGetQuorumResource Failed to get quorum resource, error %1!u!.\n",
                      Status);
        goto FnExit;
    }

    //
    // Reference the specified resource ID.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, quorumId );
    if (pResource == NULL) {
        Status =  ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_ERROR,
                      "[API] s_ApiGetQuorumResource Failed to find quorum resource object, error %1!u!\n",
                      Status);
        goto FnExit;
    }

    //
    // Allocate buffer for returning the resource name.
    //
    pszResourceName = MIDL_user_allocate((lstrlenW(OmObjectName(pResource))+1)*sizeof(WCHAR));
    if (pszResourceName == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(pszResourceName, OmObjectName(pResource));

    //
    // Get the root path for cluster temporary files
    //
    idMaxSize = 0;
    idSize = 0;

    Status = DmQuerySz( DmQuorumKey,
                        cszPath,
                        (LPWSTR*)&pszLogPath,
                        &idMaxSize,
                        &idSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_ERROR,
                      "[API] s_ApiGetQuorumResource Failed to get the log path, error %1!u!.\n",
                      Status);
        goto FnExit;
    }


    //
    // Allocate buffer for returning the resource name.
    //
    pszClusFileRootPath = MIDL_user_allocate((lstrlenW(pszLogPath)+1)*sizeof(WCHAR));
    if (pszClusFileRootPath == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(pszClusFileRootPath, pszLogPath);


    *ppszResourceName = pszResourceName;
    *ppszClusFileRootPath = pszClusFileRootPath;

    DmGetQuorumLogMaxSize(pdwMaxQuorumLogSize);

FnExit:
    if (pResource)    OmDereferenceObject(pResource);
    if (pszLogPath) LocalFree(pszLogPath);
    if (quorumId) LocalFree(quorumId);
    if (Status != ERROR_SUCCESS)
    {
        if (pszResourceName) MIDL_user_free(pszResourceName);
        if (pszClusFileRootPath) MIDL_user_free(pszClusFileRootPath);
    }
    return(Status);
}


error_status_t
s_ApiSetQuorumResource(
    IN HRES_RPC hResource,
    IN LPCWSTR  lpszClusFileRootPath,
    IN DWORD    dwMaxQuorumLogSize
    )
/*++

Routine Description:

    Sets the current cluster quorum resource.

Arguments:

    hResource - Supplies a handle to the resource that should be the cluster
        quorum resource.

    lpszClusFileRootPath - The root path for storing
        permananent cluster maintenace files.

    dwMaxQuorumLogSize - The maximum size of the quorum logs before they are
        reset by checkpointing.  If 0, the default is used.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PFM_RESOURCE Resource;
    LPCWSTR lpszPathName = NULL;

    API_CHECK_INIT();
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    //  Chittur Subbaraman (chitturs) - 1/6/99
    //
    //  Check whether the user is passing in a pointer to a NULL character
    //  as the second parameter. If not, pass the parameter passed by the
    //  user
    //
    if ( ( ARGUMENT_PRESENT( lpszClusFileRootPath ) ) &&
         ( *lpszClusFileRootPath != L'\0' ) )
    {
        lpszPathName = lpszClusFileRootPath;
    }

    //
    // Let FM decide if this operation can be completed.
    //
    Status = FmSetQuorumResource(Resource, lpszPathName, dwMaxQuorumLogSize );
    if ( Status != ERROR_SUCCESS ) {
        return(Status);
    }


    //Update the path
    return(Status);
}



error_status_t
s_ApiSetNetworkPriorityOrder(
    IN handle_t IDL_handle,
    IN DWORD NetworkCount,
    IN LPWSTR *NetworkIdList
    )
/*++

Routine Description:

    Sets the priority order for internal (intracluster) networks.

Arguments:

    IDL_handle - RPC binding handle, not used

    NetworkCount - The count of networks in the NetworkList

    NetworkList - An array of pointers to network IDs.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    API_CHECK_INIT();

    return(
        NmSetNetworkPriorityOrder(
               NetworkCount,
               NetworkIdList
               )
        );

}

error_status_t
s_ApiBackupClusterDatabase(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszPathName
    )
/*++

Routine Description:

    Requests for backup of the quorum log file and the checkpoint file.

Argument:

    IDL_handle - RPC binding handle, not used

    lpszPathName - The directory path name where the files have to be
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    API_CHECK_INIT();

    //
    // Let FM decide if this operation can be completed.
    //
    return( FmBackupClusterDatabase( lpszPathName ) );
}

DWORD
ApipValidateClusterName(
    IN LPCWSTR  lpszNewName
    )
/*++

Routine Description:

    Check whether the new cluster name is valid

Argument:

    lpszNewName - New cluster name.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    DWORD                   dwSize = 0;
    PFM_RESOURCE            pResource = NULL;
    DWORD                   dwStatus;
    DWORD                   dwBytesReturned;
    DWORD                   dwRequired;
    LPWSTR                  lpszClusterNameResource = NULL;
    CLUSPROP_BUFFER_HELPER  ListEntry;
    PVOID                   pPropList = NULL;
    DWORD                   cbListSize = 0;
    DWORD                   dwBufferSize;

    ClRtlLogPrint(LOG_NOISE,
                  "[API] ApipValidateClusterName: Validating new name %1!ws!...\n",
                  lpszNewName);

    dwStatus = DmQuerySz( DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_CLUSTER_NAME_RES,
                          &lpszClusterNameResource,
                          &dwSize,
                          &dwSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_ERROR,
            "[API] ApipValidateClusterName: Failed to get cluster name resource from registry, error %1!u!...\n",
            dwStatus);
        goto FnExit;
    }

    //
    // Reference the specified resource ID.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource,
                                       lpszClusterNameResource );

    if ( pResource == NULL )
    {
        dwStatus =  ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_ERROR,
                  "[API] ApipValidateClusterName: Failed to find cluster name resource, %1!u!...\n",
                   dwStatus);
        goto FnExit;
    }

    dwBufferSize = sizeof( ListEntry.pList->nPropertyCount ) +
                   sizeof( *ListEntry.pName ) +
                        ALIGN_CLUSPROP( ( lstrlenW( CLUSREG_NAME_NET_NAME ) + 1 ) * sizeof( WCHAR ) ) +
                   sizeof( *ListEntry.pStringValue ) +
                        ALIGN_CLUSPROP( ( lstrlenW( lpszNewName ) + 1 ) * sizeof( WCHAR ) ) +
                   sizeof( *ListEntry.pSyntax );

    ListEntry.pb = (PBYTE) LocalAlloc( LPTR, dwBufferSize );

    if ( ListEntry.pb == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_ERROR,
                  "[API] ApipValidateClusterName: Error %1!u! in allocating memory...\n",
                   dwStatus);
        goto FnExit;
    }

    pPropList = ListEntry.pb;

    ListEntry.pList->nPropertyCount = 1;
    cbListSize += sizeof( ListEntry.pList->nPropertyCount );
    ListEntry.pb += sizeof( ListEntry.pList->nPropertyCount );

    ListEntry.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
    ListEntry.pName->cbLength  = ( lstrlenW( CLUSREG_NAME_NET_NAME ) + 1 ) * sizeof( WCHAR );
    lstrcpyW( ListEntry.pName->sz, CLUSREG_NAME_NET_NAME );
    cbListSize += sizeof( *ListEntry.pName ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );
    ListEntry.pb += sizeof( *ListEntry.pName ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );

    ListEntry.pStringValue->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_SZ;
    ListEntry.pStringValue->cbLength  = ( lstrlenW( lpszNewName ) + 1 ) * sizeof( WCHAR );
    lstrcpyW( ListEntry.pStringValue->sz, lpszNewName );
    cbListSize += sizeof( *ListEntry.pStringValue ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );
    ListEntry.pb += sizeof( *ListEntry.pStringValue ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );

    ListEntry.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    cbListSize   += sizeof( *ListEntry.pSyntax );
    ListEntry.pb += sizeof( *ListEntry.pSyntax );

    dwStatus = FmResourceControl( pResource,
                                  NULL,
                                  CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES,
                                  (PUCHAR)pPropList,
                                  cbListSize,
                                  NULL,
                                  0,
                                  &dwBytesReturned,
                                  &dwRequired );

FnExit:
    LocalFree( lpszClusterNameResource );

    LocalFree( pPropList );

    if ( pResource != NULL )
    {
        OmDereferenceObject( pResource );
    }

    ClRtlLogPrint(LOG_NOISE,
              "[API] ApipValidateClusterName returns %1!u!...\n",
              dwStatus);

    return( dwStatus );
}

/*++

The set service account password API was added to the cluster
service after Windows XP shipped. In order to add client-side clusapi.dll
support to XP SP1 without breaking the XP SP1 build, this dummy server-side
routine must be added, even though this code does not ship in XP SP1.

--*/
error_status_t
s_ApiSetServiceAccountPassword(
    IN handle_t IDL_handle,
    IN LPWSTR lpszNewPassword,
    IN DWORD dwFlags,
    OUT IDL_CLUSTER_SET_PASSWORD_STATUS *ReturnStatusBufferPtr,
    IN DWORD ReturnStatusBufferSize,
    OUT DWORD *SizeReturned,
    OUT DWORD *ExpectedBufferSize
    )
{
    return( ERROR_CALL_NOT_IMPLEMENTED );
} // s_ApiSetServiceAccountPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\fixup.cpp ===
//depot/Lab01_N/Base/cluster/service/api/fixup.cpp#2 - edit change 450 (text)
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    FixUp.cpp

Abstract:

    Fix up Routines for Rolling Upgrades

Author:

    Sunita Shrivastava(sunitas) 18-Mar-1998
    Galen Barbee    (galenb)    31-Mar-1998


Revision History:

--*/

#include "apip.h"

//extern "C"
//{
//extern ULONG CsLogLevel;
//extern ULONG CsLogModule;
//}

//static WCHAR	wszPropertyName [] =  { CLUSREG_NAME_CLUS_SD };

//typedef struct stSecurityDescriptorProp
//{
//	DWORD					dwPropCount;
//	CLUSPROP_PROPERTY_NAME	pnPropName;
//	WCHAR					wszPropName [( sizeof( wszPropertyName ) / sizeof( WCHAR ) )];
//	CLUSPROP_BINARY			biValueHeader;
//	BYTE 					rgbValueData[1];
//} SECURITYPROPERTY;

/****
@func       DWORD | ApiFixNotifyCb | If a cluster component wants to make
            a fixup to the cluster registry as a part of form/join it
            must register with the NM via this API.

@parm       IN PVOID| pContext | A pointer to the context information passed
            to NmRegisterFixupCb().

@parm       IN PVOID *ppPropertyList |

@parm       IN PVOID pdwProperyListSize | A pointer to DWORD where the size
            of the property list structure is returned.


@comm       For NT 5.0, the api layer performs the fixup for the security
            descriptor.  If the new security descriptor entry for the cluster
            is not present in the registry , convert the old format to the new
            one and write it to the cluster registry.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmJoinFixup> <f NmFormFixup>
*****/
extern "C" DWORD
ApiFixupNotifyCb(
    IN DWORD    dwFixupType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
	OUT LPWSTR  *pszKeyName
    )
{
//	CL_ASSERT( ppPropertyList != NULL );
//	CL_ASSERT( pdwPropertyListSize != NULL );

    PSECURITY_DESCRIPTOR    psd             = NULL;
    DWORD                   dwBufferSize    = 0;
    DWORD                   dwSize          = 0;
    DWORD                   dwStatus        = E_FAIL;

//    ClRtlLogPrint( LOG_INFORMATION,  "[API] ApiFixupNotifyCb: entering.\n" );

	if ( pdwPropertyListSize && ppPropertyList )
	{
	    *ppPropertyList = NULL;
	    *pdwPropertyListSize = 0;

	    dwStatus = DmQueryString( DmClusterParametersKey,   //try to get the NT5 SD
	                               CLUSREG_NAME_CLUS_SD,
	                               REG_BINARY,
	                               (LPWSTR *) &psd,
	                               &dwBufferSize,
	                               &dwSize );

	    if ( dwStatus != ERROR_SUCCESS )
	    {
	        dwStatus = DmQueryString( DmClusterParametersKey,  // try to get the NT4 SD
	                                   CLUSREG_NAME_CLUS_SECURITY,
	                                   REG_BINARY,
	                                   (LPWSTR *) &psd,
	                                   &dwBufferSize,
	                                   &dwSize );

	        if ( dwStatus == ERROR_SUCCESS )
	        {
	            PSECURITY_DESCRIPTOR	psd5 = ClRtlConvertClusterSDToNT5Format( psd );   // convert SD to NT5 format

				*pdwPropertyListSize =  sizeof( DWORD )
											+ sizeof( CLUSPROP_PROPERTY_NAME )
											+ ( ALIGN_CLUSPROP( ( lstrlenW( CLUSREG_NAME_CLUS_SD )  + 1 ) * sizeof( WCHAR ) ) )
											+ sizeof( CLUSPROP_BINARY )
											+ ALIGN_CLUSPROP( GetSecurityDescriptorLength( psd5 ) )
											+ sizeof( CLUSPROP_SYNTAX );

				*ppPropertyList = LocalAlloc( LMEM_ZEROINIT, *pdwPropertyListSize );
				if ( *ppPropertyList != NULL )
				{
					CLUSPROP_BUFFER_HELPER	props;

					props.pb = (BYTE *) *ppPropertyList;

					// set the number of properties
					props.pList->nPropertyCount = 1;
					props.pb += sizeof( props.pList->nPropertyCount );		// DWORD

					// set the property name
					props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
					props.pName->cbLength = ( lstrlenW( CLUSREG_NAME_CLUS_SD )  + 1 ) * sizeof( WCHAR );
					lstrcpyW( props.pName->sz, CLUSREG_NAME_CLUS_SD );
					props.pb += ( sizeof( CLUSPROP_PROPERTY_NAME )
							  + ( ALIGN_CLUSPROP( ( lstrlenW( CLUSREG_NAME_CLUS_SD )  + 1 ) * sizeof( WCHAR ) ) ) );

					// set the binary part of the property the SD...
					props.pBinaryValue->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_BINARY;
					props.pBinaryValue->cbLength = GetSecurityDescriptorLength( psd5 );
					CopyMemory( props.pBinaryValue->rgb, psd5, GetSecurityDescriptorLength( psd5 ) );
					props.pb += sizeof(*props.pBinaryValue) + ALIGN_CLUSPROP( GetSecurityDescriptorLength( psd5 ) );

					// Set an endmark.
					props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
				}
				else
				{
					dwStatus = GetLastError();
//	        		ClRtlLogPrint( LOG_CRITICAL, "[API] ApiFixupNotifyCb: Security key not found. Error = %1!0x.8!.\n", dwStatus );
				}

				// specify the registry key
				*pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED, (lstrlenW(L"Cluster") + 1) *sizeof(WCHAR));
    			if(*pszKeyName==NULL)
        			dwStatus =GetLastError();
        		else
    				lstrcpyW(*pszKeyName,L"Cluster");
    			
	            LocalFree( psd5 );

	            LocalFree( psd );
	        }
	    }
	    else
	    {
//	        ClRtlLogPrint( LOG_INFORMATION,  "[API] ApiFixupNotifyCb: No fixup neccessary.\n" );
	        LocalFree( psd );
	    }
	}
	else
	{
//		ClRtlLogPrint( LOG_CRITICAL,  "[API] ApiFixupNotifyCb: Invalid parameters.\n" );
	}

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Implements server side of the resource and resource type
    IOCTL interfaces in the CLUSAPI.

Author:

    John Vert (jvert) 10/16/1996

Revision History:

--*/
#include "apip.h"


error_status_t
s_ApiNodeResourceControl(
    IN HRES_RPC hResource,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    hResource - Supplies a handle to the resource to be controlled.

    hNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    PNM_NODE     Node;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_NODE(Node, hNode);

    return(FmResourceControl( Resource,
                              Node,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiResourceControl(
    IN HRES_RPC hResource,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    hResource - Supplies a handle to the resource to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    return(FmResourceControl( Resource,
                              NULL,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiNodeResourceTypeControl(
    IN HCLUSTER_RPC hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    hCluster - Supplies a handle to the cluster to be controlled. Not used.

    lpszResourceTypename - Supplies the name of the resource type to be
        controlled.

    hNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE     Node;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);

    return(FmResourceTypeControl( lpszResourceTypeName,
                                  Node,
                                  dwControlCode,
                                  lpInBuffer,
                                  dwInBufferSize,
                                  lpOutBuffer,
                                  nOutBufferSize,
                                  lpBytesReturned,
                                  lpcbRequired ));

}


error_status_t
s_ApiResourceTypeControl(
    IN HCLUSTER_RPC hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    hCluster - Supplies a handle to the cluster to be controlled. Not used.

    lpszResourceTypename - Supplies the name of the resource type to be
        controlled.

    hNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..


    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    API_CHECK_INIT();

    return(FmResourceTypeControl( lpszResourceTypeName,
                                  NULL,
                                  dwControlCode,
                                  lpInBuffer,
                                  dwInBufferSize,
                                  lpOutBuffer,
                                  nOutBufferSize,
                                  lpBytesReturned,
                                  lpcbRequired ));

}


error_status_t
s_ApiNodeGroupControl(
    IN HGROUP_RPC hGroup,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    hGroup - Supplies a handle to the group to be controlled.

    hNode - Supplies a handle to the node on which the group
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP    Group;
    PNM_NODE     Node;

    API_CHECK_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);
    VALIDATE_NODE(Node, hNode);

    return(FmGroupControl( Group,
                           Node,
                           dwControlCode,
                           lpInBuffer,
                           dwInBufferSize,
                           lpOutBuffer,
                           nOutBufferSize,
                           lpBytesReturned,
                           lpcbRequired ));
}


error_status_t
s_ApiGroupControl(
    IN HGROUP_RPC hGroup,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    hGroup - Supplies a handle to the group to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_CHECK_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmGroupControl( Group,
                           NULL,
                           dwControlCode,
                           lpInBuffer,
                           dwInBufferSize,
                           lpOutBuffer,
                           nOutBufferSize,
                           lpBytesReturned,
                           lpcbRequired ));
}


error_status_t
s_ApiNodeNetworkControl(
    IN HNETWORK_RPC hNetwork,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    hNetwork - Supplies a handle to the network to be controlled.

    hNode - Supplies a handle to the node on which the network
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;
    PNM_NODE    Node;

    API_CHECK_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);
    VALIDATE_NODE(Node, hNode);

    return(NmNetworkControl(Network,
                            Node,
                            dwControlCode,
                            lpInBuffer,
                            dwInBufferSize,
                            lpOutBuffer,
                            nOutBufferSize,
                            lpBytesReturned,
                            lpcbRequired ));
}


error_status_t
s_ApiNetworkControl(
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    hNetwork - Supplies a handle to the network to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;

    API_CHECK_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    return(NmNetworkControl(Network,
                            NULL,
                            dwControlCode,
                            lpInBuffer,
                            dwInBufferSize,
                            lpOutBuffer,
                            nOutBufferSize,
                            lpBytesReturned,
                            lpcbRequired ));
}


error_status_t
s_ApiNodeNetInterfaceControl(
    IN HNETINTERFACE_RPC hNetInterface,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    hNetInterface - Supplies a handle to the network interface to be controlled.

    hNode - Supplies a handle to the node on which the network
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_INTERFACE NetInterface;
    PNM_NODE    Node;

    API_CHECK_INIT();

    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);
    VALIDATE_NODE(Node, hNode);

    return(NmInterfaceControl(NetInterface,
                              Node,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiNetInterfaceControl(
    IN HNETINTERFACE_RPC hNetInterface,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    hNetInterface - Supplies a handle to the network interface to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_INTERFACE NetInterface;

    API_CHECK_INIT();

    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    return(NmInterfaceControl(NetInterface,
                              NULL,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiNodeNodeControl(
    IN HNODE_RPC hNode,
    IN HNODE_RPC hHostNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    hNode - Supplies a handle to the node to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE     Node;
    PNM_NODE     HostNode;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);
    VALIDATE_NODE(HostNode, hHostNode);

    return(NmNodeControl( Node,
                          HostNode,
                          dwControlCode,
                          lpInBuffer,
                          dwInBufferSize,
                          lpOutBuffer,
                          nOutBufferSize,
                          lpBytesReturned,
                          lpcbRequired ));
}


error_status_t
s_ApiNodeControl(
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    hNode - Supplies a handle to the node to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE Node;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);

    return(NmNodeControl( Node,
                          NULL,
                          dwControlCode,
                          lpInBuffer,
                          dwInBufferSize,
                          lpOutBuffer,
                          nOutBufferSize,
                          lpBytesReturned,
                          lpcbRequired ));
}



error_status_t
s_ApiNodeClusterControl(
    IN HCLUSTER hCluster,
    IN HNODE_RPC hHostNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and the cluster.

Arguments:

    dwControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE     HostNode;

    API_CHECK_INIT();

    VALIDATE_NODE(HostNode, hHostNode);

    return(CsClusterControl(
               HostNode,
               dwControlCode,
               lpInBuffer,
               dwInBufferSize,
               lpOutBuffer,
               nOutBufferSize,
               lpBytesReturned,
               lpcbRequired ));
}


error_status_t
s_ApiClusterControl(
    IN HCLUSTER hCluster,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and the cluster.

Arguments:

    dwControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    API_CHECK_INIT();

    return(CsClusterControl(
               NULL,
               dwControlCode,
               lpInBuffer,
               dwInBufferSize,
               lpOutBuffer,
               nOutBufferSize,
               lpBytesReturned,
               lpcbRequired ));
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\network.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Server side support for Cluster APIs dealing with networks

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HNETWORK_RPC
s_ApiOpenNetwork(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNetworkName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing network object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNetworkName - Supplies the name of the network to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a network object if successful

    NULL otherwise.

--*/

{
    PAPI_HANDLE Handle;
    HNETWORK_RPC Network;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));

    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    Network = OmReferenceObjectByName(ObjectTypeNetwork, lpszNetworkName);

    if (Network == NULL) {
        LocalFree(Handle);
        *Status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        return(NULL);
    }

    Handle->Type = API_NETWORK_HANDLE;
    Handle->Flags = 0;
    Handle->Network = Network;
    InitializeListHead(&Handle->NotifyList);

    *Status = ERROR_SUCCESS;

    return(Handle);
}


error_status_t
s_ApiCloseNetwork(
    IN OUT HNETWORK_RPC *phNetwork
    )

/*++

Routine Description:

    Closes an open network context handle.

Arguments:

    Network - Supplies a pointer to the HNETWORK_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PNM_NETWORK Network;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NETWORK(Network, *phNetwork);

    Handle = (PAPI_HANDLE)*phNetwork;
    ApipRundownNotify(Handle);

    OmDereferenceObject(Network);

    LocalFree(Handle);
    *phNetwork = NULL;

    return(ERROR_SUCCESS);
}


VOID
HNETWORK_RPC_rundown(
    IN HNETWORK_RPC Network
    )

/*++

Routine Description:

    RPC rundown procedure for a HNETWORK_RPC. Just closes the handle.

Arguments:

    Network - Supplies the HNETWORK_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    API_ASSERT_INIT();

    s_ApiCloseNetwork(&Network);
}


error_status_t
s_ApiGetNetworkState(
    IN HNETWORK_RPC hNetwork,
    OUT DWORD *lpState
    )

/*++

Routine Description:

    Returns the current state of the specified network.

Arguments:

    hNetwork - Supplies the network whose state is to be returned.

    lpState - Returns the current state of the network

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;


    API_ASSERT_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    *lpState = NmGetNetworkState( Network );

    return( ERROR_SUCCESS );
}


error_status_t
s_ApiSetNetworkName(
    IN HNETWORK_RPC hNetwork,
    IN LPCWSTR lpszNetworkName
    )
/*++

Routine Description:

    Sets the new friendly name of a network.

Arguments:

    hNetwork - Supplies the network whose name is to be set.

    lpszNetworkName - Supplies the new name of hNetwork

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;
    HDMKEY NetworkKey;
    DWORD Status = ERROR_INVALID_FUNCTION;

    API_ASSERT_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Status = NmSetNetworkName(
                 Network,
                 lpszNetworkName
                 );

    return(Status);
}


error_status_t
s_ApiGetNetworkId(
    IN HNETWORK_RPC hNetwork,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a network.

Arguments:

    hNetwork - Supplies the network whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PNM_NETWORK Network;
    DWORD NameLen;
    LPCWSTR Name;

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Name = OmObjectId(Network);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);

    *pGuid = MIDL_user_allocate(NameLen);

    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    CopyMemory(*pGuid, Name, NameLen);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\notify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Server side support for the notification APIs in the NT Cluster Service

Author:

    John Vert (jvert) 26-Mar-1996

Revision History:

--*/
#include "apip.h"

//
// Classification of the item types based on FilterType
//

#define ITEM_TYPE_OBJECT_NAME (CLUSTER_CHANGE_GROUP_STATE          |   \
                               CLUSTER_CHANGE_GROUP_ADDED          |   \
                               CLUSTER_CHANGE_GROUP_DELETED        |   \
                               CLUSTER_CHANGE_GROUP_PROPERTY       |   \
                               CLUSTER_CHANGE_NODE_STATE           |   \
                               CLUSTER_CHANGE_NODE_DELETED         |   \
                               CLUSTER_CHANGE_NODE_ADDED           |   \
                               CLUSTER_CHANGE_NODE_PROPERTY        |   \
                               CLUSTER_CHANGE_RESOURCE_STATE       |   \
                               CLUSTER_CHANGE_RESOURCE_ADDED       |   \
                               CLUSTER_CHANGE_RESOURCE_DELETED     |   \
                               CLUSTER_CHANGE_RESOURCE_PROPERTY    |   \
                               CLUSTER_CHANGE_NETWORK_STATE        |   \
                               CLUSTER_CHANGE_NETWORK_ADDED        |   \
                               CLUSTER_CHANGE_NETWORK_DELETED      |   \
                               CLUSTER_CHANGE_NETWORK_PROPERTY     |   \
                               CLUSTER_CHANGE_NETINTERFACE_STATE   |   \
                               CLUSTER_CHANGE_NETINTERFACE_ADDED   |   \
                               CLUSTER_CHANGE_NETINTERFACE_DELETED |   \
                               CLUSTER_CHANGE_NETINTERFACE_PROPERTY)

#define ITEM_TYPE_OBJECT_ID   (CLUSTER_CHANGE_RESOURCE_TYPE_DELETED    | \
                               CLUSTER_CHANGE_RESOURCE_TYPE_ADDED      | \
                               CLUSTER_CHANGE_QUORUM_STATE             | \
                               CLUSTER_CHANGE_CLUSTER_STATE)

#define ITEM_TYPE_REGISTRY    (CLUSTER_CHANGE_REGISTRY_NAME            | \
                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      | \
                               CLUSTER_CHANGE_REGISTRY_VALUE           | \
                               CLUSTER_CHANGE_REGISTRY_SUBTREE)

#define ITEM_TYPE_NAME        (ITEM_TYPE_REGISTRY                   | \
                               CLUSTER_CHANGE_HANDLE_CLOSE          | \
                               CLUSTER_CHANGE_CLUSTER_PROPERTY)


//
// Define types local to this module
//

typedef struct _INTEREST {
    LIST_ENTRY ListEntry;
    LIST_ENTRY HandleList;
    PVOID Object;
    DWORD Filter;
    DWORD Key;
} INTEREST, *PINTEREST;

typedef struct _ITEM {
    LIST_ENTRY ListEntry;
    DWORD FilterType;
    DWORD NotifyKey;
    union {
        LPVOID Object;
        WCHAR KeyName[0];               // For registry notifications
    };
} ITEM, *PITEM;

//
// Function prototypes local to this module
//
DWORD
ApipAddNotifyInterest(
    IN PNOTIFY_PORT Notify,
    IN PAPI_HANDLE ObjectHandle,
    IN DWORD Filter,
    IN DWORD NotifyKey,
    IN DWORD NotifyFilter
    );

//
// Define static data local to this module
//
LIST_ENTRY NotifyListHead;
CRITICAL_SECTION NotifyListLock;


VOID
ApiReportRegistryNotify(
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2,
    IN DWORD     CompletionFilter,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Interface to be called by DM when a registry change triggers
    a notification.

Arguments:

    Context1 - Supplies the first DWORD of Context that was passed
        to DmNotifyChangeKey. This is the NOTIFY_PORT to be used.

    Context2 - Supplies the second DWORD of Context that was passed
        to DmNotifyChangeKey. This is the NotifyKey to be used.

    CompletionFilter - Supplies the type of change that occurred.

    KeyName - Supplies the relative name of the key that was changed.

Return Value:

    None.

--*/

{
    PLIST_ENTRY InterestEntry;
    PLIST_ENTRY PortEntry;
    PINTEREST Interest;
    PITEM Item;
    PNOTIFY_PORT NotifyPort;
    DWORD NameLength;

    ClRtlLogPrint(LOG_NOISE,
               "[API] Notification on port %1!8lx!, key %2!8lx! of type %3!d!. KeyName %4!ws!\n",
               (DWORD)Context1,
               (DWORD)Context2,
               CompletionFilter,
               KeyName);

    NameLength = (lstrlenW(KeyName)+1)*sizeof(WCHAR);
    NotifyPort  = (PNOTIFY_PORT)Context1;

    //
    // Post notification item for this interest.
    //
    Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM)+NameLength);
    if (Item != NULL) {
        Item->FilterType = CompletionFilter;
        Item->NotifyKey = (DWORD)Context2;
        CopyMemory(Item->KeyName, KeyName, NameLength);

        ClRtlInsertTailQueue(&NotifyPort->Queue, &Item->ListEntry);
    }

}


VOID
ApipRundownNotify(
    IN PAPI_HANDLE Handle
    )
/*++

Routine Description:

    Runs down any notification interests on a particular
    cluster object. The INTEREST structures will be yanked
    from their notification lists and freed.

Arguments:

    Handle - Supplies the API handle for the object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PINTEREST Interest;

    if (IsListEmpty(&Handle->NotifyList)) {
        return;
    }

    EnterCriticalSection(&NotifyListLock);
    while (!IsListEmpty(&Handle->NotifyList)) {
        ListEntry = RemoveHeadList(&Handle->NotifyList);
        Interest = CONTAINING_RECORD(ListEntry,
                                     INTEREST,
                                     HandleList);
        CL_ASSERT(Interest->Object == Handle->Cluster);

        RemoveEntryList(&Interest->ListEntry);
        LocalFree(Interest);
    }
    LeaveCriticalSection(&NotifyListLock);
}


DWORD
WINAPI
ApipEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes cluster events and dispatches the notifications to the appropriate
    notify queues.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD Filter;
    DWORD NameLength = 0;
    PLIST_ENTRY PortEntry;
    PNOTIFY_PORT NotifyPort;
    PLIST_ENTRY InterestEntry;
    PINTEREST Interest;
    PITEM Item;

    //
    // Translate EP event types into clusapi notification filters
    //
    switch (Event) {
        case CLUSTER_EVENT_API_NODE_UP:
        case CLUSTER_EVENT_NODE_DOWN:
        case CLUSTER_EVENT_NODE_JOIN:
        case CLUSTER_EVENT_NODE_CHANGE:
            Filter = CLUSTER_CHANGE_NODE_STATE;
            break;

        case CLUSTER_EVENT_NODE_ADDED:
            Filter = CLUSTER_CHANGE_NODE_ADDED;
            break;

        case CLUSTER_EVENT_NODE_PROPERTY_CHANGE:            
            Filter = CLUSTER_CHANGE_NODE_PROPERTY;
            break;

        case CLUSTER_EVENT_NODE_DELETED:
            Filter = CLUSTER_CHANGE_NODE_DELETED;
            break;

        case CLUSTER_EVENT_RESOURCE_ONLINE:
        case CLUSTER_EVENT_RESOURCE_OFFLINE:
        case CLUSTER_EVENT_RESOURCE_FAILED:
        case CLUSTER_EVENT_RESOURCE_CHANGE:
            Filter = CLUSTER_CHANGE_RESOURCE_STATE;
            break;

        case CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_RESOURCE_PROPERTY;
            break;

        case CLUSTER_EVENT_RESOURCE_ADDED:
            Filter = CLUSTER_CHANGE_RESOURCE_ADDED;
            break;

        case CLUSTER_EVENT_RESOURCE_DELETED:
            Filter = CLUSTER_CHANGE_RESOURCE_DELETED;
            break;

        case CLUSTER_EVENT_GROUP_ONLINE:
        case CLUSTER_EVENT_GROUP_OFFLINE:
        case CLUSTER_EVENT_GROUP_FAILED:
        case CLUSTER_EVENT_GROUP_CHANGE:
            Filter = CLUSTER_CHANGE_GROUP_STATE;
            break;

        case CLUSTER_EVENT_GROUP_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_GROUP_PROPERTY;
            break;

        case CLUSTER_EVENT_GROUP_ADDED:
            Filter = CLUSTER_CHANGE_GROUP_ADDED;
            break;

        case CLUSTER_EVENT_GROUP_DELETED:
            Filter = CLUSTER_CHANGE_GROUP_DELETED;
            break;

        case CLUSTER_EVENT_NETWORK_UNAVAILABLE:
        case CLUSTER_EVENT_NETWORK_DOWN:
        case CLUSTER_EVENT_NETWORK_PARTITIONED:
        case CLUSTER_EVENT_NETWORK_UP:
            Filter = CLUSTER_CHANGE_NETWORK_STATE;
            break;

        case CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_NETWORK_PROPERTY;
            break;

        case CLUSTER_EVENT_NETWORK_ADDED:
            Filter = CLUSTER_CHANGE_NETWORK_ADDED;
            break;

        case CLUSTER_EVENT_NETWORK_DELETED:
            Filter = CLUSTER_CHANGE_NETWORK_DELETED;
            break;

        case CLUSTER_EVENT_NETINTERFACE_UNAVAILABLE:
        case CLUSTER_EVENT_NETINTERFACE_FAILED:
        case CLUSTER_EVENT_NETINTERFACE_UNREACHABLE:
        case CLUSTER_EVENT_NETINTERFACE_UP:
            Filter = CLUSTER_CHANGE_NETINTERFACE_STATE;
            break;

        case CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_NETINTERFACE_PROPERTY;
            break;

        case CLUSTER_EVENT_NETINTERFACE_ADDED:
            Filter = CLUSTER_CHANGE_NETINTERFACE_ADDED;
            break;

        case CLUSTER_EVENT_NETINTERFACE_DELETED:
            Filter = CLUSTER_CHANGE_NETINTERFACE_DELETED;
            break;

        case CLUSTER_EVENT_RESTYPE_ADDED:
            Filter = CLUSTER_CHANGE_RESOURCE_TYPE_ADDED;
            break;

        case CLUSTER_EVENT_RESTYPE_DELETED:
            Filter = CLUSTER_CHANGE_RESOURCE_TYPE_DELETED;
            break;

        case CLUSTER_EVENT_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_CLUSTER_PROPERTY;
            break;

        default:
            //
            // No notification for any of the other events yet.
            //
            return(ERROR_SUCCESS);

    }

    //
    // Run through the outstanding notify sessions and post notify items
    // for any matches.
    //
    EnterCriticalSection(&NotifyListLock);
    PortEntry = NotifyListHead.Flink;
    while (PortEntry != &NotifyListHead) {
        NotifyPort = CONTAINING_RECORD(PortEntry, NOTIFY_PORT, ListEntry);
        if (NotifyPort->Filter & Filter) {

            //
            // There are notification interests for this notify type, run
            // through the list of notification interests.
            //
            InterestEntry = NotifyPort->InterestList.Flink;
            while (InterestEntry != &NotifyPort->InterestList) {
                Interest = CONTAINING_RECORD(InterestEntry, INTEREST, ListEntry);

                //
                // Report the notification if the Interest's cluster object is NULL (which
                // means that this is a general cluster interest) or if the interest's specific
                // object matches the object reporting the notify.
                //
                if ((Interest->Filter & Filter) &&
                    ((Interest->Object == NULL) ||
                     (Interest->Object == Context))) {
                    //
                    // Post notification item for this interest.
                    //
                    if (Filter & ITEM_TYPE_NAME) {
                        NameLength = (lstrlenW(Context)+1)*sizeof(WCHAR);
                        Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM)+NameLength);
                    } else {
                        Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM));
                    }
                    if (Item != NULL) {
                        Item->FilterType = Filter;
                        Item->NotifyKey = Interest->Key;

                        if (!(Filter & ITEM_TYPE_NAME)) {
                            //
                            // Reference the object again to ensure that the name does
                            // not disappear out from under us before we are done with it.
                            //
                            Item->Object = Context;
                            OmReferenceObject(Context);
                        } else {
                            CopyMemory(Item->KeyName, Context, NameLength);
                        }
                        ClRtlInsertTailQueue(&NotifyPort->Queue, &Item->ListEntry);
                    }
                }
                InterestEntry = InterestEntry->Flink;
            }
        }
        PortEntry = PortEntry->Flink;
    }

    LeaveCriticalSection(&NotifyListLock);

    return(ERROR_SUCCESS);
}


HNOTIFY_RPC
s_ApiCreateNotify(
    IN HCLUSTER_RPC hCluster,
    OUT error_status_t *rpc_error
    )

/*++

Routine Description:

    Creates the server side of a notification port.

Arguments:

    IDL_handle - Supplies cluster handle.

    dwFilter - Supplies the cluster events of interest.

    dwNotifyKey - Supplies a key to be returned on any notifications

    rpc_error - Returns any RPC-specific error

Return Value:

    An RPC context handle for a notification port.

    NULL on failure.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PAPI_HANDLE Handle;

    if (ApiState != ApiStateOnline) {
        *rpc_error = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *rpc_error = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }
    Port = LocalAlloc(LMEM_FIXED, sizeof(NOTIFY_PORT));
    if (Port == NULL) {
        LocalFree(Handle);
        *rpc_error = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }
    InitializeListHead(&Port->InterestList);
    InitializeListHead(&Port->RegistryList);
    InitializeCriticalSection(&Port->Lock);
    Status = ClRtlInitializeQueue(&Port->Queue);
    if (Status != ERROR_SUCCESS) {
        LocalFree(Port);
        *rpc_error = Status;
        return(NULL);
    }

    EnterCriticalSection(&NotifyListLock);
    InsertTailList(&NotifyListHead, &Port->ListEntry);
    LeaveCriticalSection(&NotifyListLock);

    Handle->Type = API_NOTIFY_HANDLE;
    Handle->Notify = Port;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    *rpc_error = ERROR_SUCCESS;
    return(Handle);
}



error_status_t
s_ApiAddNotifyCluster(
    IN HNOTIFY_RPC hNotify,
    IN HCLUSTER_RPC hCluster,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey
    )

/*++

Routine Description:

    Adds another set of notification events to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hCluster - Supplies the cluster to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);

    Handle = (PAPI_HANDLE)hCluster;
    if (Handle->Type != API_CLUSTER_HANDLE) {
        return(ERROR_INVALID_HANDLE);
    }
    Status = ApipAddNotifyInterest(Port,
                                   Handle,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (dwFilter & ITEM_TYPE_REGISTRY) {
        //
        // Add a registry notification for the entire cluster.
        //
        DmNotifyChangeKey(DmClusterParametersKey,
                          dwFilter & ITEM_TYPE_REGISTRY,
                          (dwFilter & CLUSTER_CHANGE_REGISTRY_SUBTREE) ? TRUE : FALSE,
                          &Port->RegistryList,
                          ApiReportRegistryNotify,
                          (DWORD_PTR)Port,
                          dwNotifyKey);
    }
    return(Status);

}


error_status_t
s_ApiAddNotifyNode(
    IN HNOTIFY_RPC hNotify,
    IN HNODE_RPC hNode,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a node-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNode - Supplies the node to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this node

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NODE(Node, hNode);
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNode,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = NmGetNodeState(Node);
    }

    return(Status);
}


error_status_t
s_ApiAddNotifyGroup(
    IN HNOTIFY_RPC hNotify,
    IN HGROUP_RPC hGroup,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a group-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hGroup - Supplies the group to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_GROUP_EXISTS(Group, hGroup);
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hGroup,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = Group->StateSequence;
    }
    return(Status);

}


error_status_t
s_ApiAddNotifyNetwork(
    IN HNOTIFY_RPC hNotify,
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a network-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetwork - Supplies the network to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NETWORK Network;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetwork,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);

    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = NmGetNetworkState( Network );
    }

    return(Status);
}


error_status_t
s_ApiAddNotifyNetInterface(
    IN HNOTIFY_RPC hNotify,
    IN HNETINTERFACE_RPC hNetInterface,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a network interface-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetInterface - Supplies the network interface to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_INTERFACE NetInterface;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetInterface,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);

    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = NmGetInterfaceState( NetInterface );
    }

    return(Status);
}


error_status_t
s_ApiAddNotifyResource(
    IN HNOTIFY_RPC hNotify,
    IN HRES_RPC hResource,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a resource-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hResource - Supplies the resource to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_RESOURCE Resource;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hResource,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = Resource->StateSequence;
    }
    return(Status);

}


error_status_t
s_ApiReAddNotifyNode(
    IN HNOTIFY_RPC hNotify,
    IN HNODE_RPC hNode,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a node-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNode - Supplies the node to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this node

    dwStateSequence - Supplies the previous state sequence. If this does
        not match the current sequence, an immediate notification will
        be issued.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NODE Node;
    DWORD NotifyFilter;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NODE(Node, hNode);

    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyNode for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
               OmObjectId(Node),
               dwFilter,
               dwStateSequence,
               NmGetNodeState(Node));
    if (NmGetNodeState(Node) != (CLUSTER_NODE_STATE)dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_NODE_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNode,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);
}


error_status_t
s_ApiReAddNotifyGroup(
    IN HNOTIFY_RPC hNotify,
    IN HGROUP_RPC hGroup,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a group-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hGroup - Supplies the group to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_GROUP Group;
    DWORD NotifyFilter;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_GROUP_EXISTS(Group, hGroup);
    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyGroup for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
               OmObjectName(Group),
               dwFilter,
               dwStateSequence,
               Group->StateSequence);
    if (Group->StateSequence != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_GROUP_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hGroup,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);

}


error_status_t
s_ApiReAddNotifyNetwork(
    IN HNOTIFY_RPC hNotify,
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a network-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetwork - Supplies the network to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NETWORK Network;
    DWORD NotifyFilter = 0;
    CLUSTER_NETWORK_STATE CurrentState;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    CurrentState = NmGetNetworkState( Network );

    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyNetwork for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
                OmObjectName(Network),
                dwFilter,
                dwStateSequence,
                CurrentState);

    if ((DWORD)CurrentState != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_NETWORK_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetwork,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);
}


error_status_t
s_ApiReAddNotifyNetInterface(
    IN HNOTIFY_RPC hNotify,
    IN HNETINTERFACE_RPC hNetInterface,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a network interface-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetInterface - Supplies the network interface to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_INTERFACE NetInterface;
    DWORD NotifyFilter = 0;
    CLUSTER_NETINTERFACE_STATE CurrentState;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    CurrentState = NmGetInterfaceState( NetInterface );

    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyNetInterface for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
                OmObjectName(NetInterface),
                dwFilter,
                dwStateSequence,
                CurrentState);

    if ((DWORD)CurrentState != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_NETINTERFACE_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetInterface,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);
}


error_status_t
s_ApiReAddNotifyResource(
    IN HNOTIFY_RPC hNotify,
    IN HRES_RPC hResource,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a resource-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hResource - Supplies the resource to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_RESOURCE Resource;
    DWORD NotifyFilter;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyGroup for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
               OmObjectName(Resource),
               dwFilter,
               dwStateSequence,
               Resource->StateSequence);
    if (Resource->StateSequence != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_RESOURCE_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hResource,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);

}


error_status_t
s_ApiAddNotifyKey(
    IN HNOTIFY_RPC hNotify,
    IN HKEY_RPC hKey,
    IN DWORD dwNotifyKey,
    IN DWORD Filter,
    IN BOOL WatchSubTree
    )

/*++

Routine Description:

    Adds a registry notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hKey - Supplies the key to be added

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

    WatchSubTree - Supplies whether the notification applies to just
        the specified key or to the keys entire subtree

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    HDMKEY Key;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_KEY(Key, hKey);
    Status = DmNotifyChangeKey(Key,
                               Filter,
                               WatchSubTree,
                               &Port->RegistryList,
                               ApiReportRegistryNotify,
                               (DWORD_PTR)Port,
                               dwNotifyKey);
    return(Status);

}


void
HNOTIFY_RPC_rundown(
    IN HNOTIFY_RPC hNotify
    )

/*++

Routine Description:

    RPC rundown routine for notification ports.

Arguments:

    hNotify - Supplies the notification port to be rundown

Return Value:

    None.

--*/

{
    s_ApiCloseNotify(&hNotify);
}


error_status_t
s_ApiUnblockGetNotifyCall(
    IN HNOTIFY_RPC hNotify
    )

/*++

Routine Description:

    Unblocks the s_ApiGetNotify call.

Arguments:

    hNotify - Supplies the notification port to be closed.

Return Value:

    None.

--*/

{
    PNOTIFY_PORT pPort;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/2000
    //
    //  In order to prevent the client from calling ApiGetNotify
    //  during or after the context handle is destroyed, we split
    //  the notification port close into two steps. In the first step,
    //  we merely unblock the ApiGetNotify call without freeing the 
    //  context handle. That is the purpose of this function.
    //  In the next step, we free the context handle. The client can now 
    //  perform the notification port close in 2 steps, properly 
    //  synchronizing the freeing of the context handle with the call to 
    //  ApiGetNotify. This avoids an AV in RPC code caused by the 
    //  ApiGetNotify call being made during or soon after the context 
    //  handle is freed.
    //
    API_ASSERT_INIT();

    VALIDATE_NOTIFY( pPort, hNotify );

    DELETE_HANDLE( hNotify );

    ApipUnblockGetNotifyCall( pPort );
    
    return( ERROR_SUCCESS );
}

DWORD
s_ApiCloseNotify(
    IN OUT HNOTIFY_RPC *phNotify
    )

/*++

Routine Description:

    Closes a cluster notification port and unblocks the s_ApiGetNotify
    thread, if necessary.

Arguments:

    phNotify - Supplies the pointer to the notification port to be closed.
               Returns NULL

Return Value:

    ERROR_SUCCESS.

--*/

{
    PNOTIFY_PORT pPort;

    API_ASSERT_INIT();
 
    if ( !IS_HANDLE_DELETED( *phNotify ) )
    {
        //
        //  If the handle is not already deleted, this means this call is
        //  coming from a client that does not make the ApiUnblockGetNotify
        //  call. In such a case, do all the work of unblocking the 
        //  ApiGetNotify thread and freeing the context handle.
        //
        VALIDATE_NOTIFY( pPort, *phNotify );

        ApipUnblockGetNotifyCall( pPort );
    } else
    {
        pPort = ((PAPI_HANDLE)(*phNotify))->Notify;
    }

    DeleteCriticalSection(&pPort->Lock);
    
    LocalFree( pPort );

    LocalFree( *phNotify );

    *phNotify = NULL;

    return( ERROR_SUCCESS );
}

error_status_t
s_ApiGetNotify(
    IN HNOTIFY_RPC hNotify,
    IN DWORD Timeout,
    OUT DWORD *dwNotifyKey,
    OUT DWORD *dwFilter,
    OUT DWORD *dwStateSequence,
    OUT LPWSTR *Name
    )


/*++

Routine Description:

    Retrieves a cluster notification event from a notify port

Arguments:

    hNotify - Supplies the notification port

    Timeout - Supplies the time to wait in ms.

    dwNotifyKey - Returns the notification key of the event

    dwFilter - Returns the notification type of the event

    dwStateSequence - Returns the current state sequence of the object.

    Name - Returns the name of the event. This buffer must be
        freed on the client side with MIDL_user_free

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PNOTIFY_PORT Port;
    PLIST_ENTRY ListEntry;
    PITEM Item;
    DWORD NameLen;
    LPCWSTR ObjectName;
    LPWSTR NullName = L"";
    DWORD StateSequence = 0;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);

    //
    // Make sure that Port is valid.
    //
    if ( Port == NULL ) {
        return(ERROR_INVALID_HANDLE);
    }

    //
    // Wait for something to arrive in the queue.
    // Take the lock to make sure the notify port doesn't
    // disappear out from under us.
    //
    EnterCriticalSection(&Port->Lock);
    if (IS_HANDLE_DELETED(hNotify)) {
        ListEntry = NULL;
    } else {
        ListEntry = ClRtlRemoveHeadQueue(&Port->Queue);
    }
    LeaveCriticalSection(&Port->Lock);
    if (ListEntry == NULL) {
        return(ERROR_NO_MORE_ITEMS);
    }

    Item = CONTAINING_RECORD(ListEntry, ITEM, ListEntry);
    if (Item->FilterType & ITEM_TYPE_OBJECT_NAME) {
        ObjectName = OmObjectName( Item->Object );
    } else if (Item->FilterType & ITEM_TYPE_OBJECT_ID) {
        ObjectName = OmObjectId( Item->Object );
    } else if (Item->FilterType & ITEM_TYPE_NAME) {
        ObjectName = Item->KeyName;
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[API] s_ApiGetNotify: Unrecognized filter type,0x%1!08lx!\r\n",
            Item->FilterType);
        LocalFree(Item);
#if DBG
        CL_ASSERT(FALSE)
#endif
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Get the state sequence for those notifications that have
    // state sequences.
    //
    if (Item->FilterType & CLUSTER_CHANGE_GROUP_STATE) {
        StateSequence = ((PFM_GROUP)(Item->Object))->StateSequence;
    } else if (Item->FilterType & CLUSTER_CHANGE_RESOURCE_STATE) {
        StateSequence = ((PFM_RESOURCE)(Item->Object))->StateSequence;
    } else if (Item->FilterType & CLUSTER_CHANGE_NODE_STATE) {
        StateSequence = NmGetNodeState((PNM_NODE)(Item->Object));
    }
    if ( ObjectName == NULL ) {
        ObjectName = NullName;
    }
    NameLen = (lstrlenW(ObjectName)+1)*sizeof(WCHAR);
    *Name = MIDL_user_allocate(NameLen);
    if (*Name != NULL) {
        CopyMemory(*Name, ObjectName, NameLen);
    }

    *dwFilter = Item->FilterType;
    *dwNotifyKey = Item->NotifyKey;
    *dwStateSequence = StateSequence;
    if (Item->FilterType & (ITEM_TYPE_OBJECT_NAME | ITEM_TYPE_OBJECT_ID)) {
        OmDereferenceObject(Item->Object);
    }
    LocalFree(Item);

    if (*Name == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    } else {
        return(ERROR_SUCCESS);
    }

}


DWORD
ApipAddNotifyInterest(
    IN PNOTIFY_PORT Notify,
    IN PAPI_HANDLE ObjectHandle,
    IN DWORD Filter,
    IN DWORD NotifyKey,
    IN DWORD NotifyFilter
    )

/*++

Routine Description:

    Registers a notification interest on an existing
    cluster notification port

Arguments:

    Notify - Supplies the notification port

    ObjectHandle - Supplies a pointer to the object's handle.

    Filter - Supplies the set of notification events to be added.

    NotifyKey - Supplies the notification key to be returned on
        any notification events

    NotifyNow - Supplies whether a notification should be immediately
        posted (TRUE).

    NotifyFilter - If not zero, indicates that a notification should be
        immediately posted with the specified filter.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PINTEREST Interest;
    PITEM Item;

    if (Filter == 0) {
        return(ERROR_SUCCESS);
    }

    Interest = LocalAlloc(LMEM_FIXED, sizeof(INTEREST));
    if (Interest == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Interest->Object = ObjectHandle->Cluster;
    Interest->Filter = Filter;
    Interest->Key = NotifyKey;

    EnterCriticalSection(&NotifyListLock);
    InsertHeadList(&Notify->InterestList, &Interest->ListEntry);
    InsertHeadList(&ObjectHandle->NotifyList, &Interest->HandleList);
    Notify->Filter |= Filter;
    if (NotifyFilter) {
        //
        // Post an immediate notification on this object.
        //
        //SS: this assert is wrong because you can have a filter
        //that is a combination of say CLUSTER_CHANGE_GROUP_STATE+CLUSTER_CHANGE_HANDLE_CLOSE
        //and that is perfectly valid
        //CL_ASSERT(!(Filter & ITEM_TYPE_NAME));
        Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM));
        if (Item != NULL) {
            Item->FilterType = NotifyFilter;
            Item->NotifyKey = Interest->Key;
            Item->Object = ObjectHandle->Node;
            OmReferenceObject(ObjectHandle->Node);
            ClRtlInsertTailQueue(&Notify->Queue, &Item->ListEntry);
        }

    }
    LeaveCriticalSection(&NotifyListLock);

    return(ERROR_SUCCESS);

}

DWORD
ApipUnblockGetNotifyCall(
    PNOTIFY_PORT pPort
    )

/*++

Routine Description:

    Unblocks the s_ApiGetNotify call.

Arguments:

    pPort - Port associated with the session.

Return Value:

    ERROR_SUCCESS.

--*/

{
    PINTEREST Interest;
    PLIST_ENTRY ListEntry;
    LIST_ENTRY RundownList;
    PITEM Item;

    EnterCriticalSection(&NotifyListLock);
    RemoveEntryList(&pPort->ListEntry);

    //
    // rundown registry notifications
    //
    DmRundownList(&pPort->RegistryList);

    //
    // Abort any waiters on the queue and rundown any
    // items that may have already been posted to the
    // queue.
    //
    ClRtlRundownQueue(&pPort->Queue, &RundownList);
    while (!IsListEmpty(&RundownList)) {
        ListEntry = RemoveHeadList(&RundownList);
        Item = CONTAINING_RECORD(ListEntry,
                                 ITEM,
                                 ListEntry);
        if (!(Item->FilterType & ITEM_TYPE_NAME)) {
            OmDereferenceObject(Item->Object);
        }
        LocalFree(Item);
    }

    EnterCriticalSection(&pPort->Lock);
    ClRtlDeleteQueue(&pPort->Queue);
    LeaveCriticalSection(&pPort->Lock);

    //
    // rundown list of notify interests and delete each one.
    //
    while (!IsListEmpty(&pPort->InterestList)) {
        ListEntry = RemoveHeadList(&pPort->InterestList);
        Interest = CONTAINING_RECORD(ListEntry, INTEREST, ListEntry);
        RemoveEntryList(&Interest->HandleList);
        LocalFree(Interest);
    }

    LeaveCriticalSection(&NotifyListLock);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\enum.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    Server side support for Cluster APIs dealing with enumeration

Author:

    John Vert (jvert) 9-Feb-1996

Revision History:

--*/
#include "apip.h"

#define ENUM_SIZE(Entries) ((Entries-1) * sizeof(ENUM_ENTRY) + sizeof(ENUM_LIST))

//
// Define structure passed to enumeration routine.
//
typedef struct _REFOBJECT {
    HDMKEY RootKey;
    LPCWSTR FriendlyName;
    DWORD NameLength;
    LPWSTR NameBuffer;
    OBJECT_TYPE Type;
} REFOBJECT, *PREFOBJECT;

BOOL
ApipRefObjectWorker(
    IN PREFOBJECT Target,
    IN PVOID *pObject,
    IN PVOID Object,
    IN LPCWSTR ObjectId
    );

BOOL
ApipEnumResourceWorker(
    IN PENUM_LIST *pEnum,
    IN PVOID Context2,
    IN PFM_RESOURCE Node,
    IN LPCWSTR Name
    );

BOOL
ApipEnumGroupResourceWorker(
    IN PENUM_LIST *pEnum,
    IN PVOID Context2,
    IN PFM_RESOURCE Node,
    IN LPCWSTR Name
    );

BOOL
ApipEnumNodeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    );


BOOL
ApipEnumResTypeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    );

BOOL
ApipEnumGroupWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    );

BOOL
ApipEnumNetworkWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    );

DWORD
ApipEnumInternalNetworks(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated
    );

BOOL
ApipEnumNetworkInterfaceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    );

VOID
ApipFreeEnum(
    IN PENUM_LIST Enum
    );



error_status_t
s_ApiCreateEnum(
    IN handle_t IDL_handle,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the specified objects and returns the
    list of objects to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    IDL_handle - RPC binding handle, not used

    dwType - Supplies the type of objects to be enumerated

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;

    //initialize to NULL for failure cases
    *ReturnEnum = NULL;

    if (dwType != CLUSTER_ENUM_NODE) {
        API_CHECK_INIT();
    }

    if (dwType & CLUSTER_ENUM_INTERNAL_NETWORK) {
        if ((dwType & ~CLUSTER_ENUM_INTERNAL_NETWORK) != 0) {
            return(ERROR_INVALID_PARAMETER);
        }
    }
    else {
        if (dwType & ~CLUSTER_ENUM_ALL) {
            return(ERROR_INVALID_PARAMETER);
        }
    }

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    Enum->EntryCount = 0;

    //
    // Enumerate all nodes
    //
    if (dwType & CLUSTER_ENUM_NODE) {
        OmEnumObjects(ObjectTypeNode,
                      ApipEnumNodeWorker,
                      &Enum,
                      &Allocated);

    }

    //
    // Enumerate all resource types
    //
    if (dwType & CLUSTER_ENUM_RESTYPE) {
        OmEnumObjects(ObjectTypeResType,
                      ApipEnumResTypeWorker,
                      &Enum,
                      &Allocated);
    }

    //
    // Enumerate all resources
    //
    if (dwType & CLUSTER_ENUM_RESOURCE) {
        OmEnumObjects(ObjectTypeResource,
                      ApipEnumResourceWorker,
                      &Enum,
                      &Allocated);

    }

    //
    // Enumerate all groups
    //
    if (dwType & CLUSTER_ENUM_GROUP) {
        OmEnumObjects(ObjectTypeGroup,
                      ApipEnumGroupWorker,
                      &Enum,
                      &Allocated);

    }

    //
    // Enumerate all networks
    //
    if (dwType & CLUSTER_ENUM_NETWORK) {
        OmEnumObjects(ObjectTypeNetwork,
                      ApipEnumNetworkWorker,
                      &Enum,
                      &Allocated);
    }

    //
    // Enumerate internal networks in highest to lowest priority order.
    //
    if (dwType & CLUSTER_ENUM_INTERNAL_NETWORK) {
        Status = ApipEnumInternalNetworks(&Enum, &Allocated);

        if (Status != ERROR_SUCCESS) {
            goto ErrorExit;
        }
    }

    //
    // Enumerate all network interfaces
    //
    if (dwType & CLUSTER_ENUM_NETINTERFACE) {
        OmEnumObjects(ObjectTypeNetInterface,
                      ApipEnumNetworkInterfaceWorker,
                      &Enum,
                      &Allocated);
    }

    *ReturnEnum = Enum;
    return(ERROR_SUCCESS);

ErrorExit:

    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    return(Status);

}


VOID
ApipFreeEnum(
    IN PENUM_LIST Enum
    )
/*++

Routine Description:

    Frees an ENUM_LIST and all of its strings.

Arguments:

    Enum - Supplies the Enum to free.

Return Value:

    None.

--*/

{
    DWORD i;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
}


VOID
ApipAddToEnum(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN LPCWSTR Name,
    IN DWORD Type
    )

/*++

Routine Description:

    Common worker callback routine for enumerating objects.
    Adds the specified resource to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Name - Supplies the name of the object to be added to the ENUM_LIST.

           A copy of this name will be created by using MIDL_user_allocate.

    Type - Supplies the object's type

Return Value:

    None


--*/

{
    PENUM_LIST Enum;
    PENUM_LIST NewEnum;
    DWORD NewAllocated;
    DWORD Index;
    LPWSTR NewName;

    NewName = MIDL_user_allocate((lstrlenW(Name)+1)*sizeof(WCHAR));
    if (NewName == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
    lstrcpyW(NewName, Name);
    Enum = *pEnum;
    if (Enum->EntryCount >= *pAllocated) {
        //
        // Need to grow the ENUM_LIST
        //
        NewAllocated = *pAllocated + 8;
        NewEnum = MIDL_user_allocate(ENUM_SIZE(NewAllocated));
        if (NewEnum == NULL) {
            MIDL_user_free(NewName);
            return;
        }
        CopyMemory(NewEnum, Enum, ENUM_SIZE(*pAllocated));
        CL_ASSERT( Enum->EntryCount == NewEnum->EntryCount );
        *pAllocated = NewAllocated;
        *pEnum = NewEnum;
        MIDL_user_free(Enum);
        Enum = NewEnum;
    }

    //
    // Initialize new entry field.
    //
    Enum->Entry[Enum->EntryCount].Name = NewName;
    Enum->Entry[Enum->EntryCount].Type = Type;
    ++Enum->EntryCount;

    return;
}



BOOL
ApipEnumResourceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of resources.
    Adds the specified resource to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Resource - Supplies the resource to be added to the ENUM_LIST

    Name - Supplies the resource's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Resource);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_RESOURCE);
        MIDL_user_free( RealName);
    }
    return(TRUE);
}


BOOL
ApipEnumGroupResourceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of resources.
    Adds the specified resource to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Resource - Supplies the resource to be added to the ENUM_LIST

    Name - Supplies the resource's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Resource);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_GROUP_ENUM_CONTAINS);
        MIDL_user_free( RealName );
    }
    return(TRUE);
}


BOOL
ApipEnumNodeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of nodes.
    Adds the specified node to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Node - Supplies the node to be added to the ENUM_LIST

    Name - Supplies the node's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPCWSTR RealName;

    RealName = OmObjectName(Node);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_NODE);
    }
    return(TRUE);
}


BOOL
ApipEnumResTypeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of resource types.
    Adds the specified resource type to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Node - Supplies the resource type to be added to the ENUM_LIST

    Name - Supplies the resource type's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    ApipAddToEnum(pEnum,
                  pAllocated,
                  Name,
                  CLUSTER_ENUM_RESTYPE);
    return(TRUE);
}


BOOL
ApipEnumGroupWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of groups.
    Adds the specified group to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Group - Supplies the group to be added to the ENUM_LIST

    Name - Supplies the group's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPCWSTR RealName;

    RealName = OmObjectName(Group);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_GROUP);
    }
    return(TRUE);
}



BOOL
ApipEnumNetworkWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of networks.
    Adds the specified network to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Object - Supplies the object to be added to the ENUM_LIST

    Name - Supplies the network's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Object);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_NETWORK);
        MIDL_user_free( RealName );
    }
    return(TRUE);
}


DWORD
ApipEnumInternalNetworks(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated
    )

/*++

Routine Description:

    Enumerates all networks used for internal communication.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD         Status;
    DWORD         NetworkCount;
    PNM_NETWORK  *NetworkList;
    DWORD         i;
    LPWSTR        RealName;


    Status = NmEnumInternalNetworks(&NetworkCount, &NetworkList);

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    for (i=0; i<NetworkCount; i++) {
        RealName = ApipGetObjectName(NetworkList[i]);

        if (RealName != NULL) {
            ApipAddToEnum(pEnum,
                          pAllocated,
                          RealName,
                          (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK);
            MIDL_user_free( RealName );
        }

        OmDereferenceObject(NetworkList[i]);
    }

    if (NetworkList != NULL) {
        LocalFree(NetworkList);
    }

    return(ERROR_SUCCESS);

}


BOOL
ApipEnumNetworkInterfaceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of network interfaces.
    Adds the specified network interface to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Object - Supplies the object to be added to the ENUM_LIST

    Name - Supplies the network interface's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Object);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_NETINTERFACE);
        MIDL_user_free( RealName );
    }
    return(TRUE);
}


error_status_t
s_ApiCreateNodeEnum(
    IN HNODE_RPC hNode,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the resource objects contained in the specified
    node and returns them to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    hNode - Supplies the node to be enumerated

    dwType - Supplies a bitmask of the type of properties to be
            enumerated.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PNM_INTERFACE * InterfaceList;
    DWORD InterfaceCount;
    PNM_NODE Node;
    DWORD i;


    API_CHECK_INIT();

    VALIDATE_NODE_EXISTS(Node, hNode);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));

    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    Enum->EntryCount = 0;

    if (dwType & CLUSTER_NODE_ENUM_NETINTERFACES) {
        Status = NmEnumNodeInterfaces(
                     Node,
                     &InterfaceCount,
                     &InterfaceList
                     );

        if (Status != ERROR_SUCCESS) {
            goto ErrorExit;
        }

        for (i=0; i<InterfaceCount; i++) {
            ApipAddToEnum(&Enum,
                          &Allocated,
                          OmObjectName(InterfaceList[i]),
                          CLUSTER_NODE_ENUM_NETINTERFACES);
            OmDereferenceObject(InterfaceList[i]);
        }

        if (InterfaceList != NULL) {
            LocalFree(InterfaceList);
        }
    }

    *ReturnEnum = Enum;

    return(ERROR_SUCCESS);

ErrorExit:
    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);

}


error_status_t
s_ApiCreateGroupResourceEnum(
    IN HGROUP_RPC hGroup,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the resource objects contained in the specified
    group and returns them to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    hGroup - Supplies the group to be enumerated

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_GROUP_ENUM_CONTAINS  - All resources contained in the specified
                                           group

            CLUSTER_GROUP_ENUM_NODES     - All nodes in the specified group's preferred
                                           owner list.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PFM_GROUP Group;

    API_CHECK_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    Enum->EntryCount = 0;

    //
    // Enumerate all contained resources
    //
    if (dwType & CLUSTER_GROUP_ENUM_CONTAINS) {
        //
        // Enumerate all resources for the Group.
        //
        Status = FmEnumerateGroupResources(Group,
                                  ApipEnumGroupResourceWorker,
                                  &Enum,
                                  &Allocated);
        if ( Status != ERROR_SUCCESS ) {
            goto ErrorExit;
        }
    }

    if (dwType & CLUSTER_GROUP_ENUM_NODES) {
        LPWSTR Buffer=NULL;
        DWORD BufferSize=0;
        DWORD DataSize=0;
        DWORD i;
        HDMKEY GroupKey;
        LPCWSTR Next;
        PNM_NODE Node;

        //
        // Enumerate all preferred nodes for the group.
        // Just get this data right out of the registry.
        //
        GroupKey = DmOpenKey(DmGroupsKey,
                             OmObjectId(Group),
                             KEY_READ);
        if (GroupKey == NULL) {
            Status = GetLastError();
            goto ErrorExit;
        }
        Status = DmQueryMultiSz(GroupKey,
                                CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                                &Buffer,
                                &BufferSize,
                                &DataSize);
        DmCloseKey(GroupKey);
        if (Status != ERROR_FILE_NOT_FOUND) {
            if (Status != ERROR_SUCCESS) {
                //
                //  Chittur Subbaraman (chitturs) - 10/05/98
                //  Fix memory leak
                //
                LocalFree(Buffer);
                goto ErrorExit;
            }
            for (i=0; ; i++) {
                Next = ClRtlMultiSzEnum(Buffer, DataSize/sizeof(WCHAR), i);
                if (Next == NULL) {
                    Status = ERROR_SUCCESS;
                    break;
                }
                Node = OmReferenceObjectById(ObjectTypeNode, Next);
                if (Node != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  OmObjectName(Node),
                                  CLUSTER_GROUP_ENUM_NODES);
                    OmDereferenceObject(Node);
                }

            }
        }
        //
        //  Chittur Subbaraman (chitturs) - 10/05/98
        //  Fix memory leak
        //
        LocalFree(Buffer);
    }

    *ReturnEnum = Enum;
    return(ERROR_SUCCESS);

ErrorExit:
    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);

}


error_status_t
s_ApiCreateNetworkEnum(
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the interface objects contained in the specified
    network and returns them to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    hNetwork - Supplies the network to be enumerated

    dwType - Supplies a bitmask of the type of properties to be
            enumerated.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PNM_INTERFACE * InterfaceList;
    DWORD InterfaceCount;
    PNM_NETWORK Network;
    DWORD i;


    API_CHECK_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));

    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    Enum->EntryCount = 0;

    if (dwType & CLUSTER_NETWORK_ENUM_NETINTERFACES) {
        Status = NmEnumNetworkInterfaces(
                     Network,
                     &InterfaceCount,
                     &InterfaceList
                     );

        if (Status != ERROR_SUCCESS) {
            goto ErrorExit;
        }

        for (i=0; i<InterfaceCount; i++) {
            ApipAddToEnum(&Enum,
                          &Allocated,
                          OmObjectName(InterfaceList[i]),
                          CLUSTER_NETWORK_ENUM_NETINTERFACES);
            OmDereferenceObject(InterfaceList[i]);
        }

        if (InterfaceList != NULL) {
            LocalFree(InterfaceList);
        }
    }

    *ReturnEnum = Enum;

    return(ERROR_SUCCESS);

ErrorExit:
    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);

}


BOOL
ApipRefObjectWorker(
    IN PREFOBJECT Target,
    IN PVOID *pObject,
    IN PVOID Object,
    IN LPCWSTR ObjectId
    )

/*++

Routine Description:

    Enumeration worker for ApipReferenceObjectByName.

Arguments:

    Target - Supplies the friendly name that is to be referenced.

    pObject - Returns the object found, if any.

    Object - Supplies the current object being enumerated.

    ObjectId - Supplies the identifier (GUID) of the current object being
            enumerated.

Return Value:

    TRUE - Object did not match. Enumeration should continue.

    FALSE - Object match was found. Enumeration should stop.

--*/

{
    HDMKEY Key;
    DWORD Size;
    DWORD Status;
    DWORD Type;

    Key = DmOpenKey(Target->RootKey,
                    ObjectId,
                    KEY_READ);
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(GetLastError());
        return(TRUE);
    }

    Size = Target->NameLength;
    Status = DmQueryValue(Key,
                          L"Name",
                          &Type,
                          (UCHAR *)Target->NameBuffer,
                          &Size);
    DmCloseKey(Key);
    if ((Status == ERROR_SUCCESS) &&
        (lstrcmpiW(Target->NameBuffer, Target->FriendlyName)==0)) {
        //
        // Found a match. Reference it and return it.
        //
        OmReferenceObject(Object);
        *pObject = Object;
        return(FALSE);
    }
    //
    // Mismatch.
    //
    return(TRUE);

}


LPWSTR
ApipGetObjectName(
    IN PVOID Object
    )

/*++

Routine Description:

    Allocates a string and fills in the object's name.

Arguments:

    Object - A pointer to the object to get its name.

Return Value:

    A pointer to a WSTR that contains the user-friendly name of the object.
    NULL on failure - use GetLastError to get the Win32 error code.

--*/

{
    LPWSTR  Name;
    DWORD   NameSize;

    if ( OmObjectName(Object) == NULL ) {
        Name = MIDL_user_allocate(1 * sizeof(WCHAR));
        if ( Name != NULL ) {
            *Name = (WCHAR)0;
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        NameSize = lstrlenW(OmObjectName(Object));
        Name = MIDL_user_allocate((NameSize + 1) * sizeof(WCHAR));
        if ( Name != NULL ) {
            lstrcpyW( Name, OmObjectName(Object) );
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(Name);

} // ApipGetObjectName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\intrface.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Server side support for Cluster APIs dealing with network interfaces

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HNETINTERFACE_RPC
s_ApiOpenNetInterface(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNetInterfaceName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing network interface object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNetInterfaceName - Supplies the name of the netinterface to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a network interface object if successful

    NULL otherwise.

--*/

{
    PAPI_HANDLE Handle;
    HNETINTERFACE_RPC NetInterface;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));

    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    NetInterface = OmReferenceObjectByName(ObjectTypeNetInterface,
                                           lpszNetInterfaceName);

    if (NetInterface == NULL) {
        LocalFree(Handle);
        *Status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        return(NULL);
    }

    Handle->Type = API_NETINTERFACE_HANDLE;
    Handle->Flags = 0;
    Handle->NetInterface = NetInterface;
    InitializeListHead(&Handle->NotifyList);

    *Status = ERROR_SUCCESS;

    return(Handle);
}


error_status_t
s_ApiCloseNetInterface(
    IN OUT HNETINTERFACE_RPC *phNetInterface
    )

/*++

Routine Description:

    Closes an open network interface context handle.

Arguments:

    NetInterface - Supplies a pointer to the HNETINTERFACE_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PNM_INTERFACE NetInterface;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NETINTERFACE(NetInterface, *phNetInterface);

    Handle = (PAPI_HANDLE)*phNetInterface;
    ApipRundownNotify(Handle);

    OmDereferenceObject(NetInterface);

    LocalFree(Handle);
    *phNetInterface = NULL;

    return(ERROR_SUCCESS);
}


VOID
HNETINTERFACE_RPC_rundown(
    IN HNETINTERFACE_RPC NetInterface
    )

/*++

Routine Description:

    RPC rundown procedure for a HNETINTERFACE_RPC. Just closes the handle.

Arguments:

    NetInterface - Supplies the HNETINTERFACE_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    API_ASSERT_INIT();

    s_ApiCloseNetInterface(&NetInterface);
}


error_status_t
s_ApiGetNetInterfaceState(
    IN HNETINTERFACE_RPC hNetInterface,
    OUT DWORD *lpState
    )

/*++

Routine Description:

    Returns the current state of the specified network interface.

Arguments:

    hNetInterface - Supplies the network interface whose state is to be returned

    lpState - Returns the current state of the network interface

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_INTERFACE NetInterface;


    API_ASSERT_INIT();

    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    *lpState = NmGetInterfaceState( NetInterface );

    return( ERROR_SUCCESS );
}


error_status_t
s_ApiGetNetInterface(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNodeName,
    IN LPCWSTR lpszNetworkName,
    OUT LPWSTR *lppszInterfaceName
    )
/*++

Routine Description:

    Gets the network interface for the given node and network.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the node name

    lpszNetworkName - Supplies the network name

    lppszInterfaceName - Returns the interface name

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    API_ASSERT_INIT();

    return(NmGetInterfaceForNodeAndNetwork(
               lpszNodeName,
               lpszNetworkName,
               lppszInterfaceName
               ));
}


error_status_t
s_ApiGetNetInterfaceId(
    IN HNETINTERFACE_RPC hNetInterface,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a network interface.

Arguments:

    hNetInterface - Supplies the network interface whose identifer is to be
                    returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PNM_INTERFACE NetInterface;
    DWORD NameLen;
    LPCWSTR Name;


    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    Name = OmObjectId(NetInterface);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);

    *pGuid = MIDL_user_allocate(NameLen);

    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    CopyMemory(*pGuid, Name, NameLen);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\group.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    group.c

Abstract:

    Server side support for Cluster APIs dealing with groups

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HGROUP_RPC
s_ApiOpenGroup(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszGroupName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing group object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszGroupName - Supplies the name of the group to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a group object if successful

    NULL otherwise.

--*/

{
    PAPI_HANDLE Handle;
    HGROUP_RPC Group;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }
    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    Group = OmReferenceObjectByName(ObjectTypeGroup, lpszGroupName);
    if (Group == NULL) {
        LocalFree(Handle);
        *Status = ERROR_GROUP_NOT_FOUND;
        return(NULL);
    }

    Handle->Type = API_GROUP_HANDLE;
    Handle->Flags = 0;
    Handle->Group = Group;
    InitializeListHead(&Handle->NotifyList);
    *Status = ERROR_SUCCESS;
    return(Handle);
}

HGROUP_RPC
s_ApiCreateGroup(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszGroupName,
    OUT error_status_t *pStatus
    )

/*++

Routine Description:

    Creates a new group object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszGroupName - Supplies the name of the group to create.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a group object if successful

    NULL otherwise.

--*/

{
    HGROUP_RPC Group=NULL;
    UUID Guid;
    DWORD Status = ERROR_SUCCESS;
    WCHAR *KeyName=NULL;
    PAPI_HANDLE Handle;
    DWORD dwDisposition;
    HDMKEY hKey = NULL;

    if (ApiState != ApiStateOnline) {
        *pStatus = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }
retry:
    //
    //
    // Create a GUID for this group.
    //
    Status = UuidCreate(&Guid);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }
    Status = UuidToString(&Guid, &KeyName);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }

    //
    // Create this group in the FM. This will also trigger the notification.
    //
    Group = FmCreateGroup(KeyName, lpszGroupName);

    if (Group == NULL) {
        Status = GetLastError();
        if (Status == ERROR_ALREADY_EXISTS) {
            RpcStringFree(&KeyName);
            goto retry;
        }
    }

error_exit:   
    if (KeyName != NULL) {
        RpcStringFree(&KeyName);
    }
    
    *pStatus = Status;
    
    if (Status == ERROR_SUCCESS) {
        CL_ASSERT(Group != NULL);
        Handle->Type = API_GROUP_HANDLE;
        Handle->Group = Group;
        Handle->Flags = 0;
        InitializeListHead(&Handle->NotifyList);
        return(Handle);
    } else {
        LocalFree(Handle);
        return(NULL);
    }
}


error_status_t
s_ApiDeleteGroup(
    IN HGROUP_RPC hGroup
    )
/*++

Routine Description:

    Deletes a cluster group. The group must contain no resources.

Arguments:

    hGroup - Supplies the group to delete.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PFM_GROUP Group;
    HDMKEY Key;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    Status = FmDeleteGroup(Group);
    if (Status == ERROR_SUCCESS) {
        DmDeleteTree(DmGroupsKey,OmObjectId(Group));
    }
    return(Status);
}


error_status_t
s_ApiCloseGroup(
    IN OUT HGROUP_RPC *phGroup
    )

/*++

Routine Description:

    Closes an open group context handle.

Arguments:

    Group - Supplies a pointer to the HGROUP_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PFM_GROUP Group;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_GROUP(Group, *phGroup);

    Handle = (PAPI_HANDLE)*phGroup;
    ApipRundownNotify(Handle);

    OmDereferenceObject(Group);

    LocalFree(Handle);
    *phGroup = NULL;

    return(ERROR_SUCCESS);
}


VOID
HGROUP_RPC_rundown(
    IN HGROUP_RPC Group
    )

/*++

Routine Description:

    RPC rundown procedure for a HGROUP_RPC. Just closes the handle.

Arguments:

    Group - Supplies the HGROUP_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    API_ASSERT_INIT();

    s_ApiCloseGroup(&Group);
}


error_status_t
s_ApiGetGroupState(
    IN HGROUP_RPC hGroup,
    OUT DWORD *lpState,
    OUT LPWSTR *lpNodeName
    )

/*++

Routine Description:

    Returns the current state of the specified group.

Arguments:

    hGroup - Supplies the group whose state is to be returned.

    lpState - Returns the current state of the group

    lpNodeName - Returns the name of the node where the group is currently online

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    LPWSTR NodeName;
    DWORD NameLength;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);
    NameLength = MAX_COMPUTERNAME_LENGTH+1;
    NodeName = MIDL_user_allocate(NameLength*sizeof(WCHAR));
    if (NodeName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    *lpState = FmGetGroupState( Group,
                                NodeName,
                                &NameLength);
    if ( *lpState ==  ClusterGroupStateUnknown ) {
        MIDL_user_free(NodeName);
        return(GetLastError());
    }
    *lpNodeName = NodeName;

    return( ERROR_SUCCESS );
}


error_status_t
s_ApiSetGroupName(
    IN HGROUP_RPC hGroup,
    IN LPCWSTR lpszGroupName
    )
/*++

Routine Description:

    Sets the new friendly name of a group.

Arguments:

    hGroup - Supplies the group whose name is to be set.

    lpszGroupName - Supplies the new name of hGroup

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    HDMKEY GroupKey;
    DWORD Status;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    //
    // Tell the FM about the new name. If it is OK with the
    // FM, go ahead and update the registry.
    //
    Status = FmSetGroupName(Group,
                            lpszGroupName);
    if (Status == ERROR_SUCCESS) {
        GroupKey = DmOpenKey(DmGroupsKey,
                             OmObjectId(Group),
                             KEY_SET_VALUE);
        if (GroupKey == NULL) {
            return(GetLastError());
        }

        Status = DmSetValue(GroupKey,
                            CLUSREG_NAME_GRP_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszGroupName,
                            (lstrlenW(lpszGroupName)+1)*sizeof(WCHAR));
        DmCloseKey(GroupKey);
    }

    return(Status);
}


error_status_t
s_ApiGetGroupId(
    IN HGROUP_RPC hGroup,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a group.

Arguments:

    hGroup - Supplies the group whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_GROUP Group;
    DWORD IdLen;
    LPCWSTR Id;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    Id = OmObjectId(Group);

    IdLen = (lstrlenW(Id)+1)*sizeof(WCHAR);
    *pGuid = MIDL_user_allocate(IdLen);
    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*pGuid, Id, IdLen);
    return(ERROR_SUCCESS);
}


DWORD
s_ApiOnlineGroup(
    IN HGROUP_RPC hGroup
    )

/*++

Routine Description:

    Brings a group and all its dependencies online

Arguments:

    hGroup - Supplies the group to be brought online

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmOnlineGroup(Group));

}


DWORD
s_ApiOfflineGroup(
    IN HGROUP_RPC hGroup
    )

/*++

Routine Description:

    Brings a group and all its dependents offline

Arguments:

    hGroup - Supplies the group to be brought offline

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmOfflineGroup(Group));

}



DWORD
s_ApiMoveGroup(
    IN HGROUP_RPC hGroup
    )

/*++

Routine Description:

    Moves a group and all its dependents to another system.

Arguments:

    hGroup - Supplies the group to be moved

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmMoveGroup(Group, NULL));

}


DWORD
s_ApiMoveGroupToNode(
    IN HGROUP_RPC hGroup,
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Moves a group and all its dependents to another system.

Arguments:

    hGroup - Supplies the group to be moved

    hNode - Supplies the node to move the group to

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);
    VALIDATE_NODE(Node, hNode);

    return(FmMoveGroup(Group, Node));

}



error_status_t
s_ApiSetGroupNodeList(
    IN HGROUP_RPC hGroup,
    IN UCHAR *lpNodeList,
    IN DWORD cbListSize
    )
/*++

Routine Description:

    Sets the list of preferred nodes for a group.

Arguments:

    hGroup - Supplies the group to set the preferred nodes.

    lpNodeList - Supplies the list of preferred owners, as a REG_MULTI_SZ.

    cbListSize - Supplies the size in bytes of the preferred owners list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    HDMKEY GroupKey;
    DWORD Status;
    DWORD i;
    DWORD multiSzLength;
    LPWSTR multiSz;
    LPWSTR tmpSz;
    //LPCWSTR lpszNodeList = (LPCWSTR)lpNodeList;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

#if 0
    //
    // Marshall the node list into a MULTI_SZ.
    //
    for ( i = 0; i < dwNodeCount; i++ ) {
        multiSzLength += lstrlenW(rgszNodeList[i] + 1);
    }

    multiSzLength += sizeof(UNICODE_NULL);

    multiSz = MIDL_user_allocate(multiSzLength);

    if ( multiSz == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    tmpSz = multiSz;

    for ( i = 0; i < dwNodeCount; i++ ) {
        lstrcpynW( tmpSz, rgszNodeList[i], lstrlenW(rgszNodeList[i] + 1) );
    }

    *tmpSz = UNICODE_NULL;
#endif

    //
    // Set the registry with the REG_MULTI_SZ. Let the FM pick it up from
    // there.
    //
    GroupKey = DmOpenKey(DmGroupsKey,
                         OmObjectId(Group),
                         KEY_SET_VALUE);
    if (GroupKey == NULL) {
        return(GetLastError());
    }

    Status = DmSetValue(GroupKey,
                        CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                        REG_MULTI_SZ,
                        (CONST BYTE *)lpNodeList,
                        cbListSize);

    DmCloseKey(GroupKey);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\node.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    node.c

Abstract:

    Public interfaces for managing the nodes of a cluster

Author:

    John Vert (jvert) 11-Jan-1996

Revision History:

--*/
#include "apip.h"


HNODE_RPC
s_ApiOpenNode(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNodeName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing node object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the node to open.

    Status - Returns any error

Return Value:

    A context handle to a node object if successful

    NULL otherwise.

--*/

{
    HNODE_RPC Node;
    PAPI_HANDLE Handle;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }
    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    Node = OmReferenceObjectByName(ObjectTypeNode, lpszNodeName);
    if (Node != NULL) {
        *Status = ERROR_SUCCESS;
    } else {
        *Status = ERROR_CLUSTER_NODE_NOT_FOUND;
        LocalFree(Handle);
        return(NULL);
    }
    Handle->Type = API_NODE_HANDLE;
    Handle->Node = Node;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);
}


error_status_t
s_ApiGetNodeId(
    IN HNODE_RPC hNode,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier for a node.

Arguments:

    hNode - Supplies the node whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PNM_NODE Node;
    DWORD IdLen;
    LPCWSTR Id;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Id = OmObjectId(Node);
    CL_ASSERT(Id != NULL);

    IdLen = (lstrlenW(Id)+1)*sizeof(WCHAR);
    *pGuid = MIDL_user_allocate(IdLen);
    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*pGuid, Id, IdLen);
    return(ERROR_SUCCESS);
}


error_status_t
s_ApiCloseNode(
    IN OUT HNODE_RPC *phNode
    )

/*++

Routine Description:

    Closes an open node context handle.

Arguments:

    Node - Supplies a pointer to the HNODE_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PNM_NODE Node;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, *phNode);

    Handle = (PAPI_HANDLE)*phNode;
    ApipRundownNotify(Handle);

    OmDereferenceObject(Node);
    LocalFree(*phNode);
    *phNode = NULL;

    return(ERROR_SUCCESS);
}



VOID
HNODE_RPC_rundown(
    IN HNODE_RPC Node
    )

/*++

Routine Description:

    RPC rundown procedure for a HNODE_RPC. Just closes the handle.

Arguments:

    Node - supplies the HNODE_RPC that is to be rundown.

Return Value:

    None.

--*/

{

    s_ApiCloseNode(&Node);

}


error_status_t
s_ApiGetNodeState(
    IN HNODE_RPC hNode,
    OUT DWORD *lpState
    )

/*++

Routine Description:

    Returns the current state of the specified node.

Arguments:

    hNode - Supplies the node whose state is to be returned.

    lpState - Returns the current state of the node

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

//    *lpState = NmGetNodeState( Node );
    *lpState = NmGetExtendedNodeState( Node );
    return( ERROR_SUCCESS );
}


error_status_t
s_ApiPauseNode(
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Pauses a node in the cluster

Arguments:

    hNode - Supplies the node to be paused.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Status = NmPauseNode( Node );
    return( Status );

}


error_status_t
s_ApiResumeNode(
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Resumes a node in the cluster

Arguments:

    hNode - Supplies the node to be resumed.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Status = NmResumeNode( Node );
    return( Status );

}


error_status_t
s_ApiEvictNode(
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Pauses a node in the cluster

Arguments:

    hNode - Supplies the node to be evicted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Status = NmEvictNode( Node );
    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\resource.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Server side support for Cluster APIs dealing with resources

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HRES_RPC
s_ApiOpenResource(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszResourceName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing resource object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszResourceName - Supplies the name of the resource to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a resource object if successful

    NULL otherwise.

--*/

{
    HRES_RPC Resource;
    PAPI_HANDLE Handle;

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }
    Resource = OmReferenceObjectByName(ObjectTypeResource, lpszResourceName);
    if (Resource == NULL) {
        LocalFree(Handle);
        *Status = ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_NOISE,
                      "[API] s_ApiOpenResource: Resource %1!ws! not found, status = %2!u!...\n",
                      lpszResourceName,
                      *Status);
        return(NULL);
    }
    *Status = ERROR_SUCCESS;
    Handle->Type = API_RESOURCE_HANDLE;
    Handle->Resource = Resource;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);
}

HRES_RPC
s_ApiCreateResource(
    IN HGROUP_RPC hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags,
    OUT error_status_t *pStatus
    )

/*++

Routine Description:

    Creates a new resource object.

Arguments:

    hGroup - Supplies the group the resource is to be created in.

    lpszResourceName - Supplies the name of the resource to create.

    lpszResourceType - Supplies the type of the resource.

    dwFlags - Supplies any optional flags.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a resource object if successful

    NULL otherwise.

--*/

{
    HRES_RPC Resource=NULL;
    PFM_GROUP Group;
    UUID Guid;
    DWORD Status = ERROR_SUCCESS;
    WCHAR *KeyName=NULL;
    HDMKEY Key=NULL;
    HDMKEY GroupKey=NULL;
    HDMKEY TypeKey = NULL;
    HDMKEY ParamKey;
    DWORD Disposition;
    DWORD pollIntervals = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
    PAPI_HANDLE Handle;
    PFM_RESTYPE ResType;
    DWORD dwPersistentState = 0;
    DWORD dwClusterHighestVersion;

    if (ApiState != ApiStateOnline) 
    {
        *pStatus = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    if (((PAPI_HANDLE)hGroup)->Type != API_GROUP_HANDLE) 
    {
        *pStatus = ERROR_INVALID_HANDLE;
        return(NULL);
    }
    Group = ((PAPI_HANDLE)hGroup)->Group;


    //
    // Check for bogus flags.
    //
    if (dwFlags & ~CLUSTER_RESOURCE_VALID_FLAGS) 
    {
        *pStatus = ERROR_INVALID_PARAMETER;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) 
    {
        *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    //
    //  Chittur Subbaraman (chitturs) - 1/30/2000
    //
    //  If we are dealing with the mixed mode cluster, do the
    //  registry updates right here since the GUM handler won't do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    //
    // Open the resource type key. This validates that the specified type exists.
    //
    TypeKey = DmOpenKey(DmResourceTypesKey,
                        lpszResourceType,
                        KEY_READ);
    if (TypeKey == NULL) 
    {
        Status = GetLastError();
        goto error_exit;
    }

retry:
    //
    // Create a GUID for this resource.
    //
    Status = UuidCreate(&Guid);

    if (Status != RPC_S_OK) 
    {
        goto error_exit;
    }
    Status = UuidToString(&Guid, &KeyName);
    if (Status != RPC_S_OK) 
    {
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[API] Creating resource %1!ws! <%2!ws!> (%3!ws!)\n",
                  lpszResourceType,
                  lpszResourceName,
                  KeyName);

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {   
        //
        // Create the new resource key.
        //
        Key = DmCreateKey(DmResourcesKey,
                          KeyName,
                          0,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &Disposition);
        if (Key == NULL) 
        {
            Status = GetLastError();
            goto error_exit;
        }
        if (Disposition != REG_CREATED_NEW_KEY) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[API] ApiCreateResource generated GUID %1!ws! that already existed! This is impossible.\n",
                          KeyName);
            DmCloseKey(Key);
            RpcStringFree(&KeyName);
            goto retry;
        }
        
        CL_ASSERT(Disposition == REG_CREATED_NEW_KEY);

        //
        // Set the resource's name in the registry
        //
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszResourceName,
                            (lstrlenW(lpszResourceName)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }

        //
        // Set the resource's type in the registry
        // Note we reference the resource type and use its ID
        // so that the case is correct.
        //
        ResType = OmReferenceObjectById(ObjectTypeResType, lpszResourceType);
        CL_ASSERT(ResType != NULL);
        lpszResourceType = OmObjectId(ResType);
        OmDereferenceObject(ResType);
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_TYPE,
                            REG_SZ,
                            (CONST BYTE *)lpszResourceType,
                            (lstrlenW(lpszResourceType)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }

        //
        // Set the resource's poll intervals in the registry.
        //
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_LOOKS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&pollIntervals,
                            4);
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_IS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&pollIntervals,
                            4);
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }

        //
        // If this resource should be started in a separate monitor, set that
        // parameter now.
        //
        if (dwFlags & CLUSTER_RESOURCE_SEPARATE_MONITOR) 
        {
            DWORD SeparateMonitor = 1;

            Status = DmSetValue(Key,
                                CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                REG_DWORD,
                                (CONST BYTE *)&SeparateMonitor,
                                sizeof(SeparateMonitor));
            if (Status != ERROR_SUCCESS) 
            {
                goto error_exit;
            }
        }

        //
        // Create a Parameters key for the resource.
        //
        ParamKey = DmCreateKey(Key,
                               CLUSREG_KEYNAME_PARAMETERS,                   
                               0,
                               KEY_READ,
                               NULL,
                               &Disposition);
        if (ParamKey == NULL) 
        {
            CL_LOGFAILURE(GetLastError());
        } else 
        {
            DmCloseKey(ParamKey);
        }

        GroupKey = DmOpenKey(DmGroupsKey, OmObjectId(Group), KEY_READ | KEY_WRITE);
        if (GroupKey == NULL) 
        {
            Status = GetLastError();
            goto error_exit;
        }

        //
        //  Chittur Subbaraman (chitturs) - 5/25/99
        //
        //  Make sure you set the persistent state of the resource to 
        //  ClusterResourceOffline before you create the resource. If
        //  this is not done, if you create a resource in a group which
        //  is online, the group's persistent state value (i.e., 1 in
        //  this case) is inherited by the resource in FmpQueryResourceInfo
        //  (only the memory state is set and not the registry state and
        //  this was a problem as well) and if you move such a group to 
        //  another node, it will bring the newly created resource online.
        //
        Status = DmSetValue( Key,
                             CLUSREG_NAME_RES_PERSISTENT_STATE,
                             REG_DWORD,
                             ( CONST BYTE * )&dwPersistentState,
                             sizeof( DWORD ) );
                         
        if ( Status != ERROR_SUCCESS ) 
        {
            goto error_exit;
        }
    }
    
    Resource = FmCreateResource(Group, KeyName, lpszResourceName, lpszResourceType, dwFlags);

    if (Resource == NULL) 
    {
        Status = GetLastError();
        if (Status == ERROR_ALREADY_EXISTS) 
        {
            RpcStringFree(&KeyName);
            goto retry;
        }
        goto error_exit;
    }

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        //
        // Add the resource to the Contains value of the specified group.
        //      
        Status = DmAppendToMultiSz(GroupKey,
                                   CLUSREG_NAME_GRP_CONTAINS,
                                   KeyName);
        if (Status != ERROR_SUCCESS) 
        {
            //
            // BUGBUG John Vert (jvert) 3-May-1996
            //      Need to delete this from the FM!
            //
            OmDereferenceObject(Resource);
            Resource = NULL;
        }
    }
    
error_exit:
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        if (Key != NULL) 
        {
            if (Status != ERROR_SUCCESS) 
            {
                //
                // Try and cleanup the key we just created.
                //
                DmDeleteKey(Key, CLUSREG_KEYNAME_PARAMETERS);
                DmDeleteKey(DmResourcesKey, KeyName);
            }
            DmCloseKey(Key);
        }
        if (GroupKey != NULL) 
        {
            DmCloseKey(GroupKey);
        }
    }

    if (TypeKey != NULL) 
    {
        DmCloseKey(TypeKey);
    }

    if (KeyName != NULL) 
    {
        RpcStringFree(&KeyName);
    }

    *pStatus = Status;
    if (Status != ERROR_SUCCESS) 
    {
        LocalFree(Handle);
        return(NULL);
    }

    CL_ASSERT(Resource != NULL);
    Handle->Type = API_RESOURCE_HANDLE;
    Handle->Resource = Resource;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);
}


error_status_t
s_ApiDeleteResource(
    IN HRES_RPC hResource
    )
/*++

Routine Description:

    Deletes the specified cluster resource from the group. The resource
    must have no other resources dependent on it.

Arguments:

    hResource - Supplies the cluster resource to be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PFM_RESOURCE Resource;
    DWORD Status;
    HDMKEY Key;
    HDMKEY GroupKey;
    DWORD  dwClusterHighestVersion; 

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    //  Chittur Subbaraman (chitturs) - 09/07/2000
    //
    //  If we are dealing with a Whistler-Win2K cluster, do the
    //  registry updates right here since the GUM handler won't do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    Status = FmDeleteResource(Resource);

    if ( ( Status == ERROR_SUCCESS ) && 
         ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) ) {
        Status = DmDeleteTree(DmResourcesKey,OmObjectId(Resource));
        if ( (Status != ERROR_SUCCESS) &&
             (Status != ERROR_FILE_NOT_FOUND) ) {
            CL_LOGFAILURE( Status );
            return(Status);
        }
        GroupKey = DmOpenKey(DmGroupsKey,
                             OmObjectId(Resource->Group),
                             KEY_READ | KEY_SET_VALUE);
        if (GroupKey != NULL) {
            DmRemoveFromMultiSz(GroupKey,
                                CLUSREG_NAME_GRP_CONTAINS,
                                OmObjectId(Resource));
            DmCloseKey(GroupKey);
        }
    }
    return(Status);
}


error_status_t
s_ApiCloseResource(
    IN OUT HRES_RPC *phResource
    )

/*++

Routine Description:

    Closes an open resource context handle.

Arguments:

    Resource - Supplies a pointer to the HRES_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PFM_RESOURCE Resource;
    PAPI_HANDLE Handle;

    VALIDATE_RESOURCE(Resource, *phResource);

    Handle = (PAPI_HANDLE)*phResource;
    ApipRundownNotify(Handle);
    OmDereferenceObject(Resource);

    LocalFree(*phResource);
    *phResource = NULL;

    return(ERROR_SUCCESS);
}


VOID
HRES_RPC_rundown(
    IN HRES_RPC Resource
    )

/*++

Routine Description:

    RPC rundown procedure for a HRES_RPC. Just closes the handle.

Arguments:

    Resource - Supplies the HRES_RPC that is to be rundown.

Return Value:

    None.

--*/

{

    s_ApiCloseResource(&Resource);
}


error_status_t
s_ApiGetResourceState(
    IN HRES_RPC hResource,
    OUT DWORD *lpState,
    OUT LPWSTR *lpNodeId,
    OUT LPWSTR *lpGroupName
    )

/*++

Routine Description:

    Returns the current state of the specified resource.

Arguments:

    hResource - Supplies the resource whose state is to be returned.

    lpState - Returns the current state of the resource

    lpNodeId - Returns the Id of the node where the resource is currently online

    lpGroupName - Returns the name of the group the the resource is a member of

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    LPWSTR NodeId;
    DWORD IdLength;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    IdLength = MAX_COMPUTERNAME_LENGTH+1;
    NodeId = MIDL_user_allocate(IdLength*sizeof(WCHAR));
    if (NodeId == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    *lpState = FmGetResourceState( Resource,
                                   NodeId,
                                   &IdLength);
    if ( *lpState == ClusterResourceStateUnknown ) {
        MIDL_user_free(NodeId);
        return(GetLastError());
    }
    *lpNodeId = NodeId;
    *lpGroupName = ApipGetObjectName(Resource->Group);

    return(ERROR_SUCCESS);
}


error_status_t
s_ApiSetResourceName(
    IN HRES_RPC hResource,
    IN LPCWSTR lpszResourceName
    )
/*++

Routine Description:

    Sets the new friendly name of a resource.

Arguments:

    hResource - Supplies the resource whose name is to be set.

    lpszResourceName - Supplies the new name of hResource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    DWORD Status;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Tell the FM about the new name. If it is OK with the
    // FM, go ahead and update the registry.
    //
    Status = FmSetResourceName(Resource,
                               lpszResourceName);


    return(Status);
}



error_status_t
s_ApiGetResourceId(
    IN HRES_RPC hResource,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a resource.

Arguments:

    hResource - Supplies the resource whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    DWORD NameLen;
    LPCWSTR Name;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    Name = OmObjectId(Resource);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);
    *pGuid = MIDL_user_allocate(NameLen);
    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*pGuid, Name, NameLen);
    return(ERROR_SUCCESS);
}


error_status_t
s_ApiGetResourceType(
    IN HRES_RPC hResource,
    OUT LPWSTR *lpszResourceType
    )

/*++

Routine Description:

    Returns the resource type for a resource.

Arguments:

    hResource - Supplies the resource whose identifer is to be returned

    lpszResourceType - Returns the resource type name. This memory must be
            freed on the client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    DWORD NameLen;
    LPCWSTR Name;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    if ( Resource->Type == NULL ) {
        return(ERROR_INVALID_STATE);
    }

    Name = OmObjectId(Resource->Type);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);
    *lpszResourceType = MIDL_user_allocate(NameLen);
    if (*lpszResourceType == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*lpszResourceType, Name, NameLen);
    return(ERROR_SUCCESS);
}


DWORD
s_ApiOnlineResource(
    IN HRES_RPC hResource
    )

/*++

Routine Description:

    Brings a resource and all its dependencies online

Arguments:

    hResource - Supplies the resource to be brought online

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE(Resource, hResource);

    return(FmOnlineResource(Resource));

}


DWORD
s_ApiFailResource(
    IN HRES_RPC hResource
    )

/*++

Routine Description:

    Initiates a resource failure. The specified resource is treated as failed.
    This causes the cluster to initiate the same failover process that would
    result if the resource actually failed.

Arguments:

    hResource - Supplies the resource to be failed over

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    return(FmFailResource(Resource));

}


DWORD
s_ApiOfflineResource(
    IN HRES_RPC hResource
    )

/*++

Routine Description:

    Brings a resource and all its dependents offline

Arguments:

    hResource - Supplies the resource to be brought offline

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    return(FmOfflineResource(Resource));

}


error_status_t
s_ApiAddResourceDependency(
    IN HRES_RPC hResource,
    IN HRES_RPC hDependsOn
    )
/*++

Routine Description:

    Adds a dependency relationship to a given resource. Both
    resources must be in the same group.

Arguments:

    hResource - Supplies the resource which is dependent.

    hDependsOn - Supplies the resource that hResource depends on.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    DWORD Status;
    HDMKEY ResKey;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_RESOURCE_EXISTS(DependsOn, hDependsOn);

    //
    // Call the FM to create the dependency relationship.
    //
    Status = FmAddResourceDependency(Resource, DependsOn);
    if (Status == ERROR_SUCCESS) {
        //
        // Add the dependency information to the cluster database.
        //
        ResKey = DmOpenKey(DmResourcesKey,
                           OmObjectId(Resource),
                           KEY_READ | KEY_SET_VALUE);
        if (ResKey == NULL) {
            Status = GetLastError();
            CL_LOGFAILURE(Status);
        } else {
            Status = DmAppendToMultiSz(ResKey,
                                       CLUSREG_NAME_RES_DEPENDS_ON,
                                       OmObjectId(DependsOn));
            DmCloseKey(ResKey);
        }
        if (Status != ERROR_SUCCESS) {
            FmRemoveResourceDependency(Resource, DependsOn);
        }
    }
    return(Status);
}


error_status_t
s_ApiRemoveResourceDependency(
    IN HRES_RPC hResource,
    IN HRES_RPC hDependsOn
    )
/*++

Routine Description:

    Removes a dependency relationship to a given resource. Both
    resources must be in the same group.

Arguments:

    hResource - Supplies the resource which is dependent.

    hDependsOn - Supplies the resource that hResource depends on.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    DWORD Status;
    HDMKEY ResKey;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_RESOURCE_EXISTS(DependsOn, hDependsOn);

    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((Resource->Group != DependsOn->Group) ||
        (Resource == DependsOn)) {
        return(ERROR_DEPENDENCY_NOT_FOUND);
    }

    //
    // Remove the dependency from the registry database.
    //
    ResKey = DmOpenKey(DmResourcesKey,
                       OmObjectId(Resource),
                       KEY_READ | KEY_SET_VALUE);
    if (ResKey == NULL) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
    } else {
        Status = DmRemoveFromMultiSz(ResKey,
                                     CLUSREG_NAME_RES_DEPENDS_ON,
                                     OmObjectId(DependsOn));
        DmCloseKey(ResKey);
    }

    if (Status == ERROR_SUCCESS) {

        //
        // Call the FM to remove the dependency relationship.
        //
        Status = FmRemoveResourceDependency(Resource, DependsOn);

    } else if (Status == ERROR_FILE_NOT_FOUND) {

        //
        // Map this expected error to something a little more reasonable.
        //
        Status = ERROR_DEPENDENCY_NOT_FOUND;
    }

    return(Status);
}


error_status_t
s_ApiCanResourceBeDependent(
    IN HRES_RPC hResource,
    IN HRES_RPC hResourceDependent
    )
/*++

Routine Description:

    Determines if the resource identified by hResource can depend on hResourceDependent.
    In order for this to be true, both resources must be members of the same group and
    the resource identified by hResourceDependent cannot depend on the resource identified
    by hResource, whether directly or indirectly.

Arguments:

    hResource - Supplies a handle to the resource to be dependent.

    hResourceDependent - Supplies a handle to the resource on which
        the resource identified by hResource can depend.


Return Value:

    If the resource identified by hResource can depend  on the resource
        identified by hResourceDependent, the return value is ERROR_SUCCESS.

    Otherwise, the return value is ERROR_DEPENDENCY_ALREADY_EXISTS.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE ResourceDependent;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_RESOURCE_EXISTS(ResourceDependent, hResourceDependent);

    if (Resource == ResourceDependent) {
        //
        // The caller is confused and is trying to make something
        // depend on itself.
        //
        return(ERROR_DEPENDENCY_ALREADY_EXISTS);
    }

    if (Resource->Group != ResourceDependent->Group) {
        //
        // The caller is confused and is trying to make something
        // depend on a resource in another group.
        //
        return(ERROR_DEPENDENCY_ALREADY_EXISTS);
    }

    if (FmDependentResource(ResourceDependent, Resource, FALSE)) {
        return(ERROR_DEPENDENCY_ALREADY_EXISTS);
    } else {

        //
        // Finally check to make sure an immediate dependency does
        // not already exist.
        //
        if (FmDependentResource(Resource, ResourceDependent, TRUE)) {
            return(ERROR_DEPENDENCY_ALREADY_EXISTS);
        } else {
            return(ERROR_SUCCESS);
        }
    }

}


error_status_t
s_ApiCreateResEnum(
    IN HRES_RPC hResource,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )
/*++

Routine Description:

    Enumerates all the specified resource properties and returns the
    list of objects to the caller. The client-side is responsible
    for freeing the allocated memory.

Arguments:

    hResource - Supplies the resource whose properties are to be
                enumerated.

    dwType - Supplies the type of properties to be enumerated.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PENUM_LIST NewEnum = NULL;
    DWORD i;
    DWORD Result;
    PFM_RESOURCE Resource;
    PFM_RESOURCE Target;
    PNM_NODE Node;
    LPWSTR RealName;

    if (dwType & ~CLUSTER_RESOURCE_ENUM_ALL) {
        return(ERROR_INVALID_PARAMETER);
    }

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    Enum->EntryCount = 0;

    //
    // Enumerate all dependencies.
    //
    if (dwType & CLUSTER_RESOURCE_ENUM_DEPENDS) {
        i=0;
        do {
            Result = FmEnumResourceDependent(Resource,
                                             i,
                                             &Target);
            if (Result == ERROR_SUCCESS) {
                RealName = ApipGetObjectName( Target );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_ENUM_DEPENDS);
                    MIDL_user_free(RealName);                                  
                }
                OmDereferenceObject(Target);
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );

    }

    //
    // Enumerate all dependents
    //
    if (dwType & CLUSTER_RESOURCE_ENUM_PROVIDES) {
        i=0;
        do {
            Result = FmEnumResourceProvider(Resource,
                                            i,
                                            &Target);
            if (Result == ERROR_SUCCESS) {
                RealName = ApipGetObjectName( Target );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_ENUM_PROVIDES);
                    MIDL_user_free(RealName);                                  
                }
                OmDereferenceObject(Target);
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    //
    // Enumerate all possible nodes
    //
    if (dwType & CLUSTER_RESOURCE_ENUM_NODES) {
        i=0;
        do {
            Result = FmEnumResourceNode(Resource,
                                        i,
                                        &Node);
            if (Result == ERROR_SUCCESS) {
                RealName = (LPWSTR)OmObjectName( Node );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_ENUM_NODES);
                }
                OmDereferenceObject(Node);
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    *ReturnEnum = Enum;
    return(ERROR_SUCCESS);

ErrorExit:

    if (Enum != NULL) {
        MIDL_user_free(Enum);
    }
    if (NewEnum != NULL) {
        MIDL_user_free(NewEnum);
    }

    *ReturnEnum = NULL;
    return(Status);
}


error_status_t
s_ApiAddResourceNode(
    IN HRES_RPC hResource,
    IN HNODE_RPC hNode
    )
/*++

Routine Description:

    Adds a node to the list of nodes where the specified resource
    can be brought online.

Arguments:

    hResource - Supplies the resource whose list of possible nodes is
        to be modified.

    hNode - Supplies the node to be added to the resource's list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    PNM_NODE Node;
    DWORD Status;
    DWORD dwUserModified;
    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Call the FM to do the real work.
    //
    Status = FmChangeResourceNode(Resource, Node, TRUE);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //write out the fact that the user has explicitly set the 
    //resource possible node list
    //
    dwUserModified = 1;

    ClRtlLogPrint(LOG_NOISE,
                  "[API] s_ApiAddResourceNode: Setting UserModifiedPossibleNodeList key for resource %1!ws! \r\n",
                  OmObjectId(Resource));
                         
    DmSetValue( Resource->RegistryKey,
                     CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST,
                     REG_DWORD,
                     (LPBYTE)&dwUserModified,
                     sizeof(DWORD));

    return(Status);
}


error_status_t
s_ApiRemoveResourceNode(
    IN HRES_RPC hResource,
    IN HNODE_RPC hNode
    )
/*++

Routine Description:

    Removes a node from the list of nodes that can host the
    specified resource. The resource must not be currently
    online on the specified node.

Arguments:

    hResource - Supplies the resource whose list of possible nodes is
        to be modified.

    hNode - Supplies the node to be removed from the resource's list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    PNM_NODE Node;
    DWORD Status;
    DWORD dwUserModified;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Call the FM to do the real work.
    //
    Status = FmChangeResourceNode(Resource, Node, FALSE);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //write out the fact that the user has explicitly set the 
    //resource possible node list
    //
    dwUserModified = 1;
    ClRtlLogPrint(LOG_NOISE,
                  "[API] s_ApiRemoveResourceNode: Setting UserModifiedPossibleNodeList key for resource %1!ws! \r\n",
                  OmObjectId(Resource));

    DmSetValue( Resource->RegistryKey,
                     CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST,
                     REG_DWORD,
                     (LPBYTE)&dwUserModified,
                     sizeof(DWORD));

    //SS: moved the write to the registry settings to the fm
    // layer as well, this way it is truly transactional
    
    return(Status);
}


error_status_t
s_ApiCreateResourceType(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    )
/*++

Routine Description:

    Creates a new resource type in the cluster.  Note that this API only
    defines the resource type in the cluster registry and registers the
    resource type with the cluster service.  The calling program is
    responsible for installing the resource type DLL on each node in the
    cluster.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszResourceTypeName - Supplies the new resource types name. The
        specified name must be unique within the cluster.

    lpszDisplayName - Supplies the display name for the new resource
        type. While lpszResourceTypeName should uniquely identify the
        resource type on all clusters, the lpszDisplayName should be
        a localized friendly name for the resource, suitable for displaying
        to administrators

    lpszResourceTypeDll - Supplies the name of the new resource types DLL.

    dwLooksAlive - Supplies the default LooksAlive poll interval
        for the new resource type in milliseconds.

    dwIsAlive - Supplies the default IsAlive poll interval for
        the new resource type in milliseconds.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    HDMKEY TypeKey = NULL;
    DWORD Disposition;
    DWORD dwClusterHighestVersion;

    //
    //  Chittur Subbaraman (chitturs) - 2/8/2000
    //
    //  If we are dealing with the mixed mode cluster, do the
    //  registry updates right here since the GUM handler won't do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) {   
        //
        // Add the resource information to the registry. If the key does not already
        // exist, then the name is unique and we can go ahead and call the FM to
        // create the actual resource type object.
        //
        TypeKey = DmCreateKey(DmResourceTypesKey,
                              lpszTypeName,
                              0,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &Disposition);
        if (TypeKey == NULL) {
            return(GetLastError());
        }
        if (Disposition != REG_CREATED_NEW_KEY) {
            DmCloseKey(TypeKey);
            return(ERROR_ALREADY_EXISTS);
        }

        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_DLL_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszDllName,
                            (lstrlenW(lpszDllName)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_IS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&dwIsAlive,
                            sizeof(dwIsAlive));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&dwLooksAlive,
                            sizeof(dwIsAlive));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszDisplayName,
                            (lstrlenW(lpszDisplayName)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    Status = FmCreateResourceType(lpszTypeName,
                                  lpszDisplayName,
                                  lpszDllName,
                                  dwLooksAlive,
                                  dwIsAlive);
    if (Status != ERROR_SUCCESS) {
        goto error_exit;
    }

    if (TypeKey != NULL) {
        DmCloseKey(TypeKey);
    }
    return(ERROR_SUCCESS);

error_exit:
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) {   
        DmCloseKey(TypeKey);
        DmDeleteKey(DmResourceTypesKey, lpszTypeName);
    }
    return(Status);
}


error_status_t
s_ApiDeleteResourceType(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszTypeName
    )
/*++

Routine Description:

    Deletes a resource type in the cluster.  Note that this API only
    deletes the resource type in the cluster registry and unregisters the
    resource type with the cluster service.  The calling program is
    responsible for deleting the resource type DLL on each node in the
    cluster.  If any resources of the specified type exist, this API
    fails.  The calling program is responsible for deleting any resources
    of this type before deleting the resource type.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszResourceTypeName - Supplies the name of the resource type to
        be deleted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    //
    // Delete the resource from the FM. This will check to make sure no
    // resources of the specified type exist and check that the resource
    // is already installed.
    //
    Status = FmDeleteResourceType(lpszTypeName);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Now remove the resource type from the registry.
    //
    DmDeleteTree(DmResourceTypesKey, lpszTypeName);

    return(ERROR_SUCCESS);
}


error_status_t
s_ApiChangeResourceGroup(
    IN HRES_RPC hResource,
    IN HGROUP_RPC hGroup
    )
/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    hResource - Supplies the resource to move.

    hGroup - Supplies the new group that the resource should be in.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE    Resource;
    PFM_GROUP       Group;
    DWORD           Status;
    
    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_GROUP_EXISTS(Group, hGroup);


    //
    // Call the FM to do the real work. 
    //
    Status = FmChangeResourceGroup(Resource, Group);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

FnExit:
    return(Status);
}

/****
@func       error_status_t | s_ApiCreateResTypeEnum | Enumerates the list of 
            nodes in which the resource type can be supported and 
            returns the list of nodes to the caller. The client-side 
            is responsible for freeing the allocated memory.

@parm       IN handle_t | IDL_handle | RPC binding handle, not used.
@parm       IN LPCWSTR  | lpszTypeName | Name of the resource type.
@parm       IN DWORD | dwType | Supplies the type of properties 
            to be enumerated.
@parm       OUT PNM_NODE | ReturnEnum | Returns the requested objects.

@comm       This routine helps enumerating all the nodes that a particular
            resource type can be supported on.

@rdesc      ERROR_SUCCESS on success. Win32 error code otherwise.

@xref       
****/
error_status_t
s_ApiCreateResTypeEnum(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszTypeName,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )
{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    DWORD i;
    DWORD Result;
    PFM_RESTYPE  pResType = NULL;
    PNM_NODE     pNode;
    LPWSTR       RealName = NULL;

    pResType = OmReferenceObjectById(ObjectTypeResType, 
                                    lpszTypeName);

    if (dwType & ~CLUSTER_RESOURCE_TYPE_ENUM_ALL) {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }
                                    
    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    
    if (pResType == NULL) {
        //
        // The object cannot be found in the list !
        //
        Status = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        goto ErrorExit;
    }

    Enum->EntryCount = 0;

    //
    // Enumerate all possible nodes
    //
    if (dwType & CLUSTER_RESOURCE_TYPE_ENUM_NODES) {
        i=0;
        do {
            Result = FmEnumResourceTypeNode(pResType,
                                            i,
                                            &pNode);
            if (Result == ERROR_SUCCESS) {
                RealName = (LPWSTR)OmObjectName( pNode );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_TYPE_ENUM_NODES);
                }
                OmDereferenceObject( pNode );
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    *ReturnEnum = Enum;
    OmDereferenceObject( pResType );
    return(ERROR_SUCCESS);

ErrorExit:
    if (pResType != NULL) {
        OmDereferenceObject( pResType );
    }
    if (Enum != NULL) {
        MIDL_user_free(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\api\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Server side support for Cluster registry database APIs

Author:

    John Vert (jvert) 8-Mar-1996

Revision History:

--*/
#include "apip.h"


PAPI_HANDLE
ApipMakeKeyHandle(
    IN HDMKEY Key
    )
/*++

Routine Description:

    Allocates and initializes an API_HANDLE structure for the
    specified HDMKEY.

Arguments:

    Key - Supplies the HDMKEY.

Return Value:

    A pointer to the initialized API_HANDLE structure on success.

    NULL on memory allocation failure.

--*/

{
    PAPI_HANDLE Handle;

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        return(NULL);
    }
    Handle->Type = API_KEY_HANDLE;
    Handle->Flags = 0;
    Handle->Key = Key;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);

}


HKEY_RPC
s_ApiGetRootKey(
    IN handle_t IDL_handle,
    IN DWORD samDesired,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens the registry key at the root of the cluster registry database

Arguments:

    IDL_handle - Supplies RPC binding handle, not used.

    samDesired - Supplies requested security access

    Status - Returns error code, if any.

Return Value:

    A handle to the opened registry key.

--*/

{
    DWORD Error;
    HDMKEY Key;
    PAPI_HANDLE Handle=NULL;

    *Status = RpcImpersonateClient(NULL);
    if (*Status != RPC_S_OK)
    {
        goto FnExit;
    }
    Key = DmGetRootKey(samDesired);
    RpcRevertToSelf();
    if (Key == NULL) {
        *Status = GetLastError();
    } else {
        Handle = ApipMakeKeyHandle(Key);
        if (Handle == NULL) {
            DmCloseKey(Key);
            *Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *Status = ERROR_SUCCESS;
        }
    }
FnExit:    
    return(Handle);
}


HKEY_RPC
s_ApiCreateKey(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN PRPC_SECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT LPDWORD lpdwDisposition,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Creates a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, it is created on all nodes in
    the cluster.

Arguments:

    hKey - Supplies the key that the create is relative to.

    lpSubKey - Supplies the key name relative to hKey

    dwOptions - Supplies any registry option flags. The only currently
        supported option is REG_OPTION_VOLATILE

    samDesired - Supplies desired security access mask

    lpSecurityAttributes - Supplies security for the newly created key.

    Disposition - Returns whether the key was opened (REG_OPENED_EXISTING_KEY)
        or created (REG_CREATED_NEW_KEY)

    Status - Returns the error code if the function is unsuccessful.

Return Value:

    A handle to the specified key if successful

    NULL otherwise.

--*/

{
    HDMKEY NewKey;
    PAPI_HANDLE Handle = NULL;
    PAPI_HANDLE RootHandle = NULL;

    if (hKey != NULL) {
        RootHandle = (PAPI_HANDLE)hKey;
        if (RootHandle->Type != API_KEY_HANDLE) {
            *Status = ERROR_INVALID_HANDLE;
            return(NULL);
        }
    }

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    *Status = RpcImpersonateClient(NULL);
    if (*Status != RPC_S_OK)
    {
        return(NULL);
    }

    if ( ARGUMENT_PRESENT( lpSecurityAttributes ) &&
         (lpSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor != NULL) &&
         !RtlValidRelativeSecurityDescriptor( lpSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor,
          lpSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor,
          0 ) ) {
            *Status = ERROR_INVALID_SECURITY_DESCR;
            goto FnExit;
    }

    NewKey = DmCreateKey(hKey ? RootHandle->Key : NULL,
                         lpSubKey,
                         dwOptions,
                         samDesired,
                         ARGUMENT_PRESENT(lpSecurityAttributes)
                              ? lpSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor
                              : NULL,
                         lpdwDisposition);
    if (NewKey == NULL) {
        *Status = GetLastError();
    } else {
        Handle = ApipMakeKeyHandle(NewKey);
        if (Handle == NULL) {
            DmCloseKey(NewKey);
            *Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *Status = ERROR_SUCCESS;
        }
    }

FnExit:
    RpcRevertToSelf();
    return(Handle);
}


HKEY_RPC
s_ApiOpenKey(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, the call fails.

Arguments:

    hKey - Supplies the key that the open is relative to.

    lpSubKey - Supplies the key name relative to hKey

    samDesired - Supplies desired security access mask

    Status - Returns the error code if the function is unsuccessful.

Return Value:

    A handle to the specified key if successful

    NULL otherwise.

--*/

{
    HDMKEY NewKey;
    PAPI_HANDLE Handle=NULL;
    PAPI_HANDLE RootHandle;

    if (hKey != NULL) {
        RootHandle = (PAPI_HANDLE)hKey;
        if (RootHandle->Type != API_KEY_HANDLE) {
            *Status = ERROR_INVALID_HANDLE;
            return(NULL);
        }
    }


    *Status = RpcImpersonateClient(NULL);
    if (*Status != RPC_S_OK)
    {
        goto FnExit;
    }

    NewKey = DmOpenKey((hKey) ? RootHandle->Key : NULL,
                       lpSubKey,
                       samDesired);
    if (NewKey == NULL) {
        *Status = GetLastError();
    } else {
        Handle = ApipMakeKeyHandle(NewKey);
        if (Handle == NULL) {
            DmCloseKey(NewKey);
            *Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *Status = ERROR_SUCCESS;
        }
    }
    RpcRevertToSelf();
FnExit:    
    return(Handle);
}


error_status_t
s_ApiEnumKey(
    IN HKEY_RPC hKey,
    IN DWORD dwIndex,
    OUT LPWSTR *KeyName,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Enumerates the subkeys of a cluster registry key.

Arguments:

    hKey - Supplies the registry key for which the subkeys should
           be enumerated.

    dwIndex - Supplies the index to be enumerated.

    KeyName - Returns the name of the dwIndex subkey. The memory
           allocated for this buffer must be freed by the client.

    lpftLastWriteTime - Returns the last write time.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LONG Status;
    DWORD NameLength;
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);

    Status = DmQueryInfoKey(DmKey,
                            NULL,
                            &NameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    NameLength += 1;

    *KeyName = MIDL_user_allocate(NameLength*sizeof(WCHAR));
    if (*KeyName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = DmEnumKey(DmKey,
                       dwIndex,
                       *KeyName,
                       &NameLength,
                       lpftLastWriteTime);
    if (Status != ERROR_SUCCESS) {
        MIDL_user_free(*KeyName);
        *KeyName = NULL;
    }
    return(Status);
}


DWORD
s_ApiSetValue(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST UCHAR *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key.

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();

    return(DmSetValue(DmKey,
                      lpValueName,
                      dwType,
                      lpData,
                      cbData));
}


DWORD
s_ApiDeleteValue(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpValueName
    )

/*++

Routine Description:

    Removes the specified value from a given registry subkey

Arguments:

    hKey - Supplies the key whose value is to be deleted.

    lpValueName - Supplies the name of the value to be removed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();
    return(DmDeleteValue(DmKey, lpValueName));
}


error_status_t
s_ApiQueryValue(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpValueName,
    OUT LPDWORD lpValueType,
    OUT PUCHAR lpData,
    IN DWORD cbData,
    OUT LPDWORD lpcbRequired
    )

/*++

Routine Description:

    Queries a named value for the specified cluster registry subkey

Arguments:

    hKey - Supplies the subkey whose value should be queried

    lpValueName - Supplies the named value to be queried

    lpValueType - Returns the type of the value's data

    lpData - Returns the value's data

    cbData - Supplies the size (in bytes) of the lpData buffer
             Returns the number of bytes copied into the lpData buffer
             If lpData==NULL, cbData is set to the required buffer
             size and the function returns ERROR_SUCCESS

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    DWORD BuffSize;
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);

    BuffSize = cbData;
    Status = DmQueryValue(DmKey,
                          lpValueName,
                          lpValueType,
                          lpData,
                          &BuffSize);
    if ((Status == ERROR_SUCCESS) ||
        (Status == ERROR_MORE_DATA)) {
        *lpcbRequired = BuffSize;
    }

    return(Status);
}


DWORD
s_ApiDeleteKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();
    return(DmDeleteKey(DmKey, lpSubKey));
}


error_status_t
s_ApiEnumValue(
    IN HKEY_RPC hKey,
    IN DWORD dwIndex,
    OUT LPWSTR *lpValueName,
    OUT LPDWORD lpType,
    OUT UCHAR *lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD TotalSize
    )

/*++

Routine Description:

    Enumerates the specified value of a registry subkey

Arguments:

    hKey - Supplies the registry key handle

    dwIndex - Supplies the index of the value to be enumerated

    lpValueName - Returns the name of the dwIndex'th value. The
        memory for this name is allocated on the server and must
        be freed by the client side.

    lpType - Returns the value data type

    lpData - Returns the value data

    lpcbData - Returns the number of bytes written to the lpData buffer.

    TotalSize - Returns the size of the data

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LONG Status;
    DWORD OriginalNameLength;
    DWORD NameLength;
    DWORD DataLength;
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);

    Status = DmQueryInfoKey(DmKey,
                            NULL,
                            NULL,
                            NULL,
                            &NameLength,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    NameLength += 1;

    *lpValueName = MIDL_user_allocate(NameLength * sizeof(WCHAR));
    if (*lpValueName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *TotalSize = *lpcbData;

    //
    //  Chittur Subbaraman (chitturs) - 3/13/2001
    //
    //  First of all, at the beginning of this function, a big enough buffer for lpValueName
    //  is allocated. This means that ERROR_SUCCESS or ERROR_MORE_DATA will be returned by
    //  DmEnumValue depending ONLY on the size of the lpData buffer. This info is used by
    //  by the clusapi layer when it makes a decision based on the return code from this
    //  function.
    //
    //  Note that *TotalSize is initialized to *lpcbData just above. The TotalSize OUT variable 
    //  allows the required lpData size to be returned without touching lpcbData. This is 
    //  important since lpcbData is declared as the sizeof lpData in the IDL file and that is 
    //  what RPC will consider the lpData buffer size as. So, it is important that if the lpData
    //  buffer is not big enough, this function does not change the value of *lpcbData from what
    //  it was originally at IN time.
    //
    //  Strange behavior of RegEnumValue: If you supply a big enough buffer for lpValueName and
    //  a smaller than required buffer for lpData, then RegEnumValue won't bother to fill in
    //  lpValueName and will return ERROR_MORE_DATA. This irregular behavior is handled by
    //  DmEnumValue.
    //
    //  For reference pointers, RPC won't allow a client to pass in NULL pointers. That is why
    //  clusapi layer uses dummy variables in case some of the parameters passed in by the
    //  client caller is NULL.
    //
    //
    //  Behavior of RegEnumValue (assuming lpValueName buffer is big enough):
    //      (1) If lpData = NULL and lpcbData = NULL, then returns ERROR_SUCCESS.
    //      (2) If lpData = NULL and lpcbData != NULL, then returns ERROR_SUCCESS and sets
    //          *lpcbData to total buffer size required.
    //      (3) If lpData != NULL and lpcbData != NULL, but the data buffer size is smaller than
    //          required size, then returns ERROR_MORE_DATA and sets *lpcbData to the size required.
    //      (4) If lpData != NULL and lpcbData != NULL and the buffer is big enough, then returns
    //          ERROR_SUCCESS and sets *lpcbData to the size of the data copied into lpData.
    //
    //  OUR GOAL: ClusterRegEnumValue == RegEnumValue.
    //
    //  
    //  The following cases are handled by this function and the clusapi layer. Note that in this
    //  analysis, we assume that the client has called into clusapi with a big enough lpValueName
    //  buffer size. (If this is not true, then clusapi layer handles that, check ClusterRegEnumValue.)
    //
    //  Case 1: Client passes in lpData=NULL, lpcbData=NULL to ClusterRegEnumValue.
    //
    //      In this case, the clusapi layer will point both lpData and lpcbData to local dummy
    //      variables and initialize *lpcbData to 0. Thus, s_ApiEnumValue will see 
    //      both lpData and lpcbData as valid pointers. If the data value is bigger than the size of
    //      *lpcbData, then DmEnumValue will return ERROR_MORE_DATA. In this case, *TotalSize will
    //      contain the required buffer size and *lpcbData will be untouched. The client detects this 
    //      error code and sets the return status to ERROR_SUCCESS and *lpcbData to *TotalSize. Note
    //      that the 2nd action has less relevance since lpcbData is pointing to a local dummy variable.
    //      If the data value is of zero size, DmEnumValue will return ERROR_SUCCESS. 
    //      In such a case, *lpcbData will be set to *TotalSize before returning by this function. 
    //      Note that since the data size is 0, DmEnumValue would set *TotalSize to 0 and hence 
    //      *lpcbData will also be set to 0. Thus, in this case, when ApiEnumValue returns to the 
    //      clusapi layer, lpValueName will be filled in, *lpData will not be changed and *lpcbData 
    //      will be set to 0.
    //
    //  Case 2: Client passes in lpData=NULL, lpcbData!=NULL and *lpcbData=0 to ClusterRegEnumValue.
    //
    //      In this case, lpData alone will be pointing to a dummy clusapi buffer when ApiEnumValue
    //      is invoked. Thus, s_ApiEnumValue will get both lpData and lpcbData as valid pointers.
    //      If the data size is non-zero, then DmEnumValue will return ERROR_MORE_DATA and
    //      *TotalSize will contain the size of the required buffer. When this function returns,
    //      *lpcbData will remain untouched. As in case 1, the clusapi layer will set status
    //      to ERROR_SUCCESS and *lpcbData to *TotalSize. Thus, the client will see the required
    //      buffer size in *lpcbData. If the data size is zero, then it is handled as in case 1.
    //
    //  Case 3: Client passes in lpData!=NULL, lpcbData!=NULL, but the data buffer size is smaller than
    //      required.
    //
    //      In this case, both lpData and lpcbData will be pointing to client buffers (or RPC buffers
    //      representing them) at the entry to s_ApiEnumValue. DmEnumValue will return ERROR_MORE_DATA
    //      and this function will return the size required in *TotalSize. *lpcbData will not be
    //      touched. At the clusapi layer, *lpcbData will be set to *TotalSize and ERROR_MORE_DATA
    //      will be returned to the client.
    //      
    //  Case 4: Client passes in lpData!=NULL, lpcbData!=NULL and the data buffer size is big enough.
    //
    //      In this case, as in case 3, s_ApiEnumValue will have lpData and lpcbData pointing to 
    //      client buffers. DmEnumValue will return ERROR_SUCCESS, data copied to lpData and 
    //      *lpcbData will be set to *TotalSize (which is the size of the data copied into the 
    //      lpData buffer), before returning. The clusapi layer will return these values to the client.
    //
    Status = DmEnumValue(DmKey,
                         dwIndex,
                         *lpValueName,
                         &NameLength,
                         lpType,
                         lpData,
                         TotalSize);

    if (Status == ERROR_MORE_DATA) {
        return(Status);
    } else if (Status != ERROR_SUCCESS) {
        MIDL_user_free(*lpValueName);
        *lpValueName = NULL;
        *lpcbData = 0;
    } else {
        // This tells RPC how big the lpData buffer
        // is so it can copy the buffer to the client.
        *lpcbData = *TotalSize;
    }
    return(Status);
}


error_status_t
s_ApiQueryInfoKey(
    IN  HKEY_RPC hKey,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )
/*++

Routine Description:

    Retrieves information about a specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key.

    lpcSubKeys - Points to a variable that receives the number of subkeys
        contained by the specified key.

    lpcbMaxSubKeyLen - Points to a variable that receives the length, in
        characters, of the key's subkey with the longest name.
        The count returned does not include the terminating null character.

    lpcValues - Points to a variable that receives the number of values
        associated with the key.

    lpcbMaxValueNameLen - Points to a variable that receives the length,
        in characters, of the key's longest value name. The count
        returned does not include the terminating null character.

    lpcbMaxValueLen - Points to a variable that receives the length, in
        bytes, of the longest data component among the key's values.

    lpcbSecurityDescriptor - Points to a variable that receives the length,
        in bytes, of the key's security descriptor.

    lpftLastWriteTime - Pointer to a FILETIME structure.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY DmKey;
    DWORD Status;

    VALIDATE_KEY(DmKey, hKey);

    Status = DmQueryInfoKey(DmKey,
                            lpcSubKeys,
                            lpcbMaxSubKeyLen,
                            lpcValues,
                            lpcbMaxValueNameLen,
                            lpcbMaxValueLen,
                            lpcbSecurityDescriptor,
                            lpftLastWriteTime);
    return(Status);
}


error_status_t
s_ApiCloseKey(
    IN OUT HKEY_RPC *pKey
    )

/*++

Routine Description:

    Closes a cluster registry key

Arguments:

    pKey - Supplies the key to be closed
           Returns NULL

Return Value:

    None.

--*/

{
    HDMKEY DmKey;
    DWORD Status;

    VALIDATE_KEY(DmKey, *pKey);

    Status = RpcImpersonateClient(NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    Status = DmCloseKey(DmKey);
    RpcRevertToSelf();

    LocalFree(*pKey);
    *pKey = NULL;

    return(Status);
}


void
HKEY_RPC_rundown(
    IN HKEY_RPC Key
    )

/*++

Routine Description:

    RPC rundown routine for cluster registry keys

Arguments:

    Key - Supplies the handle to be rundown

Return Value:

    None.

--*/

{
    HDMKEY DmKey;

    //this should not call impersonate client

    if (((PAPI_HANDLE)(Key))->Type == API_KEY_HANDLE) 
    {
        DmKey = ((PAPI_HANDLE)(Key))->Key;                   \
        DmCloseKey(DmKey);
        LocalFree(Key);

    }

}


DWORD
s_ApiSetKeySecurity(
    IN HKEY hKey,
    IN DWORD SecurityInformation,
    IN PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    Sets the security on the specified registry key.

Arguments:

    hKey - Supplies a handle to a currently open key.

    SecurityInformation - Supplies the type of security information to
        be set.

    pRpcSecurityDescriptor - Supplies the security information

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;
    DWORD Status;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();

    pSecurityDescriptor = pRpcSecurityDescriptor->lpSecurityDescriptor;
    if (!RtlValidRelativeSecurityDescriptor( pSecurityDescriptor,
          pRpcSecurityDescriptor->cbInSecurityDescriptor,0)){
        return(ERROR_INVALID_PARAMETER);
    }
    Status = RpcImpersonateClient(NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    Status = DmSetKeySecurity(DmKey, SecurityInformation, pSecurityDescriptor);
    RpcRevertToSelf();
    return(Status);
}


DWORD
s_ApiGetKeySecurity(
    IN HKEY hKey,
    IN DWORD SecurityInformation,
    IN PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    Gets the security from the specified registry key.

Arguments:

    hKey - Supplies a handle to a currently open key.

    SecurityInformation - Supplies the type of security information to
        be retrieved.

    pRpcSecurityDescriptor - Returns the security information

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;
    DWORD cbLength;
    DWORD Status;
    PSECURITY_DESCRIPTOR    lpSD;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();

    cbLength = pRpcSecurityDescriptor->cbInSecurityDescriptor;
    lpSD = LocalAlloc(LMEM_FIXED, cbLength);
    if (lpSD == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Status = RpcImpersonateClient(NULL);
    if (Status != ERROR_SUCCESS) {
        LocalFree(lpSD);
        return(Status);
    }
    Status = DmGetKeySecurity(DmKey, SecurityInformation, lpSD, &cbLength);
    RpcRevertToSelf();
    if (Status == ERROR_SUCCESS) {
        Status = MapSDToRpcSD(lpSD, pRpcSecurityDescriptor);
    }
    if (Status != ERROR_SUCCESS) {
        pRpcSecurityDescriptor->cbInSecurityDescriptor = cbLength;
        pRpcSecurityDescriptor->cbOutSecurityDescriptor = 0;
    }

    LocalFree(lpSD);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\cpp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cpp.h

Abstract:

    Private data structures and procedure prototypes for the
    Checkpoint Manager (CP) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_CP

//global data relating to the quorum resource
#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION gQuoLock;
#else
    extern RTL_RESOURCE     gQuoLock;
#endif    

//
// Local function prototypes
//
typedef struct _CP_CALLBACK_CONTEXT {
    PFM_RESOURCE Resource;
    LPCWSTR lpszPathName;
    BOOL    IsChangeFileAttribute;
} CP_CALLBACK_CONTEXT, *PCP_CALLBACK_CONTEXT;

DWORD
CppReadCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CppWriteCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CppGetCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId,
    OUT OPTIONAL LPWSTR *pDirectoryName,
    OUT LPWSTR *pFileName,
    IN OPTIONAL LPCWSTR lpszQuorumDir,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CppCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HKEY hKey,
    IN DWORD dwId,
    IN LPCWSTR KeyName
    );

//
// Crypto key checkpoint interfaces
//
DWORD
CpckReplicateCryptoKeys(
    IN PFM_RESOURCE Resource
    );

BOOL
CpckRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );

//
// Registry watcher interfaces
//
DWORD
CppWatchRegistry(
    IN PFM_RESOURCE Resource
    );

DWORD
CppUnWatchRegistry(
    IN PFM_RESOURCE Resource
    );

DWORD
CppRegisterNotify(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR lpszKeyName,
    IN DWORD dwId
    );

DWORD
CppRundownCheckpoints(
    IN PFM_RESOURCE Resource
    );

DWORD
CppRundownCheckpointById(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId
    );

DWORD
CppInstallDatabase(
    IN HKEY hKey,
    IN LPWSTR   FileName
    );


BOOL
CppRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );


DWORD CppDeleteCheckpointFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD
CpckDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR  lpszQuorumPath
    );
    
DWORD CppDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD CpckDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD
CpckDeleteCryptoFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

error_status_t
CppDepositCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData,
    BOOLEAN fCryptoCheckpoint
    );

error_status_t
CppRetrieveCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BOOLEAN fCryptoCheckpoint,
    BYTE_PIPE CheckpointData
    );

error_status_t
CppDeleteCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath,
    BOOL        fCryptoCheckpoint
    );

BOOL
CppIsQuorumVolumeOffline(
    VOID
    );

extern CRITICAL_SECTION CppNotifyLock;
extern LIST_ENTRY CpNotifyListHead;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\cp\notify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Registry notification processor for registry checkpoints.

    This is a fairly gnarly bit of code. Each resource can have multiple
    registry subtree notifications associated with it. Each active notification
    has an associated Registry Notify Block (RNB) chained off the FM_RESOURCE
    structure. A single registry notification thread can handle max 31 RNBs
    This is because WaitForMultipleObjects maxes out at 64 objects and each RNB
    takes two wait slots.

    When an RNB is created, an available notify thread is found (or created if
    there are none). Then the notify thread is woken up with its command event
    to insert the RNB into its array of wait events.

    Once a notification occurs, the notify thread sets the RNB to "pending" and
    sets its associated timer to go off in a few seconds. If another registry
    notification occurs, the timer is reset. Thus, the timer will not actually
    go off until there have been no registry notifications for a few seconds.

    When the RNB timer fires, the notify thread checkpoints its subtree and
    puts it back on the queue. If the notify thread is asked to remove a RNB
    that is in the "pending" state, it cancels the timer, checkpoints the registry,
    and removes the RNB from its list.

Author:

    John Vert (jvert) 1/17/1997

Revision History:

--*/
#include "cpp.h"

CRITICAL_SECTION CppNotifyLock;
LIST_ENTRY CpNotifyListHead;

#define MAX_BLOCKS_PER_GROUP ((MAXIMUM_WAIT_OBJECTS-1)/2)
#define LAZY_CHECKPOINT 3               // checkpoint 3 seconds after last update

typedef struct _RNB {
    struct _RNB *Next;
    BOOL Pending;
    PFM_RESOURCE Resource;
    LPWSTR KeyName;
    DWORD dwId;
    HKEY hKey;
    HANDLE hEvent;
    HANDLE hTimer;
    struct _NOTIFY_GROUP *NotifyGroup;
    DWORD NotifySlot;
} RNB, *PRNB;

typedef enum {
    NotifyAddRNB,
    NotifyRemoveRNB
} NOTIFY_COMMAND;

typedef struct _NOTIFY_GROUP {
    LIST_ENTRY      ListEntry;           // Linkage onto CpNotifyListHead;
    HANDLE          hCommandEvent;
    HANDLE          hCommandComplete;
    HANDLE          hThread;
    NOTIFY_COMMAND  Command;
    ULONG_PTR       CommandContext;
    DWORD           BlockCount;
    HANDLE          WaitArray[MAXIMUM_WAIT_OBJECTS];
    PRNB            NotifyBlock[MAXIMUM_WAIT_OBJECTS-1];
} NOTIFY_GROUP, *PNOTIFY_GROUP;

//
// Local function prototypes
//
DWORD
CppRegNotifyThread(
    IN PNOTIFY_GROUP Group
    );

DWORD
CppNotifyCheckpoint(
    IN PRNB Rnb
    );


DWORD
CppRegisterNotify(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR lpszKeyName,
    IN DWORD dwId
    )
/*++

Routine Description:

    Creates a registry notification block for the specified resource.

Arguments:

    Resource - Supplies the resource the notification is for.

    KeyName - Supplies the registry subtree (relative to HKEY_LOCAL_MACHINE

    CheckpointId - Supplies the checkpoint ID.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PLIST_ENTRY ListEntry;
    PNOTIFY_GROUP Group;
    PNOTIFY_GROUP CurrentGroup;
    PRNB Block;

    Block = CsAlloc(sizeof(RNB));
    Block->Resource = Resource;
    Block->KeyName = CsStrDup(lpszKeyName);
    Block->dwId = dwId;
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         lpszKeyName,
                         &Block->hKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppRegisterNotify failed to open key %1!ws! error %2!d!\n",
                   lpszKeyName,
                   Status);
        return(Status);
    }
    Block->hTimer = CreateWaitableTimer(NULL,FALSE,NULL);
    CL_ASSERT(Block->hTimer != NULL);
    Block->hEvent = CreateEventW(NULL,TRUE,FALSE,NULL);
    CL_ASSERT(Block->hEvent != NULL);
    Block->Pending = FALSE;

    //
    // Get the lock
    //
    EnterCriticalSection(&CppNotifyLock);

    //
    // Find a group with space for this notify block
    //
    Group = NULL;
    ListEntry = CpNotifyListHead.Flink;
    while (ListEntry != &CpNotifyListHead) {
        CurrentGroup = CONTAINING_RECORD(ListEntry,
                                         NOTIFY_GROUP,
                                         ListEntry);
        ListEntry = ListEntry->Flink;
        if (CurrentGroup->BlockCount < MAX_BLOCKS_PER_GROUP) {
            //
            // Found a group.
            //
            Group = CurrentGroup;
            break;
        }
    }
    if (Group == NULL) {
        DWORD ThreadId;
        HANDLE hThread;

        //
        // Need to spin up a new group
        //
        Group = CsAlloc(sizeof(NOTIFY_GROUP));
        ZeroMemory(Group, sizeof(NOTIFY_GROUP));
        Group->hCommandEvent = CreateEventW(NULL,FALSE,FALSE,NULL);
        if ( Group->hCommandEvent == NULL ) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        }
        Group->hCommandComplete = CreateEventW(NULL,FALSE,FALSE,NULL);
        if ( Group->hCommandComplete == NULL ) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        }
        hThread = CreateThread(NULL,
                               0,
                               CppRegNotifyThread,
                               Group,
                               0,
                               &ThreadId);
        if (hThread == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppRegisterNotify failed to create new notify thread %1!d!\n",
                       Status);
            LocalFree(Group);
            goto error_exit2;
        }
        Group->hThread = hThread;
        InsertHeadList(&CpNotifyListHead, &Group->ListEntry);
    }

    //
    // Wake up the notify thread to insert the RNB for us.
    //
    Block->NotifyGroup = Group;
    Group->Command = NotifyAddRNB;
    Group->CommandContext = (ULONG_PTR)Block;
    SetEvent(Group->hCommandEvent);
    WaitForSingleObject(Group->hCommandComplete, INFINITE);

    Block->Next = (PRNB)Resource->CheckpointState;
    Resource->CheckpointState = Block;

    LeaveCriticalSection(&CppNotifyLock);
    return(ERROR_SUCCESS);

error_exit2:
    LeaveCriticalSection(&CppNotifyLock);
    RegCloseKey(Block->hKey);
    CloseHandle(Block->hTimer);
    CloseHandle(Block->hEvent);
    CsFree(Block->KeyName);
    CsFree(Block);
    return(Status);
}


DWORD
CppRegNotifyThread(
    IN PNOTIFY_GROUP Group
    )
/*++

Routine Description:

    Worker thread that handles multiple registry notification subtrees.

Arguments:

    Group - Supplies the NOTIFY_GROUP control structure owned by this thread.

Return Value:

    None.

--*/

{
    PRNB Rnb;
    DWORD Signalled;
    DWORD Index;
    BOOL Success;
    DWORD Slot;
    DWORD Status;

    Group->BlockCount = 0;
    Group->WaitArray[0] = Group->hCommandEvent;
    do {
        Signalled = WaitForMultipleObjects(Group->BlockCount*2 + 1,
                                           Group->WaitArray,
                                           FALSE,
                                           INFINITE);
        if (Signalled == Group->BlockCount*2) {
            switch (Group->Command) {
                case NotifyAddRNB:
                    //
                    // Add this notify block to our list.
                    //
                    CL_ASSERT(Group->BlockCount < MAX_BLOCKS_PER_GROUP);
                    Rnb = (PRNB)Group->CommandContext;

                    Status = RegNotifyChangeKeyValue(Rnb->hKey,
                                 TRUE,
                                 REG_LEGAL_CHANGE_FILTER,
                                 Rnb->hEvent,
                                 TRUE);
                    if (Status != ERROR_SUCCESS) {
                        CL_UNEXPECTED_ERROR(Status);
                    }

                    Index = Group->BlockCount*2;
                    Group->WaitArray[Index] = Rnb->hEvent;
                    Group->WaitArray[Index+1] = Rnb->hTimer;
                    Rnb->NotifySlot = Group->BlockCount;
                    Group->NotifyBlock[Rnb->NotifySlot] = Rnb;
                    ++Group->BlockCount;
                    Group->WaitArray[Group->BlockCount*2] = Group->hCommandEvent;
                    break;

                case NotifyRemoveRNB:
                    Rnb = (PRNB)Group->CommandContext;

                    //
                    // Check to see if the RNB is pending. If so, checkpoint it
                    // now before we remove it.
                    //
                    if (Rnb->Pending) {

                        DWORD   Count = 60;
                    
                        ClRtlLogPrint(LOG_NOISE,
                                   "[CP] CppRegNotifyThread checkpointing key %1!ws! to id %2!d! due to removal while pending\n",
                                   Rnb->KeyName,
                                   Rnb->dwId);
RetryCheckpoint:                                   
                        Status = CppNotifyCheckpoint(Rnb);
                        if (Status != ERROR_SUCCESS)
                        {
                            WCHAR  string[16];



                            ClRtlLogPrint(LOG_CRITICAL,
                                   "[CP] CppRegNotifyThread, CppNotifyCheckpoint failed with Status=%1!u!\n",
                                   Status);
                            if ((Status == ERROR_ACCESS_DENIED) ||
                                (Status == ERROR_INVALID_FUNCTION) ||
                                (Status == ERROR_NOT_READY) ||
                                (Status == RPC_X_INVALID_PIPE_OPERATION) ||
                                (Status == ERROR_BUSY) ||
                                (Status == ERROR_SWAPERROR))
                            {
                                //SS: we should retry forever??
                                //SS: Since we allow the quorum to come
                                //offline after 30 seconds of waiting on 
                                //pending resources, the checkpointing should
                                //be able to succeed
                                if (Count--)
                                {
                                    Sleep(1000);
                                    goto RetryCheckpoint;
                                }                                    
                            }
#if DBG
                            if (IsDebuggerPresent())
                                DebugBreak();
#endif                                
                            wsprintfW(&(string[0]), L"%u", Status);
                            CL_LOGCLUSERROR2(CP_SAVE_REGISTRY_FAILURE, Rnb->KeyName, string);
                        } 
                        // irrespective of the failure set pending to FALSE
                        Rnb->Pending = FALSE;
                    }

                    //
                    // Move everything down to take the previous RNB's slot.
                    //
                    Index = Rnb->NotifySlot * 2 ;
                    Group->BlockCount--;
                    for (Slot = Rnb->NotifySlot; Slot < Group->BlockCount; Slot++) {

                        Group->NotifyBlock[Slot] = Group->NotifyBlock[Slot+1];
                        Group->NotifyBlock[Slot]->NotifySlot--;
                        Group->WaitArray[Index] = Group->WaitArray[Index+2];
                        Group->WaitArray[Index+1] = Group->WaitArray[Index+3];
                        Index += 2;
                    }
                    Group->WaitArray[Index] = NULL;
                    Group->WaitArray[Index+1] = NULL;
                    Group->WaitArray[Index+2] = NULL;
                    Group->NotifyBlock[Group->BlockCount] = NULL;
                    Group->WaitArray[Group->BlockCount*2] = Group->hCommandEvent;
                    break;

                default:
                    CL_UNEXPECTED_ERROR( Group->Command );
                    break;
            }
            SetEvent(Group->hCommandComplete);
        } else {
            //
            // Either a registry notification or a timer has fired.
            // Process this.
            //
            Rnb = Group->NotifyBlock[(Signalled)/2];
            if (!(Signalled & 1)) {
                LARGE_INTEGER DueTime;
                //
                // This is a registry notification.
   